:source-highlighter: highlight.js
:icons: font
:home: https://elmprogramming.com/
:source: https://github.com/pawanpoudel/beginning-elm-code
:kroki-server-url: http://localhost:8000

[source,bash]
----
while read -r it
do
    name=${it##*/}
    tag=${name%.*}
    echo "[[$tag]] ==> $name" >> $0
    pandoc --wrap=preserve -tasciidoc $it >> $0
    exit
done << EOF
https://elmprogramming.com/introduction.html
https://elmprogramming.com/why-elm.html
https://elmprogramming.com/who-this-book-is-for.html
https://elmprogramming.com/conventions-used-in-the-book.html
https://elmprogramming.com/acknowledgements.html
https://elmprogramming.com/about-the-author.html
https://elmprogramming.com/getting-started-intro.html
https://elmprogramming.com/installation.html
https://elmprogramming.com/building-a-simple-page-in-elm.html
https://elmprogramming.com/elm-platform.html
https://elmprogramming.com/elm-language.html
https://elmprogramming.com/elm-compiler.html
https://elmprogramming.com/elm-architecture.html
https://elmprogramming.com/elm-runtime.html
https://elmprogramming.com/elm-make.html
https://elmprogramming.com/elm-install.html
https://elmprogramming.com/elm-reactor.html
https://elmprogramming.com/elm-repl.html
https://elmprogramming.com/ellie.html
https://elmprogramming.com/getting-started-conclusion.html
https://elmprogramming.com/elm-language-basics-intro.html
https://elmprogramming.com/simple-arithmetic.html
https://elmprogramming.com/boolean.html
https://elmprogramming.com/comparison.html
https://elmprogramming.com/comment.html
https://elmprogramming.com/expression.html
https://elmprogramming.com/value.html
https://elmprogramming.com/constant.html
https://elmprogramming.com/if-expression.html
https://elmprogramming.com/function.html
https://elmprogramming.com/let-expression.html
https://elmprogramming.com/case-expression.html
https://elmprogramming.com/indentation.html
https://elmprogramming.com/string.html
https://elmprogramming.com/regular-expression.html
https://elmprogramming.com/list.html
https://elmprogramming.com/array.html
https://elmprogramming.com/tuple.html
https://elmprogramming.com/record.html
https://elmprogramming.com/elm-lang-basics-conclusion.html
https://elmprogramming.com/benefits-of-elm-intro.html
https://elmprogramming.com/immutability.html
https://elmprogramming.com/pure-functions.html
https://elmprogramming.com/function-composition.html
https://elmprogramming.com/easy-to-test.html
https://elmprogramming.com/type-system.html
https://elmprogramming.com/easier-code-organization.html
https://elmprogramming.com/fuzz-testing.html
https://elmprogramming.com/pattern-matching.html
https://elmprogramming.com/benefits-of-elm-conclusion.html
https://elmprogramming.com/elm-architecture-intro.html
https://elmprogramming.com/model-view-update-part-1.html
https://elmprogramming.com/virtual-dom.html
https://elmprogramming.com/model-view-update-part-2.html
https://elmprogramming.com/side-effects.html
https://elmprogramming.com/commands.html
https://elmprogramming.com/elm-architecture-conclusion.html
https://elmprogramming.com/http-requests-intro.html
https://elmprogramming.com/fetching-data-using-get.html
https://elmprogramming.com/decoding-json-part-1.html
https://elmprogramming.com/decoding-json-part-2.html
https://elmprogramming.com/remote-data.html
https://elmprogramming.com/retrieving-data-on-initialization.html
https://elmprogramming.com/http-requests-conclusion.html
https://elmprogramming.com/single-page-apps-intro.html
https://elmprogramming.com/what-is-a-single-page-app.html
https://elmprogramming.com/restructuring-code.html
https://elmprogramming.com/creating-post-module.html
https://elmprogramming.com/creating-list-posts-page.html
https://elmprogramming.com/navigating-to-list-posts-page.html
https://elmprogramming.com/editing-a-post.html
https://elmprogramming.com/deleting-a-post.html
https://elmprogramming.com/creating-a-new-post.html
https://elmprogramming.com/single-page-apps-conclusion.html
https://elmprogramming.com/interact-with-javascript-intro.html
https://elmprogramming.com/sending-data-to-javascript.html
https://elmprogramming.com/subscriptions.html
https://elmprogramming.com/receiving-data-from-javascript.html
https://elmprogramming.com/protecting-boundaries.html
https://elmprogramming.com/saving-app-state.html
https://elmprogramming.com/retrieving-app-state.html
https://elmprogramming.com/interacting-with-web-components.html
https://elmprogramming.com/interact-with-javascript-conclusion.html
https://elmprogramming.com/where-to-go-from-here.html
EOF
exit
----

http://elmprogramming.com/[Beginning Elm]

https://twitter.com/elm_programming[twitter]
https://github.com/pawanpoudel[github]
https://twitter.com/share[Tweet]

== Beginning Elm

[.text-center.big]
*Beginning Elm* +
*A gentle introduction to Elm programming language* +
Pawan Poudel

=== Introduction

*_Get your feet wet with Elm_*


• _01_ <<introduction, *_Introduction_*>>
. <<why-elm, Why Elm?>>
. <<who-this-book-is-for, Who This Book is For>>
. <<conventions-used-in-the-book, Conventions Used in This Book>>
. <<acknowledgements, Acknowledgements>>
. <<about-the-author, About the Author>>

• _02_ <<getting-started-intro, *_Getting Started_*>>
. <<installation, Installation>>
. <<building-a-simple-page-in-elm, Building a Simple Web Page>>
. <<elm-platform, Elm Platform>>
. <<elm-language, Elm Programming Language>>
. <<elm-compiler, Elm Compiler>>
. <<elm-architecture, Elm Architecture>>
. <<elm-runtime, Elm Runtime>>
. <<elm-make, elm make>>
. <<elm-install, elm install>>
. <<elm-reactor, elm reactor>>
. <<elm-repl, elm repl>>
. <<ellie, Ellie>>
. <<getting-started-conclusion, Conclusion>>

''''''

=== Syntax & Semantics

*_Learn Elm from the ground up_*


• _03_ <<elm-language-basics-intro, *_Elm Language Basics_*>>
. <<simple-arithmetic, Simple Arithmetic>>
. <<boolean, Boolean>>
. <<comparison, Comparison>>
. <<comment, Comments>>
. <<expression, Expression>>
. <<value, Value>>
. <<constant, Constant>>
. <<if-expression, If Expression>>
. <<function, Function>>
. <<let-expression, Let Expression>>
. <<case-expression, Case Expression>>
. <<indentation, Indentation>>
. <<string, String>>
. <<regular-expression, Regular Expression>>
. <<list, List>>
. <<array, Array>>
. <<tuple, Tuple>>
. <<record, Record>>
. <<elm-lang-basics-conclusion, Conclusion>>

• _04_ <<benefits-of-elm-intro, *_Benefits of Using Elm_*>>
. <<immutability, Immutability>>
. <<pure-functions, Pure Functions>>
. <<function-composition, Solving Complex Problems with Simple Functions>>
. <<easy-to-test, Easy to Test>>
. <<type-system, Type System>>
. <<easier-code-organization, Easier Code Organization>>
. <<fuzz-testing, Fuzz Testing>>
. <<pattern-matching, Pattern Matching>>
. <<benefits-of-elm-conclusion, Conclusion>>

''''''

=== Architecture

*_Understand how the Elm Architecture helps us build robust front-end web applications_*


• 05 <<elm-architecture-intro, *_Elm Architecture_*>>
. <<model-view-update-part-1, Model View Update - Part 1>>
. <<virtual-dom, Virtual DOM>>
. <<model-view-update-part-2, Model View Update - Part 2>>
. <<side-effects, Side Effects>>
. <<commands, Commands>>
. <<elm-architecture-conclusion, Conclusion>>

• 06 <<http-requests-intro, *_HTTP Requests_*>>
. <<fetching-data-using-get, Fetching Data Using GET>>
. <<decoding-json-part-1, Decoding JSON - Part 1>>
. <<decoding-json-part-2, Decoding JSON - Part 2>>
. <<remote-data, RemoteData>>
. <<retrieving-data-on-initialization, Retrieving Data on Initialization>>
. <<http-requests-conclusion, Conclusion>>

• 07 <<single-page-apps-intro, *_Single-Page Apps_*>>
. <<what-is-a-single-page-app, What is a Single-Page App?>>
. <<restructuring-code, Restructuring Code>>
. <<creating-post-module, Creating Post Module>>
. <<creating-list-posts-page, Creating List Posts Page>>
. <<navigating-to-list-posts-page, Navigating to List Posts Page>>
. <<editing-a-post, Editing a Post>>
. <<deleting-a-post, Deleting a Post>>
. <<creating-a-new-post, Creating a New Post>>
. <<single-page-apps-conclusion, Conclusion>>

• 08 <<interact-with-javascript-intro, *_Interact with JavaScript_*>>
. <<sending-data-to-javascript, Sending Data to JavaScript>>
. <<subscriptions, Subscriptions>>
. <<receiving-data-from-javascript, Receiving Data from JavaScript>>
. <<protecting-boundaries, Protecting Boundaries between Elm and JavaScript>>
. <<saving-app-state, Saving App State in Local Storage>>
. <<retrieving-app-state, Retrieving App State from Local Storage>>
. <<interacting-with-web-components, Interacting with Web Components>>
. <<interact-with-javascript-conclusion, Conclusion>>
. <<where-to-go-from-here, Where To Go From Here?>>

Copyright © 2018 Pawan Poudel. All Rights Reserved.

[[introduction]]
== 1 Introduction

=== 1.1 prelude

Hi there! Thanks for stopping by. I hope you will find this book and other contents on the site (coming soon) helpful for learning Elm — a delightful programming language for building robust front-end web applications.

I first discovered Elm when I listened to a Functional Geekery podcast https://www.functionalgeekery.com/functional-geekery-episode-33-richard-feldman-and-tessa-kelly/[episode] featuring Richard Feldman and Tessa Kelly. When I heard Tessa mention that it’s almost impossible to have runtime errors in Elm, I was intrigued. None of the languages I have worked with during my fifteen years as a programmer offered such a guarantee, so I started experimenting with Elm. To my delight, I not only found Tessa’s claim to be true, but also really enjoyed writing code in Elm.

Although it’s been more than seven years since Elm was created, it hadn’t caught most front-end web developers’ attention until recently. More and more programmers are experimenting with the language and using it in production. They are also sharing what they have learned with the ever-growing community.

I, too, am constantly learning new things about Elm on a daily basis. This book is an attempt to distill my understanding of Elm thus far. I will continue to update the material in this book as I gain more insight into the language and Elm ecosystem in general.

With that, I would like to invite you to join me on a wonderful journey into learning a very friendly yet extremely practical language.

[[why-elm]]
=== 1.2 Why Elm?

****
*Quote:* _“We want to do our best work, and we want the work we do to have meaning. And, all else being equal, we prefer to enjoy ourselves along the way.” - Sandi Metz_
****

As programmers, we pride ourselves in building easy-to-use and robust software programs for solving the thorniest of problems our users face. However, building good software that not only solves today’s problems, but also adapts well to the future requirements, is hard. Really hard. This difficulty isn’t due to lack of tools that enable us to ship highly maintainable programs. For example, the programming languages in the https://en.wikipedia.org/wiki/ML_(programming_language)[ML family] such as https://www.haskell.org/[Haskell] and http://www.ocaml.org/[OCaml] are well known for making it almost impossible to cause errors in production. The compilers for these languages catch almost all errors that plague programs built using other languages that are not as strict.

It stands to reason that all programmers should then be using languages from the ML family. After all, who doesn’t want to build programs that are error free? The reality actually is quite the opposite. Take a look at the results from a survey conducted by Stack Overflow in 2019 for the most popular web frameworks used by programmers.

// image:https://elmprogramming.com/images/chapter-1/1.2-why-elm/most-popular-languages.png[]
****
[tikz,role=text-center]
----
%\documentclass{standalone}
\usepackage{tikz}
\begin{document}
   
\begin{tikzpicture}[very thick,top color=white,bottom color=gray]
    \draw [line width=8pt,draw=blue!20,align=right,minimum width=5]
    (0,1) -- (0.5*48.7,1) node at (22,1) {\LARGE jQuery 48.7\%} 
    (0,2) -- (0.5*31.3,2) node at (22,2) {\LARGE React.js 31.3\%} 
    (0,3) -- (0.5*30.7,3) node at (22,3) {\LARGE Angular/Angular.js 30.7\%} 
    (0,4) -- (0.5*26.3,4) node at (22,4) {\LARGE ASP.NET 26.3\%} 
    (0,5) -- (0.5*19.7,5) node at (22,5) {\LARGE Express 19.7\%} 
    (0,6) -- (0.5*16.2,6) node at (22,6) {\LARGE Spring 16.2\%} 
    (0,7) -- (0.5*15.2,7) node at (22,7) {\LARGE Vue.js 15.2\%} 
    (0,8) -- (0.5*13.0,8) node at (22,8) {\LARGE Django 13.0\%} 
    (0,9) -- (0.5*12.1,9) node at (22,9) {\LARGE Flask 12.1\%} 
    (0,10)-- (0.5*10.5,10)node at (22,10){\LARGE Laravel 10.5\%} 
    (0,11)-- (0.5*8.2,11) node at (22,11){\LARGE Ruby on Rails 8.2\%} 
    (0,12)-- (0.5*3.5,12) node at (22,12){\LARGE Drupal 3.5\%}; 
\end{tikzpicture}

\end{document}
----
****


https://insights.stackoverflow.com/survey/2019#technology-_-web-frameworks[Source: Stack Overflow Developer Survey Results 2019]

The three most popular web frameworks — jQuery, React.js, and Angular — all use JavaScript. None of the languages from the ML family are in the list. Programmers are a smart bunch. Why then are they using languages such as JavaScript that have no built-in safeguards to prevent errors from happening in production?

One reason could be because the languages from the ML family are more suitable for building back-end systems. Front-end programmers are responsible for the code that runs in the client (typically, a web browser), as opposed to the server. Because web browsers only understand JavaScript, that makes it hard to use other languages. However, there have been multiple efforts to bring the robustness from the ML family languages to front-end development with projects such as https://github.com/faylang/fay[Fay] and https://github.com/ghcjs/ghcjs[GHCJS] that compile to JavaScript a web browser can understand. Yet the front-end programmers don’t seem to want to use them.

Another reason could be because the languages from the ML family are hard to use. They are notorious for having a steep learning curve. In contrast, someone who has experience in HTML and CSS can learn how to add JavaScript functionality to their web page in a matter of hours. JavaScript is easy to get started with and thus highly usable. However, large programs written in it can be a nightmare to maintain. Programmers tend to write mountain of tests to prevent JavaScript programs from misbehaving in production. They also use elaborate architectural patterns to make adding new features to their apps less painful. What we need is a language that not only provides the robustness inherent in languages from the ML family, but also is highly usable like JavaScript. Elm is one such language.

// image:https://elmprogramming.com/images/chapter-1/1.2-why-elm/maintainability-usability.svg[]
.Language maintainability vs. usability
:kroki-server-url: http://localhost:8000

[tikz]
------
\documentclass[border=3pt,tikz]{standalone}
\usetikzlibrary{calc}
\pgfdeclarelayer{nodelayer}
\pgfdeclarelayer{edgelayer}
\pgfsetlayers{main,edgelayer,nodelayer}
\begin{document}
\tikzset{ none/.style={ align=center, draw=none,fill=none,text=black} }

% Node styles
\tikzset{dot/.style={fill=white, draw={rgb,255: red,132; green,132; blue,132}, shape=circle}}
\tikzset{box/.style={fill={rgb,255: red,186; green,186; blue,0}, draw={rgb,255: red,226; green,226; blue,226}, shape=rectangle, minimum height=1.15cm, minimum width=0.5cm}}
\tikzset{Circle/.style={fill=white, draw=black, shape=circle, align=center, inner sep=10pt}}

% Edge styles
\tikzset{thin edge arrow/.style={fill=none, draw={rgb,255: red,99; green,99; blue,99}, ->}}
\tikzset{thick edge/.style={-, fill={rgb,255: red,191; green,128; blue,64}, draw={rgb,255: red,63; green,59; blue,40}}}
\tikzset{dashed edge/.style={-, fill=none, draw={rgb,255: red,25; green,25; blue,25}, dashed}}
\tikzset{thin edge/.style={-}}
\tikzset{thick edge arrow/.style={->, line width=2pt, color=blue!40}}
\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (11, 0) {};
		\node [style=none] (2) at (0, 7) {};
		\node [style=Circle] (3) at (2.75, 5.5) {Haskell\\OCaml};
		\node [style=Circle] (4) at (7.25, 3.2) {Java\\C\#};
		\node [style=Circle] (5) at (10.75, 2.45) {Ruby\\Python\\JavaScript\\PHP};
		\node [style=Circle] (6) at (11.75, 6.25) {ELM};
		\draw node [style=none] (7) at ($(3.south)+(0,-12pt)$) {MLFamily languages};
		\draw node [style=none] (8) at ($(4.south)+(0,-12pt)$) {Statically typed\\Object-oriented languages};
		\draw node [style=none] (9) at ($(5.south)+(0,-12pt)$) {Dynamic language};
		\node [style=none] (10) at (5.25, -0.5) {Usable\\(speed from novice to product)};
		\node [style=none, align=right] (11) at (-2.5, 3.55) {Maintainable\\(ease of adding new feature)};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=thick edge arrow] (0.center) to (2.center);
		\draw [style=thick edge arrow] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}

\end{document}
------


https://www.youtube.com/watch?v=oYk8CKH7OhE[Source: User Focused Design in Elm]

Elm is a functional programming language for building front-end web applications. It brings the best of both worlds when it comes to building highly robust applications with ease. Besides maintainability and usability, Elm provides a plethora of benefits that are not present in most mainstream languages such as immutable values, stateless functions, type inference, pattern matching, automatic code formatting, and a great debugger. We will explore each of these concepts in detail in <<benefits-of-elm-intro, chapter 4>>.

Finally, Elm provides a novel architecture for organizing code which makes managing data flow between various components a breeze. Most other languages don’t come with one canonical way to organize code like this. We often have to compare and contrast multiple frameworks which is confusing and time consuming. Elm makes that decision for us so that we can just focus on solving the problem at hand and not worry about how easy our program will be to change in the future. We will cover the Elm Architecture in detail in <<elm-architecture-intro, chapter 5>>.


[[who-this-book-is-for]]
=== 1.3 Who This Book is For


This book assumes you have a basic understanding of programming, but no prior knowledge of Elm or functional programming is required. Nor do you need any mathematical background. If you have dabbled in a programming language before, you should have no trouble learning Elm with this book.

Listed below are a few additional things you need to have basic familiarity with to be able to follow along and fully understand the concepts presented in this book.

===== Command Line

If you have never used command line tools before, I recommend going through Michael Hartl’s friendly introductory https://www.learnenough.com/command-line-tutorial[tutorial] on the topic.

===== HTML and CSS

If you have never used HTML or CSS before, Jeremy Thomas has a great http://marksheet.io/[tutorial] for learning the basics.

==== How to read this book

I recommend reading this book in sequential order. Each chapter builds upon the chapter before it. I highly recommend that you try things out as you go through the book by typing each line of code into `+elm repl+` (which we will cover in <<elm-repl, Chapter 2>>) or your favorite source code editor. Execute the code to see what output you get. This is a very practical book. You won’t get the most out of it if you just read it passively.

==== Code Examples

All code examples from this book are publicly available from https://github.com/pawanpoudel/beginning-elm-code[this repo] on Github.


[[conventions-used-in-the-book]]
=== 1.4 Conventions Used in This Book


Most conventions used in the book should be self-explanatory. Listed below are some that might be a bit confusing.

==== Terminal

We will be using the term _terminal_ throughout the book to mean a program that lets you type and execute textual commands. If you come from Unix background, this term should already be familiar to you. But, if you come from Windows background, you can mentally replace it with _command prompt_.

****
NOTE: Unix refers to a family of operating systems that includes macOS and Linux.
****

==== Commands

This book presents many commands that are run from the terminal. For simplicity, all command examples use the `+$+` sign which is common in Unix-based systems. You can mentally replace it with `+>+` on Windows. Here is an example:

[source,bash]
----
$ elm --version
----

However, when we’re inside <<elm-repl, `+elm repl+`>>, the `+>+` sign is shown on both Unix and Windows systems to indicate that the code is meant to be entered into an `+elm repl+` session. Here is an example:

[source,elm]
----
> 1 + 2
3 : number
----

==== Vertical Pipes

When entering multi-line code, `+elm repl+` adds pipes (`+|+`) in-front of each line starting from the second line. You shouldn’t type these pipes literally. Here’s an example:

[source,elm]
----
> if velocity > 11.186 then \
|   "Godspeed" \
| else if speed == 7.67 then \
|   "Stay in orbit" \
| else \
|   "Come back"
"Stay in orbit"
----

==== Two Vertical Dots

Many code examples in the book include two vertical dots to omit a big chunk of code not relevant to the topic being discussed. You shouldn’t type these dots literally. Here are some examples:

[source,elm]
----
import Html exposing (text)
.
.

main =
    isEmpty list2
        |> toString
        |> text
----

[source,javascript]
----
{
    .
    .
    "source-directories": [
        ".",
        "elm-examples"
    ],
    .
    .
}
----

==== Three Horizontal Dots

Three horizontal dots are used to omit the body of a function. Again, you shouldn’t type them literally. Here is an example:

[source,elm]
----
list2 =
    MyList.Node 9 MyList.Empty


main =
    ...
----

==== Two Horizontal Dots

When importing a `module`, the two horizontal dots (`+..+`) have special meaning in Elm. You should definitely type them literally. Here’s an example:

[source,elm]
----
import Html exposing (..)
----

We will cover modules in detail in <<easier-code-organization, chapter 4>>.


[[acknowledgements]]

=== 1.5 Acknowledgements

I would like to thank Evan Czaplicki for creating a wonderful language that has made the process of building and maintaining complex web applications a joy. Thanks also to all members of the Elm community who have generously offered their time and resources to advance the Elm ecosystem.

I would also like to thank Jeremy Thomas for open sourcing the code behind his awesome http://marksheet.io/[Marksheet] site. The underlying framework he created has made it incredibly easy to organize the contents of this book.

I am very grateful to my friend Julianne DiLorenzo for her enormous help and encouragement throughout the process of writing this book. Without her thorough review and insightful critique, this book wouldn’t be half as good.

Finally, I would like to thank everyone who has kindly taken the time to read the book and provide valuable feedback. I couldn’t have finished this book without so many encouraging emails, tweets, and comments from you all. Thank you!


[[about-the-author]]
=== 1.6 About the Author

[.right]
image:https://elmprogramming.com/images/chapter-1/1.7-about-the-author/author-profile.jpg[]

Hi there, my name is Pawan Poudel. I have been coding for more than fifteen years. My first encounter with programming was with GW-BASIC when I was in eighth grade. However, it wasn’t until I discovered C in college that I really started to enjoy programming. Since then, I have built applications in C++, Java, C#, Objective-C, Swift, Python, Ruby, and JavaScript.

Before moving into web development, I spent more than five years honing my mobile development skills building iOS apps. Lately, I have been spending most of my free time learning functional programming languages, mainly Elm and Haskell.

I believe programming is an art and a science. Therefore, I have deep respect for both the theoretical and the practical applications of it. I feel just as comfortable hunting obscure UI bugs as I do implementing sophisticated algorithms. I feel happiest when I get to share what I have learned with fellow programmers like you. I have a masters degree in computer science from Miami University.


[[getting-started-intro]]
== 2 Getting Started

=== 2.1 prelude

In this chapter we will build a simple web page to get a sense of what it feels like to write Elm code. We will also look into what’s inside the _Elm Platform_ - a bundle of tools essential for building applications in Elm.


[[installation]]
=== 2.2 Installation


Before we get started, we need to install and configure a few tools essential for learning Elm.

[[installing-nodejs]]
==== Installing Node.js

Node.js is a JavaScript runtime environment for building mostly server-side applications.

Why Node.js?::
  This book is all about learning a language for building client-side applications. So why do we need to install Node.js? We need it for two reasons:
+
* <<elm-repl, elm-repl>> - a tool we will be using later to experiment with Elm - works by compiling the Elm code to JavaScript. Node.js provides an environment for running that JavaScript code.
+
* Node.js comes with a package manager called NPM (**N**ode.js **P**ackage **M**anager). Most tools and libraries for building front-end applications (including a few in Elm ecosystem) are distributed as NPM packages. Therefore, you need it in your arsenal to be a productive Elm programmer.

Follow the https://nodejs.org/en/download/[instructions] on the official site to install Node.js on your computer. Node.js comes with NPM, so you don’t need to download them separately. Once installed, run the following command from the terminal to verify that you have Node.js 7.0.0 or higher installed. It doesn’t matter which directory you run this command from.

[source,bash]
----
$ node --version
----

==== Installing Elm Platform

The Elm Platform bundles together most tools we need to work with Elm. Follow the https://guide.elm-lang.org/install.html[instructions] on the official site to install the Elm Platform on your computer. Once the installation is complete, run the following command from the terminal to verify that Elm is installed properly. It also doesn’t matter which directory you run this command from.

[source,bash]
----
$ elm --version
----

You should see the version number of the Elm Platform installed on your computer. We will be using the `+0.19.0+` version throughout this book unless mentioned otherwise.

==== Source Code Editor

This book will make you write a lot of code. Some of that code will be executed inside the terminal using <<elm-repl, elm-repl>>. Some will have to be saved in a file and compiled. Elm doesn’t come with a source code editor, so you are free to choose whatever you like. Out of the box, most editors don’t support features such as syntax highlighting and autocompletion that will significantly enhance the experience of writing Elm code. You will have to install a plugin for that. Select a plugin for your editor from the https://guide.elm-lang.org/install.html[Configure Your Editor] section in the official guide.

****
NOTE: Because tab characters are syntax errors in Elm, don’t forget to configure your editor to insert spaces when the tab key is pressed.
****

==== Installing `+elm-format+`

The <<elm-compiler, Elm compiler>> will accept any valid program, but the community at large prefers those programs to be written in a certain style. In most other languages, we need to remember what that style is and follow them diligently. Not only does this take up extra space in our brain, but also distracts us when we are in the middle of solving a problem.

https://github.com/avh4/elm-format[elm-format] tackles this issue by automatically formatting our code according to a set of rules standardized by the community. Although you don’t have to install `+elm-format+` to follow along, it’s highly recommend that you do.

*elm-format Release Status* ::
  As of this writing, `+elm-format+` is still in https://en.wikipedia.org/wiki/Software_release_life_cycle#Beta[beta]. Don’t be surprised if the current format of your program looks different from the one 1.0.0 version of `+elm-format+` produces in the future. Despite its beta status, most community members are already using it, so you should be fine using it too. All code in this book that is meant to be saved in a file has been formatted using `+elm-format+`.

Installing `+elm-format+` is quite easy. Just run the following command from any directory in the terminal.

[source,bash]
----
$ npm install elm-format -g
----

The `+-g+` option above installs the package _globally_ so that we can use the `+elm-format+` command from anywhere in the terminal. Now, you can format Elm code by specifying a filename in the terminal like this:

[source,bash]
----
$ elm-format Main.elm
----

The https://github.com/avh4/elm-format#usage[usage section] in the official documentation shows various ways of using `+elm-format+` from the terminal, including how to format all Elm files in a directory.

===== Using `+elm-format+` from a Source Editor

Running `+elm-format+` from the terminal whenever we change an Elm file can be tedious. Therefore, most source code editors offer a plugin for automatically running it every time we save an Elm file. Install a plugin for your editor from the https://github.com/avh4/elm-format#editor-integration[official site]. Some plugins require you to manually turn on the _format on save_ option. Make sure to read the instructions (listed on the official site) on how to do that as well.


[[building-a-simple-page-in-elm]]
=== 2.3 Building a Simple Web Page


Let’s get a little taste of Elm before we get properly introduced to it. We will be building a simple web page using just HTML and CSS first. Later we will rebuild the same page with Elm to see the difference between two approaches.

==== Building a Simple Page with HTML

Create a new directory called `+beginning-elm+`. It doesn’t matter where you create it. Inside that directory, create a file named `homepage.html` and add the following code to it.

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" 
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

    <style>
      .jumbotron {
        background-color: #e6ffe6;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div class="jumbotron">
      <h1>Welcome to Dunder Mifflin!</h1>
      <p>
        Dunder Mifflin Inc. (stock symbol <strong>DMI</strong>) is
        a micro-cap regional paper and office supply distributor with
        an emphasis on servicing small-business clients.
      </p>
    </div>
  </body>
</html>
----

It’s a simple web page with a welcome message and a short description of one of our https://en.wikipedia.org/wiki/Dunder_Mifflin[beloved companies]. The page is styled with http://getbootstrap.com/[Bootstrap], a CSS framework. It also contains some inline style.

****
NOTE: Don’t worry if you aren’t familiar with Bootstrap. We are using it here to make the page look slightly better. Later it will serve as an example for how to load an external CSS framework in Elm.
****

Open the `homepage.html` file in a browser. It should look something like this:

image:https://elmprogramming.com/images/chapter-2/2.3-building-a-simple-web-page/homepage-in-html.png[]

Next, we will rebuild the home page for Dunder Mifflin with _Elm_.

==== Building a Simple Page with Elm

Create a new Elm project by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm init
----

We are greeted with the following message.

[source,bash]
----
Hello! Elm projects always start with an elm.json file. I can create them!

Now you may be wondering, what will be in this file? How do I add Elm files to
my project? How do I see it in the browser? How will my code grow? Do I need
more directories? What about tests? Etc.

Check out <https://elm-lang.org/0.19.0/init> for all the answers!

Knowing all that, would you like me to create an elm.json file now? [Y/n]:
----

The creators of Elm have gone to great lengths to make it a very friendly language. Consequently, Elm often tries to gently nudge us in the right direction with just the amount of information we need at the moment. Go ahead and press `Y`. All `+elm init+` does is create the `elm.json` file and an empty directory called `src`.

*elm.json* - Elm uses this file to determine which packages our project depends on. More on this later.

*src* - This directory is where all of our Elm files will be stored. Create a new file called `HomePage.elm` inside the `src` directory and add the following code to it.

[source,elm]
----
module HomePage exposing (main)

import Html exposing (..)
import Html.Attributes exposing (..)


view model =
    div [ class "jumbotron" ]
        [ h1 [] [ text "Welcome to Dunder Mifflin!" ]
        , p []
            [ text "Dunder Mifflin Inc. (stock symbol "
            , strong [] [ text "DMI" ]
            , text <|
                """ 
                ) is a micro-cap regional paper and office 
                supply distributor with an emphasis on servicing 
                small-business clients.
                """
            ]
        ]


main =
    view "dummy model"
----

Don’t worry about understanding the code above for now. We will cover how an Elm application works in detail later. All this code does is implement the exact same home page we built with plain HTML and CSS above. Run the following command from `+beginning-elm+` directory in terminal to compile `HomePage.elm` to JavaScript.

[source,bash]
----
$ elm make src/HomePage.elm --output elm.js
----

****
NOTE: The output file doesn’t have to be `elm.js`. You can call it anything you want. If you do name it something else, make sure to change the name in the HTML code below too.
****

If you look inside the `+beginning-elm+` directory, you should see the `elm.js` file and a new directory called `+elm-stuff+` which contains the build artifacts. Create one more file called `index.html` inside `+beginning-elm+` and add the following code to it.

[svgbob]
----

beginning-elm
    |
    +-- elm.json
    +-- homepage.html
    +-- index.html      <- - - -
    `-- src
        |
        `-- HomePage.elm

----
// image:https://elmprogramming.com/images/chapter-2/2.3-building-a-simple-web-page/index-file-location.png[]

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" 
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

    <style>
      .jumbotron {
        background-color: #e6ffe6;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div id="elm-app-is-loaded-here"></div>
    
    <script src="elm.js"></script>
    <script>
      var app = Elm.HomePage.init({
        node: document.getElementById("elm-app-is-loaded-here")
      });      
    </script>
  </body>
</html>
----

The code inside `+<head>+` is exactly the same as before. The `+<body>+`, however, looks different. We created a `div` and gave it an `id`. We then loaded the `elm.js` file that was generated as an output when we ran this command earlier: `+elm make src/HomePage.elm --output elm.js+`. That command compiles our Elm code and puts it in the `elm.js` file. Finally, we used the `+Elm.HomePage.init+` function to load our Elm app inside the `+elm-app-is-loaded-here+` div.

****
NOTE: Don’t worry if some of this doesn’t make sense yet. We will cover the mechanics of creating and embedding an Elm app in detail later.
****

Open the `index.html` file in a browser. It should look exactly like the one we built with just HTML and CSS.

Building a simple web page with Elm took a bit more effort than doing it with just HTML and CSS. If all you are building is a bunch of static pages, Elm is probably not the right tool for that. But if you need to build a highly interactive web application that will continue to grow in size and complexity over time then Elm is a fantastic tool for that.

The rest of this book is dedicated to getting ourselves familiarized with Elm and understanding how its architecture helps us build incredibly robust front-end web applications.


[[elm-platform]]
=== 2.4 Elm Platform


In the <<installation, Installation>> section, we installed Elm Platform which bundles together all the tools we need to work with Elm. In this section, we will briefly go through those tools. As you work through each chapter in this book, you will gain more insight into them.

You’ll also notice that the term _Elm_ will be used throughout the book to mean different things. Depending on the context it could mean any one of these:

* Elm Programming Language
* Elm Architecture
* Elm Compiler
* Elm Runtime

There is no harm in collectively calling them _Elm_, but it’s important to know what they really mean. The following sections will explain the difference between them.


[[elm-language]]
=== 2.5 Elm Programming Language


Elm programming language is a notation for writing programs that run on a web browser. The description of the language is split into two components: syntax and semantics. Syntax refers to the grammatical structure of a program whereas semantics refers to its meaning. For instance, the following code is syntactically invalid in Elm because the `pass:[+++]` operator doesn’t exist in the language.

[source,elm]
----
"syntactically invalid " +++ "code"
----

There are countless scenarios where Elm can throw a syntactic error. Here are some examples: a misplaced keyword, two operators in a row, unbalanced parentheses, etc.

After a program’s syntactic validity has been established, the next step is to look for semantic errors. For example, the following code is syntactically valid, but semantically invalid. `pass:[++]` is a valid operator in Elm, but it can only be used to combine two strings not a string and a number.

[source,elm]
----
"syntactically valid, but semantically invalid " ++ 45
----

For a program to be valid in Elm, it has to be both syntactically and semantically correct.

****
NOTE: Elm programming language itself is written in another language called https://www.haskell.org/[Haskell].
****


[[elm-compiler]]
=== 2.6 Elm Compiler


The Elm compiler is a program that transforms the code written in Elm programming language to JavaScript.

[tikz]
------
\documentclass[border=3pt,tikz]{standalone}
\pgfdeclarelayer{nodelayer}
\pgfdeclarelayer{edgelayer}
\pgfsetlayers{main,nodelayer,edgelayer}
\begin{document}
\tikzset{ none/.style={ draw=none,fill=none,text=black} }

% Node styles
\tikzstyle{box}=[anchor=north, fill={rgb,255: red,186; green,186; blue,0}, draw={rgb,255: red,226; green,226; blue,226}, shape=rectangle, minimum height=1.15cm, minimum width=0.5cm]
\tikzstyle{rounded}=[fill=white, draw=black, shape=rectangle, rounded corners=8pt, inner xsep=16pt,  inner ysep=60pt, align=center]

% Edge styles
\tikzstyle{dashed edge}=[->, line width=2pt, draw=blue!30, dashed]
\tikzstyle{thin edge}=[-]
\tikzstyle{thick edge}=[->, line width=2pt]
\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=rounded] (0) at (0, 0) {Elm project};
		\node [style=box] (1) at (0, 1.6) {.elm};
		\node [style=box] (2) at (0, -0.65) {.elm};
		\node [style=rounded] (3) at (4, 0) {Elm\\Compiler};
		\node [style=rounded] (4) at (9.25, 0) {Final Build};
		\node [style=box] (5) at (9.75, 1.75) {.html};
		\node [style=box] (6) at (9.75, -0.75) {.css};
		\node [style=box] (7) at (8.5, 1.5) {.js};
		\node [style=box] (8) at (8.5, -0.6) {.js};
		\node [style=rounded] (9) at (12.5, 0) {Bowser};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw[->,style=dashed edge] (1) to (3);
		\draw[->,style=dashed edge] (2) to (3);
		\draw[->,style=dashed edge] (4) to (9);
		\draw[->,style=dashed edge] (3) to (7.west);
		\draw[->,style=dashed edge] (3) to (8.west);
	\end{pgfonlayer}
\end{tikzpicture}

\end{document}
------

// image:https://elmprogramming.com/images/chapter-2/2.6-elm-compiler/elm-compiler.svg[]

Notice the two JavaScript files in the Final Build box above. Generally speaking, Elm takes in multiple `+.elm+` files in our project and compiles them to a single `+.js+` file. So why do we have multiple `+.js+` files in the final build?

The reason behind it is that the code for our application doesn’t need to be written 100% in Elm. Once you realize what a delightful language Elm is, you will be hard-pressed to write your code in anything else. But even then you can write only a portion of your application in Elm if you choose to do so.

In fact, this approach is recommended if you are trying to https://elm-lang.org/blog/how-to-use-elm-at-work[introduce Elm to an existing project]. You can pick a less risky area of your application and write it in Elm. Find out if the Elm code is more fun to write, performs better, and easier to maintain than the existing code. If yes, continue to write more features in Elm. Otherwise, perhaps Elm is not the right fit for your project.

Elm is designed to build reliable web apps that run on a browser. And browsers understand only JavaScript. Therefore, the Elm code has to be compiled to JavaScript. However, in the future if the Web moves away from JavaScript to http://webassembly.org/[something else], Elm code will need to be compiled to that instead. As of this writing, we can’t build server applications with Elm. Hopefully, someday we will be able to. When that day comes, Elm code will need to be compiled to multiple targets.


[[elm-architecture]]
=== 2.7 Elm Architecture


Elm Architecture is a set of patterns and language features for managing the flow of data in a program. In a highly interactive application, the data flows through many components. The resulting interaction between these components can be quite complex. The Elm Architecture reduces this complexity by using some very clever techniques. We will find out what those techniques are in <<elm-architecture-intro, chapter 5>>.

If you are coming to Elm from other languages such as JavaScript, Ruby, or Python, you will notice that there is no separate framework for building applications in Elm. That’s because the Elm Architecture is baked into the language.

Any additional feature(s) not available in the core language can be added to your project by simply installing a package from the http://package.elm-lang.org/[vast collection] of packages Elm offers. Most of these packages are designed to carry out a specific task such as retrieving data from an HTTP server rather than providing an overarching framework for building complex applications. Because of this, Elm is not just a JavaScript alternative, but also an alternative to frameworks like https://reactjs.org/[React], https://angular.io/[Angular], and https://vuejs.org/[Vue.js].


[[elm-runtime]]
=== 2.8 Elm Runtime


The Elm runtime is a system designed to support the execution of programs written in the <<elm-language, Elm programming language>>. The runtime is part of what makes Elm so powerful. It’s all the code that Elm runs behind the scenes, so that we can write programs describing what we want to accomplish and not worry about how Elm executes them. You can see it in action by looking at the output of the command we ran earlier in the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section.

[source,bash]
----
$ elm make src/HomePage.elm --output elm.js
----

We asked `+elm make+` to compile the code in our Elm file to JavaScript. If you look inside the `elm.js` file, you will realize that it contains thousands of lines of JavaScript code. But, wait a second — we didn’t write a ton of Elm code when we built our simple home page. It was barely fifteen lines of code. What’s going on here?

That’s where the Elm runtime comes in. The `elm.js` file contains not only the code we wrote, but also the entire Elm runtime and all the other Elm packages we installed. The browser understands only JavaScript, so every piece of Elm code must be transformed to it including the code for the runtime itself. The end users of our application won’t even know that Elm was ever involved in its creation.

image:https://elmprogramming.com/images/chapter-2/2.8-elm-runtime/elm-vs-javascript-territory.svg[]

****
NOTE: This book won’t cover any of the code inside the Elm runtime. We don’t have to drop down to this level at all to understand how to build complex applications in Elm. That is one of the reasons why Elm is such an easy-to-use language. The creators of Elm have done a lot of the hard work for us. We just build on top of all the features that are already written for us in the runtime.
****


[[elm-make]]

=== 2.9 elm make

`+elm make+` is a tool for building Elm projects. It takes `+.elm+` files and compiles them to JavaScript. In the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section, we used `+elm make+` to compile `HomePage.elm` to `elm.js` like this:

[source,bash]
----
$ elm make src/HomePage.elm --output elm.js
----

We then imported the `elm.js` file from `index.html`.

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    ...
  </head>

  <body>
    .
    .
    <script src="elm.js"></script>
    .
    .
  </body>
</html>
----

We have to go through this process of creating a separate `index.html` file if we want to add any JavaScript code of our own or import a CSS file or use a <<interacting-with-web-components, Web Component>> in our app. But if we don’t want any of that, we can simply remove the `+--output+` flag. `+elm make+` will then automatically create an `index.html` file for us and put the compiled code in it. We don’t have to manually create that file like we did before. Go ahead and delete the `+beginning-elm/index.html+` file and run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/HomePage.elm
----

Look inside `index.html` and you’ll see the code that used to be in `elm.js`. If you open `index.html` in a browser, you should see the home page for Dunder Mifflin with no CSS styling.

image:https://elmprogramming.com/images/chapter-2/2.9-elm-make/homepage-no-style.png[]

Although `+elm make+` allows us to lump everything in one file, it’s best practice to keep the compiled JavaScript code in a separate file. That way, if we need to add more JavaScript code or import any other file later we won’t have to move things around much. It will also improve the testability, code organization, and reusability in our app. We’ll be following this best practice throughout the book, so let’s restore the contents of `index.html` to what it used to be.

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <link 
      rel="stylesheet" 
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

    <style>
      .jumbotron {
        background-color: #e6ffe6;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div id="elm-app-is-loaded-here"></div>
    
    <script src="elm.js"></script>
    <script>
      var app = Elm.HomePage.init({
        node: document.getElementById("elm-app-is-loaded-here")
      });      
    </script>
  </body>
</html>
----


[[elm-install]]
=== 2.10 elm install


The <<elm-platform, Elm Platform>> includes all the tools necessary to work with Elm, but it doesn’t come with every package available in the http://package.elm-lang.org/[online catalog]. If all those packages were to be included in the platform itself, its download size would be huge. Even then we would still need to download packages from the catalog because new packages are being published frequently.

==== Installing a Package

Earlier, when we ran the `+elm init+` command in the <<building-a-simple-page-in-elm, Building a Simple Web Page>> section, the `elm.json` file was created inside the `+beginning-elm+` directory. If you look inside that file, you’ll see the packages our project depends on.

[source,json]
----
{
    .
    .
    "dependencies": {
        "direct": {
            "elm/browser": "1.0.1",
            "elm/core": "1.0.2",
            "elm/html": "1.0.0"
        },
        "indirect": {
            "elm/json": "1.1.3",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.2"
        }
    },
    .
    .
}
----

****
NOTE: Our project uses packages listed in `direct`. Some of those direct packages depend on other packages which are listed in `indirect`.
****

We then ran the `+elm make+` command to compile our Elm code to JavaScript.

[source,bash]
----
$ elm make src/HomePage.elm --output elm.js
----

`+elm make+` looks inside the `elm.json` file and automatically installs all packages listed as dependencies. Once the initial project is setup, we shouldn’t modify `elm.json` by hand. Instead, we should use the `+elm install+` command to download packages from the online catalog.

Let’s install a new package called https://package.elm-lang.org/packages/elm/http/latest/Http[`+elm/http+`] to get a feel for how `+elm install+` works. Later in the book, we will be making multiple HTTP requests to a server to retrieve data. To do that we will need the `+elm/http+` package. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install elm/http
----

Before downloading the package, `+elm install+` politely asks for our permission to add this package as a dependency to `elm.json`.

[source,bash]
----
Here is my plan:

  Add:
    elm/bytes    1.0.8
    elm/file     1.0.5
    elm/http     2.0.0

Would you like me to update your elm.json accordingly? [Y/n]:
----

Answer `Y` and you should see the following message.

[source]
----
Starting downloads...

  ● elm/bytes 1.0.8
  ● elm/file 1.0.5
  ● elm/http 2.0.0

Dependencies ready!
----

Once the package has been downloaded, `+elm install+` saves it in a local cache which is located in your home directory (`+~/.elm+`). Whenever we ask `+elm install+` to install a package, it first checks to see if that package is already in local cache. If yes, it’ll install from there. If not, it will download the package from online catalog. This speeds up the installation process quite a bit.

****
NOTE: A package name is prefixed by the username of the person or organization who publishes the package. All packages we have installed so far are published by https://github.com/elm[`elm`] — official organization for developing Elm’s compiler and core tools.
****

`+elm install+` also adds the `+elm/http+` package as a direct dependency to the `elm.json` file.

[source,json]
----
{
    .
    .
    "dependencies": {
        "direct": {
            "elm/browser": "1.0.1",
            "elm/core": "1.0.2",
            "elm/html": "1.0.0",
            "elm/http": "2.0.0"
        }
    }
    .
    .
}
----

By listing all of our dependencies in one place (`elm.json`), Elm has made it easy for us to share our project with others. All our co-workers need to do is run <<elm-make, `+elm make+`>> and the required packages will be installed automatically.

==== What is a package anyway?

The term _package_ has been used throughout this chapter without being formally introduced. A package in Elm is a collection of modules. A module is a collection of functions and other values. Don’t worry if you don’t know what functions and values are in Elm. We’ll get properly introduced to them in <<elm-language-basics-intro, chapter 3>>.

For now, think of functions as the smallest utilities you can write in Elm. Some of these utilities can be reused in multiple contexts. You can combine these reusable utilities that perform similar tasks into a module. You might even want to combine multiple modules that solve similar problems into a package. You can then share that package with other programmers by publishing it on the online catalog.

[tikz]
------
\documentclass[border=3pt,tikz]{standalone}
\pgfdeclarelayer{nodelayer}
\pgfdeclarelayer{edgelayer}
\pgfsetlayers{main,edgelayer,nodelayer}
\begin{document}
\tikzset{ none/.style={ align=center,fill=none,text=black} }

% TiKZ style file generated by TikZiT. You may edit this file manually,
% but some things (e.g. comments) may be overwritten. To be readable in
% TikZiT, the only non-comment lines must be of the form:
% \tikzstyle{NAME}=[PROPERTY LIST]

% Node styles
\tikzstyle{dot}=[fill=white, draw={rgb,255: red,132; green,132; blue,132}, shape=circle]
\tikzstyle{box}=[fill={rgb,255: red,186; green,186; blue,0}, draw={rgb,255: red,226; green,226; blue,226}, shape=rectangle, minimum height=1.15cm, minimum width=0.5cm]
\tikzstyle{Circle}=[fill=white, draw=black, shape=circle, inner sep=16pt, align=center]
\tikzstyle{roundedbox}=[fill=white, draw=black, shape=rectangle, rounded corners=6pt, inner sep=4pt]

% Edge styles
\tikzstyle{thin edge arrow}=[fill=none, draw={rgb,255: red,99; green,99; blue,99}, ->]
\tikzstyle{thick edge}=[-, fill={rgb,255: red,191; green,128; blue,64}, draw={rgb,255: red,63; green,59; blue,40}]
\tikzstyle{dashed edge}=[-, fill=none, draw={rgb,255: red,25; green,25; blue,25}, dashed]
\tikzstyle{thin edge}=[-]
\tikzstyle{thick edge arrow}=[->, line width=2pt]
\begin{tikzpicture}
  \begin{pgfonlayer}{nodelayer}
    \node [style=none] (0) at (7.5, 6) {};
    \node [style=none] (1) at (8.25, 6.75) {};
    \node [style=none] (2) at (9.25, 7) {};
    \node [style=none] (3) at (9.75, 6.75) {};
    \node [style=none] (4) at (10.25, 6.25) {};
    \node [style=none] (5) at (8.75, 6.25) {Package\\Catalog};
    \node [style=none] (6) at (6, 5.25) {https://package.elm-lang.org/};
    \node [style=none] (7) at (7.05, 4) {Download using\\elm install command};
    \node [style=none] (8) at (4.3, 6.5) {Publish using elm publish command};
    \node [style=roundedbox] (9) at (0, 6) {Package};
    \node [style=roundedbox] (12) at (1.5, 3.5) {module 2};
    \node [style=roundedbox] (13) at (1.25, 1.25) {function 2};
    \node [style=roundedbox] (14) at (3,    1.25) {value 2};
    \node [style=roundedbox] (15) at (-1.5, 3.5) {module 1};
    \node [style=roundedbox] (16) at (-2.75, 1.25) {function 1};
    \node [style=roundedbox] (17) at (-0.75, 1.25) {value 1};
    \node [style=none] (18) at (8, 2.75) {};
    \node [style=none] (19) at (9.5, 2.75) {};
    \node [style=none] (20) at (9.5, 1.75) {};
    \node [style=none] (21) at (8, 1.75) {};
    \node [style=none] (22) at (8, 1.75) {};
    \node [style=none] (23) at (7.5, 1) {};
    \node [style=none] (24) at (10, 1) {};
    \node [style=none] (25) at (9.5, 1.75) {};
    \node [style=none] (26) at (8.12, 1.5) {};
    \node [style=none] (27) at (9.37, 1.5) {};
    \node [style=none] (28) at (8, 1.35) {};
    \node [style=none] (29) at (9.5, 1.35) {};
    \node [style=none] (30) at (8.75, 2.75) {};
    \node [style=none] (31) at (8.75, 5.5) {};
  \end{pgfonlayer}
  \begin{pgfonlayer}{edgelayer}
    \draw [fill=white] (2.center)
        to [in=90, out=15, looseness=1.25] (3.center)
        to [bend left=75, looseness=1.50] (4.center)
        to [bend right=315, looseness=0.75] (0.center)
        to [in=180, out=120] (1.center)
        to [bend left=90, looseness=2.25] cycle;
    \draw [style=thick edge arrow, in=90, out=-90, looseness=1.25] (12) to (13);
    \draw [style=thick edge arrow, in=90, out=-90, looseness=1.25] (12) to (14);
    \draw [style=thick edge arrow, in=90, out=-90, looseness=1.25] (15) to (16);
    \draw [style=thick edge arrow, in=90, out=-90, looseness=1.25] (15) to (17);
    \draw [style=thick edge arrow, in=90, out=-90] (9) to (12);
    \draw [style=thick edge arrow, in=90, out=-90, looseness=1.25] (9) to (15);
    \draw [style=thick edge arrow] (9) to (0);
    \draw [style=thick edge arrow] (31.center) to (30.center);
    \draw [style=thick edge] (23.center)
       to (22.center)
       to (25.center)
       to (24.center)
       to cycle;                   % notebook
    \draw [draw=black!70, line width=2.5pt] (23.center) -- (24.center);
    \draw [style=thick edge, dotted, line width=2.5pt, draw=black!10]
       (28.center) to (29.center)
       (27.center) to (26.center); % keyboard
    \draw [style=thick edge, fill=blue!40, draw=black!70, line width=1.5pt]
       (20.center)
       to (19.center)
       to (18.center)
       to (21.center)
       to cycle;                   % screen
  \end{pgfonlayer}
\end{tikzpicture}

\end{document}
------

// image:https://elmprogramming.com/images/chapter-2/2.10-elm-install/package-module-relationship.svg[]

A package doesn’t have to have multiple modules in it. For example, as of this writing the https://package.elm-lang.org/packages/elm/random/latest/[`+elm/random+`] package has only one module called `Random`. `+elm install+` is designed to work with packages. Therefore, putting a module in a package makes it easier to share with others through the online catalog.


[[elm-reactor]]
=== 2.11 elm reactor


Earlier when we <<building-a-simple-page-in-elm, built a simple web page in Elm>>, we first created a file with `+.elm+` extension and put all of our Elm code in it. We then compiled it to JavaScript using <<elm-make, `+elm make+`>>. After that we referenced the output file (`elm.js`) from `index.html` to load our Elm application into the browser.

That was a lot of steps just to see the result of our code. Luckily, Elm provides an interactive development tool called `+elm reactor+` that lets us see the result of our code instantly. Go to the `+beginning-elm+` directory in terminal and run this command: `+elm reactor+`. You should see something like this:

[source,bash]
----
$ elm reactor

Go to <http://localhost:8000> to see your project dashboard.
----

`+elm reactor+` has created a development server on port `8000`.

****
NOTE: If you have another server running on port `8000`, you need to stop it. Otherwise, `+elm reactor+` won’t be able to launch a development server.
****

If you visit http://localhost:8000/[`+http://localhost:8000+`] from a browser, you will see the contents of `+beginning-elm+` — our root project directory. You will also see a list of packages our project depends on.

image:https://elmprogramming.com/images/chapter-2/2.11-elm-reactor/elm-reactor.png[]

Click on the `src` link under _File Navigation_ section and then click `HomePage.elm`. You should see the home page of Dunder Mifflin with no CSS styling.

image:https://elmprogramming.com/images/chapter-2/2.9-elm-make/homepage-no-style.png[]

`+elm reactor+` compiles the code in `+src/HomePage.elm+` file and renders it on a browser. Unfortunately, the page doesn’t look as nice as our original home page:

image:https://elmprogramming.com/images/chapter-2/2.3-building-a-simple-web-page/homepage-in-html.png[]

As of this writing, `+elm reactor+` doesn’t support loading external CSS frameworks such as https://getbootstrap.com/[Bootstrap]. It has other limitations too. For example, it lacks live reloading — a technique that reloads a page automatically when the underlying code changes — thus requiring us to refresh the page manually every time we make a small change to our code to see the result. Because of these limitations, `+elm reactor+` may not provide the best development experience especially when building complex applications that demand a robust build process.

Fortunately, there are multiple tools out there that are much more powerful than `+elm reactor+` such as https://github.com/architectcodes/elm-live[elm-live] and https://webpack.js.org/[Webpack]. We’ll cover `+elm-live+` in <<navigating-to-list-posts-page, chapter 6>>. Despite those limitations, `+elm reactor+` is still great for prototyping simple applications and we will be using it throughout this book.


[[elm-repl]]
=== 2.12 elm repl


`+elm repl+` is a tool that lets us experiment with Elm. We will be using this tool extensively in the next chapter to learn the syntax and semantics of the <<elm-language, Elm programming language>>.

REPL stands for **R**ead **E**val **P**rint **L**oop. It basically waits for us to enter some Elm code, evaluates it, prints out the result, and goes back to waiting for more code. This cycle repeats forever until we exit out of it by pressing `+Ctrl + d+`.

****
NOTE: Another way of exiting an `+elm repl+` session is by typing `+:exit+` and hitting enter.
****

Like `+elm reactor+`, `+elm repl+` allows us to type Elm code and see the result immediately without having to compile it manually. The difference between `+elm reactor+` and `+elm repl+` is that the former takes in an Elm file, compiles it to JavaScript, and renders it on a browser whereas the latter takes an expression in Elm, evaluates it on the fly and displays the result right in the terminal. `+elm repl+` is good for trying out short expressions as we explore the language. In contrast, `+elm reactor+` is better for trying out a bigger piece of code that’s cumbersome to type in the repl.

Although `+elm repl+` works by compiling Elm code to JavaScript, it doesn’t render the compiled code on a browser. Therefore, it needs an alternative environment to run that code. As explained in the <<installation, Installation>> section, Node.js provides that environment.

==== Running `+elm repl+`

Go to the `+beginning-elm+` directory in the terminal and run this command: `+elm repl+`. You should see something like this:

[source,bash]
----
$ elm repl

---- Elm 0.19.0 ----------------------------------------------------------------
Read <https://elm-lang.org/0.19.0/repl> to learn more: exit, help, imports, etc.
--------------------------------------------------------------------------------
>
----

We can now type all sorts of Elm expressions in here and find out what they evaluate to. Here are some examples:

[source,elm]
----
> 42 / 7.5
5.6 : Float

> pi
3.141592653589793 : Float

> List.reverse [ "Next", "Stop", "Pottersville" ]
["Pottersville","Stop","Next"] : List String
----

****
NOTE: All examples in this book are thoroughly tested with Elm 0.19. As you work through them, if you notice that the output produced by the repl doesn’t match what’s in the book, try re-starting the repl. Sometimes that fixes the issue. If not, please provide a helpful description of the issue you are experiencing in the comments section.
****


[[ellie]]
=== 2.13 Ellie


There are times when we want to just write some Elm code and see what happens without having to install the <<elm-platform, Elm Platform>> and other required tools. https://ellie-app.com/new[Ellie] is perfect for that.

Let’s run the Elm code for our home page on Ellie. Copy everything in the `+src/HomePage.elm+` file and paste it in the Elm area. Now copy the contents of the `+beginning-elm/index.html+` file and paste it in the HTML area. After that, click the compile button. You should see our home page on the right side.

image:https://elmprogramming.com/images/chapter-2/2.13-ellie/ellie.png[]

Ellie is good for trying a one-off experimental code. In addition to running simple programs, Ellie allows us to add Elm packages, work through compiler errors, and share our code with others. As of this writing, Ellie doesn’t provide a robust environment required for professional web application development. Hopefully, someday it will.


[[getting-started-conclusion]]

=== 2.14 Conclusion

In this chapter, we acquired a high-level understanding of various concepts and tools essential for building applications in Elm. Don’t worry about understanding each tool in detail right now. You will have plenty of opportunities to dive deeper into those tools as you work through the rest of the chapters in this book.

The next chapter is all about learning how Elm’s syntax works. Let’s get to it!


[[elm-language-basics-intro]]
== 3 Elm Language Basics

=== 3.1 prelude

Every programming language has its own syntax and semantics. Elm too provides a simple yet powerful syntax for writing expressions — the basic building blocks of any Elm program. In this chapter, we will learn the fundamentals of Elm programming language. We will use <<elm-repl, elm repl>> and <<elm-reactor, elm reactor>> throughout this chapter to try out many examples that will illustrate the core ideas in Elm.


[[simple-arithmetic]]
=== 3.2 Simple Arithmetic


Performing arithmetic calculations in Elm is straightforward. Go to the `+beginning-elm+` directory in terminal and run the `+elm repl+` command. Now let’s try some simple arithmetic.

[source,elm]
----
> 1 + 2
3 : number

> 4534 - 789
3745 : number

> 42 * 10
420 : number

> 9 / 4
2.25 : Float
----

There are two types of divisions in Elm: floating-point and integer. The `+/+` operator is used for the former and `+//+` for the latter. The integer division truncates everything after the decimal point.

[source,elm]
----
> 5 / 2
2.5 : Float

> 5 // 2
2 : Int
----

****
NOTE: For the rest of this chapter, the type annotations printed by the repl (e.g., `+: Float+`) will be omitted to reduce the clutter. We haven’t covered types yet, so they won’t make much sense now anyway. We will cover them in <<type-system, chapter 4>>.
****

Just like in mathematics, operators (`+++`, `-`, `+*+`, and `+/+`) are placed between numerical arguments in above examples. This is called _infix_ style. We can also write them in _prefix_ style, where the operator precedes its arguments. Prefix style requires us to enclose the operator in parentheses.

[source,elm]
----
> (+) 1 2
3

> (-) 4534 789
3745

> (*) 42 10
420

> (/) 9 4
2.25
----

==== Operator precedence

We can also use several operators in one line.

[source,elm]
----
> 42 * 200 - 8000
400

> (42 * 200) - 8000
400

> 42 * (200 - 8000)
-327600
----

Notice how in the last example above we used parentheses to change the order in which the operators were applied. `+*+` has a higher precedence than `-`. Therefore, if we want `-` to be applied first, we must apply parentheses around its arguments. In the second example, we made the precedence explicit by applying parentheses around `+*+`, but it’s not necessary.

Elm assigns numeric precedence values to operators, with `0` being the lowest precedence and `9` being the highest. A higher-precedence operator is applied before a lower-precedence operator. See the table below to find the precedence for various operators in Elm.

==== Associativity

Associativity determines whether an expression containing multiple operators is evaluated from left to right, or right to left. Operators that evaluate from left are called _left-associative_ and the ones that evaluate from right are called _right-associative_. `+++`, `-`, `+*+`, and `+/+` are all left-associative. Whereas the power operator (`+^+`) is right-associative.

[source,elm]
----
> 2 ^ 3 ^ 2
512

> (2 ^ 3) ^ 2
64
----

If we don’t use parentheses, the power operator evaluates the expression from right to left. The table below shows the precedence and associativity of various operators in Elm. The operators you see here that haven’t been covered yet will be discussed in later parts of the book.

[cols=",,",options="header,autowidth",frame=ends,grid=rows]
|===
|Operators  |Precedence |Associativity
|`>>`       |9          |left
|`<<`       |9          |right
|`^`        |8          |right
|`* / // % rem` |7      |left
|`+ -`      |6          |left
|`+ ::`     |5          |right
|`== /= < > <= >=` |4   |none
|`&&`       |3          |right
|`\|\|`     |2          |right
|`\|>`      |0          |left
|`<\|`      |0          |right
|===

http://faq.elm-community.org/operators.html[Source: Unofficial FAQ for the Elm language]


[[boolean]]
=== 3.3 Boolean


Performing operations from boolean algebra is also quite straightforward in Elm.

[source,elm]
----
> True || False
True

> False || False
False

> True && False
False

> True && True
True

> not True
False

> xor True False
True

> xor True True
False

> xor False False
False
----

* `+||+` - Boolean _or_ - returns true if at least one input is `True`.
* `+&&+` - Boolean _and_ - returns true only if both options are `True`.
* `not` - Boolean _negation_ - returns the opposite value of the input.
* `xor` - Boolean _exclusive-or_ - returns True if exactly one input is `True`.

Some programming languages treat the number zero or `null` as synonymous with `False`. Elm doesn’t allow that, nor does it consider a non-zero value to be `True`. For a condition to be true, it must evaluate exactly to the value `True`.

[source,elm]
----
> True && 0

----------------- TYPE MISMATCH -----------------------
I am struggling with this boolean operation:

4|   True && 0
             ^
Both sides of (&&) must be Bool values, but the right side is:

    number

Hint: Only Int and Float values work as numbers.
----

Look how helpful the error messages are. It’s one of many reasons why Elm is such a delightful language.


[[comparison]]
=== 3.4 Comparison


Elm compares values using these operators:

[cols=",",options="header,autowidth",frame=ends,grid=rows]
|===
|Operator |Meaning
|`==`     |Equal
|`/=`     |Not Equal
|`>`      |Greater than
|`<`      |Less than
|`>=`     |Greater than or equal to
|`<=`     |Less than or equal to
|`max`    |Find the larger of two
|`min`    |Find the smaller of two
|===

[source,elm]
----
> (5 == 5)
True

> 1 /= 2
True

> 10 < 7
False

> 100 > 99
True

> 7 >= 10
False

> 9 <= 9
True

> max 5 6
6

> min 3 8
3
----


[[comment]]
=== 3.5 Comments


Comments can be quite useful for:

* Providing documentation that explains how the code works.
* Preventing execution of some code when we are experimenting or trying to find the root cause of a bug.

Like most programming languages, Elm provides two types of comments: single line and multi-line.

==== Single Line Comments

Single line (also known as _inline_) comments start with `--`. Elm will ignore any text between `--` and the end of the line.

[source,elm]
----
> 42 -- This is a single line comment and will be ignored by Elm.
42

> 42 * (78 - (50 / 4) + (80 / 3)) -- A slightly more complex math expression.
3871
----

==== Multi-line Comments

Multi-line (also known as _block_) comments start with `{-` and end with `-}`. Elm will ignore any text between `{-` and `-}`.

[source,elm]
----
> 5 {- This is a block comment and will be ignored by Elm. -}
5
----

Here is an example of a multi-line comment that explains how the `not` function works in Elm.

[source,elm]
----
{-| Negate a boolean value.

    not True == False
    not False == True
-}
not : Bool -> Bool
not =
    Elm.Kernel.Basics.not
----

Generally speaking it’s unnecessary to type comments in the repl. They are more appropriate for the code written in a file.

==== Toggling Comments

When we are experimenting with code, we often want to toggle comments. Most code editors provide a shortcut for toggling single line comments. For example, in https://www.sublimetext.com/[Sublime Text] and https://code.visualstudio.com/[Visual Studio Code] a comment can be toggled (on a Mac) by pressing `Cmd` + `+/+`. However, these editors don’t have a good mechanism for toggling multi-line Elm comments. One handy trick we can use for that is to add and remove `}` on the first line. Let’s say we have some code commented out like this:

[source,elm]
----
{--
  multiply x y = x * y
  divide x y = x / y
--}
----

****
NOTE: Your source editor may not know how to toggle even single-line Elm comments out-of-the-box. If that’s the case, you’ll have to install a plugin for that. Refer to the <<installation, Source Code Editor>> section in Chapter 2 to find out how to install an Elm plugin for your favorite editor.
****

Notice we added extra `-` after `{-` and before `-}`. Now to uncomment the code all we have to do is add `}` to the end of the first line.

[source,elm]
----
{--}
  multiply x y = x * y
  divide x y = x / y
--}
----

Because the leftover `}` at the end is preceded by `--`, Elm treats it as a single-line comment. To bring back the multi-line comment, just remove `}` from the first line.


[[expression]]
=== 3.6 Expression


Before we attempt to understand what an expression is in Elm, let’s look at its definition in https://en.wikipedia.org/wiki/Algebra[algebra] first. An expression groups together numbers, symbols, and operators to compute a value. Here is an example:

image:https://elmprogramming.com/images/chapter-3/3.6-expression/expression.svg[]

The expression above can be evaluated to some value depending on what `x` holds. Since `x` is a variable, its value will also change depending on the context of a problem. If `x` is `2`, the expression will evaluate to `1`. If `x` is `3`, the expression will evaluate to `4`. But what if we put a constraint on `x` like this:

image:https://elmprogramming.com/images/chapter-3/3.6-expression/equation.svg[]

Because the expression on the left must evaluate to `7`, `x` can now have only _one_ value: `4`. We put a constraint on the value of a variable through an _equation_. Notice that we have labeled `7` on the right side of the equation as an expression too. We don’t need to have a symbol and an operator to create a valid expression. Anything that evaluates to a value is an expression. Since `7` is already a value and doesn’t need further evaluation, it’s considered an expression as well.

With this foundational knowledge about expressions, variables, and equations, let’s turn our attention back to Elm. Each line of code we have typed in the repl so far is an expression. All of them evaluate to a _value_. Like algebra, if we just type a number without any operator in the repl, Elm treats it as an expression and attempts to evaluate it. But since a number itself is a value, Elm doesn’t need to evaluate it any further. So it just prints the number back.

[source,elm]
----
> 42
42

> 5
5
----


[[value]]
=== 3.7 Value


We have used the term _value_ without formally defining it. Mathematics defines a value as the result of a calculation. When we evaluate an expression we are performing a calculation. The terms _calculation_ and _computation_ can be used interchangeably. In Elm, all computations are done by evaluating expressions to yield values. This makes expressions the basic building blocks of any Elm application. No matter how complex an Elm application is, its essentially one big expression comprising of mini expressions.

So far we have only used numbers and boolean as values, but in Elm anything we can produce as a result of a computation can be considered a value. Here are some examples:

[source,elm]
----
> 'c' -- character
'c'

> "pretzels" -- string
"pretzels"

> [ 1, 2, 3 ] -- list
[1,2,3]

> { a = 1, b = 2 } -- record
{ a = 1, b = 2 }

> ( "first", "second" ) -- tuple
("first","second")

> someFunction x = x + 1 -- function
<function>
----

We will cover each of these values in detail later. All values in Elm can be passed as arguments to functions, returned as results, and placed in data structures.


[[constant]]
=== 3.8 Constant


We glossed over an important detail when we were discussing variables. After we have put a constraint on a value of the variable `x` like this: `+3x - 5 = 7+`, it essentially turns into a constant. Let’s write it another way to make this point clearer: `+x = (7 + 5) / 3+`. In this scenario, `x` can have only one value and that is `4`. It can never change. It will remain `4` forever, until the end of time. It looks as if we have discovered a way to give a name to an expression. We can refer to the expression `+(7 + 5) / 3+` as `x` now. If we see another expression that uses `x`, we can safely replace it with `+(7 + 5) / 3+`. As it turns out, Elm also lets us name expressions like this:

[source,elm]
----
> x = (7 + 5) / 3
4

> x
4

> meaningOfLife = 42
42

> meaningOfLife
42
----

From now onwards, we will use the term _constant_ for something that gives a name to an expression. Elm also defines constants of its own, for example here is our favorite constant from mathematics:

[source,elm]
----
> pi
3.141592653589793
----

==== Naming Constants

Elm provides certain guidelines for naming constants.

===== Camel Case

The first letter of a constant must be written in lowercase and the first letter of each subsequent concatenated word should be capitalized. This style of naming is called https://en.wikipedia.org/wiki/Camel_case[Camel Case].

[source,elm]
----
> meaningOfLife = 42   -- Valid name for a constant
42
----

[source,elm]
----
> MeaningOfLife = 42   -- Invalid name for a constant
----

===== Numbers

A constant can have numbers in its name.

[source,elm]
----
> height1 = 6
6
----

Although `height1` is a valid name in Elm, it’s recommended that you minimize the use of numbers in a name. Numbers are cryptic and they don’t reveal much about the information represented by a constant.

===== Apostrophes

Prior to the `0.18` version, Elm allowed apostrophes in a constant’s name. Not anymore.

[source]
----
> name' = "Walter"   -- Invalid name for a constant
----

===== Underscore

A constant can also have an underscore in its name.

[source,elm]
----
> base_height = 4   -- Valid but not recommended
4
----

However, as we covered before, Elm style conventions dictate that constant names are written in Camel Case. When there is an underscore in between words, that is called https://en.wikipedia.org/wiki/Snake_case[Snake Case].

Just like numbers, we may feel the temptation to add an underscore to the end to create a constant that represents a similar concept we have dealt with before.

[source,elm]
----
> name = "Sansa"
"Sansa"

> name_ = "Stark"  -- Valid but not recommended
"Stark"
----

I encourage you to replace an underscore with a meaningful word to describe the subtle difference.

[source,elm]
----
> firstName = "Sansa"
"Sansa"

> lastName = "Stark"  -- Much better
"Stark"
----

===== Special Characters

A constant cannot have a special character (e.g. `$`, `#`, or `&`) in its name.

[source,elm]
----
> height$ = 7  -- Invalid name for a constant
----


[[if-expression]]
=== 3.9 If Expression


Let’s say we are embarking on an exciting journey to find out whether Enceladus, one of Saturn’s moons, can sustain life. First, we have to escape the gravitational pull from mighty Earth. If our spaceship can travel with a velocity greater than `11.186 km/s`, we can then be free to begin our interplanetary journey. Let’s express this in Elm.

[source,elm]
----
> velocity = 11.2
11.2

> if velocity > 11.186 then "Godspeed" else "Come back"
"Godspeed"
----

The most common way to express a conditional logic in Elm is through an `if` expression. It requires three parts:

* A condition
* An expression (branch) to evaluate if the condition is true
* An expression (branch) to evaluate if the condition is false

Unlike some other languages, in Elm we must provide the else branch. Otherwise Elm will throw an error.

[source]
----
> if velocity > 11.186 then "Godspeed"

-------------------- PARSE ERROR ------------------------
Something went wrong while parsing an `if` expression in 
repl_value_2's definition.

5|   if velocity > 11.186 then "Godspeed"
6|
   ^
I was expecting:

  - an `else` branch. An `if` must handle both possibilities.
  - an argument, like `name` or `total`
  - the end of that `if`. Maybe you forgot some code? Or maybe the body of
    `repl_value_2` needs to be indented?
----

Like all other expressions, an `if` expression also returns a value. Let’s capture the return value of the above expression in a constant.

[source,elm]
----
> whatToDo = if velocity > 11.186 then "Godspeed" else "Come back"
"Godspeed"

> whatToDo
"Godspeed"
----

image:https://elmprogramming.com/images/chapter-3/3.9-if-expression/if-expression.svg[]

Some people don’t have the desire to venture out into the unknown corners of Cosmos. But they also don’t like living on Earth. One option for them is to live on a space station that revolves around Earth in perpetuity with horizontal speed of `+7.67 km/s+`. Let’s add this option to our code.

[source,elm]
----
> velocity = 11
11

> speed = 7.67
7.67

> if velocity > 11.186 then "Godspeed" else if speed == 7.67 then "Stay in orbit" else "Come back"
"Stay in orbit"
----

We can nest as many `+else if+` branches as we want. It’s hard to understand what a code does when it’s crammed in one line like that. Elm repl allows us to split code into multiple lines by adding `+\+` to the end of each line and indenting the next line. Let’s try that.

[source,elm]
----
> if velocity > 11.186 then \
|     "Godspeed" \
|   else if speed == 7.67 then \
|     "Stay in orbit" \
|   else \
|     "Come back"
"Stay in orbit"
----

****
NOTE: As mentioned in <<conventions-used-in-the-book, chapter 1>>, `+elm repl+` automatically adds a vertical bar (`+|+`) in-front of each line starting from the second line. You shouldn’t type them. Also, don’t forget to indent `+"Godspeed"+`, `+"Stay in orbit"+`, and `+"Come back"+` with at least one space. Elm treats lack of indentation as syntax errors in some cases. We will cover those cases in detail in the <<indentation, Indentation>> section. Finally, we terminated the lines with `+\+` to make the code more readable, but you don’t have to do that when entering Elm code in a file, which will be covered in the next section.
****

Even with this ability to type multi-line code, it still is cumbersome to enter longer code in repl. We’ll switch to writing code in a file in the next section.


[[function]]
=== 3.10 Function


The good old space race is back on. Wouldn’t it be great if we could help out some of these incredibly ambitious companies by letting them reuse our code to find out whether or not their spaceship can leave the Earth too? We can do that by creating a _function_ that encapsulates our logic. Before we do that, let’s understand what a function is in mathematics first.

****
NOTE: You may be wondering why I keep taking you back to the wonderful world of mathematics every time I try to explain a concept in Elm. That’s because Elm is a functional programming language which gives it a strong mathematical foundation. Elm implements concepts from mathematics without distorting them. So by understanding how they work in mathematics first, it’s easier to understand them later in Elm. As a bonus, you know where these concepts originally came from. This doesn’t mean you need to have a strong math background to learn Elm. Everything you need to know is covered in this book.
****

A function, in mathematics, is a relationship from a set of inputs to a set of possible outputs where each input is mapped to exactly one output. Functions in Elm also work the same way.

image:https://elmprogramming.com/images/chapter-3/3.10-function/function.svg[]

Let’s write a function in Elm called `escapeEarth` that takes a value from an input set of velocities and maps it to a value from an output set of instructions.

[source,elm]
----
> escapeEarth myVelocity = \
|   if myVelocity > 11.186 then \
|     "Godspeed" \
|   else \
|     "Come back"
<function>
----

We can now call this function with different velocities to find out whether or not a spaceship can leave the Earth.

[source,elm]
----
> escapeEarth 11.2
"Godspeed"

> escapeEarth 11
"Come back"
----

Like `if` expression, we can assign the value returned by a function to a constant.

[source,elm]
----
> whatToDo = escapeEarth 11.2
"Godspeed"

> whatToDo
"Godspeed"
----

==== Function Syntax

image:https://elmprogramming.com/images/chapter-3/3.10-function/function-syntax.svg[]

Functions are so critical to Elm applications that Elm provides an incredibly straightforward syntax for creating them. No ceremony is required, such as using a special keyword or curly braces which is common in many languages.

==== Function Application

Once we create a function, we need to apply it to a value to get a desired output. In mathematics, function application is the act of applying a function to a value from the input set to obtain a corresponding value from the output set. You have already seen an example of a function application above: `+escapeEarth 11+`. When a function is applied, its name should be separated from its argument with whitespace. If a function takes multiple arguments, they too should be separated from each other with whitespace.

****
NOTE: In most programming languages, it’s more common to say _“calling a function”_ instead of _“applying a function”_. Those two phrases are interchangeable in meaning.
****

Parameter vs Argument::
  The terms _parameter_ and _argument_ are often used interchangeably although they are not the same. There is no harm in doing so, but just to clear things up, an argument is used to supply a value when applying the function (e.g. `+escapeEarth 11+`) whereas a parameter is used to hold onto that value in function definition (e.g. `+escapeEarth myVelocity+`).

Earlier we learned that all Elm applications are built by stitching together expressions. How do functions fit into this organizational structure? Functions are values too like numbers and strings. Since all values are expressions, that makes functions expressions as well. Because of this, functions can be returned as a result of a computation. They can be passed around like any other value. For example, we can give them to another function as an argument. Functions that take other functions as arguments or return a function are called _Higher Order Functions_. We will see many examples of higher order functions soon.

==== Functions with Multiple Parameters

The `escapeEarth` function above takes only one argument: `velocity`. But, we can give it as many arguments as we want. Let’s add one more parameter to its definition so that it can tell us whether or not our horizontal speed is fast enough to stay in an orbit.

The next code we will write is a bit difficult to type in the repl without making any mistakes, so we will write it in a file instead. Create a new file called `Playground.elm` inside the `src` directory which is located in the root directory (`+beginning-elm+`) of the Elm project we created in the <<building-a-simple-page-in-elm, last chapter>>. We will use the `Playground.elm` file to experiment with various concepts in Elm. Here is how the directory structure should look like so far.

image:https://elmprogramming.com/images/chapter-3/3.10-function/playground-elm-file-location.png[]

Filename::
  Elm style conventions dictate that filenames are also written in <<constant, Camel Case>>. Unlike constants, the first letter in a filename should be written in uppercase though. The first letter of each subsequent concatenated word should be capitalized. Elm doesn’t throw an error if we don’t follow this convention, but there is no reason not to follow it.

Put the following code in `Playground.elm`.

[source,elm]
----
module Playground exposing (main)

import Html


escapeEarth myVelocity mySpeed =
    if myVelocity > 11.186 then
        "Godspeed"

    else if mySpeed == 7.67 then
        "Stay in orbit"

    else
        "Come back"


main =
    Html.text (escapeEarth 11.2 7.2)
----

The first two lines define a new module called `Playground` and import the `Html` package. Don’t worry about `module` and `import` yet; we’ll cover them later. Next is our function `escapeEarth`. We give it one more parameter called `mySpeed`. If `myVelocity` is not greater than `11.186`, it will use the `+else if+` branch to compare whether `mySpeed` is equal to `7.67`. If yes, it returns `+"Stay in orbit"+`. Otherwise, it falls to the `else` branch.

The last function is `main`. The execution of all Elm applications start with this function. It’s a regular function like any other. It just happens to be the entry-point for an application. We apply a function called `Html.text` to the result produced by yet another function application: `+escapeEarth 11.2 7.2+`. `Html.text` takes a string and displays it on a browser. It’s important to surround `escapeEarth` and its arguments with parentheses. Otherwise, Elm will think we are passing three arguments to `Html.text` which takes only one argument. This is because Elm uses whitespace to separate a function name from its arguments. We can chain as many function applications as we want.

Go to the `+beginning-elm+` directory in your terminal and run `+elm reactor+`. After that open this URL in a browser: http://localhost:8000/[`+http://localhost:8000+`]. You should see `src` as one of the directories listed in the _File Navigation_ section. Click on it. Now you should see the `Playground.elm` file. If you click that file too, `+elm reactor+` will compile the code in it and display the string “Godspeed”.

==== Partial Function Application

When we applied the `escapeEarth` function above, we pulled the value for speed out of thin air. What if it’s actually computed by another function? Add the following function definitions right above `main` in `Playground.elm`.

[source,elm]
----
computeSpeed distance time =
    distance / time


computeTime startTime endTime =
    endTime - startTime
----

`computeSpeed` takes two parameters: distance covered by a spaceship and travel time. Time in turn is computed by another function called `computeTime`. Here’s how the main function looks when we delegate the calculation of speed to our newly created functions:

[source,elm]
----
main =
    Html.text (escapeEarth 11 (computeSpeed 7.67 (computeTime 2 3)))
----

Yikes! Chaining multiple function applications looks hideous and hard to read. But what if we write it this way instead:

[source,elm]
----
main =
    computeTime 2 3
        |> computeSpeed 7.67
        |> escapeEarth 11
        |> Html.text
----

Ah, much better! To compile the new code, refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`]. You should see the string “Stay in orbit.”

The nicely formatted code above is possible because Elm allows _partial_ application of functions. Let’s play with some examples in `+elm repl+` to understand what partial functions are. Create a function called multiply with two parameters in the repl.

[source,elm]
----
> multiply a b = a * b
<function>
----

When we apply it to two arguments, we get the expected result.

[source,elm]
----
> multiply 3 4
12
----

Let’s see what happens if we pass only the first argument.

[source,elm]
----
> multiply 3
<function>
----

Hmm… It returns a function instead of giving us an error. Let’s capture that function in a constant.

[source,elm]
----
> multiplyByThree = multiply 3
<function>
----

Now, let’s see what happens if we apply this intermediate function to the second (and final) argument.

[source,elm]
----
> multiplyByThree 4
12

> multiplyByThree 5
15
----

`multiplyByThree` is a partial function. When Elm sees that we haven’t given enough arguments to a function, it doesn’t complain. It simply applies the function to given arguments and returns a new function that can be applied to the remaining arguments at a later point in time. This has many practical benefits. You will see plenty of examples of partial function application throughout the book.

==== Forward Function Application

Let’s get back to that fancy `+|>+` operator that made our code look so pretty. It’s called the _forward function application operator_. Since that name is too long, the Elm community refers to it as the _pipe operator_. It is very useful for avoiding parentheses. It pipes the result from previous expression to the next one.

image:https://elmprogramming.com/images/chapter-3/3.10-function/pipe-operator.svg[]

The pipe operator takes the result from the previous expression and passes it as the last argument to the next function application. For example, the first expression in the chain above (`+computeTime 2 3+`) generates number `1` as the result which gets passed to the `computeSpeed` function as the last argument.

==== Backward Function Application

There is another operator that works similarly to `+|>+`, but in backward order. It’s called the _backward function application operator_ and is represented by this symbol: `+<|+`. Let’s deviate from our spaceship saga for a bit and create some trivial functions to try out the `+<|+` operator. Add the following function definitions right above `main` in `Playground.elm`.

[source,elm]
----
add a b =
    a + b


multiply c d =
    c * d


divide e f =
    e / f
----

`add`, `multiply`, and `divide` are functions that do exactly what their names suggest. Let’s create an expression that uses these functions. Modify the `main` function to this:

[source,elm]
----
main =
    Html.text (String.fromFloat (add 5 (multiply 10 (divide 30 10))))
----

Ugh. Even more parentheses. Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see `35`.

****
NOTE: The `add` function returns a number, but `Html.text` expects a string. That’s why we need to use the `String.fromFloat` function to convert a number into a string. We’ll cover the <<string, `String` module>> in detail later in this chapter.
****

Let’s use our knowledge of the `+|>+` operator to turn the expression in `main` into a beautiful chain.

[source,elm]
----
main =
    divide 30 10
        |> multiply 10
        |> add 5
        |> String.fromFloat
        |> Html.text
----

Let’s see how the above expression looks when we rewrite it using the `+<|+` operator.

[source,elm]
----
main =
    Html.text <| String.fromFloat <| add 5 <| multiply 10 <| divide 30 10
----

Not bad, huh? Both `+|>+` and `+<|+` operators can be used to avoid parentheses, but `+|>+` is better suited for writing pipelined code. That’s why it’s called the _“pipe”_ operator. Elm provides other higher-order helper operators like these. You can learn more about them https://package.elm-lang.org/packages/elm/core/latest/Basics#identity[here].

==== Operators are Functions Too

In Elm, all computations happen through the use of functions. As it so happens, all operators in Elm are also functions. They differ from normal functions in three ways:

===== Naming

Operators cannot have letters or numbers in their names whereas the normal functions can. Similarly, functions cannot have special characters in their names whereas the operators can.

===== Number of Arguments

Operators accept exactly two arguments. In contrast, there is no limit to how many arguments a normal function can take.

===== Application Style

Operators are applied by writing the first argument, followed by the operator, followed by the second argument. This style of application is called _infix-style_.

[source,elm]
----
> 2 + 5
7
----

Normal functions are applied by writing the function name, followed by its arguments. This style of application is called _prefix-style_.

[source,elm]
----
> add a b = a + b
<function>

> add 2 5
7
----

We can also apply operators in prefix-style if we so choose to.

[source,elm]
----
> (+) 2 5
7
----

The operators must be surrounded by parentheses. We can’t apply normal functions in infix-style, but we can create something that resembles infix-style by using `+|>+`.

[source,elm]
----
> 2 |> add 5
7
----

Custom Operators::
  Elm doesn’t allow us to define custom operators. It’s quite difficult to come up with a good operator that uses simple symbols to visually illustrate the meaning of an operation it represents. Therefore, a code base with many custom operators is generally hard to read. It’s better to use named functions instead.
+
Elm used to support custom operators prior to version `0.19`. If you are interested in further exploration, https://gist.github.com/evancz/769bba8abb9ddc3bf81d69fa80cc76b1[this document] explains the reason behind removing them in great detail.


[[let-expression]]
=== 3.11 Let Expression


When someone else reads our `escapeEarth` function’s definition, they may wonder what the numbers `11.186` and `7.67` really mean.

[source,elm]
----
escapeEarth myVelocity mySpeed =
    if myVelocity > 11.186 then
        "Godspeed"

    else if mySpeed == 7.67 then
        "Stay in orbit"

    else
        "Come back"
----

It would be nice if we could give them names. We can do that using a `let` expression. In `+src/Playground.elm+`, modify `escapeEarth` to this:

[source,elm]
----
escapeEarth myVelocity mySpeed =
    let
        escapeVelocityInKmPerSec =
            11.186

        orbitalSpeedInKmPerSec =
            7.67
    in
    if myVelocity > escapeVelocityInKmPerSec then
        "Godspeed"

    else if mySpeed == orbitalSpeedInKmPerSec then
        "Stay in orbit"

    else
        "Come back"
----

The `let` expression creates a local scope.

Scope::
  A scope is a region in a program where defined constants exist and are accessible. Constants created in a region cannot be accessed outside of that region. As soon as the program execution leaves this region all constants and values created in the region will be destroyed.

Often times, we want to define local constants and functions that we don’t want the rest of the code in our module to know about. We can define them inside a `let` expression. They won’t be visible outside the scope created by a `let` expression making them essentially private. No code outside `escapeEarth` function can access the `escapeVelocityInKmPerSec` and `orbitalSpeedInKmPerSec` constants.

image:https://elmprogramming.com/images/chapter-3/3.11-let-expression/let-expression-syntax.svg[]

Right now if a spaceship’s velocity or speed isn’t fast enough to either escape Earth’s gravity or stay in an orbit we simply tell it to come back to Earth. It would be more helpful if we could tell the spaceship where to land. Let’s create a function for that in the `let` area.

[source,elm]
----
escapeEarth myVelocity mySpeed fuelStatus =
    let
        escapeVelocityInKmPerSec =
            11.186

        orbitalSpeedInKmPerSec =
            7.67

        whereToLand fuel =
            if fuel == "low" then
                "Land on droneship"

            else
                "Land on launchpad"
    in
    if myVelocity > escapeVelocityInKmPerSec then
        "Godspeed"

    else if mySpeed == orbitalSpeedInKmPerSec then
        "Stay in orbit"

    else
        whereToLand fuelStatus
----

`escapeEarth` now takes an additional parameter called `fuelStatus`. The newly defined private function `whereToLand` checks the fuel status and tells where to land. This function is not visible outside the `let` expression. Modify `main` to apply `escapeEarth` like this:

[source,elm]
----
main =
    escapeEarth 10 6.7 "low"
        |> Html.text
----

If you refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`], you should see `+Land on droneship+`.

Strictly speaking, we didn’t have to define `whereToLand` as a function. The `fuelStatus` parameter is directly accessbile inside `whereToLand`, so there is no need to introduce the `fuel` parameter. If we remove `fuel` from `whereToLand`’s definition, it simply becomes a constant. Go ahead and make that change.

[source,elm]
----
escapeEarth myVelocity mySpeed fuelStatus =
    let
        .
        .
        whereToLand =
            if fuelStatus == "low" then
                "Land on droneship"

            else
                "Land on launchpad"
    in
    .
    .
    else
        whereToLand
----


[[case-expression]]
=== 3.12 Case Expression


Let’s say we have the weekdays being represented in numbers between `0` and `6` and we want to convert those numbers to strings (`0` = Sunday, `1` = Monday, etc.). We can use an `if` expression to do that. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
weekday dayInNumber =
    if dayInNumber == 0 then
        "Sunday"

    else if dayInNumber == 1 then
        "Monday"

    else if dayInNumber == 2 then
        "Tuesday"

    else if dayInNumber == 3 then
        "Wednesday"

    else if dayInNumber == 4 then
        "Thursday"

    else if dayInNumber == 5 then
        "Friday"

    else if dayInNumber == 6 then
        "Saturday"

    else
        "Unknown day"
----

Now let’s render `Friday` on a browser by calling the `weekday` function from `main`.

[source,elm]
----
main =
    Html.text <| weekday 5
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see `Friday`. As it stands right now, the `weekday` function looks a bit superfluous. It does nothing more than a number comparison in each conditional branch. Can we express it more succinctly? Let’s try using a `case` expression.

[source,elm]
----
weekday dayInNumber =
    case dayInNumber of
        0 ->
            "Sunday"

        1 ->
            "Monday"

        2 ->
            "Tuesday"

        3 ->
            "Wednesday"

        4 ->
            "Thursday"

        5 ->
            "Friday"

        6 ->
            "Saturday"

        _ ->
            "Unknown day"
----

Ah! Much better!

==== Case Expression Syntax

image:https://elmprogramming.com/images/chapter-3/3.12-case-expression/case-expression-syntax.svg[]

`case` works by matching an expression to a pattern. When a match is found, it evaluates the expression to the right of `+->+` and returns whatever value is produced.

Pattern Matching::
  Pattern matching is the act of checking one or more inputs against a pre-defined pattern and seeing if they match. We will explore pattern matching in much more detail in <<pattern-matching, chapter 4>>.

The expression after the keyword `case` can be anything from a simple value to a complex computation including function applications. For example, if we want to generate a hashtag for each day, we can write another function that takes a string value returned by the `weekday` function and matches it against a hashtag. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
hashtag dayInNumber =
    case weekday dayInNumber of
        "Sunday" ->
            "#SinDay"

        "Monday" ->
            "#MondayBlues"

        "Tuesday" ->
            "#TakeMeBackTuesday"

        "Wednesday" ->
            "#HumpDay"

        "Thursday" ->
            "#ThrowbackThursday"

        "Friday" ->
            "#FlashbackFriday"

        "Saturday" ->
            "#Caturday"

        _ ->
            "#Whatever"
----

Now call the `hashtag` function instead of `weekday` from `main`.

[source,elm]
----
main =
    Html.text <| hashtag 5
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see `+#FlashbackFriday+`. You might be tempted to line each arrow (`+->+`) up when writing a `case` expression like this:

[source,elm]
----
hashtag dayInNumber =
    case weekday dayInNumber of
        "Sunday"    -> "#SinDay"
        "Monday"    -> "#MondayBlues"
        "Tuesday"   -> "#TakeMeBackTuesday"
        "Wednesday" -> "#HumpDay"
        "Thursday"  -> "#ThrowbackThursday"
        "Friday"    -> "#FlashbackFriday"
        "Saturday"  -> "#Caturday"
        _           -> "#Whatever"
----

The Elm http://elm-lang.org/docs/style-guide[style guide] tells us not to do that. Although this arrangement is easier on the eye, it takes aways the ease of modification. Let’s say we need to add another day with a long name to the list of patterns. Now we need to move all the arrows. But if we arrange the code as suggested by the style guide, then it becomes much easier to modify. Although `+elm-format+` automatically reformats our code to follow the style guide, I wanted to point it out here so that you understand why a `case` expression in Elm is formatted like that.

==== Catch All Pattern

Notice how we used `_` in both examples above as the last pattern? Without it, Elm will throw an error. Go ahead and remove the line that contains `_` from the `weekday` function and refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`]. You should see the following error.

image:https://elmprogramming.com/images/chapter-3/3.12-case-expression/case-expression-error.png[]

We have to account for every single value an expression can have. Since `dayInNumber` holds an integer whose range is quite big, it’s not feasible to list all those options in our code. The `_` character works as a _catch-all-pattern_. Because of this, it’s important to place the most specific pattern at the top and the least specific at the bottom. For example, if we move `_` to the top, the `weekday` function will always return `+"Unknown day"+` no matter what number we pass in. Add the catch-all-pattern back to the `weekday` function.

[source,elm]
----
weekday dayInNumber =
    case dayInNumber of
        .
        .
        _ ->
            "Unknown day"
----

==== If vs Case Expression

Does this mean all `if` expressions can be replaced with `case`? Not necessarily. A `case` expression works by matching a pattern, whereas an `if` expression checks whether a condition is true or not. For example, the following code doesn’t really have a pattern.

[source,elm]
----
escapeEarth myVelocity mySpeed =
    if myVelocity > 11.186 then
        "Godspeed"

    else if mySpeed == 7.67 then
        "Stay in orbit"

    else
        "Come back"
----

If we attempt to re-write it with a `case` expression, we will get an error. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
escapeEarthWithCase myVelocity mySpeed =
    case (myVelocity, mySpeed) of
        (myVelocity > 11.186) ->
            "Godspeed"

        (mySpeed == 7.67) ->
            "Stay in orbit"

        _ ->
            "Come back"
----

If you refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`], you should see the following error.

image:https://elmprogramming.com/images/chapter-3/3.12-case-expression/case-if-expression-error.png[]

The reason why Elm is throwing an error is because there is no pattern to match here. All we have is a couple of disparate conditions. More importantly, the part before `+->+` has to be a pattern. It can’t be any expression. Here we are trying to compare the given velocity and speed with some number using an expression.

Go ahead and remove the `escapeEarthWithCase` function from `Playground.elm` and refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] to make sure there are no errors.

To summarize, if we have disparate conditions to check then `if` expression is a good fit. Whereas if we need to match an expression to a pattern, a `case` expression is the way to go.


[[indentation]]
=== 3.13 Indentation


Unlike most other languages, Elm doesn’t use syntactic markers such as curly brackets, parentheses, or semicolons to specify code boundaries. It uses whitespaces and indentations instead. There are situations where if we don’t place our code in a certain order or provide proper indentation, Elm will throw a syntax error. Let’s go through those one by one.

==== Function Definitions

Let’s use an example from the <<function, Function>> section earlier in this chapter to understand the implications of using incorrect orders and indentations when defining a function.

[source,elm]
----
module Playground exposing (main)

import Html


escapeEarth myVelocity mySpeed =
    if myVelocity > 11.186 then
        "Godspeed"

    else if mySpeed == 7.67 then
        "Stay in orbit"

    else
        "Come back"


main =
    Html.text <| escapeEarth 11.2 7.2
----

All Elm files begin with a `module` definition. It’s perfectly fine to add comments above the `module` definition, but no other code can go above it.

[source,elm]
----
{-
   The Playground module is used to experiment with
   various concepts in Elm programming language.
-}


module Playground exposing (main)
.
.
----

`import` lines are optional. If they’re included, they’re listed right below the `module` definition. Both `module` and `import` lines must start at the left most column. The top-level function definitions are placed below the `import` lines. They too must start at the left most column. Later, you will be introduced to other concepts in Elm such as <<type-system, `type`>> that also go below the `import` lines.

Notice how two blank lines are used to separate the definitions of `escapeEarth` and `main` functions? Because Elm doesn’t use delimiters such as curly braces to surround functions like in other mainstream languages, using only a single blank line to separate definitions can make our code less readable.

Elm borrowed this convention from https://www.python.org/[Python] — another great language. However, the `module` and `import` lines are separated with only one blank line. These spacing rules are enforced by `+elm-format+`. It is a little confusing that `+elm-format+` uses two blank lines between some definitions, and one blank line between others. Maybe that will change by the time `+1.0.0+` version is out.

At the time of this writing, `+elm-format+` uses four spaces to indent a function body. Because it’s still in beta, don’t be surprised if it ends up using two spaces instead of four when version `+1.0.0+` is out.

In the earlier sections, you were led to believe that the body of a function, `if`, `let`, and `case` expressions must be indented with at least one space. That still holds true. Syntactically speaking, all Elm cares about is an indentation with at least one space, but using more than one space improves readability of our code.

****
NOTE: If you’re interested in further exploration, https://github.com/avh4/elm-format/issues/158[here] is a vigorous debate between the Elm community members on whether to use two or four spaces for indentation. We programmers are so nitpicky, aren’t we?
****

==== If, Let, and Case Expressions

An `if` expression must be placed inside a function definition, otherwise Elm will throw an error.

[source,elm]
----
module Playground exposing (main)

import Html


-- This is invalid code


if myVelocity > 11.186 then
    "Godspeed"

else if mySpeed == 7.67 then
    "Stay in orbit"

else
    "Come back"
----

The part after `then` and final `else` should be placed on the next line indented with four spaces. It’s perfectly fine to place an `if` expression inside a `let` or `case` expression as long as they themselves are placed inside a function. We already saw an example of this in the <<let-expression, Let Expression>> section earlier. Here it is again.

[source,elm]
----
escapeEarth myVelocity mySpeed =
    let
        escapeVelocityInKmPerSec =
            11.186

        orbitalSpeedInKmPerSec =
            7.67
    in
    if myVelocity > escapeVelocityInKmPerSec then
        "Godspeed"

    else if mySpeed == orbitalSpeedInKmPerSec then
        "Stay in orbit"

    else
        "Come back"
----

The code inside the `let` area must be indented with at least one space, whereas the code inside the `in` area doesn’t need any indentation. The body of the `case` expression must also be indented with at least one space. As of this writing, `+elm-format+` uses four spaces in both cases to improve readability. The list below summarizes the indentation rules we have covered thus far.

Basic Indentation Rules::
  * `module`, `import`, and top-level `function` definitions must start at the left most column.
  * If an expression is split into multiple lines, the code that is part of that expression must be indented under that expression with at least one space.
  * Parts of the expression that are grouped together should be indented with equal number of spaces. This rule is particularly important in the `let` area.


[[string]]
=== 3.14 String


In Elm, strings are represented with double quotes:

[source,elm]
----
> "Pretzels"
"Pretzels" : String
----

Characters are represented with single quotes:

[source,elm]
----
> 'p'
'p' : Char
----

Character literals must contain exactly one character. Therefore, these expressions are not allowed in Elm: `+'abc'+`, `+''+`. Strings can have as many characters as we want in them.

==== Multiline Strings

Multi-line strings are created using `+"""+`. That’s triple quotes. Here’s how we can insert a multi-line string in repl:

[source,elm]
----
> """ \
|   It became very clear to me sitting out there today \
|   that every decision I've made in my entire life has \
|   been wrong. My life is the complete "opposite" of \
|   everything I want it to be. Every instinct I have, \
|   in every aspect of life, be it something to wear, \
|   something to eat - it's all been wrong. \
|   """
----

We don’t need to add `+\+` to the end of each line when we create a multi-line string in a file though. Define a constant called `revelation` right above `main` in `Playground.elm` file.

[source,elm]
----
revelation =
    """
    It became very clear to me sitting out there today
    that every decision I've made in my entire life has
    been wrong. My life is the complete "opposite" of
    everything I want it to be. Every instinct I have,
    in every aspect of life, be it something to wear,
    something to eat - it's all been wrong.
    """
----

Now pass the `revelation` constant to `Html.text` in `main`.

[source,elm]
----
main =
    Html.text revelation
----

Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`]. You should see the profound revelation https://en.wikipedia.org/wiki/George_Costanza[George Costanza] had when he was looking at the ocean on a dreary day.

We can use both single and double quotes inside a multi-line string. Using a single quote inside a single-line string is fine, but we need to escape the double quotes with `+\+`.

[source,elm]
----
> "Michael Scott's Rabies Awareness \"Fun Run\" Race for the Cure"
"Michael Scott's Rabies Awareness \"Fun Run\" Race for the Cure"
----

`+\+` tells Elm that the double quotes immediately after it aren’t there to end the string. Similarly, a single quote must be escaped inside a character literal.

[source,elm]
----
> '\''
'\''
----

How do we escape the backslash itself? With another backslash.

[source,elm]
----
> '\\'
'\\'
----

==== Calculating Length

To calculate a string’s length, we can use the `length` function from https://package.elm-lang.org/packages/elm/core/latest/String[String] module.

[source,elm]
----
> String.length "Creed Bratton"
13

> String.length ""
0
----

Up until now, we have been creating only custom functions by explicitly defining them. Going forward we will make heavy use of built-in functions like `String.length`, which is a part of Elm’s standard library.

Standard Library::
  Most programming languages come with a standard library — a collection of functions and values most likely written in the same language. Elm follows that trend by providing a standard library of its own. All functions and values in Elm’s standard library are grouped into modules based on what type of data they operate on. For example, the `String` module contains functions for manipulating strings. Similarly, the `List` module provides functions for modifying lists. There are many more modules in the standard library for working with almost any type of data, for example https://package.elm-lang.org/packages/elm/core/latest/Dict[Dict], https://package.elm-lang.org/packages/elm/core/latest/Set[Set], and https://package.elm-lang.org/packages/elm/time/latest/Time[Time] to name a few. Various math and function helper operators we saw earlier in this chapter are inside the https://package.elm-lang.org/packages/elm/core/latest/Basics[Basics] module.
+
Modules are further grouped into packages. `String`, `List`, and `Basics` all belong to a package called https://package.elm-lang.org/packages/elm/core/latest[Core], which comes pre-loaded with the Elm Platform. Only the most essential packages are included in Elm Platform. Others are available for download from the http://package.elm-lang.org/[online catalog].

When an `+elm repl+` session is started, the `String` module gets loaded automatically. Otherwise we would have to explicitly import it like this:

[source,elm]
----
> import String
----

`+elm repl+` automatically loads modules that are most frequently used in Elm. When using a function, it’s a good practice to prefix it with a module name for two reasons:

* It tells us where the function came from.
* It prevents name clashes between functions from different modules.

If we want to, we can expose the `length` function so that we don’t have to use the prefix.

[source,elm]
----
> import String exposing (length)

> length "Angela Martin"
13
----

We used a slightly different syntax to import the `String` module here. The `+exposing (length)+` part tells Elm to expose the `length` function so that we don’t have to prefix it with `String`. As it happens, the `List` module also provides a function called `length`. What will happen if we expose that function too? Let’s find out.

****
NOTE: In Elm, a list is a data structure for storing multiple values. We can create one with square brackets like this: `+[ "Titan", "Encaladus" ]+`. We will cover lists in detail <<list, later in this chapter>>.
****

[source,elm]
----
> import List exposing (length)

> length [ 1, 2, 3 ]

----------------- TYPE MISMATCH ------------------
The 1st argument to `length` is not what I expect:

6|   length [ 1, 2, 3 ]
            ^^^^^^^^^^^
This argument is a list of type:

    List number

But `length` needs the 1st argument to be:

    String.String
----

Even though we exposed the `length` function from `List`, Elm still thinks we are trying to use `String.length`. To avoid this confusion, we need to be specific by prefixing the module name.

[source,elm]
----
> String.length "Angela Martin"
13

> List.length [ 1, 2, 3 ]
3
----

===== Checking Emptiness

The `String` module provides a function called `isEmpty` that tells us whether a given string is empty or not.

[source,elm]
----
 > String.isEmpty ""
True

> String.isEmpty "Kevin Malone"
False
----

This is more readable than using the `length` function, where we have to explicitly compare the length to `0`.

[source,elm]
----
> String.length "Kevin Malone" == 0
False
----

==== Combining Strings

`pass:[++]` operator is used to concatenate two strings.

[source,elm]
----
> "These pretzels are " ++ "makin' me thirsty!"
"These pretzels are makin' me thirsty!"
----

****
NOTE: We don’t need to prefix operators with a module name.
****

We can’t use `pass:[++]` to combine characters or numbers though. These will throw errors:

[source,elm]
----
> 'p' ++ 'r' -- Error
> 42 ++ 10 -- Error
----

One way to combine characters is by converting them to strings first. We can use the `fromChar` function to do that.

[source,elm]
----
> (String.fromChar 'p') ++ (String.fromChar 'r')
"pr"
----

We can also combine two strings using the `append` function.

[source,elm]
----
> String.append "These pretzels are " "makin' me thirsty!"
"These pretzels are makin' me thirsty!"
----

`append` is a special case of `pass:[++]` operator, which puts two _appendable_ things such as strings and lists together.

===== Concatenating multiple strings

We can also combine more than two strings using the `pass:[++]` operator.

[source,elm]
----
> "Bears. " ++ "Beats. " ++ "Battlestar Gallactica."
"Bears. Beats. Battlestar Gallactica."
----

Technically speaking, the `pass:[++]` operator combines only two strings. In our example above, Elm first applies `pass:[++]` to `+"Bears. "+` and `+"Beats. "+` resulting in `+"Bears. Beats. "+`. It then applies `pass:[++]` with `+"Battlestar Gallactica."+` as a second argument to produce the final string. We can also use `append` to combine more than two strings. Although it tends to get a bit verbose.

[source,elm]
----
> String.append (String.append "Butter shave, " "Voice, ") "Serenity now"
"Butter shave, Voice, Serenity now"
----

Another way of concatenating multiple strings is by using the `concat` function which requires us to put individual strings into a list.

[source,elm]
----
> String.concat [ "Bears. ", "Beats. ", "Battlestar Gallactica." ]
"Bears. Beats. Battlestar Gallactica."
----

Notice how we included the space between words as part of the individual strings themselves. That looks awkward. If we use the `join` function instead, we don’t have to do that.

[source,elm]
----
> String.join " " [ "Bears.", "Beats.", "Battlestar Gallactica." ]
"Bears. Beats. Battlestar Gallactica."
----

`join` takes two parameters:

* A separator that separates individual strings when they all get combined.
* A list of strings.

The separator can be anything we want.

[source,elm]
----
> String.join "/" [ "Bears.", "Beats.", "Battlestar Gallactica." ]
"Bears./Beats./Battlestar Gallactica."

> String.join " thatswhatshesaid " [ "Bears.", "Beats.", "Battlestar Gallactica." ]
"Bears. thatswhatshesaid Beats. thatswhatshesaid Battlestar Gallactica."
----

==== Splitting a String

We can use the `split` function to break a string into multiple parts. It’s the exact opposite of `join`.

[source,elm]
----
> String.split " " "Bears. Beats. Battlestar Gallactica."
["Bears.","Beats.","Battlestar","Gallactica."]

> String.split "/" "Bears./Beats./Battlestar Gallactica."
["Bears.","Beats.","Battlestar Gallactica."]

> String.split " thatswhatshesaid " "Bears. thatswhatshesaid Beats. thatswhatshesaid Battlestar Gallactica."
["Bears.","Beats.","Battlestar Gallactica."]
----

Did you notice that in the first example above, when we split on `+" "+`, we end up with four strings, while in the other examples the result is three strings? That’s because there is a space between the words “Battlestar” and “Gallactica.” If we wanted to get a result of three strings, we’d have to be more specific on what to split on like the following example:

[source,elm]
----
> String.split ". " "Bears. Beats. Battlestar Gallactica."
["Bears","Beats","Battlestar Gallactica."]
----

==== Reversing a String

Let’s write a function that tells us whether or not a word is a palindrome. Palindrome is a word or groups of words that read the same forward as backward.

[source,elm]
----
> palindrome word = word == String.reverse word
<function>
----

We reverse the word using the `reverse` function and compare it with the original. If they both are same, we return `True`. Now let’s have some fun with this function.

[source,elm]
----
> palindrome "tacocat"
True

> palindrome "hannah"
True

> palindrome "palindrome"
False

> palindrome "As I pee, sir, I see Pisa"
False
----

Unfortunately, our function is too simple to recognize the last example as a palindrome. See if you can improve it to return `True` for that phrase too. Also, why is the word `+"palindrome"+` not a palindrome?

==== Filtering a String

Let’s say we need to do a background check on every candidate that wants to join the Enceladus Program for exploring one of Saturn’s moons. So we have asked the candidates to give us their social security number. Someone miscommunicated and asked them to enter it like this: 222-11-5555 when in fact our system doesn’t accept dashes. We can use the `filter` function to get rid of them, but we can’t just apply it like this:

[source,elm]
----
> String.filter '-' "222-11-5555"

----------------- TYPE MISMATCH -------------------
The 1st argument to `filter` is not what I expect:

7|   String.filter '-' "222-11-5555"
                   ^^^
This argument is a character of type:

    Char

But `filter` needs the 1st argument to be:

    Char -> Bool
----

It expects a function that takes a character and returns a boolean. Let’s create a function which does exactly that.

[source,elm]
----
> isValid char = char /= '-'
<function>

> isValid '-'
False

> isValid '2'
True
----

****
NOTE: In mathematics, a function that takes a value and returns a boolean is called a _predicate function_. You will often hear functions like `isValid` being called a _predicate_.
****

If the character is `-` we return `False`, otherwise `True`. Let’s give the `isValid` function to `filter` and see what happens.

[source,elm]
----
> String.filter isValid "222-11-5555"
"222115555"
----

Aha! The dashes are gone. The following diagram illustrates how `filter` works.

image:https://elmprogramming.com/images/chapter-3/3.14-string/filter-string.svg[]

`filter` fed each character from the string we provided into `isValid`. If it returned `True`, the character was kept, otherwise it was discarded. `filter` is a higher-order function because it takes another function as an argument. The String module provides many more higher-order functions like this such as `map`. We won’t cover them all here, but you should check them out from the official https://package.elm-lang.org/packages/elm/core/latest/String[documentation].

==== Anonymous Function

Sometimes its desirable to inline the function that determines whether or not a value should be filtered instead of defining it separately as shown below.

[source,elm]
----
> String.filter (\char -> char /= '-') "222-11-5555"
"222115555"
----

This time we gave `filter` a function that doesn’t have a name. It’s called an _anonymous function_. The following diagram explains various components of an anonymous function.

image:https://elmprogramming.com/images/chapter-3/3.14-string/anonymous-function.svg[]

Anonymous functions are quite useful for writing quick inline functions. We will see more examples later. We can actually re-write the `isValid` function we saw earlier like this:

[source,elm]
----
> isValid = \char -> char /= '-'
<function>

> isValid '-'
False
----

As it turns out a function name is just a constant pointing to an anonymous function definition.

==== Formatting a String

We often need to convert a string to all upper or lower case. The `String` module provides just the functions we need.

[source,elm]
----
> String.toUpper "I declare bankruptcy!"
"I DECLARE BANKRUPTCY!"

> String.toLower "Shhh. Be quiet."
"shhh. be quiet."
----

We can also trim unnecessary whitespaces from a string.

[source,elm]
----
> String.trim "    A band of backwoods mail-hating survivalists   \n"
"A band of backwoods mail-hating survivalists"

> String.trimLeft "    A band of backwoods mail-hating survivalists   \n"
"A band of backwoods mail-hating survivalists   \n"

> String.trimRight "   A band of backwoods mail-hating survivalists   \n"
"   A band of backwoods mail-hating survivalists"
----

If we want to stuff more characters into a string, the `String` module has functions for that too.

[source,elm]
----
> String.pad 10 ' ' "5"
"     5    "

> String.pad 10 '*' "5"
"*****5****"
----

The `pad` function pads both sides of a string with a character of our choice until it reaches the given length: `10`. We can also pad only one side if we want.

[source,elm]
----
> String.padLeft 10 ' ' "5"
"         5"

> String.padRight 10 ' ' "5"
"5         "

> String.padLeft 10 '*' "5"
"*********5"

> String.padRight 10 '*' "5"
"5*********"
----

==== Substrings

===== Finding Substrings

We can check for substrings using the `contains` function.

[source,elm]
----
> String.contains "believe" "It’s not a lie if you believe it."
True

> String.contains "George" "Fires people like it's a bodily function!"
False
----

We can also find out if a string starts or ends with a certain substring.

[source,elm]
----
> String.startsWith "Kruger" "Kruger Industrial Smoothing"
True

> String.endsWith "LeBaron" "1989 LeBaron"
True
----

We can even pinpoint where exactly the substring lies with the `indexes` function.

[source,elm]
----
> String.indexes "on" "They just write it off."
[]

> String.indexes "write" "They just write it off."
[10]

> String.indexes "write" "How is it a write-off? They just write it off."
[12,33]
----

`indexes` returns an empty list when it can’t find a substring. Otherwise it returns an index where the substring starts for each occurrence. And remember when we count indexes in Elm, we have to start from `0`. We can also use the `indexes` function on multi-line strings.

[source,elm]
----
> String.indexes "quitter" """ \
|   I'm a great quitter. It's one of the few things \
|   I do well. I come from a long line of quitters. \
|   My father was a quitter, my grandfather was a \
|   quitter... I was raised to give up. \
|   """
[18,97,128,163]
----

It’s important to note that most functions in the `String` module for locating substrings are case-sensitive.

[source,elm]
----
> String.contains "Believe" "It’s not a lie if you believe it."
False

> String.endsWith "Lebaron" "1989 LeBaron"
False

> String.indexes "Write" "They just write it off."
[]
----

===== Extracting Substrings

Now that we know how to look for substrings, let’s go ahead and extract them using the `slice` function.

[source,elm]
----
> String.slice 0 5 "Bears. Beets. Battlestar Galactica."
"Bears"

> String.slice 7 12 "Bears. Beets. Battlestar Galactica."
"Beets"

> String.length "Bears. Beets. Battlestar Galactica."
35

> String.slice 14 35 "Bears. Beets. Battlestar Galactica."
"Battlestar Galactica."
----

`slice` takes start and end indices of the substring we are interested in. But there is a catch. It stops at the character right before the end index. When we extracted “Bears”, we had to give 5 as the end index even though the last character on that word (`s`) is located at index `4`. We can also count backwards like this:

[source,elm]
----
> String.slice -21 -1 "Bears. Beets. Battlestar Galactica."
"Battlestar Galactica" : String

> String.slice -28 -23 "Bears. Beets. Battlestar Galactica."
"Beets"

> String.slice -35 -30 "Bears. Beets. Battlestar Galactica."
"Bears"
----

Counting backwards can be confusing. Because of how the end index works, we can’t extract the last dot (`+.+`) if we count from the back. `+-1+` is the index of the last dot, but `slice` only extracts characters up until the index before it. If we try to use `0` as the end, we get an empty string. Let’s just stick with the positive indices.

[source,elm]
----
> String.slice -21 0 "Bears. Beets. Battlestar Galactica."
""
----

===== Replacing Substrings

The `String` module doesn’t provide an easy way to replace substrings yet. We will have to use regular expressions for that. The <<regular-expression, next section>> is all about them.

We have only covered some of the most commonly used functions for manipulating strings. The `String` module provides plenty more functions. You can learn all about them https://package.elm-lang.org/packages/elm/core/latest/String[here].


[[regular-expression]]
=== 3.15 Regular Expression


So far we have been able to extract a substring by specifying its start and end locations within a string like this:

[source,elm]
----
> String.slice 0 5 "Bears. Beets. Battlestar Galactica."
"Bears"
----

What if we need something more sophisticated than this? Let’s say we want to extract the launch time of https://en.wikipedia.org/wiki/Apollo_11[Apollo 11] _(09:32 a.m.)_ hiding inside the following text.

[source]
----
On July 16, 1969, the massive Saturn V rocket lifted
off from NASA's Kennedy Space Center at 09:32 a.m. EDT.
Four days later, on July 20, Neil Armstrong and Buzz Aldrin
landed on the Moon.
----

It’s possible to accomplish this by using string functions, but it’s also tedious. With regular expressions it’s a piece of cake once we know how to define a pattern. Let’s install the `+elm/regex+` package which contains functions and values for working with regular expressions. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install elm/regex
----

Answer `Y` and start an `+elm repl+` session. Now import the `Regex` module which resides in the `+elm/regex+` package.

[source,elm]
----
> import Regex
----

Next, we’ll define a pattern for `+09:32 a.m.+` and use various functions in the `Regex` module to check whether that substring exists in the text above. Don’t worry about understanding the code below yet. It’s there to give you an idea of how regular expressions work in Elm. We’ll <<regular-expression, go over it in detail>> after we understand the basics of regular expression.

[source,elm]
----
> pattern = "\\d\\d:\\d\\d (a\\.m\\.|p\\.m\\.)"
"\\d\\d:\\d\\d (a\\.m\\.|p\\.m\\.)"

> maybeRegex = Regex.fromString pattern
Just {}

> regex = Maybe.withDefault Regex.never maybeRegex
{}

> apollo11 = """ \
|   On July 16, 1969, the massive Saturn V rocket \
|   lifted off from NASA's Kennedy Space Center at \
|   09:32 a.m. EDT. Four days later, on July 20, Neil \
|   Armstrong and Buzz Aldrin landed on the Moon. \
|   """

> Regex.contains regex apollo11
True
----

==== Regular Expression Basics

A regular expression (regex) is a pattern for matching character combinations in a string. It is an incredibly powerful tool for working with strings, yet the basic concepts behind it aren’t that complex. Before we attempt to understand the code above, let’s get familiar with the basics of regular expressions first. After that we will learn how to use them in Elm.

****
NOTE: If you already know how regular expressions work, feel free to skip to the <<regular-expression, Regular Expressions in Elm>> section below.
****

===== Matching a single character

In a regular expression, letters and numbers match themselves. For example, `A` will match `A` and `1` will match `1`. All regular expressions are case-sensitive, so `A` won’t match `a`.

===== Matching multiple characters

To match multiple characters, we just need to repeat the character. `AAA` will match three `A`s in a row and `123` will match the number `123`.

===== Dot character

Instead of repeating a character, we can use the dot character to match multiple characters like this: `+A..+`. The dot character matches a single character. A character can be a letter, number, or any special character. So `+A..+` will match `AAA`, `ABB`, `ACC`, `ABC`, and so on. It will also match `A12`, `+A$3+`, and `+A^%+`. Punctuation characters such as `+.+` allow us to create patterns instead of explicitly specifying all characters in a substring.

The punctuation characters have special meanings in a regular expression. So if we want to match a literal dot, we must precede it with a backslash which turns off dot’s special meaning allowing regex to treat it as a regular character. Here are some examples that match a literal dot.

* `\.` will match a literal dot.
* `Dr\. Strange` will match _Dr. Strange_.
* `Kevin Malone, Esq\.` will match _Kevin Malone, Esq._
* `7\.67` will match _7.67_

===== Matching a set

So far we have focused on matching a specific character. What if we want to match the characters of same kind, for example only numbers? We can use a set for that. Sets are created by wrapping the characters in square brackets. Here are some examples:

* `[0123456789]` will match a single digit.
* `[aeiou]` will match a single lowercase vowel.
* `[AEIOU]` will match a single uppercase vowel.

It’s important to note that a set will match only a single character. For example `[Pp]` will match a single character (either `P` or `p`), not `PP`, `pp`, or `Pp`. If we want to match more than one character, we can just repeat the set like this: `[Pp][Pp]` and it will match all of these combinations: `PP`, `Pp`, `pp`, `pP`.

One of the reasons why regular expressions are so powerful is because we can build more and more complex patterns by progressively combining different kinds of expressions.

===== Using ranges to make sets more succinct

Sets don’t scale well. For example, if we want to match two lowercase letters, we will have to use this: `[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz]`. Yikes! This is where a range comes handy. Instead of typing each element in a set, we just define a range. We can rewrite that super long regex with ranges like this: `[a-z][a-z]`. All we need to do is specify the beginning and end of a sequence of characters separated by a dash.

Similarly, `[0-9]` will match any digit. And `[A-Za-z0-9_]` will match any word character (letter, number, or underscore). Since certain character sets are used often, regex provides a series of shorthands for representing them. Here are some examples:

* `\d` will match any digit. It is short for `[0-9]`.
* `\w` will match any word character. It is short for `[A-Za-z0-9_]`.
* `\s` will match any whitespace character. It is short for `[\t\r\n\f]`.
* `\s\d` will match a whitespace character followed by a digit.
* `[\da-f]` will match a hexadecimal digit. It is short for `[0-9a-f]`. Here we combined a shorthand with a range. We can combine expressions however we want.

===== Matching alternatives

Sometimes we need to match this character or that character. We can use a vertical bar for that. Here are some examples:

* `+X|Y+` will match either `X` or `Y`.
* `+EST|PST+` will match either `EST` or `PST`.
* `+Jim|Pam+` will match the name of one of the two biggest pranksters in https://en.wikipedia.org/wiki/Dunder_Mifflin[Dunder Mifflin’s] history: `Jim` or `Pam`.
* `+am|a\.m\.|pm|p\.m\.+` will match `am` or `+a.m.+`, or `pm` or `+p.m.+`
* `+[0-9]|[a-zA-Z]+` will match a digit or a letter.

===== Matching zero or more characters with asterisk

Asterisk (`+*+`) is probably the most powerful character in a regular expression. Like the dot character, it has a special meaning. It matches zero or more of the thing that came just before it. Let’s see some examples.

* `+a*+` will match `a`. It will also match `aa` or `aaa` or `aaaa` or `aaaaa` and so on. Here `a` is the thing that came before `+*+`. So the pattern will match zero or more `a`s. Because of that it will also match an empty string.
* `+ab*+` will match `a`, `ab`, `abb`, `abbb`, `abbbb`, etc.

The asterisk doesn’t have to be at the end. We can put it anywhere we want.

* `+a*b+` will match `b`, `ab`, `aab`, `aaab`, `aaaab`, etc.
* `+Cree*d+` will match `Creed`, `Creeed`, `Creeeed`, `Creeeeed`, etc.

We can’t put it in the front though because then there won’t be anything to repeat. Since regular expressions don’t put any limitations on how we combine expressions, we can use `+*+` with sets or ranges too.

* `+[0-9]*+` will match any number of digits.
* `+[a-z]*+` will match any number of lowercase letters.
* `+[a-zA-Z0-9_]*+` will match any number of word characters (letter, number, or underscore).

We can even combine `+*+` with special shorthands like this:

* `+\d*+` will match any number of digits.
* `+\w*+` will match any number of word characters.
* `+\s*+` will match any number of white spaces.

===== Mother of all regular expressions

Remember, earlier I said `+*+` is probably the most powerful character in a regular expression. There is a reason for that. If we combine it with the dot character, we can create the mother of all regular expressions: `+.*+`. It will match any number of any characters. Basically, it will match anything. That is because the dot matches a single character (doesn’t matter what character it is) and the asterisk matches any number of characters represented by the dot. If it matches everything, how can it be useful? Let’s see some examples:

* `+.*Kramer+` will match the name of anyone whose last name is _Kramer_.
* `+Cosmo.*+` will match the name of anyone whose first name is _Cosmo_.
* `+.*Sacamano.*+` will match the name that has _Sacamano_ somewhere in it.

That should be enough basics about regular expressions for you to feel comfortable with the examples shown below.

****
NOTE: There is so much more to regular expressions. We barely scratched the surface here. If you are interested in exploring them further, there are plenty of resources online including https://regex101.com/[tools for building and testing complex regular expressions].
****

==== Regular Expressions in Elm

Now that we have the basics of regular expressions down, it’s time to understand that glorious pattern we wrote earlier for extracting the launch time of Apollo 11. Here is that code again:

[source,elm]
----
> import Regex

> pattern = "\\d\\d:\\d\\d (a\\.m\\.|p\\.m\\.)"
"\\d\\d:\\d\\d (a\\.m\\.|p\\.m\\.)"

> maybeRegex = Regex.fromString pattern
Just {}

> regex = Maybe.withDefault Regex.never maybeRegex
{}

> apollo11 = """ \
|   On July 16, 1969, the massive Saturn V rocket \
|   lifted off from NASA's Kennedy Space Center at \
|   09:32 a.m. EDT. Four days later, on July 20, Neil \
|   Armstrong and Buzz Aldrin landed on the Moon. \
|   """

> Regex.contains regex apollo11
True
----

Let’s go through it step-by-step.

*Step 1:* Start by importing the `Regex` module.

[source,elm]
----
> import Regex
----

Unlike the `String` module, `Regex` doesn’t come preloaded with the Elm Platform. That’s why we had to install the `+elm/regex+` package separately. For the rest of the examples in this section, we will assume that `Regex` is already imported.

*Step 2:* Define a pattern that matches the time _(09:32 a.m.)_ we’re looking for.

[source,elm]
----
> pattern = "\\d\\d:\\d\\d (a\\.m\\.|p\\.m\\.)"
----

The following diagram illustrates how the pattern above matches _09:32 a.m._.

image:https://elmprogramming.com/images/chapter-3/3.15-regular-expression/regular-expression-for-time.svg[]

\ vs \\::
  When we were learning the basics of regular expressions earlier, we used only one `+\+` to either use a special shorthand or escape a dot like this: `+\d+` and `+\.+`. Why then do we need two `+\+`s in Elm code? That’s because `+\+` has a special purpose in Elm — escape other characters. When you place it before another character, it removes the second character’s special Elm meaning and lets it be a regular character instead.
+
If you recall from the <<string, String>> section earlier, when we used a double quote inside a single-line string, we had to escape it like this so the string wouldn’t end early: `+"Michael Scott's Rabies Awareness \"Fun Run\" Race for the Cure"+`.
+
If you want to use a literal `+\+`, it needs to be escaped just like double quotes do. Put two `+\\+` in a row and Elm will understand that you want to use the literal `+\+` character. If you use just one `+\+` Elm will think you are telling it to remove the next character’s special Elm meaning.

*Step 3:* Create a regular expression by passing `pattern` to the `Regex.fromString` function.

[source,elm]
----
> maybeRegex = Regex.fromString pattern
Just {} : Maybe Regex
----

Not all strings are valid regex patterns. That’s why the `fromString` function returns a `Maybe` value.

Maybe::
  When Elm cannot guarantee a value, it returns a data structure called `Maybe`. If the value is present, it’s wrapped inside `Just`, otherwise `Nothing` is returned. `Just` and `Nothing` are members of the `Maybe` type. This simple concept is at the heart of writing incredibly robust applications in Elm. The next chapter will cover `Maybe` in much more detail. Until then you can think of `Maybe` as a container that can hold at most one value.
+
image:https://elmprogramming.com/images/chapter-3/3.15-regular-expression/maybe-container.svg[]

*Step 4:* Extract the regular expression inside `Maybe` container using the `Maybe.withDefault` function.

[source,elm]
----
> regex = Maybe.withDefault Regex.never maybeRegex
{}
----

The following diagram illustrates how `Maybe.withDefault` works.

image:https://elmprogramming.com/images/chapter-3/3.15-regular-expression/maybe-withDefault-flowchart.svg[]

*Step 5:* Define the string that contains the launch time of Appolo 11 (_09:32 a.m._).

[source,elm]
----
> apollo11 = """ \
|   On July 16, 1969, the massive Saturn V rocket \
|   lifted off from NASA's Kennedy Space Center at \
|   09:32 a.m. EDT. Four days later, on July 20, Neil \
|   Armstrong and Buzz Aldrin landed on the Moon. \
|   """
----

*Step 6:* Use the `Regex.contains` function to check if `apollo11` has any substrings that match the `pattern` defined in step 2.

[source,elm]
----
> Regex.contains regex apollo11
True
----

****
NOTE: The `String` module also has a function named `contains` which works differently than `Regex.contains`. This is the second time we encountered two functions with the same name from different modules. This is quite common in Elm. In addition to grouping similar functions, a module also acts as a namespace. Therefore, `String.contains` and `Regex.contains` are two completely separate functions.
****

===== Extracting a Substring

We set out to extract the substring _09:32 a.m._, but all we have done so far is verify that it exists. To extract it, we will use the `Regex.find` function which is much more powerful than `String.slice` explained in the <<string, Substrings>> section. `Regex.find` and `Regex.contains` both take the exact same arguments:

*1.* A regular expression pattern that represents a substring.

*2.* Original string where the substring is hiding.

[source,elm]
----
> launchTimes = Regex.find regex apollo11
----

The output is easier to read if it’s formatted like this:

[source,elm]
----
[
    { index = 103
    , match = "09:32 a.m."
    , number = 1
    , submatches = [Just "a.m."] 
    }
]
----

`Regex.find` doesn’t return just the substring we’re looking for. It returns a list of records each containing information about the matches.

Record::
  For now, you can think of a record as a collection of key value pairs. We will cover it in detail later in the <<record, Record>> section.

As the output above shows, `Regex.find` returns four pieces of information about each match it found:

* *index:* The index of the matched substring in the original string.
* *match:* The substring we are looking for.
* *number:* If multiple substrings are found, `Regex.find` labels each match with a number starting at one. The first match is labeled `1`, the second is labeled `2`, and so on. This number will be important when replacing all occurrences of a substring later.
* *submatches:* `Regex.find` also looks for substrings that match any subpattern included inside the original pattern. In our case, the substring *“a.m.”* matches the subpattern `+(a\\.m\\.|p\\.m\\.)+`. All submatches are wrapped inside `Just`. The examples in this section don’t take advantage of submatches, so it’s safe to ignore them for now.

We are one more step away from extracting our sneaky substring friend. We just need to figure out a way to get to that `match` key inside the record. We will use a function called `List.map` for that.

[source,elm]
----
> List.map (\launchTime -> launchTime.match) launchTimes
["09:32 a.m."]
----

Finally, we have our substring. Well, it’s still wrapped in a list, but we will have to wait until the <<list, next section>> to find out how to free it from the clutches of `List`.

List.map::
  `List.map` creates a new list with the results of applying a provided function to every element in the original list. Just like the <<string, `String.filter`>> function we saw in the previous section, we give it an <<string, anonymous function>> that reads the value stored in `match` key. We’ll cover it in detail in the <<list, Mapping a List>> section.

===== Finding Multiple Occurrences of a Substring

Let’s see an example of a string that has multiple occurrences of a substring we’re looking for.

[source,elm]
----
> pattern = "quitter"
"quitter"

> maybeRegex = Regex.fromString pattern
Just {}

> regex = Maybe.withDefault Regex.never maybeRegex
{}

> string = """ \
|   I'm a great quitter. It's one of the few things \
|   I do well. I come from a long line of quitters. \
|   My father was a quitter, my grandfather was a \
|   quitter... I was raised to give up. \
|   """

> Regex.find regex string
...
----

Here’s the output after some formatting:

[source,elm]
----
[
  { index = 16, 
    match = "quitter", 
    number = 1, 
    submatches = [] 
  },
  { index = 93, 
    match = "quitter", 
    number = 2, 
    submatches = [] 
  },
  { index = 122, 
    match = "quitter", 
    number = 3, 
    submatches = [] 
  },
  { index = 155, 
    match = "quitter", 
    number = 4, 
    submatches = [] 
  }
]
----

`Regex.find` found four occurrences of the substring `+"quitter"+`. Notice how the value for `number` key is incremented for each match.

===== Replacing a Substring

Although https://en.wikipedia.org/wiki/George_Costanza[George] likes to brag about how good of a quitter he is, let’s make him a go-getter for once. We’ll replace all occurrences of the substring `+"quitter"+` with `+"go-getter"+` in the original string. To do that we will need to use the `Regex.replace` function.

[source,elm]
----
> Regex.replace regex (\_ -> "go-getter") string
...
----

Here’s how the output looks after some formatting:

[source,elm]
----
"I'm a great go-getter. It's one of the few things
I do well. I come form a long line of go-getters.
My father was a go-getter, my grandfather was a
go-getter... I was raised to give up."
----

`+\n+` characters and extra spaces have been removed to make the output look nicer. In the original output, you’ll see an extra space and `+\n+` in the beginning. That’s because when we defined the `string` constant with multi-line syntax, we used a space and `+\n+` to make the code look nicer.

[source]
----
> string = """ \
|   I'm a great quitter. It's one of the few things \
...
----

We could have just begun our `string` in the first line like this:

[source]
----
> string = """I'm a great quitter. It's one of the few things \
...
----

The `Regex.replace` function takes three arguments:

*1.* A regular expression that contains the pattern for matching the substring we want to replace.

*2.* A function that takes the matched substring as an argument and returns a replacement. Notice how we used `_` in place of a parameter name inside the anonymous function. Since our function simply returns a new substring (`+"go-getter"+`) and doesn’t modify the original substring (`+"quitter"+`) in any form, we are not interested in the argument. By using `_`, we are essentially ignoring the argument.

*3.* The original string that contains the substring we want to replace.

image:https://elmprogramming.com/images/chapter-3/3.15-regular-expression/regex-replace-syntax.svg[]

===== Splitting a String

In the <<string, Splitting a String>> section earlier, we learned how to split a string by using the `String.split` function. That function is limited to splitting a string based only on a separator. What if we need to split a string using a complex pattern? For example, the following string contains two instances of time: _09:32_ and _10:56_

[source,elm]
----
> string = """On July 16, 1969, the massive Saturn \
|   V rocket lifted off from NASA's Kennedy Space Center \
|   at 09:32 a.m. EDT. Four days later, on July 20 at \
|   10:56 p.m. EDT, Neil Armstrong and Buzz Aldrin landed \
|   on the Moon. \
|   """
----

Let’s say we want to split it right where the times appear into three substrings like this:

[source,elm]
----
"On July 16, 1969, the massive Saturn V rocket lifted
off from NASA's Kennedy Space Center at ",

" a.m. EDT. Four days later, on July 20 at",

" p.m. EDT, Neil Armstrong and Buzz Aldrin landed on the Moon."
----

Not sure why we would arbitrarily split a string like that, but if we do we will need something more flexible than `String.split`. As it so happens, the `Regex` module also provides a function called `split` which uses a regular expression pattern to break a string into a list of substrings. Let’s try it out.

[source,elm]
----
> pattern = "\\d\\d:\\d\\d"
"\\d\\d:\\d\\d"

> maybeRegex = Regex.fromString pattern
Just {}

> regex = Maybe.withDefault Regex.never maybeRegex
{}

> Regex.split regex string
...
----

Here’s the output after some formatting:

[source,elm]
----
[
  "On July 16, 1969, the massive Saturn \nV rocket lifted off from NASA's Kennedy Space Center \nat ",

  " a.m. EDT. Four days later, on July 20 at \n",

  " p.m. EDT, Neil Armstrong and Buzz Aldrin landed \non the Moon. \n"
]
----

===== Removing Case Sensitivity

Regular expressions are case-sensitive by default. If we want to make them case-insensitive, we need to use the `Regex.fromStringWith` function to create a regex. Let’s try it out.

[source,elm]
----
> pattern = "phoenix"
"phoenix"

> options = { caseInsensitive = True, multiline = False }
{ caseInsensitive = True, multiline = False }

> maybeRegex = Regex.fromStringWith options pattern
Just {}

> regex = Maybe.withDefault Regex.never maybeRegex
{}

> Regex.contains regex "I'm like the Phoenix, rising from Arizona."
True
----

`Regex.fromStringWith` takes an options record that not only lets us specify case sensitivity but also the multiline status.

We covered almost everything in the `Regex` module, but you can still check out its https://package.elm-lang.org/packages/elm/regex/latest/[full documentation] to learn more.


[[list]]
=== 3.16 List


So far we have only seen how to store a single value in a data structure. To store multiple values, we can use one of the following collections Elm provides: `List`, `Array`, `Tuple`, or `Record`. This section covers list. The rest will be covered in successive sections.

==== Creating a List

In Elm, a list is a data structure for storing multiple values of the _same_ kind. List is one of the most used data structures in Elm. A list is created with square bracket literals. Each element in a list must be separated by a comma. Here are some examples:

[source,elm]
----
> [ 1, 2, 3 ]
[1,2,3] : List number

> [ 'a', 'b', 'c' ]
['a','b','c'] : List Char

> [ "Tobias", "Gob", "George Michael" ]
["Tobias","Gob","George Michael"] : List String
----

****
NOTE: Elm style guide recommends using a space after `+[+` and a space before `+]+`, but when `+elm repl+` prints a list, it doesn’t include those spaces because the style guide was created to improve the readability of code for humans.
****

What happens when we try to put values of different types in a list?

[source,elm]
----
> [ 1, 'a' ]

------------------- TYPE MISMATCH --------------------------
The 2nd element of this list does not match all the previous 
elements:

4|   [ 1, 'a' ]
          ^^^
The 2nd element is a character of type:

    Char

But all the previous elements in the list are:

    number
----

Elm doesn’t like that. We can also create a numeric list by specifying a range.

[source,elm]
----
> List.range 1 5
[1,2,3,4,5]
----

A range is created by specifying the first and last numbers in a sequence. It’s a nice shortcut that saves you from having to type out a long list of numbers. As of this writing, Elm can only use a range to create a list of numbers, but not other types such as character or string.

[source,elm]
----
> List.range 'a' 'z'   -- This will throw an error
----

The Elm Platform also comes pre-loaded with the `List` module. Like the `String` module, it’s also automatically loaded by `+elm repl+`. That’s why we don’t need to explicitly import it. The `List` module contains many more functions for working with lists. Let’s go through some of them.

==== Checking Membership

The `member` function determines whether or not an item is present in a given list.

[source,elm]
----
> List.member "Jayne" [ "Kaylee", "Jayne", "Malcolm" ]
True

> List.member "Inara" [ "Kaylee", "Jayne", "Malcolm" ]
False
----

==== Checking Length

The `isEmpty` function determines whether or not a list is empty, whereas the `length` function returns the number of elements in a list.

[source,elm]
----
> List.isEmpty []
True

> List.isEmpty [ "Dolores", "Teddy" ]
False

> List.length []
0

> List.length [ 1, 2, 3 ]
3
----

==== Reversing a List

[source,elm]
----
> List.reverse [ 1, 2, 3 ]
[3,2,1]
----

The `reverse` function returns a new list that contains elements from the original list in reverse order.

==== Combining Lists

The `List` module provides multiple functions for putting lists together. Let’s start with something we’re already familiar with: `pass:[++]` operator.

[source,elm]
----
> [ 1, 2, 3 ] ++ [ 4, 5, 6 ]
[1,2,3,4,5,6]

> [ "Donna", "Eric" ] ++ [ "Fez", "Hyde", "Kelso" ]
["Donna","Eric","Fez","Hyde","Kelso"]
----

We can also combine more than two lists with `pass:[++]` operator.

[source,elm]
----
> [ "Donna", "Eric" ] ++ [ "Fez", "Hyde" ] ++ [ "Jackie", "Kitty" ]
["Donna","Eric","Fez","Hyde","Jackie","Kitty"]
----

Just like the <<string, `String`>> module, `List` also provides the `append` function for combining two lists.

[source,elm]
----
> List.append [ 1, 2 ] [ 3, 4 ]
[1,2,3,4]
----

Unlike `pass:[++]`, combining more than two lists with `append` is a bit tedious.

[source,elm]
----
> List.append (List.append [ 1, 2 ] [ 3, 4 ]) [ 5, 6 ]
[1,2,3,4,5,6]
----

If we have a bunch of lists buried inside another list, we can use the `concat` function to flatten it like this:

[source,elm]
----
> List.concat [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]
[1,2,3,4,5,6]
----

Finally, we can add an element to the front of a list using the `+::+` (pronounced _cons_) operator.

[source,elm]
----
> 1 :: []
[1]

> 1 :: [ 2, 3 ]
[1,2,3]
----

==== Splitting a List

===== Partitioning a List

Unlike strings, we can’t use a separator to split a list. What we can do is partition a list based on some criteria. The elements that satisfy the criteria will be put into one list and the ones that don’t into another. A predicate function is the perfect place to store our criteria. As a reminder, a predicate is a function that takes a value as an input and returns a boolean as an output. Here’s an example that partitions a list using an <<string, anonymous function>> as a predicate.

[source,elm]
----
> List.partition (\x -> x < 4) [ 1, 2, 3, 4, 5, 6 ]
([1,2,3],[4,5,6])
----

Here’s another example that uses a normal function as a predicate to partition a list.

[source,elm]
----
> isEvil name = List.member name [ "Joffrey", "Ramsay" ]
<function>

> List.partition isEvil [ "Samwell", "Joffrey", "Hodor", "Ramsay" ]
(["Joffrey","Ramsay"],["Samwell","Hodor"])
----

Elements that satisfy the predicate are placed in the first list, the rest go into the second list. Notice how the partitioned lists are contained inside a tuple?

Tuple::
  A tuple is a container like a list, but we can put values of different types into it like this: `+( 1, "Sobchak", [ 't', 'd' ] )+`. Tuples are quite useful for returning multiple results from a function. We will cover it in much more detail later in the <<tuple, Tuple>> section.

You may be wondering why the `partition` function didn’t return a list instead of a tuple. After all a list can also hold multiple lists in it. That’s because lists must contain values of the same kind, but tuples don’t have to. In the future, if `partition` decides to also return the number of elements in each list like this: `+(3, [1,2,3], 3, [4,5,6])+`, it won’t be able to do that with a list. Tuples on the other hand are perfect for a situation like this.

===== Unzipping a List

Let’s say we have a list of tuples each containing two elements.

[source,elm]
----
[ ( "Andy", True ), ( "Hadley", False ), ( "Red", True ) ]
----

How can we split it into two lists? We can use the `unzip` function to accomplish that.

[source,elm]
----
> List.unzip [ ( "Andy", True ), ( "Hadley", False ), ( "Red", True ) ]
(["Andy","Hadley","Red"],[True,False,True])
----

The first list contains the first item from each tuple in the original list and the second list contains the second item. Notice that `unzip` also returns a tuple instead of a list. You will see this pattern of functions returning multiple values in a tuple in most Elm code.

==== Sorting a List

===== Ascending order

Below is a list of top seven highest scores from regular season games in https://en.wikipedia.org/wiki/National_Basketball_Association[NBA] history.

[source,elm]
----
[ 316, 320, 312, 370, 337, 318, 314 ]
----

But they aren’t sorted in any particular order. How can we sort them in ascending order? We can do that by using the `sort` function.

[source,elm]
----
> List.sort [ 316, 320, 312, 370, 337, 318, 314 ]
[312,314,316,318,320,337,370]
----

===== Descending order

The `sort` function sorts a list only in ascending array. It doesn’t allow us to pass an argument specifying in what order we want the list to be sorted. What a let-down. If we want to sort a list in descending order, Elm makes us jump through a couple of hoops. Let’s try the next example in the `+src/Playground.elm+` file as the code we’re about to type is a bit too long for the repl. Define a function called `descending` right above `main`.

[source,elm]
----
descending a b =
    case compare a b of
        LT ->
            GT

        GT ->
            LT

        EQ ->
            EQ
----

Now change `main` to this:

[source,elm]
----
main =
    [ 316, 320, 312, 370, 337, 318, 314 ]
        |> List.sortWith descending
        |> Debug.toString
        |> Html.text
----

Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and go to http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] in your browser. You should see the original list sorted in descending order:

[source,elm]
----
[370,337,320,318,316,314,312]
----

Let’s go through the above code step-by-step. Not sure if you noticed, but in `main` we used the `sortWith` function instead of our stubborn friend `sort` to sort the list of scores in descending order. `sortWith` accepts two arguments:

* A comparison function
* A list that needs sorting

Given two values, a comparison function tells us whether the first value is equal, less than, or greater than the second value. As it happens, Elm provides a function called `compare` which does just that. If the first value is less than the second, `compare` returns `LT`. But if the first value is greater, it returns `GT`. And if they both are equal, it returns `EQ`.

[source,elm]
----
> compare 1 2
LT

> compare 2 1
GT

> compare 1 1
EQ
----

****
NOTE: `compare` is defined in the https://package.elm-lang.org/packages/elm/core/latest/Basics#compare[Basics] module. Elm puts generic values and functions that can operate on different types of data such as strings, lists, records, etc. into the `Basics` module. Like `String` and `List`, the `Basics` module is also loaded automatically by the repl. That’s why we don’t need to explicitly import it.
****

We can also compare strings with the `compare` function.

[source,elm]
----
> compare "Blade" "Dragonetti"
LT

> compare "Dragonetti" "Blade"
GT

> compare "Blade" "Blade"
EQ
----

Strings are compared based on https://en.wikipedia.org/wiki/Lexicographical_order[alphabetical order]. This is how words are ordered in an English dictionary. For example, the word “Thomas” is considered less than “Thompson” because the letter ‘a’ comes before the letter ‘p’ in the alphabet.

[source,elm]
----
> compare "Thomas" "Thompson"
LT
----

When we want to sort a list in descending order, we need the `compare` function to behave in opposite manner. How can we make it do that? By creating another function that pulls a switcheroo on `compare` like this:

[source,elm]
----
descending a b =
    case compare a b of
        LT ->
            GT

        GT ->
            LT

        EQ ->
            EQ
----

`descending` returns `GT` when `compare` actually meant `LT` and `LT` when it meant `GT`. Now we can give this function to `sortWith` and our list will get sorted in descending order.

[source,elm]
----
List.sortWith descending [ 316, 320, 312, 370, 337, 318, 314 ]
----

The sorted list is then passed to the `Debug.toString` function, which generates a string representation of the list. Finally, the `Html.text` function renders the sorted list on a browser.

[source,elm]
----
main =
    [ 316, 320, 312, 370, 337, 318, 314 ]
        |> List.sortWith descending
        |> Debug.toString
        |> Html.text
----

===== Converting a Value to a String

Earlier, in the <<function, Backward Function Application>> section, we used the `String.fromFloat` function to convert a float to a string before rendering it on a browser with `Html.text` like this:

[source,elm]
----
main =
    divide 30 10
        |> multiply 10
        |> add 5
        |> String.fromFloat
        |> Html.text
----

In Elm, there are three ways to convert a value to a string:

* `String.fromInt` — Converts an `Int` to a `String`.
* `String.fromFloat` — Converts a `Float` to a `String`.
* `Debug.toString` — Converts any kind of value to a string. This function is not meant to be used in production code. If you need to show a string representation of a value other than `Int` or `Float` in production, you need to use localization. Similarly to the `Basics`, `String`, and `List` modules, `Debug` is also included in the Elm Platform and is automatically loaded.

Localization::
  “Localization is the process of translating software user interfaces from one language to another and adapting it to suit a foreign culture.” - https://developer.mozilla.org/en-US/docs/Mozilla/Localization[MDN]

****
NOTE: Unfortunately, as of this writing Elm doesn’t provide an elegant approach to localization. Therefore, we won’t be covering it in this book.
****

===== Arbitrary order

`sortWith` actually opens a door for comparing values using any order we want, not just ascending or descending. Let’s say we want to sort certain characters from https://en.wikipedia.org/wiki/Game_of_Thrones[Game of Thrones] based on how evil they are. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
evilometer character1 character2 =
    case ( character1, character2 ) of
        ( "Joffrey", "Ramsay" ) ->
            LT

        ( "Joffrey", "Night King" ) ->
            LT

        ( "Ramsay", "Joffrey" ) ->
            GT

        ( "Ramsay", "Night King" ) ->
            LT

        ( "Night King", "Joffrey" ) ->
            GT

        ( "Night King", "Ramsay" ) ->
            GT

        _ ->
            GT
----

Now let’s use `evilometer` in `main` to sort a list of evil characters.

[source,elm]
----
main =
    [ "Night King", "Joffrey", "Ramsay" ]
        |> List.sortWith evilometer
        |> Debug.toString
        |> Html.text
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see `+["Joffrey","Ramsay","Night King"]+`.

All `sortWith` expects from a comparing function is one of these values: `LT`, `GT`, or `EQ`. It doesn’t care how those values are computed. The `sort` function is actually a specialized case of `sortWith`. Internally, it just calls the `compare` function directly to compare values. So if we write `sortWith` like this, we get the behavior of `sort` function:

[source,elm]
----
> List.sortWith compare [ 316, 320, 312, 370, 337, 318, 314 ]
[312,314,316,318,320,337,370]
----

==== Filtering a List

Just like <<string, `String.filter`>> `List.filter` also takes a predicate and a list of items. It then creates a new list containing all items from the original list that pass the test implemented by the predicate. Here are some examples:

[source,elm]
----
> isOdd number = if (remainderBy 2 number) == 0 then False else True
<function>

> List.filter isOdd [ 0, 1, 2, 3, 4, 5 ]
[1,3,5]

> isHost name = List.member name [ "Dolores", "Teddy", "Maeve" ]
<function>

> List.filter isHost [ "William", "Bernard", "Dolores", "Teddy" ]
["Dolores","Teddy"]
----

The `isOdd` function is a predicate that determines whether a given number is odd. We divide the number by `2` and check if the remainder is `0`. If yes, it’s not an odd number. The `remainderBy` function divides the second argument by the first and returns the remainder. It’s defined in the `Basics` module.

The `isHost` function is also a predicate that determines whether someone is a host from ever fascinating https://en.wikipedia.org/wiki/Westworld_(TV_series)[Westworld]. It uses the <<list, `List.member`>> function we used earlier to determine whether a given name is in a list of hosts.

==== Mapping a List

Programming is all about data transformation. We take an input and apply a sequence of functions to it until we arrive at a result that can be returned as an output. Let’s say we have a list of strings:

[source,elm]
----
> guardians = [ "Star-lord", "Groot", "Gamora", "Drax", "Rocket" ]
["Star-lord","Groot","Gamora","Drax","Rocket"]
----

And we want to find out how many strings have lengths less than six. How can we accomplish that? Well, first we need to find out a length of each string in the list. How about we generate another list that contains just lengths, but not the strings themselves? We can do that easily with the `map` function.

[source,elm]
----
> lengths = List.map String.length guardians
[9,5,6,4,6]
----

`List.map` applies the given function to each element in the original list and puts the result in a new list. Here we gave it `String.length` which takes a string and returns its length. Next, we need to remove lengths that are greater than or equal to 6. We already know a function that knows how to do it — `List.filter`.

[source,elm]
----
> List.filter (\x -> x < 6) lengths
[5,4]
----

And we have our answer.

image:https://elmprogramming.com/images/chapter-3/3.16-list/map-filter.svg[]

Let’s work through one more problem to solidify our understanding of `List.map`. Let’s say we want to find out whether any of the guardians have hyphen in their name. We can use `String.contains` to check for a hyphen like this:

[source,elm]
----
> List.map (\x -> String.contains "-" x) guardians
[True, False, False, False, False]
----

After a while, typing an anonymous function starts to get a little tiresome. What if we apply `map` like this instead:

[source,elm]
----
> List.map (String.contains "-") guardians
[True, False, False, False, False]
----

Whoa! That works too. Previously, we applied `String.contains` with both arguments (`+"-"+` and `x`) it needed to return a boolean. However, if we call it without the second argument (`x`), we get back a partially applied function instead of a boolean value. `List.map` then passes each string from the `guardians` list, one at a time, to this partially applied function as the last argument. This results in a boolean value.

image:https://elmprogramming.com/images/chapter-3/3.16-list/partial-function-application.svg[]

An anonymous function like `+(\param -> someFunction x param)+` can always be rewritten as `+(someFunction x)+` as long as `param` is the last argument. Here’s one more example that checks if a guardian’s name starts with `Dr`.

[source,elm]
----
> List.map (\x -> String.startsWith "Dr" x) guardians
[False,False,False,True,False]

> List.map (String.startsWith "Dr") guardians
[False,False,False,True,False]
----

****
NOTE: 这里的 `(String.startsWith "Dr")` 就是柯里化（currying）处理后的 String.startsWith 函数，也就是包装了某些部分参数的纯函数。后续应用此函数，只需要补足参数，或者再进一步柯里化。。
****

The partial application technique also works with operators. Let’s rewrite one of our earlier examples that contained an operator using the partial application technique.

[source,elm]
----
> List.filter (\x -> x < 6) lengths
[5,4]

> List.filter ((>) 6) lengths
[5,4]
----

Notice that we had to flip the `+<+` operator in order to achieve the same result. That’s because the partial application technique requires us to use operators in prefix style, which places an operator before the operands. If we hadn’t flipped the `+<+` operator, we would have gotten a list of numbers that are greater than `6`.

[source,elm]
----
> List.filter ((<) 6) lengths
[9]
----

==== Folding a List

We have created numerous lists with numbers in them, but we haven’t tried to add all the elements up yet. Let’s do that.

[source,elm]
----
> List.foldl (\x a -> x + a) 0 [ 1, 2, 3, 4 ]
10
----

What we have done here is _fold_ (or _reduce_) a list into a number that represents the sum of all elements in the list. The `foldl` function takes three arguments: combining function, initial value, and a list. The combining function in turn takes two arguments: an element from the list and an accumulator. The following diagram illustrates various components of the `foldl` function.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-foldl-components.svg[]

During the first application of the combining function, the initial value is passed to the accumulator as shown in the diagram below.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-foldl-initial-value.svg[]

After the first application, `foldl` repeatedly passes the accumulator (sum thus far) back to the combining function as the second argument until there are no more elements left in the original list. The figure below shows the step-by-step application of the combining function.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-foldl-iterations.svg[]

Since we are calculating a sum here, we used the `+++` operator inside our combining function. But if we were calculating a product, our combining function would use the `+*+` operator instead.

[source,elm]
----
> List.foldl (\x a -> x * a) 0 [ 1, 2, 3, 4 ]
0
----

Why is it returning zero as the product? Oops… We forgot to change the initial value. `foldl` passes the initial value (zero in our case) as the first argument to the combining function. The result of multiplying a number by zero is zero. If we change the initial value to `1`, we get the expected result.

[source,elm]
----
> List.foldl (\x a -> x * a) 1 [ 1, 2, 3, 4 ]
24
----

Remember, `+++` and `+*+` operators are also functions. And all `foldl` expects is a function as the first argument. It doesn’t care whether it’s an anonymous function or a normal function or an operator. Therefore, we can re-write the above examples in a much more succinct way like this:

[source,elm]
----
> List.foldl (+) 0 [ 1, 2, 3, 4 ]
10

> List.foldl (*) 1 [ 1, 2, 3, 4 ]
24
----

In case of addition and multiplication, you can think of replacing the commas in the list with the `+++` and `+*+` operators respectively. `foldl` is capable of reducing a list in many different ways, but if all you want to do is calculate sum or product, Elm already provides those functions as a convenience.

[source,elm]
----
> List.sum [ 1, 2, 3, 4 ]
10

> List.product [ 1, 2, 3, 4 ]
24
----

That was pretty anticlimactic, wasn’t it? I showed you in detail how to use `foldl` to calculate the sum and product of a list only to find out later there already exist functions to do exactly that much more easily. To make it up to you, I’ll show you one more example that’s actually useful. Let’s say we want to calculate the total number of characters in this list:

[source,elm]
----
> guardians = [ "Star-lord", "Groot", "Gamora", "Drax", "Rocket" ]
["Star-lord","Groot","Gamora","Drax","Rocket"]
----

We can use `foldl` to easily reduce this entire list of strings to a single number.

[source,elm]
----
> List.foldl (\x a -> (String.length x) + a) 0 guardians
30
----

==== Folding a List from Right

`foldl` folds a list from left as its name indicates. What that means is it begins its operation starting from the beginning of the list, but sometimes we need to fold a list starting from the end. The `List` module provides another function called `foldr` for that.

[source,elm]
----
> List.foldr (\x a -> x + a) 0 [ 1, 2, 3, 4 ]
10

> List.foldr (\x a -> x * a) 1 [ 1, 2, 3, 4 ]
24
----

The structure of `foldr` looks very similar to that of `foldl`.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-foldr-components.svg[]

For sum and product it doesn’t matter whether we start from the beginning or end of a list, but there are operators that produce different results depending on where we start. Let’s use one that we are already familiar with: _power operator (`+^+`)_.

Earlier, we learned that `+^+` is right-associative whereas `+++` and `+*+` are left-associative. What that means is if we write an expression as shown below, `+^+` will start evaluating it from the right.

[source,elm]
----
> 4 ^ 2 ^ 3
65536

-- (2 ^ 3) = 8
-- (4 ^ 8) = 65536
----

There are two reasons why `+^+` is right-associative in Elm:

*1.* `+^+` is also right-associative in mathematics and Elm tries to follow the rules from mathematics as much as possible.

*2.* If `+^+` was left-associative, the end result could simply be computed by just multiplying the exponents. Let’s see some examples to understand what this means.

[source,elm]
----
> (4 ^ 2) ^ 3
4096

> 4 ^ (2 * 3)
4096

> (((2 ^ 3) ^ 4) ^ 5)
1152921504606847000

> 2 ^ (3 * 4 * 5)
1152921504606847000
----

We applied parentheses to force `+^+` to evaluate from left. We were then able to simply multiply all the exponents on the right and use `+^+` only once to get the same result. Therefore, to make the `+^+` operator more meaningful, we need to evaluate an expression from the right. Now let’s see how `foldr` behaves with `+^+`.

[source,elm]
----
> List.foldr (\x a -> x ^ a) 1 [ 4, 2, 3 ]
65536
----

It can be hard to understand how `foldr` works just by looking at the code above. The figure below illustrates what exactly happens when we apply `foldr`.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-foldr-initial-value.svg[]

Just like `foldl`, `foldr` also repeatedly passes the accumulator (result thus far) back to the combining function as the second argument until there are no more elements left in the original list. The figure below shows the step-by-step application of the combining function given to `foldr`.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-foldr-iterations.svg[]

What happens if we use `+^+` with `foldl`? It starts applying the `+^+` operator from the left resulting in a different value which is not what we want.

[source,elm]
----
> List.foldl (\x a -> x ^ a) 1 [ 4, 2, 3 ]
43046721
----

Here is how we arrived at the final result in the example above:::
    `+(4 ^ 1) = 4+` +
    `+(2 ^ 4) = 16+` +
    `+(3 ^ 16) = 43046721+`

Lastly, we can rewrite the above expressions more succinctly just by specifying the operator instead of the entire anonymous function as shown below.

[source,elm]
----
> List.foldr (^) 1 [ 4, 2, 3 ]
65536

> List.foldl (^) 1 [ 4, 2, 3 ]
43046721
----

===== Are they all evil?

Earlier we partitioned a list containing characters from Game of Thrones into two lists. The first list was infested with evil people whereas the second list was full of kind souls.

[source,elm]
----
> gotCharacters = [ "Samwell", "Joffrey", "Hodor", "Ramsay" ]
["Samwell", "Joffrey", "Hodor", "Ramsay"]

> isEvil name = List.member name [ "Joffrey", "Ramsay" ]
<function>

> List.partition isEvil gotCharacters
(["Joffrey","Ramsay"],["Samwell","Hodor"])
----

What if we want to find out if any one of the characters is evil? The `any` function is designed to do just that.

[source,elm]
----
> List.any isEvil gotCharacters
True
----

There’s certainly evil lurking in that list. Just like the `partition` function, `any` takes a predicate that tells whether a given character is evil or not. We can also find out if all characters are evil by using the `all` function instead.

[source,elm]
----
> List.all isEvil gotCharacters
False
----

How can Hodor be evil, right? If you think about it, `any` and `all` are also folding a list. They both reduce a list to a single boolean value. There are a few more of these functions that perform a special kind of fold. You can learn all about them https://package.elm-lang.org/packages/elm/core/latest/List[here].

==== Take it or Drop it

Remember those annoying bouncers at famous night clubs who tend to let only good looking people in? If those bouncers were Elm programmers, they’d love the `drop` function.

[source,elm]
----
> List.drop 2 [ "Smeagol", "Freddy", "Daenerys", "Jacob" ]
["Daenerys","Jacob"]
----

The `drop` function drops the specified number of elements from the beginning of a list and returns a new list with remaining elements. Once in a while, we get a nice bouncer who lets people on a first come first serve basis. They would definitely prefer `take` to `drop`.

[source,elm]
----
> List.take 2 [ "Freddy", "Daenerys", "Driver" ]
["Freddy","Daenerys"]
----

Watch out! The bouncer just let https://en.wikipedia.org/wiki/Freddy_Krueger[Freddy] into the club. `take` returns a new list containing the specified number of elements from the beginning of a list.

==== Head or Tail?

Conceptually speaking, a list is divided into two parts: head and tail. The first element is called the head and tail represents the rest of the elements.

image:https://elmprogramming.com/images/chapter-3/3.16-list/list-head-tail.svg[]

The `List` module provides functions for getting the head and tail of a list as shown below.

[source,elm]
----
> List.head [ 1, 2, 3, 4, 5 ]
Just 1

> List.tail [ 1, 2, 3, 4, 5 ]
Just [2,3,4,5]

> List.head []
Nothing

> List.tail []
Nothing
----

Elm cannot guarantee that it can return a value when asked for the head (or tail) of a list. If the list is empty there is no value to return. Therefore, it returns a `Maybe`.

==== How List Works Behind the Scenes

List is sometimes also called a _linked list_ as it is a linear collection of data elements, each pointing to the next element. An element in a list is called a _node_.

image:https://elmprogramming.com/images/chapter-3/3.16-list/linked-list.svg[]

Even if there is no data in it, the last (empty) node does exist. If you don’t believe me check this out:

[source,elm]
----
> []
[]

> 9 :: []
[9]

> 31 :: [ 9 ]
[31,9]

> 5 :: [ 31, 9 ]
[5,31,9]

> 16 :: [ 5, 31, 9 ]
[16,5,31,9]
----

We started with an empty list and added `9` in-front of it using the cons (`+::+`) operator. We then continued to add the rest of the elements to that list one at a time. When we create a list in this way, it starts to look like a recursive data structure meaning a list consists of nodes which themselves are lists. Because a node isn’t required to contain a value, an empty node is also considered a list.

image:https://elmprogramming.com/images/chapter-3/3.16-list/recursive-list-example.svg[]

In fact, `List` in Elm is actually defined as a recursive data structure. In the <<type-system, Recursive Types>> section, we will create our own implementation of a linked list that will work similarly to Elm’s implementation of `List` to better understand how a recursive data structure works.

We covered quite a few functions from the `List` module in this section, but there are still more included in that module. You can learn all about them https://package.elm-lang.org/packages/elm/core/latest/List[here].


[[array]]
=== 3.17 Array


We covered plenty of functions from the `List` module, but we didn’t get to one of the most common operations performed on a list: accessing elements by index. That’s because there is no easy way to do that with lists. Because of the way lists are implemented, they are easy to traverse linearly, but accessing an element in random order is expensive. For example, to get to the last element in the list shown below, we have to first traverse through the six elements before it which is inefficient. We can imagine how inefficient it will get when a list has thousands of elements in it.

image:https://elmprogramming.com/images/chapter-3/3.17-array/list-traversal.svg[]

Not to worry — Elm offers another data structure called _Array_ that makes accessing a random element a breeze. Arrays are very similar to lists in behavior. Almost any operation that can be performed on a list can be performed on an array too.

==== Creating an Array

Unfortunately, we can’t create an array with a literal syntax like list. The most common way to create an array is to first create a list and then transform it to an array.

[source,elm]
----
> import Array

> myArray = Array.fromList [ 1, 2, 3, 4 ]
Array.fromList [1,2,3,4]

> myArray
Array.fromList [1,2,3,4]
----

Although the `Array` module is included in Elm Platform, it isn’t automatically loaded by `+elm repl+`. Therefore, we need to import it explicitly. `fromList` is a function that takes a list and creates an array from it. Notice when we printed the value of `myArray` constant, the repl gave us `+Array.fromList [1,2,3,4]+` as the output? That whole output is what represents the array. `+[1,2,3,4]+` by itself is still just a list.

image:https://elmprogramming.com/images/chapter-3/3.17-array/array-representation.svg[]

We can also transform an array to a list.

[source,elm]
----
> Array.toList myArray
[0,1,2,3,4]
----

If we want to include the index of each element when we transform an array to a list, we can do that too using the `toIndexedList` function.

[source,elm]
----
> myArray = Array.fromList [ "Doctor", "River", "Clara", "Tardis" ]
Array.fromList ["Doctor","River","Clara","Tardis"]

> Array.toIndexedList myArray
[(0,"Doctor"),(1,"River"),(2,"Clara"),(3,"Tardis")]
----

Sometimes we need to initialize each element of an array with some value. We can use the `+initialize +` function for that. The example below creates a list with all elements initialized to zero.

[source,elm]
----
> Array.initialize 5 (always 0)
Array.fromList [0,0,0,0,0]
----

`initialize` takes two parameters:

* Length of an array.
* Function for generating each element. `initialize` passes the index of an element as an argument to this function.

We used the `always` function (also defined in the `Basics` module) to return `0` for each element. `always` is defined like this:

[source,elm]
----
always a b = 
    a
----

It’s a constant function that ignores the second argument and always returns the first argument.

Constant Function::
  A constant function in mathematics is a function whose output is the same for every input value.
+
image:https://elmprogramming.com/images/chapter-3/3.17-array/array-always-zero.svg[]

Another way to initialize an array with the same value is to use the `repeat` function.

[source,elm]
----
> Array.repeat 5 0
Array.fromList [0,0,0,0,0]

> Array.repeat 3 "hodor"
Array.fromList ["hodor","hodor","hodor"]
----

The `Basics` module also provides a function called `identity` that, unlike `always`, returns the given value. Let’s use this function to create an array whose elements and the indexes are exactly the same.

[source,elm]
----
> Array.initialize 5 identity
Array.fromList [0,1,2,3,4]
----

Unlike `always`, `identity` is not a constant function — its output depends on what the input is. Here’s how `identity` is defined in the `Basics` module:

[source,elm]
----
identity x = 
    x
----

==== Getting and Setting a Value

To retrieve a specific element from an array, all we have to do is specify its index and the `get` function will return that element for us.

[source,elm]
----
> myArray = Array.fromList [ 0, 1, 2, 3, 4 ]
Array.fromList [0,1,2,3,4]

> Array.get 3 myArray
Just 3
----

`get` returns an element wrapped inside `Just`. We saw a similar example when we asked a <<list, list to return its head>>. We will learn how to unwrap a value from `Just` in chapter 4. Let’s see What happens if we try to access an index that doesn’t exist.

[source,elm]
----
> Array.get 5 myArray
Nothing

> Array.get -1 myArray
Nothing
----

Instead of an error, we get `Nothing` which makes perfect sense. Similarly, we can set an element at a particular index by using the `set` function.

[source,elm]
----
> Array.set 3 8 myArray
Array.fromList [0,1,2,8,4]
----

`set` takes three arguments:

* The index of the element we want to update
* The new value that’ll replace the existing element
* An array

It’s important to know that `set` returns a new array instead of modifying an existing array. If we print the contents of `myArray`, we will see that it hasn’t been changed at all.

[source,elm]
----
> myArray
Array.fromList [0,1,2,3,4]
----

This behavior is consistent with all other operations. It doesn’t matter which data structure we are dealing with, Elm never mutates them. We will discuss <<immutability, immutability>> in much more detail in chapter 4.

==== Checking Length

`isEmpty` function determines whether or not an array is empty whereas `length` returns the number of elements in an array.

[source,elm]
----
> Array.isEmpty (Array.fromList [])
True

> Array.isEmpty (Array.fromList [ "Dolores", "Teddy", "Elsie" ])
False

> Array.length (Array.fromList [])
0

> Array.length (Array.fromList [ 1, 2, 3 ])
3
----

The `isEmpty` and `length` functions in array work exactly the same way as in list.

==== Combining Arrays

The `append` function combines two arrays.

[source,elm]
----
> array1 = Array.fromList [ 1, 2, 3 ]
Array.fromList [1,2,3]

> array2 = Array.fromList [ 4, 5, 6 ]
Array.fromList [4,5,6]

> Array.append array1 array2
Array.fromList [1,2,3,4,5,6]
----

We cannot, however, use the `pass:[++]` operator to append two arrays.

[source,elm]
----
> array1 ++ array2  -- Error
----

If we want to add an element to the end of an array, we can do that too with the `push` function.

[source,elm]
----
> Array.push 4 array1
Array.fromList [1,2,3,4]
----

There is no function to add an element to the beginning of an array. That’s because it’s an expensive operation. Each element has to be moved one step right and if an array has lots of elements in it, it could get quite slow from performance standpoint. But adding an element to the end of an array is quite cheap because it doesn’t require other elements to move.

image:https://elmprogramming.com/images/chapter-3/3.17-array/array-add-to-the-front.svg[]

We can get around the performance issues caused by adding an element to the beginning of an array by appending that element instead.

[source,elm]
----
> Array.append (Array.fromList [0]) array1
Array.fromList [0,1,2,3]
----

==== Splitting Arrays

Remember how we <<string, extracted a substring>> earlier in this chapter by using the `slice` function?

[source,elm]
----
> String.slice 0 5 "Bears. Beets. Battlestar Galactica."
"Bears"
----

The `Array` module also provides a function called `slice` that extracts a sub-section of an array. Like `String.slice`, it also takes three arguments:

* Index where the sub-array starts
* Index where the sub-array ends
* An array

[source,elm]
----
> myArray = Array.fromList [ 0, 1, 2, 3, 4, 5 ]
Array.fromList [0,1,2,3,4,5]

> Array.slice 0 3 myArray
Array.fromList [0,1,2]
----

`String.slice` and `Array.slice` both extract elements up to but not including the end index. We can also use negative indices with `Array.slice`.

[source,elm]
----
> myArray
Array.fromList [0,1,2,3,4,5]

> Array.slice 0 -1 myArray
Array.fromList [0,1,2,3,4]
----

Notice how we popped off the last element from `myArray` by using a negative index. Nice trick, huh?

==== Mapping, Filtering, and Folding an Array

Earlier in the <<list, List>> section, we took a closer look at how map, filter, and fold operations work. Their behavior is exactly the same in an array too. Let’s see some examples.

===== Mapping

[source,elm]
----
> Array.map (\x -> x * 2) (Array.fromList [ 1, 2, 3 ])
Array.fromList [2,4,6]

> guardians = Array.fromList [ "Star-lord", "Groot", "Gamora", "Drax", "Rocket" ]
Array.fromList ["Star-lord","Groot","Gamora","Drax","Rocket"]

> lengths = Array.map String.length guardians
Array.fromList [9,5,6,4,6]
----

===== Filtering

[source,elm]
----
> Array.filter (\x -> x < 6) lengths
Array.fromList [5,4]

> isOdd number = if (remainderBy 2 number) == 0 then False else True
<function>

> Array.filter isOdd (Array.fromList [ 0, 1, 2, 3, 4, 5 ])
Array.fromList [1,3,5]

> isHost name = List.member name [ "Dolores", "Teddy" ]
<function>

> westWorldCharacters = Array.fromList [ "William", "Dolores", "Teddy" ]
Array.fromList ["William","Dolores","Teddy"]

> Array.filter isHost westWorldCharacters
Array.fromList ["Dolores","Teddy"]
----

===== Folding from left

[source,elm]
----
> myArray = Array.fromList [ 1, 2, 3, 4 ]
Array.fromList [1,2,3,4]

> Array.foldl (+) 0 myArray
10

> Array.foldl (*) 1 myArray
24

> guardians = Array.fromList [ "Star-lord", "Groot", "Gamora", "Drax", "Rocket" ]
Array.fromList ["Star-lord","Groot","Gamora","Drax","Rocket"]

> Array.foldl (\x a -> (String.length x) + a) 0 guardians
30
----

===== Folding from right

[source,elm]
----
> myArray = Array.fromList [ 4, 2, 3 ]
Array.fromList [4,2,3]

> Array.foldr (^) 1 myArray
65536
----

==== List vs Array

Now that we know what lists and arrays are, we are left with an important question: which one should we use and when? As lists have no easy way to access an element by index, we have no choice but to use arrays when we need positional access. But in all other cases, I recommend using lists because they are the standard choice for representing a sequence of values in Elm.

Furthermore, creating a list is easy with literal square brackets, whereas creating an array is somewhat cumbersome. We have to first create a list and then use the `fromList` function to convert that list to an array.


[[tuple]]
=== 3.18 Tuple


Just like <<list, lists>> and <<array, arrays>>, tuples are also used to store multiple values. They are created with parentheses and their elements are separated by commas.

[source,elm]
----
> ( 1, 2 )
(1,2)

> ( "Mia", "Vincent" )
("Mia","Vincent")
----

****
NOTE: Elm style guide recommends using a space after `+(+` and a space before `+)+` when creating a tuple.
****

Unlike lists and arrays, tuples can contain values of different types.

[source,elm]
----
> ( 1, 2.5, "Butch" )
(1,2.5,"Butch")
----

They can even contain other collections such as lists or arrays or tuples themselves.

[source,elm]
----
> ( [ 1, 2 ], [ "Jules", "Wolf" ] )
([1,2],["Jules","Wolf"])

> import Array

> array = Array.fromList [ 5, 6 ]
Array.fromList [5, 6]

> (array, [ 1, 2 ], ( "Jules", "Wolf" ) )
(Array.fromList [5,6],[1,2],("Jules","Wolf"))
----

How about lists? Can they contain tuples? The answer is yes.

[source,elm]
----
> [ ( 1, 2 ), ( 3, 4 ), ( 5, 6 ) ]
[(1,2),(3,4),(5,6)]
----

Remember lists can only contain values of the same kind. In the example above, all three tuples have two numbers in them. What happens if we have tuples of different sizes?

[source,elm]
----
> [ ( 1, 2 ), ( 3, 4, 5 ) ]

-------------------------- TYPE MISMATCH -----------------------------
The 2nd element of this list does not match all the previous elements:

12|   [ ( 1, 2 ), ( 3, 4, 5 ) ]
                  ^^^^^^^^^^^
The 2nd element is a tuple of type:

    ( number, number1, number2 )

But all the previous elements in the list are:

    ( number, number1 )
----

As Elm points out, `+( 1, 2 )+` and `+( 3, 4, 5 )+` are different types of values because their sizes are different. For tuples to be of the same type in Elm, they must contain the same number and type of values. So this won’t work either:

[source,elm]
----
> [ ( 1, 2 ), ( "Sansa", "Ygritte" ) ]  -- This also throws an error
----

The first tuple is a pair of numbers, whereas the second is a pair of strings which makes them different types. And a list can’t have values of different types.

==== Length of a Tuple

We can only have up to three elements in a tuple. If we add one more, we’ll get an error. It’s better to use a <<record, record>> when we need to store more than three values of different types.

[source,elm]
----
> ( 1, 2, 3, 4 )   -- This throws an error
----

==== Modifying Tuples

****
NOTE: 显然，原文小节标题“Modifying Tuples”具有误导含义。元组与列表、数组一样都是 immutable 数据类型，只能通过构造新实例来获得不同的数据结构，而不能修改它本身。显然，Elm 与其它编程语言不一样，它不希望元组（tuple）用于保存 2 (pair)、3 (triple) 个元素之外的情形。这两种类型中文称之为“对子”（或者二元组）、“三元组”。

[source,elm]
----
> t = (1, 'x')
(1,'x') : ( number, Char )

> Tuple.mapFirst (\_ -> "A") t
("A",'x') : ( String, Char )

> t
(1,'x') : ( number, Char )
> 
----
****

In the previous sections, we learned that lists and arrays are immutable. Once they are created, we can never change them. However, despite them being immutable, we were still able to add and remove values from them.

[source,elm]
----
> myList = [ 1, 2, 3, 4 ]
[1,2,3,4]

> myList ++ [ 5 ]
[1,2,3,4,5]

> List.drop 1 myList
[2,3,4]
----

How’s that possible? It’s possible because on the surface Elm makes it look like it’s modifying an existing list when in fact behind the scenes it creates a completely new list. When we print `myList`, we discover that its values are intact.

[source,elm]
----
> myList
[1,2,3,4]
----

From practical standpoint all we care about is the ability to add and remove values from a collection. How Elm enables us to do that is of little concern to us.

****
NOTE: Although, in chapter 4 we will find out that <<immutability, immutability>> does have far-reaching consequences. It’s at the core of some of Elm’s truly exciting features.
****

Like lists and arrays, tuples are also immutable. But, Elm goes a step further to keep a tuple’s immutability intact. It strips away our ability to add or remove values from a tuple. That’s why there are no functions or operators in the `Tuple` module to perform those actions.

When you think about it, it does make sense to put this restriction on tuples. Earlier we discovered that for tuples to be of the same type in Elm, they must contain the _same number_ of values. If we were to add or remove a value from a tuple, we would essentially be changing its underlying type as well which is not the case with a list or an array.

Furthermore, if we could add or remove values from tuples, they would start looking a lot like lists and arrays with only one difference: the ability to hold different types of values. In the next section, we will find out that there already exists a data structure called <<record, record>> that can hold different types of values. So without this rigidity, tuples can be easily replaced with other data structures.

Because we can’t add or remove values from tuples, we should only use them when we know in advance how many elements we will need.

==== Using Tuples

Despite their rigidity, tuples can be quite useful. Listed below are a few scenarios where using tuples makes our lives easier.

===== Representing Complex Data

Tuples can be used to represent a wide variety of data. For example, if we want to represent someone’s name, age, and a list of siblings we can easily do that with a tuple.

[source,elm]
----
> ( "Jon Snow", 14, [ "Sansa", "Arya", "Bran", "Rob", "Rickon" ] )
("Jon Snow",14,["Sansa","Arya","Bran","Rob","Rickon"])
----

===== Returning Multiple Values From a Function

It’s a common pattern in Elm to use tuples for returning multiple values from a function. To see how this works, let’s write a function that determines whether or not a given email is valid. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
validateEmail email =
    let
        emailPattern =
            "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b"

        regex =
            Maybe.withDefault Regex.never <|
                Regex.fromString emailPattern

        isValid =
            Regex.contains regex email
    in
    if isValid then
        ( "Valid email", "green" )

    else
        ( "Invalid email", "red" )
----

Now change the `main` function to this:

[source,elm]
----
main =
    validateEmail "thedude@rubix.com"
        |> Debug.toString
        |> Html.text
----

Finally import the `Regex` module right below the line that imports the `Html` module.

[source,elm]
----
import Html
import Regex
----

Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and go to http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] on your browser. You should see `+("Valid email","green")+`.

The `validateEmail` function uses a <<regular-expression, regular expression>> to determine whether a given email is valid or not. It returns a tuple containing two values:

* If the email is valid, the `+"Valid email"+` string is returned, otherwise `+"Invalid email"+` is returned.
* The color to use when displaying the validity status text.

As you can see, using a tuple made it very easy for us to return multiple values.

===== Being Explicit About the Structure of Data

Let’s say we want to compute the perimeter of a triangle using the formula shown below.

image:https://elmprogramming.com/images/chapter-3/3.18-tuple/triangle-perimeter.svg[]

One way to represent the sides of a triangle is by using a list.

[source,elm]
----
> triangleSides = [ 5, 4, 6 ]
[5,4,6]
----

Now let’s write a function that calculates perimeter in the repl.

[source,elm]
----
> trianglePerimeter sides = List.sum sides
<function>
----

We used `List.sum` to add up all sides of a triangle. If we apply this function to the `triangleSides` list we created above, we will get the perimeter.

[source,elm]
----
> trianglePerimeter triangleSides
15
----

Now what happens when we apply the `trianglePerimeter` function to a list that contains only two sides?

[source,elm]
----
> trianglePerimeter [ 5, 4 ]
9
----

It will happily compute the perimeter. If we want to make sure that the `trianglePerimeter` always receives exactly three sides, we will have to write some additional code to verify that an input list has only three elements. But if we use a tuple instead, Elm will do that for us. Let’s try it.

[source,elm]
----
> trianglePerimeter ( a, b, c ) = a + b + c
<function>

> trianglePerimeter ( 5, 4, 6 )
15
----

So far so good. Now let’s apply `trianglePerimeter` to a tuple with only two elements.

[source,elm]
----
> trianglePerimeter ( 5, 4 )

---------------------- TYPE MISMATCH ------------------------
The 1st argument to `trianglePerimeter` is not what I expect:

6|   trianglePerimeter ( 5, 4 )
                       ^^^^^^^^
This argument is a tuple of type:

    ( number, number1 )

But `trianglePerimeter` needs the 1st argument to be:

    ( number, number, number )
----

There you go. Elm points out that we need to pass in a tuple with exactly three elements. Picking a right data structure for the right problem often gets rid of subtle issues like this.

==== Retrieving Values

Elm provides two functions (`first` and `second`) for retrieving values from a tuple with two elements also known as a _pair_. Storing data in pairs is quite common in Elm. `first` returns the first element in a pair and `second` returns the second element.

[source,elm]
----
> Tuple.first ( 5, 10 )
5

> Tuple.second ( 5, 10 )
10

> Tuple.first ( "Pam", "Jim" )
"Pam"

> Tuple.second ( "Pam", "Jim" )
"Jim"
----

****
NOTE: `+elm repl+` automatically loads the `Tuple` module. That’s why we don’t need to import it.
****

There is no function for retrieving the third element in a tuple. But we can use pattern matching for that. You already saw an example of this above. Here it is again.

[source,elm]
----
> trianglePerimeter ( a, b, c ) = a + b + c
<function>

> trianglePerimeter ( 5, 4, 6 )
15
----

`trianglePerimeter` uses pattern matching to deconstruct a tuple passed to it and assigns the first, second, and third values to `a`, `b`, and `c` respectively.

Pattern Matching::
  As mentioned in the <<case-expression, Case Expression>> section earlier in this chapter, pattern matching allows us to check one or more inputs against a pre-defined pattern and see if they match. The pattern we are checking for in the above example is a tuple that contains three, and only three, numbers. We will look into some more examples of pattern matching with tuples in <<pattern-matching, chapter 4>>.

==== Mapping Pairs

The `Tuple` module also provides three functions for transforming values in a pair:

* `mapFirst` — maps the first element.
* `mapSecond` — maps the second element.
* `mapBoth` — maps both elements.

[source,elm]
----
> Tuple.mapFirst (\_ -> "Jim") ( "Roy", "Pam" )
("Jim","Pam")

> Tuple.mapFirst String.reverse ( "live", "life" )
("evil","life")

> Tuple.mapSecond (\x -> x + 1) ( "fringe", 100 )
("fringe",101)

> Tuple.mapSecond (String.contains "-") ( "Gamora", "Star-Lord" )
("Gamora",True)

> Tuple.mapBoth String.length sqrt ( "Newman", 9 )
(6, 3)
----

There is no function for mapping the third element in a tuple. Tuples really are rigid, aren’t they?


[[record]]
=== 3.19 Record


Like <<tuple, tuples>>, records can also hold values of different types, but they are much more flexible than tuples.

==== Creating a Record

Records are created with curly brackets and their elements are separated by commas.

[source,elm]
----
> { name = "Firefly", creator = "Joss Whedon", episodes = 14 }
{ creator = "Joss Whedon", episodes = 14, name = "Firefly" }
----

Unlike all data structures we have seen so far, records allow us to give names to the value contained in each element.

image:https://elmprogramming.com/images/chapter-3/3.19-record/record-syntax.svg[]

`+elm repl+` rearranges the position of each field in alphabetical order. Let’s assign the record above to a constant and while we’re at it create one more.

[source,elm]
----
> firefly = { creator = "Joss Whedon", episodes = 14, name = "Firefly" }
{ creator = "Joss Whedon", episodes = 14, name = "Firefly" }

> fringe = { creator = "J. J. Abrams", episodes = 100, name = "Fringe" }
{ creator = "J. J. Abrams", episodes = 100, name = "Fringe" }
----

We created two records each containing information about a popular TV show. Let’s put them in a list.

[source,elm]
----
> tvShows = [ firefly, fringe ]
...
----

Here’s the output after some formatting to make it look nicer:

[source,elm]
----
[
  { creator = "Joss Whedon", 
    episodes = 14, 
    name = "Firefly" 
  },
  { creator = "J. J. Abrams", 
    episodes = 100, 
    name = "Fringe" 
  }
]
----

Creating records with the literal syntax (i.e. curly brackets) can be tedious. Is there a better way? Let’s find out. First, let’s give the structure that underlies both records we just created a name.

[source,elm]
----
> type alias TVShow = { creator : String, episodes : Int, name : String }
----

`+type alias+` gives a name to an existing type. Using it we have given the underlying structure a name called `TVShow`. Now we can create records much more cleanly.

[source,elm]
----
> firefly = TVShow "Joss Whedon" 14 "Firefly"
{ creator = "Joss Whedon", episodes = 14, name = "Firefly" }

> fringe = TVShow "J. J. Abrams" 100 "Fringe"
{ creator = "J. J. Abrams", episodes = 100, name = "Fringe" }
----

With the new syntax, records are created by typing `TVShow` followed by creator, name, and number of episodes. This syntax looks familiar, doesn’t it? It’s basically a function application. `+type alias+` created a function for constructing records in addition to giving the underlying structure a name.

image:https://elmprogramming.com/images/chapter-3/3.19-record/record-constructor-function.svg[]

It’s important to notice that when defining a record structure using `+type alias+`, we must use `+:+` and not `+=+` to separate the fields from their types.

image:https://elmprogramming.com/images/chapter-3/3.19-record/record-type-alias-syntax.svg[]

==== Accessing Values

Records are values like everything else in Elm. We can pass them to a function as an argument, modify them, and return them back. Let’s create a function that checks to see if a TV show record has a creator or not.

[source,elm]
----
> hasCreator tvShow = String.length tvShow.creator > 0
<function>

> hasCreator firefly
True

> got = TVShow "" 60 "Game of Thrones"
{ creator = "", episodes = 60, name = "Game of Thrones" }

> hasCreator got
False
----

The `hasCreator` function accesses the `creator` field’s value using the dot syntax. Here are some more examples:

[source,elm]
----
> firefly.creator
"Joss Whedon"

> firefly.episodes
14

> firefly.name
"Firefly"
----

===== Special Accessor Functions

****
NOTE: 这里小标题的“Special”一词没有必要使用，因为有“特别”必然就有“一般”，所以，对于记录结构，它有“一般”的 accessor 和“特别”的 accessor 之区别吗？没有。
****

The second way to access elements in a record is with a special function.

[source,elm]
----
> .creator firefly
"Joss Whedon"

> .episodes firefly
14

> .name firefly
"Firefly"
----

`+.creator+`, `+.episodes+`, and `+.name+` are all special functions created behind the scenes when a record is created. These functions aren’t created by `+type alias+` though. They are available to us even if we use the literal syntax instead of a constructor function to create a record.

[source,elm]
----
> wire = { creator = "David Simon", episodes = 60, name = "The Wire" }
{ creator = "David Simon", episodes = 60, name = "The Wire" }

> .creator wire
"David Simon"

> .episodes wire
60

> .name wire
"The Wire"
----

Why do we call them special functions? First, they start with a dot. Normal functions aren’t allowed to start with special characters. Second, they can only be used on a record that actually has a field that matches the name of the special function. Let’s try using them to access a field in a record that doesn’t have the same name.

[source,elm]
----
> sapiens = { author = "Yuval Harari", name = "Sapiens", published = 2015 }
{ author = "Yuval Harari", name = "Sapiens", published = 2015 }

> .creator sapiens

-------------------- TYPE MISMATCH --------------------
The 1st argument to this function is not what I expect:

12|   .creator sapiens
               ^^^^^^^
This `sapiens` value is a:

    { author : String, name : String, published : number }

But this function needs the 1st argument to be:

    { b | creator : a }
----

What about `+.name+` though? Both records have a field called `name`.

[source,elm]
----
> .name sapiens
"Sapiens"
----

That works because `+.name+` function isn’t tied to any of the records we created before `sapiens`. All it cares about is whether a record has a field called `name` or not. These special functions are equivalent to:

[source,elm]
----
.creator = (\record -> record.creator)

.episodes = (\record -> record.episodes)

.name = (\record -> record.name)
----

They take a record and return the value for the field represented by their name.

==== Sorting Records

What do we gain by having special functions for accessing values in a record? After all the regular dot syntax works just fine and even looks more natural. To understand their usefulness, let’s try to sort TV shows by the number of episodes they have.

[source,elm]
----
> sortByEpisodes tvShow1 tvShow2 = compare tvShow1.episodes tvShow2.episodes
<function>

> List.sortWith sortByEpisodes [ fringe, firefly, wire ]
...
----

Here’s how the output looks after some formatting:

[source,elm]
----
[
  { creator = "Joss Whedon", 
    episodes = 14, 
    name = "Firefly" 
  },
  { creator = "David Simon", 
    episodes = 60, 
    name = "The Wire" 
  },
  { creator = "J. J. Abrams", 
    episodes = 100, 
    name = "Fringe" 
  }
]
----

Remember the <<list, `sortWith`>> function from the `List` module? We used it to sort a list of numbers in descending order like this:

[source,elm]
----
descending a b =
    case compare a b of
        LT ->
            GT

        GT ->
            LT

        EQ ->
            EQ


List.sortWith descending [ 316, 320, 312, 370, 337, 318, 314 ]
----

`sortWith` accepts two arguments: a comparison function and a list that needs sorting. `sortByEpisodes` is our comparison function that takes two TV shows and simply compares the number of episodes in them. As it turns out the `List` module provides another function called `sortBy` that makes sorting records much easier.

[source,elm]
----
> List.sortBy .episodes [ fringe, firefly, wire ]
...
----

Here’s how the output looks after some formatting:

[source,elm]
----
[
  { creator = "Joss Whedon", 
    episodes = 14, 
    name = "Firefly" 
  },
  { creator = "David Simon", 
    episodes = 60, 
    name = "The Wire" 
  },
  { creator = "J. J. Abrams", 
    episodes = 100, 
    name = "Fringe" 
  }
]
----

Instead of having to create a separate comparison function, we just tell `sortBy` which field to use while sorting records. `sortBy` then compares the specified field values and sorts a list accordingly. The first argument to `sortBy` must still be a function though. Since `+.episodes+` is a function, it’s perfectly fine to pass it to `sortBy`. Here’s another example of `sortBy` that sorts a list of strings by their length.

[source,elm]
----
> List.sortBy String.length [ "Olivia", "Peter", "Walter", "Nina" ]
["Nina","Peter","Olivia","Walter"]
----

==== Mapping Records

Earlier in the <<list, List>> section, we saw how to use the `map` function to transform a given list by applying a function to every element in that list. Since a list can also contain records in it, we can use `map` to transform those records into anything we like.

[source,elm]
----
> List.map (\record -> record.name) [ firefly, fringe, wire, got ]
["Firefly","Fringe","The Wire","Game of Thrones"]
----

We took a list of records and transformed it to a list of strings by applying an anonymous function to each element. The anonymous function simply returns the value in the `name` field. We can actually replace the anonymous function with the special function for accessing fields.

[source,elm]
----
> List.map .name [ firefly, fringe, wire, got ]
["Firefly","Fringe","The Wire","Game of Thrones"]
----

As you can see the special functions are quite useful when we want to pick just one field from each record and put them in a separate list.

==== Modifying a Record

Unlike <<tuple, tuples>>, we can modify values in a record. Remember all values in Elm are immutable and so are records. Because of that, Elm doesn’t really modify an existing record. It always returns a new one that contains the modified value. To understand how to modify a record, let’s create a function that increments the number of episodes by one.

[source,elm]
----
> incrementEpisode tvShow = { tvShow | episodes = tvShow.episodes + 1 }
<function>

> firefly.episodes
14

> incrementEpisode firefly
{ creator = "Joss Whedon", episodes = 15, name = "Firefly" }
----

As we can see, the number of episodes has been incremented to `15`. But if we print the episodes in `firefly`, it’s still `14`.

[source,elm]
----
> firefly.episodes
14
----

Elm didn’t change the record `firefly` points to. It returned a new one. The syntax for modifying a record looks a bit weird, doesn’t it? Let’s deconstruct it.

image:https://elmprogramming.com/images/chapter-3/3.19-record/record-modification-syntax.svg[]

We can also modify multiple fields at the same time.

[source,elm]
----
> { fringe | creator = "Alex Kurtzman", episodes = fringe.episodes + 1 }
{ creator = "Alex Kurtzman", episodes = 101, name = "Fringe" }
----

The expressions for updating each field must be separated by commas. If the expression becomes too long to fit in one line, it’s perfectly fine to break it into multiple lines.

[source,elm]
----
> { fringe | \
|   creator = "Alex Kurtzman", \
|   episodes = fringe.episodes + 1, \
|   name = "Fringgge" \
| }
----

****
NOTE: Unlike all other data structures we’ve explored thus far, Elm doesn’t provide a separate module for records. That’s because other than the <<record, special accessors>> there are no functions available to manipulate records. Although that sounds limiting, a lot can be achieved just by using the <<record, syntax for modifying records>>. Furthermore, the special accessor functions are generated on the fly when a record is created. Therefore, we don’t need a separate module to house them.
****


[[elm-lang-basics-conclusion]]
=== 3.20 Conclusion


In this chapter, we learned the basic syntax of the Elm programming language along with various data structures included in the standard library. Don’t worry if Elm’s syntax still looks foreign to you. As you work your way through the rest of the chapters in this book, writing Elm programs will become a second nature to you.

One of the hardest things about learning a programming language is getting accustomed to its syntax. Once you figure out how to enter and run simple programs then things starts to become more interesting. In the next chapter, we’ll learn the real reasons why Elm is such a great language to work with.


[[benefits-of-elm-intro]]
== 4 Benefits of Using Elm

=== 4.1 prelude

In this chapter, we will explore areas where Elm really shines. As mentioned in the <<why-elm, Why Elm>> section, Elm provides quite a few benefits that are lacking in most mainstream languages: immutable values, pure functions, fuzz testing, a powerful type system, pattern matching, and the absence of runtime errors. We will dig deep into each of these topics to understand why they are considered benefits. By the end of this chapter, we will have a whole new appreciation for Elm’s simplicity and power.


[[immutability]]
=== 4.2 Immutability


In the <<value, Value>> section, we learned that a value in Elm is anything that can be produced as a result of a computation. We also learned that Elm values are immutable, which means once created, we can never change them. Once again, Elm has borrowed this concept of immutability from mathematics. For example, the number `3` in mathematics is a value that cannot be changed. Sure, we can add or subtract other numbers from it, but `3` itself will never change. If we add `1` to `3`, we get `4` — a completely new number. This is exactly what happens when we try to modify a value, such as a list, in Elm.

==== Immutable Constants

All constants in Elm are immutable. Once assigned, a constant cannot be reassigned a different value in the same scope. If you are coming to Elm from an https://en.wikipedia.org/wiki/Imperative_programming[imperative language] this might sound confusing. In those languages, it’s common to write code like this:

[source,javascript]
----
var x = 1;
x = x + 1;
----

It means assign `x` as a name to an expression that evaluates to `1`. Then take the current value of `x`, add `1` to it and assign the result back to `x` essentially mutating its original value. Let’s try that same code in Elm to see what happens.

[source,elm]
----
> x = 1
1

> x = x + 1

-------------------------- CYCLIC DEFINITION ----------------------------
The `x` value is defined directly in terms of itself, causing an infinite loop.

3| x = x + 1
   ^
Are you trying to mutate a variable? Elm does not have mutation, so when I
see x defined in terms of x, I treat it as a recursive definition. Try giving
the new value a new name!

Maybe you DO want a recursive value? To define x we need to know what x is, so
let’s expand it. Wait, but now we need to know what x is, so let’s expand it...
This will keep going infinitely!
----

As usual, Elm provides a descriptive error message pointing out that it doesn’t allow mutation. Definitions like `x = x + 1` are not allowed in both algebra and Elm because we already defined `x` as `1` and now we are saying that `x` is `2`. It can’t be both at the same time.

If you pay close attention to the error message, Elm is actually trying to tell us why it can’t allow mutation in this case. When we try to evaluate an expression such as `x = x + 1`, we’re asking Elm to create a constant named `x` that is defined in terms of itself. So Elm will try to expand the definition further as shown below creating an infinite loop:

Recursive Definition::
    `x = x + 1`                         +
    `x = (x + 1) + 1`                   +
    `x = ((x + 1) + 1) + 1`             +
    `x = (((x + 1) + 1) + 1) + 1`       +
    `x = ((((x + 1) + 1) + 1) + 1) + 1` +
    `...`

Elm also tells us that we can fix this by giving the `x + 1` expression a new name like this:

[source,elm]
----
> x = 1
1

> xPlusOne = x + 1
2
----

In an imperative language, `x` is appropriately called a _variable_ because its value can vary even after its creation. Whereas in Elm, `x` is a constant. Because Elm doesn’t allow mutation, the language has no variables. Does this mean we can’t use the same name to represent other values anywhere else in our code? Not really. Once assigned, a constant cannot be reassigned to a different value only in the _same scope_.

Constants like `x` are local to their scope so their life is usually short. When their scope is no longer alive, they will be discarded. After that we can reuse the name to represent other values. The function definition shown below is a good example of a constant in a limited scope. Go ahead and add it right above `main` in `Playground.elm`.

[source,elm]
----
multiplyByFive number =
    let
        multiplier =
            5
    in
    number * multiplier
----

Now call `multiplyByFive` from `main`.

[source,elm]
----
main =
    multiplyByFive 3
        |> Debug.toString
        |> Html.text
----

Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and go to http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] in a browser. You should see `15`.

We learned in <<let-expression, chapter 3>> that `let` expression is one of the ways we can create a local scope in Elm. The `multiplier` constant in `multiplyByFive` function above is bound to `5`. As soon as the program execution steps out of the `let` expression, `multiplier` won’t be alive anymore. If we try to reassign a different value to it inside the `let` expression Elm will complain. Replace the `multiplyByFive` function definition in `Playground.elm` with the following code.

[source,elm]
----
multiplyByFive number =
    let
        multiplier =
            5
        multiplier =
            6
    in
    number * multiplier


----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see the following error.

[source]
----
-- NAME CLASH ------------------------------------------------------------- REPL

This `let` expression defines `multiplier` more than once! One here:

6|           multiplier =
             ^^^^^^^^^^
And another one here:

4|           multiplier =
             ^^^^^^^^^^
How can I know which one you want? Rename one of them!
----
// image:https://elmprogramming.com/images/chapter-4/4.2-immutability/duplicate-assignment-error.png[]

Let’s move the second definition of `multiplier` out of the `multiplyByFive` function and see what happens.

[source,elm]
----
multiplier =
    6


multiplyByFive number =
    let
        multiplier =
            5
    in
    number * multiplier


----



Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] once again and you should see a different error.

[source]
----
-- SHADOWING -------------------------------------------------------------- REPL

The name `multiplier` is first defined here:

2| multiplier =
   ^^^^^^^^^^
But then it is defined AGAIN over here:

7|           multiplier =
             ^^^^^^^^^^
Think of a more helpful name for one of them and you should be all set!

Note: Linters advise against shadowing, so Elm makes “best practices” the
default. Read https://elm-lang.org/0.19.1/shadowing> for more details on this
choice
----
// https://github.com/elm/compiler/blob/master/hints/shadowing.md
// image:https://elmprogramming.com/images/chapter-4/4.2-immutability/shadow-error.png[]

Shadowing::
  Shadowing occurs when a constant defined within a certain scope has the same name as a constant defined in a outer scope. It often makes code hard to read and may create unnecessary bugs. *_Most programming languages allow shadowing by default, but Elm doesn’t._* It’s not surprising because two things Elm cares a lot about are minimizing bugs and easy-to-read code. You can read more about shadowing https://elm-lang.org/0.19.0/shadowing[here].

Let’s rename the `multiplier` constant in outer scope to `outerMultiplier`.

[source,elm]
----
outerMultiplier =
    6


multiplyByFive number =
    ...
----

Now, if you refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] once more, the error should be gone and you should see `15` again. Next, let’s try the same thing in `+elm repl+`.

[source,elm]
----
> multiplier = 5
5

> multiplier = 6
6
----

Hmm… why does the repl allow us to reassign a different value to `multiplier`? That’s because the repl works a little differently. Whenever we assign a different value to an existing constant, the repl _rebinds_ the constant to a new value. The rebinding process kills the constant and brings it back to life as if the constant was never pointing to any other value before. Without this rebinding process, it would be difficult to try things out in the repl.

==== Immutable Collections

In the <<tuple, Modifying Tuples>> section, when we were trying to understand why we couldn’t modify tuples, we discovered that all collections in Elm are also immutable. Because it’s hard to build anything useful if we can’t transform data from one form to another, Elm uses a clever technique to give us the appearance of adding or removing values from a collection.

[source,elm]
----
> numbers = [ 1, 2, 3 ]
[1,2,3]

> 0 :: numbers
[0, 1, 2, 3]

> List.drop 1 numbers
[2,3]
----

In the example above, we used the `+::+` operator to add `0` to the beginning of the `numbers` list and used the `drop` function to remove the first element from the same list. Although we were able to add and drop values from the list, its original content has remained intact.

[source,elm]
----
> numbers
[1,2,3]
----

Elm created a copy of the original list, added `0` to it, and returned it as the result. While this was all happening, the original list remained unchanged.

****
*Quote:* _“In a purely functional program, the value of a [constant] never changes, and yet, it changes all the time! A paradox!” - Joel Spolsky_
****

==== Performance Implications of Immutability

Creating a new copy of data whenever we update it sounds like an expensive operation from performance standpoint. This is a valid concern. However, Elm is smart and it knows the existing data is immutable. So it reuses it, in part or as a whole, when building new data. Consequently, immutability doesn’t really incur any performance penalty in Elm. Here is how the internal representation of the new list from the example above looks:

image:https://elmprogramming.com/images/chapter-4/4.2-immutability/immutability-performance.svg[]

==== Benefits of Immutability

We have talked a lot about how constants and values are immutable in Elm, but what benefits do we get from it? The primary benefit of immutability is that it allows us to write programs that behave as expected. This leads to highly maintainable code. To make this more concrete, let’s compare an implementation in Elm with another language that doesn’t have immutability baked in. JavaScript fits the bill.

Back in the <<list, Sorting a List>> section, we learned how to sort a list containing the top seven highest scores (shown below) from regular season games in NBA history in different orders.

[source,elm]
----
[ 316, 320, 312, 370, 337, 318, 314 ]
----

Let’s say the NBA has decided to allow a new performance-enhancing drug that has the potential to double each player’s scoring. This will make it hard to compare current players against players who have already retired, so we need to adjust all historical stats. Let’s write a function to do that. We will first write it in JavaScript — a language that allows mutation — to find out what could go wrong.

****
NOTE: Don’t worry if you have never used JavaScript before. The example below is quite simple and you should be able to follow along without any difficulty.
****

Create a new file called `experiment.js` in the `+beginning-elm+` directory and add the code below to it.

[source,bash]
----
$ tree beginning-elm-code/chapter-4/4.2-immutability/
└── beginning-elm    
    ├── elm.json     
    ├── experiment.js           <- - - -
    ├── homepage.html
    ├── index.html   
    └── src
        ├── HomePage.elm
        └── Playground.elm
----
// image:https://elmprogramming.com/images/chapter-4/4.2-immutability/experiment-javascript-file.png[]

[source,javascript]
----
var scoreMultiplier = 2;
var highestScores = [316, 320, 312, 370, 337, 318, 314];

function doubleScores(scores) {
    for (var i = 0; i < scores.length; i++) {
        scores[i] = scores[i] * scoreMultiplier;
    }

    return scores;
}
----

* `highestScores` — A variable that points to a list of highest scores.
* `scoreMultiplier` — A variable that points to a number used to multiply each element in the `highestScores` list.
* `doubleScores` — A function that takes a list of scores; iterates through each element in the list using a `for` loop; and multiplies them by a value held in the `scoreMultiplier` variable.

Next, load `experiment.js` in `index.html`, which is also located inside the `+beginning-elm+` directory.

[source,html]
----
<!DOCTYPE html>
<html>
  .
  .
  <body>
    .
    .
    <script src="elm.js"></script>
    <script src="experiment.js"></script>
    .
    .
  </body>
</html>
----

****
NOTE: As mentioned in the <<elm-compiler, Elm Compiler>> section, it’s perfectly fine to use both Elm and JavaScript code side by side.
****

Open `index.html` in a browser and then go to the browser console.

Opening browser console::
  Instructions for opening the browser console depends on which browser you’re using. Please read https://www.wickedlysmart.com/hfjsconsole/[this nice tutorial from WickedlySmart] to learn how to open the console on various browsers.

Verify that the code in `experiment.js` is loaded successfully by printing the following values from the console.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> scoreMultiplier
2
----

Let’s see `doubleScores` function in action. Call it from the console like this:

[source,javascript]
----
> doubleScores(highestScores)
[632, 640, 624, 740, 674, 636, 628]
----

So far everything looks good. Now let’s go ahead and redefine the `scoreMultiplier` variable in `experiment.js` so that it points to `3` instead.

[source,javascript]
----
var scoreMultiplier = 2;
var highestScores = [316, 320, 312, 370, 337, 318, 314];

var scoreMultiplier = 3;
.
.
----

Notice the original definition `+var scoreMultiplier = 2;+` is still there. Reload `index.html` in the browser so our changes to `experiment.js` will take effect. After that, apply the `doubleScores` function to the `highestScores` list by typing the code below into the browser console.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[948, 960, 936, 1110, 1011, 954, 942]
----

`doubleScores` now triples each element in the `highestScores` list. This is problematic. The new behavior does not match its name. We want it to double the scores no matter what, so that other people reading our code aren’t confused by the mismatch.

Unfortunately, most languages that allow mutation suffer from this problem. It’s especially frustrating when the redefinition happens in a remote part of the code, which is hard to detect. At least in the example above, we can see that `scoreMultiplier` is being redefined close to the original definition and we can correct it. But in the real world, most problems caused by mutation tend to manifest after the code has been deployed to a production environment.

How does Elm deal with this situation? Well, let’s reimplement the code above in Elm to find out. Add the following code right above `main` in `Playground.elm`.

[source,elm]
----
scoreMultiplier =
    2


highestScores =
    [ 316, 320, 312, 370, 337, 318, 314 ]


scoreMultiplier =
    3


doubleScores scores =
    List.map (\x -> x * scoreMultiplier) scores

----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see the following error.

[source]
----
-- NAME CLASH  chapter-4\4.2-immutability\beginning-elm\src\Playground.elm

This file has multiple `scoreMultiplier` declarations. One here:

189| scoreMultiplier =
     ^^^^^^^^^^^^^^^
And another one here:

192| scoreMultiplier =
     ^^^^^^^^^^^^^^^
How can I know which one you want? Rename one of them!
----
// image:https://elmprogramming.com/images/chapter-4/4.2-immutability/duplicate-assignment-error-2.png[]

It’s exactly the same error we got in the <<immutability, Immutable Constants>> section above. Elm doesn’t allow us to redefine `scoreMultiplier` in the same scope. Remove the second definition of `scoreMultiplier` from `Playground.elm`.

[source,elm]
----
scoreMultiplier =
    3
----

===== Mutation

The JavaScript code above has one more issue: it mutates the original `highestScores` list. Reload `index.html` in browser and enter the following code in console.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[948, 960, 936, 1110, 1011, 954, 942]

> highestScores
[948, 960, 936, 1110, 1011, 954, 942]
----

As you can see the values inside the `highestScores` list have changed. This is also problematic. To understand why, let’s remove the redefinition `+var scoreMultiplier = 3+` from `experiment.js` and add two new functions below the `doubleScores` function like this:

[source,javascript]
----
var scoreMultiplier = 2;
var highestScores = [316, 320, 312, 370, 337, 318, 314];

function doubleScores(scores) {
    for (var i = 0; i < scores.length; i++) {
        scores[i] = scores[i] * scoreMultiplier;
    }

    return scores;
}

function scoresLessThan320(scores) {
    return scores.filter(isLessThan320);
}

function isLessThan320(score) {
    return score < 320;
}
----

As its name suggests, the `scoresLessThan320` function returns all scores that are less than `320`. It delegates the task of checking whether a score is less than `320` or not to the `isLessThan320` function. Reload `index.html` in browser and call the `scoresLessThan320` function from console like this:

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> scoresLessThan320(highestScores)
[316, 312, 318, 314]
----

`scoresLessThan320` gives us what we expect. But what will happen if we apply the `doubleScores` function before `scoresLessThan320`? To find out let’s reload `index.html` in browser one more time so that we’re starting fresh. After that, apply the functions as shown below in console.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[632, 640, 624, 740, 674, 636, 628]

> scoresLessThan320(highestScores)
[]
----

`scoresLessThan320` reports that there are no scores below `320`, which is incorrect. This is because `doubleScores` doubled the values and saved them back into the original list which we ended up passing to `scoresLessThan320` without realizing that it has already been changed.

image:https://elmprogramming.com/images/chapter-4/4.2-immutability/mutation-unexpected-result.svg[]

What we really intended to happen was this:

image:https://elmprogramming.com/images/chapter-4/4.2-immutability/mutation-expected-result.svg[]

===== How to Avoid Mutation?

Can this problem be avoided in JavaScript? Absolutely. Replace the current implementation of `doubleScores` in `experiment.js` with this:

[source,javascript]
----
function doubleScores(scores) {
    var newScores = [];

    for (var i = 0; i < scores.length; i++) {
        newScores[i] = scores[i] * scoreMultiplier;
    }

    return newScores;
}
----

`doubleScores` doesn’t modify the existing list anymore. Instead it always returns a new one. Refresh the browser and call `doubleScores` and `scoresLessThan320` in the same order as before.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[632, 640, 624, 740, 674, 636, 628]

> scoresLessThan320(highestScores)
[316, 312, 318, 314]
----

Now it works as expected. Let’s try this in Elm to see if we will get different results depending on which order we call the `scoresLessThan320` function. Add the following definitions right above `main` in `Playground.elm`

[source,elm]
----
scoresLessThan320 scores =
    List.filter isLessThan320 scores


isLessThan320 score =
    score < 320
----

To properly compare the results from JavaScript and Elm, we need to load the code from `Playground.elm` into `+elm repl+`. Before we do that though, we need to expose some values from the `Playground` module. Modify the first line in `Playground.elm` to this:

[source,elm]
----
module Playground exposing
    ( doubleScores
    , highestScores
    , main
    , scoresLessThan320
    )
----

****
NOTE: We’ll discuss the syntax for exposing valus from a module in detail later in the <<easier-code-organization, Creating a Module>> section.
****

Now we’re ready to import the `Playground` module in `+elm repl+`.

[source,elm]
----
> import Playground exposing (doubleScores, highestScores, scoresLessThan320)
----

We exposed `doubleScores`, `highestScores`, and `scoresLessThan320` so that we don’t have to prefix the module name when we use them. Not having prefix makes it easier to compare our Elm code with the JavaScript code listed above. As mentioned in the http://localhost:4000/string.html#calculating-length[Strings] section, be careful not to run into name collision when exposing values like this.

One other thing we need to keep in mind is that the `Playground.elm` file must be located inside the `src` directory. Otherwise, `+elm repl+` won’t know about it because in the `elm.json` file we have specified `src` as the only source directory.

[source,json]
----
{
    .
    .
    "source-directories": [
        "src"
    ],
    .
    .
}
----

Let’s say we decided to move `Playground.elm` to a new directory called `code`. Now we’ll have to include `code` in `+source-directories+` as shown below, otherwise the repl won’t find it.

[source,json]
----
{
    .
    .
    "source-directories": [
        "src",
        "code"
    ],
    .
    .
}
----

Now let’s apply `scoresLessThan320` before `doubleScores` and see what we get.

[source,elm]
----
> highestScores
[316,320,312,370,337,318,314]

> scoresLessThan320 highestScores
[316,312,318,314]

> doubleScores highestScores
[632,640,624,740,674,636,628]
----

We get what we expect. Now let’s apply `scoresLessThan320` after `doubleScores`.

[source,elm]
----
> highestScores
[316,320,312,370,337,318,314]

> doubleScores highestScores
[632,640,624,740,674,636,628]

> scoresLessThan320 highestScores
[316,312,318,314]
----

Again, we get what we expect. No matter which order we apply the functions in, we get the exact same result. In Elm, we don’t need to implement `scoresLessThan320` in a special way for it to behave consistently.

Although we were able to resolve the issue introduced by mutation in JavaScript by explicitly returning a new list, we had to be cognizant of the fact that immutability isn’t baked into JavaScript. That made us take extra precaution. This can get tiresome as the code base grows. However, in Elm <<list, `List.map`>> (and all other functions in the `List` module) always return a new list by default. Having immutability baked into the language itself allows us to completely avoid problems like these.


[[pure-functions]]
=== 4.3 Pure Functions


In the <<immutability, Immutability>> section, when we called the `scoresLessThan320` JavaScript function, we received different results depending on which order we called it. When we called it before `doubleScores`, we got what we expected.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> scoresLessThan320(highestScores)
[316, 312, 318, 314]
----

But when we called it after `doubleScores`, we received a completely different result.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[632, 640, 624, 740, 674, 636, 628]

> scoresLessThan320(highestScores)
[]
----

A function that exhibits an inconsistent behavior like this is said to be _impure_. In contrast, all functions in Elm are _pure_, which means they will _always_ return the exact same output given the same input, regardless of the order they’re called in.

[source,elm]
----
> highestScores
[316,320,312,370,337,318,314]

> scoresLessThan320 highestScores
[316,312,318,314]

> doubleScores highestScores
[632,640,624,740,674,636,628]
----

[source,elm]
----
> highestScores
[316,320,312,370,337,318,314]

> doubleScores highestScores
[632,640,624,740,674,636,628]

> scoresLessThan320 highestScores
[316,312,318,314]
----

There is one more condition a function has to meet to become _pure_: it shouldn’t cause any _side effects_. Before we understand what a side effect is it’s important for us to know what a _state_ is.

==== What is a state?

A state represents all the information stored at a given instant in time that a function has access to. In the <<immutability, Immutability>> section we wrote this code:

[source,elm]
----
scoreMultiplier =
    2


doubleScores scores =
    List.map (\x -> x * scoreMultiplier) scores
----

The state of `doubleScores` is whatever information stored in the parameter `scores` and constant `scoreMultiplier` because it has access to both. If we were to introduce another constant called `differentMultiplier` like this:

[source,elm]
----
differentMultiplier =
    3


scoreMultiplier =
    2


doubleScores scores =
    List.map (\x -> x * scoreMultiplier) scores
----

That would also become a part of the `doubleScores` function’s state. Even if `doubleScores` doesn’t use `differentMultiplier` in its definition, it can still access that constant.

==== Side Effect

A function has a side effect if it modifies its state. In other words, a function causes a side effect if it performs any other action apart from calculating its return value. Elm functions don’t have side effects.

The `doubleScores` function above cannot modify any part of its state. Because `scores`, `scoreMultiplier`, and `differentMultiplier` are all immutable, Elm prohibits `doubleScores` from modifying them.

Therefore, an Elm function doesn’t remember one or more preceding events in a given sequence of operations. Each interaction with a function happens based entirely on the information given to it.

****
NOTE: In <<side-effects, Chapter 5>>, we’ll learn how the <<elm-runtime, Elm runtime>> uses various techniques to shield our application code from harmful side effects caused by operations such as sending or reciving data form an HTTP server or listening to a web socket message.
****

In the <<function, Functions>> section, we learned that a function in mathematics is a relationship from a set of inputs to a set of possible outputs where each input is mapped to exactly one output.

image:https://elmprogramming.com/images/chapter-3/3.10-function/function.svg[]

Functions in Elm will _always_ return the same output given the same input and they don’t have any side effects. Their behavior aligns perfectly well with how functions work in mathematics.

Referential Transparency::
  If an expression can be replaced with the value it evaluates to without changing the program’s behavior at all, that expression is said to have referential transparency. Since functions in Elm are expressions that always return the same output given the same input, they are referentially transparent. We can safely replace a function application with its output anywhere in an Elm program, and it will work just the same as it did before.

Whereas in an impure language such as JavaScript, functions are free to modify their state. We already discovered that the `doubleScore` function in JavaScript _can_ modify the `scores` list parameter even though we were very careful not to do that in its implementation.

[source,javascript]
----
var scoreMultiplier = 2;
var highestScores = [316, 320, 312, 370, 337, 318, 314];

function doubleScores(scores) {
    var newScores = [];

    for (var i = 0; i < scores.length; i++) {
        newScores[i] = scores[i] * scoreMultiplier;
    }

    return newScores;
}
----

It can also modify the `scoreMultiplier` variable which is defined outside of it. Go to `experiment.js` and reset `scoreMultiplier`’s value to `3` right above the line where `newScores` is returned like this:

[source,javascript]
----
var scoreMultiplier = 2;
var highestScores = [316, 320, 312, 370, 337, 318, 314];

function doubleScores(scores) {
    var newScores = [];

    for (var i = 0; i < scores.length; i++) {
        newScores[i] = scores[i] * scoreMultiplier;
    }

    scoreMultiplier = 3;

    return newScores;
}
----

Now let’s find out the consequences of changing the state as we’ve done here. Reload `index.html` in browser and enter the following code in console.

[source,javascript]
----
> scoreMultiplier
2

> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[632, 640, 624, 740, 674, 636, 628]
----

So far everything looks good. Let’s see what happens if we apply `doubleScores` again to the `highestScores` list.

[source,javascript]
----
> doubleScores(highestScores)
[948, 960, 936, 1110, 1011, 954, 942]
----

It tripled each element in the list which is not what we want. That’s because it reassigned `scoreMultiplier` to `3` after it was done doubling each element in the previous run. By modifying its state, the `doubleScore` function has caused a side effect that resulted in unintended consequences.

==== Benefits of Pure Functions

What practical benefits do we get from pure functions? They are useful to us in many ways such as:

*1. Easy to understand code* — The idea of _easy to understand code_ is very subjective and depends on each programmer’s perception of what easy really means to them. That said, when we can rely on our functions to not behave in surprising new ways, understanding our program’s behavior does become somewhat easier in Elm. Functions in Elm aren’t affected by the external state. They are also prohibited from modifying any state. As a result, we don’t need to mentally keep track of things that aren’t in their scope. Just by looking at the input and output we can understand a function’s behavior quite a bit.

*2. Easy to debug* — It’s much easier to find the root cause of a bug in a program built by assembling pure functions. Since functions in Elm don’t depend on unrelated code that was executed before them, we can reliably reproduce the bug. Once it’s reproduced, finding the root cause of a bug is also easy. We pause the execution of our program and examine each function’s output. Because a function in Elm depends only on its arguments and other immutable constants in its scope, all the information being fed to a function is right before our eyes. If we see a function producing unexpected output, then we must have incorrectly implemented the logic inside that function. This differs from languages that lack immutability and pure functions. When functions in those languages produce unexpected output, we can’t be certain that the logic is wrong because the function depends on an unpredictable external state.

*3. Easy to test* — Verifying that our functions work exactly how we expect them to also becomes easier when they are pure. There are multiple ways to verify a function’s behavior. One such technique is to write _unit tests_ which determine whether an individual unit of source code can be used reliably. In Elm, that individual unit of code is a function. When we write our unit tests, we repeatedly pass values to a function from its input set and verify that the values it produces belong to its output set. Since a pure function doesn’t rely on external states, we don’t need to worry about writing tests that verify whether the function caused any side effects. Whereas in languages that lack pure functions, writing such tests is not only necessary, but tricky as well. We will <<easy-to-test, learn how to write tests>> later in this chapter.

*4. Solving complex problems with simple functions* — An effective way of solving a problem is to break it into smaller problems first. We can then write small reliable functions that solve each mini-problem separately. We then put the functions back together to create a solution that solves the original complex problem. It’s incredibly difficult to apply this technique if the functions aren’t pure. We will see a concrete example of how to <<function-composition, combine pure functions to solve a complex problem>> later in this chapter.

In the next couple of sections, we’ll dig deeper into how pure functions enable us to create elegant solutions to large problems through composition and why it’s easier to test them.


[[function-composition]]
=== 4.4 Solving Complex Problems with Simple Functions


****
*Quote:* _“Whenever trying to make complicated systems and understand them, it’s crucial to divide the things up into as many pieces as I can, each of which I understand separately. I would like to understand the way of adding things up independently of what it is I’m adding up.” - https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/2a-higher-order-procedures/[Gerald Sussman]_
****

==== Implementing a 4-bit Ripple-Carry Adder

****
NOTE: 行波进位加法器（Ripple-Carry Adder）。首先，我需要回忆一下什么是行波进位加法器。行波进位加法器是由多个全加器（Full Adder）级联而成的，每个全加器的进位输出连接到下一个全加器的进位输入。这样，进位信号像波浪一样从低位传递到高位，因此得名。
****

Let’s work through an example to understand how functions that solve simple problems can be combined to solve a complex problem. The problem we want to solve is simulating the behavior of a 4-bit ripple-carry adder using an Elm program. “4-bit ripple-carry adder” is a bit of a mouthful, so let’s break down what that means word by word.

* *4-bit:* “bit” is short for binary digit. So 4-bit means a four digit binary number, like `1001`.
* *Ripple-Carry:* Remember how in the early days of learning addition, you were taught that when you add `5` + `5` you carry the `1` left one column, resulting in `10`? Then once you were comfortable with that concept, you moved on to math problems with two carries — like adding `95` + `5`. First, you carry the one that is the result of `5` + `5` left one column, but then when you add `1` to `9` in that column you need to carry another `1` to the another left column, resulting in `100`. That’s basically what a “ripple-carry” is — each number that is carried out of one column is then carried in to the next column.
* *Adder:* A digital circuit that adds two binary numbers.

First, let’s understand how the binary system works before diving deeper into the ripple-carry adder.

==== Binary System

The decimal numeral system is the mathematical system most people are familiar with. In the decimal system, the integers `0` through `9` are combined in different ways to represent all numbers. It uses base-10 notation, which means each digit in a number is ten times larger than the digit to its right. The figure below breaks down the decimal number `4608` so you can see for yourself – the digits start from 10^0^ on the right, then the next digit to the left is ten times larger at 10^1^, then the digit to the left of that is ten times larger at 10^2^, and so on.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/decimal-base-10.svg[]

The binary system, however, has only two integers — `0` and `1`. It uses base-2 notation, which means each digit in a binary number is two times larger than the digit to its right. Here’s an example of the binary number `1101`:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/binary-base-10.svg[]

If you are wondering what decimal number the binary `1101` is equivalent to, it’s easy to find out. Just evaluate the bottom row of the above figure as one mathematical expression, and you will see that you get a final result of `13`. `13` is the decimal equivalent of `1101` in binary.

==== Binary Addition

Adding binary numbers is much like adding everyday decimal numbers, except that it carries on a value of `2` instead of `10`. For example, in decimal, if we add `6` + `3` we get `9`. But if we add `6` + `4`, we’ve run out of single integers to represent what comes next! That’s when the digit on the far right resets to zero, and we now have a one to carry into the next digit spot on the left.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/decimal-addition-carry.svg[]

In binary, if we add `1` + `1` we are in the same pickle as the decimal `6` + `4` example above: we have exhausted the integers available to us. When you run out of integers, it’s time to reset the digit on the right to zero and carry the one into the next digit spot on the left.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/binary-addition-carry.svg[]

By this logic, it’s easy to keep adding binary numbers together. Let’s find out what the decimal number `4` is equivalent to in binary. Remember, every time we run out of numbers, that means it’s time to reset to zero and carry the one:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/adding-four-in-binary.svg[]

Now we can see, `4` in decimal system is `100` in binary.

==== Adding Numbers with a 4-bit Ripple-Carry Adder

A 4-bit ripple-carry adder can add binary numbers up to four digits. The figure below shows an example, adding the binary numbers `1110` + `1011`, with the digits to carry shown in purple.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/4-digit-binary-addition.svg[]

A ripple-carry adder adds two digits at a time starting from the right. If there’s a carry, it propagates that to the next addition. Once it’s done adding all four digits, the output is presented to us like this:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/4-bit-ripple-carry-adder-output.svg[]

A~0~, A~1~, A~2~, and A~3~ represent the individual digits of the first number. B~0~, B~1~, B~2~, and B~3~ represent the individual digits of the second number. S~0~, S~1~, S~2~, and S~3~ represent the individual digits of the sum. C~out~ represents the most significant digit of the sum. The most significant digit is the digit that has the greatest value. In the case of a binary number, that’s the digit all the way to the left. Here is a circuit diagram for a 4-bit ripple-carry adder.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/4-bit-ripple-carry-adder.svg[]

*C~in~* is the carry-in bit from the previous addition and *C~out~* is the carry-out bit that will be passed to the next addition.

The circuit above is what we want to simulate in Elm. Where should we start? Well, the first thing we need to do is look for ways to break the problem at hand into smaller problems. If we look closer, we can see that a ripple-carry adder uses the same adder repeatedly but with different inputs and outputs. This adder acts as a building block for a ripple-carry adder and is called _1-bit full adder_. Let’s figure out how we can implement a 1-bit full adder before we implement a ripple-carry adder.

[[1-bit-full-adder]]
==== 1-bit Full Adder

A 1-bit full adder adds only two binary digits, but it’s capable of accepting a carry-in value as well. It takes three inputs and produces two outputs as shown in the figure below:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/full-adder.svg[]

A~n~ and B~n~ represent the binary digits that need adding. C~n~ represents the carry-in digit, and C~n+1~ represents the carry-out digit. S~n~ represents the least significant digit of the sum. The least significant digit is the digit that has the lowest value. In a binary number, that’s the digit all the way to the right. Here’s a truth table that shows all the possible inputs and outputs produced by a full adder:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/full-adder-truth-table.svg[]

Can we break a 1-bit full adder further into something even smaller? As it turns out, we can as shown in the figure below.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/full-adder-internals.svg[]

A full adder can be implemented using two half adders and an OR gate. We’ll find out what an OR gate is soon, but first let’s understand how a half adder works.

==== Half Adder

A half adder also adds two binary digits, but unlike a full adder it doesn’t accept a carry-in value.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/half-adder.svg[]

Here’s a truth table that shows all the possible inputs and outputs for a half adder:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/half-adder-truth-table.svg[]

We can break its implementation into even smaller components: AND gate, OR gate, and inverter.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/half-adder-internals.svg[]

==== AND Gate

An AND gate takes two input signals and returns an output that is the _logical and_ of the inputs. It’s equivalent to the <<boolean, `+&&+` operator>> in Elm.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/and-gate.svg[]

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/and-gate-truth-table.svg[]

==== OR Gate

An OR gate takes two input signals and returns an output that is the _logical or_ of the inputs. It’s equivalent to the <<boolean, `+||+` operator>> in Elm.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/or-gate.svg[]

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/or-gate-truth-table.svg[]

==== Inverter

An inverter takes one input signal and inverts it. If the input is `0` it returns `1` as the output. If the input is `1`, it returns `0` as the output. It’s equivalent to the <<boolean, `not` function>> in Elm.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/inverter.svg[]

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/inverter-truth-table.svg[]

Now that we have broken down our original problem (4-bit ripple-carry) into its essential building blocks (AND gate, OR gate, and inverter),
we can start building a solution by first implementing the building blocks.

==== Implementing an AND Gate

Let’s create a separate file that will contain all the code we will be writing as we implement different parts of a 4-bit ripple-carry adder. In the `+beginning-elm/src+` directory, create a new file called `RippleCarryAdder.elm`.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/ripple-carry-adder-directory.png[]

Add the following code to the `RippleCarryAdder.elm` file.

[source,elm]
----
module RippleCarryAdder exposing (andGate)

import Bitwise


andGate a b =
    Bitwise.and a b
----

We declared a new module called `RippleCarryAdder` and imported an existing module called https://package.elm-lang.org/packages/elm/core/latest/Bitwise[Bitwise], which includes functions for manipulating individual bits. As it so happens, the `Bitwise.and` function does exactly what our AND gate is supposed to do which is to compute a _logical and_ of two input signals.

You may be wondering why we didn’t just use the `+&&+` operator to implement the `andGate` function. That’s because it only works for boolean values. Since we are trying to simulate a digital circuit, we want to work with `0`s and `1`s instead of `True` and `False` although conceptually they are equivalent in our case.

In most cases it doesn’t make sense to create a new function that just wraps an existing function, but here the name `andGate` is bit more revealing in the context of a digital circuit than just `and`.

Let’s load `andGate` in repl and verify that it works as expected. Run `+elm repl+` from the `+beginning-elm+` directory in terminal to launch the repl, and expose the `andGate` function when importing the `RippleCarryAdder` module like this:

[source,elm]
----
> import RippleCarryAdder exposing (..)

> andGate 0 0
0

> andGate 0 1
0

> andGate 1 0
0

> andGate 1 1
1
----

****
NOTE: Unlike the `Playground` module, we didn’t write a `main` function in `RippleCarryAdder`. That’s because we will be executing the code in `RippleCarryAdder` only from the repl. We need a `main` function only if we want to run our code in the browser.
****

Although there’s only one function in the `RippleCarryAdder` module right now, we used `+(..)+` to expose everything in it. It’ll make it easier for us to test things from that module as we add more functions to it. Our function names will continue to be very descriptive, so there’s a very little chance of them colliding with other names that may have already been imported.

==== Implementing an OR Gate

The `Bitwise` module also includes a function for computing a _logical or_ of two signals. Let’s use that to implement an OR gate. Add the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
orGate a b =
    Bitwise.or a b
----

We also need to expose the `orGate` function. Modify the first line in `RippleCarryAdder.elm` to this:

[source,elm]
----
module RippleCarryAdder exposing (andGate, orGate)
----

****
NOTE: When defining a module, Elm doesn’t allow us to expose everything inside it by using `+(..)+`. We can do that only when we `import` the module as we saw earlier inside `+elm repl+`. Therefore, we have to explicitly mention the name of the value we intend to expose after the `exposing` keyword. This is a good thing. We should expose as little as possible from a module. This reduces unnecessary dependencies between modules making our code more maintainable. We’ll discuss this in detail later in the <<easier-code-organization, Easier Code Organization>> section.
****

Let’s load `orGate` up in the repl and verify that it works as expected.

[source,elm]
----
> orGate 0 0
0

> orGate 0 1
1

> orGate 1 0
1

> orGate 1 1
1
----

We don’t need to reimport the `RippleCarryAdder` module whenever we make any changes to it. The repl automatically reloads a module when it detects a change. Isn’t that nice?

==== Implementing an Inverter

There is no suitable function in the `Bitwise` module that does what an inverter is supposed to do, so let’s roll our own. Add the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
inverter a =
    case a of
        0 ->
            1

        1 ->
            0

        _ ->
            -1
----

And expose `inverter` in the module definition.

[source,elm]
----
module RippleCarryAdder exposing (andGate, inverter, orGate)
----

****
NOTE: Did you notice that <<installation, elm-format>> automatically sorts the exposed values in alphabetical order? That’s nice, isn’t it? The https://github.com/elm[Elm core team members] have been working hard to bring us tools that save time by automating mundane tasks like this.
****

The `inverter` function flips the input signal using a `case` expression. If the input signal is `0` it returns `1` and vice versa. If the input signal is anything other than `0` or `1`, it returns `+-1+`. We used negative `1` to indicate an input signal doesn’t represent a valid binary number, although any number other than `0` and `1` would work.

If we don’t add the `+_ -> -1+` catch-all pattern, Elm will complain because without it we wouldn’t be accounting for all possible integer values the parameter `a` can hold. This is not an elegant way to implement an inverter, but it gets the job done. Once we get introduced to <<type-system, types>> later in this chapter, we can refine this implementation. Let’s verify that `inverter` works as expected in the repl.

[source,elm]
----
> inverter 0
1

> inverter 1
0
----

Now that we have implemented the basic building blocks, we can start implementing the more complex parts.

==== Implementing a Half Adder

We can implement a half adder by adding the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
halfAdder a b =
    let
        d =
            orGate a b

        e =
            andGate a b
                |> inverter

        sumDigit =
            andGate d e

        carryOut =
            andGate a b
    in
    { carry = carryOut
    , sum = sumDigit
    }
----

Let’s expose `halfAdder` in the module definition.

[source,elm]
----
module RippleCarryAdder exposing (andGate, halfAdder, inverter, orGate)
----

The `halfAdder` function mimics the <<function-composition, half adder circuit>> we saw earlier. It uses all three logic gates we implemented before to compute a sum and a carry which are then returned as a record. The constants `d` and `e` hold onto the intermediate results that get passed to an AND gate to compute the final sum.

In the http://localhost:4000/tuple.html#using-tuples[Using Tuples] section, we learned that when we want to return multiple values from a function, we should consider using a tuple. But records are also useful for returning multiple values. If we use a record in this instance, when we look at the output of `halfAdder`, it’ll be easier for us to recognize which digit is a sum and which digit is a carry.

In the record above we added the comma in front of `+sum = sumDigit+` instead of adding it at the end of the previous line. In most languages, it’s best practice to add commas at the end when we create a collection, but the Elm style guide recommends adding them in the front. That’s because it’s easier to spot a missing comma when they’re all in the front. For example, here’s a bigger record with commas in the end:

[source,elm]
----
{ carry1 = carryOut1,
  sum1 = sumDigit1,
  carry2 = carryOut2
  sum2 = sumDigit2,
  carry3 = carryOut3,
  sum3 = sumDigit3
}
----

It’s hard to notice that the third line is missing a comma. But if we move them all to the front it’s much easier to spot a missing comma.

[source,elm]
----
{ carry1 = carryOut1
, sum1 = sumDigit1
, carry2 = carryOut2
  sum2 = sumDigit2
, carry3 = carryOut3
, sum3 = sumDigit3
}
----

The Elm compiler will easily catch errors like this, but by putting the commas in the front we save ourselves an extra trip to the compiler land. Let’s verify that the `halfAdder` function works as expected.

[source,elm]
----
> halfAdder 0 0
{ carry = 0, sum = 0 }

> halfAdder 0 1
{ carry = 0, sum = 1 }

> halfAdder 1 0
{ carry = 0, sum = 1 }

> halfAdder 1 1
{ carry = 1, sum = 0 }
----

==== Implementing a 1-bit Full Adder

Let’s implement a full adder next by using two half adders and an OR gate. Add the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
fullAdder a b carryIn =
    let
        firstResult =
            halfAdder b carryIn

        secondResult =
            halfAdder a firstResult.sum

        finalCarry =
            orGate firstResult.carry secondResult.carry
    in
    { carry = finalCarry
    , sum = secondResult.sum
    }
----

And expose `fullAdder` in the module definition.

[source,elm]
----
module RippleCarryAdder exposing
    ( andGate
    , fullAdder
    , halfAdder
    , inverter
    , orGate
    )
----

****
NOTE: When the module definition line gets too long, it’s recommended that you break it into multiple lines as we have done here.
****

The `fullAdder` function also mimics the <<function-composition, full adder circuit>> we saw earlier. A full adder is capable of taking a carry-in value as one of the inputs. So we give it a third parameter that represents a carry-in value in addition to the two input signals: `a` and `b`. Let’s verify that the logic in `fullAdder` works as expected.

[source,elm]
----
> fullAdder 0 0 0
{ carry = 0, sum = 0 }

> fullAdder 0 0 1
{ carry = 0, sum = 1 }

> fullAdder 0 1 0
{ carry = 0, sum = 1 }

> fullAdder 0 1 1
{ carry = 1, sum = 0 }

> fullAdder 1 0 0
{ carry = 0, sum = 1 }

> fullAdder 1 0 1
{ carry = 1, sum = 0 }

> fullAdder 1 1 0
{ carry = 1, sum = 0 }

> fullAdder 1 1 1
{ carry = 1, sum = 1 }
----

==== Implementing a 4-bit Ripple-Carry Adder

Finally, we’re ready to implement a 4-bit ripple-carry adder. Add the following code to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
type alias Binary =
    { d0 : Int
    , d1 : Int
    , d2 : Int
    , d3 : Int
    }


rippleCarryAdder a b carryIn =
    let
        firstResult =
            fullAdder a.d3 b.d3 carryIn

        secondResult =
            fullAdder a.d2 b.d2 firstResult.carry

        thirdResult =
            fullAdder a.d1 b.d1 secondResult.carry

        finalResult =
            fullAdder a.d0 b.d0 thirdResult.carry
    in
    { carry = finalResult.carry
    , sum0 = finalResult.sum
    , sum1 = thirdResult.sum
    , sum2 = secondResult.sum
    , sum3 = firstResult.sum
    }
----

And expose `Binary` and `rippleCarryAdder` in the module definition.

[source,elm]
----
module RippleCarryAdder exposing
    ( Binary
    , rippleCarryAdder
    .
    .
    )
----

Unlike most other languages, Elm doesn’t provide a way to represent binary numbers yet. For example, in JavaScript we can represent them by adding `0b` as a prefix:

[source,javascript]
----
var a = 0b1110    // Equivalent to 14 in decimal
var b = 0b1011    // Equivalent to 11 in decimal
----

Therefore, we have to do some extra work to pass binary numbers as inputs to the `rippleCarryAdder` function. For now, the simplest way is to define a record called `Binary`.

[source,elm]
----
type alias Binary =
    { d0 : Int
    , d1 : Int
    , d2 : Int
    , d3 : Int
    }
----

`rippleCarryAdder` computes the final sum and a carry-out by repeatedly applying the `fullAdder` function to each digit. Let’s verify that it works as expected.

[source,elm]
----
> a = Binary 1 1 0 1
{ d0 = 1, d1 = 1, d2 = 0, d3 = 1 }

> b = Binary 1 0 1 1
{ d0 = 1, d1 = 0, d2 = 1, d3 = 1 }

> rippleCarryAdder a b 0
{ carry = 1, sum0 = 1, sum1 = 0, sum2 = 0, sum3 = 0 }
----

To summarize, we took a complex problem of building a 4-bit ripple-carry adder and broke it down to its essential building blocks: AND gate, OR gate, and inverter. We used those building blocks to implement a half adder. We then used a half adder and an OR gate to implement a full adder. Finally, we combined four full adders to implement a 4-bit ripple-carry adder.

We used small reliable functions to build bigger and equally reliable functions. This pattern of solving a complex problem by combining small functions is quite common in functional programming languages such as Elm. The main reason this pattern works well is because all functions in Elm are <<pure-functions, pure>>.

==== Improving Inputs and Outputs

The `rippleCarryAdder` function uses records to represent the input and output signals. It would be much nicer, if we could just use plain old numbers like this:

[source,elm]
----
rippleCarryAdder 1110 1011 0
11001

rippleCarryAdder 1110 1011 1
11010
----

==== Improving Inputs

The first thing we need to do is extract digits from a binary number so that we can pass them individually to different full adders. Modify the `rippleCarryAdder` function as shown below. It now accepts numbers instead of records.

[source,elm]
----
rippleCarryAdder a b carryIn =
    let
        -- Extract digits
        firstSignal =
            extractDigits a

        secondSignal =
            extractDigits b

        -- Compute sum and carry-out
        firstResult =
            fullAdder firstSignal.d3 secondSignal.d3 carryIn

        secondResult =
            fullAdder firstSignal.d2 secondSignal.d2 firstResult.carry

        thirdResult =
            fullAdder firstSignal.d1 secondSignal.d1 secondResult.carry

        finalResult =
            fullAdder firstSignal.d0 secondSignal.d0 thirdResult.carry
    in
    { carry = finalResult.carry
    , sum0 = finalResult.sum
    , sum1 = thirdResult.sum
    , sum2 = secondResult.sum
    , sum3 = firstResult.sum
    }
----

===== Implementing extractDigits

We used a non-existent function called `extractDigits` to extract digits from input numbers. Let’s implement it next. Add the following code to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
extractDigits number =
    String.fromInt number
        |> String.split ""
        |> List.map stringToInt
        |> Array.fromList
        |> arrayToRecord
----

`extractDigits` accepts a number representing binary digits and takes it through several transformations until all digits have been extracted. Let’s understand how each transformation works.

****
NOTE: You don’t have to try the code listed in each step below. It’s there to show how `extractDigits` works. Some of it won’t even compile because we haven’t implemented all functions used inside `extractDigits` yet.
****

*Step 1:* Convert the input number to a string.

[source,elm]
----
> String.fromInt 1110
"1110"
----

*Step 2:* Split the string into a list.

[source,elm]
----
> String.split "" "1110"
["1","1","1","0"]
----

*Step 3:* Convert each string element inside the list back to a number.

[source,elm]
----
> List.map stringToInt [ "1", "1", "1", "0" ]
[1,1,1,0]
----

****
NOTE: Steps 1, 2, and 3 collectively represent a roundabout way of converting a number to a list of digits. Unfortunately, Elm doesn’t provide a straightforward function for that.
****

*Step 4:* Convert the list to an array so that we can access each digit by specifying an index.

[source,elm]
----
> Array.fromList [ 1, 1, 1, 0 ]
Array.fromList [1,1,1,0]
----

*Step 5:* Convert the array to a record.

[source,elm]
----
> arrayToRecord (Array.fromList [ 1, 1, 1, 0 ])
{ d0 = 1, d1 = 1, d2 = 1, d3 = 0 }
----

===== Implementing stringToInt

Next, let’s implement the `stringToInt` function we used inside `extractDigits`. Add the following code to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
stringToInt string =
    String.toInt string
        |> Maybe.withDefault -1
----

As its name suggests, the `stringToInt` function takes a string and converts it to an integer. `String.toInt` returns a `Maybe` because not all strings can be converted to an integer.

[source,elm]
----
> String.toInt "1"
Just 1 : Maybe Int

> String.toInt "hello"
Nothing : Maybe Int
----

As we learned in the <<regular-expression, Regular Expressions>> section, the `Maybe.withDefault` function can be used to extract a value out of a `Maybe` container. If the value is present, `Maybe.withDefaut` will unwrap it from `Just`. If the value is `Nothing`, it’ll return a default value. In `stringToInt` function above, the default value is `+-1+`, which represents an invalid binary number.

===== Implementing arrayToRecord

Next up, we need to implement the `arrayToRecord` function. Add the following code to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
arrayToRecord array =
    let
        firstElement =
            Array.get 0 array
                |> Maybe.withDefault -1

        secondElement =
            Array.get 1 array
                |> Maybe.withDefault -1

        thirdElement =
            Array.get 2 array
                |> Maybe.withDefault -1

        fourthElement =
            Array.get 3 array
                |> Maybe.withDefault -1
    in
    { d0 = firstElement
    , d1 = secondElement
    , d2 = thirdElement
    , d3 = fourthElement
    }
----

The `Array` module isn’t imported automatically by Elm, so we need to do that ourselves. Import it right above the line that imports the `Bitwise` module in `RippleCarryAdder.elm`.

[source,elm]
----
module RippleCarryAdder exposing
.
.
import Array
import Bitwise
----

As its name suggests, the `arrayToRecord` function takes an array, reads values at each index and puts them in a record. As we learned in the <<array, Array>> section, we can use the `Array.get` function to read a value from an array at a specific index.

[source,elm]
----
> import Array

> myArray = Array.fromList [ 0, 1, 2, 3, 4 ]
Array.fromList [0,1,2,3,4]

> Array.get 3 myArray
Just 3 : Maybe number
----

Like `String.toInt`, `Array.get` also doesn’t return the value we’re looking for directly. It returns a `Maybe` instead. That’s why we had to use the `Maybe.withDefault` function to extract each element. Now we can pass input signals as plain old numbers to `rippleCarryAdder`.

[source,elm]
----
> rippleCarryAdder 1110 1011 0
{ carry = 1, sum0 = 1, sum1 = 0, sum2 = 0, sum3 = 1 }
----

Ah, much better!

==== Improving Output

Let’s turn our attention to the output. Currently it looks like this:

[source,elm]
----
{ carry = 1, sum0 = 1, sum1 = 0, sum2 = 0, sum3 = 1 }
----

We want it to look like this instead:

[source,elm]
----
11001
----

It’s not difficult to show the output as a number. All we need to do is assemble the sum and carry-out digits in a list and turn that list into a number. Modify the code inside the `in` area in `rippleCarryAdder` function to the following.

[source,elm]
----
rippleCarryAdder a b carryIn =
    let
        .
        .
    in
    [ finalResult, thirdResult, secondResult, firstResult ]
        |> List.map .sum
        |> (::) finalResult.carry
        |> numberFromDigits
----

Let’s go through the new code step by step.

****
NOTE: You don’t have to try the code listed in each step below. It’s there to show how `rippleCarryAdder` produces a binary number as an output. Some of it won’t even compile because we haven’t implemented all functions used inside `rippleCarryAdder` yet.
****

*Step 1:* Put the records produced by each full adder into a list.

[source,elm]
----
> [ finalResult, thirdResult, secondResult, firstResult ]
...
----

Here is the output after some formatting:

[source,elm]
----
[
    { carry = 1, sum = 1 },
    { carry = 1, sum = 0 },
    { carry = 1, sum = 0 },
    { carry = 0, sum = 1 }
]
----

*Step 2:* Map the list of records into a list of sum digits.

[source,elm]
----
> List.map .sum [ finalResult, thirdResult, secondResult, firstResult ]
[1,0,0,1]
----

As mentioned in the <<record, Record>> section, the `map` function can be used to transform a list of records into a new list that contains values from a specific field. We used a special function called `+.sum+` to extract the sum digits from each record.

*Step 3:* Add the carry-out digit to the front of the list.

[source,elm]
----
> (::) finalResult.carry [1,0,0,1]
[1,1,0,0,1]
----

*Step 4:* Convert the list of digits into a number.

[source,elm]
----
> numberFromDigits [1,1,0,0,1]
11001
----

`numberFromDigits` is a function we haven’t implemented yet. Let’s do that next. Add the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
numberFromDigits digitsList =
    List.foldl (\digit number -> digit + 10 * number) 0 digitsList
----

`numberFromDigits` uses `foldl` to reduce a list of digits into a single number. If you don’t remember how `foldl` works, you may want to review the <<list, Folding a List>> section from chapter 3. The figure below shows how `numberFromDigits` combines the digits to create a number by repeatedly applying the anonymous function to each element in `digitsList`.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/numberFromDigits-foldl-iterations.svg[]

Now both inputs and outputs look much nicer.

[source,elm]
----
> rippleCarryAdder 1110 1011 0
11001
----

==== Inputs with Leading Zeros

Let’s try entering a binary number with leading zeros and see what happens.

[source,elm]
----
> rippleCarryAdder 1001 0011 0

----------------------- PARSE ERROR ---------------------------------
Normal numbers cannot start with zeros. Take the zeros off the front.

9|   rippleCarryAdder 1001 0011 0
                            ^
Only numbers like 0x0040 or 0.25 can start with a zero.
----

Unfortunately, Elm doesn’t like that. One way to get around this limitation is by padding the input with enough zeros in `extractDigits` like this:

[source,elm]
----
extractDigits number =
    String.fromInt number
        |> String.padLeft 4 '0'
        |> String.split ""
        |> List.map stringToInt
        |> Array.fromList
        |> arrayToRecord
----

But this whole approach of converting a number to a string which gets padded with zeros and then gets converted back to numbers feels a bit clumsy. Why don’t we write a function that directly converts a number into a list of digits without involving any string operation? Add the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
digits number =
    if number == 0 then
        []

    else
        digits (number // 10) ++ [ remainderBy 10 number ]
----

And expose `digits` in the module definition.

[source,elm]
----
module RippleCarryAdder exposing
    ( digits
    .
    .
    )
----

****
NOTE: It’s not a good idea to expose private helper functions such as `digits`. We should only expose public functions that are meant to be used by other modules. The reason we’re exposing `digits` here is so that we can try it out in `+elm repl+`. We’ll cover private functions in detail in the <<easier-code-organization, Making Functions Private>> and <<fuzz-testing, Fuzz Testing>> sections later in this chapter.
****

The `digits` function takes a number and returns a list of digits.

[source,elm]
----
> digits 1100
[1,1,0,0]
----

When we set out to implement a 4-bit ripple-carry adder, we broke the problem at hand into smaller sub-problems, solved them individually and combined the results. The `digits` function follows a similar approach, but instead of using other functions to solve the sub-problems it solves them by itself. To understand how it does that, let’s break the problem of extracting digits from `1100` into multiple sub-problems.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/extract-digits-recursion.svg[]

We start with the number `1100` which is our original problem. We take the last digit from it and reduce the problem to `110`. We then take the last digit from `110` and further reduce the problem to `11`. We continue to do this until there are no digits left in which case we simply return an empty list. Then we combine the solution to each sub-problem one at a time moving from left to right.

==== Recursion

This process of solving a problem by first solving the smaller versions of the same problem is called _recursion_. The problem eventually gets reduced to something so small that we can just solve it directly. This is called a _base case_. In the example above, when there’s no digit left in the number we know that we’ve arrived at the base case. We then solve it by simply returning an empty list.

Like most programming languages, Elm supports recursion by allowing a function to apply itself as we have done in the definition of `digits`. When using recursion, we need to keep the following three things in mind.

*1. How do we reduce the problem?* If a problem can’t be reduced to smaller versions of itself then recursion probably isn’t the best tool to solve that problem. Therefore, we need to know how exactly are we going to reduce the problem. The `digits` function does this by dividing the `number` by `10`.

[source,elm]
----
digits (number // 10)
----

The `+//+` operator performs integer division, which truncates everything after the decimal point. We didn’t use recursion to build a 4-bit ripple-carry adder because we couldn’t reduce the problem into smaller versions of itself. Therefore, we had to assemble a bunch of other functions to solve the original problem instead of applying itself repeatedly.

*2. What is the base case?* A properly designed recursive function must simplify the problem with each invocation so that it will eventually reach the base case. Once the execution hits the base case, then it pops back out and starts gathering the results from each invocation. If we don’t provide a base case, a recursive function will create an infinite loop. Here’s the base case from the `digits` function:

[source,elm]
----
if number == 0 then
    []
----

After the third invocation of the `digits` function, the number `1100` gets reduced to `1`. When integer division is performed on that number by `10`, the `number` becomes `0`. At that point the condition for the base case is satisfied and an empty list is returned. If we didn’t have this condition, the `digits` function would run forever.

*3. How do we combine the result of each sub problem?* Once the base case is reached, we need to provide a mechanism for combining the result from each invocation. The `digits` function does this by using the `pass:[++]` operator.

[source,elm]
----
digits (number // 10) ++ [ remainderBy 10 number ]
----

To see how recursion works behind the scenes, let’s walk through each step in the `digits` function’s execution.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/digits-function-recursion-invocation.svg[]

Breaking down a recursive function’s invocations like this is fine when we are trying to understand how recursion works in the beginning, but once we have developed an intuition for recursion we should avoid thinking explicitly about the sequence of invocations. We should instead focus on the three things we discussed above.

Hopefully you now understand how recursion works. If not, don’t worry. It’s a tricky concept. You just need more practice writing recursive functions and reasoning through them. There are many resources out there for diving deeper into recursion. I recommend checking out https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursion[Khan Academy’s mini-course] that not only explains recursion in simple terms, but also provides exercises for you to practice.

==== Improving the digits Function’s Performance

In Elm, it’s more efficient from performance standpoint to build a list by adding an element to the front using the cons (`+::+`) operator than by appending values to the end using the `pass:[++]` operator. Let’s say we have a list like this: `+[ 2, 3, 4, 5 ]+`. And we want to add `1` to the front of that list.

[source,elm]
----
> 1 :: [ 2, 3, 4, 5 ]
[1,2,3,4,5]
----

The cons operator doesn’t traverse the entire list before adding the given number to the front. Whereas `pass:[++]` does. Therefore this code:

[source,elm]
----
> [ 2, 3, 4, 5 ] ++ [ 6 ]
[2,3,4,5,6]
----

Essentially turns into this behind the scenes:

[source,elm]
----
> 5 :: [ 6 ]
[5,6]

> 4 :: [ 5, 6 ]
[4,5,6]

> 3 :: [ 4, 5, 6 ]
[3,4,5,6]

> 2 :: [ 3, 4, 5, 6 ]
[2,3,4,5,6]
----

Earlier we used `pass:[++]` to append a single element to a list in the `digits` function like this:

[source,elm]
----
digits number =
    .
    .
    else
        digits (number // 10) ++ [ remainderBy 10 number ]
----

Now that we know the cons operator is more performant, let’s change the `digits` function to use that instead. Since the calculations being done here are so small, we won’t see much of a speed difference between the two operators. It’s when we are passing a very big number through `digits` that the speed differences really start to add up. Change the `digits` function in `RippleCarryAdder.elm` to use the cons operator like this:

[source,elm]
----
digits number =
    let
        getDigits n =
            if n == 0 then
                []

            else
                remainderBy 10 n :: getDigits (n // 10)
    in
    getDigits number
        |> List.reverse
----

With your new found understanding of recursion, you should be able to figure out how the new implementation above works. Modify the `extractDigits` function in `RippleCarryAdder.elm` to use the new `digits` function:

[source,elm]
----
extractDigits number =
    digits number
        |> Array.fromList
        |> arrayToRecord
----

The `extractDigits` function now looks much more succinct with the `digits` function. Here’s how it looked before:

[source,elm]
----
extractDigits number =
    String.fromInt number
        |> String.split ""
        |> List.map stringToInt
        |> Array.fromList
        |> arrayToRecord
----

===== Adding a Number with Leading Zeros

The new implementation of the `extractDigits` function still doesn’t solve the problem of adding a binary number with leading zeros, but it’s quite easy to pad zeros to the front of a list. Add the following function to the bottom of `RippleCarryAdder.elm`.

[source,elm]
----
padZeros total list =
    let
        numberOfZeros =
            total - List.length list
    in
    List.repeat numberOfZeros 0 ++ list
----

The `padZeros` function pads a list with zeros until it reaches a given length represented by the parameter named `total`. Let’s call `padZeros` from `extractDigits` in `RippleCarryAdder.elm`.

[source,elm]
----
extractDigits number =
    digits number
        |> padZeros 4
        |> Array.fromList
        |> arrayToRecord
----

Now when we add a binary number with leading zeros, we get a correct result.

[source,elm]
----
> rippleCarryAdder 1001 11 0
1100
----

As we found out earlier, we can’t actually type leading zeros in Elm, so assume the second argument `11` has two zeros before it like this: `0011`. In the next section, we will learn how to verify `rippleCarryAdder` behaves as expected using unit tests.


[[easy-to-test]]
=== 4.5 Easy to Test


In the <<pure-functions, Pure Functions>> section, we learned that it’s much easier to verify an Elm function’s correctness compared to functions written in a language that lacks purity. In this section, we will find out why that is the case. We will also write quite a few tests to make sure that our implementation of various functions in the <<function-composition, `RippleCarryAdder` module>> is correct. First, we need to learn how to write tests in Elm.

==== Setting Up Our Project for Tests

Before we can write tests in Elm, we need to first set some things up in our project using a tool called https://www.npmjs.com/package/elm-test[`+elm-test+`]. Let’s install it by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ npm install elm-test -g
----

In the <<installation, Installing Node.js>> section, we learned that one of the reasons we had to install Node.js was so that we could use NPM (**N**ode.js **P**ackage **M**anager) to install tools and packages needed for building front-end web applications. A good number of tools in the Elm ecosystem are also distributed as NPM packages. `+elm-test+` is one of them. It allows us to run Elm tests from the terminal or a http://www.martinfowler.com/articles/continuousIntegration.html[continuous integration server].

Now that `+elm-test+` has been installed, we can use it to set up our project for writing tests. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm-test init
----

You should see the following message.

[source,bash]
----
Here is my plan:

  Add:
    elm/random               1.0.0
    elm-explorations/test    1.2.2

Would you like me to update your elm.json accordingly? [Y/n]:
----

Answer `Y`. https://package.elm-lang.org/packages/elm-explorations/test/latest/[`+elm-exploration/test+`] is an Elm package for writing tests. It depends on another package called `+elm/random+`. That’s why we need both. Once the installation is complete, the `+test-dependencies+` section of our `elm.json` should be updated like this:

[source,json]
----
{
    .
    .
    "test-dependencies": {
        "direct": {
            "elm-explorations/test": "1.2.2"
        },
        "indirect": {
            "elm/random": "1.0.0"
        }
    }
}
----

****
NOTE: `+elm-exploration/test+` is different from the `+elm-test+` command-line tool. The former is an Elm package for writing tests whereas the latter is a NPM package for running those tests in the terminal.
****

It’s best practice to keep the dependencies for tests and application code separate. That’s why `elm.json` provides separate areas for those.

[source,json]
----
{
    "dependencies": {
        .
        .
    },
    "test-dependencies": {
        .
        .
    }
}
----

The `+elm-test init+` command also creates a new directory called `tests` inside `+beginning-elm+`. All it has right now is an example test file.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/create-tests-directory.png[]

[[exampleelm]]
===== Example.elm

We’ll be using the `Example.elm` file to understand how Elm tests work. Here is how it looks right now:

[source,elm]
----
module Example exposing (suite)

import Expect exposing (Expectation)
import Fuzz exposing (Fuzzer, int, list, string)
import Test exposing (..)


suite : Test
suite =
    todo "Implement our first test. See https://package.elm-lang.org/packages/elm-explorations/test/latest for how to do this!"
----

It imports three modules:

* *Expect* is for specifying how we expect our code to behave.
* *Fuzz* is for writing <<fuzz-testing, fuzz tests>>.
* *Test* is for creating and managing tests.

`Example.elm` also includes a placeholder for implementing our first test inside the value called `suite`. In programming terminology, _test suite_ is a collection of tests that verify a program’s behavior.

There is no special syntax for writing tests in Elm. The <<indentation, formatting rules>> that apply to normal functions and values we’ve seen so far also apply to tests.

****
NOTE: The code above shows that `suite` returns a value of type `Test`. Since we haven’t covered <<type-system, type system>> yet, we’ll continue to omit type annotations in this section as well to avoid any confusion.
****

==== Writing Our First Unit Test

Now that all the packages needed for writing and running tests are installed and imported, we’re ready to write our first test. Let’s replace the placeholder implementation inside `suite` in `Example.elm` with a real unit test.

[source,elm]
----
suite =
    test "two plus two equals four"
        (\_ -> Expect.equal 4 (2 + 2))
----

To execute this test all we have to do is run `+elm-test+` from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm-test
----

****
WARNING: If you get the “Invalid Package Dependencies” error, run `+elm install elm/json+` from the `+beginning-elm+` directory in terminal. Answer `Y` and then run `+elm-test+` again. https://discourse.elm-lang.org/t/elm-test-how-to-fix-package-dependency-errors/4054/4[This post] explains why that error may occur.
****

If you don’t run into any errors, you should see an output like this:

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/first-unit-test-run-output.png[]

Reproducing a Test Result::
  Notice the following instructions in the above output.
+
`+To reproduce these results, run: elm-test --fuzz 100 --seed <seed-value>+`
+
It is meant for a fuzz test. We’ll go over what this instruction means in the <<fuzz-testing, Fuzz Testing>> section later in this chapter.

Now let’s understand how the test we wrote earlier actually works. The following diagram explains the syntax for writing a unit test in Elm.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/elm-test-syntax.svg[]

The `test` function requires us to wrap our test in an <<string, anonymous function>>. That’s why we can’t just write it like this:

[source,elm]
----
test "two plus two equals four"
    (Expect.equal 4 (2 + 2))
----

This is due to how things are implemented internally in `+elm-test+`. To make things easier, `+elm-test+` wants to have control over when and how tests get executed. By putting a test inside a function we’re giving up that control because when we define a function, Elm doesn’t execute it immediately. It waits for some other code to apply it first.

In the <<function, Function>> section, we learned that every function in Elm, including anonymous functions, must receive at least one argument. So what argument does `+elm-test+` pass to the anonymous function we used earlier to wrap our test? To find out, let’s look at the `test` function’s type signature.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/test-function-type-signature.svg[]

As it turns out, the argument passed to our anonymous function is `+()+`.

===== Unit Type

Sine the argument given to the anonymous function never gets used inside the test, `+elm-test+` doesn’t even bother to pass an argument that can be used in a meaningful way. It just passes an empty value represented by `+()+`, which means an empty <<tuple, tuple>> in Elm. It’s also known as the _unit type_. It’s often used to represent an empty value. When we enter `+()+` in the repl, its type is also displayed as `+()+`.

[source,elm]
----
> ()
() : ()
----

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/empty-value-unit-type.svg[]

****
NOTE: We will cover types in detail in the <<type-system, Type System>> section, but for now think of it as something that represents a collection of values that have similar properties. For example, the type `Int` represents numbers with no fractional part: `+-1+`, `0`, `1`, `2`, etc. And the type `Bool` represents logical values `True` and `False`.
****

Elm uses the `+()+` symbol to represent both value and type. There can only ever be one value of the unit type: `+()+`. That’s because the number of elements in a tuple determines its type. For example, the following two tuples have completely different types even though they both contain the same type of values.

[source,elm]
----
> ( 1, 2 )
(1,2) : ( number, number1 )

> ( 1, 2, 3 )
(1,2,3) : ( number, number1, number2 )
----

For two tuples to be of the same type, they must contain the same number and type of values. In contrast, two <<list, lists>> containing the same type of values but different lengths have the exact same type.

[source,elm]
----
> [ 1, 2 ]
[1,2] : List number

> [ 1, 2, 3 ]
[1,2,3] : List number
----

[[-vs-_]]
===== `()` vs `_`

It’s common in Elm to use an underscore (`_`) when we want to ignore a parameter. Here’s a simple anonymous function that always returns `0`:

[source,elm]
----
> List.map (\_ -> 0) [ 1, 2, 3 ]
[0,0,0] : List number

> List.map (\_ -> 0) [ 'a', 'b', 'c' ]
[0,0,0] : List number
----

****
NOTE: If you don’t remember how the `List.map` function works, go ahead and refresh your memory by reviewing the <<list, Mapping a List>> section.
****

The `+(\_ -> 0)+` anonymous function doesn’t use its parameter to compute a return value. So instead of giving a name to the parameter, it just uses `_`.

On the surface, `_` and `+()+` seem to be used for the same purpose: ignoring a parameter. But if we look deeper, there’s a subtle difference. Although `+(\_ -> 0)+` ignores its parameter, it allows us to pass any type of value to it. In the example above, we first gave it numbers and then characters. Will it still allow us to pass any type of value if we switched to `+()+` from `_`? Let’s find out.

[source,elm]
----
> List.map (\() -> 0) [ 1, 2, 3 ]

---------------- TYPE MISMATCH ----------------
The 2nd argument to `map` is not what I expect:

4|   List.map (\() -> 0) [ 1, 2, 3 ]
                         ^^^^^^^^^^^
This argument is a list of type:

    List number

But `map` needs the 2nd argument to be:

    List ()
----

No it doesn’t. `+(\() -> 0)+` only accepts a value of type `+()+`, nothing else.

[source,elm]
----
> List.map (\() -> 0) [ (), (), () ]
[0,0,0] : List number
----

`_` means _any value_, whereas `+()+` means _only unit type value_. By replacing `_` with `+()+`, we severely limited our input options. If you just want to ignore a parameter without limiting the types of input values that can be passed to your function, then use `_`. On the other hand, if no meaningful argument will ever get passed to your function, then use `+()+`. Why then are we using `_` instead of `+()+` in our test?

[source,elm]
----
test "two plus two equals four"
    (\_ -> Expect.equal 4 (2 + 2))
----

That’s because we know `+elm-test+` only ever passes the unit type to our anonymous function. Therefore, whether we use `+()+` or `_` doesn’t really make any difference and since `_` is easier to type we went with that.

==== Failed Test

Let’s see how the output looks when our test fails. Change the expected value from `4` to `3` in `Example.elm`.

[source,elm]
----
suite =
    test "two plus two equals four"
        (\_ -> Expect.equal 3 (2 + 2))
----

Run `+elm-test+` from the `+beginning-elm+` directory in terminal and you should see the following output.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/first-failed-test.svg[]

The output shows the actual value _before_ the expected value, but in our test the actual value is placed _after_ the expected value. Can we rewrite our test so that it closely resembles the output? Yes we can. Update the test in `Example.elm` like this:

[source,elm]
----
suite =
    test "two plus two equals four"
        (\_ -> (2 + 2) |> Expect.equal 3)
----

The `+|>+` operator passes the result from the expression on the left as the last argument to the function on the right. If you are fuzzy on how `+|>+` works, go back and review the <<function, Forward Function Application>> section from chapter 3. Now the output closely resembles our test.

[source,elm]
----
(2 + 2) |> Expect.equal 3  -- Our test
----

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/expect-equal-pipe-operator.svg[]

Because of this resemblance, it’s easier to notice that our expected result is incorrect. When we wrote our test like this:

[source,elm]
----
Expect.equal 3 (2 + 2)
----

The test code wasn’t in the same order as the output, so it was harder to visually compare them and locate the offending code. Change the expected value back to `4` to pass the test. `+|>+` improves the readability even more in a complex test. Here’s an example:

[source,elm]
----
guardianNames =
    test "only 2 guardians have names with less than 6 characters"
        (\_ ->
            let
                guardians =
                    [ "Star-lord", "Groot", "Gamora", "Drax", "Rocket" ]
            in
            guardians
                |> List.map String.length
                |> List.filter (\x -> x < 6)
                |> List.length
                |> Expect.equal 2
        )
----

Add that test to the bottom of `Example.elm` and also expose it in the module declaration.

[source,elm]
----
module Example exposing (guardianNames, suite)
----

Run `+elm-test+` from the `+beginning-elm+` directory in terminal and you should see two passing tests. The anonymous function given to the `test` function as an argument is like any other function, except it doesn’t have a name. We can use anything inside it that’s allowed in a normal function including a `let` expression.

The test inside `guardianNames` verifies that there are only two guardians whose names have less than six characters in them. We applied three different transformations to the original list to get to the final number. As you can see, the `+|>+` operator significantly improved the readability of our test. When a test contains a complex computation like this, the anonymous function tends to take the following shape:

[source,elm]
----
\_ ->
    someComputation
        |> producing
        |> actualValue
        |> Expect.equal expectedValue
----

If we didn’t use `+|>+`, our test would be very hard to read. Here is the same test without `+|>+`:

[source,elm]
----
Expect.equal 2
    (List.length (List.filter (\x -> x < 6) (List.map String.length guardians)))
----

Not only those parentheses get in the way, but the function logic also starts on the far right whereas English reads from left to right. Hence, reading that test feels a bit unnatural.

===== Maintaining a Suite of Well Written Tests

When a test fails, it could mean two things: either we made a mistake writing the test or the logic inside the code under test is incorrect. If the logic is incorrect, we obviously have to fix it. If the test itself is incorrect, we should either fix or remove it. In our first test, the expression `+2 + 2+` will never produce `3`. Therefore, the test is incorrect.

A suite of well written tests play a critical role in refactoring the existing code. It gives us the confidence to rearrange our code so that we can make it easier to read and maintain. If we make a mistake, a test will catch it. For that reason, it’s important to keep our test suite clean by removing any incorrectly written failing tests.

Refactoring::
  _“Refactoring is the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves the internal structure.” - https://www.amazon.com/gp/product/0134757599/[Martin Fowler]_

[[improving-our-tests-with-]]
==== Improving Our Tests with `<|`

`|>` made our tests quite readable. We can make them even better by replacing the parentheses around anonymous functions with `+<|+`. Update the tests in `Example.elm` as shown below.

[source,elm]
----
suite =
    test "two plus two equals four" <|
        \_ -> (2 + 2) |> Expect.equal 4


guardianNames =
    test "only 2 guardians have names with less than 6 characters" <|
        \_ ->
            let
                guardians =
                    [ "Star-lord", "Groot", "Gamora", "Drax", "Rocket" ]
            in
            guardians
                |> List.map String.length
                |> List.filter (\x -> x < 6)
                |> List.length
                |> Expect.equal 2
----

`+<|+` is quite useful for avoiding parentheses. Here is another example from the <<function, Backward Function Application>> section.

[source,elm]
----
main =
    Html.text (toString (add 5 (multiply 10 (divide 30 10))))
----

We can replace those pesky parentheses with `+<|+` like this:

[source,elm]
----
main =
    Html.text <| toString <| add 5 <| multiply 10 <| divide 30 10
----

Ah, much better!

==== Grouping Similar Tests with `describe`

Let’s rename `suite` to `additionTests` and add one more test to it in `Example.elm`.

[source,elm]
----
additionTests =
    describe "Addition"
        [ test "two plus two equals four" <|
            \_ -> (2 + 2) |> Expect.equal 4
        , test "three plus four equals seven" <|
            \_ -> (3 + 4) |> Expect.equal 7
        ]
----

Don’t forget to replace `suite` with `additionaTests` in the module declaration.

[source,elm]
----
module Example exposing (additionTests, guardianNames)
----

Run `+elm-test+` from the `+beginning-elm+` directory in terminal and you should see three passing tests. The `describe` function is used to group related tests. Notice that we didn’t use `+<|+` on the line that contains `describe`. That’s because `describe` doesn’t need to wrap its second argument (a list of tests) in parentheses.

==== More Expectations

The `Expect` module also provides functions for expressing expectations other than equality. Let’s find out what they are. Add the following tests to the bottom of `Example.elm`.

[source,elm]
----
comparisonTests =
    describe "Comparison"
        [ test "2 is not equal to 3" <|
            \_ -> 2 |> Expect.notEqual 3
        , test "4 is less than 5" <|
            \_ -> 4 |> Expect.lessThan 5
        , test "6 is less than or equal to 7" <|
            \_ -> 6 |> Expect.atMost 7
        , test "9 is greater than 8" <|
            \_ -> 9 |> Expect.greaterThan 8
        , test "11 is greater than or equal to 10" <|
            \_ -> 11 |> Expect.atLeast 10
        , test "a list with zero elements is empty" <|
            \_ ->
                List.isEmpty []
                    |> Expect.true "expected the list to be empty"
        , test "a list with some elements is not empty" <|
            \_ ->
                List.isEmpty [ "Jyn", "Cassian", "K-2SO" ]
                    |> Expect.false "expected the list not to be empty"
        ]
----

And expose `comparisonTests` in the module definition.

[source,elm]
----
module Example exposing (additionTests, guardianNames, comparisonTests)
----

Now run `+elm-test+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed. The tests above are self-explanatory except the last two. `Expect.true` and `Expect.false` require us to pass a string as the first argument. When a test fails, that string is used to explain why the test failed. Make the test that uses `Expect.true` fail by passing a non-empty list like this:

[source,elm]
----
comparisonTests =
    describe "Comparison"
        .
        .
        , test "a list with zero elements is empty" <|
            \_ ->
                List.isEmpty [ "The Ancient One" ]
                    |> Expect.true "expected the list to be empty"
        .
        .
----

Run `+elm-test+` once again and you should see the string we gave to `Expect.true` being used as an explanation for why the test failed.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/expect-true-test-failed.png[]

Remove `+"The Ancient One"+` from the list in above test so that it passes again. The `Expect` module provides even more ways to express expectations. You can learn all about them https://package.elm-lang.org/packages/elm-explorations/test/latest/Expect[here].

Now that we’re familiar with how to write tests in Elm, let’s turn our attention to testing various functions in the `RippleCarryAdder.elm` file we created earlier in the <<function-composition, Solving Complex Problems with Simple Functions>> section.

==== Testing the `inverter` Function

Let’s start with the `inverter` function which is the easiest one to test. To refresh your memory, here’s how the function looks:

[source,elm]
----
inverter a =
    case a of
        0 ->
            1

        1 ->
            0

        _ ->
            -1
----

Create a new file called `RippleCarryAdderTests.elm` in the `+beginning-elm/tests+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/create-ripple-carry-adder-tests-file.png[]

[source,elm]
----
module RippleCarryAdderTests exposing (inverterTests)

import Expect exposing (Expectation)
import Fuzz exposing (..)
import RippleCarryAdder exposing (..)
import Test exposing (..)


inverterTests =
    describe "Inverter"
        [ test "output is 0 when the input is 1" <|
            \_ ->
                inverter 0
                    |> Expect.equal 1
        , test "output is 1 when the input is 0" <|
            \_ ->
                inverter 1
                    |> Expect.equal 0
        ]
----

Each test case in `inverterTests` represents a row from an inverter’s truth table we saw in the <<function-composition, Inverter>> section.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/inverter-truth-table.svg[]

Run the following command from the `+beginning-elm+` directory in terminal to execute the tests inside `inverterTests`.

[source,bash]
----
$ elm-test tests/RippleCarryAdderTests.elm
----

`+elm-test+` allows us to run tests from a specific file. All we have to do is give it a filename. When we run `+elm-test+` without any arguments, it goes through all `+.elm+` files in the `+beginning-elm/tests+` directory and runs every test in them. For the remainder of this section, we’ll focus on testing the `RippleCarryAdder` module, so we’ll be running the tests in `RippleCarryAdderTests.elm` only.

==== Testing the `andGate` Function

Testing the `andGate` function is very similar to testing `inverter`. We just need to account for all four possible outcomes. Here’s how the `andGate` function looks:

[source,elm]
----
andGate a b =
    Bitwise.and a b
----

Add the following tests to the bottom of `RippleCarryAdderTests.elm`.

[source,elm]
----
andGateTests =
    describe "AND gate"
        [ test "output is 0 when both inputs are 0" <|
            \_ ->
                andGate 0 0
                    |> Expect.equal 0
        , test "output is 0 when the first input is 0" <|
            \_ ->
                andGate 0 1
                    |> Expect.equal 0
        , test "output is 0 when the second input is 0" <|
            \_ ->
                andGate 1 0
                    |> Expect.equal 0
        , test "output is 1 when both inputs are 1" <|
            \_ ->
                andGate 1 1
                    |> Expect.equal 1
        ]
----

And expose `andGateTests` in the module definition.

[source,elm]
----
module RippleCarryAdderTests exposing (andGateTests, inverterTests)
----

Like `inverterTests`, each test in `andGateTests` represents a row from an AND gate’s truth table.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/and-gate-truth-table.svg[]

Run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal to execute the tests inside `andGateTests`.

[[exercise-451]]
==== Exercise 4.5.1

Using `andGateTests` as a reference, write tests for the `orGate` function whose definition looks like this:

[source,elm]
----
orGate a b =
    Bitwise.or a b
----

Here’s the truth table for an OR gate:

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/or-gate-truth-table.svg[]

After you’ve written the tests, don’t forget to run them to make sure they all pass.

==== Testing the `halfAdder` Function

A half adder is slightly more complex because it produces two outputs: sum and carry-out.

[source,elm]
----
halfAdder a b =
    let
        d =
            orGate a b

        e =
            andGate a b
                |> inverter

        sumDigit =
            andGate d e

        carryOut =
            andGate a b
    in
        { carry = carryOut
        , sum = sumDigit
        }
----

Even though it produces multiple outputs, the tests for the `halfAdder` function look very similar to the `andGate` tests. Add the following tests to the bottom of `RippleCarryAdderTests.elm`.

[source,elm]
----
halfAdderTests =
    describe "Half adder"
        [ test "sum and carry-out are 0 when both inputs are 0" <|
            \_ ->
                halfAdder 0 0
                    |> Expect.equal { carry = 0, sum = 0 }
        , test "sum is 1 and carry-out is 0 when the 1st input is 0 and the 2nd input is 1" <|
            \_ ->
                halfAdder 0 1
                    |> Expect.equal { carry = 0, sum = 1 }
        , test "sum is 1 and carry-out is 0 when the 1st input is 1 and the 2nd input is 0" <|
            \_ ->
                halfAdder 1 0
                    |> Expect.equal { carry = 0, sum = 1 }
        , test "sum is 0 and carry-out is 1 when both inputs are 1" <|
            \_ ->
                halfAdder 1 1
                    |> Expect.equal { carry = 1, sum = 0 }
        ]
----

And expose `halfAdderTests` in the module definition.

[source,elm]
----
module RippleCarryAdderTests exposing
    ( andGateTests
    , halfAdderTests
    , inverterTests
    , orGateTests
    )
----

Each test case in `halfAdderTests` represents a row from the half adder’s truth table.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/half-adder-truth-table.svg[]

Run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal to execute the tests inside `halfAdderTests`.

==== Testing the `fullAdder` Function

Here’s how the `fullAdder` function looks:

[source,elm]
----
fullAdder a b carryIn =
    let
        firstResult =
            halfAdder b carryIn

        secondResult =
            halfAdder a firstResult.sum

        finalCarry =
            orGate firstResult.carry secondResult.carry
    in
        { carry = finalCarry
        , sum = secondResult.sum
        }
----

It takes one more input (`carryIn`) compared to the `halfAdder` function. Therefore, we have to account for all eight combinations of inputs as shown in the truth table below.

image:https://elmprogramming.com/images/chapter-4/4.4-function-composition/full-adder-truth-table.svg[]

Add the following tests to the bottom of `RippleCarryAdderTests.elm`.

[source,elm]
----
fullAdderTests =
    describe "Full adder"
        [ test "sum and carry-out are 0 when both inputs and carry-in are 0" <|
            \_ ->
                fullAdder 0 0 0
                    |> Expect.equal { carry = 0, sum = 0 }
        , test "sum is 1 and carry-out is 0 when both inputs are 0, but carry-in is 1" <|
            \_ ->
                fullAdder 0 0 1
                    |> Expect.equal { carry = 0, sum = 1 }
        , test "sum is 1 and carry-out is 0 when the 1st input is 0, the 2nd input is 1, and carry-in is 0" <|
            \_ ->
                fullAdder 0 1 0
                    |> Expect.equal { carry = 0, sum = 1 }
        , test "sum is 0 and carry-out is 1 when the 1st input is 0, the 2nd input is 1, and the carry-in is 1" <|
            \_ ->
                fullAdder 0 1 1
                    |> Expect.equal { carry = 1, sum = 0 }
        , test "sum is 1 and carry-out is 0 when the 1st input is 1, the 2nd input is 0, and the carry-in is 0" <|
            \_ ->
                fullAdder 1 0 0
                    |> Expect.equal { carry = 0, sum = 1 }
        , test "sum is 0 and carry-out is 1 when the 1st input is 1, the 2nd input is 0, and the carry-in is 1" <|
            \_ ->
                fullAdder 1 0 1
                    |> Expect.equal { carry = 1, sum = 0 }
        , test "sum is 0 and carry-out is 1 when the 1st input is 1, the 2nd input is 1, and the carry-in is 0" <|
            \_ ->
                fullAdder 1 1 0
                    |> Expect.equal { carry = 1, sum = 0 }
        , test "sum is 1 and carry-out is 1 when the 1st input is 1, the 2nd input is 1, and the carry-in is 1" <|
            \_ ->
                fullAdder 1 1 1
                    |> Expect.equal { carry = 1, sum = 1 }
        ]
----

And expose `fullAdderTests` in the module definition.

[source,elm]
----
module RippleCarryAdderTests exposing
    ( andGateTests
    , fullAdderTests
    .
    .
----

Like all other tests we’ve written so far, the tests inside `fullAdderTests` represent rows from the full adder’s truth table. Run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal to execute the tests inside `fullAdderTests`.

The test descriptions in `fullAdderTests` are too long. It makes reading the tests difficult. We can improve the readability by grouping similar tests inside a `describe` block. Rewrite `fullAdderTests` as shown below.

[source,elm]
----
fullAdderTests =
    describe "Full adder"
        [ describe "when both inputs are 0"
            [ test "and carry-in is 0 too, then both sum and carry-out are 0" <|
                \_ ->
                    fullAdder 0 0 0
                        |> Expect.equal { carry = 0, sum = 0 }
            , test "but carry-in is 1, then sum is 1 and carry-out is 0" <|
                \_ ->
                    fullAdder 0 0 1
                        |> Expect.equal { carry = 0, sum = 1 }
            ]
        , describe "when the 1st input is 0, and the 2nd input is 1"
            [ test "and carry-in is 0, then sum is 1 and carry-out is 0" <|
                \_ ->
                    fullAdder 0 1 0
                        |> Expect.equal { carry = 0, sum = 1 }
            , test "and carry-in is 1, then sum is 0 and carry-out is 1" <|
                \_ ->
                    fullAdder 0 1 1
                        |> Expect.equal { carry = 1, sum = 0 }
            ]
        , describe "when the 1st input is 1, and the 2nd input is 0"
            [ test "and carry-in is 0, then sum is 1 and carry-out is 0" <|
                \_ ->
                    fullAdder 1 0 0
                        |> Expect.equal { carry = 0, sum = 1 }
            , test "and carry-in is 1, then sum is 0 and carry-out is 1" <|
                \_ ->
                    fullAdder 1 0 1
                        |> Expect.equal { carry = 1, sum = 0 }
            ]
        , describe "when the 1st input is 1, and the 2nd input is 1"
            [ test "and carry-in is 0, then sum is 0 and carry-out is 1" <|
                \_ ->
                    fullAdder 1 1 0
                        |> Expect.equal { carry = 1, sum = 0 }
            , test "and carry-in is 1, then sum is 1 and carry-out is 1" <|
                \_ ->
                    fullAdder 1 1 1
                        |> Expect.equal { carry = 1, sum = 1 }
            ]
        ]
----

They are much easier to read now. It’s recommended that you group similar tests inside a `describe` block whenever you can. We should always look for ways to improve the readability of our tests. In addition to verifying the behavior of our code, tests also act as a documentation describing how that code should behave. Therefore, improving the readability of our tests is just as important as improving the readability of our code.

We can nest as many `describe` blocks as we want. Here’s `fullAdderTests` rewritten again with multiple `describe` blocks:

[source,elm]
----
fullAdderTests =
    describe "Full adder"
        [ describe "when both inputs are 0"
            [ describe "and carry-in is 0"
                [ test "both sum and carry-out are 0" <|
                    \_ ->
                        fullAdder 0 0 0
                            |> Expect.equal { carry = 0, sum = 0 }
                ]
            , describe "but carry-out is 1"
                [ test "sum is 1 and carry-out is 0" <|
                    \_ ->
                        fullAdder 0 0 1
                            |> Expect.equal { carry = 0, sum = 1 }
                ]
            ]
        , describe "when the 1st input is 0"
            [ describe "and the 2nd input is 1"
                [ describe "and carry-in is 0"
                    [ test "sum is 1 and carry-out is 0" <|
                        \_ ->
                            fullAdder 0 1 0
                                |> Expect.equal { carry = 0, sum = 1 }
                    ]
                , describe "and carry-in is 1"
                    [ test "sum is 0 and carry-out is 1" <|
                        \_ ->
                            fullAdder 0 1 1
                                |> Expect.equal { carry = 1, sum = 0 }
                    ]
                ]
            ]
        , describe "when the 1st input is 1"
            [ describe "and the 2nd input is 0"
                [ describe "and carry-in is 0"
                    [ test "sum is 1 and carry-out is 0" <|
                        \_ ->
                            fullAdder 1 0 0
                                |> Expect.equal { carry = 0, sum = 1 }
                    ]
                , describe "and carry-in is 1"
                    [ test "sum is 0 and carry-out is 1" <|
                        \_ ->
                            fullAdder 1 0 1
                                |> Expect.equal { carry = 1, sum = 0 }
                    ]
                ]
            ]
        , describe "when the 1st input is 1"
            [ describe "and the 2nd input is 1"
                [ describe "and carry-in is 0"
                    [ test "sum is 0 and carry-out is 1" <|
                        \_ ->
                            fullAdder 1 1 0
                                |> Expect.equal { carry = 1, sum = 0 }
                    ]
                , describe "and carry-in is 1"
                    [ test "sum is 1 and carry-out is 1" <|
                        \_ ->
                            fullAdder 1 1 1
                                |> Expect.equal { carry = 1, sum = 1 }
                    ]
                ]
            ]
        ]
----

If you run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal, you’ll see the following error.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/duplicate-test-name-error.png[]

`+elm-test+` forces us to provide a unique description for each test that are on the same level. This applies to `describe` as well. This rule is actually good for detecting misplaced tests. The test cases inside the last `+describe "when the 1st input is 1"+` block should really be moved to the one above it. Let’s do that.

[source,elm]
----
fullAdderTests =
    describe "Full adder"
        [ describe "when both inputs are 0"
            [ describe "and carry-in is 0"
                [ test "both sum and carry-out are 0" <|
                    \_ ->
                        fullAdder 0 0 0
                            |> Expect.equal { carry = 0, sum = 0 }
                ]
            , describe "but carry-out is 1"
                [ test "sum is 1 and carry-out is 0" <|
                    \_ ->
                        fullAdder 0 0 1
                            |> Expect.equal { carry = 0, sum = 1 }
                ]
            ]
        , describe "when the 1st input is 0"
            [ describe "and the 2nd input is 1"
                [ describe "and carry-in is 0"
                    [ test "sum is 1 and carry-out is 0" <|
                        \_ ->
                            fullAdder 0 1 0
                                |> Expect.equal { carry = 0, sum = 1 }
                    ]
                , describe "and carry-in is 1"
                    [ test "sum is 0 and carry-out is 1" <|
                        \_ ->
                            fullAdder 0 1 1
                                |> Expect.equal { carry = 1, sum = 0 }
                    ]
                ]
            ]
        , describe "when the 1st input is 1"
            [ describe "and the 2nd input is 0"
                [ describe "and carry-in is 0"
                    [ test "sum is 1 and carry-out is 0" <|
                        \_ ->
                            fullAdder 1 0 0
                                |> Expect.equal { carry = 0, sum = 1 }
                    ]
                , describe "and carry-in is 1"
                    [ test "sum is 0 and carry-out is 1" <|
                        \_ ->
                            fullAdder 1 0 1
                                |> Expect.equal { carry = 1, sum = 0 }
                    ]
                ]
            , describe "and the 2nd input is 1"
                [ describe "and carry-in is 0"
                    [ test "sum is 0 and carry-out is 1" <|
                        \_ ->
                            fullAdder 1 1 0
                                |> Expect.equal { carry = 1, sum = 0 }
                    ]
                , describe "and carry-in is 1"
                    [ test "sum is 1 and carry-out is 1" <|
                        \_ ->
                            fullAdder 1 1 1
                                |> Expect.equal { carry = 1, sum = 1 }
                    ]
                ]
            ]
        ]
----

Now if you run `+elm-test tests/RippleCarryAdderTests.elm+` once again, you should see that all tests have passed.

We shouldn’t go overboard with nesting `describe` blocks, though. Writing deeply-nested `describe` blocks could get tedious. That said, nesting does make the output read a little bit better when a test fails. If you try to make a test fail in the example above that has fewer `describe` blocks, the output will look like this:

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/nested-describe-test-failed.png[]

Compare that to the output below that shows a failing test from the example that has deeply-nested `describe` blocks.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/deeply-nested-describe-test-failed.png[]

There are no set guidelines in Elm for how deep the nesting should go, so use whatever level of nesting you find most readable.

[[exercise-452]]
==== Exercise 4.5.2

See if you can improve the readability of tests in <<easy-to-test, `halfAdderTests`>> by adding more `describe` blocks.

==== Testing the `rippleCarryAdder` Function

A 4-bit ripple carry adder has nine inputs and five outputs as shown in the truth table below.

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/ripple-carry-adder-truth-table.svg[]

That means there are `512` (`+2 ^ 9+`) different permutations of inputs we can test for. That’s a lot of tests, so the question becomes: Do we have to write tests to account for each member in the input set of a function? The answer depends on how much confidence do we have in our function. If we know what our function does is quite straightforward then we might not need as much testing, but if it’s fairly complex with many edge cases then we might need to write more tests to cover those edge cases. In any case, it’s rare to have a function that warrants 100% test coverage.

****
*Quote:* _“I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence.” - http://stackoverflow.com/a/153565[Kent Beck]_
****

One good thing about testing in Elm is that we can combine different types of tests to achieve the right level of confidence in our code. So far we’ve only written unit tests. Elm also offers another type of testing called _fuzz testing_. It’s a form of testing where the same test is run over and over with randomly generated inputs. In contrast, a unit test runs the code under test only once with a single input scenario, and then verifies that the output is correct.

The `rippleCarryAdder` function is a good candidate for fuzz testing, but we’ll have to wait until the <<fuzz-testing, Fuzz Testing>> section to find out how to write those tests. For now, let’s write a few unit tests which will supplement the fuzz tests we will write later. Add the following tests to the bottom of `RippleCarryAdderTests.elm`.

[source,elm]
----
rippleCarryAdderTests =
    describe "4-bit ripple carry adder"
        [ describe "given two binary numbers and a carry-in digit"
            [ test "returns the sum of those numbers and a carry-out digit" <|
                \_ ->
                    rippleCarryAdder 1001 1101 1
                        |> Expect.equal 10111
            ]
        , describe "when the 1st input is 1111, and the 2nd input is 1111"
            [ test "and carry-in is 0, the output is 11110" <|
                \_ ->
                    rippleCarryAdder 1111 1111 0
                        |> Expect.equal 11110
            , test "and carry-in is 1, the output is 11111" <|
                \_ ->
                    rippleCarryAdder 1111 1111 1
                        |> Expect.equal 11111
            ]
        , describe "when the 1st input is 0000, and the 2nd input is 0000"
            [ test "and carry-in is 0, the output is 0000" <|
                \_ ->
                    rippleCarryAdder 0 0 0
                        |> Expect.equal 0
            , test "and carry-in is 1, the output is 0001" <|
                \_ ->
                    rippleCarryAdder 0 0 1
                        |> Expect.equal 1
            ]
        ]
----

And expose `rippleCarryAdderTests` in the module definition.

[source,elm]
----
module RippleCarryAdderTests exposing
    .
    .
    , orGateTests
    , rippleCarryAdderTests
    )
----

Now run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal to execute the tests inside `rippleCarryAdderTests`.

We wrote one test to communicate what the function actually does, and two more to test boundary cases. Unit tests are generally useful for testing a specific scenario that either represents an edge case or an input boundary. The first test verifies that the `rippleCarryAdder` function generates an expected output when we add two binary numbers chosen by us at random. The last four tests verify that a correct output is generated when we add inputs with all `1`s and `0`s.

In the last two tests, we had to use single digits to represent the binary numbers with leading zeros because `+elm-format+` gets rid of zeros in the front when a file is saved. The tests still work because `rippleCarryAdder` pads zeros in the front if the input number doesn’t have four digits in it.

==== Summary

Throughout this section we saw many examples that proved our claim that writing tests for pure functions is quite straightforward. All we have to do is properly identify values from the input set, feed those values into the function repeatedly, and verify that the result belongs to the output set. We don’t need to worry about checking whether the function modified its state or caused any other side effects.


[[type-system]]
=== 4.6 Type System


Back in the <<immutability, Immutability>> section, we wrote a function in JavaScript that doubled the highest scores from regular season games in NBA history.

[source,javascript]
----
var scoreMultiplier = 2;
var highestScores = [316, 320, 312, 370, 337, 318, 314];

function doubleScores(scores) {
    var newScores = [];

    for (var i = 0; i < scores.length; i++) {
        newScores[i] = scores[i] * scoreMultiplier;
    }

    return newScores;
}
----

When we gave it a list of numbers as an input, it produced an expected output.

[source,javascript]
----
> highestScores
[316, 320, 312, 370, 337, 318, 314]

> doubleScores(highestScores)
[632, 640, 624, 740, 674, 636, 628]
----

What happens when we give it an input of a different type — one that’s not a list of numbers?

[source,javascript]
----
> var string = "highestScores"

> doubleScores(string)
[NaN, NaN, NaN, NaN, NaN, NaN]
----

[source,javascript]
----
> var undefinedValue = undefined

> doubleScores(undefinedValue)

Uncaught TypeError: Cannot read property 'length' of undefined
    at doubleScores (experiment.js:7)
    at <anonymous>:1:1
----

[source,javascript]
----
> var object = { "key" : "value" }

> doubleScores(object)
[]
----

It accepts the input no matter what its type is and gives us an unexpected output. When the input is a string, it generates an array of `NaN` (not-a-number). JavaScript doesn’t have a data type called `List`. It only has an array, which is like an Elm list and Elm array combined.

When the input is an undefined value, the `doubleScores` function throws an error. Finally, when the input is an object, it returns an empty list. An object in JavaScript is similar to a <<record, record>> in Elm. It’s a collection of key value pairs.

We want our functions to be reliable. We want them to reject inputs that don’t belong to their input sets. Can we put up some guardrails around our functions so that they can reject invalid inputs? Let’s find out. Modify the `doubleScores` function in `experiment.js` located in the `+beginning-elm+` directory like this:

[source,javascript]
----
function doubleScores(scores) {

    // Reject non-list type inputs
    if (Array.isArray(scores) === false) {
        throw new Error("Input must be of type array");
    }

    var newScores = [];

    for (var i = 0; i < scores.length; i++) {
        newScores[i] = scores[i] * scoreMultiplier;
    }

    return newScores;
}
----

We added an `if` condition at the very beginning to verify that the input is in fact an array. If it’s not, we throw an error. Now let’s see how the `doubleScores` function reacts when we pass invalid inputs to it. From the `+beginning-elm+` directory, open `index.html` in a browser and then open the browser console. Enter the code after the `+>+` prompt into the console to see the results.

[source]
----
> var string = "highestScores"

> doubleScores(string)

Uncaught Error: Input must be of type array
    at doubleScores (experiment.js:8)
    at <anonymous>:1:1
----

[source]
----
> var undefinedValue = undefined

> doubleScores(undefinedValue)

Uncaught Error: Input must be of type array
    at doubleScores (experiment.js:8)
    at <anonymous>:1:1
----

[source]
----
> var object = { "key" : "value" }

> doubleScores(object)

Uncaught Error: Input must be of type array
    at doubleScores (experiment.js:8)
    at <anonymous>:1:1
----

It consistently rejects the inputs and gives us a predictable error. This is much better than allowing any input and producing unpredictable output. Next, let’s find out what happens if we pass an array of values that are not numbers.

[source,javascript]
----
> var undefinedArray = [undefined]

> doubleScores(undefinedArray)
[NaN]

> var stringArray = ["highestScores"]

> doubleScores(stringArray)
[NaN]

> var object = { "key" : "value" }

> doubleScores([object])
[NaN]
----

The `doubleScores` function allows arrays with non-number values, which is also problematic. Can we put up some more guardrails so that this can also be prevented? Sure. Modify the `doubleScores` function in `experiment.js` like this:

[source,javascript]
----
function doubleScores(scores) {

    // Reject non-list type inputs
    if (Array.isArray(scores) === false) {
        throw new Error("Input must be of type array");
    }

    var newScores = [];

    for (var i = 0; i < scores.length; i++) {

        // Reject arrays that contain values that are not numbers
        if (typeof scores[i] !== "number") {
            throw new Error("Input array must contain numbers only");
        }
        else {
            newScores[i] = scores[i] * scoreMultiplier;
        }
    }

    return newScores;
}
----

We added another `if` condition inside the `for` loop to verify that each element in the array is of type number. Now let’s find out how the `doubleScores` function reacts when we give it an array with non-number values. Reload `index.html` in the browser so our changes to `experiment.js` take effect.

[source,javascript]
----
> var undefinedArray = [undefined]

> doubleScores(undefinedArray)

Uncaught Error: Input array must contain numbers only
    at doubleScores (experiment.js:17)
    at <anonymous>:1:1
----

[source,javascript]
----
> var stringArray = ["highestScores"]

> doubleScores(stringArray)

Uncaught Error: Input array must contain numbers only
    at doubleScores (experiment.js:17)
    at <anonymous>:1:1
----

[source,javascript]
----
> var object = { "key" : "value" }

> doubleScores([object])

Uncaught Error: Input array must contain numbers only
    at doubleScores (experiment.js:17)
    at <anonymous>:1:1
----

Once again, it consistently rejects arrays that contain non-number values and gives us a predictable error. Although the `doubleScores` function is more reliable now than before, we not only had to identify scenarios when it would allow bad inputs, but also take actions to mitigate those scenarios. This can get exhausting when our code base contains hundreds of functions like `doubleScores`.

Next, we’ll find out how the `doubleScores` function in Elm reacts when we give it inputs with invalid types. You should already have the following code in `Playground.elm` located in the `+beginning-elm/src+` directory.

[source,elm]
----
scoreMultiplier =
    2


highestScores =
    [ 316, 320, 312, 370, 337, 318, 314 ]


doubleScores scores =
    List.map (\x -> x * scoreMultiplier) scores
----

Let’s start with a string. Fire up an `+elm repl+` session from the `+beginning-elm+` directory in terminal and enter the following code.

[source,elm]
----
> import Playground exposing (..)

> doubleScores "highestScores"

--------------------- TYPE MISMATCH --------------------
The 1st argument to `doubleScores` is not what I expect:

5|   doubleScores "highestScores"
                  ^^^^^^^^^^^^^^^
This argument is a string of type:

    String

But `doubleScores` needs the 1st argument to be:

    List number
----

****
NOTE: The `doubleScores` function is defined in the `Playground` module. Therefore, we need to import the module before we can use the function in `+elm repl+`.
****

It tells us that it’s expecting the argument to be a list. What if we give it a list of non-number values?

[source,elm]
----
> doubleScores [ "highestScores" ]

--------------------- TYPE MISMATCH --------------------
The 1st argument to `doubleScores` is not what I expect:

5|   doubleScores [ "highestScores" ]
                  ^^^^^^^^^^^^^^^^^^^
This argument is a list of type:

    List String

But `doubleScores` needs the 1st argument to be:

    List number
----

It’ll keep rejecting until we give it a list of numbers.

[source,elm]
----
> doubleScores [ 316, 320, 312, 370, 337, 318, 314 ]
[632,640,624,740,674,636,628]
----

We didn’t have to put up any guardrails around `doubleScores` for it to reject inputs with invalid types. That’s because Elm comes with a powerful type system that automatically throws an error when an input doesn’t match the exact type a function is expecting.

Elm’s type system lets us focus on the problem at hand instead of having to worry about how our code will behave when invalid inputs are passed. Functions in Elm also look more succinct due to the absence of type checking code. The rest of this section covers Elm’s type system in great detail.

==== Type

A type is a collection of values that have similar properties. For example, the type `Int` represents numbers with no fractional part: `+-1+`, `0`, `1`, `2` etc. And the type `Bool` represents logical values `True` and `False`. When we enter a value in `+elm repl+`, it tells us which type that value belongs to.

[source,elm]
----
> 1
1 : number

> 2.5
2.5 : Float

> True
True : Bool

> "dudeism"
"dudeism" : String
----

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/types-and-values.svg[]

`+:+` is used to separate a value from its type. It means “has type of”. When we typed `1`, the repl printed its type as `number`, which means a numeric type. Its final type is determined as an `Int` or a `Float` depending on how it’s used.

[source,elm]
----
> x = 1
1 : number

> 5.3 + x
6.3 : Float

> 5 + x
6 : number
----

When we add `1` to `5.3` we get a `Float`. When we add it to `5`, we still get a `number` because the result `6` can also be treated as either an `Int` or a `Float` depending on its usage. Here’s an example of `x` ending up with type `Int`:

[source,elm]
----
> x + (String.length "Duder")
6 : Int
----

The expression `+String.length "Duder"+` returns an `Int` value. So when we add `x` to the result of that expression, it is forced to become an `Int` value as well.

===== Expressions Have Types Too

Since all expressions in Elm get reduced to a value when evaluated, they too have a type.

[source,elm]
----
> "The church of " ++ "the latter-day dude"
"The church of the latter-day dude" : String
----

The expression `+"The church of " ++ "the latter-day dude"+` appends two strings. Its type is the type of whatever value it evaluates to.

****
NOTE: Up until now, the examples in this book have omitted the type printed by `+elm repl+` after an expression. Now that we know what a type is, we won’t be doing that anymore.
****

==== List Type

Let’s see what type we get when we enter a list.

[source,elm]
----
> [ 1.0, 2.0 ]
[1,2] : List Float

> [ "Jackie", "Treehorn" ]
["Jackie","Treehorn"] : List String
----

We get `List` followed by the type of values the list contains. How about an empty list?

[source,elm]
----
> []
[] : List a
----

Instead of a concrete type, we get `a`, which means the type can vary depending on how we use the empty list.

[source,elm]
----
> 1.5 :: []
[1.5] : List Float

> "Maude" :: []
["Maude"] : List String
----

If we append a float, its type is `+List Float+`, but if we append a string, its type is `+List String+`. All concrete type names in Elm start with a capital letter. Therefore, the lowercase `a` isn’t considered a type. It’s actually a _type variable_, which means it can be of any type. The letter `a` itself doesn’t have any significance. It’s just a stand-in for the concrete type Elm will determine after evaluating an expression.

Any name that starts with a lowercase letter can be a type variable. For example, `value`, `placeholder`, and `walter` are all valid names for a type variable. Elm just happens to use `a` in most cases because it’s succinct. Earlier when we entered `1` in the repl, it printed the type as `number`, which is a special type variable. We can only use `number` to represent either `Int` or `Float`. There are very few special type variables like `number` in Elm.

==== Array Type

[source,elm]
----
> import Array

> Array.fromList [ 1, 2, 3 ]
Array.fromList [1,2,3]
    : Array.Array number

> Array.fromList [ "You", "Human", "Paraquat" ]
Array.fromList ["You","Human","Paraquat"]
    : Array.Array String
----

Like `List`, the type of an array is `Array.Array` followed by the type of values the array contains. Types that aren’t pre-loaded into the repl are prefixed with the name of the module where they are defined. Since `Int`, `Float`, `String`, and `List` are automatically loaded into the repl, we don’t see a prefix attached to them.

==== Tuple Type

[source,elm]
----
> ( 1, 2 )
(1,2) : ( number, number1 )
----

Elm doesn’t have a name for a tuple type like `List` or `Array`. That’s why the repl prints the type as `+( number, number1 )+`. `number1` is also a special type variable. Basically, when a type variable starts with the word `number` and ends with an actual number it has a special meaning in Elm.

[source,elm]
----
> ( 1, 2, 3 )
(1,2,3) : ( number, number1, number2 )
----

You may be wondering why the type for `+( 1, 2 )+` is shown as `+(number, number1)+` and not `+(number, number)+`. After all, `1` and `2` both have the same type: `number`. But remember, in Elm there are two types of numbers: `Float` and `Int`. Because the type `+(number, number)+` uses exactly the same type variable, twice, that would mean our tuple would have to have exactly the same type twice — either two `Int`s or two `Float`s. By setting the type using two different type variables, `+(number, number1)+`, Elm gives us the flexibility to have one `Float` and one `Int`, if we desire. Here are four possible sets of values a tuple with type `+(number, number1)+` can have:

[source,elm]
----
> ( 1, 2 )
(1,2) : ( number, number1 )

> ( 1, 2.0 )
(1,2) : ( number, Float )

> ( 1.0, 2 )
(1,2) : ( Float, number )

> ( 1.0, 2.0 )
(1,2) : ( Float, Float )
----

To reiterate, numbers such as `1` and `2` can be treated as either `Int` or `Float` depending on their usage. That’s why you don’t see the type of `+(1, 2.0)+` as `+(Int, Float)+`. By using the type `+(number, Float)+`, Elm preserves the flexibility to use `1` as either an `Int` or a `Float` at a later point in time. Here’s what the type of a tuple containing two strings looks like:

[source,elm]
----
> ( "Bunny", "Uli" )
("Bunny","Uli") : ( String, String )
----

For tuples to be of the same type in Elm, they must contain the same number and type of values. `+( 1, 2 )+` and `+( 1, 2, 3 )+` have different types. So do `+( 1, 2 )+` and `+( "Bunny", "Uli" )+`. That’s why when we try to put two tuples with same type of values, but different lengths into a list, we get an error.

[source,elm]
----
> [ ( 1, 2 ), ( 3, 4, 5 ) ]

--------------------------- TYPE MISMATCH ----------------------------
The 2nd element of this list does not match all the previous elements:

7|   [ ( 1, 2 ), ( 3, 4, 5 ) ]
                 ^^^^^^^^^^^
The 2nd element is a tuple of type:

    ( number, number1, number2 )

But all the previous elements in the list are:

    ( number, number1 )
----

==== Record Type

[source,elm]
----
> { name = "The Big Lebowski", releaseYear = 1998 }
{ name = "The Big Lebowski", releaseYear = 1998 }
    : { name : String, releaseYear : number }
----

Like `Tuple`, Elm doesn’t have a name for a record type either. That’s why the repl prints the type as `+{ name : String, releaseYear : number }+`. It means the `name` field can only have a `String` and the `releaseYear` field can only have a `number`. As we learned in the <<record, Record>> section, we can use `+type alias+` to name the underlying structure of a record.

[source,elm]
----
> type alias Movie = { name : String, releaseYear : Int }
----

`+type alias+` gives a name to an existing type. `Movie` is not a new type. It’s just an alias for the type `+{ name : String, releaseYear : Int }+`. Later we’ll find out how to define our own types. `+type alias+` also creates a function for constructing records behind the scenes. We can use that constructor function to create a record like this:

[source,elm]
----
> Movie "The Big Lebowski" 1998
{ name = "The Big Lebowski", releaseYear = 1998 }
    : Movie
----

Now the type is `Movie` instead of `+{ name : String, releaseYear : Int }+`.

****
NOTE: If you don’t remember how a constructor function works, the <<record, Record>> section has a nice diagram that explains it in great detail.
****

==== Function Type

Functions also have types.

[source,elm]
----
> addOne y = y + 1
<function> : number -> number
----

We defined a function called `addOne` that takes one argument of type `number` and returns a number as well. So its type is printed as `+number -> number+`.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/function-type.svg[]

When we enter a function definition into a code file, it’s best practice to write down its type annotation. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
addOne : number -> number
addOne y =
    y + 1
----

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/function-type-annotation.svg[]

The parameter and return types are separated by `+->+`. We didn’t specify the type annotation for any of the functions we created before. How was Elm able to correctly identify the types of parameters and return values without the type annotation? Elm was able to do that because it can infer the types based on what operations we perform inside a function. In `addOne`, we’re using the `+++` operator which has the following type.

[source,elm]
----
> (+)
<function> : number -> number -> number
----

It takes two numbers and returns a number. The parameter `x` in `addOne` must be a `number` to satisfy the `+++` operator’s constraints. This automatic deduction of types is known as _type inference_. Elm makes extensive use of type inference throughout our code base so that we don’t have to specify the type of each and every value used in our programs. Let’s look at a few more examples of type inference in the repl.

[source,elm]
----
> divideByTwo z = z / 2
<function> : Float -> Float

> divideByTwo z = z // 2
<function> : Int -> Int
----

When we use the floating-point division operator (`+/+`), the `divideByTwo` function’s type is inferred as `+Float -> Float+`, but when we use the integer division operator (`+//+`), which truncates everything after the decimal point, the type is inferred as `+Int -> Int+`.

So far we’ve looked at simple functions that only use one operator. Let’s write a slightly more complex function and find out if Elm can infer its type too. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
guardiansWithShortNames guardians =
    guardians
        |> List.map String.length
        |> List.filter (\x -> x < 6)
        |> List.length
----

And expose `guardiansWithShortNames` in the module definition.

[source,elm]
----
module Playground exposing
    ( doubleScores
    , guardiansWithShortNames
    .
    .
----

We didn’t specify the type annotation for `guardiansWithShortNames` because we want Elm to infer its type. Let’s see what Elm shows as its type in the repl.

[source,elm]
----
> import Playground exposing (..)

> guardiansWithShortNames
<function> : List String -> Int
----

The first operation we apply to the `guardians` parameter helps Elm determine its type. For `List.map` to be able to apply `String.length` to each element in a list, those elements must be of type `String`. That’s why we see `+List String+` as the `guardian` parameter’s type. Similarly, Elm determines the return type of a function from the last operation performed. In the example above, it’s `List.length`, which returns an `Int` value.

[source,elm]
----
> List.length
<function> : List a -> Int
----

Therefore, Elm deduces that the `guardiansWithShortNames` function also returns an `Int` value. If Elm infers type automatically, then why do we still need to write the type annotation above each function declaration? Because we get the following benefits from type annotations:

* Provides documentation
* Enables code validation
* Limits types of values a function can accept

===== Providing Documentation

It’s often hard, for us humans, to deduce the types of parameters and return value just by looking at a function’s implementation. We can solve that problem by adding comments above each function like this:

[source,elm]
----
{- Takes a list of strings and
   returns an integer value
-}
guardiansWithShortNames guardians =
    guardians
        |> List.map String.length
        |> List.filter (\x -> x < 6)
        |> List.length
----

Static comments like this are only as good as their author’s ability to write well. They could also go stale if someone decides to change the function but forgets to update the comment. A better alternative is to use a type annotation that will never go stale because if the code doesn’t match the type annotation, the Elm compiler will throw an error. Add the following type annotation right above the `guardiansWithShortNames` function’s definition in `Playground.elm`

[source,elm]
----
guardiansWithShortNames : List String -> Int
guardiansWithShortNames guardians =
    ...
----

===== Enabling Code Validation

Elm can help us detect errors in our code by validating the type annotation against the actual code. Let’s say we want to write a function that adds two numbers. After some experimentation, we’ve figured out that the function’s type annotation should be:

[source]
----
add : number -> number -> number
----

Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
add : number -> number -> number
add num1 num2 =
    num1 ++ num2
----

And expose `add` in the module definition.

[source,elm]
----
module Playground exposing
    ( add
    .
    .
----

****
NOTE: We created a function called `add` back in the <<function, Functions>> section. If you still have that definition in `Playground.elm`, go ahead and remove it. Otherwise, you’ll get a duplicate definition error.
****

When we try to use the `add` function in the repl, we get the following error.

[source,elm]
----
> add 1 2

------------------- TYPE MISMATCH ------------------
The (++) operator cannot append this type of value:

221|     num1 ++ num2
         ^^^^
This `num1` value is a:

    number

Hint: Only strings, text, and lists are appendable.
----

In the type annotation we specified that `add` accepts two numerical arguments, but our code expects those arguments to be `appendable`. An `appendable` is a type variable that can represent a list, string, or text — those are the only types in Elm that can be appended together using `pass:[++]`. We mistakenly typed `pass:[++]` instead of `+++`. If we hadn’t added the type annotation, Elm would have happily accepted the `add` function’s definition and inferred its type to be:

[source]
----
add : appendable -> appendable -> appendable
----

Which is not what we want. Go ahead and replace `pass:[++]` with `+++` in the `add` function so that its implementation matches the type annotation.

[source]
----
add : number -> number -> number
add num1 num2 =
    num1 + num2
----

===== Limiting Types of Values a Function Can Accept

Let’s say we want our `add` function to accept only integer values. Modify its type annotation in `Playground.elm` to this:

[source]
----
add : Int -> Int -> Int
----

Now if we try to add two `Float` values, the compiler will throw an error.

[source,elm]
----
> add 1.5 2.3

----------------- TYPE MISMATCH ---------------
The 1st argument to `add` is not what I expect:

5|   add 1.5 2.3
         ^^^
This argument is a float of type:

    Float

But `add` needs the 1st argument to be:

    Int
----

Without type annotation, we wouldn’t have been able to limit the arguments to only `Int` values.

===== Type Annotation with Multiple Parameters

The type annotation for a function that accepts multiple arguments can be confusing to look at.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/multiple-params-type-annotation.svg[]

The return type is separated from the parameters by `+->+`. The parameters themselves are also separated by `+->+`. There’s no visual cue to tell where the parameters end and the return type begins. To understand why the type annotation uses a series of arrows, we need to first understand how a function in Elm works at a fundamental level.

In the <<function, Partial Function Application>> section, we learned that when we don’t pass enough arguments to a normal function, instead of getting an error we get a partially applied function.

[source,elm]
----
> add 1 2
3 : Int

> add 1
<function> : Int -> Int
----

When we pass only the first argument to `add`, it returns a function that looks something like this behind the scenes:

[source,elm]
----
addPartiallyApplied : Int -> Int
addPartiallyApplied num2 =
    1 + num2
----

It replaced `num1` with `1` and now it’s waiting for us to pass the second argument. First, let’s assign the partially applied function to a constant.

[source,elm]
----
> addPartiallyApplied = add 1
<function> : Int -> Int
----

Now we can apply `addPartiallyApplied` to `2` and get our final result.

[source,elm]
----
> addPartiallyApplied 2
3 : Int
----

In the beginning, `add` looked like a function that took two arguments and returned an `Int` value, but after careful inspection we found out that it actually accepts only one argument and returns a partially applied function. All functions in Elm work in this manner no matter how many arguments they appear to take on the surface. With this new found knowledge, we can rewrite the `add` function’s type annotation like this:

[source]
----
add : Int -> (Int -> Int)
----

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/curried-function.svg[]

Since parentheses indicate a function, if we continue to wrap each individual function in parenthesis, the type annotation will look like this:

[source]
----
add : (Int -> (Int -> Int))
----

However, Elm makes all those parentheses optional so that our type annotations can look much cleaner. That’s how we ended up with this:

[source]
----
add : Int -> Int -> Int
----

Currying::
  This process of evaluating a function that takes multiple arguments by converting it to a sequence of functions each taking a single argument is known as _currying_. This technique is what enables us to use the `+|>+` operator. Here’s an example we saw back in the link:function.html#forward-function-application[Function] section:
+
image:https://elmprogramming.com/images/chapter-3/3.10-function/pipe-operator.svg[]

[[exercise-461]]
==== Exercise 4.6.1

Now that we know what type annotations are, moving forward we’ll be adding them to all functions defined in a code file. Go back to `Playground.elm` and add type annotations to all functions. Once you’re done, run any function within `Playground.elm` in repl. Here’s an example:

[source,elm]
----
> add 2 4
----

You may see a list of type errors in the repl. You may also notice that Elm is expecting a few type values we haven’t yet discussed in this book, like `Order` and `+Html.Html.msg+`. The beautiful thing about Elm is, since it tells you exactly what type value it is expecting in the error message, you should still be able to complete the exercise even though you may not be familiar with all the types.

==== Creating Our Own Types

So far we have only used the types provided by Elm, but sometimes those types aren’t enough when we want to describe and structure complex data processed by our applications. It’s hard for Elm to predict what type of data each application wants to process. That’s why it allows us to create our own custom types. Here’s an example:

[source,elm]
----
> type Greeting = Howdy
----

We defined a new type called `Greeting`. It’s not an `Int`, `String` or any of the other types Elm provides. It’s a completely separate type of its own, and it has only one possible value: `Howdy`. Just like the type names Elm already comes with, all custom types must be named starting with a capital letter.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/custom-type-with-one-value.svg[]

Let’s see what we get when we try to print `Howdy` in the repl.

[source,elm]
----
> Howdy
Howdy : Greeting
----

As expected, the type is listed as `Greeting`. What happens if we try to print the `Greeting` type itself.

[source,elm]
----
> Greeting

------------ NAMING ERROR -------------
I cannot find a `Greeting` constructor:

7|   Greeting
     ^^^^^^^^
----

We get a naming error. We’ll get the same error if we also try to print other types provided by Elm.

[source,elm]
----
> String

------------ NAMING ERROR -----------
I cannot find a `String` constructor:

7|   String
     ^^^^^^
----

As it turns out, it doesn’t make sense to input a type into the repl. That’s because we’re supposed to enter a valid expression. `Howdy`, `1`, and `+"Walter"+` are values, and all values are valid expressions. That’s why we don’t get an error when we enter those values in the repl. On the other hand, `Greeting`, `Int`, and `String` are names that represent categories of values, not values themselves.

Custom types aren’t limited to only one value. We can give them as many values as we want. Let’s extend the `Greeting` type to include one more value.

[source,elm]
----
> type Greeting = Howdy | Hola
----

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/custom-type-with-two-values.svg[]

Now `Greeting` has two possible values: `Howdy` and `Hola`.

[source,elm]
----
> Howdy
Howdy : Greeting

> Hola
Hola : Greeting
----

`Greeting`’s definition looks very similar to how `Bool` is defined in Elm.

[source,elm]
----
type Bool = False | True
----

===== Using Custom Types

Let’s see how we can use the new type `Greeting` in our code. Add the following code right above the `main` function in `Playground.elm` located in the `+beginning-elm/src+` directory.

[source,elm]
----
type Greeting
    = Howdy
    | Hola


sayHello : Greeting -> String
sayHello greeting =
    case greeting of
        Howdy ->
            "How y'all doin'?"

        Hola ->
            "Hola amigo!"
----

And expose `+Greeting(..)+` and `sayHello` in the module definition.

[source,elm]
----
module Playground exposing
    ( Greeting(..)
    , sayHello  
    .
    .
----

****
NOTE: To access `Howdy` and `Hola` from outside the `Playground` module, we have to add `+(..)+` after `Greeting` in the module definition. `+(..)+` tells Elm to expose all data constructors inside a type. More on this later.
****

A custom type is often used with a case expression to pattern match a value of that type. Once a match is found, the corresponding expression is evaluated. There’s nothing special about how we use a custom type. The `Bool` type provided by Elm can also be used in a similar fashion.

[source,elm]
----
welcomeMessage : Bool -> String
welcomeMessage isLoggedIn =
    case isLoggedIn of
        True ->
            "Welcome to my awesome site!"

        False ->
            "Please log in."
----

The `sayHello` function takes one argument of type `Greeting`. If the value is `Howdy`, it engages in a proper Texan interaction. If the value is `Hola`, it says “Hello friend!” in Spanish. Let’s import `sayHello` into the repl and use it to greet a stranger.

[source,elm]
----
> import Playground exposing (..)

> sayHello Howdy
"How y'all doin'?" : String

> sayHello Hola
"Hola amigo!" : String
----

If you see the following error, restart the `+elm repl+` session. We defined the `Greeting` type first in the repl. Later when we redefined it in `Playground.elm`, the repl gets confused — hence the error message.

[source,elm]
----
------------------ TYPE MISMATCH -------------------
The 1st argument to `sayHello` is not what I expect:

6|   sayHello Howdy
              ^^^^^
This `Howdy` value is a:

    Elm_Repl.Greeting

But `sayHello` needs the 1st argument to be:

    Playground.Greeting
----

When typing code in a file, it’s best practice to break the definition of a custom type so that each value gets a line of its own. That’s why when we enter `+type Greeting = Howdy | Hola+` into an Elm file and save, `+elm-format+` automatically reformats it to:

[source,elm]
----
type Greeting
    = Howdy
    | Hola
----

In contrast, when typing code into the repl, it’s not necessary to break it into multiple lines because typing multiline code in the repl is tedious and requires special characters to indicate a line break.

===== The Difference Between `type` and `+type alias+`

It’s important to note that `type` and `+type alias+` are two different concepts. `type` creates a _new type_, whereas `+type alias+` gives a new name to an _existing type_. We already saw an example of `+type alias+` above. Here it is again:

[source,elm]
----
> type alias Movie = { name : String, releaseYear : Int }
----

We assigned `Movie` as a name to the type `+{ name : String, releaseYear : Int }+` so that we could create a movie record more succinctly like this:

[source,elm]
----
> Movie "The Big Lebowski" 1998
{ name = "The Big Lebowski", releaseYear = 1998 }
    : Movie
----

Here’s another example from the https://package.elm-lang.org/packages/elm/url/latest/Url[Url] module:

[source,elm]
----
type alias Url =
    { protocol : Protocol
    , host : String
    , port_ : Maybe Int
    , path : String
    , query : Maybe String
    , fragment : Maybe String
    }
----

Various functions in that module accept url as a record. To make that fact clearer, an alias called `Url` has been created. Type aliases make it easier for us to write succinct code. Let’s say we want to write a function that tells us whether a movie is released in `2016` or not.

[source,elm]
----
releasedIn2016 : Movie -> Bool
releasedIn2016 movie =
    movie.releaseYear == 2016
----

If we hadn’t created the `Movie` type alias, the type annotation would look like this:

[source,elm]
----
releasedIn2016 : { name : String, releaseYear : Int } -> Bool
releasedIn2016 movie =
    movie.releaseYear == 2016
----

It’s hard to know from type annotation what type of information the `releasedIn2016` function is expecting. But if we use a type alias, we can tell that it’s expecting a `Movie` record. As our application grows, our data structures also tend to get more complex. By giving names to these complex data structures, we can write code that’s much more readable without losing all the benefits we get from the type system.

===== Custom Types with Payload

Elm makes it easier to describe complex data structures by letting us add a payload to each value in a custom type. To understand what a payload is, let’s add a couple more options to our `Greeting` type. Modify it and the `sayHello` function in `Playground.elm` to this:

[source,elm]
----
type Greeting
    = Howdy
    | Hola
    | Namaste String
    | NumericalHi Int Int


sayHello : Greeting -> String
sayHello greeting =
    case greeting of
        Howdy ->
            "How y'all doin'?"

        Hola ->
            "Hola amigo!"

        Namaste message ->
            message

        NumericalHi value1 value2 ->
            value1 + value2 |> String.fromInt
----

We added two more ways to create a value of type `Greeting`. `Namaste` enables us to say hi in https://en.wikipedia.org/wiki/Nepali_language[Nepali language], and `NumericalHi` allows us to greet mathematicians. Unlike `Howdy` and `Hola`, `Namaste` and `NumericalHi` aren’t values by themselves. Instead they provide a way to create values (or data). That’s why they’re called _data constructors_. Let’s see what we get when we print them in the repl.

[source,elm]
----
> Namaste
<function> : String -> Greeting

> NumericalHi
<function> : Int -> Int -> Greeting
----

Interestingly enough, data constructors are actually functions behind the scenes. They take a payload as an argument and create values of type `Greeting`. In case of `Namaste`, the payload only consists of a string, but the payload for `NumericalHi` includes two `Int` values. There’s no limit to how many and what type of data a payload can contain.

`Namaste` and `NumericalHi` are like functions in that they must be applied to the arguments inside their payloads to create concrete values.

[source,elm]
----
> Namaste "Tapailai kasto cha?"
Namaste ("Tapailai kasto cha?") : Greeting

> NumericalHi 1 4
NumericalHi 1 4 : Greeting
----

****
NOTE: In Nepali language, _“Tapailai kasto cha?”_ means _“How are you?”_.
****

It’s important to keep in mind that the data constructors don’t behave like normal functions in terms of performing an operation on data. They’re more like boxes to put data into. They don’t do anything with that data other than carry them around. That’s why when we type `+NumericalHi 1 4+` into the repl, it spits out the same thing back. This entire expression: `+NumericalHi 1 4+` is considered a value of type `Greeting`.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/custom-type-payload.svg[]

Since `Howdy` and `Hola` take no payload, their values don’t need to be constructed. Their values are already established, which essentially makes them constants. That’s why when we print them, the repl doesn’t present them to us as functions.

[source,elm]
----
> Howdy
Howdy : Greeting

> Hola
Hola : Greeting
----

The way we used `Namaste` and `NumericalHi` in the `sayHello` function is very similar to how we used `Howdy` and `Hola`. The only difference is that we captured the arguments included in the payload and used them to create an appropriate response.

Although `Howdy` and `Hola` behave like constants, sometimes you’ll hear them being referred to as _nullary data constructors_. A nullary constructor is a constructor that takes no arguments.

==== Union Types

The `Greeting` custom type we created above actually has a name in Elm. It’s called a _union type_. All custom types created using the `type` keyword are called union types. They are sometimes referred to as _tagged unions_ or _algebraic data types (ADTs)_.

The term _union_ is derived from set theory — a branch of mathematics for studying collections of distinct objects known as sets. A set can contain anything we can imagine such as numbers, people, cars, movies, nations, colors, and so on. Let’s say we have two sets of numbers:

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/sets-of-numbers.svg[]

The union of these two sets looks something like this:

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/set-union.svg[]

Notice that the union contains only one instance of `3` and not two. Each element in a set has to be unique. We can only have `3` once. Another way to visualize a union of two sets is through a https://en.wikipedia.org/wiki/Venn_diagram[Venn diagram].

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/set-union-venn-diagram.svg[]

If two sets don’t have any elements in common, they are called disjoint sets and their union is called _disjoint union_.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/disjoint-set-union.svg[]

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/disjoint-union-venn-diagram.svg[]

In a disjoint union, it’s always possible to tell where each element came from. For example, we can tell that `2` came from set `A`, and `4` came from `B`. If two sets do have some elements in common, it’s still possible to create a disjoint union by tagging the elements in each set.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/tagged-disjoint-union-set.svg[]

`X` and `Y` are two sets that are not disjoint because they have a common element: `3`. To create a disjoint union, first, we need to turn `X` and `Y` into disjoint sets by tagging each element in both sets. Tagging makes them disjoint because the letter `X` is not equal to the letter `Y`, even though the number `3` is equal in both cases. We can tag an element by creating a pair whose first element is the name of the set where the second element came from. X^*^ and Y^*^ are disjoint sets that contain tagged elements from `X` and `Y`.

A union type in Elm is similar to a disjoint union set of tagged elements. For example, the `Greeting` type can be thought of as a disjoint union of four sets:

* A set that contains `Howdy` as its only element.
* A set that contains `Hola` as its only element.
* A set that contains infinite number of strings each tagged with `Namaste`.
* A set that contains infinite number of two `Int` values tagged with `NumericalHi`.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/type-as-disjoint-union-set.svg[]

The third set that contains elements tagged with `Namaste` looks like this:

[source,elm]
----
{ (Namaste "a"), (Namaste "b"), (Namaste "aaramai?"), ... }
----

The total number of elements in this set is equal to the total number of unique strings we can create in Elm, which is infinite. Similarly, the fourth set that contains elements tagged with `NumericalHi` looks like this:

[source,elm]
----
{ (NumericalHi 0 0), (NumericalHi 0 1), (Numerical 0 2), ... }
----

The total number of elements in this set is equal to twice the number of `Int` values we can create in Elm, which is a very large number. The `Greeting` type represents every single element in all four sets listed above. Now you know why the custom types in Elm are called _union_ or _tagged union_ types.

===== Duplicate Tags

Each tag in a type has to be unique. Add a duplicate tag to the `Greeting` type in `Playground.elm` like this:

[source,elm]
----
type Greeting
    = Howdy
    | Hola
    | Namaste String
    | NumericalHi Int Int
    | NumericalHi Int Int Int
----

Now try to print `NumericalHi` in the repl.

[source,elm]
----
> NumericalHi

---------------------------- NAME CLASH -----------------------------
This file defines multiple `NumericalHi` type constructors. One here:

231|     | NumericalHi Int Int
           ^^^^^^^^^^^
And another one here:

232|     | NumericalHi Int Int Int
           ^^^^^^^^^^^
How can I know which one you want? Rename one of them!
----

As you can see, Elm gets confused by the duplicate definition because `NumericalHi` is essentially a function behind the scenes and we can’t have two functions with the same name in the same scope. Elm also prevents us from creating two different types with the same tag in the same scope. Remove the duplicate `NumericalHi` tag from `Greeting` and define a new type called `Salutation` right above `Greeting` in `Playground.elm`.

[source,elm]
----
type Salutation
    = Aloha
    | Howdy
----

The new type `Salutation` also includes `Howdy` as one of its tags. Let’s see what we get when we try to print `Howdy` in the repl.

[source,elm]
----
> Howdy

------------------------- NAME CLASH --------------------------
This file defines multiple `Howdy` type constructors. One here:

233|     = Howdy
           ^^^^^
And another one here:

229|     | Howdy
           ^^^^^
How can I know which one you want? Rename one of them!
----

Once again, Elm is confused. Remove the type definition for `Salutation` from `Playground.elm`. One big advantage of using union types in Elm is that the compiler will force us to handle all cases. For example in the `sayHello` function, if we leave out even a single case from the `Greeting` type, the compiler will complain. Remove the code that handles `NumericalHi` tag from `sayHello` in `Playground.elm`.

[source,elm]
----
sayHello : Greeting -> String
sayHello greeting =
    case greeting of
        Howdy ->
            "How y'all doin'?"

        Hola ->
            "Hola amigo!"

        Namaste message ->
            message
----

Now if we try to print `sayHello` in the repl, we get the following error.

[source,elm]
----
> sayHello

------------------ MISSING PATTERNS ----------------------
This `case` does not have branches for all possibilities:

236|>    case greeting of
237|>        Howdy ->
238|>            "How y'all doin'?"
239|>
240|>        Hola ->
241|>            "Hola amigo!"
242|>
243|>        Namaste message ->
244|>            message

Missing possibilities include:

    NumericalHi _ _

I would have to crash if I saw one of those. Add branches for them!
----

The Elm compiler is like a friendly assistant who gently informs us when we make a mistake. We have Elm’s powerful type system to thank to for making the compiler so smart. Go ahead and add the `NumericalHi` case back to the `sayHello` function.

[source]
----
sayHello : Greeting -> String
sayHello greeting =
    case greeting of
        .
        .
        Namaste message ->
            ...

        NumericalHi value1 value2 ->
            value1 + value2 |> String.fromInt
----

==== Type Constructor

In the <<regular-expression, Regular Expressions>> section we learned how the `Maybe` type works, but we haven’t really seen its type definition. Here is how it looks:

[source,elm]
----
type Maybe a
    = Just a
    | Nothing
----

`Maybe` is a built-in type in Elm that allows us to express the idea of a missing value. Often times we are not quite sure whether a value we are looking for really exists. For example, if we try to retrieve the tenth element from an array that only contains five elements, we get `Nothing`.

[source,elm]
----
> import Array

> myArray = Array.fromList [ 0, 1, 2, 3, 4 ]
Array.fromList [0,1,2,3,4]
    : Array.Array number

> Array.get 10 myArray
Nothing : Maybe number
----

Instead of returning an error or crashing our program, the `get` function returns a value of type `Maybe`. Here is what the type annotation for `get` looks like:

[source]
----
get : Int -> Array a -> Maybe a
----

Like `List` and `Array`, `Maybe` is a container, but it can have at most one value in it. That value can be of any type. To create a value of type `Maybe`, we must use either the `Just` data constructor or `Nothing` constant.

[source,elm]
----
> Nothing
Nothing : Maybe a

> Just 5
Just 5 : Maybe number

> Just "Andre the Giant"
Just ("Andre the Giant") : Maybe String

> Just [ 1, 2, 3 ]
Just [1,2,3] : Maybe (List number)
----

Unlike our `Greeting` type, `Maybe` by itself is not a valid type. It merely provides a way for us to construct a type. That’s why it’s called a _type constructor_. It must be applied to another type argument for it to generate a valid type. `+Maybe Int+`, `+Maybe String+`, `+Maybe (List number)+` are all valid types.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/maybe-type-definition.svg[]

Generic (or parameterized) types such as `+Maybe a+` can be incredibly powerful. To create our own generic types all we have to do is pass an argument to a type constructor. The `Greeting` type we created earlier is not a generic type.

[source,elm]
----
type Greeting
    = Howdy
    | Hola
    | Namaste String
    | NumericalHi Int Int
----

Data constructors that create a value of type `Greeting` expect their payloads to be of certain types. `Namaste` requires its payload to be a `String`, and `NumericalHi` requires two `Int` values. Modify the type definition for `Greeting` in `Playground.elm` so that it accepts a type argument.

[source,elm]
----
type Greeting a
    = Howdy
    | Hola
    | Namaste a
    | NumericalHi Int Int
----

Now that we can pass a type argument to `Greeting`, the `Namaste` data constructor isn’t limited to just one type. It accepts a payload of any type. Before trying out the following examples, comment out the `sayHello` function including its type annotation and remove it from the list of values being exposed in the module definition. Otherwise, you’ll get errors. We’ll fix that function soon.

[source,elm]
----
> Namaste 5
Namaste 5 : Greeting number

> Namaste "aaramai?"
Namaste "aaramai?" : Greeting String

> Namaste [ 1, 2, 3 ]
Namaste [1,2,3] : Greeting (List number)
----

Its type signature has also changed.

[source]
----
> Namaste
<function> : a -> Greeting a
----

Before adding a type argument, it was this:

[source,elm]
----
> Namaste
<function> : String -> Greeting
----

Notice that we used the type argument `a` only with `Namaste`, but not with `NumericalHi`. We’re not required to pass a type argument to all data constructors. In fact, we don’t even have to pass it to any data constructor. The following type definition is perfectly valid in Elm. Modify the type definition for `Greeting` to look like this:

[source,elm]
----
type Greeting a
    = Howdy
    | Hola
    | Namaste String
    | NumericalHi Int Int
----

A type argument that doesn’t get used in any of the data constructors is known as a _phantom type argument_. There are legitimate reasons for a phantom type argument’s existence, but the explanation of those reasons is beyond the scope of this book.

Since `Greeting` and `+Greeting a+` are two different types, we need to modify the `sayHello` function’s type annotation. Uncomment the `sayHello` function and expose it in the module definition once again. After that, modify its type annotation to this:

[source]
----
sayHello : Greeting a -> String
----

We only need to change the type annotation, but not `+sayHello greeting =+` part in function definition, because the function parameter `greeting` simply holds any value of type `+Greeting a+`. Another way of looking at it is, if we change our type definition to `+type Welcome a+`, we would need to change the type annotation to `+sayHello : Welcome a -> String+`, but we could then leave our function definition as `+sayHello greeting =+`.

The type annotation is the thing that connects the value stored in a function parameter to the correct type, not the name of the function parameter itself, which can be whatever we want. Before we move on, let’s revert the type definition for `Greeting` back to this:

[source,elm]
----
type Greeting a
    = Howdy
    | Hola
    | Namaste a
    | NumericalHi Int Int
----

The only thing that changed is the `Namaste` data constructor requires its payload to be of type `a` instead of `String`. Now if we try to print `sayHello` in repl, we’ll get the following error.

[source,elm]
----
> sayHello

------------------------ TYPE MISMATCH ------------------------
Something is off with the 3rd branch of this `case` expression:

244|             message
                 ^^^^^^^
This `message` value is a:

    a

But the type annotation on `sayHello` says it should be:

    String

Hint: Your type annotation uses type variable `a` which means 
ANY type of value can flow through, but your code is saying it 
specifically wants a `String` value. Maybe change your type 
annotation to be more specific? Maybe change the code to be more 
general?
----

According to the error message, all branches in a `case` expression must return a value of the same type, but we aren’t following that rule. We’re returning a `String` value for `Howdy`, `Hola`, and `NumericalHi`, and returning a value of any type (represented by `a`) for `Namaste`.

Functions in Elm must return a value of only one type. Therefore, we need to either have all branches return a value of type `a` or `String`. Let’s revert the definition back to what it was before we introduced the type variable to get rid of the error:

[source,elm]
----
type Greeting
    = Howdy
    | Hola
    | Namaste String
    | NumericalHi Int Int
----

Since `Greeting` doesn’t accept a type variable anymore, we need to modify the `sayHello` function’s type annotation to this:

[source]
----
sayHello : Greeting -> String
----

===== Multiple Type Arguments

Elm allows us to have multiple arguments in a type definition. Here’s an example:

[source,elm]
----
type Result error value
    = Ok value
    | Err error
----

Like `Maybe`, `Result` is another built-in type in Elm. It accepts two type arguments: `error` and `value`. The `Result` type comes very handy when an operation fails and we need to return a descriptive error message. To see it in action, let’s try to decode some https://www.json.org/[JSON] values and see what output we get. Install the https://package.elm-lang.org/packages/elm/json/latest/[`+elm/json+`] package by running the following command from `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install elm/json
----

If you see the following message, answer `Y`.

[source,bash]
----
I found it in your elm.json file, but in the "indirect" dependencies.
Should I move it into "direct" dependencies for more general use? [Y/n]:
----

Now run the following code in `+elm repl+`.

[source,elm]
----
> import Json.Decode exposing (decodeString, int)

> decodeString int "42"
Ok 42 : Result Json.Decode.Error Int

> decodeString int "hello"
Err (Failure ("This is not valid JSON! Unexpected token h in JSON at position 0") <internals>)
    : Result Json.Decode.Error Int
----

****
NOTE: The `Json.Decode` module provides functions for decoding a JSON string into Elm values. We’ll cover this module in detail in http://localhost:4000/decoding-json-part-1.html[chapter 6].
****

When we give the `decodeString` function an invalid input, it returns a value of type `Result` instead of crashing our program. Here’s what `decodeString`’s type signature looks like:

[source]
----
decodeString : Decoder a -> String -> Result Error a
----

To create a value of type `Result`, we must use one of these data constructors: `Ok` and `Err`.

[source,elm]
----
> Ok 5
Ok 5 : Result error number

> Ok "hello"
Ok "hello" : Result error String

> Ok [ 1, 2, 3 ]
Ok [1,2,3] : Result error (List number)

> Err "Operation failed because you entered invalid data."
Err ("Operation failed because you entered invalid data.")
    : Result String value
----

`Result` type is a bit more expressive than `Maybe`. Instead of just returning `Nothing`, we can create a descriptive message that explains why the operation didn’t succeed. The next example shows how the `Result` type can make the output of our function more descriptive. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
signUp : String -> String -> Result String String
signUp email ageStr =
    case String.toInt ageStr of
        Nothing ->
            Err "Age must be an integer."

        Just age ->
            let
                emailPattern =
                    "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b"

                regex =
                    Maybe.withDefault Regex.never <|
                        Regex.fromString emailPattern

                isValidEmail =
                    Regex.contains regex email
            in
            if age < 13 then
                Err "You need to be at least 13 years old to sign up."

            else if isValidEmail then
                Ok "Your account has been created successfully!"

            else
                Err "You entered an invalid email."
----

Now expose `signUp` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .
    , signUp
    )
----

The `signUp` function takes an email address and an age as inputs. First, it attempts to convert the user entered age from `String` to `Int`. Since the `String.toInt` function returns a `Maybe` type, we need to use a `case` expression to handle both success and failure scenarios. If the user is at least thirteen years old and the email is valid too, we return a success message tagged with `Ok`, otherwise we return an appropriate error message tagged with `Err`.

[source,elm]
----
> import Playground exposing (..)

> signUp "thedude@rubix.com" "48"
Ok ("Your account has been created successfully!")
    : Result String String

> signUp "@sobchaksecurity.com" "51"
Err ("You entered an invalid email.") : Result String String

> signUp "walter@sobchaksecurity.com" "11"
Err ("You need to be at least 13 years old to sign up.")
    : Result String String

> signUp "bunny@jackietreehorn.com" "aa"
Err ("Age must be an integer.") : Result String String
----

The `Maybe` and `Result` types provide a robust mechanism for handling errors during the compile time. As a result, it’s extremely rare to have runtime errors in Elm.

==== Type vs Data Constructor

At this point you may be wondering where exactly in our code do type and data constructors get used. Type constructors are mainly used either in a type declaration or a type annotation, whereas data constructors are used inside a function body or when we define a top-level constant. Let’s say we want to find out which of the Stark siblings from https://en.wikipedia.org/wiki/Game_of_Thrones[Game of Thrones] have reached adulthood. Add the following code right above `main` in `Playground.elm`.

[source]
----
type alias Character =
    { name : String
    , age : Maybe Int
    }


sansa : Character
sansa =
    { name = "Sansa"
    , age = Just 19
    }


arya : Character
arya =
    { name = "Arya"
    , age = Nothing
    }


getAdultAge : Character -> Maybe Int
getAdultAge character =
    case character.age of
        Nothing ->
            Nothing

        Just age ->
            if age >= 18 then
                Just age

            else
                Nothing
----

And expose `Character`, `sansa`, `arya`, and `getAdultAge` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .
    , Character
    , sansa
    , arya
    , getAdultAge
    )
----

We defined a record called `Character` that contains a character’s name and age. A concrete type `+Maybe Int+` is assigned to the `age` field to indicate that a character may choose not to disclose their age. We then created two characters: `sansa` and `arya`. `sansa`’s age is included in the record as `+Just 19+`, but `arya`’s is listed as `Nothing` which means her age is unknown.

So far, in the example above, we have encountered one type constructor (`Maybe`) and two data constructors (`Just` and `Nothing`). `Nothing` is more like a constant, but we are treating it as a nullary data constructor here. Since `Character` is a type alias, it’s not considered a real type. As we can see, the `Maybe` type constructor is used in the record’s type declaration.

[source,elm]
----
type alias Character =
    { name : String
    , age : Maybe Int
    }
----

Although `Character` is not a real type, `+{ name : String, age : Maybe Int }+` is. A type alias tends to show up in places where a type constructor usually does. When we create an actual record, instead of using the `Maybe` type constructor, we need to use either `Just` or `Nothing` data constructor.

[source,elm]
----
sansa : Character
sansa =
    { name = "Sansa"
    , age = Just 19
    }


arya : Character
arya =
    { name = "Arya"
    , age = Nothing
    }
----

The `Maybe` type constructor also shows up in the `getAdultAge` function’s type annotation.

[source]
----
getAdultAge : Character -> Maybe Int
----

The `Just` and `Nothing` data constructors are used inside the function body to create actual values of type `+Maybe Int+`. They’re also used in the case expression to pattern match the values contained inside `character.age`.

[source]
----
getAdultAge character =
    case character.age of
        Nothing ->
            Nothing

        Just age ->
            if age >= 18 then
                Just age
            else
                Nothing
----

Let’s see how the `getAdultAge` function behaves when we give it a character whose age is present.

[source,elm]
----
> getAdultAge sansa
Just 19 : Maybe Int
----

In repl, a data constructor shows up in the value area, whereas a type constructor shows up in the type annotation area.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/value-and-type-annotation-areas.svg[]

How about a character whose age is missing?

[source,elm]
----
> getAdultAge arya
Nothing : Maybe Int
----

As expected, we get `Nothing`. Let’s create three more characters in repl to further explore the `getAdultAge` function’s behavior.

[source,elm]
----
> jonSnow = Character "Jon Snow" <| Just 21
{ age = Just 21, name = "Jon Snow" }
    : Character

> rickon = Character "Rickon" <| Just 11
{ age = Just 11, name = "Rickon" }
    : Character

> robb = Character "Robb" <| Just 18
{ age = Just 18, name = "Robb" }
    : Character
----

What happens if we give a character whose age is less than `18` to `getAdultAge`?

[source,elm]
----
> getAdultAge rickon
Nothing : Maybe Int
----

Instead of returning `rickon`’s actual age, it returns `Nothing` because the `getAdultAge` function is designed to ignore the age of characters who haven’t reached adulthood yet. We can take advantage of this behavior to do something cool: print only the age of adult characters.

[source,elm]
----
> List.filterMap getAdultAge [ sansa, arya, jonSnow, rickon, robb ]
[19,21,18] : List Int
----

In Elm, we can guess how a function works by looking at its type. Let’s give it a try. When we ask the repl for `List.filterMap`’s type, here’s what we get:

[source,elm]
----
> List.filterMap
<function> : (a -> Maybe b) -> List a -> List b
----

The type annotation tells us that the `filterMap` function takes two arguments:

* A function that indicates whether a specific operation is successful or not for a given input. If successful, it returns a value wrapped in `Just`, otherwise it returns `Nothing`.
* A list of values of type `a`.

Finally, the `filterMap` function returns a list of values of type `b`. In most cases, type annotation alone isn’t enough to figure out how a function actually works. For example, one of the behaviors that’s not quite apparent from the type annotation is that `filterMap` discards all elements from the original list for which the `getAdultAge` function returns `Nothing`. It then pulls values out from the remaining `Just` elements and puts them in a new list.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/filter-map-list.svg[]

==== Recursive Types

In the <<list, How List Works Behind the Scenes>> section, we learned that `List` in Elm is defined as a _recursive type_. At the time, we didn’t know enough about types to fully grasp the idea of recursive types. Now that we know what types are, we’re better positioned to understand what they are. Let’s say we have a list of numbers: `+[ 16, 5, 31, 9 ]+`. Behind the scenes, this list is constructed like this:

[source,elm]
----
> []
[] : List a

> 9 :: []
[9] : List number

> 31 :: [ 9 ]
[31,9] : List number

> 5 :: [ 31, 9 ]
[5,31,9] : List number

> 16 :: [ 5, 31, 9 ]
[16,5,31,9] : List number
----

We started with an empty list and added `9` in-front of it using the cons (`+::+`) operator. We then continued to add the rest of the elements to that list one at a time. When a list is constructed like this, we can see the underlying recursive structure inherent in all lists.

image:https://elmprogramming.com/images/chapter-3/3.16-list/recursive-list-example.svg[]

The figure above shows that a list consists of nodes which themselves are lists. This is what makes the `List` type recursive. Let’s create our own data structure that looks very much like `List` to better understand how a recursive data structure works. Add the following type definition right above `main` in `Playground.elm`.

[source,elm]
----
type MyList a
    = Empty
    | Node a (MyList a)
----

And expose `MyList` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .
    , MyList(..)
    )
----

What the definition above means is that a list of type `MyList` can be either `Empty` or `+Node a+` followed by another list `+(MyList a)+`. A list with no elements can be represented like this: `Empty`. A list with a single element is represented like this: `+Node a Empty+`. Similarly, a list with two elements is represented like this: `+(Node a (Node a Empty))+` and so on. Now let’s recreate the list `+[ 16, 5, 31, 9 ]+` using our definition.

[source,elm]
----
> Empty
Empty : MyList a

> Node 9 Empty
Node 9 Empty : MyList number
----

We start with an empty element and then add 9 in front of it similarly to how we built a list using the cons (`+::+`) operator: `+9 :: []+`. Next, we keep adding the rest of the elements to the front.

[source,elm]
----
> Node 31 (Node 9 Empty)
Node 31 (Node 9 Empty)
    : MyList number

> Node 5 (Node 31 (Node 9 Empty))
Node 5 (Node 31 (Node 9 Empty))
    : MyList number

> Node 16 (Node 5 (Node 31 (Node 9 Empty)))
Node 16 (Node 5 (Node 31 (Node 9 Empty)))
    : MyList number
----

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/recursive-list-definition.svg[]

Granted our list doesn’t look as nice as the one Elm provides, but conceptually they’re the same. Although `MyList` behaves similarly to `List`, we can’t use any of the functions defined in the https://package.elm-lang.org/packages/elm/core/latest/List[List] module. `MyList` and `List` are two completely different types. In the <<easier-code-organization, Easier Code Organization>> section we will reimplement one of the functions from the `List` module so that it will work on `MyList` too.

It’s important to note that if a recursive type doesn’t provide at least one nullary data constructor, then we end up with a value that never ends. If we remove the `Empty` data constructor from `MyList`:

[source,elm]
----
type MyList a
    = Node a (MyList a)
----

We’ll end up with a value like this:

[source,elm]
----
Node 16 (Node 5 (Node 31 (Node 9 (Node 18 (Node 7 (Node 26 (...)))))))
----

`+...+` represents infinite iterations of `+Node a+`.

===== Working with Recursive Types

We can use recursive types the same way we use any other union type. A `case` expression is used to pattern match each individual data constructor defined in the type. Add the following function definition right above `main` in `Playground.elm`

[source,elm]
----
sum : MyList Int -> Int
sum myList =
    case myList of
        Empty ->
            0

        Node intValue remainingNodes ->
            intValue + sum remainingNodes
----

And expose `sum` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .
    , sum
    )
----

`sum` is a function that computes a sum of int values contained in a `MyList`. We need to handle only two cases (`Empty` and `Node`) because those are the only two data constructors `MyList` type offers. If the list is not empty, we remove an int value from the front and apply `sum` <<function-composition, recursively>> to the rest of the list. Here’s how we can use `sum` in the repl:

[source,elm]
----
> import Playground exposing (..)

> myList = Node 1 (Node 2 (Node 3 (Node 4 Empty)))
Node 1 (Node 2 (Node 3 (Node 4 Empty)))
    : MyList number

> sum myList
10 : Int
----

The figure below shows each individual step in the execution of `+sum myList+` expression.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/my-list-recursive-sum.svg[]

Recursive types are very powerful. They enable us to define complex data structures succinctly. Let’s implement one more data structure called _binary tree_ using a recursive type. Explaining the inner workings of a binary tree is out of scope for this book, so we’ll just look at its definition and visual illustration.

[source,elm]
----
type Tree a
    = Empty
    | Node a (Tree a) (Tree a)
----

`Tree` represents a https://en.wikipedia.org/wiki/Binary_tree[binary tree] — a hierarchical tree structure in which each node can have at most two children. It has many applications in programming.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/binary-tree.svg[]

The tree shown in the figure above can be implemented like this:

[source,elm]
----
exampleTree : Tree Int
exampleTree =
    Node '1'
        (Node '2'
            (Node '4'
                Empty
                (Node '8' Empty Empty)
            )
            (Node '5' Empty Empty)
        )
        (Node '3'
            (Node '6' Empty Empty)
            (Node '7'
                (Node '9' Empty Empty)
                Empty
            )
        )
----

If you add the `exampleTree` function and `Tree` type definition to `Playground.elm`, you’ll get a duplicate definition error because the `Node` data constructor is used by both `MyList` and `Tree` types, which isn’t allowed. The example above is meant to show you how you can create a tree using a recursive type definition. You don’t have to actually implement it.

==== How Powerful is Elm’s Type System Exactly?

Elm’s type system is quite powerful, but how does it compare to the type system of other languages out there? There are so many great languages to choose from, but we’ll limit our comparison to these three: JavaScript, https://www.haskell.org/[Haskell], and http://www.idris-lang.org/[Idris]. Type systems in these languages have some interesting characteristics that contrast well with Elm’s. For this exercise, we’ll use a simple function that adds two values.

****
NOTE: You don’t have to try out the code listed in the rest of this section. Just sit back and enjoy reading.
****

[source,javascript]
----
function add (x, y) {
    return x + y
}
----

The above function is written in JavaScript. Looking at the definition, we can’t tell what type of values the `add` function accepts. After some experimentation, we find out that it pretty much accepts anything.

[source,javascript]
----
> add(1, 2)
3

> add(2.5, 4.3)
6.8

> add('a', 'b')
"ab"

> add("romeo", "juliet")
"romeojuliet"
----

JavaScript is a _dynamically_ typed language, which means it doesn’t verify the type of values until a program is actually run. The types of `x` and `y` parameters aren’t known until we pass concrete values to the `add` function during its execution. As you can see from the examples above, it can add two integers, floating-point numbers, characters, and even strings. There’s no way to tell what values we can expect during compile time. Let’s reimplement the `add` function in Elm.

[source,elm]
----
add : number -> number -> number
add x y =
    x + y
----

Elm’s type system allows us to specify exactly what type of values our functions can operate on. With the type annotation above, we’re saying that the `add` function accepts two numbers and returns a number as well. A number can be either an `Int` or a `Float`. If we try to pass values of any other type, our program won’t even compile. Elm is a _statically_ typed language, which means it verifies the type of values during the compile time.

[source,elm]
----
> add 1 2
3 : number

> add 2.5 4.3
6.8 : Float
----

Next, let’s implement the `add` function in Haskell.

[source,ruby]
----
add :: Num a => a -> a -> a
add x y =
    x + y
----

The `add` function’s body in both Haskell and Elm looks exactly the same because Elm’s syntax is heavily derived from Haskell. Haskell’s type system also allows us to specify exactly what type of values our functions can operate on, but it’s more powerful than Elm’s. In Haskell, we can say that the `add` function accepts _any_ type of numbers not just `Int` and `Float`, and returns a number of that same type.

One of the reasons why Haskell’s type system is more expressive than Elm’s is due to _type classes_, which allow us to group common behaviors found in different types. `Int`, `Integral`, `Float`, and `Double` are different types in Haskell, but they all share one common behavior: they can be treated as numbers. So operations that can be applied to all numbers are defined in a type class called `Num`. When we ask Haskell to reveal all the operations defined in `Num`, we get the following list.

[source,ruby]
----
> :info Num
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
----

`+::+` in Haskell is the same as `+:+` in Elm. It means “has type of”. As you can see, the `+++` operator belongs to the `Num` type class. That means our `add` function can operate on any type that is a member of `Num`. That’s why the type annotation for the `add` function includes `Num`.

[source,ruby]
----
add :: Num a => a -> a -> a
----

Anything that comes before `+=>+` and after `+::+` is a type class constraint. `Num` is the type class and `+Num a+` is a class constraint on the type variable `a`. Let’s compare Haskell’s type annotation with Elm’s:

[source]
----
add : number -> number -> number
----

Elm’s type annotation is much more restrictive than Haskell’s. Now, you may be thinking that `number` in Elm seems like a type class — it lets us say the `add` function accepts a `number` and not just `Int` or `Float`, after all. However, we were able to do that not because `number` represents a type class, but because it happens to be a special type variable that stands in for both `Int` and `Float` types.

****
NOTE: The designers of Elm chose not to include type classes in the language due to various reasons. https://github.com/elm-lang/elm-compiler/issues/38[This issue] on Github explains what those reasons are.
****

Lastly, let’s reimplement the same `add` function in Idris.

[source,ruby]
----
add : (x : Nat) -> (y : Nat) -> {auto smaller : LT x y} -> Nat
add x y =
    x + y
----

The `add` function’s body in Idris also looks exactly like the one in Elm and Haskell. That’s because Idris, too, heavily derives its syntax from Haskell. The type annotation, however, looks quite different. It says that the `add` function accepts two integers and also returns an integer, but the first argument must be smaller than the second.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/idris-type-annotation.svg[]

In Idris, the compiler will make sure that `add` is never applied to two arguments if the first argument is greater than the second. Constraints like this is possible in Idris because it supports https://en.wikipedia.org/wiki/Dependent_type[dependent types] — a type whose definition depends on a value. Very few languages allow us to specify constraints like this through types. Even Haskell doesn’t have this capability. In Haskell, we can check for this constraint only during runtime like this:

[source,ruby]
----
add x y =
    if x < y then
        x + y
    else
        error "First argument must be smaller than the second."
----

To summarize, Elm’s type system allows us to specify more constraints than JavaScript’s, and Haskell’s type system allows us to specify more constraints than Elm’s. Finally, Idris’s type system allows us to specify even more constraints than Haskell’s. The more constraints we can specify at the compile time, the less chance there will be for errors to show during runtime. Therefore, Idris can prevent more bugs than Haskell, and Haskell can prevent more bugs than Elm.

image:https://elmprogramming.com/images/chapter-4/4.6-type-system/type-system-spectrum.svg[]

One obvious question is: if Idris’s type system can prevent most bugs, why didn’t the designers of Elm adopt a type system like that? The answer to that question lies in complexity. The more powerful a type system is, more complex it is to implement. It’s also harder to learn. One of the hallmarks of Elm is that it’s easy to learn. Some of that ease comes from not having an overly complex type system. That said, Elm’s type system is still powerful enough to make those pesky runtime errors extremely rare.


[[easier-code-organization]]
=== 4.7 Easier Code Organization


A software program is like an organism. When it’s first brought into the digital world, it’s tiny. It might contain a few functions for solving a problem whose scope is very narrow. It then starts to grow, one function at a time. Before we know it, it turns into a behemoth capable of tackling problems with monstrous complexity.

It’s often easier to read and change small programs. But as programs grow into thousands of lines of code, they become hard to understand and maintain without a good organizational structure. Some of the features in Elm we explored earlier, such as <<immutability, immutability>>, <<pure-functions, pure functions>>, <<easy-to-test, tests>>, and a <<type-system, powerful type system>> help us write robust programs, but they don’t enable us to organize our code in a maintainable way.

Elm provides three more features that are designed specifically for better code organization: modules, packages, and the Elm Architecture. The Elm Architecture will be covered in <<elm-architecture-intro, chapter 5>>. We will cover the other two in this section.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/module-hierarchy.svg[]

A _value_ is the most basic concept in Elm. `1`, `a`, `+"Hannibal"+`, and `+[ 1, 2, 3 ]+` are all values. An expression allows us to compute a value by grouping together other values, operators, and constants. `+3 * x + 5 * y + 10+` is an expression. We can even use `if`, `case`, and `let` to combine multiple expressions and execute them only when certain conditions are met.

As we write more expressions, we’ll inevitably want to reuse some of them in multiple places. We can achieve reusability by using functions to encapsulate a bunch of expressions and give names to the collective task those expressions accomplish.

As our program grows, our data structures also tend to become more complex. To be able to easily describe complex data structures, we need to first define relationships between different kinds of values used in our program through the use of types. As the number of functions and type definitions grow, we need to start grouping together the ones that perform similar tasks into modules.

A module is essentially a collection of functions, constants, type definitions, and other values that can be reused in multiple contexts. For example, all functions that perform some kind of operation on a list of values are grouped into a module called https://package.elm-lang.org/packages/elm/core/latest/List[List]. We might even want to combine multiple modules that solve similar problems into a package. For example, various modules that provide functionalities for writing and manipulating HTML code are grouped together in a package called https://package.elm-lang.org/packages/elm/html/latest/[Html]. We can share a package with other programmers by publishing it through the http://package.elm-lang.org/[online catalog].

So far, in this book, we’ve created a few modules without understanding how they actually work. In this section, we’ll attempt to understand the syntax for creating new modules and how they get imported into other modules. Along the way, we’ll learn some best practices that will make the code in our modules more maintainable.

==== Creating a Module

In the <<type-system, Recursive Types>> section, we created our own data structure called `MyList` that looked very much like the built-in type `List`.

[source,elm]
----
type MyList a
    = Empty
    | Node a (MyList a)
----

Unfortunately, we can’t use any of the functions defined in the `List` module with `MyList`, because all those functions expect a list of type `List`. Let’s rewrite a function from the `List` module so that it also works on `MyList`. The source code for Elm’s standard library is freely available. We can read it to figure out how functions in the `List` module are implemented. Here is the original implementation for `List.isEmpty` function:

[source,elm]
----
isEmpty : List a -> Bool
isEmpty xs =
    case xs of
        [] ->
            True

        _ ->
            False
----

****
NOTE: You can find the source code for all modules included in the `+elm/core+` package https://github.com/elm/core/tree/1.0.0[here].
****

Quite simple, right? If the list is empty it returns `True`, otherwise it returns `False`. Let’s reimplement `isEmpty` so that it works with `MyList` too. Before we do that though, we need to create a module first. Create a file named `MyList.elm` in the `+beginning-elm/src+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/mylist-module-directory.png[]

[source,elm]
----
module MyList exposing (MyList(..), isEmpty, sum)


type MyList a
    = Empty
    | Node a (MyList a)


sum : MyList Int -> Int
sum myList =
    case myList of
        Empty ->
            0

        Node intValue remainingNodes ->
            intValue + sum remainingNodes


isEmpty : MyList a -> Bool
isEmpty xs =
    case xs of
        Empty ->
            True

        _ ->
            False
----

We created a module called `MyList` that contains the definition for the `MyList` type and two functions: `sum` and `isEmpty`. In the <<type-system, Recursive Types>> section, we had already defined `MyList` and `sum` in `Playground.elm`. Now that we have a separate module that will contain all code related to the `MyList` type, it makes sense to move them over to `MyList.elm`. Don’t forget to remove the definitions for the `MyList` type and `sum` function from `Playground.elm`.

You already know how `MyList` and `sum` work. If not, you can refresh your memory by reading the <<type-system, Recursive Types>> section again. `isEmpty` is a re-implementation of the `List.isEmpty` function. The only difference between our implementation and Elm’s is that we use `Empty` to represent emptiness whereas Elm uses `+[]+`.

****
NOTE: It’s perfectly OK to use the same name for a module and a type. In fact you will see this pattern over and over again with many of the modules Elm provides such as https://package.elm-lang.org/packages/elm/core/latest/Array[Array], https://package.elm-lang.org/packages/elm/html/latest/Html[Html], and https://package.elm-lang.org/packages/elm/core/latest/Task[Task]. However, Elm doesn’t allow us to have two modules or types with the same name.
****

`MyList`, `isEmpty`, and `sum` aren’t accessible outside the module they’re defined in, unless we expose them. Exposing a function is straightforward. We include its name between parentheses after the keyword `exposing`. But exposing a type requires us to append `+(..)+` to the type name. By adding `+(..)+`, we’re asking Elm to expose the `Empty` and `Node` data constructors as well.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/module-syntax.svg[]

It’s important to note that Elm doesn’t allow us to export only a subset of data constructors from a type. Therefore, the following code is invalid.

[source,elm]
----
module MyList exposing (MyList(Empty), isEmpty, sum)
----

We tried to expose only `Empty` from the `MyList` type. Elm doesn’t allow that because data constructors are primarily used for pattern matching and pattern matches need to be exhaustive. Take the `sum` function from the <<type-system, Recursive Types>> section for example.

[source,elm]
----
sum : MyList Int -> Int
sum myList =
    case myList of
        Empty ->
            0

        Node intValue remainingNodes ->
            intValue + sum remainingNodes
----

If Elm had allowed us to expose only `Empty`, we would have had to use the <<case-expression, catch-all-pattern>> to account for the `Node` constructor. That would have prevented us from correctly implementing the `sum` function.

[source,elm]
----
sum : MyList Int -> Int
sum myList =
    case myList of
        Empty ->
            0

        _ ->
            ...
----

Isn’t it great that the designers of Elm have put so much thought into how to guide us toward good code? You’ll encounter many more smart decisions like this as you learn more about Elm.

==== Importing a Module

To be able to use the new `isEmpty` function outside of `MyList` module, we need to import `MyList`. Let’s do that in `Playground.elm`.

[source,elm]
----
module Playground exposing
.
.
import MyList
----

We can verify that `MyList` was imported successfully by loading the `Playground` module up in a browser. Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it isn’t running already, and go to http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`]. If you don’t see any errors, that means the module was imported successfully. We’re now ready to use the `isEmpty` function in the `Playground` module. Add the following code right above `main` in `Playground.elm`.

[source,elm]
----
list1 : MyList.MyList a
list1 =
    MyList.Empty


list2 : MyList.MyList number
list2 =
    MyList.Node 9 MyList.Empty
----

Now, call the `isEmpty` function from `main` to check if the list referenced by `list1` is empty or not.

[source,elm]
----
main : Html.Html msg
main =
    MyList.isEmpty list1
        |> Debug.toString
        |> Html.text
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see `True`. Let’s apply `isEmpty` to `list2` to make sure that the false condition is also working.

[source,elm]
----
main : Html.Html msg
main =
    MyList.isEmpty list2
        |> Debug.toString
        |> Html.text
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should see `False`. The way we are creating lists now is slightly more verbose compared to how we created them in the <<type-system, Recursive Types>> section.

[source,elm]
----
-- Before
Node 9 Empty

-- Now
MyList.Node 9 MyList.Empty
----

The reason why we need to prefix `Node` and `Empty` with `MyList` is because the `MyList` type is now being used inside a code file instead of the repl. Before, when we imported the `Playground` module into repl, we used `+(..)+` after the `exposing` keyword so that everything inside that module is exposed.

[source,elm]
----
> import Playground exposing (..)
----

This allowed us to drop `MyList` prefix and use the data constructors directly. To drop the prefix in `Playground.elm` too, we need to explicitly expose the type when we import a module. Add `+exposing (MyList(..))+` to the end of the line that imports `MyList` in `Playground.elm`.

[source,elm]
----
module Playground exposing
.
.
import MyList exposing (MyList(..))
----

Notice the syntax for exposing a type — or any other value for that matter — in a module that uses that type is exactly the same as the one used in the module that created the type.

[source,elm]
----
module MyList exposing (MyList(..), isEmpty, sum)


type MyList a
    = Empty
    | Node a (MyList a)
.
.
----

Now we can get rid of the prefix from `list1` and `list2` in `Playground.elm`.

[source,elm]
----
list1 : MyList a
list1 =
    Empty


list2 : MyList number
list2 =
    Node 9 Empty
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you should still see `False`. We were also able to remove the `MyList` prefix from type annotations now that we’ve explicitly exposed the type.

[source]
----
-- Before
list1 : MyList.MyList a

-- Now
list1 : MyList a
----

What about `MyList.isEmpty` inside `main`?

[source,elm]
----
main : Html.Html msg
main =
    MyList.isEmpty list2
        |> Debug.toString
        |> Html.text
----

Can we get rid of the prefix there too? Sure. Just add `isEmpty` to the list of values being exposed in `Playground.elm`.

[source,elm]
----
module Playground exposing
.
.

import MyList exposing (MyList(..), isEmpty)
.
.

main : Html.Html msg
main =
    isEmpty list2
        |> Debug.toString
        |> Html.text
----

The figure below explains how the module import syntax works in detail.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/module-import-syntax.svg[]

The only thing that’s not exposed to the `Playground` module right now is the `sum` function. Let’s expose that too. Add `sum` to the list of things being exposed in `Playground.elm`.

[source,elm]
----
import MyList exposing (MyList(..), isEmpty, sum)
----

At this point, we have exposed all values from the `MyList` module. There is actually a shorthand `+(..)+` for exposing everything in a module. Let’s use that instead of exposing each value individually.

[source,elm]
----
module Playground exposing
.
.
import MyList exposing (..)
----

You’ve seen `+(..)+` in various places throughout the book. Now you know what it means. We cannot, however, use the `+(..)+` shorthand to expose everything in a file where the module is defined. Syntactically speaking, the following code is invalid.

[source,elm]
----
module MyList exposing (..)
----

But if you do type that code and save the file, `+elm-format+` will automatically replace `+..+` with the names of all values in `MyList.elm`. By not allowing us to expose everything through the use of `+(..)+`, Elm is encouraging us to carefully consider which values to expose from a module. We should expose as little as possible so that we don’t create unnecessary dependencies between modules. A code base with fewer dependencies is easier to maintain.

While we are at it, let’s get rid of the `Html` prefix too by exposing the `text` function and `Html` type in `Playground.elm`.

[source,elm]
----
module Playground exposing
.
.
import Html exposing (Html, text)
.
.

main : Html msg
main =
    isEmpty list2
        |> Debug.toString
        |> text
----

It’s tempting to remove the `Debug` prefix too like this:

[source,elm]
----
module Playground exposing
.
.
import Debug exposing (toString)
.
.
main : Html msg
main =
    isEmpty list2
        |> toString
        |> text
----

But we shouldn’t do that. The `Debug` module isn’t meant to be used in production. By not removing `Debug` as a prefix, we’re making it clear that this code needs to be removed or modified before it gets deployed to production.

==== Qualified vs Unqualified Import

What happens if we also want to use the `isEmpty` function from the `List` module inside `Playground.elm`? Let’s find out. Import the `List` module and add a constant named `list3` right above `main`. After that apply `isEmpty` to `list3` in `main` like this:

[source,elm]
----
module Playground exposing
.
.
import List exposing (isEmpty)
import MyList exposing (..)
.
.

list3 : List a
list3 =
    []


main : Html msg
main =
    isEmpty list3
        |> Debug.toString
        |> text
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] and you’ll see the following error.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/module-ambiguity-error.png[]

Elm is confused. It doesn’t know which `isEmpty` to use because we exposed it from both `List` and `MyList`. This is a drawback of exposing values when importing a module. To resolve this issue, we need to be explicit about which `isEmpty` we intend to use. Prefix `isEmpty` with `List` in `main`.

[source,elm]
----
main : Html msg
main =
    List.isEmpty list3
        |> Debug.toString
        |> text
----

Refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`] one more time and the error should go away.

Qualified Import::
  When we import a module without exposing anything inside it, it’s called a _qualified_ import. That means we have to prefix all functions, types, constants, and other values from that module with the module name.

[source,elm]
----
-- Qualified Imports

import Html
import MyList


list2 : MyList.MyList number
list2 =
    MyList.Node 9 MyList.Empty


main : Html.Html msg
main =
    MyList.isEmpty list2
        |> Debug.toString
        |> Html.text
----

Unqualified Import::
  When we explicitly expose values while importing a module it’s called an _unqualified_ import, which means we don’t need to prefix the module name.

[source,elm]
----
-- Unqualified Imports

import Html exposing (Html, text)
import MyList exposing (..)


list2 : MyList number
list2 =
    Node 9 Empty


main : Html msg
main =
    isEmpty list2
        |> Debug.toString
        |> text
----

Writing code in unqualified style is concise, but it’s also dangerous as we saw above with the name clash. The question is, when should we prefer qualified to unqualified? It’s best practice to write code in qualified style by default. Not only it gets rid of errors caused by name clashes, but also provides some level of documentation. When we see code written in unqualified style like this:

[source,elm]
----
import Html exposing (Html, text)
import List exposing (isEmpty)
import MyList exposing (..)
import SomeOtherModule exposing (..)


main : Html msg
main =
    isEmpty list2
        |> Debug.toString
        |> text
----

It’s not obvious where `isEmpty` comes from and what it does. Does it come from `List`, `MyList`, or `SomeOtherModule`? But if we use the qualified style, we know exactly where `isEmpty` comes from. We might even be able to deduce what it does based on its origin.

[source,elm]
----
import Html
import List
import MyList
import SomeOtherModule


main : Html.Html msg
main =
  List.isEmpty list2
    |> Debug.toString
    |> Html.text
----

Now we know that `isEmpty` definitely comes from `List` and it checks whether a list is empty or not. But there are scenarios where using the unqualified style could make our code more readable. In <<building-a-simple-page-in-elm, Building a Simple Web Page>> section, we wrote the following code.

[source,elm]
----
module HomePage exposing (main)

import Html exposing (..)
import Html.Attributes exposing (..)


view : a -> Html msg
view model =
    div [ class "jumbotron" ]
        [ h1 [] [ text "Welcome to Dunder Mifflin!" ]
        , p []
            [ text "Dunder Mifflin Inc. (stock symbol "
            , strong [] [ text "DMI" ]
            , text <|
                """
                ) is a micro-cap regional paper and office
                supply distributor with an emphasis on servicing
                small-business clients.
                """
            ]
        ]


main : Html msg
main =
    view "dummy model"
----

As you can see, the `Html` and `Html.Attributes` modules are imported using the unqualified style. The reason behind that is, these two modules contain non-overlapping functions. Therefore, the chances of function names clashing over each other is minimal. Furthermore, the function names in these modules resemble HTML markup pretty closely which makes reading the code that represents HTML in Elm quite intuitive. But if we were to write the code above in qualified style, it would be hard to read.

[source,elm]
----
module BeginningElm exposing (main)

import Html
import Html.Attributes


view : a -> Html.Html msg
view model =
    Html.div [ Html.Attributes.class "jumbotron" ]
        [ Html.h1 [] [ Html.text "Welcome to Dunder Mifflin!" ]
        , Html.p []
            [ Html.text "Dunder Mifflin Inc. (stock symbol "
            , Html.strong [] [ Html.text "DMI" ]
            , Html.text <|
                """
                ) is a micro-cap regional paper and office
                supply distributor with an emphasis on servicing
                small-business clients.
                """
            ]
        ]


main : Html.Html msg
main =
    view "dummy model"
----

If you do decide to use the unqualified style, I recommend limiting it to one `+exposing (..)+` per file. If there is a family of modules that often get used together such as `Html` and `Html.Attributes` where the chances of name clashes are minimal and the function names are self-documenting then it’s safe to use more than one `+exposing (..)+`.

Module Names with Prefix::
  Notice how the `Html.Attributes` module has a prefix called `Html` in its name? That’s because it resides in a package called https://package.elm-lang.org/packages/elm/html/latest/[Html] which contains multiple modules:
+
* Html
* Html.Attributes
* Html.Events
* Html.Keyed
* Html.Lazy
+
When we import a module from a package that has multiple modules in it, we have to add the package name as a prefix except when the module name is the same as the package name, for example the `Html` module. In that case, the package name essentially becomes a part of the module name. One exception to this rule is the https://package.elm-lang.org/packages/elm/core/latest[`Core`] package. It contains multiple modules, but when we import those modules we don’t have to prefix them with `Core`. For example, to import the `Array` module all we need to type is `+import Array+` and not `+import Core.Array+`.

==== As Syntax

If a module name is long, writing code in qualified style gets tedious and the final code looks verbose. Let’s say we have a module called `PageVisibility` whose name is a bit longer than some of the modules we have seen thus far. Take a look at the following code that uses this module. Don’t worry about what the code actually does, just pay attention to all the places the name `PageVisibility` appears.

[source,elm]
----
import PageVisibility


type Msg =
    VisibilityChanged PageVisibility.Visibility


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        VisibilityChanged PageVisibility.Visible ->
            ...

        VisibilityChanged PageVisibility.Hidden ->
            ...


subscriptions : Model -> Sub Msg
subscriptions model =
    PageVisibility.visibilityChanges VisibilityChanged
----

We can reduce the clutter by introducing a shorter alias for `PageVisibility` using the `as` syntax.

[source,elm]
----
import PageVisibility as PV


type Msg =
    VisibilityChanged PV.Visibility


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        VisibilityChanged PV.Visible ->
            ...

        VisibilityChanged PV.Hidden ->
            ...


subscriptions : Model -> Sub Msg
subscriptions model =
    PV.visibilityChanges VisibilityChanged
----

Looks better, doesn’t it? It also strikes a good balance between conciseness and self-documentation. `PV` is much more concise compared to `PageVisibility`, but we also know where the `visibilityChanges` function comes from. It’s prefixed with `PV` which is an alias for `PageVisibility`, so it must be from that module.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/module-import-as-syntax.svg[]

We can combine the `as` syntax with unqualified imports like this:

[source,elm]
----
import PageVisibility as PV exposing (visibilityChanges)
----

The alias must come before `exposing`, otherwise, Elm will throw an error.

[source,elm]
----
-- This will throw an error

import PageVisibility exposing (visibilityChanges) as PV
----

==== Making Functions Private

Making functions private is quite easy in Elm. All we have to do is not expose them. Let’s say the `isEmpty` function in the `MyList` module delegates the task of determining whether a list is empty or not to a different function, and we don’t want the world to know about this little secret. Add a new function definition below `isEmpty` in `MyList.elm` and delegate the responsibility of checking emptiness to it.

[source,elm]
----
module MyList exposing (MyList(..), isEmpty, sum)
.
.

isEmpty : MyList a -> Bool
isEmpty xs =
    isItReallyEmpty xs


isItReallyEmpty : MyList a -> Bool
isItReallyEmpty xs =
    case xs of
        Empty ->
            True

        _ ->
            False
----

`isItReallyEmpty` is a private function because it’s not added to the list of values that are exposed. Let’s try to access it anyway from `Playground.elm` to see what happens. Change the content of the `main` function to this:

[source,elm]
----
main : Html msg
main =
    MyList.isItReallyEmpty list2
        |> Debug.toString
        |> Html.text
----

If you refresh the page at http://localhost:8000/src/Playground.elm[`+http://localhost:8000/src/Playground.elm+`], Elm will point out that it doesn’t recognize what `isItReallyEmpty` is.

image:https://elmprogramming.com/images/chapter-4/4.7-easier-code-organization/is-it-really-empty-error.png[]

To get rid of the error, replace `isItReallyEmpty` with `isEmpty` in the `main` function inside `Playground.elm`.

[source,elm]
----
main : Html msg
main =
    MyList.isEmpty list2
        |> Debug.toString
        |> Html.text
----

It’s best practice to keep functions private unless you must expose them. Once they are exposed to the outside world, it can be very risky to change them. If we modify the input parameters or the return value of a function with no backward compatibility, the client code using that function could stop working. But if a function is private, we can refactor it without any fear of breaking some code out there.

If you’re worried about the list of values exposed in a module definition getting too long, don’t be. Most Elm modules expose a lengthy list of values. Here’s how the `List` module exposes its values:

[source,elm]
----
module List exposing
    ( singleton, repeat, range, (::)
    , map, indexedMap, foldl, foldr, filter, filterMap
    , length, reverse, member, all, any, maximum, minimum, sum, product
    , append, concat, concatMap, intersperse, map2, map3, map4, map5
    , sort, sortBy, sortWith
    , isEmpty, head, tail, take, drop, partition, unzip
    )
----

Unfortunately, as of this writing, `+elm-format+` pushes each exposed item into a new line when you save the file which makes the module declaration hard to read. Hopefully, that’ll change in the future.

[source,elm]
----
module List exposing
    ( (::)
    , all
    , any
    , append
    , concat
    .
    .
    )
----

==== Summary

To summarize, Elm makes it very easy to group functions, constants, type definitions, and other values together using modules. The syntax for creating and importing modules is straightforward. We can also share our modules with other programmers first by including them in a package and then publishing them through the online catalog. We’ll see more examples of custom modules in the <<elm-architecture-intro, chapter that covers the Elm Architecture>>.


[[fuzz-testing]]
=== 4.8 Fuzz Testing


In the <<easy-to-test, Easy to Test>> section, we learned how to write unit tests. A unit test runs the code under test with an input scenario, and then verifies that the output is correct. It’s important to note that a unit test runs the code _only once_. That means a single test covers only one input scenario. For example, the <<function-composition, `orGate`>> function we implemented earlier in this chapter only has four possible values in its input set, so we need four unit tests to fully verify that it behaves as expected.

[source,elm]
----
orGate : Int -> Int -> Int
orGate a b =
    Bitwise.or a b
----

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/or-gate-function-mapping.svg[]

It’s quite easy to write those four tests, but when a function’s input set is much bigger, writing unit tests to cover most input scenarios starts to become tedious. The <<function-composition, `rippleCarryAdder`>> function, for example, takes nine signals as input which creates `+2 ^ 9 = 512+` different scenarios.

[source,elm]
----
rippleCarryAdder a b carryIn =
    let
        -- Extract digits
        firstSignal =
            extractDigits a

        secondSignal =
            extractDigits b

        -- Compute sum and carry-out
        firstResult =
            fullAdder firstSignal.d3 secondSignal.d3 carryIn

        secondResult =
            fullAdder firstSignal.d2 secondSignal.d2 firstResult.carry

        thirdResult =
            fullAdder firstSignal.d1 secondSignal.d1 secondResult.carry

        finalResult =
            fullAdder firstSignal.d0 secondSignal.d0 thirdResult.carry
    in
    [ finalResult, thirdResult, secondResult, firstResult ]
        |> List.map .sum
        |> (::) finalResult.carry
        |> numberFromDigits
----

image:https://elmprogramming.com/images/chapter-4/4.5-easy-to-test/ripple-carry-adder-truth-table.svg[]

To fully verify `rippleCarryAdder`’s behavior, we need to write 512 unit tests. That’s a lot of tests. Granted, we don’t usually need 100% test coverage. We only need enough tests to reach a given level of confidence. But even if we want to achieve 50% test coverage, that’s still a lot of tests to write.

A better alternative is to use _fuzz tests_. A fuzz test runs the code under test over and over with randomly generated inputs. Before we find out how fuzz tests make it easier to test functions like `rippleCarryAdder`, let’s write a few simple fuzz tests to understand how they work.

Fuzzing::
  “The term ‘fuzzing’ originates from a 1988 class project, taught by Barton Miller at the University of Wisconsin. To fuzz test a https://en.wikipedia.org/wiki/Unix[Unix] utility meant to automatically generate random files and command-line parameters for the utility. The project was designed to test the reliability of Unix programs by executing a large number of random inputs in quick succession until they crashed.” — https://en.wikipedia.org/wiki/Fuzzing[Wikipedia]

==== A Simple Fuzz Test

Create a new file called `FuzzTests.elm` in the `+beginning-elm/tests+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/create-fuzz-tests-file.png[]

[source,elm]
----
module FuzzTests exposing (addOneTests)

import Expect exposing (Expectation)
import Fuzz exposing (..)
import Test exposing (..)


addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz int "adds 1 to any integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]


addOne : Int -> Int
addOne x =
    1 + x
----

We created a new module called `FuzzTests` and imported a bunch of other modules that enable us to write fuzz tests. We also created a function that adds `1` to a given integer. Finally, we wrote a fuzz test that verifies the `addOne` function works as expected.

****
NOTE: It’s perfectly fine to include regular functions like `addOne` that don’t test anything in a test module. Elm doesn’t make any distinction between a test module and a regular module. That said, in a real project it’s best practice to put the production code and tests in separate modules. To make things simpler, we’ll ignore that best practice in this section and include the code we want to test in the same module.
****

The following diagram explains various components of a fuzz test.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/fuzz-test-syntax.svg[]

The structure of a fuzz test looks very similar to that of a <<easy-to-test, unit test>>. There are only three differences:

*Difference #1:* A fuzz test is created using the function called `fuzz`, whereas a unit test is created using the `test` function. Both of these functions are defined in the https://package.elm-lang.org/packages/elm-explorations/test/latest/Test[`Test`] module.

*Difference #2:* `fuzz` takes three arguments whereas the `test` function takes two.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/fuzz-vs-test-function-type-1.svg[]

The first argument to `fuzz` is a fuzzer that knows how to generate values of a given type. In the above example, we used the https://package.elm-lang.org/packages/elm-explorations/test/latest/Fuzz#int[`int`] fuzzer which generates a 32-bit integer value. By default, it generates 100 values between -50 and 50. Since 0 is notorious for introducing edge cases in most code, the `int` fuzzer makes sure that 0 is one of the generated values.

The https://package.elm-lang.org/packages/elm-explorations/test/latest/Fuzz[`Fuzz`] module provides a fuzzer for commonly used built-in types. Here are some examples: `float`, `string`, `list`, and `maybe`. We can also create a fuzzer for a custom type of our own.

All fuzzers are defined in the `Fuzz` module, but the `fuzz` function itself is defined in the https://package.elm-lang.org/packages/elm-explorations/test/latest/Test[`Test`] module. That’s why we need to import both modules when we write fuzz tests.

*Difference #3:* The anonymous function that contains the fuzz test uses a real parameter (`num`) instead of an underscore (`_`) because that parameter is actually used inside the test. In a unit test, `+elm-test+` passes a unit type which is unusable. Therefore, we simply ignored it.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/fuzz-vs-test-function-type-2.svg[]

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal to execute that test in `FuzzTests.elm`. Running a fuzz test is no different than running a unit test. The output should look very similar to that of a unit test.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/running-first-fuzz-test.png[]

Reproducing a Test Result::
  You may have noticed that all test outputs we’ve seen so far contain the following text.
+
`+To reproduce these results, run: elm-test --fuzz 100 --seed <seed-value>+`
+
`+elm-test+` uses a random number generator (RNG) to create random values for each fuzzer. A RNG takes an initial value called _seed_ and uses an algorithm to generate a seemingly random number. Given an initial seed, we can always predict the values generated by a RNG, which means fuzz tests are deterministic if we know the initial seed. So if we need to reproduce the results from a specific run of a fuzz test, we can run the `+elm-test+` command with the `+--seed+` option. The `+--fuzz+` option specifies how many times a fuzz test should run.
+
We’ll cover random number generators in detail in the <<commands, Generating Random Numbers>> section in chapter 5.

==== Failing Fuzz Test

Let’s see what a failing fuzz test looks like. Replace `+++` with `-` in the `addOne` function inside `FuzzTests.elm` like this:

[source,elm]
----
addOne : Int -> Int
addOne x =
    1 - x
----

Instead of adding `x` to `1`, it now subtracts it. If you run `+elm-test tests/FuzzTests.elm+` once again from the `+beginning-elm+` directory in terminal, you should see a failing test.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/fuzz-test-failed-output.svg[]

The output looks almost exactly the same as a <<easy-to-test, failing unit test>>. There’s just one tiny difference. Also, fuzz tests fail more intelligently compared to unit tests. Let’s explore these differences by adding a unit test to `addOneTests` in `FuzzTests.elm`.

[source,elm]
----
addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz int "adds 1 to any integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        , test "when 1 is added to 2, the result is 3" <|
            \_ ->
                addOne 2 |> Expect.equal 4
        ]
----

It’s perfectly fine to combine unit and fuzz tests as we’ve done here. If you run `+elm-test tests/FuzzTests.elm+` again, you should see two failing tests.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/comparing-fuzz-and-unit-test-outputs.svg[]

Notice how the fuzz test output shows `+Given 1+`. With a unit test, we know exactly what value the test failed on just by looking at the test. We passed `2` to `addOne`, so we definitely know that the function doesn’t work if the input is `2`. However, with a fuzz test we can’t tell which value the test failed on just by looking at its implementation. `+elm-test+` runs the same fuzz test multiple times with different values. In our case, the `int` fuzzer generates a value between -50 and 50 and feeds that into the test. There is no way of knowing what that value is.

The current (incorrect) logic in the `addOne` function passes for `0`, but fails for all non-zero values. So, why did the test output report that the function logic fails for `1` instead of any other randomly chosen number? That’s because when a fuzz test fails, instead of showing us the first value the test failed on, it tries to shrink the failing input to the smallest and simplest value possible. That way it’s easier for us to investigate why the test failed.

==== Property Based Testing

The fuzz test we wrote above is equivalent to hundred unit tests because it runs the same test with hundred different input values. We can run it with even more inputs if we want. While a unit test is focused on verifying one _specific input scenario_ works correctly, a fuzz test, on the other hand, is focused on making sure an important _property_ holds true for all inputs and outputs. For example, the `addOne` function must satisfty this property: the difference between the output and input value is always exactly `1`.

Compared to unit tests, fuzz tests make it possible to test the behavior of our code on a much higher level. Instead of coming up with individual input scenarios, we can think of properties that must hold true for our code and then write fuzz tests to make sure that those properties do hold true. Because of this, writing fuzz tests could turn out to be much more challenging than writing individual unit tests especially if our code is complex. We have to think very carefully about the exact properties our code exhibits.

We should always prefer fuzz tests to unit tests because they give us the most bang for our buck. If we come across edge cases that aren’t covered by fuzz tests then it’s okay to supplement our test suite with unit tests. Otherwise, if a unit test isn’t providing additional value, we should just delete it. Speaking of which, let’s remove the unnecessary unit test from `addOneTests` in `FuzzTests.elm`.

[source,elm]
----
addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz int "adds 1 to any integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]
----

Let’s also fix the logic in `addOne` function by replacing `-` with `+++`.

[source,elm]
----
addOne : Int -> Int
addOne x =
    1 + x
----

==== Multiple Fuzzers

It’s very common for Elm functions to take multiple arguments, so knowing how to generate only one random input value isn’t enough. Luckily, `+elm-test+` makes it easy to generate multiple values. Let’s add a new function called `add` to the bottom of `FuzzTests.elm`.

[source,elm]
----
add : Int -> Int -> Int
add x y =
    x + y
----

To test this function we need to generate two random values. We can do that by using the `fuzz2` function. Add the following test to the bottom of `FuzzTests.elm`.

[source,elm]
----
addTests : Test
addTests =
    describe "add"
        [ fuzz2 int int "adds two given integers" <|
            \num1 num2 ->
                add num1 num2
                    |> Expect.equal (num1 + num2)
        ]
----

And expose `addTests` in the module definition.

[source,elm]
----
module FuzzTests exposing (addOneTests, addTests)
----

Now run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal. You should see that all tests have passed including the one we just wrote.

The `fuzz2` function is also defined in the `Test` module and works just like `fuzz`. The only difference is that it takes two fuzzers. Here’s how its type signature looks:

[source,elm]
----
fuzz2
    :  Fuzzer a
    -> Fuzzer b
    -> String
    -> (a -> b -> Expectation)
    -> Test
----

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/fuzz2-syntax.svg[]

If we need three random inputs, we can use `fuzz3`. Here’s how its type signature looks:

[source,elm]
----
fuzz3
    :  Fuzzer a
    -> Fuzzer b
    -> Fuzzer c
    -> String
    -> (a -> b -> c -> Expectation)
    -> Test
----

==== Controlling Fuzz Test Runs

Earlier we learned that, by default, each fuzz test is run hundred times with different inputs. We can control how many times a test runs by using the `fuzzWith` function, which is also defined in the `Test` module. Here’s how its type signature looks:

[source,elm]
----
fuzzWith
    :  FuzzOptions
    -> Fuzzer a
    -> String
    -> (a -> Expectation)
    -> Test


type alias FuzzOptions =
    { runs : Int }
----

Let’s rewrite the test inside `addOneTests` in `FuzzTests.elm` using `fuzzWith`.

[source,elm]
----
addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzzWith { runs = 200 } int "adds 1 to the given integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]
----

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/fuzzwith-syntax.svg[]

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal. You should see that all tests have passed. It would be nice if the test output indicated how many times a fuzz test was run. Unfortunately it doesn’t.

==== Controlling the Range of Values

By default, the `int` fuzzer generates values between -50 and 50. We can control that by using `intRange`. Let’s modify `addOneTests` in `FuzzTests.elm` one more time so that it’s explicit about the range of values to use when the test is run.

[source,elm]
----
addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz (intRange -100 100) "adds 1 to the given integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]
----

Run `+elm-test tests/FuzzTests.elm+` once again and you should see that all tests have passed. We can also tell `intRange` to pick values from the full spectrum of integers. Modify `addOneTests` in `FuzzTests.elm` one more time to this:

[source]
----
addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz (intRange minInt maxInt) "adds 1 to the given integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]
----

`maxInt` is a constant defined in the `Random` module. It represents the maximum value for randomly generated 32-bit ints: `2147483647`. `minInt` is also defined in the `Random` module and it represents the minimum value for randomly generated 32-bit ints: `+-2147483648+`. Before running the test above, we need to import `Random` in `FuzzTests.elm`.

[source,elm]
----
module FuzzTests exposing (addOneTests, addTests)
.
.
import Random exposing (maxInt, minInt)
----

Now if you run `+elm-test tests/FuzzTests.elm+` once again, you should see that all tests have passed.

==== Controlling the Frequency of Values

Here’s an experiment you can run when you see your friends, the next time. Ask each one of them to pick a random number between `1` and `10`. You’ll realize that most of them will pick `7`, and very few will pick `1`, `5`, and `10`. They also tend to pick numbers between `5` and `10` more often than the numbers between `1` and `5`.

Let’s create a fuzzer that simulates this somewhat predictable behavior of your friends. We’ll use the following probabilities for each number between `1` and `10`.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/numbers-probabilities.svg[]

Add the following code to the bottom of `FuzzTests.elm`.

[source,elm]
----
frequencyFuzzer : Fuzzer Int
frequencyFuzzer =
    frequency
        [ ( 70, constant 7 )
        , ( 12, intRange 8 9 )
        , ( 6, constant 6 )
        , ( 9, intRange 2 4 )
        , ( 1, constant 5 )
        , ( 1, constant 1 )
        , ( 1, constant 10 )
        ]
----

We used the `frequency` fuzzer to assign probabilities to values between `1` and `10` per the table above. Here is how its type signature looks:

[source]
----
frequency : List (Float, Fuzzer a) -> Fuzzer a
----

It takes a list of tuples as its only argument. The first element of that tuple represents a probabilistic weight and the second element represents an actual fuzzer responsible for generating random values. We already know what `intRange` does. The `constant` fuzzer always generates the given value no matter what.

`frequency` isn’t guaranteed to generate a valid fuzzer. If any one of the following conditions is met, it’ll return an invalid fuzzer in which case the test simply fails.

* The list of frequencies is empty.
* Any one of the weights is less than `0`.
* The sum of all weights is `0`.

Let’s rewrite `addOneTests` in `FuzzTests.elm` to use `frequencyFuzzer`.

[source,elm]
----
addOneTests : Test
addOneTests =
    describe "addOne"
        [ fuzz frequencyFuzzer "adds 1 to the given integer" <|
            \num ->
                addOne num |> Expect.equal (num + 1)
        ]
----

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

So far we’ve only covered the `int`, `intRange`, `constant`, and `frequency` fuzzers. Let’s go through some of the other fuzzers the `Fuzz` module provides for generating values of different built-in Elm types.

==== Bool Fuzzer

The `bool`fuzzer generates values of `Bool` type: `True` and `False`. Add the following code to the bottom of `FuzzTests.elm`.

[source,elm]
----
flip : Bool -> Bool
flip x =
    not x


flipTests : Test
flipTests =
    describe "flip"
        [ fuzz bool "negates the given boolean value" <|
            \value ->
                flip value |> Expect.equal (not value)
        ]
----

And expose `flipTests` in the module definition.

[source,elm]
----
module FuzzTests exposing (addOneTests, addTests, flipTests)
----

Now run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

==== Float Fuzzer

The `float` fuzzer is very similar to `int`. By default, it generates random `Float` values between `+-50+` and `50`. Since fuzz tests are especially useful for tracking down obscure bugs caused by unexpected inputs such as `0`, the `float` fuzzer makes sure to include those inputs. Add the following code to the bottom of `FuzzTests.elm`.

[source,elm]
----
multiplyFloat : Float -> Int -> Float
multiplyFloat x y =
    x * toFloat y


multiplyFloatTests : Test
multiplyFloatTests =
    describe "multiplyFloat"
        [ fuzz2 float int "multiplies given numbers" <|
            \x y ->
                multiplyFloat x y
                    |> Expect.equal (x * toFloat y)
        ]
----

And expose `multiplyFloatTests` in the module definition.

[source,elm]
----
module FuzzTests exposing
    ( addOneTests
    , addTests
    , flipTests
    , multiplyFloatTests
    )
----

`multiplyFloatTests` combines two different fuzzers: `float` and `int`. Since it’s common for Elm functions to take inputs of different types, we often end up combining different types of fuzzers in our tests.

Notice how we’ve pretty much duplicated the logic inside the `multiplyFloat` function in our test. For a simple function, we often end up copying the implementation to the test. As our function’s complexity grows, we’ll have to be more creative about defining <<fuzz-testing, properties>> we want to test instead of copying the entire function to our test module.

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see the following error.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/expect-equal-float-error.png[]

What the error is trying to say is that https://en.wikipedia.org/wiki/Floating-point_arithmetic[floating-point arithmetic], by its nature, is tricky and may introduce minor inaccuracies. Therefore, we should use the `Expect.within` function, which is better suited for verifying calculations involving floats.

****
NOTE: The output actually recommends using the `Float.within` function. It’s a typo. It meant to say `Expect.within`.
****

Let’s rewrite `multiplyFloatTests` in `FuzzTests.elm` using `Expect.within`.

[source,elm]
----
multiplyFloatTests : Test
multiplyFloatTests =
    describe "multiplyFloat"
        [ fuzz2 float int "multiplies given numbers" <|
            \x y ->
                multiplyFloat x y
                    |> Expect.within (Absolute 0.000000001) (x * toFloat y)
        ]
----

Here is how the `Expect.within` function’s type signature compares with that of `Expect.equal`.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/expect-within-vs-expect-equal-syntax.svg[]

The `FloatingPointTolerance` type is defined like this:

[source,elm]
----
type FloatingPointTolerance
    = Absolute Float
    | Relative Float
    | AbsoluteOrRelative Float Float
----

By using `+Absolute 0.000000001+` in `multiplyFloatTests`, we’re telling `+elm-test+` to pass the test as long as the actual value is within `0.000000001` of the expected value. The error message above shows that `+elm-test+` passed `0.000001` and `1` as inputs to the fuzz test inside `multiplyFloatTests`.

[source,elm]
----
Given (0.000001, 1)
----

When we multiply those two numbers the result is `0.000001` which is within the specified limit, so the test should pass. Let’s expose `FloatingPointTolerance` in `FuzzTests.elm` and run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal. You should see that all tests have passed now.

[source,elm]
----
module FuzzTests exposing
.
.
import Expect exposing (Expectation, FloatingPointTolerance(..))
----

****
NOTE: For more information on floating-point comparison, check out the https://package.elm-lang.org/packages/elm-explorations/test/latest/Expect#floating-point-comparisons[official documentation].
****

The `float` fuzzer will never produce these values defined in the https://en.wikipedia.org/wiki/IEEE_floating_point[IEEE Standard for Floating-Point Arithmetic (IEEE 754)]: `NaN`, `+-Infinity+`, and `Infinity`.

===== NaN

`NaN` stands for “not a number.” When a computation results into a floating-point value that’s unrepresentable, Elm presents us with `NaN`. Here are some examples:

[source,elm]
----
> 0 / 0
NaN : Float

> sqrt -5
NaN : Float
----

The `Basics` module defines a function called `isNaN` for checking whether the result of a computation is indeed `NaN`.

[source,elm]
----
> isNaN (0 / 0)
True : Bool

> isNaN (sqrt -5)
True : Bool
----

===== Infinity and -Infinity

`Infinity` and `+-Infinity+` represent numbers greater than any countable numbers. They aren’t just huge numbers. They’re in fact never-ending numbers. Here are some examples:

[source,elm]
----
> 1 / 0
Infinity : Float

> -1 / 0
-Infinity : Float
----

The `Basics` module also provides a function called `isInfinite` for checking whether a given computation results in infinity.

[source,elm]
----
> isInfinite (1 / 0)
True : Bool

> isInfinite (0 / 0)
False : Bool

> googol = 10 ^ 100
1.0000000000000002e+100 : number

> isInfinite googol
False : Bool
----

A https://en.wikipedia.org/wiki/Googol[Googol] is a number so big that it’s bigger than the total number of https://en.wikipedia.org/wiki/Elementary_particle[elementary particles] present in the known universe. And even that’s not considered an infinite number. Notice how `+0 / 0+` isn’t treated as `Infinity`? That’s because it’s `NaN` which is different from `Infinity`.

===== Controlling the Range of Float Values

Like `intRange`, we can also control the range of float values by using the `floatRange` fuzzer. Modify `multiplyFloatTests` in `FuzzTests.elm` so that it uses `floatRange` instead.

[source,elm]
----
multiplyFloatTests : Test
multiplyFloatTests =
    describe "multiplyFloat"
        [ fuzz2 (floatRange -1.0 1.0) int "multiplies given numbers" <|
            \x y ->
                multiplyFloat x y
                    |> Expect.within (Absolute 0.000000001) (x * toFloat y)
        ]
----

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

==== Percentage Fuzzer

The `percentage` fuzzer generates float values between `0.0` and `1.0`. It generates zero and one about 10% of the time. Add the following code to the bottom of `FuzzTests.elm`.

[source,elm]
----
pizzaLeft : Float -> Float -> Float
pizzaLeft eatenPercent totalSlices =
    totalSlices - (eatenPercent * totalSlices)


pizzaLeftTests : Test
pizzaLeftTests =
    describe "pizzaLeft"
        [ fuzz2 percentage float "returns remaining pizza slices" <|
            \eaten total ->
                pizzaLeft eaten total
                    |> Expect.within (Absolute 0.000000001) (total - (eaten * total))
        ]
----

And expose `pizzaLeftTests` in the module definition.

[source,elm]
----
module FuzzTests exposing
    .
    .
    , pizzaLeftTests
    )
----

Now run `+elm-test tests/FuzzTests.elm+` once again and you should see that all tests have passed.

==== String Fuzzer

The `string` fuzzer generates random printable https://en.wikipedia.org/wiki/ASCII[ASCII] string values consisting of up to 1000 characters. Since we often forget to handle edge cases containing the empty string, the `string` fuzzer makes sure that it’s one of the generated values.

The https://package.elm-lang.org/packages/elm-explorations/test/latest/[official documentation] for the `+elm-test+` package has a nice example that uses the `string` fuzzer. We’ll just borrow it here. Add the following tests to the bottom of `FuzzTests.elm`.

[source,elm]
----
stringTests : Test
stringTests =
    describe "The String module"
        [ describe "String.reverse"
            [ test "has no effect on a palindrome" <|
                -- Unit Test - 1
                \_ ->
                    let
                        palindrome =
                            "hannah"
                    in
                    palindrome
                        |> String.reverse
                        |> Expect.equal palindrome
            , test "reverses a known string" <|
                -- Unit Test - 2
                \_ ->
                    "ABCDEFG"
                        |> String.reverse
                        |> Expect.equal "GFEDCBA"
            , fuzz string "restores the original string if you run it again" <|
                -- Fuzz Test
                \randomlyGeneratedString ->
                    randomlyGeneratedString
                        |> String.reverse
                        |> String.reverse
                        |> Expect.equal randomlyGeneratedString
            ]
        ]
----

And expose `stringTests` in the module definition.

[source,elm]
----
module FuzzTests exposing
    .
    .
    , stringTests
    )
----

Notice how `stringTests` supplements a fuzz test with two unit tests. The first unit test verifies that an edge case for reversing a palindrome works as expected. The second unit test makes it clear what the `String.reverse` function does. Unit tests like these can provide a good documentation of how our code should behave and prevent regressions.

Regression::
  _“The reappearance of a bug in a piece of software that had previously been fixed.” - https://en.wiktionary.org/wiki/regression[Wikitionary]_

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

==== List Fuzzer

The `list` fuzzer generates a list of random values of given type. Let’s say we want to verify that the <<list, `List.length`>> function never returns a negative value. Add the following test to the bottom of `FuzzTests.elm`.

[source,elm]
----
listLengthTests : Test
listLengthTests =
    describe "List.length"
        [ fuzz (list int) "never returns a negative value" <|
            \intList ->
                intList
                    |> List.length
                    |> Expect.atLeast 0
        ]
----

And expose `listLengthTests` in the module definition.

[source,elm]
----
module FuzzTests exposing
    .
    .
    , listLengthTests
    )
----

This is the first time we’ve seen a fuzzer that takes another fuzzer as an argument. Let’s look at the `list` fuzzer’s type signature to understand how it works.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/list-fuzzer-type-signature.svg[]

Like `intRange` and `floatRange`, the `list` fuzzer and its argument must be surrounded by parentheses. Otherwise, Elm thinks we’re passing two different fuzzers to the `fuzz` function which takes only one. Although `list` and `int` are two different types of fuzzers, the expression `+(list int)+` returns just one.

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

==== Array Fuzzer

Like `list`, the `array` fuzzer generates an array of random values of given type. It’s type signature also looks very similar to that of `list`.

[source]
----
array : Fuzzer a -> Fuzzer (Array a)
----

Let’s write a test to verify the <<array, `Array.get`>> function always returns `Nothing` when we access an index that’s out of range. Add the following test to the bottom of `FuzzTests.elm`.

[source,elm]
----
arrayGetTests : Test
arrayGetTests =
    describe "Array.get"
        [ fuzz (array (intRange -20 20)) "returns Nothing for out of range index" <|
            \intArray ->
                let
                    length =
                        Array.length intArray
                in
                intArray
                    |> Array.get length
                    |> Expect.equal Nothing
        ]
----

And expose `arrayGetTests` in the module definition. Also import the `Array` module.

[source,elm]
----
module FuzzTests exposing
    .
    .
    , arrayGetTests
    )
.
.
import Array
----

Run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

We asked the `array` fuzzer to generate random arrays of ints between `+-20+` and `20`. We then computed the generated array’s length and used it as an index. When we use the length as an index, it’s guaranteed to be out of range because in Elm the array indices start at `0`. Run `+elm repl+` from the `+beginning-elm+` directory and execute the following code.

[source,elm]
----
> import Array

> myArray = Array.fromList [ 1, 2, 3 ]
Array.fromList [1,2,3]
    : Array.Array number

> Array.get 2 myArray
Just 3 : Maybe number

> length = Array.length myArray
3 : Int

> Array.get length myArray
Nothing : Maybe number
----

==== Tuple Fuzzer

The `tuple` fuzzer generates a tuple of random values of given types. Let’s examine its type signature to understand how it works.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/tuple-fuzzer-type-signature.svg[]

The `tuple` fuzzer takes a _tuple_ of two individual fuzzers as the first argument. If it were to accept the two fuzzers as separate arguments, its type signature would instead be this:

[source]
----
tuple : Fuzzer a -> Fuzzer b -> Fuzzer (a, b)
----

Modify `addTests` in `FuzzTests.elm` to use the `tuple` fuzzer.

[source,elm]
----
addTests : Test
addTests =
    describe "add"
        [ fuzz (tuple ( int, int )) "adds two given integers" <|
            \( num1, num2 ) ->
                add num1 num2
                    |> Expect.equal (num1 + num2)
        ]
----

Here’s how `addTests` looked before:

[source,elm]
----
addTests : Test
addTests =
    describe "add"
        [ fuzz2 int int "adds two given integers" <|
            \num1 num2 ->
                add num1 num2
                    |> Expect.equal (num1 + num2)
        ]
----

The previous version looked a bit cleaner, didn’t it? That’s because `fuzz2` is a convenience function for writing tests that use `tuple` fuzzers in a more elegant way. Let’s write one more test for revealing the ugliness inherent in the `tuple` fuzzer. Add the following test to the bottom of `FuzzTests.elm`.

[source,elm]
----
listReverseTests : Test
listReverseTests =
    describe "List.reverse"
        [ fuzz (tuple ( (list int), int )) "doesn't remove a member of the list" <|
            \( intList, num ) ->
                intList
                    |> List.reverse
                    |> List.member num
                    |> Expect.equal (List.member num intList)
        ]
----

This test verifies that the `List.reverse` function doesn’t remove a member of the list. Look how confusing the part after `fuzz` looks with all those parentheses. We can make it easier to read by using `fuzz2` instead.

[source,elm]
----
listReverseTests : Test
listReverseTests =
    describe "List.reverse"
        [ fuzz2 (list int) int "doesn't remove a member of the list" <|
            \intList num ->
                intList
                    |> List.reverse
                    |> List.member num
                    |> Expect.equal (List.member num intList)
        ]
----

Expose `listReverseTests` in the module definition.

[source,elm]
----
module FuzzTests exposing
    .
    .
    , listReverseTests
    )
----

Now run `+elm-test tests/FuzzTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed. As it turns out, the `fuzz3` function we saw earlier is also a convenience function like `fuzz2` for simplifying the tupple fuzzer syntax.

[source,elm]
----
fuzz3 :
    Fuzzer a
    -> Fuzzer b
    -> Fuzzer c
    -> String
    -> (a -> b -> c -> Expectation)
    -> Test


tuple3
    : (Fuzzer a, Fuzzer b, Fuzzer c)
    -> Fuzzer (a, b, c)
----

[[exercise-481]]
==== Exercise 4.8.1

In the <<type-system, Recursive Types>> section, we wrote a function for computing the sum of all the nodes contained in a list of type `MyList`.

[source,elm]
----
sum : MyList Int -> Int
sum myList =
    case myList of
        Empty ->
            0

        Node intValue remainingNodes ->
            intValue + sum remainingNodes
----

See if you can verify that this function works as expected by writing some fuzz tests.

==== Testing `rippleCarryAdder`

Now that we know how fuzz testing works, let’s turn our attention to the <<function-composition, `rippleCarryAdder`>> function. Back in the <<easy-to-test, Easy to Test>> section, we wrote four unit tests that covered the boundary cases and one more test to communicate what `rippleCarryAdder` actually does.

[source,elm]
----
rippleCarryAdderTests : Test
rippleCarryAdderTests =
    describe "4-bit ripple carry adder"
        [ describe "given two binary numbers and a carry-in digit"
            [ test "returns the sum of those numbers and a carry-out digit" <|
                \_ ->
                    rippleCarryAdder 1001 1101 1
                        |> Expect.equal 10111
            ]
        , describe "when the 1st input is 1111, and the 2nd input is 1111"
            [ test "and carry-in is 0, the output is 11110" <|
                \_ ->
                    rippleCarryAdder 1111 1111 0
                        |> Expect.equal 11110
            , test "and carry-in is 1, the output is 11111" <|
                \_ ->
                    rippleCarryAdder 1111 1111 1
                        |> Expect.equal 11111
            ]
        , describe "when the 1st input is 0000, and the 2nd input is 0000"
            [ test "and carry-in is 0, the output is 0000" <|
                \_ ->
                    rippleCarryAdder 0 0 0
                        |> Expect.equal 0
            , test "and carry-in is 1, the output is 0001" <|
                \_ ->
                    rippleCarryAdder 0 0 1
                        |> Expect.equal 1
            ]
        ]
----

As mentioned earlier, the `rippleCarryAdder` function has nine input signals which result into `+2 ^ 9 = 512+` different input scenarios. In the <<easy-to-test, Easy to Test>> section, we quickly realized that it wasn’t feasible to use unit tests to cover all of those scenarios. How about fuzz tests? Let’s see what they look like.

[source,elm]
----
rippleCarryAdderFuzzTests : Test
rippleCarryAdderFuzzTests =
    describe "Fuzz tests"
        [ fuzz3
            (intRange 0 1111)
            (intRange 0 1111)
            (intRange 0 1)
            "fuzz tests for ripple carry adder" <|
            \a b carryIn ->
                rippleCarryAdder a b carryIn
                    |> Expect.equal ...
        ]
----

The code above shows a rough outline of a fuzz test that attempts to cover all `512` scenarios, but it quickly runs into a big problem: How to test the `rippleCarryAdder` function without duplicating the logic in its entirely?

So far we’ve used fuzz tests to verify trivial functions by duplicating the logic in tests. It doesn’t make sense to do the same with the `rippleCarryAdder` function. We need to step back and ask ourselves what our goal here is. It certainly isn’t to test every single input scenario. We should instead think of general properties our function satisfies and use fuzz tests to verify that those properties do hold true for a wide variety of inputs.

****
*Quote:* _“Being proud of 100% test coverage is like being proud of reading every word in the newspaper. Some are more important than others.” - https://twitter.com/kentbeck/status/812703192437981184?lang=en[Kent Beck]_
****

Listed below are some of the properties we can test for `rippleCarryAdder`.

*Property #1:* If the most significant digits of both inputs are `0`, the carry-out digit will always be `0` regardless of what the carry-in digit is.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/most-significant-digits-as-zero.svg[]

*Property #2:* If the most significant digits of both inputs are `1`, the carry-out digit will always be `1` regardless of what the carry-in digit is.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/most-significant-digits-as-one.svg[]

*Property #3:* If the least significant digits of both inputs are `0` and the carry-in digit is also `0`, the least significant digit of the output will always be `0`.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/least-significant-digits-as-zero.svg[]

*Property #4:* If the least significant digits of both inputs are `1` and the carry-in digit is `0`, the least significant digit will always be `0`.

image:https://elmprogramming.com/images/chapter-4/4.8-fuzz-testing/least-significant-digits-as-one.svg[]

==== Testing Property #1

Let’s begin our testing with property #1. Add the following test to the bottom of `RippleCarryAdderTests.elm` located inside `+beginning-elm/tests+`.

[source,elm]
----
rippleCarryAdderProperty1 : Test
rippleCarryAdderProperty1 =
    describe "carry-out's relationship with most significant digits"
        [ fuzz3
            (list (intRange 0 1))
            (list (intRange 0 1))
            (intRange 0 1)
            "carry-out is 0 when most significant digits are both 0" <|
            \list1 list2 carryIn ->
                let
                    convertToBinary digitsList =
                        digitsList
                            |> List.take 3
                            |> numberFromDigits

                    firstInput =
                        convertToBinary list1

                    secondInput =
                        convertToBinary list2
                in
                rippleCarryAdder firstInput secondInput carryIn
                    |> digits
                    |> List.length
                    |> Expect.lessThan 5
        ]
----

And expose `rippleCarryAdderProperty1` in the module definition.

[source,elm]
----
module RippleCarryAdderTests exposing
    .
    .
    , rippleCarryAdderProperty1
    )
----

===== Generating Input Values

As of this writing, Elm doesn’t provide a fuzzer for generating binary numbers. We could write a custom fuzzer for that, but that’s an advanced topic requiring a lot of explaining. We’ll instead settle for generating a list of binary digits and turn them into a binary number. Here are some examples of the lists generated by the `+(list (intRange 0 1))+` fuzzer:

[source,elm]
----
[ ]
[ 0 ]
[ 1 ]
[ 0, 1]
[ 1, 0, 1]
[ 1, 1, 0, 1, 1]
[ 1, 0, 1, 1, 1, 0, 1]
.
.
----

We then use the `convertToBinary` function to convert these lists into binary numbers.

[source,elm]
----
convertToBinary digitsList =
    digitsList
        |> List.take 3
        |> numberFromDigits
----

The `rippleCarryAdder` function takes binary numbers that have at most four digits.

[source,elm]
----
> rippleCarryAdder 1001 1100 0
10101
----

Unfortunately, there’s no easy way to limit the length of lists generated by `+(list (intRange 0 1))+` to four. But we can use the <<list, `List.take`>> function to extract the first four elements from a list.

In the `convertToBinary` function, we’re actually extracting only three because property #1 requires the most significant digits of both input numbers to be `0` and `rippleCarryAdder` treats a list with only three elements as a binary number with four digits whose most significant digit is `0`. So `+[ 1, 0, 1 ]+` is equivalent to `0101`.

Next we use the `numberFromDigits` function to convert a list of digits into an actual binary number.

[source,elm]
----
numberFromDigits : List Int -> Int
numberFromDigits digitsList =
    List.foldl (\digit number -> digit + 10 * number) 0 digitsList
----

We wrote this function back in the <<function-composition, Solving Complex Problems with Simple Functions>> section. If you don’t remember how it works, go ahead and refresh your memory by re-reading that section. To be able to access `numberFromDigits` from `RippleCarryAdderTests.elm`, we need to first expose it in `+src/RippleCarryAdder.elm+`. Let’s do that.

[source,elm]
----
module RippleCarryAdder exposing
    .
    .
    , numberFromDigits
    )
----

As far as generating the carry-in digit is concerned, all we need is the `intRange` fuzzer with a range from `0` to `1` because the carry-in digit can only be either `0` or `1`.

===== Private Functions

It’s generally a bad practice to reach into private functions such as `numberFromDigits` from our tests. At the moment, it’s technically a public function because we just exposed it from the `RippleCarryAdder` module. Ideally, we should only expose functions that are meant to be public, but how do we know which functions should be public and which ones should be private?

The `RippleCarryAdder` module contains a dozen functions, but if we look closely we realize that there’s only one function that’s responsible for computing a sum of two 4-bit binary numbers, and that function is `rippleCarryAdder`. All other functions are there to assist `rippleCarryAdder`. Therefore, the `rippleCarryAdder` function is the only one that needs to be public.

One obvious question is, why do we need to split the functionality into multiple functions as we’ve done in the `RippleCarryAdder` module? Can’t we consolidate all helper functions into `rippleCarryAdder` since it’s the only function the outside world cares about anyway?

The answer to that question is, creating one giant function that does everything turns out to be quite hard to maintain in the long run. It’s difficult to figure out what the function is supposed to do when it’s that big. Just take a look at the following code that attempts to consolidate all helper functions into `rippleCarryAdder`.

[source,elm]
----
rippleCarryAdder a b carryIn =
    let
        halfAdder a b =
            let
                d =
                    Bitwise.and a b

                e =
                    Bitwise.or a b
                        |> (case a of
                                0 ->
                                    1

                                1 ->
                                    0

                                _ ->
                                    -1
                           )

                sumDigit =
                    Bitwise.and d e

                carryOut =
                    Bitwise.and a b
            in
            { carry = carryOut
            , sum = sumDigit
            }

        fullAdder a b carryIn =
            let
                firstResult =
                    halfAdder b carryIn

                secondResult =
                    halfAdder a firstResult.sum

                finalCarry =
                    orGate firstResult.carry secondResult.carry
            in
            { carry = finalCarry
            , sum = secondResult.sum
            }

        extractDigits number =
            digits number
                |> padZeros 4
                |> Array.fromList
                |> arrayToRecord

        stringToInt string =
            String.toInt string
                |> Maybe.withDefault -1

        arrayToRecord array =
            let
                firstElement =
                    Array.get 0 array
                        |> Maybe.withDefault -1

                secondElement =
                    Array.get 1 array
                        |> Maybe.withDefault -1

                thirdElement =
                    Array.get 2 array
                        |> Maybe.withDefault -1

                fourthElement =
                    Array.get 3 array
                        |> Maybe.withDefault -1
            in
            { d0 = firstElement
            , d1 = secondElement
            , d2 = thirdElement
            , d3 = fourthElement
            }

        numberFromDigits digitsList =
            List.foldl (\digit number -> digit + 10 * number) 0 digitsList

        digits number =
            let
                getDigits n =
                    if n == 0 then
                        []

                    else
                        remainderBy 10 n :: getDigits (n // 10)
            in
            getDigits number
                |> List.reverse

        padZeros total list =
            let
                numberOfZeros =
                    total - List.length list
            in
            List.repeat numberOfZeros 0 ++ list

        -- Extract digits
        firstSignal =
            extractDigits a

        secondSignal =
            extractDigits b

        -- Compute sum and carry-out
        firstResult =
            fullAdder firstSignal.d3 secondSignal.d3 carryIn

        secondResult =
            fullAdder firstSignal.d2 secondSignal.d2 firstResult.carry

        thirdResult =
            fullAdder firstSignal.d1 secondSignal.d1 secondResult.carry

        finalResult =
            fullAdder firstSignal.d0 secondSignal.d0 thirdResult.carry
    in
    [ finalResult, thirdResult, secondResult, firstResult ]
        |> List.map .sum
        |> (::) finalResult.carry
        |> numberFromDigits
----

Someone who is reading this code for the first time will find it quite difficult to understand how the `rippleCarryAdder` function is supposed to work. There’s too much going on. But, if we extract a few functions out, give them proper names, and add a little structure to the overall code, it becomes much easier to capture the intent of the `rippleCarryAdder` function in just eighteen lines as shown below.

[source,elm]
----
rippleCarryAdder a b carryIn =
    let
        -- Extract digits
        firstSignal =
            extractDigits a

        secondSignal =
            extractDigits b

        -- Compute sum and carry-out
        firstResult =
            fullAdder firstSignal.d3 secondSignal.d3 carryIn

        secondResult =
            fullAdder firstSignal.d2 secondSignal.d2 firstResult.carry

        thirdResult =
            fullAdder firstSignal.d1 secondSignal.d1 secondResult.carry

        finalResult =
            fullAdder firstSignal.d0 secondSignal.d0 thirdResult.carry
    in
    [ finalResult, thirdResult, secondResult, firstResult ]
        |> List.map .sum
        |> (::) finalResult.carry
        |> numberFromDigits
----

Another maintenance problem big functions create is lack of reusability. Big functions tend to do too many things. This makes it hard to reuse the logic inside them somewhere else in the module. This results in code duplication which is also bad.

Now that we know why we shouldn’t write long functions, let’s get back to the previous discussion of which functions should be public and which ones should be private.

Generally speaking, helper functions that are used only inside the module they are defined in should be made private. If we follow that guideline, the `andGate`, `orGate`, `inverter`, `halfAdder`, and `fullAdder` functions should also be private and we won’t be able to access them from our tests included in the `RippleCarryAdderTests.elm` file. We wrote those tests as a learning exercise, but in a real project, it’s not necessary to test private functions like `andGate` for two reasons:

* First, they are hidden inside public functions and their results cannot be seen by the code outside of the module they are defined in. Private functions are invoked by public functions that should already have tests. So if we do introduce a bug in a private function, it should be caught by one of the public functions’ tests.
* Second, private functions tend to be more unstable compared to public functions. Once a function is made public, it can be very risky to change it. If we modify its interface, the client code using that function could stop working. That’s why we need to make public functions as stable as possible. But if a function is private, we don’t have to put a lot of effort into refining its interface. We can always come back and refactor it without the fear of breaking some code out there. Because of this, private functions tend to change a lot more than public functions. So if we write tests for a private function, we might have to change those tests every time that function’s structure has changed even if the underlying behavior hasn’t.

Since you already know how to make functions private in Elm from the <<easier-code-organization, Easier Code Organization>> section, making the `numberFromDigits` function private is left as an exercise. If you do end up making `numberFromDigits` private, you won’t be able to access it from the `RippleCarryAdderTests` module.

You can solve this problem either by copying the function into the test module itself or by creating a new module that’s shared between `RippleCarryAdder` and `RippleCarryAdderTests`. It’s fine to duplicate a function or two from the production code into a test file. But if you need to reuse multiple functions, the latter approach is better from maintenance standpoint.

===== Verifying Output

Now that we’ve successfully generated and transformed the inputs required by property #1, let’s discuss the output.

[source,elm]
----
rippleCarryAdder firstInput secondInput carryIn
    |> digits
    |> List.length
    |> Expect.lessThan 5
----

Property #1 requires that the carry-out digit must be `0`. To verify this requirement, we need to make sure that there are only four digits in the output generated by the `rippleCarryAdder` function. That’s because if the carry-out digit is `0`, `rippleCarryAdder` returns a binary number with only four digits.

[source,elm]
----
> rippleCarryAdder 1001 0011 0
1100
----

But if the carry-out digit is `1`, it returns a binary number with five digits.

[source,elm]
----
> rippleCarryAdder 1101 1110 0
11011
----

To find out how many digits are in a number, we need to first convert it to a list. The `digits` function does exactly that.

[source,elm]
----
digits number =
    let
        getDigits n =
            if n == 0 then
                []

            else
                remainderBy 10 n :: getDigits (n // 10)
    in
    getDigits number
        |> List.reverse
----

This function was also created back in the <<function-composition, Solving Complex Problems with Simple Functions>> section. Finally, we used `Expect.equal` to assert that the length of the output list containing individual digits is less than `5`.

To execute the tests in `rippleCarryAdderProperty1`, run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal. All tests should pass.

[[exercise-482]]
==== Exercise 4.8.2

Property #2 is very similar to property #1. See if you can write a fuzz test to make sure it too holds true for a wide variety of inputs.

==== Testing Property #3

Next, we’ll verify property #3 also holds true. Here is what that property says: if the least significant digits of both inputs are `0` and the carry-in digit is also `0`, the least significant digit of the output will always be `0`. Add the following test to the bottom of `RippleCarryAdderTests.elm`.

[source,elm]
----
rippleCarryAdderProperty3 : Test
rippleCarryAdderProperty3 =
    describe "carry-in's relationship with least significant digits"
        [ fuzz3
            (list (intRange 0 1))
            (list (intRange 0 1))
            (constant 0)
            """
            the least significant digit of the output is 0 when the
            carry-in is 0 and the least significant digits of both
            inputs are 0
            """ <|
            \list1 list2 carryIn ->
                let
                    firstInput =
                        convertToBinary list1

                    secondInput =
                        convertToBinary list2

                    convertToBinary digitsList =
                        digitsList
                            |> List.take 4
                            |> setLastDigitToZero
                            |> numberFromDigits

                    setLastDigitToZero digitsList =
                        Array.fromList digitsList
                            |> Array.set (lastIndex digitsList) 0
                            |> Array.toList

                    lastIndex digitsList =
                        List.length digitsList - 1

                    isLastDigitZero digitsList =
                        Array.fromList digitsList
                            |> Array.get (lastIndex digitsList)
                            |> Maybe.withDefault 0
                            |> (==) 0
                in
                rippleCarryAdder firstInput secondInput carryIn
                    |> digits
                    |> isLastDigitZero
                    |> Expect.equal True
        ]
----

And expose `rippleCarryAdderProperty3` in the module definition.

[source,elm]
----
module RippleCarryAdderTests exposing
    .
    .
    , rippleCarryAdderProperty3
    )
----

The `+(list (intRange 0 1))+` fuzzer used here for generating random lists of binary digits is the same as the one used in `rippleCarryAdderProperty1`. Since this property is a bit more complicated than property #1, we need to apply a few more transformations before we arrive at the inputs we need.

The `convertToBinary` function extracts four digits from a random list; sets the last digit to zero; and converts the list of digits into a binary number.

[source,elm]
----
convertToBinary digitsList =
    digitsList
        |> List.take 4
        |> setLastDigitToZero
        |> numberFromDigits
----

We used the `constant` fuzzer to make sure that the carry-in digit is always `0`. This fuzzer generates only the specified value no matter what. Also, this is the first time we used a <<string, multi-line string>> to describe a test. Generally speaking, you should keep the description short, but don’t hesitate to use more words if you can’t distill the essence of your test into a short sentence.

Finally, to verify the output, we converted the binary number into a list of digits and checked whether the last digit is `0` or not.

[source,elm]
----
rippleCarryAdder firstInput secondInput carryIn
    |> digits
    |> isLastDigitZero
    |> Expect.equal True
----

Before we can run the tests in `rippleCarryAdderProperty3`, we need to import the `Array` module in `RippleCarryAdderTests.elm`.

[source,elm]
----
module RippleCarryAdderTests exposing
.
.
import Array
----

Now run `+elm-test tests/RippleCarryAdderTests.elm+` from the `+beginning-elm+` directory in terminal and you should see that all tests have passed.

[[exercise-483]]
==== Exercise 4.8.3

Property #4 is also very similar to property #3. See if you can write a fuzz test to verify the `rippleCarryAdder` function exhibits that property.

==== Summary

We covered quite a bit of ground — from learning how to write simple fuzz tests to verifying general properties of a complex function. Don’t worry if you aren’t yet comfortable figuring out which properties to test for in your code.

Identifying properties for testing is quite hard, even for experienced programmers. That’s why fuzz tests are generally more difficult to write than unit tests, especially if a function logic is complex. Identifying a few individual input scenarios isn’t enough. We need to think hard about the properties that must hold true for a wide variety of inputs. The only way to get better at it is through practice. So next time you write some code of your own, try to identify a few properties and use fuzz tests to verify that your code does satisfy them.

The `Fuzz` module contains a lot more fuzzers than what we covered in this section. You can learn all about them https://package.elm-lang.org/packages/elm-explorations/test/latest/Fuzz[here].


[[pattern-matching]]
=== 4.9 Pattern Matching


Pattern matching is the act of checking one or more inputs against a pre-defined pattern and seeing if they match. In Elm, there’s only a fixed set of patterns we can match against, so pattern matching has limited application. However, it’s still an important feature of the language. In this section, we’ll go through a few examples of pattern matching to understand how it works in Elm.

==== Pattern Matching in Case Expression

The `case` expression works by matching an expression to a pattern. When a match is found, it evaluates the expression to the right of `+->+` and returns whatever value is produced. We saw a simple example of pattern matching in the <<case-expression, Case Expression>> section.

[source,elm]
----
weekday dayInNumber =
    case dayInNumber of
        0 ->
            "Sunday"

        1 ->
            "Monday"

        2 ->
            "Tuesday"

        3 ->
            "Wednesday"

        4 ->
            "Thursday"

        5 ->
            "Friday"

        6 ->
            "Saturday"

        _ ->
            "Unknown day"
----

In this example, `dayInNumber` is the expression and the pattern is the numbers `0` through `6`, with a catchall `_` at the end. Here’s a slightly more complex example:

[source,elm]
----
map2 : (a -> b -> value) -> Result x a -> Result x b -> Result x value
map2 func ra rb =
    case ( ra, rb ) of
        ( Ok a, Ok b ) ->
            Ok (func a b)

        ( Err x, _ ) ->
            Err x

        ( _, Err x ) ->
            Err x
----

The code above shows the implementation of the https://package.elm-lang.org/packages/elm/core/latest/Result#map2[`Result.map2`] function which accepts three arguments: a function and two results. The `map2` function uses the `case` expression to determine what to do based on what’s inside the result arguments.

*Case #1:* If both results are `Ok`, it applies the function to the payloads contained inside each `Ok`.

[source,elm]
----
> import Json.Decode exposing (decodeString, int)

> Result.map2 (*) (decodeString int "2") (decodeString int "3")
Ok 6 : Result Json.Decode.Error Int
----

*Case #2:* If the first result contains `Err`, the second result gets ignored through the use of `_` and the `Err` from the first result gets returned.

[source,elm]
----
> Result.map2 (*) (decodeString int "y") (decodeString int "3")
Err (Failure ("This is not valid JSON! Unexpected token y in JSON at position 0")  <internals>)
    : Result Json.Decode.Error Int
----

*Case #3:* If the second result contains `Err`, the first result gets ignored, and the `Err` from the second result gets returned.

[source,elm]
----
> Result.map2 (*) (decodeString int "2") (decodeString int "i")
Err (Failure ("This is not valid JSON! Unexpected token i in JSON at position 0") <internals>)
    : Result Json.Decode.Error Int
----

Elm allows us to reach into a data structure and match patterns directly instead of writing nested `if` and `case` expressions to get to the values. This enables us to write compact yet readable code.

Learning From The Standard Library::
  One of the best ways to learn Elm is to read Elm’s standard library. A large portion of the code contained in the standard library is written in Elm. It’s good code written by experienced programmers some of whom were responsible for creating Elm itself.
+
Just https://package.elm-lang.org/packages/elm/core/latest/[pick a module] you like and browse through some of the functions, types, and values listed in that module. After that, head on over to https://github.com/elm/core/tree/1.0.2[Github] and look for the filename that contains the code for the module you’re interested in. For example, the code for the `List` module is in `+src/List.elm+`, and the code for `Maybe` is in `+src/Maybe.elm+`. Once you’re in the right file, search for the value you’re looking for and try to understand how it’s implemented.

===== Using Tuples To Pattern Match in Case Expression

One of the reasons the implementation of the `map2` function is so compact is because Elm allows us to use tuples to match complex patterns in a `case` expression. If the `map2` function didn’t use a tuple in the `case` expression above, here is what its implementation would look:

[source,elm]
----
map2 : (a -> b -> value) -> Result x a -> Result x b -> Result x value
map2 func ra rb =
    case ra of
        Ok a ->
            case rb of
                Ok b ->
                    Ok (func a b)

                Err x ->
                    Err x

        Err x ->
            Err x
----

The code above isn’t easy to understand due to too much nesting. In contrast, the implementation with tuples we saw earlier is much easier to read. Unfortunately, Elm doesn’t allow more than three elements in a tuple. Otherwise, we would have been able to write code like this:

[source,elm]
----
map5 :
    (a -> b -> c -> d -> e -> value)
    -> Result x a
    -> Result x b
    -> Result x c
    -> Result x d
    -> Result x e
    -> Result x value
map5 func ra rb rc rd re =
    case ( ra, rb, rc, rd, re ) of
        ( Ok a, Ok b, Ok c, Ok d, Ok e ) ->
            Ok (func a b c d e)

        ( Err x, _, _, _, _ ) ->
            Err x

        ( _, Err x, _, _, _ ) ->
            Err x

        ( _, _, Err x, _, _ ) ->
            Err x

        ( _, _, _, Err x, _ ) ->
            Err x

        ( _, _, _, _, Err x ) ->
            Err x
----

The code above is a fictitious implementation of https://package.elm-lang.org/packages/elm/core/latest/Result#map5[`Result.map5`] which takes a function and five results as arguments. Since we can’t put more than three elements in a tuple, the actual implementation of that function looks something like this:

[source,elm]
----
map5 :
    (a -> b -> c -> d -> e -> value)
    -> Result x a
    -> Result x b
    -> Result x c
    -> Result x d
    -> Result x e
    -> Result x value
map5 func ra rb rc rd re =
    case ra of
        Err x ->
            Err x

        Ok a ->
            case rb of
                Err x ->
                    Err x

                Ok b ->
                    case rc of
                        Err x ->
                            Err x

                        Ok c ->
                            case rd of
                                Err x ->
                                    Err x

                                Ok d ->
                                    case re of
                                        Err x ->
                                            Err x

                                        Ok e ->
                                            Ok (func a b c d e)
----

It’s not as easy to read as the previous implementation. Here’s an example of how to use `map5`, in case you are curious:

[source,elm]
----
resultMap5Example : Result Json.Decode.Error Int
resultMap5Example =
    Result.map5 addFiveNumbers
        (decodeString int "1")
        (decodeString int "2")
        (decodeString int "3")
        (decodeString int "4")
        (decodeString int "5")


addFiveNumbers : Int -> Int -> Int -> Int -> Int -> Int
addFiveNumbers a b c d e =
    a + b + c + d + e
----

Add that code right above `main` in the `Playground.elm` file located in `+beginning-elm/src+`. After that import the `Json.Decode` module and expose `resultMap5Example` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .    
    , resultMap5Example
    )
.
.
import Json.Decode exposing (decodeString, int)
----

Now enter the following code in `+elm repl+`.

[source,elm]
----
> import Playground exposing (..)

> resultMap5Example
Ok 15 : Result Json.Decode.Error Int
----

===== Pattern Matching Can’t Do Computation

It’s important to realize that pattern matching can only look at the structure of data. It can’t do any computation on the data itself. In the <<case-expression, Case Expression>> section, we tried to rewrite the following `if` expression with `case`.

[source,elm]
----
escapeEarth myVelocity mySpeed =
    if myVelocity > 11.186 then
        "Godspeed"

    else if mySpeed == 7.67 then
        "Stay in orbit"

    else
        "Come back"
----

[source,elm]
----
escapeEarthWithCase myVelocity mySpeed =
    case (myVelocity, mySpeed) of
        (myVelocity > 11.186) ->
            "Godspeed"

        (mySpeed == 7.67) ->
            "Stay in orbit"

        _ ->
            "Come back"
----

When we ran the `escapeEarthWithCase` function we received the following error.

image:https://elmprogramming.com/images/chapter-3/3.12-case-expression/case-if-expression-error.png[]

We received a syntax error because we tried to perform computations on `myVelocity` and `mySpeed` while matching patterns. Elm doesn’t allow that. If we do need to perform computations before matching patterns, we can do so inside a `let` expression.

[source,elm]
----
escapeEarthWithCase : Float -> Float -> String
escapeEarthWithCase myVelocity mySpeed =
    let
        escapeVelocity =
            myVelocity > 11.186

        orbitalSpeed =
            mySpeed == 7.67
    in
        case ( escapeVelocity, orbitalSpeed ) of
            ( True, _ ) ->
                "Godspeed"

            ( _, True ) ->
                "Stay in orbit"

            _ ->
                "Come back"
----

==== Pattern Matching Lists

Pattern matching could be used to reach into values contained inside almost any data structure. Let’s explore how we can take advantage of it to simplify code that involve list manipulation. In the <<easier-code-organization, Creating a Module>> section, we saw how the `List` module implements the `isEmpty` function.

[source,elm]
----
isEmpty : List a -> Bool
isEmpty xs =
    case xs of
        [] ->
            True

        _ ->
            False
----

The `case` expression uses `+[]+` to match an empty list. When pattern matching a list, you’ll often see `x` being used to match a single element and `xs` to match several. The reason behind that is, `x` is a common variable name in mathematics and `xs` is treated as the plural form of `x`. Here’s a slightly more complex example of pattern matching in a list:

[source,elm]
----
foldl : (a -> b -> b) -> b -> List a -> b
foldl func acc list =
    case list of
        [] ->
            acc

        x :: xs ->
            foldl func (func x acc) xs
----

The code above is the implementation of the `foldl` function we went through in the <<list, List>> section. `foldl` extracts the first element from a given list, adds it to the accumulator, and applies itself <<function-composition, recursively>> to the remaining items in the list. Eventually, the list runs out of items. When that happens it simply returns the accumulator. It then starts accumulating results from each invocation. Let’s use an example to further explore the above implementation.

[source,elm]
----
> List.foldl (+) 0 [ 1, 2, 3, 4 ]
10 : number
----

We used `foldl` to compute the sum of all elements in a list. Like any other recursive function, `foldl` exhibits <<function-composition, three important characteristics>>:

*#1 Reducing the problem:* `foldl` reduces the original problem to smaller sub-problems by taking the first element out from the given list.

[source,elm]
----
x :: xs
----

This is the part we’re most interested in as far as pattern matching is concerned.

image:https://elmprogramming.com/images/chapter-4/4.9-pattern-matching/list-pattern-matching.svg[]

Behind the scenes, the `+[ 1, 2, 3, 4 ]+` list is constructed like this:

[source,elm]
----
> 4 :: []
[4] : List number

> 3 :: [ 4 ]
[3,4] : List number

> 2 :: [ 3, 4 ]
[2,3,4] : List number

> 1 :: [ 2, 3, 4 ]
[1,2,3,4] : List number
----

That’s why we’re able to pattern match a list using the cons (`+::+`) operator.

*#2 Providing a base case:* `foldl` simplifies the problem with each invocation so that it will eventually reach the following base case.

[source,elm]
----
[] ->
    acc
----

*#3 Combining results from each sub-problem:* Once the base case is reached, `foldl` starts the process of combining results from each invocation. It uses the following code to accomplish that.

[source,elm]
----
foldl func (func x acc) xs
----

It’s not easy to figure out how the accumulation of results happens just by looking at that code. So let’s visualize each step in the invocation.

image:https://elmprogramming.com/images/chapter-4/4.9-pattern-matching/foldl-invocations.svg[]

==== Pattern Matching Function Arguments

We can pattern match on function arguments too. Here’s an example from the <<tuple, Tuples>> section that computes the perimeter of a triangle:

[source,elm]
----
> trianglePerimeter ( a, b, c ) = a + b + c
<function> : ( number, number, number ) -> number

> trianglePerimeter ( 5, 4, 6 )
15 : number
----

The pattern we are checking for in the above example is a tuple that contains three, and only three, numbers. When we apply the function, Elm reaches into the tuple that represents the sole argument of the `trianglePerimeter` function and binds `a` to `5`, `b` to `4`, and `c` to `6`. Let’s say we want to ignore the second argument. Not sure why we’d want to do that in this case, but if we do, we could use `_` instead of an actual parameter.

[source,elm]
----
> trianglePerimeter ( a, _, c ) = a + c
<function> : ( number, a, number ) -> number

> trianglePerimeter ( 5, 4, 6 )
11 : number
----

Notice how the `trianglePerimeter` function’s type got changed with the use of `_`. This ability to pattern match function arguments came in handy when we used a `tuple` fuzzer to write tests in the <<fuzz-testing, Fuzz Testing>> section.

[source,elm]
----
addTests : Test
addTests =
    describe "add"
        [ fuzz (tuple ( int, int )) "adds two given integers" <|
            \( num1, num2 ) ->
                add num1 num2
                    |> Expect.equal (num1 + num2)
        ]
----

When the `tuple` fuzzer generates two integers, it binds them to constants — `num1` and `num2` — contained inside the tuple parameter. That’s what enables us to use `num1` and `num2` in the function body directly without having to use the `Tuple.first` and `Tuple.second` functions.

[[listunzip]]
===== List.unzip

The implementation of the `List.unzip` function is another good example of matching patterns on function arguments.

[source,elm]
----
unzip : List ( a, b ) -> ( List a, List b )
unzip pairs =
    let
        step ( x, y ) ( xs, ys ) =
            ( x :: xs, y :: ys )
    in
        foldr step ( [], [] ) pairs
----

The `unzip` function converts a list of tuples into a tuple of lists. Here’s an example:

[source,elm]
----
> List.unzip [ ( "Andy", True ), ( "Red", False ) ]
(["Andy","Red"],[True,False])
----

The first list in the output contains the first item from each tuple in the original list, and the second list contains the second items. The private function `step` in `unzip`’s implementation uses pattern matching to break the pairs apart and put them into separate lists. Look how succinct the code inside the `step` function is. Without pattern matching it would take a lot more code to accomplish the same task.

==== Pattern Matching Records

In the <<type-system, Using Custom Types>> section, we created a simple function that checked the `isLoggedIn` flag to return an appropriate welcome message.

[source,elm]
----
welcomeMessage : Bool -> String
welcomeMessage isLoggedIn =
    case isLoggedIn of
        True ->
            "Welcome to my awesome site!"

        False ->
            "Please log in."
----

Let’s say we want to return a personalized welcome message that contains the user’s name. We can accomplish that by adding a second parameter. Add the following function definition right above `main` in `Playground.elm`.

[source,elm]
----
welcomeMessage : Bool -> String -> String
welcomeMessage isLoggedIn name =
    case isLoggedIn of
        True ->
            "Welcome " ++ name ++ "!"

        False ->
            "Please log in."
----

And expose `welcomeMessage` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .
    , welcomeMessage
    )
----

Now enter the following code in `+elm repl+`.

[source,elm]
----
> import Playground exposing (..)

> welcomeMessage True "Gob Bluth"
"Welcome Gob Bluth!" : String
----

Instead of passing each user data individually, we can actually pass an entire user record to `welcomeMessage` through pattern matching. Modify the `welcomeMessage` function like this:

[source,elm]
----
welcomeMessage : { a | isLoggedIn : Bool, name : String } -> String
welcomeMessage { isLoggedIn, name } =
    case isLoggedIn of
        True ->
            "Welcome " ++ name ++ "!"

        False ->
            "Please log in."
----

Next, add the following type alias right above `main` in `Playground.elm`.

[source,elm]
----
type alias User =
    { name : String
    , email : String
    , age : Int
    , isLoggedIn : Bool
    }
----

And expose `User` in the module definition.

[source,elm]
----
module Playground exposing
    .
    .
    , User
    )
----

Now we can create a `User` record using the <<record, constructor function>> and pass that to `welcomeMessage`.

[source,elm]
----
> user = User "Gob Bluth" "gob@bluthboat.com" 42 True
{ age = 42, email = "gob@bluthboat.com", isLoggedIn = True, name = "Gob Bluth" }
    : User

> welcomeMessage user
"Welcome Gob Bluth!" : String
----

What will happen if we pass a record that contains only name and logged in status?

[source,elm]
----
> user2 = { name = "Gob Bluth", isLoggedIn = True }
{ isLoggedIn = True, name = "Gob Bluth" }
    : { isLoggedIn : Bool, name : String }

> welcomeMessage user2
"Welcome Gob Bluth!" : String
----

That works! How about this:

[source,elm]
----
> user3 = { name = "Gob Bluth", magician = True, isLoggedIn = True }
{ isLoggedIn = True, magician = True, name = "Gob Bluth" }
    : { isLoggedIn : Bool, magician : Bool, name : String }

> welcomeMessage user3
"Welcome Gob Bluth!" : String
----

That works too. Basically, the `welcomeMessage` function works with _any record_ that contains `name` and `isLoggedIn`. This was made possible by applying pattern matching to the function argument. The pattern matching version of `welcomeMessage` has an interesting type annotation:

[source]
----
welcomeMessage : { a | isLoggedIn : Bool, name : String } -> String
----

This is called _extensible record syntax_. It says the argument can be any record (represented by `a`) as long as it has `isLoggedIn` whose type is `Bool` and `name` whose type is `String`. The part that makes our argument an extensible record is this: `+a |+`. If the type annotation were to be this instead:

[source]
----
welcomeMessage : { isLoggedIn : Bool, name : String } -> String
----

We wouldn’t be able to pass _any record_ that contains `isLoggedIn` and `name` because it expects a record that has exactly two elements: `isLoggedIn` and `name`.

==== Summary

Although pattern matching is most evident in `case` expressions, Elm allows us to use it in other places too. We looked at several examples of how to use tuples to simplify the logic in a function or a `case` expression through pattern matching. We also saw an example that showed us how pattern matching on a list could enable us to write compact recursive functions such as `foldl`. We learned what extensible records are and how pattern matching makes them flexible. Finally, it’s important to keep in mind that pattern matching can only look at the structure of data. It can’t do any computation on the data itself.


[[benefits-of-elm-conclusion]]
=== 4.10 Conclusion


In this chapter, we learned how some of the features present in Elm enable us to write reliable and maintainable programs. Much of that reliability comes from immutable values, pure functions, and a powerful type system. These three features are at the core of some of Elm’s truly exciting features such as the <<elm-architecture-intro, Elm Architecture>> and an http://elm-lang.org/blog/the-perfect-bug-report[amazing debugger] which makes reproducing bugs quite easy.

Organizing functions, constants, type definitions, and other values in Elm is relatively easy through the use of modules. Once created, modules can be shared with other programmers first by including them in a package and then publishing the package on the http://package.elm-lang.org/[online catalog].

Elm also mitigates the https://en.wikipedia.org/wiki/Dependency_hell[“dependency hell”] problem by automatically enforcing http://semver.org/[semantic versioning] on all packages published on its online catalog. Elm’s package manager makes sure that we’ll never run into a breaking API change again when we install a patch.

Elm encourages us to identify important properties of our programs and then use fuzz testing to make sure those properties do hold true for a wide variety of inputs. It also offers traditional unit tests if we feel the need to supplement our test suite with tests that provide better documentation and cover tricky edge cases.

Finally, Elm lets us reach deep into our data structures and match complex patterns, enabling us to write compact yet readable code. In the next chapter, we’ll learn the Elm Architecture in detail and find out how it helps us build robust front-end web applications.


[[elm-architecture-intro]]
== 5 Elm Architecture

=== 5.1 prelude

In this chapter, we will explore the Elm Architecture — a novel approach for organizing code that makes managing data flow in our application quite easy. Elm as a programming language, in general, is wonderful. However, it’s the Elm Architecture that makes building front-end web applications in Elm so much fun. Let’s dive into it!


[[model-view-update-part-1]]
=== 5.2 Model View Update - Part 1


On a very high level, web applications tend to have two major parts: state and user interface (UI). An application starts with an initial state and presents that state to the user through UI. The user takes some action through a UI element that modifies the initial state. The new state is then presented back to the user for more actions. The figure below shows the interaction between a state and UI in a hypothetical application that allows logged in users to create blog posts.

image:https://elmprogramming.com/images/chapter-5/5.2-model-view-update-part-1/state-and-ui.svg[]

At any given point in time, an application needs to store different types of information in memory. For example, it needs to know whether or not a user is logged in or how many blogs a user has posted. State is like a repository for storing all of this information. This state is then made available to various data structures in the application. Functions in the application perform different operations on it, resulting into a new state.

In the <<pure-functions, Pure Functions>> section, we defined a state as something that represents all the information stored at a given point in time that a _function_ has access to. Conceptually, an _application state_ works the same way. It just contains a lot more information than a function-level state.

==== Model

In Elm, we represent the state of an application with something called a _model_. A model is just a data structure that contains important information about the application. Imagine a simple app for incrementing and decrementing a counter. The only thing we need to track in this app is the current value of a counter. Here is what the model definition for this app looks like:

[source,elm]
----
type alias Model
    = Int
----

It’s just an `Int`. A model doesn’t necessarily have to be complicated. It all depends on how complex the app is and how many different things it needs to track. For a simple counter app, all we need is a number that tells us what the current value is. A model is generally defined as a `+type alias+`.

Let’s add the above model definition to a file and start building a counter app in Elm. Create a new file called `Counter.elm` in the `+beginning-elm/src+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-5/5.2-model-view-update-part-1/create-counter-file.png[]

[source,elm]
----
module Counter exposing (Model)


type alias Model =
    Int
----

The definition above doesn’t create a model. All it tells Elm is what our model looks like. Here is the code that actually creates our initial model:

[source,elm]
----
initialModel : Model
initialModel =
    0
----

Add the code above to the bottom of `Counter.elm`.

==== View

Next, we need to present our initial model to the user. Add the following code to the bottom of `Counter.elm`.

[source,elm]
----
view : Model -> Html msg
view model =
    div []
        [ button [] [ text "-" ]
        , text (String.fromInt model)
        , button [] [ text "+" ]
        ]
----

The `view` function takes a model and returns HTML code. Behind the scenes, the `div` function in Elm produces the `+<div>+` element in HTML, and the `button` function produces the `+<button>+` element. The `text` function doesn’t represent any HTML tag. It just displays a plain text by escaping special characters so that the text appears exactly as we specify in our code.

The first argument to `div` and `button` represent a list of attributes. The second argument represents a list of nested elements. The Elm code in the `view` function is equivalent to the following HTML code.

[source,html]
----
<div>
    <button> + </button>
    String representation of our model
    <button> - </button>
</div>
----

The `div`, `button`, and `text` functions are all defined in the https://package.elm-lang.org/packages/elm/html/latest/Html[`Html`] module included in the https://package.elm-lang.org/packages/elm/html/latest/[`+elm/html+`] package. The `Html` module provides full access to HTML elements through normal Elm functions. Let’s import it in `Counter.elm`.

[source,elm]
----
module Counter exposing (Model)

import Html exposing (..)
.
.
----

Since we can treat HTML elements as plain old Elm functions, we can apply all the nice things Elm has to offer to the view code as well. For example, we can refactor the duplicate code out into separate functions and reuse them from different places in our app. We can write automated tests for the view code using the same tools used for testing any other Elm code. Elm compiler will even let us know if we made any mistake in the view code.

The `view` function isn’t responsible for rendering HTML on a screen. All it does is take a model and return a chunk of HTML. It’s a pure function that returns the same HTML code given the same model. To actually render HTML on a screen, Elm uses a different package called https://package.elm-lang.org/packages/elm/virtual-dom/latest/[`+elm/virtual-dom+`] behind the scenes. Don’t worry about how this package works now. We’ll explore it in detail in the <<virtual-dom, Virtual DOM>> section later in this chapter.

The `+elm/html+` package depends on `+elm/virtual-dom+`. That’s why it was
automatically installed and listed as an indirect dependency in the `elm.json` file when we ran `+elm make+` in the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section.

[source,json]
----
{
    "dependencies": {
        "direct": {
            "elm/html": "1.0.0",
        },
        "indirect": {
            "elm/virtual-dom": "1.0.2"
        }
    }
}
----

We don’t need to import any of the modules included in the `+elm/virtual-dom+` package in our code because we shouldn’t be using it directly. It only exists to support the modules defined in the `+elm/html+` package.

The `view` function’s type annotation suggests it returns a value of type `+Html msg+` which means the HTML code generated by `view` is capable of producing messages of type `msg`. We’ll find out what `msg` is in the <<model-view-update-part-1, Update>> section below.

[source,elm]
----
view : Model -> Html msg
----

==== Application Entry Point

Add the following code to the bottom of `Counter.elm`.

[source,elm]
----
main : Html msg
main =
    view initialModel
----

As usual, `main` acts as an entry point for our app. All it does is pass the initial model to the `view` function. Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and go to this URL: http://localhost:8000/src/Counter.elm[`+http://localhost:8000/src/Counter.elm+`]. You should see something like this in the top left corner of your browser:

image:https://elmprogramming.com/images/chapter-5/5.2-model-view-update-part-1/counter-app-1.png[]

==== Update

Our app is utterly uninteresting at the moment. The buttons don’t do anything. That’s because we haven’t specified what should happen when the buttons are clicked. Let’s do that next. The first thing to do is define _messages_ that represent the actions users can take. Add the following type definition right above `main` in `Counter.elm`.

[source,elm]
----
type Msg
    = Increment
    | Decrement
----

`Msg` is a <<type-system, custom type>> with two constants. When the `+++` button is clicked, our app will receive the message called `Increment` and clicking the `-` button will generate the `Decrement` message.

Message::
  The term “message” doesn’t have any special meaning in Elm. It’s not a special type or a data structure. We could have very well called it “action” or “event” or “do this thing”. The official documentation and the Elm community prefer “message”, so we’ll go with that.

Unlike `Model`, we didn’t define `Msg` as a type alias because there is no built-in type in Elm for representing messages. In contrast, our `Model` is just an int value. So we made it a type alias that simply redefines the existing `Int` type.

===== Handling Messages

To handle messages, we need to define a new function. Add the following code above `main` in `Counter.elm`.

[source,elm]
----
update : Msg -> Model -> Model
update msg model =
    case msg of
        Increment ->
            model + 1

        Decrement ->
            model - 1
----

The `update` function increments or decrements the model based on which message the app receives.

===== Generating Messages

We’ve created a mechanism for handling messages, but we still don’t have a way to create them. Let’s take care of that. Modify the `view` function to fire messages when the `+++` and `-` buttons are clicked.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick Decrement ] [ text "-" ]
        , text (String.fromInt model)
        , button [ onClick Increment ] [ text "+" ]
        ]
----

Previously, the HTML returned by `view` wasn’t creating any messages, so we just used `msg` as a placeholder in its type annotation.

[source,elm]
----
view : Model -> Html msg
view model =
    ...
----

Now, `view` uses the `onClick` function from the https://package.elm-lang.org/packages/elm/html/latest/Html-Events[`Html.Events`] module to generate messages of type `Msg`. Let’s import `Html.Events` in `Counter.elm`.

[source,elm]
----
module Counter exposing (Model)

import Html.Events exposing (..)
.
.
----

`Msg` is a concrete type, whereas `msg` is just a type variable. A concrete type always starts with an uppercase letter. A type variable, on the other hand, starts with a lowercase letter. Unlike the special type variable `number` we saw in the <<type-system, Type System>> section, `msg` doesn’t have any special meaning in Elm. We could have used any random name to represent a generic message in the previous version like this:

[source,elm]
----
view : Model -> Html someMessage
view model =
    ...
----

By replacing `msg` with `Msg`, we’ve made the `view` function much more restrictive. Now, it can _only_ generate two messages: `Increment` and `Decrement`. Before, it could generate _any_ message.

==== Wiring Everything Up

Here is how our `main` looks right now:

[source,elm]
----
main : Html msg
main =
    view initialModel
----

Passing `initialModel` to `view` was enough when we were just displaying a static view. To allow interactivity, we need to add `update` in the mix. Modify `main` like this:

[source,elm]
----
main : Program () Model Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = view
        , update = update
        }
----

And import the https://package.elm-lang.org/packages/elm/browser/latest/Browser[`Browser`] module in `Counter.elm`.

[source,elm]
----
module Counter exposing (main)

import Browser
.
.
----

****
NOTE: The `Browser` module is included in the https://package.elm-lang.org/packages/elm/browser/latest/[`+elm/browser+`] package which was installed automatically when we ran `+elm make+` after our project was initialized in the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section.
****

Elm Architecture essentially boils down to these three parts: model, view, and update. The entire application can be viewed as one giant machine that runs in perpetuity. The `Browser.sandbox` function describes the structure of that machine: take an initial model, present it to the user, listen to messages, update the model based on those messages, and present the updated model back to the user again.

image:https://elmprogramming.com/images/chapter-5/5.2-model-view-update-part-1/model-view-update.svg[]

The diagram below illustrates the interaction between the Elm runtime and various components in our app.

image:https://elmprogramming.com/images/chapter-5/5.2-model-view-update-part-1/model-view-update-interaction-1.svg[]

Refresh the page at http://localhost:8000/src/Counter.elm[`+http://localhost:8000/src/Counter.elm+`] and you should be able to increment and decrement the counter.

===== main Function’s Type Annotation

Not sure if you noticed, but the `main` function’s type annotation changed from `+Html msg+` to `+Program () Model Msg+` when we introduced the `Browser.sandbox` function. Like any other function in Elm, `main` takes the type of whatever expression it happens to return. We already know what `+Html msg+` means. `+Program () Model Msg+` means an Elm program that has a model of type `Model` and accepts messages of type `Msg`. The unit type `+()+` indicates no values are passed to our app when it’s initialized. In chapter 8, we’ll see an example that shows how to <<retrieving-app-state, pass values to an Elm program during initialization>>.

==== Model as a Domain Concept

You may wonder why do we even need to define `Model`. We could simply replace `Model` with `Int` in `initialModel` and `update`’s type annotations like this:

[source,elm]
----
initialModel : Int
initialModel =
    0


update : Msg -> Int -> Int
update msg model =
    ...
----

And everything should work just fine. That is a valid point. However, by defining `Model`, we’ve given a name to the value that flows through our app. This makes our code easier to read. In a simple app, the benefits of naming things properly aren’t huge, but in a large app, a well named domain concept such as `Model` can add tremendous value from maintenance standpoint.

==== Summary

In this section, we learned the basic components of the Elm Architecture: model, view, and update. In the next section, we’ll find out what virtual DOM really is and what benefits we get from it. Here is the entire code for the counter app:

[source,elm]
----
module Counter exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (..)


type alias Model =
    Int


initialModel : Model
initialModel =
    0


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick Decrement ] [ text "-" ]
        , text (String.fromInt model)
        , button [ onClick Increment ] [ text "+" ]
        ]


type Msg
    = Increment
    | Decrement


update : Msg -> Model -> Model
update msg model =
    case msg of
        Increment ->
            model + 1

        Decrement ->
            model - 1


main : Program () Model Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = view
        , update = update
        }
----


[[virtual-dom]]
=== 5.3 Virtual DOM


The <<elm-runtime, Elm runtime>> uses a package called https://package.elm-lang.org/packages/elm/virtual-dom/latest[`+elm/virtual-dom+`] to render HTML on a screen. In this section, we’ll learn how this package works. First, let’s understand how browsers render HTML in general.

==== How Browsers Render HTML

When a browser is given some HTML code, it takes that code through a series of transformations before the UI elements are displayed on a screen.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/browser-parse-flow.svg[]

[[1-parse-html]]
===== 1. Parse HTML

Let’s look at how the following HTML code we saw earlier in the <<model-view-update-part-1, Model View Update - Part 1>> section gets rendered.

[source,html]
----
<html>
  <body>
    <div>
      <button> - </button>
      0
      <button> + </button>
    </div>
  </body>
</html>
----

The first thing a browser does when it encounters the above code is create HTML tokens. Tokens are the building blocks of a language. Collectively, they represent the entire vocabulary of that language. For example, the vocabulary of the English language consists of all the words that appear in a dictionary. Browsers use a process called _tokenization_ or _lexical analysis_ to break a chunk of HTML code into individual tokens. The figure below shows how the above code appears to a browser — a series of text characters.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-1.svg[]

To keep things simple, only a portion of the code is shown here. The first thing a browser does is step through the characters one at a time starting from the beginning.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-2.svg[]

The first character it encounters is `+<+`, which means what follows is a _start tag token_. The browser continues to process the next characters until it encounters `+>+`, which marks the end of a _start tag token_.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-3.svg[]

The series of characters between `+<+` and `+>+` are converted into the first start tag token called `html`.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-4.svg[]

The second token is the `body` start tag.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-5.svg[]

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-6.svg[]

The browser continues to step through the characters in our code, converting them into more tokens. The figure below shows all the tokens present in our code.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-tokenization-7.svg[]

[[2-construct-the-dom-tree]]
===== 2. Construct the DOM Tree

During the tokenization phase, the browser processed our code, which started as a stream of text characters, into a series of tokens. The next step is to create the Document Object Model (DOM) tree using these tokens.

Document Object Model::
  “The Document Object Model (DOM) is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects. That way, programming languages can connect to the page.” - https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction[Mozilla Developer Network]

After an HTML page is loaded, we often need to make changes to it based on various events generated either by the user or some other source. For example, when the user clicks the `+++` button in the counter app we built earlier, we need to increment the count. To make this update easier, the browser creates the DOM tree for the page. A tree is a data structure that simulates the hierarchical relationship between objects.

With access to the object representation of each element in the HTML page, we can now add, change, and remove HTML elements and attributes; change the CSS styles; react to existing events; or create new events through JavaScript.

The DOM objects tend to have almost one-to-one mapping to the HTML markup as shown in the figure below.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-to-dom-mapping.svg[]

The mapping is very close because the browser builds a DOM tree from tokens extracted from the original HTML code as shown below.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/html-token-to-dom-mapping.svg[]

The objects in the DOM tree are often referred to as `nodes` in HTML parlance. We can be specific and call each node with a different name based on what type of object it represents. For example, the root node in the DOM tree is known as `document`. It is a special type of node that represents the entire HTML document. When the DOM tree creation process begins, the `document` node is the first one to be created. The browser then takes a sequence of tokens from the tokenization stage, creates respective DOM objects, and adds them to the tree as the `document` node’s children.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/dom-tree-with-document-node.svg[]

Nodes that can be used to specify an HTML tag are called `elements`. The element attributes such as `id` and `class` can be represented using the `attribute` nodes. Similarly, the comments and plain text can be represented using the `comment` and `text` nodes respectively. The official https://www.w3.org/TR/dom/[DOM specification] contains many more types of nodes.

We can actually query the node type from a browser. Let’s try it. Open browser console from the counter app page located at http://localhost:8000/src/Counter.elm[`+http://localhost:8000/src/Counter.elm+`] and enter the code after the `+>+` prompt below into the console.

Opening browser console::
  Instructions for opening the browser console depends on which browser you’re using. Please read https://www.wickedlysmart.com/hfjsconsole/[this nice tutorial from WickedlySmart] for learning how to open the console on various browsers.

[source,javascript]
----
> document.nodeType
9
----

The https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType[`nodeType`] property returns a number. To find out which node type that number represents, we need to reference the following table.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/node-types-mdn.png[]

https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType[Source: Mozilla Developer Network]

The number `9` means the `DOCUMENT_NODE`. Let’s query the node type of a few more DOM objects.

[source,javascript]
----
> var div = document.createElement("div")
undefined

> div.nodeType
1      // --> ELEMENT_NODE

> var text = document.createTextNode("some text")
undefined

> text.nodeType
3      // --> TEXT_NODE

> var comment = document.createComment("some comment")
undefined

> comment.nodeType
8      // --> COMMENT_NODE
----

Notice how we can create HTML elements using JavaScript functions such as `createElement`, `createTextNode`, and `createComment`. That’s possible due to the existence of the DOM tree. It turns the HTML code we typed into something we can manipulate using JavaScript in memory.

[[3-construct-the-render-tree]]
===== 3. Construct the Render Tree

While the DOM tree is being created, the browser starts the rendering process in parallel by creating yet another tree called the _render tree_. The render tree contains the style information for each DOM node that dictates how the node should be displayed. Nodes that aren’t meant to be displayed on a screen aren’t included in the render tree. Here are a few examples of nodes that aren’t visible: `head`, `script`, and `meta`. Some nodes might be hidden via CSS through the use of `+display: none+` even though they can actually be displayed on a screen. These nodes are also excluded from the render tree.

[[4-layout-the-render-tree]]
===== 4. Layout the Render Tree

With the render tree in place, the browser proceeds to lay out each node.
The render tree contains the information that dictates _how_ the nodes should be displayed, but not _where_ on a screen they should be rendered.
The browser computes the position and size of each node from the information stored in the render tree.

[[5-paint-the-render-tree-on-screen]]
===== 5. Paint the Render Tree on Screen

Now that all information required to render the nodes has been computed, the browser begins to convert each node in the render tree to actual pixels on the screen. This process is called _painting_.

The virtual DOM library in Elm only deals with the DOM tree, not the render tree, but by learning about both you have a complete picture of how an HTML page is rendered.

Further Reading::
  What we covered so far is a very high-level overview of how browsers parse and render HTML on a screen. If you’d like to learn more about this topic, here are some good resources:
+
* https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/[How Browsers Work: Behind the scenes of modern web browsers]
  * https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model#top_of_page[Web Fundamentals - Constructing the Object Model]
  * https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction[Web Fundamentals - Render-tree Construction&#44; Layout&#44; and Paint]

[[virtual-dom]]
==== Virtual DOM

Although the DOM tree makes it easy for us to create, update, and delete nodes, the direct manipulation of that tree tends to be really slow when we have large number of nodes. Let’s write some code in JavaScript to find out how long it takes to update a DOM node compared to a simple string. Create a new file called `+dom-performance-test.js+` in the `+beginning-elm+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/dom-performance-test-file.png[]

[source,javascript]
----
// Create a simple string
var someString = "some string";

// Update string 10,000 times
function updateString() {
    for (var i = 0; i <= 10000; i++) {
        someString = "updated string"
    };
}

// Find out how long it takes to update a string 10,000 times
var t1 = performance.now();
updateString();
var t2 = performance.now();

console.log("It took " + (t2 - t1) + " milliseconds to update a string.");
----

We created a simple string and wrote a function to update that string 10,000 times. We then used the https://developer.mozilla.org/en-US/docs/Web/API/Performance/now[`performance.now`] function to capture the timestamp right before and after applying `updateString`. Finally, we printed how long it took for the `updateString` function to execute in the console.

Next, we’ll write a similar test to find out how long it takes to update a DOM node. Add the following code to the bottom of `+dom-performance-test.js+`.

[source,javascript]
----
// Create new nodes
var newDiv = document.createElement("div");
var newText = document.createTextNode("some text");

// Add new nodes to the DOM tree
newDiv.appendChild(newText);
document.body.appendChild(newDiv);

// Update the text node inside div 10,000 times
function updateDOM() {
    for (var i = 0; i <= 10000; i++) {
        newDiv.innerHTML = "updated text";
    }
}

// Find out how long it takes to update a DOM element
var t3 = performance.now();
updateDOM();
var t4 = performance.now();

console.log("It took " + (t4 - t3) + " milliseconds to update a DOM element.");
----

We created a new `div` element and added a text node to it. After that, we appended the `div` as a child to the `body` element. The `updateDOM` function simply updates the HTML content inside the `div` element 10,000 times by assigning a new value to the https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML[`innerHtml`] property.

To run this experiment, we need to load `+dom-performance-test.js+` from the `index.html` file located in the `+beginning-elm+` directory.

[source,html]
----
<!DOCTYPE html>
<html>
  .
  .
  <body>
    .
    .
    <script src="experiment.js"></script>
    <script src="dom-performance-test.js"></script>
    .
    .
  </body>
</html>
----

Open `index.html` in a browser and then go to the browser console. You should see the number of milliseconds it took to update a string and a DOM element.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/dom-performance-1.png[]

Those numbers are from Chrome 70 on a MacBook Pro with 2.2 GHz Intel Core i7 processor and 16 GB of memory. You might see different results depending on which browser and computer you run the experiment on. No matter which configuration you use, you’ll notice that it takes significantly longer to update a DOM element compared to a string. Why is that?

Updating a string is quite straightforward. JavaScript knows where the string is stored in memory, so it takes the new value and simply overwrites the bits in memory. But when we update a DOM node, it’s not just JavaScript that’s doing the work. The browser needs to take the new change through the entire process we laid out earlier:

* Parse HTML
* Update the DOM tree
* Update the render tree
* Layout the render tree
* Paint the render tree on screen

Depending on how complex the change is, the browser may need to destroy and re-create the existing children nodes of the element we’re trying to update. It may also need to recompute the physical dimensions and style of many nodes that are affected by the change. If there are any browser extensions that control access to the node we want to modify, the browser will have to first ask for their permission and notify them after the change has been made.

The full implications of updating a DOM node could be huge. The update we’re trying to make above wasn’t even that complex and it took about 104 times longer than updating a string. We can only imagine how much longer it will take when we need to update many nodes at once.

Although we can’t fully sidestep this problem, Elm mitigates it by making as few updates as possible to the DOM tree. Elm actually takes over the entire responsibility for updating the DOM tree from us. Earlier when we wrote this code in JavaScript:

[source,javascript]
----
// Update the text node inside div 10,000 times
function updateDOM() {
    for (var i = 0; i <= 10000; i++) {
        newDiv.innerHTML = "updated text";
    }
}
----

We were getting into the dirty details of updating the DOM by ourselves. In Elm, all we need to do is specify how we want to present our model to the user and let the runtime take care of updating the DOM. In the <<model-view-update-part-1, Model View Update - Part 1>> section, we wrote the following code to display our view.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick Decrement ] [ text "-" ]
        , text (String.fromInt model)
        , button [ onClick Increment ] [ text "+" ]
        ]
----

We didn’t have to specify which DOM nodes should be updated. All we did was declare what our view should look like by using simple Elm functions. Behind the scenes, Elm used the https://package.elm-lang.org/packages/elm/virtual-dom/latest[`+elm/virtual-dom+`] package to convert the code in `view` to actual DOM nodes.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/elm-runtime-virtual-dom.svg[]

===== Understanding How `+elm/virtual-dom+` Works

Let’s dig a little deeper into the `+elm/virtual-dom+` package to understand how it works. Most functions defined in the `Html` module are wrappers for virtual DOM nodes. Take a look at how the `div` function is implemented in the `Html` module.

[source,elm]
----
div : List (Attribute msg) -> List (Html msg) -> Html msg
div =
    Elm.Kernel.VirtualDom.node "div"
----

All it does is pass a tag name to another function called `node` defined in the `+Elm.Kernel.VirtualDom+`. Here are a couple more examples:

[source,elm]
----
button : List (Attribute msg) -> List (Html msg) -> Html msg
button =
    Elm.Kernel.VirtualDom.node "button"
----

[source,elm]
----
label : List (Attribute msg) -> List (Html msg) -> Html msg
label =
    Elm.Kernel.VirtualDom.node "label"
----

The `Elm.Kernel` prefix indicates this module is not written in Elm. Kernel modules are generally written in JavaScript, but they can also be written in some other language (e.g., CoffeeScript) that eventually compiles to JavaScript. And someday they might be rewritten in https://developer.mozilla.org/en-US/docs/WebAssembly[WebAssembly] too.

A good number of Elm modules are partially implemented in JavaScript behind the scenes. For example, the `List.sortWith` function we went over in the <<list, Sorting a List>> section is implemented like this:

[source,elm]
----
sortWith : (a -> a -> Order) ->  List a -> List a
sortWith =
    Elm.Kernel.List.sortWith
----

`+Elm.Kernel.List.sortWith+` is in turn implemented in JavaScript like this:

[source,javascript]
----
var _List_sortWith = F2(function(f, xs) {
    return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
        var ord = A2(f, a, b);
        return ord === __Basics_EQ ? 0 : ord === __Basics_LT ? -1 : 1;
    }));
});
----

Similarly, the `String.filter` function we covered in the <<string, Filtering a String>> section also uses a kernel module behind the scenes.

[source,elm]
----
filter : (Char -> Bool) -> String -> String
filter =
    Elm.Kernel.String.filter
----

As of this writing, 14% of the entire https://github.com/elm/core[`+elm/core+`] package, which includes standard library modules such as `List` and `String`, is implemented in JavaScript.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/elm-lang-core-javascript-percentage.png[]

Similarly, 75% of the https://github.com/elm/virtual-dom[`+elm/virtual-dom+`] package is implemented in JavaScript.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/virtual-dom-javascript-percentage.png[]

Elm Kernel::
  In the context of an operating system, the https://en.wikipedia.org/wiki/Kernel_(operating_system)[kernel] is a program that handles lower-level tasks such as managing memory and interfacing with peripherals like keyboards, monitors, and speakers. Higher-level programs aren’t allowed to communicate with those peripherals directly. They have to make a https://en.wikipedia.org/wiki/Kernel_(operating_system)#System_calls[system call] to the kernel to get access.
+
Elm uses a similar approach to manage lower-level web systems such as DOM, mouse, keyboard, and geolocation. To access those systems, our applications must go through the Elm Kernel. When the `Html.div` function used `node` from `+Elm.Kernel.VirtualDom+` package earlier, it actually made a system call to the Elm Kernel to create an HTML node. Luckily for us, most of these lower-level system calls are hidden behind easy-to-use modules such as `Html`, `List`, and `String`. Therefore, we rarely need to call them directly.
+
One of the biggest benefits of restricting direct access to the lower-level systems is reliability. If Elm Kernel didn’t exist, we would be forced to use JavaScript to interact with those systems. In the <<pure-functions, Pure Functions>> section, we learned how unreliable the JavaScript code can be due to its impurity. By going through the Elm Kernel, our application code is in a position to take advantage of the _“if it compiles, it works”_ guarantee that comes with using Elm functions.
+
Not only Elm doesn’t allow our application code to directly access the lower-level web systems, but it also prevents our code from calling the kernel. Third-party packages are also not allowed to access the kernel. Only official packages published by the https://github.com/elm[`elm`] and https://github.com/elm-explorations[`+elm-explorations+`] organizations can access the kernel. Without this restriction, it would be difficult to provide the _“if it compiles, it works”_ guarantee.
+
The Elm Kernel offers many more benefits. To find out what they are, I recommend reading https://discourse.elm-lang.org/t/native-code-in-0-19/826[this wonderful post about the history of Elm Kernel]
  by Evan Czaplicki — the creator of Elm.

===== Inner Workings of the Virtual Dom

Now that we know what kernel modules are, let’s get back to understanding how `+Elm.Kernel.VirtualDom+` works. The `node` function in that module is implemented like this in JavaScript:

[source,javascript]
----
var _VirtualDom_nodeNS = F2(function(namespace, tag) {
    return F2(function(factList, kidList) {
        for (var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b) {
            var kid = kidList.a;
            descendantsCount += (kid.__descendantsCount || 0);
            kids.push(kid);
        }

        descendantsCount += kids.length;

        return {
            $: __2_NODE,
            __tag: tag,
            __facts: _VirtualDom_organizeFacts(factList),
            __kids: kids,
            __namespace: namespace,
            __descendantsCount: descendantsCount
        };
    });
});
----

Most code in `+Elm.Kernel.VirtualDom+` including the one above is highly complex. We aren’t equipped to understand that code without extensive knowledge of JavaScript and the inner workings of virtual DOM. We’ll just settle for a high-level overview of how `+Elm.Kernel.VirtualDom+` works. The following https://en.wikipedia.org/wiki/Algorithm[algorithm] roughly outlines the process used by this module.

Algorithm for Rendering HTML Elements in Elm::
  *Step 1:* Create a virtual DOM tree. This is not an exact replica of the real DOM tree. It’s just a light-weight version built using https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects[JavaScript objects].
+
*Step 2:* Make a UI change in our app. This change could be anything, for example changing the color of a button, or adding a completely new UI element, or removing an existing one.
+
*Step 3:* Create a new virtual DOM tree that reflects the UI changes we made. This tree is different from the one created in step 1.
+
*Step 4:* Figure out the exact differences between the new and previous virtual DOM trees. This step is where the virtual DOM really shines. If we were to compute the difference between the new and previous UI using the real DOM, we would take a huge performance hit. In contrast, the virtual DOM is highly optimized for operations like these.
+
*Step 5:* Repeat step 2 through step 4 until all UI changes have been identified.
+
*Step 6:* Create instructions for modifying the real DOM tree in one big batch. As mentioned earlier, even a seemingly small change to the real DOM tree is expensive from performance standpoint. So it’s prudent to combine multiple instructions together rather than applying each change individually.
+
*Step 7:* Modify the real DOM tree using the https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame[`requestAnimationFrame`] function, which figures out the best way to apply multiple changes so that the transition from the previous UI to the new one is smooth.

Although we dug deep into the `+elm/virtual-dom+` package in this section, the good news is we don’t really have to understand how it works at all to be able to build great apps in Elm. The `Html` module abstracts all this dirty detail away and lets us use simple functions like `div`, `button`, and `label` that map directly to the HTML tags.

A Brief History of the Virtual DOM::
  The concept of a virtual DOM was popularized by https://facebook.github.io/react/[React] — a JavaScript library for building user interfaces — back in 2013. At the time, the virtual DOM implementation was buried deep into React, so other languages and frameworks couldn’t take advantage of this great concept.
+
https://twitter.com/raynos?lang=en[Jake Verbaten] realized that it’s possible to implement a virtual DOM on its own as a set of independent modules and wrote a https://gist.github.com/Raynos/8414846[nice article] that laid out what that implementation would look like. In early 2014, Matt Esch started working on creating a standalone https://github.com/Matt-Esch/virtual-dom[virtual DOM library].
+
Soon after the standalone virtual DOM library was available, https://twitter.com/czaplic?lang=en[Evan Czaplicki] — the creator of Elm — used it as an underlying implementation for the `+Elm.Kernel.VirtualDom+` module. In May of 2016, a new version (0.17) of Elm was released and Evan had to rewrite the entire virtual DOM implementation from scratch to support the API changes made in 0.17. The new implementation is much faster than the versions used before 0.17 and it continues to improve with each new release.

==== Benefits of Using the Virtual DOM

From what we have learned so far, it appears that the reason virtual DOM exists is to mitigate the performance bottlenecks caused by manipulating the DOM tree too often. There is also a second benefit that is more relevant to our day-to-day experience with Elm — it allows us to write modular view code using pure functions. The rest of this section is dedicated to exploring these two benefits.

===== Writing Modular View Code

Let’s look at the `view` function we wrote in Elm earlier once again.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick Decrement ] [ text "-" ]
        , text (String.fromInt model)
        , button [ onClick Increment ] [ text "+" ]
        ]
----

The beautiful thing about this function is that it will always return the exact same HTML given the same input. That means we can reliably verify that the `view` function behaves as expected with <<easy-to-test, simple tests>>. We can also break it into multiple equally reliable functions if it starts to get more complex. Let’s imagine an app whose home page looks like this:

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/amicus-home-page.png[]

The home page is divided into three distinct regions: navigation header, main content region, and footer. The view code for this page will certainly be a lot more complex than the above `view` function, but we can break it into multiple functions so that it doesn’t get too overwhelming. Here’s how a hypothetical `view` function for that home page would look:

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ nav model
        , mainContent model
        , footer model
        ]


nav : Model -> Html Msg
nav model =
    header [ class "navbar navbar-fixed-top navbar-inverse" ]
        [ div [ class "container" ]
            [ div [ class "navbar-header" ]
                [ button
                    [ class "navbar-toggle"
                    , attribute "data-target" "#myNavBar"
                    , attribute "data-toggle" "collapse"
                    ]
                    [ span [ class "icon-bar" ] []
                    , span [ class "icon-bar" ] []
                    , span [ class "icon-bar" ] []
                    ]
                , li []
                    [ a [ href "#home", id "logo" ]
                        [ text "amicus app" ]
                    ]
                ]
            , Html.nav [ class "collapse navbar-collapse", id "myNavBar" ]
                [ ul [ class "nav navbar-nav navbar-right" ]
                    [ li []
                        [ a [ href "#help" ]
                            [ text "Help" ]
                        ]
                    , li []
                        [ a [ href "#login" ]
                            [ text "Login" ]
                        ]
                    ]
                ]
            ]
        ]


mainContent : Model -> Html Msg
mainContent model =
    case model.route of
        HomeRoute ->
            StaticPages.HomeView.view ()

        AboutRoute ->
            StaticPages.AboutView.view ()

        ContactRoute ->
            StaticPages.ContactView.view ()

        HelpRoute ->
            StaticPages.HelpView.view ()

        SignupRoute ->
            App.map SignupMsg (Signup.View.view model.currentUser)

        ProfileRoute ->
            App.map ProfileMsg (Profile.View.view model.currentUser)

        LoginRoute ->
            App.map LoginMsg (Login.View.view model.currentUser)

        NotFoundRoute ->
            notFoundView


notFoundView : Html Msg
notFoundView =
    div [] [ text "Not found" ]


footer : Model -> Html Msg
footer model =
    Html.footer [ class "container" ]
        [ small [] [ text "Copyright © 2016 Vandelay Industries" ]
        , Html.nav []
            [ ul []
                [ li []
                    [ a [ href "#about" ]
                        [ text "About" ]
                    ]
                , li []
                    [ a [ href "#contact" ]
                        [ text "Contact" ]
                    ]
                ]
            ]
        ]
----

Don’t worry about understanding how each function in the above code listing works. Just focus on the overall structure of the code. Instead of producing all HTML code by itself, the `view` function now delegates that task to the `nav`, `mainContent`, and `footer` functions which are responsible for producing HTML for each individual section of the page.

By splitting the view code like this, we’ve reduced the cognitive overload quite a bit. We can zoom in on one specific part of the page by locating the respective function and just understand how that code works. This is one of the reasons why Elm is a fantastic tool for building highly interactive web apps that will continue to grow in size and complexity over time.

In most languages and frameworks, it’s not so straightforward to write modular view functions like in Elm. That’s because not only do those languages lack inherent support for pure functions, but the view code also often wants to manipulate the real DOM directly.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/view-code-in-other-languages.svg[]

Whereas in Elm, the view code is isolated from real DOM by the runtime.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/view-code-in-elm.svg[]

===== Performance Benefits

Since the Elm runtime abstracts away the dirty details of manipulating the real DOM, it has more freedom to make clever optimizations behind the scenes resulting in much faster rendering of pages. But, how fast can Elm render pages exactly? The chart below shows how Elm fares against some of the most popular front-end frameworks in use today.

image:https://elmprogramming.com/images/chapter-5/5.3-virtual-dom/elm-vs-other-frameworks.png[]

http://elm-lang.org/blog/blazing-fast-html-round-two[Source: Blazing Fast HTML by Evan Czaplicki]

The above graph shows that Elm is _extremely_ fast when it comes to rendering pages. If you are interested in learning what optimizations Elm uses to achieve such great performance, you should definitely read http://elm-lang.org/blog/blazing-fast-html-round-two[this] wonderful blog post by Evan.

==== Summary

In this section, we learned how modern browsers render HTML by first parsing a stream of characters into HTML tokens and building the DOM tree using those tokens. The DOM tree is then converted into the render tree, which goes through a layout process, before finally being painted on a screen.

We also learned that manipulating the DOM tree directly is quite slow. This led to the development of virtual DOM which enabled the Elm runtime to significantly speed up the rendering process. The virtual DOM has also enabled us to write modular view code using pure Elm functions that are easy to test and maintain in the long run.


[[model-view-update-part-2]]
=== 5.4 Model View Update - Part 2


In <<model-view-update-part-1, Model View Update - Part 1>>, we used a very simple example to learn the fundamental concepts behind Elm Architecture. In this section, we’ll build a slightly more complex app to reinforce our understanding of the _Model View Update_ pattern.

==== Building a Sign-Up Form

Most web applications today require users to create a new account, so let’s build a sign-up form in Elm. It will be a good exercise to see how the Elm Architecture holds up when our application isn’t just a simple counter. It’ll also give us an opportunity to learn how to style our app using different techniques including an external CSS framework. Here’s how the sign-up form will look after we’re done implementing it.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-inline-styled.png[]

When building a new app, we often don’t know where to start. One approach is to define the model first, write some view code to present that model to the user, and figure out what messages the user can send to our app. We can then use those messages to transform the current model into a new one. This is exactly the approach we took in the <<model-view-update-part-1, Model View Update - Part 1>> section when we built a simple counter app. We’ll use the same approach here too.

==== Model

First, let’s think about what information does our app need to keep track of. To create a new account, we need the user’s name, email, and password. We also need to keep track of whether or not the user is logged in. Based on that, here is what the model looks like:

[source,elm]
----
module Signup exposing (User)


type alias User =
    { name : String
    , email : String
    , password : String
    , loggedIn : Bool
    }
----

Create a new file called `Signup.elm` in the `+beginning-elm/src+` directory and add the above code to it.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-elm-file-location.png[]

Our model is a record with four fields. The user entered information will be stored in `name`, `email`, and `password`. `loggedIn` will indicate whether or not the user has been authenticated to use the app. It’s quite common to use a <<record, record>> for defining a model in Elm as we’ve done here.

We called our model `User`. Elm doesn’t require us to use the word `Model`, so we can give it whatever name we want. It makes sense to call our model `User` since we’re using it to track information about the user. The model for our sign-up app is more complex compared to the counter app. Here’s the counter app model again for comparison:

[source,elm]
----
type alias Model
    = Int
----

Now that we’ve defined the structure of our model, we need to create an initial version of it. The initial model will be given to the app when it gets launched. Add the following code to the bottom of `Signup.elm`.

[source,elm]
----
initialModel : User
initialModel =
    { name = ""
    , email = ""
    , password = ""
    , loggedIn = False
    }
----

==== View

The next step is to present the initial model to the user. We do that by passing the model to the `view` function. Add the following code to the bottom of `Signup.elm`.

[source,elm]
----
view : User -> Html msg
view user =
    div []
        [ h1 [] [ text "Sign up" ]
        , Html.form []
            [ div []
                [ text "Name"
                , input [ id "name", type_ "text" ] []
                ]
            , div []
                [ text "Email"
                , input [ id "email", type_ "email" ] []
                ]
            , div []
                [ text "Password"
                , input [ id "password", type_ "password" ] []
                ]
            , div []
                [ button [ type_ "submit" ]
                    [ text "Create my account" ]
                ]
            ]
        ]
----

We already know what the `div`, `text`, and `button` functions do. The new functions — `h1`, `form`, and `input` — represent the `+<h1>+`, `+<form>+`, and `+<input>+` HTML tags respectively. The `id` function represents the `id` attribute of an HTML tag. Finally, the `type_` function defines which type of button we want to use. We can also use `type_` to specify the type for other tags such as `+<input>+`, `+<script>+`, and `+<style>+`.

Notice the underscore in the `type_` function’s name. That’s because the <<type-system, `type`>> keyword is already taken in Elm. Earlier in the <<constant, Naming Constants>> section, it was suggested that we should try to replace an underscore with a meaningful word like this:

[source,elm]
----
> name = "Sansa"
"Sansa"

> name_ = "Stark"    -- Valid but not recommended
"Stark"
----

[source,elm]
----
> firstName = "Sansa"
"Sansa"

> lastName = "Stark"    -- Much better
"Stark"
----

Following that suggestion, the creators of the `Html` module could have renamed the `type_` function to `buttonType`, but then they’d have to create separate functions for specifying the type attribute of other tags too such as `+<input>+`, `+<script>+`, and `+<style>+`. That seems a bit superfluous, so the use of an underscore is justified in this case.

All of the functions used in `view` are defined in the `Html` and `Html.Attributes` modules, so go ahead and import them in `Signup.elm`.

[source,elm]
----
module Signup exposing (User)

import Html exposing (..)
import Html.Attributes exposing (..)
.
.
----

Notice how we had to use the `Html` prefix before `form` in the `view` function — `Html.form`. That’s because we exposed everything from the `Html` and `Html.Attributes` modules and both of them define a function called `form`. If we hadn’t added the prefix, the Elm would get confused and show us the following error.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/form-no-prefix-error.png[]

Generally speaking, we should avoid exposing everything from a module due to reasons explained in the <<easier-code-organization, Qualified vs Unqualified Import>> section. However, if we have a family of modules that often get used together such as `Html` and `Html.Attributes` where the chances of name clashes are minimal and the function names are self-documenting then it’s safe to expose everything. If you don’t feel comfortable exposing everything at all, an alternative is to expose each value individually like this:

[source,elm]
----
module Signup exposing (User)

import Html exposing (Html, button, div, form, h1, input, text)
import Html.Attributes exposing (id, type_)
.
.
----

==== Application Entry Point

To display the view, we need to define an entry point to our app. Add the following code to the bottom of `Signup.elm`.

[source,elm]
----
main : Html msg
main =
    view initialModel
----

Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already, and go to this URL in your browser: http://localhost:8000/src/Signup.elm[`+http://localhost:8000/src/Signup.elm+`]. You should see the sign-up form.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-unstyled.png[]

==== Styling Our View

Our sign-up form looks a bit ugly. Let’s add some style. There are multiple ways to style a page in Elm:

* Using inline styles
* Using the http://package.elm-lang.org/packages/rtfeldman/elm-css/latest[`+elm-css+`] package
* Using an external CSS file
* Using a CSS framework

We’ll use all of those approaches to style the sign-up form. That way you’ll have a better sense of which one feels more comfortable and maintainable to you.

[[1-using-inline-styles]]
==== 1. Using Inline Styles

We can use the `style` function from the `Html.Attributes` module to add an inline style. Let’s add some padding to the header. In the `view` function, modify the line that applies the `h1` function like this:

[source,elm]
----
view : User -> Html msg
view user =
    div []
        [ h1 [ style "padding-left" "3cm" ] [ text "Sign up" ]
        , Html.form []
        .
        .
----

The `style` function takes two arguments: CSS property name and value. Here’s how its type signature looks:

[source,elm]
----
style : String -> String -> Attribute msg
----

Next, we’ll style the `form`, `input`, and `button` tags. Add the following code below the `view` function.

[source,elm]
----
formStyle : List (Attribute msg)
formStyle =
    [ style "border-radius" "5px"
    , style "background-color" "#f2f2f2"
    , style "padding" "20px"
    , style "width" "300px"
    ]


inputStyle : List (Attribute msg)
inputStyle =
    [ style "display" "block"
    , style "width" "260px"
    , style "padding" "12px 20px"
    , style "margin" "8px 0"
    , style "border" "none"
    , style "border-radius" "4px"
    ]


buttonStyle : List (Attribute msg)
buttonStyle =
    [ style "width" "300px"
    , style "background-color" "#397cd5"
    , style "color" "white"
    , style "padding" "14px 20px"
    , style "margin-top" "10px"
    , style "border" "none"
    , style "border-radius" "4px"
    , style "font-size" "16px"
    ]
----

Apply these styles to the respective tags in the `view` function.

[source,elm]
----
view : User -> Html msg
view user =
    div []
        [ h1 [ style "padding-left" "3cm" ] [ text "Sign up" ]
        , Html.form formStyle
            [ div []
                [ text "Name"
                , input ([ id "name", type_ "text" ] ++ inputStyle) []
                ]
            , div []
                [ text "Email"
                , input ([ id "email", type_ "email" ] ++ inputStyle) []
                ]
            , div []
                [ text "Password"
                , input ([ id "password", type_ "password" ] ++ inputStyle) []
                ]
            , div []
                [ button ([ type_ "submit" ] ++ buttonStyle)
                    [ text "Create my account" ]
                ]
            ]
        ]
----

Refresh the page at http://localhost:8000/src/Signup.elm[`+http://localhost:8000/src/Signup.elm+`] and you should see a much better looking sign-up form.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-inline-styled.png[]

****
NOTE: The best practice for working with HTML suggests that the styles should primarily be specified in CSS files. Therefore, we shouldn’t use too many inline styles.
****

[[2-using-the-elm-css-package]]
==== 2. Using the `+elm-css+` Package

It’s convenient to style elements inline. However, if we make a mistake typing one of the properties, the Elm compiler won’t catch it because they’re just plain old strings. Wouldn’t it be great if we could use Elm’s type system to detect errors in our CSS too? That’s exactly what the `+elm-css+` package offers.

Let’s re-implement the styles we applied above using functions defined in the `Css` module included in the `+elm-css+` package. Before we can do that though, we need to install the package. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install rtfeldman/elm-css
----

Answer `y` when asked to add `+rtfeldman/elm-css+` and other packages to `elm.json` file. `+elm-css+` is a complex package with more than a dozen modules in it, but we’re interested in only three of them:

* `Css`
* `Html.Styled`
* `+Html.Styled.Attributes+`

===== Css Module

The `Css` module enables us to apply CSS styles using plain old Elm functions. For example, if we want to give a blue background to a button, we can use the `backgroundColor` and `hex` functions defined in the `Css` module like this:

[source,elm]
----
backgroundColor (hex "#397cd5")
----

For comparison, here is how we used the `style` function earlier to do exactly that:

[source,elm]
----
style "background-color" "#397cd5"
----

If we make a mistake while typing a function name from the `CSS` module, the Elm compiler will throw an error. However, if we introduce a typo in the CSS property name passed to the `style` function, the compiler can’t help us. By taking advantange of Elm’s powerful <<type-system, type system>>, we can get rid of so many CSS related bugs during compile time. Isn’t that nice? Let’s import the `Css` module in `Signup.elm`.

[source,elm]
----
module Signup exposing (User)

import Css exposing (..)
.
.
----

[[htmlstyled-module]]
===== Html.Styled Module

`Html.Styled` is a drop-in replacement for the `Html` module from the `+elm/html+` package. All it does is return a _styled_ version of elements defined in the `Html` module. For example, here is how the `Html.text` function is implemented.

[source,elm]
----
text : String -> Html msg
text =
    VirtualDom.text
----

Remember all HTML elements in Elm are virtual DOM nodes behind the scenes. Let’s compare the implementation above with that of `+Html.Styled.text+`.

[source,elm]
----
text : String -> Html msg
text =
    VirtualDom.Styled.text
----

As you can see, the only difference is that `+Html.Styled.text+` returns a styled node whereas `Html.text` returns a plain old node. Let’s import `Html.Styled` in `Signup.elm` and remove the line that imports the `Html` module.

[source,elm]
----
module Signup exposing (User)

import Html.Styled exposing (..)
.
.
----

We can now create styled elements in our app like this:

[source,elm]
----
styledForm : List (Attribute msg) -> List (Html msg) -> Html msg
styledForm =
    styled Html.Styled.form
        [ borderRadius (px 5)
        , backgroundColor (hex "#f2f2f2")
        , padding (px 20)
        , Css.width (px 300)
        ]


styledInput : List (Attribute msg) -> List (Html msg) -> Html msg
styledInput =
    styled Html.Styled.input
        [ display block
        , Css.width (px 260)
        , padding2 (px 12) (px 20)
        , margin2 (px 8) (px 0)
        , border (px 0)
        , borderRadius (px 4)
        ]


styledButton : List (Attribute msg) -> List (Html msg) -> Html msg
styledButton =
    styled Html.Styled.button
        [ Css.width (px 300)
        , backgroundColor (hex "#397cd5")
        , color (hex "#fff")
        , padding2 (px 14) (px 20)
        , marginTop (px 10)
        , border (px 0)
        , borderRadius (px 4)
        , fontSize (px 16)
        ]
----

Add that code below `view` in `Signup.elm` and also remove the `formStyle`, `inputStyle`, and `buttonStyle` functions while we’re at it. To style an element using `+elm-css+`, we need to use the `styled` function defined in the `Html.Styled` module. Here is how its type signature looks:

[source,elm]
----
styled :
    (List (Attribute a) -> List (Html b) -> Html msg)
    -> List Style
    -> List (Attribute a)
    -> List (Html b)
    -> Html msg
----

The first argument is an HTML element from the `Html.Styled` module. We can’t use the one defined in `Html`. The second argument is a list of CSS styles. Each style is represented by the `Style` type defined in the `Css` module we covered earlier. Now that we have styled the `form`, `input`, and `button` elements separately, let’s use them in our `view` function.

[source,elm]
----
view : User -> Html msg
view user =
    div []
        [ h1 [ style "padding-left" "3cm" ] [ text "Sign up" ]
        , styledForm []
            [ div []
                [ text "Name"
                , styledInput [ id "name", type_ "text" ] []
                ]
            , div []
                [ text "Email"
                , styledInput [ id "email", type_ "email" ] []
                ]
            , div []
                [ text "Password"
                , styledInput [ id "password", type_ "password" ] []
                ]
            , div []
                [ styledButton [ type_ "submit" ]
                    [ text "Create my account" ]
                ]
            ]
        ]
----

[[htmlstyledattributes-module]]
===== Html.Styled.Attributes Module

To style the header, we’ll use the `css` function from the `+Html.Styled.Attributes+` module like this:

[source,elm]
----
view : User -> Html msg
view user =
    div []
        [ h1 [ css [ paddingLeft (cm 3) ] ] [ text "Sign up" ]
        .
        .
----

We’re still inlining our style here, but we’re using an Elm function to specify the `+padding-left+` CSS property. Here’s how the `css` function’s type signature looks:

[source,elm]
----
css : List Style -> Html.Styled.Attribute msg
----

`+Html.Styled.Attributes+` is a drop-in replacement for the `Html.Attributes` module from the `+elm/html+` package. Let’s import it in `Signup.elm` and remove the line that imports `Html.Attributes`.

[source,elm]
----
module Signup exposing (User)

import Html.Styled.Attributes exposing (..)
.
.
----

The `id` and `type_` attributes used inside the `view` function are now from `+Html.Styled.Attributes+` instead of `Html.Attributes`.

===== Rendering Styled Elements

All of our HTML elements and their attributes now come from the `Html.Styled` and `+Html.Styled.Attributes+` modules respectively. Elm doesn’t know how to render them. Luckily, the `Html.Styled` module provides a function called `toUnstyled` for converting the styled elements to something Elm can render. Here is how its type signature looks:

[source,elm]
----
toUnstyled : Html msg -> Virtual.Node msg
----

Modify `main` in `Signup.elm` to this:

[source,elm]
----
main : VirtualDom.Node msg
main =
    toUnstyled <| view initialModel
----

`main`’s type is now `+VirtualDom.Node msg+`. Before using `+elm-css+` it was `+Html msg+`. The definition of the `Html` type reveals that it’s just a type alias for `VirtualDom.Node`.

[source,elm]
----
type alias Html msg =
    VirtualDom.Node msg
----

Because of this, we are allowed to return a virtual DOM node directly from `main`. Let’s install the `+elm/virtual-dom+` package by running the following command from the `+beginning-elm+` directory.

[source,bash]
----
$ elm install elm/virtual-dom
----

Actually, that package is already installed as an `indirect` dependency. Answer `y` to make it a `direct` dependency. Now import the `VirtualDom` module in `Signup.elm`.

[source,elm]
----
module Signup exposing (User)

import VirtualDom
.
.
----

Finally, we’re ready to run our app. Refresh the page at http://localhost:8000/src/Signup.elm[`+http://localhost:8000/src/Signup.elm+`] and you should see the exact same form as before.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-inline-styled.png[]

[[3-using-an-external-css-file]]
==== 3. Using an External CSS File

The third option is to create a regular CSS file and use it in our Elm app. Unfortunately, `+elm reactor+` doesn’t provide an easy way to load external CSS files, so we’ll have to compile the `Signup.elm` file manually. Create a new file called `+signup-style.css+` in the `+beginning-elm+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/create-signup-style-css-file.png[]

[source,css]
----
h1 {
    padding-left: 3cm;
}

form {
    border-radius: 5px;
    background-color: #f2f2f2;
    padding: 20px;
    width: 300px;
}

input {
    display: block;
    width: 260px;
    padding: 12px 20px;
    margin: 8px 0;
    border: none;
    border-radius: 4px;
}

button {
    width: 300px;
    background-color: #397cd5;
    color: white;
    padding: 14px 20px;
    margin-top: 10px;
    border: none;
    border-radius: 4px;
    font-size: 16px;
}
----

Next, we’ll use `+elm make+` to compile the `Signup.elm` file. Before we do that, we need to remove all traces of `+elm-css+` from that file. Remove the `styledForm`, `styledInput`, and `styledButton` functions and modify `view` to this:

[source,elm]
----
view : User -> Html msg
view user =
    div []
        [ h1 [] [ text "Sign up" ]
        , Html.form []
            [ div []
                [ text "Name"
                , input [ id "name", type_ "text" ] []
                ]
            , div []
                [ text "Email"
                , input [ id "email", type_ "email" ] []
                ]
            , div []
                [ text "Password"
                , input [ id "password", type_ "password" ] []
                ]
            , div []
                [ button [ type_ "submit" ]
                    [ text "Create my account" ]
                ]
            ]
        ]
----

We’re back to where our sign-up form had no style at all. Remove `toUnstyled` from `main` and also change its type signature.

[source,elm]
----
main : Html msg
main =
    view initialModel
----

And replace the import list in `Signup.elm` with the following.

[source,elm]
----
module Signup exposing (User)

import Html exposing (..)
import Html.Attributes exposing (..)
.
.
----

We’re now ready to compile `Signup.elm` to JavaScript. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/Signup.elm --output signup.js
----

`+elm make+` will create a new file called `signup.js` in the `+beginning-elm+` directory. If it already exists, its contents will be overwritten. The final step is to create an HTML file that loads the `+signup-style.css+` and `signup.js` files. Create a new file called `signup.html` in the `+beginning-elm+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/create-signup-html-file.png[]

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="signup-style.css">
  </head>

  <body>
    <div id="elm-app-is-loaded-here"></div>    
    <script src="signup.js"></script>
    <script>
      var app = Elm.Signup.init({
        node: document.getElementById("elm-app-is-loaded-here")
      });      
    </script>
  </body>
</html>
----

The code for loading the `+signup-style.css+` file is straightforward, but the one that loads our Elm app is slightly more complex. First, we need to load the `signup.js` file, which contains the compiled JavaScript code. Remember, the `signup.js` file includes not only the code we wrote, but also the entire Elm runtime and all the other Elm packages we installed.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/compile-signup-elm-to-javascript.svg[]

We created a `div` and gave it an `id`. We then asked the Elm runtime to load our app inside the `+elm-code-is-loaded-here+` div. When we call the `+Elm.Signup.init+` function, the runtime looks for the `main` function inside the `Signup` module and uses it as an entry point. If the `Signup` module is missing, or if the `Signup` module exists, but doesn’t have the `main` function, we’ll get an error. If you open the `+beginning-elm/signup.html+` file in a browser, you should see the exact same form as before.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-inline-styled.png[]

Loading CSS from an external file forced us to take a few more steps, but it also enabled us to use any CSS file in our Elm app. This approach will come in handy if you are planning to introduce Elm into your existing app that already contains numerous CSS files.

[[4-using-a-css-framework]]
==== 4. Using a CSS Framework

It’s also possible to use a CSS framework with Elm apps. It’s actually very similar to using an external CSS file. Back in the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section, we used the popular http://getbootstrap.com/[Bootstrap] framework to style the home page of Dunder Mifflin. Let’s use it here again to style our sign-up form. Modify the `signup.html` file to include the Bootstrap framework instead of the `+signup-style.css+` file.

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" 
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  </head>

  <body>
    <div id="elm-app-is-loaded-here"></div>    
    <script src="signup.js"></script>
    <script>
      var app = Elm.Signup.init({
        node: document.getElementById("elm-app-is-loaded-here")
      });      
    </script>
  </body>
</html>
----

Next, we need to specify which CSS classes we want to use in our Elm code. Modify the `view` function in `Signup.elm` like this:

[source,elm]
----
view : User -> Html msg
view user =
    div [ class "container" ]
        [ div [ class "row" ]
            [ div [ class "col-md-6 col-md-offset-3" ]
                [ h1 [ class "text-center" ] [ text "Sign up" ]
                , Html.form []
                    [ div [ class "form-group" ]
                        [ label
                            [ class "control-label"
                            , for "name"
                            ]
                            [ text "Name" ]
                        , input
                            [ class "form-control"
                            , id "name"
                            , type_ "text"
                            ]
                            []
                        ]
                    , div [ class "form-group" ]
                        [ label
                            [ class "control-label"
                            , for "email"
                            ]
                            [ text "Email" ]
                        , input
                            [ class "form-control"
                            , id "email"
                            , type_ "email"
                            ]
                            []
                        ]
                    , div [ class "form-group" ]
                        [ label
                            [ class "control-label"
                            , for "password"
                            ]
                            [ text "Password" ]
                        , input
                            [ class "form-control"
                            , id "password"
                            , type_ "password"
                            ]
                            []
                        ]
                    , div [ class "text-center" ]
                        [ button
                            [ class "btn btn-lg btn-primary"
                            , type_ "submit"
                            ]
                            [ text "Create my account" ]
                        ]
                    ]
                ]
            ]
        ]
----

Bootstrap defines many CSS classes such as `container`, `row`, `+col-md-6+`, and `+form-group+` that have special meaning. We won’t try to understand what each of these classes mean in this book, but you can learn all about them from the http://getbootstrap.com/getting-started/[official site]. Once you know how Bootstrap works, it’s pretty easy to understand the code above.

The next step is to re-compile `Signup.elm`. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/Signup.elm --output signup.js
----

Now, if you open the `signup.html` file in a browser, you should see this form:

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-styled-with-bootstrap.png[]

One big disadvantage of using an external CSS file or framework in this way is that we lose the ability to detect errors in our CSS code during compile time. The good news is, the Elm community members are working hard to provide Elm packages for making the use of external frameworks such as Bootstrap and https://material.io/guidelines/material-design/introduction.html[Material Design] more reliable through Elm’s type system and other features. The http://elm-bootstrap.info/[`+elm-bootstrap+`] and http://package.elm-lang.org/packages/debois/elm-mdl/latest[`+elm-mdl+`] packages give us the ability to design our pages with Bootstrap and Material Design respectively without sacrificing Elm’s type safety. You should definitely check them out.

For the rest of this section, we’ll use `+elm-css+`, so let’s revert `Signup.elm` back to the following code. This will allow us to keep using `+elm reactor+` instead of recompiling our code with `+elm make+` every time we make a small change.

****
NOTE: There is actually a tool called https://github.com/tomekwi/elm-live[`+elm-live+`] which reloads pages automatically whenever a change is made to them. We’ll cover it in the <<navigating-to-list-posts-page, Using elm-live>> section in chapter 6.
****

[source,elm]
----
module Signup exposing (main)

import Css exposing (..)
import Html.Styled exposing (..)
import Html.Styled.Attributes exposing (..)
import VirtualDom


type alias User =
    { name : String
    , email : String
    , password : String
    , loggedIn : Bool
    }


initialModel : User
initialModel =
    { name = ""
    , email = ""
    , password = ""
    , loggedIn = False
    }


view : User -> Html msg
view user =
    div []
        [ h1 [ css [ paddingLeft (cm 3) ] ] [ text "Sign up" ]
        , styledForm []
            [ div []
                [ text "Name"
                , styledInput [ id "name", type_ "text" ] []
                ]
            , div []
                [ text "Email"
                , styledInput [ id "email", type_ "email" ] []
                ]
            , div []
                [ text "Password"
                , styledInput [ id "password", type_ "password" ] []
                ]
            , div []
                [ styledButton [ type_ "submit" ]
                    [ text "Create my account" ]
                ]
            ]
        ]


styledForm : List (Attribute msg) -> List (Html msg) -> Html msg
styledForm =
    styled Html.Styled.form
        [ borderRadius (px 5)
        , backgroundColor (hex "#f2f2f2")
        , padding (px 20)
        , Css.width (px 300)
        ]


styledInput : List (Attribute msg) -> List (Html msg) -> Html msg
styledInput =
    styled Html.Styled.input
        [ display block
        , Css.width (px 260)
        , padding2 (px 12) (px 20)
        , margin2 (px 8) (px 0)
        , border (px 0)
        , borderRadius (px 4)
        ]


styledButton : List (Attribute msg) -> List (Html msg) -> Html msg
styledButton =
    styled Html.Styled.button
        [ Css.width (px 300)
        , backgroundColor (hex "#397cd5")
        , color (hex "#fff")
        , padding2 (px 14) (px 20)
        , marginTop (px 10)
        , border (px 0)
        , borderRadius (px 4)
        , fontSize (px 16)
        ]


main : VirtualDom.Node msg
main =
    toUnstyled <| view initialModel
----

==== Update

Now that we have presented the initial model to users, what can they do with it? They can enter their name, email, and password into the form and click _Create my account_ to sign up. The first thing we need to figure out is how to store name, email, and password entered by the user in `User` model. The `Html.Events` module from the `+elm/html+` package defines a function called `onInput` that allows us to specify which message should be triggered when the user starts typing into an input text box. Here’s an example:

[source,elm]
----
styledInput 
    [ id "name"
    , type_ "text"
    , onInput SaveName
    ]
----

****
NOTE: The https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/Html-Styled-Events[`+Html.Styled.Events+`] module from the `+elm-css+` package also defines the `onInput` function. Just like `Html.Styled` and `+Html.Styled.Attributes+`, the `+Html.Styled.Events+` module is a drop-in replacement for `Html.Events`.
****

Don’t type the above code yet; we’ll need to add the `onInput` attribute to all of our `input` fields. We’ll do that after we’ve defined the `SaveName` and all other messages needed in our app.

===== Handling Messages

Add the following type definition right above `main` in `Signup.elm`.

[source,elm]
----
type Msg
    = SaveName String
    | SaveEmail String
    | SavePassword String
    | Signup
----

`SaveName`, `SaveEmail`, and `SavePassword` messages will be triggered when the user enters name, email, and password respectively. The `Signup` message will be triggered when the _Create my account_ button is clicked.

We need to tell Elm what to do with these messages. This is where the `update` function comes in. Whenever Elm receives a message, it checks to see if there is a pattern in the `update` function that matches the incoming message. If a pattern does exist, it executes the code for that pattern. Otherwise, the application crashes. Therefore, it’s important to handle all possible incoming messages. Add the `update` function above `main` in `Signup.elm`.

[source,elm]
----
update : Msg -> User -> User
update message user =
    case message of
        SaveName name ->
            { user | name = name }

        SaveEmail email ->
            { user | email = email }

        SavePassword password ->
            { user | password = password }

        Signup ->
            { user | loggedIn = True }
----

The `update` function takes a message and a model (`User` in our case) and performs some operation on that model. It then returns the resulting model. So when users type their name in a text field, Elm receives the `SaveName` message. It finds a pattern that matches this message:

[source,elm]
----
SaveName name ->
    { user | name = name }
----

All we are doing here is saving the name that came in as a payload with the `SaveName` message into the `User` model using the <<record, update record syntax>>. The code for handling messages originated from the `SaveEmail` and `SavePassword` text fields looks very similar. The branch for the `Signup` message simply sets the `loggedIn` flag to `True`. The actual code for handling this message requires us to know how to send HTTP requests to a server in Elm. We haven’t learned that yet, so we’ll have to wait until <<http-requests-intro, chapter 6>> to fully implement it.

===== Creating Messages

We’ve created a mechanism for handling messages, but we still don’t have a way to create them. Let’s take care of that. Add `onInput` and `onClick` to `styledInput` and `styledButton` respectively so that they can fire messages to the runtime.

[source,elm]
----
view : User -> Html Msg
view user =
    div []
        [ h1 [ css [ paddingLeft (cm 3) ] ] [ text "Sign up" ]
        , styledForm []
            [ div []
                [ text "Name"
                , styledInput
                    [ id "name"
                    , type_ "text"
                    , onInput SaveName
                    ]
                    []
                ]
            , div []
                [ text "Email"
                , styledInput
                    [ id "email"
                    , type_ "email"
                    , onInput SaveEmail
                    ]
                    []
                ]
            , div []
                [ text "Password"
                , styledInput
                    [ id "password"
                    , type_ "password"
                    , onInput SavePassword
                    ]
                    []
                ]
            , div []
                [ styledButton
                    [ type_ "submit"
                    , onClick Signup
                    ]
                    [ text "Create my account" ]
                ]
            ]
        ]
----

Previously, the HTML returned by `view` wasn’t creating any messages, so we just used `msg` as a placeholder in its type annotation.

[source,elm]
----
view : Model -> Html msg
view model =
    ...
----

Now, `view` uses the `onInput` and `onClick` functions from the `+Html.Styled.Events+` module to generate messages of type `Msg`. That’s why we needed to change `msg` to `Msg` in `view`’s type annotation. Let’s import `+Html.Styled.Events+` in `Signup.elm`.

[source,elm]
----
module Signup exposing (main)

import Html.Styled.Events exposing (onClick, onInput)
.
.
----

==== Wiring Everything Up

Here is how our `main` looks right now in `Signup.elm`:

[source,elm]
----
main : VirtualDom.Node msg
main =
    toUnstyled <| view initialModel
----

Passing `initialModel` to `view` was enough when we were just displaying a static view. To allow interactivity, we need to add `update` in the mix. Modify `main` to this:

[source,elm]
----
main : Program () User Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = \model -> toUnstyled (view model)
        , update = update
        }
----

And import the `Browser` module in `Signup.elm`.

[source,elm]
----
module Signup exposing (main)

import Browser
.
.
----

When we compare the `main` function in `Signup.elm` to the one in `Counter.elm` from the <<model-view-update-part-1, Model View Update - Part 1>> section, we notice two differences.

*Difference #1:* The type annotation for `main` in `Signup.elm` includes `User` instead of `Model`. That’s because we decided to name our model `User` to make it more descriptive.

[source,elm]
----
-- Signup.elm --

main : Program () User Msg
main =
    ...
----

[source,elm]
----
-- Counter.elm --

main : Program () Model Msg
main =
    ...
----

*Difference #2:* `toUnstyled` is applied before rendering the view in `Signup.elm`.

[source,elm]
----
-- Signup.elm --

view = \model -> toUnstyled (view model)
----

[source,elm]
----
-- Counter.elm --

view = view
----

As mentioned earlier in the <<model-view-update-part-2, Rendering Styled Elements>> section, Elm doesn’t know how to render elements and attributes defined in the `Html.Styled` and `+Html.Styled.Attributes+` modules from the `+elm-css+` package. Therefore, we need to use the `toUnstyled` function to convert them to something Elm can render.

[[using--operator]]
===== Using `+>>+` Operator

We assigned an anonymous function to the `view` field in `Browser.sandbox`. Anonymous functions are a little hard to read by nature. We can simplify `main` in `Signup.elm` by replacing the anonymous function with `+>>+` like this:

[source,elm]
----
main : Program () User Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = view >> toUnstyled
        , update = update
        }
----

`+>>+` is a built-in operator for composing multiple functions. You can think of `+func1 >> func2+` as equivalent to this:

[source,elm]
----
func1 >> func2 == \param -> func2 (fun1 param)
----

We’re now ready to run our app once again. Refresh the page at http://localhost:8000/src/Signup.elm[`+http://localhost:8000/src/Signup.elm+`] and you should see the sign-up form.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-inline-styled.png[]

When the user enters all information and clicks _Create my account_, the resulting model will look like this:

[source,elm]
----
{ name = "Art Vandelay"
, email = "art@vandelayindustries.com"
, password = "opposite"
, loggedIn = True
}
----

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/signup-form-filled.png[]

We don’t get any visual feedback when the _Create my account_ button is clicked because we aren’t sending the user data to a server. We’ll learn how to do that in <<http-requests-intro, chapter 6>>.

==== Summary

In this section, we reinforced our understanding of how the _Model View Update_ pattern works by building a slightly more complex app that allowed users to enter their name, email, and password.

The following diagram shows the interaction between various parts of the sign-up form app which is very similar to the interaction between different components in the counter app we built in <<model-view-update-part-1, Model View Update - Part 1>>.

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/model-view-update-interaction-2.svg[]

We also learned how to style our views in different ways using inline CSS, the `+elm-css+` package, an external CSS file, and an external framework such as Bootstrap. Here is the entire code for building a sign-up form using `+elm-css+`:

[source,elm]
----
module Signup exposing (main)

import Browser
import Css exposing (..)
import Html.Styled exposing (..)
import Html.Styled.Attributes exposing (..)
import Html.Styled.Events exposing (onClick, onInput)
import VirtualDom


type alias User =
    { name : String
    , email : String
    , password : String
    , loggedIn : Bool
    }


initialModel : User
initialModel =
    { name = ""
    , email = ""
    , password = ""
    , loggedIn = False
    }


view : User -> Html Msg
view user =
    div []
        [ h1 [ css [ paddingLeft (cm 3) ] ] [ text "Sign up" ]
        , styledForm []
            [ div []
                [ text "Name"
                , styledInput
                    [ id "name"
                    , type_ "text"
                    , onInput SaveName
                    ]
                    []
                ]
            , div []
                [ text "Email"
                , styledInput
                    [ id "email"
                    , type_ "email"
                    , onInput SaveEmail
                    ]
                    []
                ]
            , div []
                [ text "Password"
                , styledInput
                    [ id "password"
                    , type_ "password"
                    , onInput SavePassword
                    ]
                    []
                ]
            , div []
                [ styledButton
                    [ type_ "submit"
                    , onClick Signup
                    ]
                    [ text "Create my account" ]
                ]
            ]
        ]


styledForm : List (Attribute msg) -> List (Html msg) -> Html msg
styledForm =
    styled Html.Styled.form
        [ borderRadius (px 5)
        , backgroundColor (hex "#f2f2f2")
        , padding (px 20)
        , Css.width (px 300)
        ]


styledInput : List (Attribute msg) -> List (Html msg) -> Html msg
styledInput =
    styled Html.Styled.input
        [ display block
        , Css.width (px 260)
        , padding2 (px 12) (px 20)
        , margin2 (px 8) (px 0)
        , border (px 0)
        , borderRadius (px 4)
        ]


styledButton : List (Attribute msg) -> List (Html msg) -> Html msg
styledButton =
    styled Html.Styled.button
        [ Css.width (px 300)
        , backgroundColor (hex "#397cd5")
        , color (hex "#fff")
        , padding2 (px 14) (px 20)
        , marginTop (px 10)
        , border (px 0)
        , borderRadius (px 4)
        , fontSize (px 16)
        ]


type Msg
    = SaveName String
    | SaveEmail String
    | SavePassword String
    | Signup


update : Msg -> User -> User
update message user =
    case message of
        SaveName name ->
            { user | name = name }

        SaveEmail email ->
            { user | email = email }

        SavePassword password ->
            { user | password = password }

        Signup ->
            { user | loggedIn = True }


main : Program () User Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = view >> toUnstyled
        , update = update
        }
----


[[side-effects]]
=== 5.5 Side Effects


One of the reasons why Elm is so reliable is because we can write our application logic using only _pure_ functions. Pure functions take an input, do some computation, and return an output. That’s their entire job. There is a lot less room for things to go wrong since they don’t perform any other operations that cause side effects, such as sending an HTTP request to a remote server or saving data to a local storage.

****
NOTE: Earlier in the <<pure-functions, Pure Functions>> section, we learned what side effects are in the context of a function. In this section, we’ll learn how they affect an entire application.
****

One of the fundamental rules all pure functions must follow is that _an expression must always evaluate to the same result in any context_. This means we are guaranteed to receive the same output for a given input no matter how many times we apply the function. This allows us to replace all applications of that function with the output it generates throughout our program and achieve the same result.

Wouldn’t our job as programmers be much easier if every line of code we wrote was part of a pure function? Reasoning about what our program does would be much easier. That means we could find the root cause of a bug much more quickly. Testing would also become less painful. We could generate a good sample input set and apply the function under test with values from that set. If the function returned the output we’re expecting, we could be certain that it is behaving as expected.

==== Real World is Messy

Unfortunately, the real world is messy. If we were to write only pure functions, we would most likely end up with useless programs. They wouldn’t be able to take any input from the user or present an output on a screen or retrieve data from a remote server. Why can’t pure functions do that? Because pure functions guarantee that for a given input it will always return the exact same output. So if we have a function that takes someone’s name as an input and attempts to display it on a screen, can we mark that function as _pure_? The answer is no. That function cannot guarantee that the name can be displayed on a screen every time we apply it. That’s because we cannot rely on a screen to be working _all_ the time. Perhaps the driver for a graphics card is not working or the graphics memory is full. There could be any number of other reasons that might cause a screen to not work.

The most common way for a program to interact with the outside world is through _side effects_. The following definition of side effects from Wikipedia explains why they tend to make our application complex and messy.

*Definition:* “A function or expression is said to have a side effect if it modifies some state or has an observable interaction with calling functions or the outside world. For example, a particular function might modify a global variable or static variable, modify one of its arguments, raise an exception, write data to a display or file, read data, or call other side-effecting functions. In the presence of side effects, a program’s behavior may depend on history; that is, the order of evaluation matters. Understanding and debugging a function with side effects requires knowledge about the context and its possible histories.” - https://en.wikipedia.org/wiki/Side_effect_(computer_science)[Wikipedia].

==== Elm Runtime to the Rescue

So how does Elm deal with this conundrum? It employs a rather clever technique to manage side effects originated from interacting with the outside world. To understand this technique, let’s go back to the sign up form example we saw in the <<model-view-update-part-2, Model View Update - Part 2>> section. The `view` function there takes a `User` model and returns some Elm code representing HTML that is capable of generating messages.

[source,elm]
----
view : User -> Html Msg
view user =
    ...
----

It’s crucial to understand that we don’t have to worry about rendering the HTML code or figure out how to route the messages originating from the text fields and buttons to our `update` function. The Elm runtime takes care of that.

One way to look at it is that our code is being placed in a protective cocoon where everything is deterministic. We can always tell what the output will be for a given input. But outside of this cocoon, we can’t tell what output we will get for the same input. The figure below shows how the Elm runtime shields our code from the outside world that is riddled with side effects.

image:https://elmprogramming.com/images/chapter-5/5.5-side-effects/elm-runtime.svg[]

User interface is not the only aspect of outside world that produces side effects. There are others too. Most scenarios in which an Elm app needs to interact with the outside world tend to fall into two categories:

*1. Ask Elm runtime to do something.* Here are some examples:

* Send and receive data from a remote HTTP server.
* Save data to a local storage.
* Generate random numbers.
* Request a JavaScript library to perform an operation

*2. Get notified when something happens.* Here are some examples:

* Listen for web socket messages.
* Listen for geolocation changes.
* Listen for clock ticks.
* Listen for an output generated by a JavaScript library

Elm offers <<commands, commands>> to deal with the scenarios in the first category and <<subscriptions, subscriptions>> to deal with the scenarios in the second category.

==== Everything is Data

As mentioned earlier in the <<model-view-update-part-1, Model View Update - Part 1>> section, the `sandbox` function from the `Browser` module is responsible for wiring our initial model, view, and update functions together.

[source,elm]
----
main : Program () User Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = view
        , update = update
        }
----

We can think of the `sandbox` function as a proxy to the Elm runtime. Even though it takes care of the wiring, in the end it’s the runtime that renders the HTML and routes messages to proper functions. We already saw how the runtime coordinates the interaction between different functions in our code. Here it is again:

image:https://elmprogramming.com/images/chapter-5/5.4-model-view-update-part-2/model-view-update-interaction-2.svg[]

As it turns out the `initialModel`, `view`, and `update` functions don’t talk to each other directly or to the outside world. Elm runtime handles all interactions between them and the outside world. Because of this, those functions can be _pure_. Although the `initialModel` doesn’t take any inputs, it will always return the same record.

[source,elm]
----
initialModel : User
initialModel =
    { name = ""
    , email = ""
    , password = ""
    , loggedIn = False
    }
----

The `view` function will also return the exact same HTML output given the same model. The `update` function might look a little tricky.

[source,elm]
----
update : Msg -> User -> User
update message user =
    case message of
        SaveName name ->
            { user | name = name }

        SaveEmail email ->
            { user | email = email }

        SavePassword password ->
            { user | password = password }

        Signup ->
            { user | loggedIn = True }
----

It takes a message and a model as inputs and returns a new model as an output. The model is just some data. But what about the message? It’s data too. It’s a special type of data that contains information about what action to perform. Similarly <<commands, commands>> and <<subscriptions, subscriptions>>, which we will cover later, are also data.

==== Program as a Data Transformation Machine

Now that you have some background, you can understand the clever technique Elm uses to deal with the outside world: it treats everything in our program as _data_, except the functions that operate on that data. This has profound implications for how we build applications. We can treat our programs as a series of data transformation operations. You take some data (perhaps something user provided), apply a function to transform that data to some other form. Take that and apply a different function to transform it to yet another form. So on and so forth until we have the final output which can be presented back to the user.

This approach to building applications drastically reduces the overall complexity. We will revisit this idea of treating everything as data when we talk about commands and subscriptions later. But for now, hopefully you understand how Elm makes it possible to write all of our logic using _pure_ functions.

image:https://elmprogramming.com/images/chapter-5/5.5-side-effects/data-transformation.svg[]

The rest of this chapter is dedicated to exploring various techniques the Elm runtime uses to deal with the outside world. We’ll start with commands in the next section.


[[commands]]
=== 5.6 Commands


We can use commands to execute operations that may cause side effects. Like messages, commands are also represented as data. Think of them as data structures that store information about an action we want to perform. We then hand that data structure over to the Elm runtime. The runtime will execute the action specified in the command and notify our application with a result. That sounds really vague, doesn’t it? Let’s look at an example for generating random numbers to make things a bit more concrete.

==== Generating Random Numbers

There are two main approaches to generating random numbers: _True Random Number Generators (TRNGs)_ and _Pseudo-Random Number Generators (PRNGs)_. TRNGs generate numbers from truly random physical phenomena, for example the little variations in someone’s mouse movements or the point in time at which a radioactive material decays or the atmospheric noise picked up by a radio.

Due to their reliance on a physical phenomena, TRNGs take considerably longer time to generate random numbers. Therefore, most computer programs that need random numbers quickly tend to rely on PRNGs which are much more efficient than TRNGs. Despite their efficiency, PRNGs are not suitable for applications that need truly unpredictable random numbers, such as encryption key generators.

PRNGs take an initial value (called seed) and apply an algorithm to generate a seemingly random number. The modern algorithms used by PRNGs are so good that the numbers generated by them look quite random.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/random-number-generation-algorithm-1.svg[]

However, if we use the same initial seed multiple times we will get the exact same number each time.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/random-number-generation-algorithm-2.svg[]

==== Generating Random Numbers without Side Effects

Let’s explore this behavior of PRNGs further by entering some code in `+elm repl+`. But first we need to install the `+elm/random+` package. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install elm/random
----

The `+elm-explorations/test+` package we used earlier in the <<easy-to-test, Easy to Test>> section depends on `+elm/random+`. That’s why when we installed it, `+elm/random+` was automatically added as an `indirect` dependency to the `+test-dependencies+` field in `elm.json`. Now `+elm install+` is asking us if it’s okay to move it to the `dependencies` field. Go ahead and answer `y`.

All packages in the `dependencies` field are also available in tests, so we’ll still be able to run our tests without any issues. Run `+elm repl+` from the `+beginning-elm+` directory in terminal and import the `Random` module included in `+elm/random+`.

[source,elm]
----
> import Random
----

We’re now ready to generate an initial seed.

[source,elm]
----
> seed0 = Random.initialSeed 31415
Seed 1947881085 1013904223 : Random.Seed
----

The `initialSeed` function takes an integer and returns a seed. We randomly picked the number `31415` as an input. Here’s what the `initialSeed` function’s type signature looks like:

[source,elm]
----
initialSeed : Int -> Seed
----

The `Seed` type is defined in the `Random` module like this:

image:https://elmprogramming.com/images/chapter-5/5.6-commands/seed-type-signature.svg[]

===== Opaque Type

`Seed` is an _opaque type_. Opaque types use the same name for <<type-system, type and data constructors>> to hide internal details. Let’s explore this idea further by creating a new file called `Profile.elm` in the `+beginning-elm/src+` directory.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/create-profile-file.png[]

Add the following code to `Profile.elm`.

[source,elm]
----
module Profile exposing (Name)


type alias Name =
    { firstName : String
    , lastName : String
    }
----

`Name` is a type alias to a record with two fields. Since we exposed it in the module definition, any code outside of `Profile` can access it. The `firstName` and `lastName` fields are also accessible from outside. Let’s test that assertion in `+elm repl+`.

[source,elm]
----
> import Profile exposing (..)
    
> tobias = Name "Tobias" "Funke"
{ firstName = "Tobias", lastName = "Funke" }
    : Name

> tobias.firstName
"Tobias" : String

> tobias.lastName
"Funke" : String
----

What if we don’t want the outside code to know how the `Name` type is implemented? We may want to add middle name to our definition in the future. The way things are right now, the code that uses `Name` will certainly break if we introduce a new field. How about we re-implement `Name` as an opaque type like this in `Profile.elm`:

[source,elm]
----
module Profile exposing (Name)


type Name
    = Name String String
----

Now any code outside of `Profile.elm` won’t be able to access the internal fields (`firstName` and `lastName`) like it used to. Let’s try to create a name using the new opaque type.

[source,elm]
----
> tobias = Name "Tobias" "Funke"

---------- NAMING ERROR -----------
I cannot find a `Name` constructor:

4| tobias = Name "Tobias" "Funke"
            ^^^^
----

Unfortunately, we lost the ability to create a name. We can expose the underlying data constructor by adding `+(..)+` next to `Name` in module definition like this:

[source,elm]
----
module Profile exposing (Name(..))


type Name
    = Name String String
----

And that will allow us to create a name using the `Name` data constructor.

[source,elm]
----
> tobias = Name "Tobias" "Funke"
Name "Tobias" "Funke" : Name
----

However, exposing the underlying data constructor defeats the purpose. We want to hide the internal details of our type and still be able to create a name. To do that, we need to introduce a new function whose sole purpose is to create a name. Remove `+(..)+` from the module definition and add a new function called `createName` to `Profile.elm`.

[source,elm]
----
module Profile exposing (Name, createName)


type Name
    = Name String String


createName : String -> String -> Name
createName firstName lastName =
    Name firstName lastName
----

Restart `+elm repl+` and enter the following code.

[source,elm]
----
> import Profile exposing (..)

> tobias = createName "Tobias" "Funke"
Name "Tobias" "Funke" : Name
----

Now we can create a name from outside `Profile` without having to know the internal details of `Name`.

===== Back to Seed

The `Random` module applies the same technique used in `Profile.elm` to hide the internal details of `Seed` while also allowing us to create a seed using the `initialSeed` function.

[source,elm]
----
> import Random

> seed0 = Random.initialSeed 31415
Seed 1947881085 1013904223 : Random.Seed
----

Now that we have an initial seed, we can use the `Random.step` function to generate a random value.

[source,elm]
----
> Random.step (Random.int 0 100) seed0
(35,Seed 1195359672 1013904223)
    : ( Int, Random.Seed )
----

The output is a tuple. The first element is a random number and the second element is the seed we can use to generate the next random number. As mentioned earlier, we need to provide a different seed to the `step` function each time we want to generate a new random number. Otherwise, we keep getting the same number over and over again. That’s why the `step` function returns a new seed in addition to a random number.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/random-step-function-syntax.svg[]

`step` takes a random number generator and a seed as inputs. Here’s what its type signature looks like:

[source,elm]
----
step : Generator a -> Seed -> (a, Seed)
----

The `+Random.int 0 100+` expression we typed into the repl earlier creates a generator that produces random 32-bit integers between `0` and `100`.

[source,elm]
----
> Random.int 0 100
Generator <function> : Random.Generator Int
----

It’s important to understand that the `Random.int` function itself doesn’t generate a random number. It returns a _generator_ which can be passed to other functions such as `step` that will in turn ask that generator to produce the actual random numbers.

Think of a generator as a recipe for generating certain types of random values. So `+Random.int 0 100+` describes how to create a recipe for generating integers between `0` and `100`. Similarly, `+Random.float 0 1+` describes how to create a recipe for generating floating-point numbers between `0` and `1`.

Next, we’ll capture the new seed returned by the `step` function so that we can use it to generate a different random number.

[source,elm]
----
> result = Random.step (Random.int 0 100) seed0
(35,Seed 1195359672 1013904223)
    : ( Int, Random.Seed )

> randomNumber = Tuple.first result
35 : Int

> newSeed = Tuple.second result
Seed 1195359672 1013904223 : Random.Seed
----

Now, we’re ready to generate a new random number.

[source,elm]
----
> Random.step (Random.int 0 100) newSeed
(91,Seed 3342525879 1013904223)
    : ( Int, Random.Seed )
----

This time we got `91` as the new number. Last time it was `35`. The numbers inside the `Seed` type also changed. If those numbers didn’t change we would get the same random number again and again. What this means is that `Random.step` is a _pure function_ and doesn’t generate any side effects. It returns the exact same output given the same input.

==== Generating Random Numbers with Side Effects

The process of manually providing seed values, as we’ve done so far, has some drawbacks. First, it is cumbersome. Second, it makes the random number sequence predictable. Elm provides a way to get rid of these hurdles by picking an unpredictable initial seed value by default. It does so by using the current time generated by a https://en.wikipedia.org/wiki/Real-time_clock[real-time clock] embedded in our computers to produce seed values.

As soon as we transfer the responsibility of picking the initial seed value to the Elm runtime, the random number generation process causes side effects. To get the initial seed value, it has to now interact with a real-time clock, which is part of the outside world. This is where commands come in handy.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/get-current-time.svg[]

To generate random numbers with side effects we need to follow the Elm Architecture. It’s hard to write a full fledged program in repl, so we’ll create a new file called `RandomNumber.elm` in the `+beginning-elm/src+` directory.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/create-random-number-elm.png[]

==== Model

The first thing we need to define is our model. Add the following code to `RandomNumber.elm`.

[source,elm]
----
module RandomNumber exposing (Model)


type alias Model =
    Int
----

All we need to keep track of here is a number. The above model looks exactly like the one we defined for the counter app in <<model-view-update-part-1, Model View Update - Part 1>>. Next, we need to create an initial model. Add the following code to the bottom of `RandomNumber.elm`.

[source,elm]
----
init : ( Model, Cmd msg )
init =
    ( 0, Cmd.none )
----

When commands are involved, the code for initializing our model becomes a little more complex. In the counter app, all we had to do was return an integer as shown below.

[source,elm]
----
initialModel : Model
initialModel =
    0
----

Let’s go through each change one by one.

*Change #1:* The function name changed from `initialModel` to `init` since we’re doing more than just initializing a model.

*Change #2:* The `init` function now returns a tuple. The first element represents the model and the second element represents commands. In addition to providing an initial value for the model, we need to tell the runtime what commands to run when the app is being loaded. Since we don’t want to run any commands during initialization, we simply return `Cmd.none`. The `Cmd` type represents commands in Elm. It’s defined in the https://package.elm-lang.org/packages/elm/core/latest/Platform-Cmd[`Platform.Cmd`] module. `none` is a constant which returns an empty list of commands. It’s also defined in the `Platform.Cmd` module.

Let’s say when our app is launched we need to restore its state from a remote server which lies outside the boundary of our app. In this scenario, we need to rely on the Elm runtime to retrieve the state by returning a command from `init`.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/reload-state.svg[]

*Change #3:* The type annotation has also changed to `+init : ( Model, Cmd msg )+`. We already know what `Model` is. `+Cmd msg+` means a command that will
notify our app with results by sending messages of type `msg`. `msg` is just a type variable, so it doesn’t represent a concrete type. Later in this section, we’ll define a type called `Msg` to be more specific about which messages our app can accept.

==== View

Next, we need to present the initial model to the user. Add the following code to the bottom of `RandomNumber.elm`.

[source,elm]
----
view : Model -> Html msg
view model =
    div []
        [ button [] [ text "Generate Random Number" ]
        , text (String.fromInt model)
        ]
----

Our view is very simple. All we’re displaying is a button and the string representation of a random number. We also need to import the `Html` module in `RandomNumber.elm`.

[source,elm]
----
module RandomNumber exposing (Model)

import Html exposing (..)
.
.
----

==== Update

Right now, the _Generate Random Number_ button doesn’t do anything. Let’s define a message that will get triggered when that button is clicked. Add the following type definition to the bottom of `RandomNumber.elm`.

[source,elm]
----
type Msg
    = GenerateRandomNumber
----

To respond to the `GenerateRandomNumber` message, we need to introduce `update`. Add the following code to the bottom of `RandomNumber.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GenerateRandomNumber ->
            ( model, Random.generate NewRandomNumber (Random.int 0 100) )
----

Notice how `update` and `init` (or `initialModel` in the previous sections) tend to have the same return types. Here is `update` from the counter app for comparison:

[source,elm]
----
update : Msg -> Model -> Model
update msg model =
    case msg of
        Increment ->
            model + 1

        Decrement ->
            model - 1
----

Let’s understand what’s going on in the body of the new `update` function. When the `GenerateRandomNumber` message is received, we return an unmodified model and a command for generating a random number. The command is generated by using the `generate` function defined in the `Random` module.

****
NOTE: In Elm, we don’t tend to use some constructor function defined in the `Platform.Cmd` module to create commands. Instead, we rely on functions like `generate`. Here’s another example: let’s say we want to create a command that sends an HTTP request to a remote server. We can use the https://package.elm-lang.org/packages/elm/http/1.0.0/Http#send[`Http.send`] function to generate that command. We just look for an appropriate function in a module and use it to create a command.
****

`generate` tries to achieve the same goal as the `step` function — generate a random number. The way it goes about achieving that goal, however, is very different. `step` uses a generator and a seed to return a random number instantly.

[source,elm]
----
> Random.step (Random.int 0 100) seed0
----

`generate` on the other hand, takes a generator and tells the Elm runtime to run that generator. It also tells the runtime which message to send when a number is ready. We haven’t defined the `NewRandomNumber` message yet; we’ll do that soon.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/random-generate-function-syntax.svg[]

Why do we have to supply a message name to `generate`? Why can’t it just return a random number immediately like `step` did? It’s due to
the fact that we aren’t manually providing an initial seed value anymore. We need to generate a seed by using our computer’s clock, which produces side effects.

To run things that generate side effects, Elm requires us to create a command along with any pertinent information that command needs. We then hand that command over to the runtime. The runtime executes the command and notifies our application with the result by sending the message included in the command. The following diagram illustrates this process.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/elm-runtime-interaction-command.svg[]

Here’s what the `generate` function’s type signature looks like:

[source,elm]
----
generate : (a -> msg) -> Generator a -> Cmd msg
----

The first argument is a function that takes a value and wraps it in a message. In our case, that’s `NewRandomNumber`. Remember, <<type-system, messages that take an argument are essentially functions>>. If you check the type of `NewRandomNumber` in repl, you will see that it takes an integer and returns a message of type `Msg`.

[source,elm]
----
> type Msg = NewRandomNumber Int

> NewRandomNumber
<function> : Int -> Msg
----

The second argument to `generate` is a random number generator. In our case, it’s `Random.int`, which takes the range as inputs (e.g., `+0 100+`). Lastly, `generate` returns a command that encapsulates the message and the generator. The next step is to add `NewRandomNumber` to the `Msg` type and also handle it in the `update` function as shown below.

[source,elm]
----
type Msg
    = GenerateRandomNumber
    | NewRandomNumber Int


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GenerateRandomNumber ->
            ( model, Random.generate NewRandomNumber (Random.int 0 100) )

        NewRandomNumber number ->
            ( number, Cmd.none )
----

When the `NewRandomNumber` message is received, we simply return the number in payload as our model and an empty list of commands. Let’s import the `Html.Events` and `Random` modules next and add an `onClick` attribute to our button so that the `GenerateRandomNumber` message gets triggered when it’s clicked.

[source,elm]
----
module RandomNumber exposing (Model)

import Html exposing (..)
import Html.Events exposing (onClick)
import Random

.
.
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick GenerateRandomNumber ]
            [ text "Generate Random Number" ]
        , text (String.fromInt model)
        ]
----

Don’t forget to replace `msg` with `Msg` in `view`’s type annotation. We actually need to make that replacement in `init` as well.

[source,elm]
----
init : ( Model, Cmd Msg )
init =
    ...
----

==== Wiring Everything Up

Let’s wire up everything we have built so far by adding `main` to the bottom of `RandomNumber.elm`.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.element
        { init = \flags -> ( initialModel, Cmd.none )
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----

With the introduction of commands, `main` also became slightly more complex. Here’s how it was in the counter app:

[source,elm]
----
main : Program () Model Msg
main =
    Browser.sandbox
        { init = initialModel
        , view = view
        , update = update
        }
----

Let’s go through each change one by one.

*Change #1:* We’re now using `Browser.element` instead of `Browser.sandbox` to wire everything up. The former takes a record with four fields whereas the latter takes a record with only three fields.

Browser.sandbox vs Browser.element::
  `Browser.sandbox` creates an Elm program that cannot communicate with the outside world by issuing commands. That’s why the <<model-view-update-part-1, counter app’s update function>> returns only a model and no commands.
+
`+update : Msg -> Model -> Model+`
+
In contrast, Elm programs created with `Browser.element` are able to communicate with the outside world. That’s why the <<commands, random number app’s update function>> returns a tuple containing a model and commands.
+
`+update : Msg -> Model -> ( Model, Cmd Msg )+`
+
When you’re building an Elm app, it’s good to start with `Browser.sandbox` and wait for a use case that requires the app to communicate with the outside world. Once that use case arrives, you can upgrade to `Browser.element`.

*Change #2:* The `init` field in `Browser.element` expects a function that takes `flags` and returns a tuple containing model and commands. The <<commands, `init`>> function we wrote earlier returns just the tuple. Let’s use it here, but before we do that let’s clean things up a bit by moving `flags` to the `init` function.

[source,elm]
----
init : flagsType -> ( Model, Cmd Msg )
init flags =
    ( 0, Cmd.none )
----

If we want to pass values to an Elm app during initialization we need to send them as `flags`. The `RandomNumber` app doesn’t need `flags`, but the `Browser.element` function expects us to include it in our `init` function anyway. In <<retrieving-app-state, chapter 8>>, we’ll implement a feature that actually uses `flags`.

Since we aren’t passing any flags to our app, we don’t know what its type should be. That’s why we used the `flagsType` type variable to indicate it can be anything. Although a type variable is fine, it’s better to use `+()+` — <<easy-to-test, the unit type>> — instead for an unused parameter’s type. So let’s replace `flagsType` with `+()+`. Let’s also replace `flags` with `_` since that parameter isn’t being used anywhere inside `init`’s body.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( 0, Cmd.none )
----

****
NOTE: If you don’t remember the difference between `+()+` and `_`, go ahead and refresh your memory by reviewing the <<easy-to-test, Unit Type vs Underscore>> section from chapter 4.
****

Now replace the anonymous function in `Browser.element` with `init`.

[source,elm]
----
Browser.element
    { init = init
    .
    .
----

*Change #3:* `subscriptions` represents things we want to listen to, for example web socket messages and location changes. By assigning `+\_ -> Sub.none+`, we let the Elm runtime know that we aren’t interested in listening to anything right now. We’ll cover <<subscriptions, subscriptions>> in detail later in chapter 8. The only thing remaining is to import the `Browser` module.

[source,elm]
----
module RandomNumber exposing (main)

import Browser
.
.
----

We’re now ready to test our app. Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already, and go to this URL in your browser: http://localhost:8000/src/RandomNumber.elm[`+http://localhost:8000/src/RandomNumber.elm+`]. You should see a view that looks like this:

image:https://elmprogramming.com/images/chapter-5/5.6-commands/generate-random-number-page.png[]

Click the _Generate Random Number_ button multiple times and you should see a different number each time.

==== Summary

In this section, we learned how to use commands to execute operations that cause side effects. Here is how the Elm Architecture looks with the introduction of commands:

image:https://elmprogramming.com/images/chapter-5/5.6-commands/model-view-update-commands.svg[]

The interaction between the Elm runtime and our code has also become a bit more complex now that we are using commands. The sequence diagram below shows that interaction.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/elm-runtime-mvu-commands.svg[]

Commands are an important concept in Elm. We need to understand them well in order to build complex applications. In <<http-requests-intro, chapter 6>>, we’ll continue to explore how commands can help us execute one of the most common operations performed in web apps — sending and receiving data from an HTTP server — without sacrificing our application code’s purity. Here is the entire code from `RandomNumber.elm`:

[source,elm]
----
module RandomNumber exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)
import Random


type alias Model =
    Int


init : () -> ( Model, Cmd Msg )
init _ =
    ( 0, Cmd.none )


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick GenerateRandomNumber ]
            [ text "Generate Random Number" ]
        , text (String.fromInt model)
        ]


type Msg
    = GenerateRandomNumber
    | NewRandomNumber Int


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GenerateRandomNumber ->
            ( model, Random.generate NewRandomNumber (Random.int 0 100) )

        NewRandomNumber number ->
            ( number, Cmd.none )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[elm-architecture-conclusion]]
=== 5.7 Conclusion


In this chapter, we learned how to properly manage data flow in our apps by following the Elm Architecture which boils down to three fundamental concepts: model, view, and update.

A model represents the state of our app. The `view` function takes a model and returns a list of HTML functions. The virtual DOM converts those functions into real HTML nodes and renders them on a screen. When the user generates an event by interacting with an HTML element, the Elm Runtime sends a message to the `update` function. After processing the message, the `update` function returns a new model back to the Elm Runtime which sends the new model to `view` to render it again. This cycle continues until the app is terminated.

image:https://elmprogramming.com/images/chapter-5/5.2-model-view-update-part-1/model-view-update.svg[]

To keep the purity of our application code intact, the Elm Runtime manages all side effects for us. If we need to perform an operation that causes a side effect such as generating a random number or fetching data from a remote HTTP server, all we need to do is create a command and hand it over to the runtime. The runtime will figure out how to execute that command and will notify the `update` function in our app with the result.

image:https://elmprogramming.com/images/chapter-5/5.6-commands/model-view-update-commands.svg[]

There is one more piece to the Elm Architecture puzzle: subscription. We’ll have to wait until chapter 8 to find out <<subscriptions, how subscriptions work>>. In the next chapter, we’ll learn how to send and receive data from an HTTP server using commands.


[[http-requests-intro]]

== 6 HTTP Requests

=== 6.1 prelude

Most Elm apps need to create, read, update, and delete data from a server. In this chapter, we will learn how to do just that by following the https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol[HTTP] protocol. Elm provides built-in modules for interacting with an HTTP server. We’ll also learn how to decode JSON and retrieve data when the app is being initialized.


[[fetching-data-using-get]]
=== 6.2 Fetching Data Using GET


In this section, we’ll try to understand the process a typical Elm app goes through to retrieve data from an HTTP server. We’ll first create a simple HTTP server on our local computer. After that, we’ll build an Elm app that will fetch data from that server.

==== Creating a Local HTTP Server

There are many different ways to create an HTTP server on our local computer. We’ll use the NPM package called https://www.npmjs.com/package/http-server[http-server], which allows us to serve static files. Static files are files that are served to the user exactly as they are stored, without any changes due to the user’s input or preferences. Go ahead and install it globally using the `+-g+` option so that it can be run from anywhere in the terminal.

[source,bash]
----
$ npm install http-server -g
----

Now create a file called `+old-school.txt+` inside a new directory called `server`, which should be placed in the `+beginning-elm+` root project directory.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/create-old-school-file.png[]

Add the following text to the `+old-school.txt+` file.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/add-text-to-old-school-file.png[]

We are ready to start an HTTP server. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ http-server server -a localhost -p 5016
----

You should see an output like this:

[source,bash]
----
Starting up http-server, serving server
Available on:
  http://localhost:5016
Hit CTRL-C to stop the server
----

The `+http-server+` command creates, you guessed it, an HTTP server. We give it the name of the directory to serve files from. In our case it’s `server`. The `+-a localhost+` option makes the URL look nicer. Without it, we would have to specify the https://en.wikipedia.org/wiki/IP_address[IP address] of the computer we are coding on like this: http://127.0.0.1:5016[`+http://127.0.0.1:5016+`]. The `+-p 5016+` runs the server on
https://en.wikipedia.org/wiki/Port_(computer_networking)[port] `5016`.

By default, an HTTP server runs on port `8080`. Your computer might be running some other application that already uses that port, so it’s better to run our server on a different port to avoid a conflict. Port `5016` is rarely used by other applications.

If you go to the url http://localhost:5016/old-school.txt[`+http://localhost:5016/old-school.txt+`] on a browser, you should see the contents of the `+old-school.txt+` file.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/show-old-school-file-contents.png[]

This means our local HTTP server is working. Next we’ll write some Elm code to communicate with this server.

==== Fetching Data from an HTTP Server

Elm provides a module called https://package.elm-lang.org/packages/elm/http/latest/Http[`Http`] for sending and receiving data from a server. We installed this module in the <<elm-install, Installing a Package>> section in chapter 2 by running the following command.

[source,bash]
----
$ elm install elm/http
----

If you don’t have it installed already, go ahead and run the above command from the `+beginning-elm+` directory in terminal. Don’t run it from the same terminal window where we ran `+http-server+` earlier. Create a new one. When `+elm install+` asks for your permission, answer `y`.

Here is our strategy: we will first write a simple Elm program to retrieve the contents of the `+old-school.txt+` file. We will then parse this comma-separated string to extract the nicknames of the main characters from https://en.wikipedia.org/wiki/Old_School_(film)[Old School] — a cult classic — and display those nicknames on a page. Let’s start by creating a new file called `HttpExamples.elm` in the `+beginning-elm/src+` directory.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/create-http-examples-file.png[]

==== Model

As usual, the first thing we will define is our model. Add the following code to `HttpExamples.elm`.

[source,elm]
----
module HttpExamples exposing (Model)


type alias Model =
    List String
----

The string from server looks like this: `+"The Godfather, The Tank, Beanie, Cheese"+`. We will extract each nickname and store it in a list. That’s why our model’s type is `+List String+`.

==== View

Next we’ll display the nicknames. Add the following code to the bottom of `HttpExamples.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , h3 [] [ text "Old School Main Characters" ]
        , ul [] (List.map viewNickname model)
        ]


viewNickname : String -> Html Msg
viewNickname nickname =
    li [] [ text nickname ]
----

Although our view is quite simple, let’s briefly go through each element. First, we display a button that when clicked tells the Elm runtime to dispatch `SendHttpRequest` message to the `update` function — we’ll implement `SendHttpRequest` and `update` in a moment. Then we add a heading followed by an unordered (bulleted) list of nicknames.

The code for rendering each nickname is extracted out to a separate function called `viewNickname`. It’s a common practice in Elm to render an individual item in a list using a separate function. <<list, `List.map`>> applies the `viewNickname` function to each nickname in our model to produce a list of `li` tags. All functions in `view` are defined in the `Html` and `Html.Events` modules. Let’s import those modules in `HttpExamples.elm`.

[source,elm]
----
module HttpExamples exposing (Model)

import Html exposing (..)
import Html.Events exposing (onClick)
.
.
----

==== Update

Next up is the `update` function and message type. Add the following code to the bottom of `HttpExamples.elm`.

[source,elm]
----
type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error String)


url : String
url =
    "http://localhost:5016/old-school.txt"


getNicknames : Cmd Msg
getNicknames =
    Http.get
        { url = url
        , expect = Http.expectString DataReceived
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, getNicknames )
----

And import the `Http` module.

[source,elm]
----
module HttpExamples exposing (Model)

import Http
.
.
----

`update` handles the `SendHttpRequest` message by returning the original model and a <<commands, command>> for fetching nicknames from the local HTTP server we created earlier. Here is what the `Http.get` function’s type signature looks like:

[source,elm]
----
get :
    { url : String
    , expect : Expect msg
    }
    -> Cmd msg
----

It takes a record with two fields and returns a command. The `url` field holds the location of the server resource. The `expect` field specifies the format we expect from the server. By using `Http.expectString`, we’re letting Elm know that we expect the response body to be a string. Here is what the `Http.expectString` function’s type signature looks like:

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-expect-string-syntax.svg[]

[[comparing-httpget-to-randomgenerate]]
===== Comparing Http.get to Random.generate

In the <<commands, Commands>> section, we wrote the following code to generate a random number.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        GenerateRandomNumber ->
            ( model, Random.generate NewRandomNumber (Random.int 0 100) )
----

Although `Random.generate` and `Http.get` look structurally different, they both contain three ingredients required for communicating with the outside world:

* A mechanism for creating a command.
* What needs to happen when the command is run?
* Which message should be sent to the app after the command has been executed?

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-get-vs-random-generate.svg[]

===== Comparing DataReceived to NewRandomNumber

The `DataReceived` message looks slightly more complex than `NewRandomNumber`.

[source,elm]
----
-- HttpExamples.elm --

type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error String)
----

[source,elm]
----
-- RandomNumber.elm --

type Msg
    = GenerateRandomNumber
    | NewRandomNumber Int
----

The command for generating a random number always succeeds. We are guaranteed to receive a random number from the Elm runtime when asked. That’s why `NewRandomNumber`’s definition is so simple. In contrast, fetching data from a server can fail. Perhaps the server isn’t available or the URL we’re trying to reach is incorrect. There are many other reasons why fetching data from a server may fail. Therefore, unlike `Random.generate`, `Http.get` must account for those failure scenarios.

As mentioned in the <<type-system, Type System>> section, Elm has a built-in type called `Result` for representing the outcome of an operation that can fail.

[source,elm]
----
type Result error value
    = Ok value
    | Err error
----

It accepts two arguments: `error` and `value`. In our case, the type of `error` is `Http.Error` and the type of `value` is `String`.

[source,elm]
----
DataReceived (Result Http.Error String)
----

`Http.Error` is a built-in <<type-system, custom type>> with the following data constructors.

[source,elm]
----
type Error
    = BadUrl String
    | Timeout
    | NetworkError
    | BadStatus Int
    | BadBody String
----

Whenever an HTTP request fails, we can expect to receive one of these values as `DataReceived`’s payload. If the request is successful, `DataReceived`’s payload will be a string. Check out the https://package.elm-lang.org/packages/elm/http/latest/Http#Error[official documentation] to find out what those error types mean.

===== Handling DataReceived Message

We need to tell the `update` function what to do when the `DataReceived` message arrives. Add a new `case` branch to `update` in `HttpExamples.elm` to handle that message as shown below.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, getNicknames )

        DataReceived result ->
            case result of
                Ok nicknamesStr ->
                    let
                        nicknames =
                            String.split "," nicknamesStr
                    in
                    ( nicknames, Cmd.none )

                Err httpError ->
                    ( model, Cmd.none )
----

All we are doing here is unpacking the `result` payload that rides on `DataReceived`’s back. If it’s a successful response, the individual nicknames are extracted from a string into a list using <<string, `String.split`>> and that list is returned as an updated model. If the response is an error, we simply return the existing model. We’ll write proper error handling code in the <<fetching-data-using-get, Handling HTTP Errors>> section below.

Notice how we have managed to cram a `case` expression inside another `case` expression in the `update` function? We can use <<pattern-matching, pattern matching>> to get rid of nested `case` expressions like this:

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, getNicknames )

        DataReceived (Ok nicknamesStr) ->
            let
                nicknames =
                    String.split "," nicknamesStr
            in
            ( nicknames, Cmd.none )

        DataReceived (Err _) ->
            ( model, Cmd.none )
----

In Elm, tuples can be used to write concise yet clear `case` expressions by matching complex patterns as we have done in the above refactoring. We’ve also replaced the payload `httpError` with `_` because we aren’t using it right now. It’s best practice to replace all unused parameters with `_` in Elm.

We’ve assembled all pieces required to fire an HTTP command. The following diagram shows how various components in our app interact with the Elm runtime to accomplish the task of fetching nicknames from a server.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/elm-runtime-interaction-http.svg[]

==== Wiring Everything Up

Even after writing all that code, we still don’t have a working app. Let’s wire everything up by adding the `main` function to the bottom of `HttpExamples.elm`.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.element
        { init = \flags -> ( [], Cmd.none )
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----

We also need to import the `Browser` module in `HttpExamples.elm`.

[source,elm]
----
module HttpExamples exposing (main)

import Browser
.
.
----

Instead of creating a separate `init` function, we directly assigned an anonymous function that takes `flags` and returns a tuple containing an empty list of nicknames and commands to the `init` field in `main`. It doesn’t make sense to create a separate function if all it’s going to do is return empty values, even though we did exactly that in the <<commands, Commands>> section.

Finally, we’re ready to taste the fruits of our labor. Fire up `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already, and go to this URL in your browser: http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`]. You should see a view that looks like this:

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-request-view-1.png[]

Unfortunately, if you click the _Get data from server_ button right now nothing happens. What could have gone wrong? To find out open the browser console. You should see an error message that looks like this:

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-requests-cors.png[]

What the browser is trying to tell us is that we can’t request data from a domain that’s different from the one where the request was originated from. For security reasons, most modern browsers restrict cross-origin HTTP requests initiated through an https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started[ajax] call which uses the https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest[`XMLHttpRequest`] JavaScript object behind the scenes. The Elm runtime uses ajax to send all HTTP requests under the hood. That’s why we weren’t able to fetch the nicknames.

At this point you may be wondering why we received that error when the local server domain and the client app domain are exactly the same: `localhost`. As it turns out, the cross-origin policy dictates that it’s not enough for the domains to be the same. The ports also have to match, but our server and client app are running on different ports.

* Server URL: http://localhost:5016/old-school.txt[`+http://localhost:5016/old-school.txt+`]
* Client URL: http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`]

==== Allowing Cross-Origin Resource Sharing

How do we fix this cross-origin issue? A solution is lurking in the error message. If you look closely, the browser is telling us what it expects: `+No 'Access-Control-Allow-Origin' header is present on the requested resource.+`

`+Access-Control-Allow-Origin+` is one of the headers included in a response sent by the server. It indicates which domains are allowed to use the response. For example, if the server returns `+Access-Control-Allow-Origin: *+`, the response can be used by any domain. But if the server wants only certain domains to have access then it’ll return a domain name(s) instead of `+*+`. Here’s an example: `+Access-Control-Allow-Origin: http://localhost:8000+`.

The `+http-server+` package we used earlier to <<fetching-data-using-get, create a local server>> provides an option called `+--cors+` for enabling https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[Cross-Origin Resource Sharing (CORS)] via the `+Access-Control-Allow-Origin+` header. Let’s stop our local server by pressing `+Ctrl + c+` and then restart it using the `+--cors+` option.

[source,bash]
----
$ http-server server -a localhost -p 5016 --cors
----

Now open a new browser window in private mode and go to http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`]. After that click the _Get data from server_ button and you should see the nicknames of some of the most popular characters in American fraternity culture.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-request-view-2.png[]

****
NOTE: Most browsers cache CORS policies for sometime in non-private mode. That’s wny we need to open `HttpExamples.elm` in private mode. Otherwise, we keep getting the same CORS error we saw earlier even after refreshing the page.
****

The `+--cors+` option adds `+Access-Control-Allow-Origin: *+` to the list of response headers. If you are using the Chrome browser, you can verify the presence of that header by following these steps:

*Step 1.* Open the page located at http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`] in a new private window.

*Step 2.* Go to the _Network_ tab in _Developer Tools_ window.

*Step 3.* Click the _Get data from server_ button from our app.

*Step 4.* A new row should appear in the _Network_ tab. Click `+old-school.text+` below the _Name_ column.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/chrome-xhr-new-row.png[]

*Step 5.* Look for `+Access-Control-Allow-Origin+` in the _Response Headers_ section.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/chrome-xhr-headers.png[]

==== Handling HTTP Errors

Earlier in this section, we cheated by simply returning an existing model when a request to fetch nicknames failed.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        DataReceived (Err _) ->
            ( model, Cmd.none )
----

We’ll rectify that by showing a proper error message.

===== Storing an Error Message

The first thing we need to do is store an error message in our model. Right now it’s just a list of strings.

[source,elm]
----
type alias Model =
    List String
----

We could simply append the error message to this list, but that seems a bit hacky. A better alternative is to store it separately from nicknames. Let’s change our `Model` to use a record instead.

[source,elm]
----
type alias Model =
    { nicknames : List String
    , errorMessage : Maybe String
    }
----

The `errorMessage` field’s type is `+Maybe String+` instead of just `String`. That’s because if the HTTP request is successful, there won’t be any error to show. What we need is a data structure that can represent the absence of a value. `Maybe` fits the bill.

===== Fixing Compiler Errors

Changing the structure of our `Model` causes the Elm compiler to throw errors when we refresh the page at http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`]. We can actually use those errors as a guide to figure out what needs to be fixed. This is a big advantage Elm has over other languages that don’t have a robust <<type-system, type system>>. We can count on the Elm compiler to catch our mistakes — no matter how subtle — as we mercilessly refactor our code.

Let’s start with the `view` function. Nicknames are now located inside a record, so we need to use the <<record, dot syntax>> to access them. Modify the line that contains the `ul` tag in `view` to this:

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        .
        .
        , ul [] (List.map viewNickname model.nicknames)
        ]
----

Next we’ll fix the `update` function. Right now it splits the nicknames string into a list and returns that as a model. We can’t do that anymore. We need to assign the list to the `nicknames` property inside the model. Modify the `+DataReceived (Ok nicknamesStr)+` branch in `update` to this:

[source,elm]
----
DataReceived (Ok nicknamesStr) ->
    let
        nicknames =
            String.split "," nicknamesStr
    in
        ( { model | nicknames = nicknames }, Cmd.none )
----

The only thing remaining to fix is the value we’re assigning to the `init` property in `main`. Change it to the following.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.element
        { init = \flags -> ( { nicknames = [], errorMessage = Nothing }, Cmd.none )
        .
        .
----

Inlining an initial model like that makes our code look a bit clunky. Let’s extract it out to a separate function.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { nicknames = []
      , errorMessage = Nothing
      }
    , Cmd.none
    )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        .
        .
----

And we’re back to having a working app. Open the page at http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`] in a new private window and click the _Get data from server_ button to make sure that you can successfully fetch the nicknames.

===== Displaying an Error Message

Here is our plan for notifying the users when things go haywire: if the request to fetch nicknames succeeds, we’ll display a heading and a bulleted list of nicknames. However, if the request fails, we’ll replace the heading and nicknames with an error message. We can accomplish that by modifying our view code in `HttpExamples.elm` as shown below.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , viewNicknamesOrError model
        ]


viewNicknamesOrError : Model -> Html Msg
viewNicknamesOrError model =
    case model.errorMessage of
        Just message ->
            viewError message

        Nothing ->
            viewNicknames model.nicknames


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch nicknames at this time."
    in
        div []
            [ h3 [] [ text errorHeading ]
            , text ("Error: " ++ errorMessage)
            ]


viewNicknames : List String -> Html Msg
viewNicknames nicknames =
    div []
        [ h3 [] [ text "Old School Main Characters" ]
        , ul [] (List.map viewNickname nicknames)
        ]


viewNickname : String -> Html Msg
viewNickname nickname =
    li [] [ text nickname ]
----

We’re using separate functions to render an error message and nicknames. The core logic for rendering nicknames hasn’t changed at all. We just extracted that logic out to the `viewNicknames` function. The `viewError` function accepts an error message which will be determined later when we deal with the `Http.Error` value. We render that error message right below a heading.

===== Creating an Error Message

When a request to fetch nicknames fails, the `update` function is notified with a value of type `Http.Error` which lays out all the different ways a request can fail.

[source,elm]
----
type Error
    = BadUrl String
    | Timeout
    | NetworkError
    | BadStatus Int
    | BadBody String
----

Add a function called `buildErrorMessage` right below `update` in `HttpExamples.elm`. This new function determines what the error message should be in each failure case.

[source,elm]
----
buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message
----

If a data constructor has a payload, an error message is created based on what’s inside it. Otherwise, we just hard code it. Now call `buildErrorMessage` from `update` to set the `errorMessage` property inside our model as shown below.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        DataReceived (Err httpError) ->
            ( { model
                | errorMessage = Just (buildErrorMessage httpError)
              }
            , Cmd.none
            )
----

We replaced `_` with `httpError` in the `+DataReceived (Err httpError) ->+` branch because we’re now actually using the error payload. We also wrapped the return value from `buildErrorMessage` in `Just` because the `errorMessage` property expects a `Maybe` type. We’re ready to test the error handling code. Let’s change the URL to something invalid in `HttpExamples.elm`.

[source,elm]
----
url : String
url =
    "http://localhost:5016/invalid.txt"
----

If you refresh the page at http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`] and click the _Get data from server_ button, you should see the following error message.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-requests-error-message.png[]

Change the URL back to http://localhost:5016/old-school.txt[`+http://localhost:5016/old-school.txt+`]. We won’t test other error types here, but if you ever receive one you now know how to handle it.

[source,elm]
----
url : String
url =
    "http://localhost:5016/old-school.txt"
----

==== Summary

We need to go through three steps to retrieve data from a server:

*1. Specify where to retrieve data from.* We used the `url` and `expect` fields in the record passed to the `Http.get` function to let the Elm runtime know where our data resides and in what format.

*2. Retrieve data.* Sending and receiving data from a server causes <<side-effects, side effects>>. Since Elm functions aren’t allowed to have any side effects, our application code can’t retrieve data by itself. It needs to ask the Elm runtime to do that by sending a command. We used the `Http.get` function to wrap our request in a command and handed that over to the runtime. The runtime executed that command to retrieve data from our local server.

*3. Notify the update function.* If the request is successful, the runtime sends the `DataReceived` message to `update` with retrieved data as a payload. If the request fails, the payload is an error.

The sequence diagram below shows how the interaction between the Elm runtime and our code looks while fetching data. Notice how similar the interaction is to the process of generating random numbers shown in the <<commands, Commands>> section.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/elm-runtime-mvu-http-requests.svg[]

In the next section, we will explore how to retrieve and decode JSON data from a server. Here is the entire code from `HttpExamples.elm`:

[source,elm]
----
module HttpExamples exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)
import Http


type alias Model =
    { nicknames : List String
    , errorMessage : Maybe String
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , viewNicknamesOrError model
        ]


viewNicknamesOrError : Model -> Html Msg
viewNicknamesOrError model =
    case model.errorMessage of
        Just message ->
            viewError message

        Nothing ->
            viewNicknames model.nicknames


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch nicknames at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewNicknames : List String -> Html Msg
viewNicknames nicknames =
    div []
        [ h3 [] [ text "Old School Main Characters" ]
        , ul [] (List.map viewNickname nicknames)
        ]


viewNickname : String -> Html Msg
viewNickname nickname =
    li [] [ text nickname ]


type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error String)


url : String
url =
    "http://localhost:5016/old-school.txt"


getNicknames : Cmd Msg
getNicknames =
    Http.get
        { url = url
        , expect = Http.expectString DataReceived
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, getNicknames )

        DataReceived (Ok nicknamesStr) ->
            let
                nicknames =
                    String.split "," nicknamesStr
            in
            ( { model | nicknames = nicknames }, Cmd.none )

        DataReceived (Err httpError) ->
            ( { model
                | errorMessage = Just (buildErrorMessage httpError)
              }
            , Cmd.none
            )


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message


init : () -> ( Model, Cmd Msg )
init _ =
    ( { nicknames = []
      , errorMessage = Nothing
      }
    , Cmd.none
    )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[decoding-json-part-1]]
=== 6.3 Decoding JSON - Part 1


In <<fetching-data-using-get, Fetching Data Using GET>>, we learned how to retrieve a simple string from an HTTP server. Nowadays most client apps expect servers to send data in https://www.json.org/[JSON] format. In this section, we’ll change the format of our server’s response from string to JSON and use various functions in Elm to translate that JSON to Elm values.

==== Creating a Local JSON Server

The local HTTP server we created in the <<fetching-data-using-get, previous section>> is capable of sending JSON too. All we need to do is structure our data as JSON instead of a regular string like this:

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/old-school-json-file.png[]

But there is a better way. We can create a different server that is fine-tuned for serving JSON instead of static files by using the NPM package called https://www.npmjs.com/package/json-server[json-server]. Go ahead and install it globally using the `+-g+` option so that it can be run from anywhere in the terminal.

[source,bash]
----
$ npm install json-server -g
----

Now create a new file called `+old-school.json+` inside `+beginning-elm/server+`.

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/create-old-school-json-file.png[]

Add the following JSON to the `+old-school.json+` file.

[source,json]
----
{
    "nicknames" : ["The Godfather", "The Tank", "Beanie", "Cheese"]
}
----

Let’s fire up a JSON server by running the following command from the `+beginning-elm+` directory in terminal. You can stop the HTTP server we created in the <<fetching-data-using-get, Fetching Data Using GET>> section if it’s still running by pressing `+Ctrl + c+`.

[source,bash]
----
$ json-server --watch server/old-school.json -p 5019
----

You should see an output like this:

[source,bash]
----
\{^_^}/ hi!

Loading server/old-school.json
Done

Resources
http://localhost:5019/nicknames

Home
http://localhost:5019

Type s + enter at any time to create a snapshot of the database
Watching...
----

Like `+http-server+`, `+json-server+` requires us to specify a file from which it will serve data. In our case it’s `+server/old-school.json+`. The `+--watch+` option tells the server to _watch_ for any changes made to `+old-school.json+`. If we don’t use this option, we’ll have to restart the server each time that file is modified. The `+-p+` option specifies the port. We are using a different port (`5019`) here to avoid any conflict with the server we created in the <<fetching-data-using-get, Fetching Data Using GET>> section in case it’s still running.

Go to http://localhost:5019/nicknames[`+http://localhost:5019/nicknames+`] in your browser. If you see a list of nicknames as shown below then the server is working as expected.

[source,json]
----
[
  "The Godfather",
  "The Tank",
  "Beanie",
  "Cheese"
]
----

Notice how the URL to retrieve nicknames has changed from what it used to be in the <<fetching-data-using-get, Fetching Data Using GET>> section:

* New URL with `+json-server+`: http://localhost:5019/nicknames[`+http://localhost:5019/nicknames+`]
* Old URL with `+http-server+`: http://localhost:5016/old-school.txt[`+http://localhost:5016/old-school.txt+`]

With the old URL we were specifying the filename because it was serving the contents of a static file. The new URL specifies which _resource_ we want to retrieve. Rather than serving the entire content of a file, `+json-server+` allows us to define resources which are just a way to name a piece of information. By adding the following JSON to the `+old-school.json+` file, we’re assigning the name `nicknames` to the resource `+["The Godfather", "The Tank", "Beanie", "Cheese"]+`.

[source,json]
----
{
    "nicknames" : ["The Godfather", "The Tank", "Beanie", "Cheese"]
}
----

Resources can be a lot more complex than just a list of strings. Here is an example derived from `+json-server+`’s https://www.npmjs.com/package/json-server[documentation] page:

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": "typicode"
    },
    {
      "id": 2,
      "title": "http-server",
      "author": "indexzero"
    }
  ],
  "comments": [
    {
      "id": 1,
      "body": "some comment",
      "postId": 1
    }
  ],
  "profile": {
    "name": "typicode"
  }
}
----

The above JSON defines three different resources: `posts`, `comments`, and `profile`. A resource can be either a collection or a single entity. `posts` and `comments` are collections, whereas `profile` is a single entity. Each resource has a unique location from where we can access it.

This concept will become clearer if we try to retrieve these resources from a browser. Go ahead and add the above JSON to a new file called `db.json` in the `+beginning-elm/server+` directory. `db` is short for https://en.wikipedia.org/wiki/Database[database].

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/create-db-json-file.png[]

Now stop the JSON server by pressing `+Ctrl + c+` and restart it so that it’ll use the `db.json` file instead.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
----

Notice how the output lists all available resources.

[source,bash]
----
Resources
http://localhost:5019/posts
http://localhost:5019/comments
http://localhost:5019/profile
----

`+json-server+` has essentially created a https://en.wikipedia.org/wiki/Representational_state_transfer[REST API] for us. Let’s retrieve the `posts` resource by loading http://localhost:5019/posts[`+http://localhost:5019/posts+`] in browser. Your output should look like this:

[source,json]
----
[
  {
    "id": 1,
    "title": "json-server",
    "author": "typicode"
  },
  {
    "id": 2,
    "title": "http-server",
    "author": "indexzero"
  }
]
----

`posts` is also a resource itself even though it contains other resources inside it. We can retrieve an individual resource inside `posts` by specifying an `id`. If you load the URL http://localhost:5019/posts/1[`+http://localhost:5019/posts/1+`] in browser, you should see only one post.

[source,json]
----
{
  "id": 1,
  "title": "json-server",
  "author": "typicode"
}
----

Hopefully, you now understand how `+json-server+` works. We really didn’t need to learn all of this just to return some JSON from our server. The good news is all of this knowledge will come handy when we create, update, and delete resources in chapter 7 using the `POST`, `PATCH`, and `DELETE` methods defined in the HTTP protocol.

==== Retrieving JSON from an Elm App

Let’s turn our attention back to the Elm app we wrote in the <<fetching-data-using-get, Fetching Data Using GET>> section. In the `HttpExamples.elm` file located inside `+beginning-elm/src+`, we retrieved a string and used the <<string, `String.split`>> function to extract individual nicknames from that string.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, getNicknames )

        DataReceived (Ok nicknamesStr) ->
            let
                nicknames =
                    String.split "," nicknamesStr
            in
            ( { model | nicknames = nicknames }, Cmd.none )
        .
        .
----

We will have to rewrite some of that logic to fetch nicknames as JSON and decode them. Stop the JSON server by pressing `+Ctrl + c+` if it’s running and restart it to use the `+old-school.json+` file.

[source,bash]
----
$ json-server --watch server/old-school.json -p 5019
----

The first thing we need to change in `HttpExamples.elm` is the URL.

[source,elm]
----
url : String
url =
    "http://localhost:5019/nicknames"
----

The process for retrieving JSON from a server isn’t any different from retrieving a string. Although we’re retrieving JSON, the underlying data format sent by the server is still a _raw string_. If that’s the case, how does a client app know how to properly parse a response if it always comes down as string? It can’t use the same technique to extract nicknames from a string and also JSON.

Luckily, the server specifies which format it intends the response to be interpreted as through the use of https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type[`+Content-Type+`] header. For JSON, the server uses `+application/json+` as the `+Content-Type+` header’s value. Whereas, for string it uses `+text/plain+`.

==== Decoding JSON

Elm provides a package called https://package.elm-lang.org/packages/elm/json/latest/[`+elm/json+`] which includes modules for encoding and decoding JSON values. We installed that package in the <<type-system, Type System>> section by running the following command.

[source,bash]
----
$ elm install elm/json
----

If you don’t have it installed already, go ahead and run the above command from the `+beginning-elm+` directory in terminal. Don’t run it from the same terminal window where we ran `+json-server+` earlier. Create a new one. When `+elm install+` asks for your permission, answer `y`. After that import the `Json.Decode` module in `HttpExamples.elm`.

[source,elm]
----
module HttpExamples exposing (main)

import Json.Decode exposing (Decoder, Error(..), decodeString, list, string)
.
.
----

Next we need to define a decoder that knows how to translate JSON into Elm values. Add the following code above the `update` function in `HttpExamples.elm`.

[source,elm]
----
nicknamesDecoder : Decoder (List String)
nicknamesDecoder =
    list string
----

The expression `+list string+` creates a decoder that knows how to translate a JSON array into a list of Elm strings. That sounds confusing, doesn’t it? Let’s experiment with this expression in repl to get a better understanding. Run `+elm repl+` from the `+beginning-elm+` directory in terminal and enter the following code.

[source,elm]
----
> import Json.Decode exposing (..)

> list
<function> : Decoder a -> Decoder (List a)
----

Look what we got when we entered just `list`. The output suggests that `list` is a function that takes a decoder and returns another decoder. Let’s see what we get when we enter `string`.

[source,elm]
----
> string
<internals> : Decoder String
----

****
NOTE: We were able to type `list` and `string` in repl without having to prefix the module name because we exposed everything while importing `Json.Decode`.
****

===== String Decoder

`string` is a decoder that knows how to translate a JSON string into an Elm string. Here is an example:

[source,elm]
----
> decodeString string "\"Beanie\""
Ok "Beanie" : Result Error String
----

We used two sets of double quotes to indicate that `+"\"Beanie\""+` contains a JSON string within a raw string. `string` by itself doesn’t decode JSON. It’s like a recipe for decoding. The `decodeString` function is the one that does the actual decoding. It first parses the raw string into JSON and then applies the `string` decoder to translate that JSON into an Elm string.

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/decodeString-flow-chart.svg[]

The following diagram explains the type signature of `decodeString` in detail.

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/decodeString-syntax.svg[]

[[jsondecodeerror]]
===== Json.Decode.Error

When decoding fails, `decodeString` returns a value of type `Error`. Here is an example:

[source,elm]
----
> decodeString string "42"
Err (Failure ("Expecting a STRING") <internals>)
    : Result Error String
----

****
NOTE: Although we wrapped `42` in double quotes, it’s not considered a JSON string. For it to be a proper JSON string, we need to add one more set of double quotes like this: `+"\"42\""+`.
****

The `Error` type is defined in the `Json.Decode` module like this:

[source,elm]
----
type Error
    = Field String Error
    | Index Int Error
    | OneOf (List Error)
    | Failure String Value
----

It’s a recursive type. Earlier in the <<type-system, Type System>> section, we created a recursive type of our own like this:

[source,elm]
----
type MyList a
    = Empty
    | Node a (MyList a)
----

Do you notice a similarity? Both types provide at least one data constructor that isn’t recursive. Without those data constructors we would end up with a value that never ends. Here’s an example:

[source,elm]
----
Node 16 (Node 5 (Node 31 (Node 9 (Node 18 (Node 7 (Node 26 (...)))))))
----

But why does the `Error` type have to be so complex? Why can’t it be just a simple string? It actually used to be just a string before Elm 0.19. By making it a more complex type, the authors of the `+elm/json+` package have given us the ability to create an elaborate visualization of the problem encountered during the decoding process. For example, we can show the entire <<decoding-json-part-2, JSON object>> and highlight the part that caused the error in red.

We won’t get into the details of how to do that here, but you may want to explore it further on your own after you have read the <<decoding-json-part-1, Decoding JSON - Part 1>> and <<decoding-json-part-2, Decoding JSON - Part 2>> sections.

===== Other Primitive Decoders

Elm provides three other decoders for translating primitive JSON types to Elm values: `int`, `float`, and `bool`. Here are some examples showing them in action:

[source,elm]
----
> decodeString int "9"
Ok 9 : Result Error Int

> decodeString int "2.5"
Err (Failure ("Expecting an INT") <internals>)
    : Result Error Int

> decodeString float "2.5"
Ok 2.5 : Result Error Float

> decodeString bool "true"
Ok True : Result Error Bool

> decodeString bool "false"
Ok False : Result Error Bool

> decodeString bool "87"
Err (Failure ("Expecting a BOOL") <internals>)
    : Result Error Bool
----

===== Building Complex Decoders

JSON supports the following data types:

* *string* — A string must be written in double quotes and looks very similar to an Elm string.
* *number* — A number must be an integer or a float.
* *boolean* — A boolean must be either `true` or `false`.
* *array* — An array can contain any other JSON values including arrays themselves.
* *object* — An object consists of key value pairs.
* *null* — `null` is used to indicate an absence of a value.

We already know how to decode strings, numbers, and booleans. To decode the rest, we need to create more complex decoders using primitive decoders as building blocks. Let’s start with a JSON array.

===== List Decoder

Earlier we <<decoding-json-part-1, created a decoder>> for translating an array of JSON strings into a list of Elm strings.

[source,elm]
----
nicknamesDecoder : Decoder (List String)
nicknamesDecoder =
    list string
----

We can decode an array of nicknames using `+list string+` like this:

[source,elm]
----
> nicknameJson = "[\"The Godfather\", \"The Tank\", \"Beanie\", \"Cheese\"]"
"[\"The Godfather\", \"The Tank\", \"Beanie\", \"Cheese\"]" : String

> decodeString (list string) nicknameJson
Ok ["The Godfather","The Tank","Beanie","Cheese"]
    : Result Error (List String)
----

Similarly, we can decode an array of JSON ints (or floats) like this:

[source,elm]
----
> decodeString (list int) "[1, 2, 3]"
Ok [1,2,3] : Result Error (List Int)

> decodeString (list float) "[1.5, 2.5]"
Ok [1.5,2.5] : Result Error (List Float)
----

`list` itself is not a decoder. It’s a function that takes a decoder and creates a more complex decoder. Here is how its type signature looks:

[source,elm]
----
list : Decoder a -> Decoder (List a)
----

If we want to decode a JSON that contains an array of arrays, we can do that by using the `list` decoder multiple times like this:

[source,elm]
----
> decodeString (list (list int)) "[[1, 2], [4, 5]]"
Ok [[1,2],[4,5]]
    : Result Error (List (List Int))
----

There is no limit to how deep this nesting can go. It’s important to remember that Elm requires all elements in a `List` to be of the same type. Therefore, we can’t decode a JSON array with different types.

[source,elm]
----
> decodeString (list (list int)) "[[1, 2], [3.5, 4.5]]"
Err (Index 1 (Index 0 (Failure ("Expecting an INT") <internals>)))
    : Result Error (List (List Int))
----

[[replacing-stringsplit-with-nicknamesdecoder]]
===== Replacing `String.split` with `nicknamesDecoder`

Now that we have understood how the `list` and `string` decoders work, let’s go back to `HttpExamples.elm` and replace `String.split` with `nicknamesDecoder` in the `+DataReceived (Ok nicknamesStr) ->+` branch inside `update`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        DataReceived (Ok nicknamesJson) ->
            case decodeString nicknamesDecoder nicknamesJson of
                Ok nicknames ->
                    ( { model | nicknames = nicknames }, Cmd.none )

                Err error ->
                    ( { model | errorMessage = handleJsonError error }
                    , Cmd.none
                    )
        .
        .
----

We renamed the payload from `nicknamesStr` to `nicknamesJson` and replaced the `let` expression with `case`. Unlike `String.split`, `decodeString` returns a `Result`. That’s why we used a `case` expression to dig nicknames out of `Ok`. If decoding fails, the `handleJsonError` function is used to extract the error message. Let’s add that function below `update`.

[source,elm]
----
handleJsonError : Json.Decode.Error -> Maybe String
handleJsonError error =
    case error of
        Failure errorMessage _ ->
            Just errorMessage

        _ ->
            Just "Error: Invalid JSON"
----

We’re only interested in the `Failure` data constructor because that’s where the error message resides. The second parameter to `Failure` is the JSON value that caused the failure. Since we aren’t using that parameter, we replaced it with `_`.

Fire up `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and go to this URL in your browser: http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`]. Click the _Get data from server_ button and you should see the same list of nicknames we saw in the <<fetching-data-using-get, Fetching Data Using GET>> section.

image:https://elmprogramming.com/images/chapter-6/6.2-fetching-data-using-get/http-request-view-2.png[]

Unlike `+http-server+`, `+json-server+` automatically enables https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[Cross-Origin Resource Sharing (CORS)]. That’s why we didn’t get the `+No 'Access-Control-Allow-Origin' header is present on the requested resource.+` error when fetching the nicknames.

==== Replacing `expectString` with `expectJson`

Let’s review the process we went through to retrieve and decode nicknames JSON.

*Step 1:* Create a command using `Http.get`. Specify which URL to use and let the Elm runtime know we’re expecting the response to be a string.

[source,elm]
----
getNicknames : Cmd Msg
getNicknames =
    Http.get
        { url = url
        , expect = Http.expectString DataReceived
        }
----

*Step 2:* The runtime runs the command.

*Step 3:* The runtime sends `DataReceived` message to the `update` function.

* _Step 3.1:_ Include JSON as a payload if the request to retrieve nicknames succeeds.
* _Step 3.2:_ Include an error of type `Http.Error` as a payload if the request to retrieve nicknames fails.

*Step 4:* Decode JSON inside the `+DataReceived (Ok nicknamesJson) ->+` branch of `update` function.

* _Step 4.1:_ If decoding succeeds, update the `nicknames` property in model.
* _Step 4.2:_ If decoding fails, update the `errorMessage` property in model.

We can simplify this process quite a bit by using the `Http.expectJson` function instead of `Http.expectString` in `getNicknames`. Here is what the simplified process looks like:

*Step 1:* Create a command using `Http.get`. Specify which URL to use and let the Elm runtime know we’re expecting the response to be a JSON.

[source,elm]
----
getNicknames : Cmd Msg
getNicknames =
    Http.get
        { url = url
        , expect = Http.expectJson DataReceived nicknamesDecoder
        }
----

*Step 2:* The runtime runs the command.

*Step 3:* The runtime sends `DataReceived` message to the `update` function.

* _Step 3.1:_ Include decoded nicknames as a payload if the request to retrieve JSON and decoding both succeed.
* _Step 3.2:_ Include an error of type `Http.Error` as a payload if either the request to retrieve JSON or decoding fails.

We don’t need *step 4* at all if we use `Http.expectJson`. The retrieving and decoding of JSON happen in one go. The following diagram shows how `Http.expectString` and `Http.expectJson` differ.

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/expectString-vs-expectJson.svg[]

Go ahead and replace `Http.expectString` with `Http.expectJson` in `getNicknames` as shown above if you haven’t done already. Next we need to modify the `+DataReceived (Ok nicknamesJson) ->+` branch in `update`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        DataReceived (Ok nicknames) ->
            ( { model | nicknames = nicknames }, Cmd.none )

        DataReceived (Err httpError) ->
            ...
----

`Http.expectJson` really simplified that branch. We don’t need to manually decode JSON anymore. It happens automatically behind the scenes. If decoding is successful, the payload will be an Elm list which we can assign directly to the `nicknames` field in our model. That means we need to change the `DataReceived` message’s definition to accept `+List String+` instead of just `String`.

[source,elm]
----
type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error (List String))
----

We don’t need to modify the `+DataReceived (Err httpError) ->+` branch in `update` at all. If decoding fails, the `Http.BadBody` error will be returned which we are already handling in `buildErrorMessage`. Finally, remove the `handleJsonError` function. We don’t need it anymore.

Refresh the page at http://localhost:8000/src/HttpExamples.elm[`+http://localhost:8000/src/HttpExamples.elm+`] and click the `+Get data from server+` button. You should once again see the list of nicknames.

==== Summary

In this section, we learned how to create a local server fine-tuned for serving JSON. We retrieved some JSON from that server and translated it to Elm values using a decoder. We also learned how to simplify the overall process of fetching and decoding JSON using the `Http.expectJson` function instead of `Http.expectString`. The diagram below shows that the overall interaction between the Elm runtime and our code didn’t change much from the <<fetching-data-using-get, Fetching Data Using GET>> section.

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/elm-runtime-mvu-decoding-json.svg[]

In the next section, we will learn how to decode more complex JSON. Here is the entire code from `HttpExamples.elm` thus far:

[source,elm]
----
module HttpExamples exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)
import Http
import Json.Decode exposing (Decoder, Error(..), decodeString, list, string)


type alias Model =
    { nicknames : List String
    , errorMessage : Maybe String
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , viewNicknamesOrError model
        ]


viewNicknamesOrError : Model -> Html Msg
viewNicknamesOrError model =
    case model.errorMessage of
        Just message ->
            viewError message

        Nothing ->
            viewNicknames model.nicknames


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch nicknames at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewNicknames : List String -> Html Msg
viewNicknames nicknames =
    div []
        [ h3 [] [ text "Old School Main Characters" ]
        , ul [] (List.map viewNickname nicknames)
        ]


viewNickname : String -> Html Msg
viewNickname nickname =
    li [] [ text nickname ]


type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error (List String))


url : String
url =
    "http://localhost:5019/nicknames"


getNicknames : Cmd Msg
getNicknames =
    Http.get
        { url = url
        , expect = Http.expectJson DataReceived nicknamesDecoder
        }


nicknamesDecoder : Decoder (List String)
nicknamesDecoder =
    list string


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, getNicknames )

        DataReceived (Ok nicknames) ->
            ( { model | nicknames = nicknames }, Cmd.none )

        DataReceived (Err httpError) ->
            ( { model
                | errorMessage = Just (buildErrorMessage httpError)
              }
            , Cmd.none
            )


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message


init : () -> ( Model, Cmd Msg )
init _ =
    ( { nicknames = []
      , errorMessage = Nothing
      }
    , Cmd.none
    )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[decoding-json-part-2]]
=== 6.4 Decoding JSON - Part 2


The JSON structure we retrieved from a server in the <<decoding-json-part-1, previous section>> is quite simple. It’s just an array of strings. Most real world Elm apps have to deal with a lot more complex structures. In this section, we will learn how to decode objects, nested values, nullable values, and many more types of JSON.

==== Decoding a JSON Object

In the <<decoding-json-part-1, Creating a Local JSON Server>> section, we retrieved the following JSON representing a resource called `post`.

[source,json]
----
{
  "id": 1,
  "title": "json-server",
  "author": "typicode"
}
----

It’s an object with three fields. To fully decode it, we need to first figure out how to individually decode each field. The `field` function in the `Json.Decode` module is just what we need. Run `+elm repl+` from the `+beginning-elm+` directory in terminal and try the following examples.

[source,elm]
----
> import Json.Decode exposing (..)

> decodeString (field "id" int) "{ \"id\": 1 }"
Ok 1 : Result Error Int

> decodeString (field "title" string) "{ \"title\": \"json-server\" }"
Ok "json-server" : Result Error String

> decodeString (field "author" string) "{ \"author\": \"typicode\" }"
Ok "typicode" : Result Error String
----

Here is what the `field` function’s type signature looks like:

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/field-function-syntax.svg[]

The decoder returned by `field` can be applied to JSON with more than one fields, but it only decodes the given field. As long as that field exists and its value matches the type of decoder, it will succeed.

[source,elm]
----
> decodeString (field "id" int) "{ \"id\": 1, \"title\": \"json-server\" }"
Ok 1 : Result Error Int

> decodeString (field "id" int) "{ \"title\": \"json-server\" }"
Err (Failure ("Expecting an OBJECT with a field named `id`") <internals>)
    : Result Error Int
----

All examples we have seen so far are for decoding _only one_ field. How do we decode multiple fields at the same time? We can do that with the `map` function from `Json.Decode` module. Before we look at how `map` works let’s create another Elm app so that we can experiment with various concepts as we go along. Create a new file called `DecodingJson.elm` in the `+beginning-elm/src+` directory.

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/create-decoding-json-file.png[]

Now add the following code to `DecodingJson.elm`. I encourage you to type the entire code instead of just copying and pasting. It will reinforce what you have learned so far about retrieving and decoding JSON.

[source,elm]
----
module DecodingJson exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode
    exposing
        ( Decoder
        , decodeString
        , field
        , int
        , list
        , map3
        , string
        )


type alias Post =
    { id : Int
    , title : String
    , author : String
    }


type alias Model =
    { posts : List Post
    , errorMessage : Maybe String
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , viewPostsOrError model
        ]


viewPostsOrError : Model -> Html Msg
viewPostsOrError model =
    case model.errorMessage of
        Just message ->
            viewError message

        Nothing ->
            viewPosts model.posts


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch data at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewPosts : List Post -> Html Msg
viewPosts posts =
    div []
        [ h3 [] [ text "Posts" ]
        , table []
            ([ viewTableHeader ] ++ List.map viewPost posts)
        ]


viewTableHeader : Html Msg
viewTableHeader =
    tr []
        [ th []
            [ text "ID" ]
        , th []
            [ text "Title" ]
        , th []
            [ text "Author" ]
        ]


viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (String.fromInt post.id) ]
        , td []
            [ text post.title ]
        , td []
            [ text post.author ]
        ]


type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error (List Post))


postDecoder : Decoder Post
postDecoder =
    map3 Post
        (field "id" int)
        (field "title" string)
        (field "author" string)


httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect = Http.expectJson DataReceived (list postDecoder)
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, httpCommand )

        DataReceived (Ok posts) ->
            ( { model
                | posts = posts
                , errorMessage = Nothing
              }
            , Cmd.none
            )

        DataReceived (Err httpError) ->
            ( { model
                | errorMessage = Just (buildErrorMessage httpError)
              }
            , Cmd.none
            )


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message


init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = []
      , errorMessage = Nothing
      }
    , Cmd.none
    )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----

Stop the JSON server if it’s running already by pressing `+Ctrl + c+` and restart it with `+server/db.json+` from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
----

Now run `+elm reactor+` also from the `+beginning-elm+` directory in a separate terminal window if it’s not running already and load this URL in browser: http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`]. Click the _Get data from server_ button and you should see the posts stored in `db.json`.

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/posts-view.png[]

So far in this chapter, we have been building apps one step at a time. Here you are asked to type the entire code because most of the code in `DecodingJson.elm` looks very similar to what’s in `HttpExamples.elm` from the <<decoding-json-part-1, Decoding JSON - Part 1>> section. Let’s go over three main areas where the code in `DecodingJson.elm` differs from `HttpExamples.elm`.

[[1-model]]
===== 1. Model

We’re now storing `posts` instead of `nicknames` in our model. A post has more information than a nickname. Therefore, we created a separate type alias called `Post` to represent that information.

[source,elm]
----
type alias Post =
    { id : Int
    , title : String
    , author : String
    }


type alias Model =
    { posts : List Post
    , errorMessage : Maybe String
    }
----

[[2-view]]
===== 2. View

The overall structure of the view code hasn’t changed at all. The only noticeable difference is we are now using a table instead of a bulleted list to display the information retrieved from a server. Notice how we are assembling the header and standard table cells in `viewPosts` function.

[source,elm]
----
viewPosts : List Post -> Html Msg
viewPosts posts =
    div []
        [ h3 [] [ text "Posts" ]
        , table []
            ([ viewTableHeader ] ++ List.map viewPost posts)
        ]
----

`viewTableHeader` returns `+Html Msg+` whereas the expression `+List.map viewPost posts+` returns `+List (Html Msg)+`. They can’t be combined just by using commas. That’s why we weren’t able to write the `viewPosts` function like this:

[source,elm]
----
viewPosts : List Post -> Html Msg
viewPosts posts =
    div []
        [ h3 [] [ text "Posts" ]
        , table []
            [ viewTableHeader
            , List.map viewPost posts
            ]
        ]
----

We wrapped the return value from `viewTableHeader` in a list and <<list, concatenated>> it with the value returned by `List.map`. After `viewTableHeader` and `List.map` are applied, the `table` code will look like this:

[source,elm]
----
table []
    [ tr []
        [ th []
            [ text "ID" ]
        , th []
            [ text "Title" ]
        , th []
            [ text "Author" ]
        ]
    , tr []
        [ td []
            [ text "1" ]
        , td []
            [ text "json-server" ]
        , td []
            [ text "typicode" ]
        ]
    , tr []
        [ td []
            [ text "2" ]
        , td []
            [ text "http-server" ]
        , td []
            [ text "indexzero" ]
        ]
    ]
----

[[3-json-decoder]]
===== 3. JSON Decoder

The decoder in `DecodingJson.elm` is slightly more complex than the one in `HttpExamples.elm`.

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    map3 Post
        (field "id" int)
        (field "title" string)
        (field "author" string)
----

The `Json.Decode` module provides a series of `map` functions for decoding an object with multiple fields. `map3` is used for decoding three fields and here is its type signature:

[source,elm]
----
map3
    :  (a -> b -> c -> value)
    -> Decoder a
    -> Decoder b
    -> Decoder c
    -> Decoder value
----

The first argument is a function that takes the values decoded by each decoder and produces a new value. We supplied `Post` as that function in `postDecoder`. Whenever we use `+type alias+` to give a name to a record, we get a constructor function as a bonus.

****
NOTE: If you don’t remember how a constructor function works, you may want to refresh your memory by reading the <<record, Creating a Record>> section from chapter 3.
****

If we have only two fields in a JSON object, we need to use `map2`. Similarly, if we have four fields, we should reach for `map4`. The most we can decode is eight fields with `map8`. If we need more than that, we’ll have to either combine existing decoders or use a third-party package called https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/[`+elm-json-decode-pipeline+`]. Let’s see how our decoder looks if we were to use this package. Install it by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install NoRedInk/elm-json-decode-pipeline
----

Answer `y` when asked to add that package to `elm.json`. After that, import the `+Json.Decode.Pipeline+` module in `DecodingJson.elm`.

[source,elm]
----
module DecodingJson exposing (main)

import Json.Decode.Pipeline exposing (optional, optionalAt, required, requiredAt)
.
.
----

Now we can rewrite `postDecoder` like this:

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "author" string
----

We replaced `map3` with `Decode.succeed` and `field` with `required`. We also replaced parentheses with <<function, pipeline operators>> (`+|>+`). I don’t know about you, but I find the new version slightly easier to read.

The `Decode.succeed` function ignores the given JSON and always produces a specific value. Earlier, we specified `Decode` as an alias when importing the `Json.Decode` module. Let’s try some examples in `+elm repl+` to understand `succeed` better.

[source,elm]
----
> import Json.Decode exposing (..)

> decodeString (succeed 42) "1"
Ok 42 : Result Error number

> decodeString (succeed 42) "true"
Ok 42 : Result Error number

> decodeString (succeed 42) "[1,2,3]"
Ok 42 : Result Error number
----

`+Json.Decode.Pipeline+` makes a clever use of `succeed` to turn the JSON decoding process into a pipeline operation. In a real project, you are most likely to use the functions defined in `+Json.Decode.Pipeline+` instead of the `map` functions from `Json.Decode`. So let’s spend some time exploring what else `+Json.Decode.Pipeline+` can do.

==== Decoding Optional Fields

Let’s imagine a scenario in which a server can’t always guarantee that a specific field will be present in a JSON response. We can create such a response by removing author from the first post in `+server/db.json+`.

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server"
    },
    .
    .
}
----

Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button. You should see the following error.

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/missing-author-field-error.png[]

Error messages in Elm are quite helpful, aren’t they? We can fix the error by using a function called `optional`. Modify `postDecoder` to use `optional` instead of `required` when decoding `author`.

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> optional "author" string "anonymous"
----

`optional` takes a field name, a decoder, and a _fallback_ value. We’re using `anonymous` as the fallback value. Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button once again. You should see `anonymous` listed as the first post’s author.

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/anonymous-author.png[]

===== Decoding `null` Value

Sometimes servers assign `null` to a JSON field instead of removing it completely to signify the absence of a value. Add the `author` field back to `db.json` and assign `null` to it.

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": null
    },
    .
    .
}
----

Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] once again and click the _Get data from server_ button. You should still see `anonymous` as the first post’s author. We don’t need to do anything extra to handle `null`. The `optional` function automatically takes care of it.

==== Decoding Nested Objects

Let’s change the structure of data in `db.json` so that we can provide more info about an author.

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": {
          "name": "typicode",
          "url": "https://github.com/typicode"
      }
    },
    {
      "id": 2,
      "title": "http-server",
      "author": {
          "name": "indexzero",
          "url": "https://github.com/indexzero"
      }
    }
  ],
.
.
}
----

What we have here is nested JSON objects. Before we start decoding them, we need to change our data model in `DecodingJson.elm` to accommodate this new structure by introducing a new record called `Author`.

[source,elm]
----
type alias Author =
    { name : String
    , url : String
    }


type alias Post =
    { id : Int
    , title : String
    , author : Author
    }
----

The `author` field in `Post` is now of type `Author`. Instead of displaying urls in plain text, let’s make the author names clickable in `viewPost`.

[source,elm]
----
viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (String.fromInt post.id) ]
        , td []
            [ text post.title ]
        , td []
            [ a [ href post.author.url ] [ text post.author.name ] ]
        ]
----

Since `href` is defined in the `Html.Attributes` module we need to import that in `DecodeJson.elm`.

[source,elm]
----
module DecodingJson exposing (main)

import Html.Attributes exposing (href)
.
.
----

We’re now ready to write decoders for nested objects. Replace the current implementation of `postDecoder` with the following code in `DecodingJson.elm`.

[source,elm]
----
authorDecoder : Decoder Author
authorDecoder =
    Decode.succeed Author
        |> required "name" string
        |> required "url" string


postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "author" authorDecoder
----

`authorDecoder` is slightly more complex than `string`, but it’s a decoder nonetheless. That’s why we were able to pass it to the `required` function in `postDecoder` to decode an `author` object. Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button. The author names should be displayed as links.

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/clickable-author-names.png[]

===== Decoding Nested Fields with `requiredAt`

What if we want to store the author information inside `Post` itself instead of creating a separate record? Update `Post`’s definition to the following in `DecodingJson.elm`:

[source,elm]
----
type alias Post =
    { id : Int
    , title : String
    , authorName : String
    , authorUrl : String
    }
----

How do we go about extracting values from a nested JSON and assign them to `authorName` and `authorUrl` fields? We can use the `requiredAt` function defined in the `+Json.Decode.Pipeline+` module for that. Update `postDecoder` in `DecodingJson.elm` like this:

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> requiredAt [ "author", "name" ] string
        |> requiredAt [ "author", "url" ] string
----

`requiredAt` takes a list of field names and traverses them in order. Once it reaches the last field, it applies the given decoder to it. We also need to replace `+post.author.url+` with `post.authorUrl` and `+post.author.name+` with `post.authorName` in `viewPost`.

[source,elm]
----
viewPost : Post -> Html Msg
viewPost post =
    tr []
        .
        .
        , td []
            [ a [ href post.authorUrl ] [ text post.authorName ] ]
        ]
----

Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button. The author names should still be displayed as links.

===== Decoding Nested Fields with `at`

The `Json.Decode` module we saw earlier also provides a function called `at` for decoding nested fields. You don’t have to implement this change, but if you wanted to rewrite `postDecoder` using `at` you could do it like this:

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    map4 Post
        (field "id" int)
        (field "title" string)
        (at [ "author", "name" ] string)
        (at [ "author", "url" ] string)
----

Due to easier syntax, it’s better to use functions in the `+Json.Decode.Pipeline+` module instead of those defined in `Json.Decode`. The above example is included here in case you’re curious how to decode nested fields using the `Json.Decode` module.

===== Decoding Nested Fields with `optionalAt`

Remove `url` from the first post’s author object in `db.json`.

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": {
          "name": "typicode"
      }
    },
    .
    .
}
----

To decode posts, we now have to use the `optionalAt` function instead of `requiredAt` in `postDecoder`.

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> requiredAt [ "author", "name" ] string
        |> optionalAt [ "author", "url" ] string "http://dudeism.com"
----

If the `url` field doesn’t exist or is `null`, we want the decoder to use a fallback link. Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button. Now click the name of the first post’s author. You should be taken to the official site of the slowest-growing religion in the world — http://dudeism.com/[Dudeism].

===== Cleaning Up

We’ll be extending the code in `DecodingJson.elm` and `db.json` in the future sections, so let’s clean those files up before moving on. To match our current definition of the `Post` type, we’ll use simple properties instead of nested objects to represent the author information. The `posts` property in `db.json` should look like this:

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "authorName": "typicode",
      "authorUrl": "https://github.com/typicode"
    },
    {
      "id": 2,
      "title": "http-server",
      "authorName": "indexzero",
      "authorUrl": "https://github.com/indexzero"
    }
  ],
  .
  .
}
----

Since the `Author` record isn’t needed anymore go ahead and remove its definition and decoder from `DecodingJson.elm`.

[source,elm]
----
type alias Author =
    { name : String
    , url : String
    }


authorDecoder : Decoder Author
authorDecoder =
    Decode.succeed Author
        |> required "name" string
        |> required "url" string
----

Next replace `requiredAt` with `required` in `postDecoder`.

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "authorName" string
        |> required "authorUrl" string
----

The only thing remaining is to remove functions we aren’t using anymore from the imports in `DecodingJson.elm`. The `Json.Decode` and `+Json.Decode.Pipeline+` imports should look like the following after deletion.

[source,elm]
----
module DecodingJson exposing (main)
.
.
import Json.Decode as Decode exposing (Decoder, int, list, string)
import Json.Decode.Pipeline exposing (required)
----

Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button to make sure everything is still working.

==== Summary

In this section, we learned how to decode a JSON object with multiple fields. The third-party package `+NoRedInk/elm-json-decode-pipeline+` provides a much better experience for decoding JSON objects compared to the official package `+elm/json+`. We also learned how to decode nested objects and nullable fields.

`Json.Decode` and `+Json.Decode.Pipeline+` modules both contain a few more functions for decoding even more complex structures. You can learn all about them https://package.elm-lang.org/packages/elm/json/latest/[here] and https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/[here].

In the next section, we’ll polish our UI with `+krisajenkins/remotedata+` — a third-party package for handling HTTP requests elegantly. Here is the entire code from `DecodingJson.elm` thus far:

[source,elm]
----
module DecodingJson exposing (main)

import Browser
import Html exposing (..)
import Html.Attributes exposing (href)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode exposing (Decoder, int, list, string)
import Json.Decode.Pipeline exposing (required)


type alias Post =
    { id : Int
    , title : String
    , authorName : String
    , authorUrl : String
    }


type alias Model =
    { posts : List Post
    , errorMessage : Maybe String
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , viewPostsOrError model
        ]


viewPostsOrError : Model -> Html Msg
viewPostsOrError model =
    case model.errorMessage of
        Just message ->
            viewError message

        Nothing ->
            viewPosts model.posts


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch data at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewPosts : List Post -> Html Msg
viewPosts posts =
    div []
        [ h3 [] [ text "Posts" ]
        , table []
            ([ viewTableHeader ] ++ List.map viewPost posts)
        ]


viewTableHeader : Html Msg
viewTableHeader =
    tr []
        [ th []
            [ text "ID" ]
        , th []
            [ text "Title" ]
        , th []
            [ text "Author" ]
        ]


viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (String.fromInt post.id) ]
        , td []
            [ text post.title ]
        , td []
            [ a [ href post.authorUrl ] [ text post.authorName ] ]
        ]


type Msg
    = SendHttpRequest
    | DataReceived (Result Http.Error (List Post))


postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "authorName" string
        |> required "authorUrl" string


httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect = Http.expectJson DataReceived (list postDecoder)
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, httpCommand )

        DataReceived (Ok posts) ->
            ( { model
                | posts = posts
                , errorMessage = Nothing
              }
            , Cmd.none
            )

        DataReceived (Err httpError) ->
            ( { model
                | errorMessage = Just (buildErrorMessage httpError)
              }
            , Cmd.none
            )


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message


init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = []
      , errorMessage = Nothing
      }
    , Cmd.none
    )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[remote-data]]
=== 6.5 RemoteData


In the <<decoding-json-part-2, previous section>>, we created an app whose view looked like this before clicking the _Get data from server_ button:

image:https://elmprogramming.com/images/chapter-6/6.5-remote-data/no-posts-view.png[]

It’s not considered a good UI practice to show the _Posts_ heading and table headers when we haven’t even fetched any data yet. We need to hide those until the data is retrieved. Before we do that though let’s look at different states an HTTP request tends to be in.

image:https://elmprogramming.com/images/chapter-6/6.5-remote-data/http-request-states.svg[]

Before the _Get data from server_ button is clicked the request for fetching posts is in the `+Not Asked+` state because we haven’t asked for that data yet. When the button is clicked the request transitions to the `Loading` state. If the request is successful, it ends up in the `Success` state. If not, it moves to the `Failure` state.

So far we have only dealt with the `Success` and `Failure` states. Once we handle the remaining two, our UI will be in a much better shape. We will be using a third-party package called https://package.elm-lang.org/packages/krisajenkins/remotedata/latest/[`+krisajenkins/remotedata+`] to handle the remaining states. Go ahead and install it by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install krisajenkins/remotedata
----

Answer `y` when asked to update `elm.json`. After that, import the `RemoteData` module in `DecodingJson.elm`.

[source,elm]
----
module DecodingJson exposing (main)

import RemoteData exposing (RemoteData, WebData)
.
.
----

==== Handling Not Asked State

The `RemoteData` module provides a type by the same name.

[source,elm]
----
type RemoteData error value
    = NotAsked
    | Loading
    | Failure error
    | Success value
----

****
NOTE: It’s perfectly fine to use the same name for a module and a type. In fact you will see this pattern over and over again with many built-in modules such as https://package.elm-lang.org/packages/elm/core/latest/Array[Array], https://package.elm-lang.org/packages/elm/html/latest/Html[Html], and https://package.elm-lang.org/packages/elm/core/latest/Task[Task].
****

Aha! The four data constructors look identical to different states we saw earlier. We need to modify several parts of our app to be able to take advantage of `RemoteData`. What follows is a step-by-step guide for making those changes.

===== Step 1: Modify the Model

The first thing we need to do is change our model. Currently, we are directly assigning a list to the `posts` field.

[source,elm]
----
type alias Model =
    { posts : List Post
    , errorMessage : Maybe String
    }
----

We need to wrap that list with `RemoteData`. Go ahead and change the `Model` type in `DecodingJson.elm` to this:

[source,elm]
----
type alias Model =
    { posts : RemoteData Http.Error (List Post)
    }
----

We removed the `errorMessage` field because any potential error now resides in the `posts` field itself. We can simplify the type of `posts` by using `WebData` instead.

[source,elm]
----
type alias Model =
    { posts : WebData (List Post)
    }
----

`WebData` is defined in the `RemoteData` module as a type alias.

[source,elm]
----
type alias WebData a =
      RemoteData Http.Error a
----

`WebData` represents data fetched from an HTTP (also known as Web) server like ours. That’s why the error type is hard-coded to `Http.Error`. If we were retrieving data from a non-HTTP server such as https://en.wikipedia.org/wiki/File_Transfer_Protocol[FTP], we would have to use the `RemoteData` type instead of `WebData`. All non-HTTP requests also go through the same four states we covered earlier.

===== Step 2: Modify init

Currently, we initialize the `posts` field to an empty list.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = []
      , errorMessage = Nothing
      }
    , Cmd.none
    )
----

It doesn’t make sense to assign an empty list to `posts` from the get go. What if the server responds with an empty list indicating there are genuinely no posts in the database? How do we differentiate between that scenario and not having requested data in the first place? The answer is to use `NotAsked` instead of an empty list. Let’s replace `+[]+` with `RemoteData.NotAsked` and remove `errorMessage` from `init`.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.NotAsked }, Cmd.none )
----

===== Step 3: Modify DataReceived’s Payload Type

Next we need to replace the `Result` type in `DataReceived` message’s payload with `WebData`.

[source,elm]
----
type Msg
    = SendHttpRequest
    | DataReceived (WebData (List Post))
----

===== Step 4: Convert Result to RemoteData Value

Here is how we’re creating a command for fetching posts right now:

[source,elm]
----
httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect = Http.expectJson DataReceived (list postDecoder)
        }
----

The type of the `expect` field in `Http.get` depends on the type of our `DataReceived` message.

[source,elm]
----
get :
    { url : String
    , expect : Expect msg
    }
    -> Cmd msg
----

Before we introduced `RemoteData`, `DataReceived` had the following type.

[source,elm]
----
DataReceived : Result Http.Error (List Post) -> Msg
----

Now `DataReceived`’s type has changed to this:

[source,elm]
----
DataReceived : WebData (List Post) -> Msg
----

Since `WebData` is just a type alias for `RemoteData`, the above type signature is equivalent to this:

[source,elm]
----
DataReceived : RemoteData Http.Error (List Post) -> Msg
----

This means the `Result` type must be converted to `RemoteData`. The `RemoteData.fromResult` function is just what we need. Here is how its type signature looks:

[source,elm]
----
fromResult : Result error value -> RemoteData error value
----

Update `httpCommand` in `DecodingJson.elm` to this:

[source,elm]
----
httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect =
            list postDecoder
                |> Http.expectJson (RemoteData.fromResult >> DataReceived)
        }
----

As mentioned in the link:++/model-view-update-part-2.html#using--operator++[Using » Operator] section in chapter 5, `+>>+` is a built-in operator for composing multiple functions. Here is an example:

[source,elm]
----
func1 >> func2 == \param -> func2 (fun1 param)
----

So conceptually we can think of `+RemoteData.fromResult >> DataReceived+` as:

[source,elm]
----
result = Result Http.Error (List Post)

\result -> DataReceived (RemoteData.fromResult result)
----

Remember, all messages that contain a payload are essentially functions behind the scenes. That’s why we were able to use `+>>+` with `DataReceived`.

===== Step 5: Modify update

`DataReceived`’s payload is now of type `WebData` instead of `Result`. That means we can replace the `+DataReceived (Ok posts) ->+` and `+DataReceived (Err httpError) ->+` branches in `update` with something much simpler.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( model, httpCommand )

        DataReceived response ->
            ( { model | posts = response }, Cmd.none )
----

All we’re doing in the `+DataReceived response ->+` branch is assign whatever `response` we get to the `posts` field in our model.

===== Step 6: Modify View Code

The only remaining change is to handle different states in our view code. Modify the `viewPostsOrError` function in `DecodingJson.elm` to this:

[source,elm]
----
viewPostsOrError : Model -> Html Msg
viewPostsOrError model =
    case model.posts of
        RemoteData.NotAsked ->
            text ""

        RemoteData.Loading ->
            h3 [] [ text "Loading..." ]

        RemoteData.Success posts ->
            viewPosts posts

        RemoteData.Failure httpError ->
            viewError (buildErrorMessage httpError)
----

Previously, we were checking for the presence of an error message to determine whether to display posts or an error view.

[source,elm]
----
viewPostsOrError : Model -> Html Msg
viewPostsOrError model =
    case model.errorMessage of
        Just message ->
            viewError message

        Nothing ->
            viewPosts model.posts
----

Now we’re determining which view to display based on different states defined in the `RemoteData` type. We’re ready to test our app. Run `+elm reactor+` from the `+beginning-elm+` directory in terminal if it’s not running already and go to this URL in your browser: http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`]. The only element you should see is a button.

image:https://elmprogramming.com/images/chapter-6/6.5-remote-data/not-asked-view.png[]

==== Transitioning to the Loading State

Run `+json-server+` from the `+beginning-elm+` directory in terminal using the following command if it’s not running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
----

Click the _Get data from server_ button and you should immediately see a table containing posts. Although the HTTP request transitions to _Loading_ state after the button is clicked, we don’t see `+Loading...+` on the page. For that text to appear, we need to make our server wait a couple of seconds before returning a response. Stop `+json-server+` by pressing `+Ctrl + c+` and restart it with the `+--delay+` option.

[source,bash]
----
$ json-server --watch server/db.json -p 5019 --delay 1000
----

`+--delay+` takes the number of milliseconds as an argument. `+json-server+` will now wait for a second before responding to all requests. Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button.

Hmm… We’re still not seeing `+Loading...+`. We forgot to change the state from `NotAsked` to `Loading` in `update` before firing off the HTTP command. `RemoteData` doesn’t transition to _Loading_ automatically. We need to do that manually inside the `+SendHttpRequest ->+` branch in `update`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( { model | posts = RemoteData.Loading }, httpCommand )
        .
        .
----

Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] one more time and click the _Get data from server_ button. You should now see `+Loading...+` while the posts are being fetched.

image:https://elmprogramming.com/images/chapter-6/6.5-remote-data/loading-view.png[]

==== Transitioning to the Failure State

Change the URL inside `httpCommand` in `DecodingJson.elm` to something invalid.

[source,elm]
----
httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/invalid"
        .
        .
----

Since we’re requesting a non-existent resource, the HTTP request will eventually transition to the `Failure` state. Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] and click the _Get data from server_ button. You should see the following error message.

image:https://elmprogramming.com/images/chapter-6/6.5-remote-data/failure-view.png[]

Don’t forget to change the URL back to `+http://localhost:5019/posts+` in `httpCommand`.

==== Summary

In this section, we used a third-party package called `+krisajenkins/remotedata+` to improve our UI by properly handling all four states an HTTP request can be in at any given time. Those four states are: `NotAsked`, `Loading`, `Success`, and `Failure`. https://twitter.com/krisajenkins[Kris Jenkins] — the author of that package — has written a wonderful http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html[blog post] explaining the rationale behind creating `RemoteData`. I highly recommend you read it.

In the next section, we will learn how to send an HTTP command when the app is being initialized. Here is the entire code from `DecodingJson.elm` thus far:

[source,elm]
----
module DecodingJson exposing (main)

import Browser
import Html exposing (..)
import Html.Attributes exposing (href)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode exposing (Decoder, int, list, string)
import Json.Decode.Pipeline exposing (required)
import RemoteData exposing (RemoteData, WebData)


type alias Post =
    { id : Int
    , title : String
    , authorName : String
    , authorUrl : String
    }


type alias Model =
    { posts : WebData (List Post)
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Get data from server" ]
        , viewPostsOrError model
        ]


viewPostsOrError : Model -> Html Msg
viewPostsOrError model =
    case model.posts of
        RemoteData.NotAsked ->
            text ""

        RemoteData.Loading ->
            h3 [] [ text "Loading..." ]

        RemoteData.Success posts ->
            viewPosts posts

        RemoteData.Failure httpError ->
            viewError (buildErrorMessage httpError)


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch data at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewPosts : List Post -> Html Msg
viewPosts posts =
    div []
        [ h3 [] [ text "Posts" ]
        , table []
            ([ viewTableHeader ] ++ List.map viewPost posts)
        ]


viewTableHeader : Html Msg
viewTableHeader =
    tr []
        [ th []
            [ text "ID" ]
        , th []
            [ text "Title" ]
        , th []
            [ text "Author" ]
        ]


viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (String.fromInt post.id) ]
        , td []
            [ text post.title ]
        , td []
            [ a [ href post.authorUrl ] [ text post.authorName ] ]
        ]


type Msg
    = SendHttpRequest
    | DataReceived (WebData (List Post))


postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "authorName" string
        |> required "authorUrl" string


httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect =
            list postDecoder
                |> Http.expectJson (RemoteData.fromResult >> DataReceived)
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendHttpRequest ->
            ( { model | posts = RemoteData.Loading }, httpCommand )

        DataReceived response ->
            ( { model | posts = response }, Cmd.none )


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message


init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.NotAsked }, Cmd.none )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[retrieving-data-on-initialization]]
=== 6.6 Retrieving Data on Initialization


Sometimes we need to fetch data from a server when an app is being initialized. In this section, we will learn how to do just that. So far in this chapter, we have been returning `Cmd.none` from `init` to indicate we don’t want to run any commands during initialization.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.NotAsked }, Cmd.none )
----

Let’s change that. We will be iterating on the same app we built in the last few sections. The good news is we have already extracted the logic for creating a command out to `httpCommand` in `DecodingJson.elm`.

[source,elm]
----
httpCommand : Cmd Msg
httpCommand =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect =
            list postDecoder
                |> Http.expectJson (RemoteData.fromResult >> DataReceived)
        }
----

All that is left to do is replace `Cmd.none` with `httpCommand` in `init`.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.NotAsked }, httpCommand )
----

Run `+json-server+` from the `+beginning-elm+` directory in terminal using the following command if it’s not running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019 --delay 1000
----

Now run `+elm reactor+` from the `+beginning-elm+` directory in a different terminal window and go to this URL in your browser: http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`]. Don’t click the `+Get data from server+` button yet. Just wait for a second and you should see the posts.

image:https://elmprogramming.com/images/chapter-6/6.4-decoding-json-part-2/posts-view.png[]

By passing a command to `init`, we’re telling the Elm runtime to fetch posts when the app is being initialized. But we broke something along the way. The text `+Loading...+` has disappeared again. That’s because we’re initializing the `posts` field in our model with `NotAsked` instead of `Loading`. Let’s fix that.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.Loading }, httpCommand )
----

Refresh the page at http://localhost:8000/src/DecodingJson.elm[`+http://localhost:8000/src/DecodingJson.elm+`] one more time and the loading text should be back.

image:https://elmprogramming.com/images/chapter-6/6.5-remote-data/loading-view.png[]

Let’s rename the button title to `+Refresh posts+` to reflect its new purpose.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendHttpRequest ]
            [ text "Refresh posts" ]
        , viewPostsOrError model
        ]
----

While we are at it, let’s also rename `httpCommand` to `fetchPosts`.

[source,elm]
----
fetchPosts : Cmd Msg
fetchPosts =
    Http.get
        .
        .
----

Don’t forget to replace `httpCommand` with `fetchPosts` in `init` and `update`. We should also rename the messages.

[source,elm]
----
-- Before

type Msg
    = SendHttpRequest
    | DataReceived (WebData (List Post))


-- After

type Msg
    = FetchPosts
    | PostsReceived (WebData (List Post))
----

Now replace `SendHttpRequest` with `FetchPosts` in `view` and `update`, and replace `DataReceived` with `PostsReceived` in `fetchPosts` and `update`.

==== Summary

In this section, we learned how to run a command when an app is being initialized. Here is the entire code from `DecodingJson.elm` thus far:

[source,elm]
----
module DecodingJson exposing (main)

import Browser
import Html exposing (..)
import Html.Attributes exposing (href)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode exposing (Decoder, int, list, string)
import Json.Decode.Pipeline exposing (required)
import RemoteData exposing (RemoteData, WebData)


type alias Post =
    { id : Int
    , title : String
    , authorName : String
    , authorUrl : String
    }


type alias Model =
    { posts : WebData (List Post)
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick FetchPosts ]
            [ text "Refresh posts" ]
        , viewPostsOrError model
        ]


viewPostsOrError : Model -> Html Msg
viewPostsOrError model =
    case model.posts of
        RemoteData.NotAsked ->
            text ""

        RemoteData.Loading ->
            h3 [] [ text "Loading..." ]

        RemoteData.Success posts ->
            viewPosts posts

        RemoteData.Failure httpError ->
            viewError (buildErrorMessage httpError)


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch data at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewPosts : List Post -> Html Msg
viewPosts posts =
    div []
        [ h3 [] [ text "Posts" ]
        , table []
            ([ viewTableHeader ] ++ List.map viewPost posts)
        ]


viewTableHeader : Html Msg
viewTableHeader =
    tr []
        [ th []
            [ text "ID" ]
        , th []
            [ text "Title" ]
        , th []
            [ text "Author" ]
        ]


viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (String.fromInt post.id) ]
        , td []
            [ text post.title ]
        , td []
            [ a [ href post.authorUrl ] [ text post.authorName ] ]
        ]


type Msg
    = FetchPosts
    | PostsReceived (WebData (List Post))


postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "authorName" string
        |> required "authorUrl" string


fetchPosts : Cmd Msg
fetchPosts =
    Http.get
        { url = "http://localhost:5019/posts"
        , expect =
            list postDecoder
                |> Http.expectJson (RemoteData.fromResult >> PostsReceived)
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        FetchPosts ->
            ( { model | posts = RemoteData.Loading }, fetchPosts )

        PostsReceived response ->
            ( { model | posts = response }, Cmd.none )


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message


init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.Loading }, fetchPosts )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[http-requests-conclusion]]
=== 6.7 Conclusion


In this chapter, we learned how to fetch data from a server by sending an HTTP `GET` request. The `Http.get` function offers a simple syntax for specifying the url and format of the data.

[source,elm]
----
get :
    { url : String
    , expect : Expect msg
    }
    -> Cmd msg
----

We handed off the <<commands, command>> returned by `Http.get` to the Elm runtime. We then used the decoders from `Json.Decode` module to translate JSON values to Elm data structures. Along the way, we learned how to fire commands when an app is being initialized.

Finally, we used a third-party package called `+krisajenkins/remotedata+` to improve our UI by properly handling all four states an HTTP request can be in at any given time. Those four states are: `NotAsked`, `Loading`, `Success`, and `Failure`.

In the next chapter, we’ll learn how to use the `POST`, `PATCH`, and `DELETE` HTTP requests to create, update, and delete a resource respectively.


[[single-page-apps-intro]]
== 7 Single-Page Apps

=== 7.1 prelude

All apps we’ve built so far in this book only focus on accomplishing a single task. It’s time for us to learn how to build more complex Elm apps. In this chapter, we’ll do just that by adding more features to the DecodingJson app we built in <<retrieving-data-on-initialization, chapter 6>>.

We’ll methodically refactor the code in DecodingJson.elm to a more flexible structure that will allow us to add new features and modify the existing ones with ease. We’ll also learn how to send the POST, PATCH, and DELETE HTTP requests to a server so that we can create, update, and delete posts respectively.

By the end of this chapter, we’ll have built a full-fledged Elm app for managing posts that includes a robust mechanism for navigating to different parts of the app.


[[what-is-a-single-page-app]]
=== 7.2 What is a Single-Page App?


On a very high level, web applications tend to have two major parts: front end and back end. The back end is responsible for computing data and the front end is responsible for presenting that data to the users.

The front end primarily consists of a presentation layer for displaying and navigating between HTML pages. Whereas the back end consists of a data layer for retrieving data from a database or an external service and a business layer for performing operations on that data.

==== Traditional Web Applications

In a traditional web application, both front and back ends are implemented on the server-side. A request is sent from a browser to a server. The presentation layer intercepts the request and forwards it to a component in business layer responsible for fulfilling that request. If the business component needs to access data from a database or an external service, it’ll make that request to the data layer. The business layer returns the result of its computation to the presentation layer. The presentation layer then determines how to display that result and sends an HTML page back to the browser. The figure below shows this end-to-end interaction between a browser and the server-side components.

image:https://elmprogramming.com/images/chapter-7/7.2-what-is-a-single-page-app/server-side-rendering.svg[]

==== Single-Page Web Applications

Often times, after an application is loaded in a browser, all client-side wants to do is send or receive new data from a server. However, with the architecture shown above, the server has to send an entire HTML page back and not just the fresh data client is interested in. This is because the presentation layer sits on the server-side. Without this layer, the client is just a dumb terminal for requesting pages. What if we move the presentation layer to the client-side as shown below?

image:https://elmprogramming.com/images/chapter-7/7.2-what-is-a-single-page-app/client-side-rendering.svg[]

With the new architecture, the entire front end is loaded at once on the client-side. This enables the client to send and receive just the data it’s interested in and nothing more. It can send those requests asynchronously via https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started[ajax].

Instead of receiving a full HTML page as a response, the client now gets a JSON representation of the data it requested. (Although a response typically is in JSON format, it doesn’t have to be.) It then updates parts of the page that display the new data without having to reload the entire page. This approach reduces unnecessary overhead incurred by traditional web applications. This is essentially how most single-page applications (SPAs) work.

****
NOTE: There is a hybrid approach to building SPAs that offers partial rendering of pages on the server-side. Explaining how this approach works is out of scope for this book.
****

===== Application Shell

The term single-page might sound confusing at first. What it means is that it’s a shell that defines an overall layout of the application. This layout divides the application into multiple regions, for example header, footer, sidebar, and main content.

image:https://elmprogramming.com/images/chapter-7/7.2-what-is-a-single-page-app/spa-shell.svg[]

Whenever the user attempts to navigate from one part of the application to another, the application determines which region(s) needs to be refreshed. It will then swap the view that is currently being displayed in that region with a new view. During the initial load, the client side fetches all views in the application along with the shell. It has to do that because in an SPA architecture, the entire presentation layer is moved to the client side.

Of course the application doesn’t display all of those views at the same time. It will wait for the right conditions to be met before showing a particular view. This mechanism is what enables SPAs to present rich user interfaces without having to retrieve a new page from the server every time the user attempts to navigate to a different part of the application.

==== Our Front End

The Elm app we’ll be building in this chapter is a SPA. It’ll be rendered fully on the client-side. This drastically simplifies the server-side implementation. However, all of that presentation complexity is now shifted over to the client-side. Luckily, Elm provides a <<elm-architecture-intro, robust architecture>> for structuring client-side applications no matter how complex they are.

==== Our Back End

The architectural diagram shown in the <<what-is-a-single-page-app, Single-Page Web Applications>> section above is a gross oversimplification of how back end apps are architected. Depending on how complex the app is, you may want to follow the guidelines set forth by a well-established architectural pattern such as https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell[Functional Core Imperative Shell], https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html[Clean Architecture] or https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215[Domain Driven Design].

We won’t be using any of those patterns for our back end because it’s a very simple JSON server designed to serve data from a file. We created this server in the link:decoding-json-part-1.html[Decoding JSON - Part 1] section in chapter 6. All interactions between our front and back ends will occur via APIs only. The table below shows all the API end points our Elm app will be using to send and receive data.

[cols=",,,",options="header,autowidth",frame=ends,grid=rows]
|===
|*Action* |*Endpoint* |*HTTP Method* |*Full URL*
|Fetch all posts |`+/posts+` |`GET` |`+http://localhost:8000/posts+`
|Create a new post |`+/posts+` |`POST` |`+http://localhost:8000/posts+`
|Edit a post |`+/posts/<post-id>+` |`PATCH` |`+http://localhost:8000/posts/<post-id>+`
|Delete a post |`+/posts/<post-id>+` |`DELETE` |`+http://localhost:8000/posts/<post-id>+`
|===

Because our front and back ends are fully decoupled, we won’t have to modify the back end at all if we ever decide to port our Elm app to other platforms, for example iOS or Android. An iOS or Android app can replicate the functionality in our Elm app by using the exact same APIs provided by the back end. Similarly, we also don’t have to modify the front-end apps if we ever decide to port our back end to a different platform as long as the APIs remain the same.


[[restructuring-code]]
=== 7.3 Restructuring Code


For the remainder of this chapter, we’ll be exploring how to send the `POST`, `PATCH`, and `DELETE` HTTP requests to create, update, and delete posts respectively. Before we do that though, we need to restructure the code in `DecodingJson.elm`. It has reached a point where breaking it into smaller modules will make adding new features easier.

The recommended way to manage data flow in an Elm app is to use the <<elm-architecture-intro, Elm Architecture>>. Elm doesn’t have such a recommendation when it comes to organizing code, so we can structure our code however we want. There are many different ways to do it, but we’ll follow the https://guide.elm-lang.org/webapps/structure.html[suggestion] from Evan Czaplicki — the creator of Elm.

Per Evan’s advice, all modules in an Elm app should be built around a central type. That means we should create a separate module for each page in the posts app. Currently, we only have one page for displaying posts. Soon we’ll add more pages for creating and editing posts.

The central type for each page module will be `Model`. The page modules will also be provided with separate `init`, `update`, and `view` functions. That will enable them to independently follow the <<elm-architecture-intro, Elm Architecture>>. The idea here is to let each individual page manage itself.

Any common data structures such as `Post` will also get their own modules. Finally, we’ll wire everything together in the `Main` module which will also have its own `Model`, `init`, `update`, and `view` functions. The final directory structure will look something like this:

image:https://elmprogramming.com/images/chapter-7/7.3-restructuring-code/post-app-directory-structure.png[]

Don’t worry if some of this doesn’t make sense yet. In the following sections, I’ll provide step-by-step instructions to guide you through the entire process of transforming the code in `DecodingJson.elm` to a more robust structure that will allow us to add new features and modify existing ones with ease.


[[creating-post-module]]
=== 7.4 Creating Post Module


Let’s create a new directory called `+post-app+` inside `+beginning-elm+` instead of cluttering the `src` directory with too many modules.

image:https://elmprogramming.com/images/chapter-7/7.4-creating-post-module/create-post-app-directory.png[]

We need to add `+post-app+` to the `+source-directories+` list in `elm.json`.

[source,json]
----
{
    .
    .
    "source-directories": [
        "src",
        "post-app"
    ],
    .
    .
}
----

==== Creating the Post Module

Let’s move the `Post` type and the code for decoding it from `DecodingJson.elm` to a new module. Create a new file called `Post.elm` inside the `+post-app+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-7/7.4-creating-post-module/create-post-module.png[]

[source,elm]
----
module Post exposing (Post, postDecoder, postsDecoder)

import Json.Decode as Decode exposing (Decoder, int, list, string)
import Json.Decode.Pipeline exposing (required)


type alias Post =
    { id : Int
    , title : String
    , authorName : String
    , authorUrl : String
    }


postsDecoder : Decoder (List Post)
postsDecoder =
    list postDecoder


postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" int
        |> required "title" string
        |> required "authorName" string
        |> required "authorUrl" string
----

==== Using Custom Types for ID

Currently, the `id` field in `Post` is an integer. We could mistakenly pass an identifier of a different data structure, which also happens to be an integer, to a function expecting a post `id`. The Elm compiler won’t be able to catch a bug like that. We can help the compiler by implementing identifiers as <<type-system, custom types>>. Add the following code below the `Post` type alias in `Post.elm`.

[source,elm]
----
type PostId
    = PostId Int
----

`PostId` is an <<commands, opaque type>>. Let’s expose it in the module definition.

[source,elm]
----
module Post exposing (Post, PostId, postDecoder, postsDecoder)
----

Change the `id` field’s type in `Post` from `Int` to `PostId`.

[source,elm]
----
type alias Post =
    { id : PostId
    .
    .
----

==== `PostId` Decoder

Now that `id` is a custom type, simply using the `int` decoder in `postDecoder` won’t be enough. We need to create a custom decoder. Add the following code to the bottom of `Post.elm`.

[source,elm]
----
idDecoder : Decoder PostId
idDecoder =
    Decode.map PostId int
----

We used the `Decode.map` function to convert an integer to `PostId`. Here is what its type signature looks like:

[source,elm]
----
map : (a -> value) -> Decoder a -> Decoder value
----

Now we can replace `int` with `idDecoder` in `postDecoder`.

[source,elm]
----
postDecoder : Decoder Post
postDecoder =
    Decode.succeed Post
        |> required "id" idDecoder
        .
        .
----

==== Converting `PostId` to String

The `viewPost` function in `DecodingJson.elm` uses `String.fromInt` to convert an `id` to a string.

[source,elm]
----
viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (String.fromInt post.id) ]
            .
            .
----

Now that the `id` field holds a value of a custom type that’s not going to work. We need to define a custom function for that. Add the following code to the bottom of `Post.elm`.

****
NOTE: Although we’re moving away from `DecodingJson.elm`, we’ll still be using the `viewPost` function in a module responsible for fetching and displaying posts in the next section.
****

[source,elm]
----
idToString : PostId -> String
idToString (PostId id) =
    String.fromInt id
----

`idToString` uses <<pattern-matching, pattern matching>> to expose the underlying integer value inside the `PostId` data constructor. Without this ability, we’d be forced to use a <<case-expression, `case` expression>> which is not as elegant.

[source,elm]
----
idToString : PostId -> String
idToString postId =
    case postId of
        PostId id ->
            String.fromInt id
----

Finally we need to expose `idToString` in the module definition.

[source,elm]
----
module Post exposing (Post, PostId, idToString, postDecoder, postsDecoder)
----

In the next section, we’ll create a separate page for fetching and listing all posts in our database.


[[creating-list-posts-page]]
=== 7.5 Creating List Posts Page


Let’s move the code for fetching and displaying all posts to a new module. Create a new directory called `Page` inside `+post-app+` and add a file named `ListPosts.elm` to it.

image:https://elmprogramming.com/images/chapter-7/7.5-creating-list-posts-page/create-list-posts-file.png[]

Add the following code to `ListPosts.elm`.

[source,elm]
----
module Page.ListPosts exposing (Model, Msg, init, update, view)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)
import Http
import Json.Decode as Decode
import Post exposing (Post, PostId, postsDecoder)
import RemoteData exposing (WebData)


type alias Model =
    { posts : WebData (List Post)
    }


type Msg
    = FetchPosts
    | PostsReceived (WebData (List Post))


init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.Loading }, fetchPosts )


fetchPosts : Cmd Msg
fetchPosts =
    Http.get
        { url = "http://localhost:5019/posts/"
        , expect =
            postsDecoder
                |> Http.expectJson (RemoteData.fromResult >> PostsReceived)
        }


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        FetchPosts ->
            ( { model | posts = RemoteData.Loading }, fetchPosts )

        PostsReceived response ->
            ( { model | posts = response }, Cmd.none )



-- VIEWS


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick FetchPosts ]
            [ text "Refresh posts" ]
        , viewPosts model.posts
        ]


viewPosts : WebData (List Post) -> Html Msg
viewPosts posts =
    case posts of
        RemoteData.NotAsked ->
            text ""

        RemoteData.Loading ->
            h3 [] [ text "Loading..." ]

        RemoteData.Success actualPosts ->
            div []
                [ h3 [] [ text "Posts" ]
                , table []
                    ([ viewTableHeader ] ++ List.map viewPost actualPosts)
                ]

        RemoteData.Failure httpError ->
            viewFetchError (buildErrorMessage httpError)


viewTableHeader : Html Msg
viewTableHeader =
    tr []
        [ th []
            [ text "ID" ]
        , th []
            [ text "Title" ]
        , th []
            [ text "Author" ]
        ]


viewPost : Post -> Html Msg
viewPost post =
    tr []
        [ td []
            [ text (Post.idToString post.id) ]
        , td []
            [ text post.title ]
        , td []
            [ a [ href post.authorUrl ] [ text post.authorName ] ]
        ]


viewFetchError : String -> Html Msg
viewFetchError errorMessage =
    let
        errorHeading =
            "Couldn't fetch posts at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message
----

==== Creating the Main Module

We moved almost all of the code from `DecodingJson.elm` to either `ListPosts.elm` or `Post.elm`. The only thing remaining is the `main` function. Where should we put it? It too should have its own module. Create a new file called `Main.elm` in the `+post-app+` directory and add the following code to it.

image:https://elmprogramming.com/images/chapter-7/7.5-creating-list-posts-page/create-main-file.png[]

[source,elm]
----
module Main exposing (main)

import Browser
import Page.ListPosts as ListPosts


main : Program () ListPosts.Model ListPosts.Msg
main =
    Browser.element
        { init = ListPosts.init
        , view = ListPosts.view
        , update = ListPosts.update
        , subscriptions = \_ -> Sub.none
        }
----

Right now the `Main` module relies heavily on the `ListPosts` page. In the next section, we’ll give it its own `Model`, `Msg`, `init`, `view`, and `update` functions so that it’s not tightly coupled to any specific module. Going forward, the primary responsibility of `Main` will be to route users to the correct page.

Before moving on, let’s make sure everything is working. Run `+json-server+` from the `+beginning-elm+` directory in terminal using the following command.

[source,bash]
----
$ json-server --watch server/db.json -p 5019 --delay 1000
----

Now run `+elm reactor+` from the `+beginning-elm+` directory in a different terminal window and go to this URL in your browser: http://localhost:8000/post-app/Main.elm[`+http://localhost:8000/post-app/Main.elm+`]. You should see a list of posts.

image:https://elmprogramming.com/images/chapter-7/7.5-creating-list-posts-page/list-posts-page.png[]


[[navigating-to-list-posts-page]]
=== 7.6 Navigating to List Posts Page


In this section, we’ll learn how to properly route users to the correct page. Elm provides the following modules to facilitate routing in an app.

* `Browser.Navigation`
* `Url`
* `Url.Parser`
* `Url.Builder`
* `+Url.Parser.Query+`

The routing logic for our app is relatively simple. Therefore, we only need the first three modules from the list above. `Browser.Navigation` is included in the https://package.elm-lang.org/packages/elm/browser/latest/[`+elm/browser+`] package, which was installed automatically when we ran `+elm make+` after our project was initialized in the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section in chapter 2.

The rest of the modules are included in the https://package.elm-lang.org/packages/elm/url/latest/[`+elm/url+`] package which is also installed already but as an indirect dependency. Let’s make it a direct dependency by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm install elm/url
----

Answer `y` when asked to update `elm.json`. Before we implement the routing logic, we need to know which URL will be used to access the `ListPosts` page. Back in the <<decoding-json-part-1, Creating a Local JSON Server>> section, we used the http://localhost:5019/posts[`+http://localhost:5019/posts+`] URL to fetch all posts in our database file (`+server/db.json+`).

[source,json]
----
[
  {
    "id": 1,
    "title": "json-server",
    "authorName": "typicode",
    "authorUrl": "https://github.com/typicode"
  },
  {
    "id": 2,
    "title": "http-server",
    "authorName": "indexzero",
    "authorUrl": "https://github.com/indexzero"
  }
]
----

To retrieve an individual post, we appended its ID to the end like this: http://localhost:5019/posts/1[`+http://localhost:5019/posts/1+`].

[source,json]
----
{
  "id": 1,
  "title": "json-server",
  "authorName": "typicode",
  "authorUrl": "https://github.com/typicode"
}
----

We’ll be using a similar URL pattern for accessing the list and edit pages.

* Full URL for the list page: http://localhost:8000/posts[`+http://localhost:8000/posts+`]
* Full URL for the edit page: http://localhost:8000/posts/1[`+http://localhost:8000/posts/1+`]

==== The `Url` Type

The `Url` module defines a type alias by the same name. Here’s how its definition looks:

[source,elm]
----
type alias Url =
    { protocol : Protocol
    , host : String
    , port_ : Maybe Int
    , path : String
    , query : Maybe String
    , fragment : Maybe String
    }
----

And here’s the definition for the `Protocol` type:

[source,elm]
----
type Protocol
    = Http
    | Https
----

The following diagram maps the fields in a `Url` record to various parts of an actual url.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/url-fields.svg[]

==== Extracting Route From URL

We should never use a full URL to navigate to a certain page. This is because the URL will change as we move our code through different environments. Right now we are building `+post-app+` on a local machine with `+localhost:8000+` as its address. When it’s ready for production we’ll need to deploy it to some other environment whose address will be different. If we use URL to navigate, the address won’t match and our app will break. We can avoid this issue by using paths instead.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/explain-paths.svg[]

Paths are generally represented as strings. It would be great if we could convert them to <<type-system, custom types>>.
That way the compiler will warn us if we make a mistake while typing. Let’s define a type called `Route`. Create a new file named `Route.elm` in the `+post-app+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/create-route-file.png[]

[source,elm]
----
module Route exposing (Route(..), parseUrl)

import Url exposing (Url)
import Url.Parser exposing (..)


type Route
    = NotFound
    | Posts


parseUrl : Url -> Route
parseUrl url =
    case parse matchRoute url of
        Just route ->
            route

        Nothing ->
            NotFound


matchRoute : Parser (Route -> a) a
matchRoute =
    oneOf
        [ map Posts top
        , map Posts (s "posts")
        ]
----

The `parseUrl` function uses `parse` — defined in the `Url.Parser` module — to extract a path from the given url and translate it to one of the values in the `Route` type. The `parse` function, in turn, uses `matchRoute` to check if the given url contains one of these routes:

* `Posts` - represents the `ListPosts` page.
* `NotFound` - represents the not-found page. We’ll create this page later.

If yes, `parseUrl` returns that route wrapped in `Just`. Otherwise it returns `NotFound` to indicate that the given url doesn’t contain a route for any of the resources in the app.

****
NOTE: We haven’t defined a route for the `EditPosts` page yet. We’ll do that in the <<editing-a-post, next section>> when we create that page.
****

==== Matching Routes

`matchRoute` defines parsers that know how to extract a given path from a url.

[source,elm]
----
matchRoute : Parser (Route -> a) a
matchRoute =
    oneOf
        [ map Posts top
        , map Posts (s "posts")
        ]
----

Parser::
  A parser is a component in a software program that takes some input data, checks for correct syntax, and builds a data structure which is easier to operate on compared to the original format. In our case the input data is a url. If the url is in correct format then the parser starts to look for a given path in it. If a match is found, it translates that path to one of the data constructors from the `Route` type.

The table below shows which parser is responsible for matching which path in a given url.

[cols=",,,",options="header,autowidth",frame=ends,grid=rows]
|===
|*URL* |*Path* |*Parser* |*Route*
|`+http://localhost:8000+` | |`top` |`Posts`
|`+http://localhost:8000/posts+` |`+/posts+` |`+s "posts"+` |`Posts`
|===

Notice how the first row doesn’t specify any path. If a path is missing, we want to take the user to the list page. `top` defines a parser that doesn’t look for any path. The `s` function also defines a parser, but it takes a path as an argument. Both `top` and `s` are defined in the `Url.Parser` module.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/parser-for-posts-path.svg[]

****
NOTE: We’ll dig deeper into `s` and other parsers from `Url.Parser` later in the <<editing-a-post, Primitive Parsers>> and <<editing-a-post, Custom Parsers>> sections.
****

The `oneOf` function executes the parsers one at a time starting from the top. It stops as soon as a match is found for the entire path and not just a portion of it.

==== Storing Current Route

For routing to work properly, we need to know which page the user is currently on. Let’s store that information in `Main`. Add the following code to the bottom of `Main.elm`.

[source,elm]
----
type alias Model =
    { route : Route
    , page : Page
    }


type Page
    = NotFoundPage
    | ListPage ListPosts.Model
----

And import the `Route` module in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Route exposing (Route)
.
.
----

We’re storing both current route and page in our main model. We’ll determine which page to navigate to based on the current route. To make things easier to manage, we’ve created a new type called `Page` in `Main` instead of using the page modules directly.

Why are we storing the page model as a payload in the `ListPage` data constructor but not in `NotFoundPage`? You’ll soon see that the not-found page is nothing but a simple view with no state. However, all other pages in our app will have their own states. For example, the `ListPosts` page uses the following data structure to store its state.

[source,elm]
----
type alias Model =
    { posts : WebData (List Post)
    }
----

We’ll be passing this state to the page’s `view` function later. Don’t worry if some of this doesn’t make sense yet. Once we write some concrete code it’ll all be clear.

==== Routing to the Correct Page

The overall process for routing users to the correct page can be summarized in the following steps.

*Step 1.* Enter a full url in the browser’s address bar.

*Step 2.* Convert the url from step 1 to `Url` type. This is done by the Elm runtime behind the scenes.

*Step 3.* Extract a route from url and store it in the `route` field inside `Main` module’s model.

*Step 4.* Determine which page to display based on `route`.

*Step 5.* Ask the page from step 4 to return its model by calling its `init` function.

*Step 6.* Pass the model from step 5 to that page’s `view` function.

==== Initializing the Main Model

Steps 1 and 2 are already in place. Let’s implement step 3 by adding the `init` function to the bottom of `Main.elm`.

[source,elm]
----
init : () -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    let
        model =
            { route = Route.parseUrl url
            , page = NotFoundPage
            , navKey = navKey
            }
    in
    initCurrentPage ( model, Cmd.none )
----

We need to import the `Browser.Navigation` and `Url` modules in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Browser.Navigation as Nav
import Url exposing (Url)
.
.
----

The `init` function in `ListPosts.elm` took `flags` as the only parameter.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.Loading }, fetchPosts )
----

****
NOTE: Since we didn’t use `flags` anywhere inside the `init` function’s body, we replaced it with `_`. If you don’t remember why we need to include that parameter even if it’s not used, you may want to review the <<commands, Commands>> section from chapter 5.
****

In contrast, the `init` function in `Main.elm` takes two additional parameters: `url` and `navKey`.

===== url

This parameter represents the full url of a specific page. In our app, this can be either the home page (http://localhost:8000[`+http://localhost:8000+`]) or the list posts page (http://localhost:8000/posts[`+http://localhost:8000/posts+`]) or any other page we might add in the future. We need to extract a route from this url by using the `Route.parseUrl` function we created earlier in the <<navigating-to-list-posts-page, Extracting Route From URL>> section and store it in the `route` field.

[source,elm]
----
model =
    { route = Route.parseUrl url
    .
    .
----

===== navKey

A navigation key is needed to create commands that will tell the Elm runtime to change the url in a browser’s address bar. You’ll see an example of such a command shortly. We don’t need to create a navigation key by ourselves. The runtime will create one for us and pass it to the `init` function when our app is being initialized. We need to add `navKey` to the model in `Main.elm`.

[source,elm]
----
type alias Model =
    { route : Route
    , page : Page
    , navKey : Nav.Key
    }
----

==== Defining Messages

Each page in our app will have its own `Msg` type. To properly manage the interaction between pages, the `Main` module needs to define a separate higher level `Msg` type of its own. Add the following code below the `Page` type in `Main.elm`.

[source,elm]
----
type Msg
    = ListPageMsg ListPosts.Msg
----

The `ListPageMsg` data constructor represents all messages meant to be handled by the `ListPosts` module. The `Main` module doesn’t handle any page specific messages. It simply forwards them to the correct page module.

==== Initializing the Current Page

The `init` function in `Main` has two responsibilities:

* Initialize the main model.
* Initialize the current page.

It delegates the second responsibility to the `initCurrentPage` function. Let’s implement that function by adding the following code below `init` in `Main.elm`.

[source,elm]
----
initCurrentPage : ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
initCurrentPage ( model, existingCmds ) =
    let
        ( currentPage, mappedPageCmds ) =
            case model.route of
                Route.NotFound ->
                    ( NotFoundPage, Cmd.none )

                Route.Posts ->
                    let
                        ( pageModel, pageCmds ) =
                            ListPosts.init
                    in
                    ( ListPage pageModel, Cmd.map ListPageMsg pageCmds )
    in
    ( { model | page = currentPage }
    , Cmd.batch [ existingCmds, mappedPageCmds ]
    )
----

`initCurrentPage` takes the main model and any commands we may want to fire when the app is being initialized. It then looks at the current route and determines which page to initialize. If the route is `NotFound`, we need to display the `NotFoundPage` which doesn’t need to be initialized. But if the current route is `Posts`, we need to initialize the `ListPosts` page by calling its `init` function which looks like this:

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( { posts = RemoteData.Loading }, fetchPosts )
----

Now that `Main` has its own `init`, we don’t need to pass `flags` to `ListPosts.init`. Let’s remove that parameter from `ListPosts.elm`.

[source,elm]
----
init : ( Model, Cmd Msg )
init =
    ( { posts = RemoteData.Loading }, fetchPosts )
----

`ListPosts.init` returns a model and commands specific to that page. The next step is to add the page model as a payload to the `ListPage` data constructor and map page commands in `Main.elm`.

===== Mapping Page Commands

Although each page is capable of creating its own commands, it can’t fire them off to the Elm runtime. That responsibility lies with the `Main` module. The page commands are designed to send a page specific message after they are executed. For example, the `fetchPosts` command in `ListPosts.elm` sends the `PostsReceived` message, which is also defined in `ListPosts.elm`.

[source,elm]
----
fetchPosts : Cmd Msg
fetchPosts =
    Http.get
        { url = "http://localhost:5019/posts/"
        , expect =
            postsDecoder
                |> Http.expectJson (RemoteData.fromResult >> PostsReceived)
        }


type Msg
    = FetchPosts
    | PostsReceived (WebData (List Post))
----

Unfortunately, the `Main` module isn’t aware of the `PostsReceived` message. All it knows is that the `ListPosts` module has a type called `Msg`. It doesn’t know the internal details of that type because in `ListPost`’s module definition we didn’t use `+(..)+` after `Msg`.

****
NOTE: If you don’t remember how `+(..)+` works, you may want to review the <<easier-code-organization, Creating a Module>> section from chapter 4.
****

[source,elm]
----
module Page.ListPosts exposing (Model, Msg, init, update, view)
----

We did that on purpose because we don’t want any outside code to know about the specific messages a page can handle. This encapsulation makes our code easier to maintain in the long run.

Because `Main` doesn’t know anything about the page specific messages, it needs to map them to one of the data constructors from its own `Msg` type using the `Cmd.map` function. The `Route.Posts` branch from `initCurrentPage` does exactly that.

[source,elm]
----
Route.Posts ->
    let
        ( pageModel, pageCmds ) =
            ListPosts.init
    in
    ( ListPage pageModel, Cmd.map ListPageMsg pageCmds )
----

The diagram below explains different parts of `Cmd.map`’s type signature.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/cmd-map-syntax.svg[]

Now that we’re done mapping page commands, all that is left is to combine `existingCmds` with `mappedPageCmds`. We can do that by using the `Cmd.batch` function.

[source,elm]
----
initCurrentPage : ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
initCurrentPage ( model, existingCmds ) =
    .
    .
    , Cmd.batch [ existingCmds, mappedPageCmds ]
    )
----

Here’s what `Cmd.batch`’s type signature looks like:

[source,elm]
----
Cmd.batch : List (Cmd msg) -> Cmd msg
----

`Cmd.batch` takes a list of commands and batches them together so that we can hand them all to the runtime at the same time. The runtime then executes them in an arbitrary order.

==== Displaying the Current Page

Now that we’ve determined which page the user should be navigated to based on the current route, we need to figure out how to actually display that page. We’ll do that by adding the following code to the bottom of `Main.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    case model.page of
        NotFoundPage ->
            notFoundView

        ListPage pageModel ->
            ListPosts.view pageModel
                |> Html.map ListPageMsg


notFoundView : Html msg
notFoundView =
    h3 [] [ text "Oops! The page you requested was not found!" ]
----

If the current page is `NotFoundPage`, an error message is displayed. Otherwise, the responsibility for displaying the page is delegated to its `view` function.

As mentioned in the <<navigating-to-list-posts-page, Mapping Page Commands>> section above, the page specific messages should be transformed to a main message. When we’re dealing with commands, that transformation happens through `Cmd.map`. But when we’re dealing with HTML, we need to use the `Html.map` function. The following diagram illustrates the difference between their type signatures.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/cmd-map-vs-html-map.svg[]

We need to import the `Html` module in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Html exposing (..)
.
.
----

==== Updating Page Models

We now know how to initialize and display the current page. Next we need to figure out how to update the current page’s model. Add the following code to the bottom of `Main.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        ( ListPageMsg subMsg, ListPage pageModel ) ->
            let
                ( updatedPageModel, updatedCmd ) =
                    ListPosts.update subMsg pageModel
            in
            ( { model | page = ListPage updatedPageModel }
            , Cmd.map ListPageMsg updatedCmd
            )

        ( _, _ ) ->
            ( model, Cmd.none )
----

The `update` function above takes a main message and the main model as inputs. The `Main` module isn’t responsible for updating page models. That responsibility lies with page modules. That’s why we need to call a page specific `update` function to get an updated page model and a new list of page commands.

[source,elm]
----
( updatedPageModel, updatedCmd ) =
    ListPosts.update subMsg pageModel
----

Once we have an updated page model, we simply store it in the main model’s `page` field. We then <<navigating-to-list-posts-page, transform the messages>> produced by page commands to a main message using `Cmd.map`.

[source,elm]
----
( { model | page = ListPage updatedPageModel }
, Cmd.map ListPageMsg updatedCmd
)
----

We also added a <<case-expression, catch-all>> branch to `update` so that we won’t have to handle every permutation of the `Msg` and `Page` types as we add more data constructors to those types in the future.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( _, _ ) ->
            ( model, Cmd.none )
----

==== Navigating to the Current Page

So far we’ve implemented the code for determining what the current page should be and how to display it. But we haven’t specified how to navigate to that page yet. Let’s do that by replacing the `main` function in `Main.elm` with the following.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        , onUrlRequest = LinkClicked
        , onUrlChange = UrlChanged
        }
----

Here’s what it looked like before:

[source,elm]
----
main : Program () ListPosts.Model ListPosts.Msg
main =
    Browser.element
        { init = ListPosts.init
        , view = ListPosts.view
        , update = ListPosts.update
        , subscriptions = \_ -> Sub.none
        }
----

We’re now using `Model`, `Msg`, `init`, `view`, and `update` from the `Main` module instead of relying on `ListPosts`. We also replaced `Browser.element` with `Browser.application`.

Browser.sandbox vs Browser.element vs Browser.application::
  In the <<commands, Commands>> section, we compared `Browser.sandbox` with `Browser.element`. Both of those functions create small Elm programs that are meant to be embedded in a larger JavaScript application. This fact isn’t apparent when we use `+elm reactor+` because it automatically embeds our app behind the scenes.
+
However, if we build our app by manually compiling the Elm code to JavaScript as shown in the <<elm-make, `+elm-make+`>> section from chapter 2 then it becomes quite clear that both `Browser.sandbox` and `Browser.element` create Elm programs that are meant to take over a specific HTML element in a larger JavaScript application.
+
A good way to https://elm-lang.org/blog/how-to-use-elm-at-work[introduce Elm at work] is by implementing a small feature using either `Browser.sandbox` or `Browser.element` and embedding it in a larger JavaScript application. If that feature is a success and the team is happy working with Elm, you may continue implementing more features in Elm. Eventually, you’ll need the ability to navigate between multiple pages implemented in Elm. That’s when you’ll reach for `Browser.application` which provides a robust mechanism for managing multiple pages.
+
To be clear, even if the user thinks an Elm app has multiple pages, behind the scenes it’s just a <<what-is-a-single-page-app, single page>> doing all the work. During initialization, the HTML code for all pages is loaded at once. When a link to an internal page is clicked, the app overwrites the contents of the current page instead of loading a new page from a server and simply changes the URL in a browser’s address bar.
+
If you’re working on a greenfield project that requires users to navigate to different parts of the application, you can start directly with `Browser.application`. Otherwise it’s better to start small with `Browser.sandbox` and work your way up to `Browser.application`.

===== Navigation Scenarios

In any Elm app, there are three navigation scenarios we need to handle:

* When the application starts
* When the user clicks a link
* When the URL is changed

Let’s go through these scenarios one by one.

==== Navigation Scenario 1: When the Application Starts

Although we have already handled this scenario, let’s go through it once again to understand what really happens when an Elm app starts. The Elm runtime takes the full URL entered by the user in a browser’s address bar and gives it to the `Main.init` function as the second argument as shown below.

[source,elm]
----
init : () -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    let
        model =
            { navKey = navKey
            , route = Route.parseUrl url
            , page = NotFoundPage
            }
    in
    initCurrentPage ( model, Cmd.none )
----

`Main.init` then extracts a route from that URL by using the `Route.parseUrl` function and saves it in the main model. Based on that route, it also determines which page to display. The following sequence diagram shows all the steps our app goes through when it starts.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/navigation-flow-when-app-starts.svg[]

==== Navigation Scenario 2: When the User Clicks a Link

The second scenario we need to handle is when the user clicks a link included in our app. This could be a link to an external page, for example an author’s Github profile or a link to an internal page such as the `EditPosts` page which we’ll add in the <<editing-a-post, Creating Edit Post Page>> section later in this chapter.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/internal-external-links.png[]

Whenever a link is clicked, the Elm runtime doesn’t take the user to that URL directly. It delegates that responsibility to our app by sending the message assigned to the `onUrlRequest` field in `main` to the `Main` module’s `update` function. Because of this, we now have the ability to save scroll position or persist data or perform some other operation before actually taking users to where they want to go.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.application
        .
        .
        , onUrlRequest = LinkClicked
        .
        .
        }
----

Although we’ve already assigned `LinkClicked` to `onUrlRequest`, we haven’t defined that message yet. Let’s do that by adding it to the `Msg` type in `Main.elm`.

[source,elm]
----
type Msg
    = ListPageMsg ListPosts.Msg
    | LinkClicked UrlRequest
----

`LinkClicked` takes a payload of type `UrlRequest`, which is defined in the `Browser` module like this:

[source,elm]
----
type UrlRequest
    = Internal Url
    | External String
----

****
NOTE: If you don’t remember how the `Url` type works, you may want to refresh your memory by reviewing the <<navigating-to-list-posts-page, Url Type>> section above.
****

Let’s expose `UrlRequest` from the `Browser` module in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Browser exposing (UrlRequest)
.
.
----

===== Handling `LinkClicked` Message

Next we need to handle the `LinkClicked` message in `update`. Add a new branch to the `update` function in `Main.elm` as shown below.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        ( ListPageMsg subMsg, ListPage pageModel ) ->
            ...

        ( LinkClicked urlRequest, _ ) ->
            case urlRequest of
                Browser.Internal url ->
                    ( model
                    , Nav.pushUrl model.navKey (Url.toString url)
                    )

                Browser.External url ->
                    ( model
                    , Nav.load url
                    )

        ( _, _ ) ->
            ( model, Cmd.none )
----

We need to move the catch-all branch to the bottom, otherwise none of the branches below it will get executed. As mentioned in the <<case-expression, Case expression>> section, it’s important to place the most specific pattern at the top and the least specific at the bottom.

===== Internal Link vs External Link

As long as a link has the same protocol, host name, and port number as the app, it’s considered internal. Otherwise, it’s an external link.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/url-fields.svg[]

If our app is hosted at `+http://example.com:8000+` then all of the following links are considered internal.

* `+/posts+`
* `+/posts/1+`
* `+/posts?tag=functional+`
* `+/posts/1#intro+`
* `+//example.com/posts+`
* `+http://example.com/posts+`

Whereas the links below are considered external.

* `+http://github.com+`
* `+https://example.com+`
* `+https://example.com/posts+`
* `+http://example.com:4000+`

===== Handling an Internal Link

If the user clicks an internal link, we simply change the URL in a browser’s address bar without loading a new page or reloading the current one. The `pushUrl` function from the `Browser.Navigation` module does exactly that. This is what enables us to create <<what-is-a-single-page-app, single-page apps>> in Elm. Here’s the branch for handling internal links in the `Main` module’s `update` function:

[source,elm]
----
Browser.Internal url ->
    ( model
    , Nav.pushUrl model.navKey (Url.toString url)
    )
----

Here’s what `pushUrl`’s type signature looks like:

[source,elm]
----
pushUrl : Key -> String -> Cmd msg
----

A navigation `Key` is needed to create navigation commands that change the URL in a browser’s address bar. We’ve saved the navigation `Key` given to us by the Elm runtime when our app starts in the `navKey` field in main model.

[source,elm]
----
init : () -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    let
        model =
            { navKey = navKey
            .
            .
----

****
NOTE: There are three other functions in the `Browser.Navigation` module that require a navigation key: https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation#replaceUrl[`replaceUrl`], https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation#back[`back`], and https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation#forward[`forward`]. We won’t cover those functions here, but feel free to check out their documentation to understand how they work.
****

`UrlRequest`’s definition shows that the internal link is actually of type `Url` and not `String`.

[source,elm]
----
type UrlRequest
    = Internal Url
    | External String
----

That’s why we need to use the `Url.toString` function to convert `Url` to `String`. `Url.toString` systematically builds a full URL by combining various fields in the <<navigating-to-list-posts-page, `Url` type>>.

If we have to convert `Url` to `String` anyway why not simply use `String` in the first place? Although our app doesn’t do anything other than changing the URL inside `+Browser.Internal url ->+` branch in `update`, more complex apps may want to do additional work depending on what’s in the <<navigating-to-list-posts-page, `Url` fields>>.

[source,elm]
----
Browser.Internal url ->
    ( model
    , Nav.pushUrl model.navKey (Url.toString url)
    )
----

In contrast, when handling an external link all we need to do is load a new page regardless of what’s inside a URL. That’s why the payload for the `External` data constructor in `UrlRequest` is of type `String` and not `Url`.

===== Handling an External Link

If the user clicks an external link, we need to leave our app and load the given URL. The `Nav.load` function does exactly that. Here’s the branch for handling external links in the `Main` module’s `update` function:

[source,elm]
----
Browser.External url ->
    ( model
    , Nav.load url
    )
----

The diagram below illustrates the difference between `Nav.load` and `Nav.pushUrl`.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/pushUrl-vs-load.svg[]

Both `Nav.pushUrl` and `Nav.load` add an entry to the browser history, so the back and forward buttons work as expected. It’s important to note that both `Nav.pushUrl` and `Nav.load` return a command because the process of changing the URL in a browser’s address bar causes a <<side-effects, side effect>>.

Not sure if you noticed, but we didn’t tell `Nav.pushUrl` or `Nav.load` which message to send back to our app once the URL has been changed.

[source,elm]
----
( LinkClicked urlRequest, _ ) ->
    case urlRequest of
        Browser.Internal url ->
            ( model
            , Nav.pushUrl model.navKey (Url.toString url)
            )

        Browser.External url ->
            ( model
            , Nav.load url
            )
----

As it turns out, we don’t have to specify a message name when calling those functions. `Nav.pushUrl` will automatically send whatever message is assigned to the `onUrlChange` field in `main` once the URL has been changed in a browser address bar.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.application
        .
        .
        , onUrlChange = UrlChanged
        }
----

****
NOTE: We’ll handle the `UrlChanged` message below in the <<navigating-to-list-posts-page, Navigation Scenario 3: When the Url is Changed>> section.
****

`Nav.load`, on the other hand, doesn’t send any messages back to our app. It creates a fire and forget command. We’ll see another example of such a command in the <<sending-data-to-javascript, Sending Data to JavaScript>> section in chapter 8.

The following sequence diagram shows all the steps our app goes through when the user clicks an internal link.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/navigation-flow-internal-link.svg[]

And the following diagram illustrates what happens when an external link is clicked.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/navigation-flow-external-link.svg[]

==== Navigation Scenario 3: When the URL is Changed

The final scenario we need to take care of is when the URL in a browser’s address bar is changed. As noted earlier, the command created by `Nav.load` doesn’t send a message back to our app after changing the URL. However, the command created by `Nav.pushUrl` does send the `UrlChanged` message back. Let’s add that message to the `Msg` type in `Main.elm`.

[source,elm]
----
type Msg
    .
    .    
    | LinkClicked UrlRequest
    | UrlChanged Url
----

Next we’ll handle `UrlChanged` in `update`. Add a new branch to the `update` function in `Main.elm` as shown below.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( LinkClicked urlRequest, _ ) ->
            ...

        ( UrlChanged url, _ ) ->
            let
                newRoute =
                    Route.parseUrl url
            in
            ( { model | route = newRoute }, Cmd.none )
                |> initCurrentPage

        ( _, _ ) ->
            ...
----

All we need to do is extract a route from the new URL and determine which page to display. The latter is done inside the `initCurrentPage` function. Whenever the main model is changed, the Elm runtime will automatically call the `view` function in `Main` to get the view code for the new current page.

[source,elm]
----
view : Model -> Html Msg
view model =
    case model.page of
        NotFoundPage ->
            notFoundView

        ListPage pageModel ->
            ListPosts.view pageModel
                |> Html.map ListPageMsg
----

The following sequence diagram shows various steps our app goes through when the URL is changed in a browser’s address bar as a result of user clicking an internal link.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/navigation-flow-url-changed.svg[]

==== HTML Document

The only thing remaining before we can test our app is changing the `view` function in `Main.elm` to return an HTML document instead of an element. The `Browser.application` function expects the `view` function to return a value of type `+Document msg+` as indicated by its type signature below.

[source,elm]
----
Browser.application :
    { init : flags -> Url -> Key -> ( model, Cmd msg )
    , view : model -> Document msg
    , update : msg -> model -> ( model, Cmd msg )
    , subscriptions : model -> Sub msg
    , onUrlRequest : UrlRequest -> msg
    , onUrlChange : Url -> msg
    }
    -> Program flags model msg
----

The `+Document msg+` type is defined in the `Browser` module like this:

[source,elm]
----
type alias Document msg =
    { title : String
    , body : List (Html msg)
    }
----

By returning a document, we’re now able to control the `title` of each page in our app if we want to. For simplicity, we’ll just use the same `title` for all pages. Let’s replace the `view` function in `Main.elm` with the following code.

[source,elm]
----
view : Model -> Document Msg
view model =
    { title = "Post App"
    , body = [ currentView model ]
    }


currentView : Model -> Html Msg
currentView model =
    case model.page of
        NotFoundPage ->
            notFoundView

        ListPage pageModel ->
            ListPosts.view pageModel
                |> Html.map ListPageMsg
----

We also need to expose `Document` from `Browser` in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Browser exposing (Document, UrlRequest)
.
.
----

==== Using elm-live

We’re now ready to test our app. Unfortunately `+elm reactor+` doesn’t know how to work with single-page apps, so if we try to load http://localhost:8000/posts[`+http://localhost:8000/posts+`] we’ll get an error.

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/page-not-found.png[]

What we need is a different development server called https://github.com/wking-io/elm-live[`+elm-live+`]. It knows how to route users to different parts of a single-page app. An added advantage of using `+elm-live+` is that it also reloads pages whenever the underlying code is modified. As a result, we don’t have to refresh a page to see new changes.

Install `+elm-live+` globally using the `+-g+` option by running the following command from `+beginning-elm+` directory in terminal.

[source,bash]
----
$ npm install elm-live -g
----

Stop `+elm reactor+` by pressing `+Ctrl + c+` and run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm-live post-app/Main.elm --pushstate
----

The `+--pushstate+` option is what allows `+elm-live+` to work with single-page apps. Don’t forget to run `+json-server+` from the `+beginning-elm+` directory in a separate terminal window if it’s not running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
----

Now if you load either one of the following URLs, you should be routed to the list posts page.

* http://localhost:8000[`+http://localhost:8000+`]
* http://localhost:8000/posts[`+http://localhost:8000/posts+`]

image:https://elmprogramming.com/images/chapter-7/7.6-navigating-to-list-posts-page/list-posts-page.png[]

==== Summary

In this section, we built a robust navigation infrastructure for our single-page app using the `Browser.Navigation`, `Url`, and `Url.Parser` modules. We can now properly route users to different parts of our app. It’s best practice to use paths instead of full URLs to determine which page the user should be taken to. We covered three navigation scenarios all single-page apps built in Elm must handle:

* When the application starts
* When the user clicks a link
* When the URL is changed

Along the way, we learned how to run single-page apps using `+elm-live+`. In the next section, we’ll build a separate page for editing a post.


[[editing-a-post]]
=== 7.7 Editing a Post


In this section, we’ll build a page for editing a post. We’ll also learn how to update a post by sending a `PATCH` HTTP request to our server.

==== Link to the Edit Post Page

Let’s add a link that says _Edit_ next to each row in the posts table. When that link is clicked, we’ll take users to a different page which contains a form for updating information associated with a post. Add a new cell to the bottom of `viewPost` in `+Page/ListPosts.elm+`.

[source,elm]
----
viewPost : Post -> Html Msg
viewPost post =
    let
        postPath =
            "/posts/" ++ Post.idToString post.id
    in
    tr []
        .
        .
        , td []
            [ a [ href postPath ] [ text "Edit" ] ]
        ]
----

`post.id` is a <<creating-post-module, custom type>>, so we need to convert it to a string by calling the `Post.idToString` function. Start `+json-server+` and `+elm-live+` using the following commands from `+beginning-elm+` directory in separate terminal windows if they aren’t running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019

$ elm-live post-app/Main.elm --pushstate
----

Go to http://localhost:8000/posts[`+http://localhost:8000/posts+`] and you should see the _Edit_ links.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/edit-post-links.png[]

The following sequence diagram shows all the steps our app goes through when an _Edit_ link is clicked from the `ListPosts` page. We haven’t implemented all of those steps yet. We’ll use the following diagram as a guide for implementing the rest of the code needed for the `EditPost` page to fully work.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/edit-link-navigation-flow.svg[]

==== Step 8: Extracting `Post` Route from URL

Steps 1 through 7 shown in the diagram above are already in place. Let’s implement step 8 by adding a new data constructor called `Post` to the `Route` type in `Route.elm`.

[source,elm]
----
type Route
    = NotFound
    | Posts
    | Post PostId
----

We need to import the `Post` module in `Route.elm`.

[source,elm]
----
module Route exposing (Route(..), parseUrl)

import Post exposing (PostId)
.
.
----

An edit link contains a post’s ID in string format.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/post-id-in-edit-link.svg[]

We’ll be converting a post’s ID from string to the <<creating-post-module, `PostId` type>> and assign it as a payload to the `Post` data constructor. To do that we need to add a new <<navigating-to-list-posts-page, parser>> to `matchRoute` in `Route.elm`.

[source,elm]
----
matchRoute : Parser (Route -> a) a
matchRoute =
    oneOf
        [ map Posts top
        , map Posts (s "posts")
        , map Post (s "posts" </> Post.idParser)
        ]
----

The table below shows which parser in `matchRoute` is responsible for matching which path in a given URL.

[cols=",,,",options="header,autowidth",frame=ends,grid=rows]
|===
|*URL* |*Path* |*Parser* |*Route*
|`+http://localhost:8000+` | |`top` |`Posts`
|`+http://localhost:8000/posts+` |`+/posts+` |`+s "posts"+` |`Posts`
|`+http://localhost:8000/posts/1+` |`+/posts/1+` |`+s "posts" </> Post.idParser+` |`+Post PostId+`
|===

The parser for matching an individual post route uses `+</>+` to combine two different parsers.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/parser-for-individual-post-path.svg[]

Next we need to define `idParser`. Add the following code to the bottom of `Post.elm`.

[source,elm]
----
idParser : Parser (PostId -> a) a
idParser =
    custom "POSTID" <|
        \postId ->
            Maybe.map PostId (String.toInt postId)
----

We also need to expose `idParser` and import `Url.Parser` in `Post.elm`.

[source,elm]
----
module Post exposing
    ( Post
    , PostId
    , idParser
    , idToString
    , postDecoder
    , postsDecoder
    )

import Url.Parser exposing (Parser, custom)
.
.
----

===== Primitive Parsers

The https://package.elm-lang.org/packages/elm/url/latest/Url-Parser[`Url.Parser`] module defines three primitive parsers as shown below.

[source,elm]
----
int : Parser (Int -> a) a

string : Parser (String -> a) a

s : String -> Parser a a
----

To understand how these parsers work, let’s imagine a type called `FakeRoute`.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/fake-route-type.svg[]

Primitive Type as an ID::
  As noted in the <<creating-post-module, Using Custom Types for ID>> section, it’s not a good practice to use primitive types such as `Int` or `String` for an identifier. We ignored that best practice when we defined `FakeRoute` because we want to see what the code for parsing those primitive values looks like. In a production app, a properly defined `FakeRoute` would look something like this:
+
image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/fake-route-type-sanitized.svg[]

Here are all the parsers for matching routes listed in `FakeRoute`:

[source,elm]
----
matchFakeRoute : Parser (Route -> a) a
matchFakeRoute =
    oneOf
        [ map Home top
        , map Posts (s "posts")
        , map Post (s "posts" </> int)
        , map User (s "user" </> string)
        , map Comment (s "user" </> string </> s "comment" </> int)
        ]
----

The table below shows which path gets parsed to which route based on the logic in `matchFakeRoute`.

[cols=",,",options="header,autowidth",frame=ends,grid=rows]
|===
|*Path* |*Parser* |*Route*
| |`top` |`Home`
|`+/posts+` |`+s "posts"+` |`Posts`
|`+/posts/1+` |`+s "posts" </> int+` |`+Post 1+`
|`+/user/pam+` |`+s "user" </> string+` |`+User "pam"+`
|`+/user/pam/comment/12+` |`+s "user" </> string </> s "comment" </> int+` |`+Comment "pam" 12+`
|===

To understand how `s`, `int`, and `string` work together, let’s unpack the line for parsing an individual post’s path in `matchFakeRoute`.

[source,elm]
----
map Post (s "posts" </> int)
----

Both `string` and `int` parsers pluck values out of a path, whereas `s` simply matches the given string. So when we use `+s "posts" </> int+` to parse `+/posts/1+`, the `s` parser first verifies that the path indeed starts with `posts`. After that the `int` parser comes in and extracts `1` from the path.

Now that the path has been parsed successfully, we need to map the result to the `Post` data constructor from `FakeRoute`. It’s important to note that `s` expects the path segment to match exactly. Therefore if the given path is `+/postss/1+`, it’ll fail.

The `+s "user" </> string+` parser works in a similar way. Let’s say the path we’re parsing is `+/user/pam+`. `s` first verifies that the path starts with `user` and then the `string` parser extracts `pam`.

The `+s "user" </> string </> s "comment" </> int+` parser is slightly more complex. Let’s find out how it parses the `+/user/pam/comment/12+` path. `s` first verifies that the path starts with `user`. After that the `string` parser extracts `pam` and then the `s` parser once again verifies that `pam` is followed by `comment`. Finally, the `int` parser extracts `12` and the result is mapped to the `Comment` data constructor.

===== Custom Parsers

As we saw above, primitive parsers are only capable of converting a path segment to either `String` or `Int`. If we need to convert a segment to any other type, we must create our own parser using the `custom` function from `Url.Parser`. Here’s the `idParser` function from `Post.elm` once again.

[source,elm]
----
idParser : Parser (PostId -> a) a
idParser =
    custom "POSTID" <|
        \postId ->
            Maybe.map PostId (String.toInt postId)
----

The following diagram explains the `custom` function’s type signature.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/custom-parser-type-signature.svg[]

As it turns out behind the scenes the `string` and `int` parsers are also defined in terms of `custom`.

[source,elm]
----
string : Parser (String -> a) a
string =
    custom "STRING" Just
----

[source,elm]
----
int : Parser (Int -> a) a
int =
    custom "NUMBER" String.toInt
----

==== Step 10: Identify EditPost as the Next Page

Step 9 from the <<editing-a-post, sequence diagram>> above tells us to store `Post` in the `route` field in main model. We’ve already done that in the `Main.update` function.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( UrlChanged url, _ ) ->
            let
                newRoute =
                    Route.parseUrl url
            in
            ( { model | route = newRoute }, Cmd.none )
                |> initCurrentPage
        .
        .
----

And step 10 tells us to identify `EditPost` as the next page. We haven’t done that yet. Let’s add a new branch to `initCurrentPage` in `Main.elm` for the `Post` route.

[source,elm]
----
initCurrentPage : ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
initCurrentPage ( model, existingCmds ) =
    let
        ( currentPage, mappedPageCmds ) =
            case model.route of
                .
                .
                Route.Posts ->
                    ...

                Route.Post postId ->
                    let
                        ( pageModel, pageCmd ) =
                            EditPost.init postId model.navKey
                    in
                    ( EditPage pageModel, Cmd.map EditPageMsg pageCmd )
    in
    ...
----

Now add `EditPage` to the `Page` type in `Main.elm`.

[source,elm]
----
type Page
    = NotFoundPage
    | ListPage ListPosts.Model
    | EditPage EditPost.Model
----

==== Creating the EditPost Page

To fully implement step 10 we also need to create the `EditPost` page module. Create a new file called `EditPost.elm` inside the `Page` directory and add the following code to it.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/create-edit-post-page-file.png[]

[source,elm]
----
module Page.EditPost exposing (Model)


type alias Model =
    {}
----

As noted in the <<restructuring-code, Restructuring Code>> section earlier in this chapter, the central type for each page module is `Model`. Right now `EditPost`’s model is an empty record. We’ll expand it as we keep building the page.

The branch for the `Post` route in `Main.update` shows that the function for initializing the `EditPost` page takes a post ID and a <<navigating-to-list-posts-page, navigation key>> as inputs.

[source,elm]
----
( pageModel, pageCmd ) =
    EditPost.init postId model.navKey
----

Let’s implement that function by adding the following code to the bottom of `EditPost.elm`.

[source,elm]
----
init : PostId -> Nav.Key -> ( Model, Cmd Msg )
init postId navKey =
    ( initialModel navKey, fetchPost postId )


initialModel : Nav.Key -> Model
initialModel navKey =
    { navKey = navKey
    }
----

We need access to `navKey` in `EditPost` to navigate users to the `ListPosts` page after the post data is saved. Let’s add that field to the model in `EditPost.elm`.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    }
----

`Key` is defined in the `Browser.Navigation` module and `PostId` is defined in the `Post` module. Let’s import those in `EditPost.elm`.

[source,elm]
----
module Page.EditPost exposing (Model)

import Browser.Navigation as Nav
import Post exposing (Post, PostId, postDecoder)
.
.
----

===== Fetching Post

When the `EditPost` page is being initialized, we need to fetch a fresh copy of the post we want to edit from the server. The `Main` module could have grabbed the post record in question from the `ListPosts` page and sent that directly to `EditPost` instead of just the ID. That would have saved us a round trip to the server. But what if some other client app has already modified the post we want to edit? By fetching it from the server, we’re always working on the latest version of that record. Add the following code to the bottom of `EditPost.elm`.

[source,elm]
----
fetchPost : PostId -> Cmd Msg
fetchPost postId =
    Http.get
        { url = "http://localhost:5019/posts/" ++ Post.idToString postId
        , expect =
            postDecoder
                |> Http.expectJson (RemoteData.fromResult >> PostReceived)
        }
----

`fetchPost` works similarly to the `fetchPosts` function we implemented in `ListPosts.elm`.

[source,elm]
----
fetchPosts : Cmd Msg
fetchPosts =
    Http.get
        { url = "http://localhost:5019/posts/"
        , expect =
            postsDecoder
                |> Http.expectJson (RemoteData.fromResult >> PostsReceived)
        }
----

The former retrieves just one post whereas the latter retrieves multiple posts. If you don’t remember how the `RemoteData.fromResult` function works, you may want to review the <<remote-data, RemoteData>> section from chapter 6. Import the `Http` module in `EditPost.elm`.

[source,elm]
----
module Page.EditPost exposing (Model)

import Http
.
.
----

===== PostReceived Message

Let’s define `PostReceived` by adding the following code to the bottom of `EditPost.elm`.

[source,elm]
----
type Msg
    = PostReceived (WebData Post)
----

Now import `RemoteData` in `EditPost.elm`.

[source,elm]
----
module Page.EditPost exposing (Model)

import RemoteData exposing (WebData)
.
.
----

Next we need to handle the `PostReceived` message inside `update`. Add the following code to the bottom of `EditPost.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        PostReceived post ->
            ( { model | post = post }, Cmd.none )
----

****
NOTE: As mentioned in the <<restructuring-code, Restructuring Code>> section, each page module is provided with the `init`, `update` and `view` functions of its own so that it can independently follow the <<elm-architecture-intro, Elm Architecture>>.
****

All we’re doing inside the `+PostReceived post ->+` branch is assign the data retrieved from a server to the `post` field. Let’s add that field to `Model` in `EditPost.elm`.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    , post : WebData Post
    }
----

We also need to initialize the `post` field to `RemoteData.Loading` in `initialModel`.

[source,elm]
----
initialModel : Nav.Key -> Model
initialModel navKey =
    { navKey = navKey
    , post = RemoteData.Loading
    }
----

==== Showing Edit Post Form

We’re now ready to create a form through which the user will edit post data. Add the following code to the bottom of `EditPost.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ h3 [] [ text "Edit Post" ]
        , viewPost model.post
        ]


viewPost : WebData Post -> Html Msg
viewPost post =
    case post of
        RemoteData.NotAsked ->
            text ""

        RemoteData.Loading ->
            h3 [] [ text "Loading Post..." ]

        RemoteData.Success postData ->
            editForm postData

        RemoteData.Failure httpError ->
            viewFetchError (buildErrorMessage httpError)


editForm : Post -> Html Msg
editForm post =
    Html.form []
        [ div []
            [ text "Title"
            , br [] []
            , input
                [ type_ "text"
                , value post.title
                , onInput UpdateTitle
                ]
                []
            ]
        , br [] []
        , div []
            [ text "Author Name"
            , br [] []
            , input
                [ type_ "text"
                , value post.authorName
                , onInput UpdateAuthorName
                ]
                []
            ]
        , br [] []
        , div []
            [ text "Author URL"
            , br [] []
            , input
                [ type_ "text"
                , value post.authorUrl
                , onInput UpdateAuthorUrl
                ]
                []
            ]
        , br [] []
        , div []
            [ button [ type_ "button", onClick SavePost ]
                [ text "Submit" ]
            ]
        ]


viewFetchError : String -> Html Msg
viewFetchError errorMessage =
    let
        errorHeading =
            "Couldn't fetch post at this time."
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message
----

The above code listing doesn’t include anything we haven’t covered already, so you should be able to figure out how it works. We need to import the following modules in `EditPost.elm` for the view code to work properly.

[source,elm]
----
module Page.EditPost exposing (Model)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput)
.
.
----

===== onInput Messages

The `input` elements in `editForm` send separate messages to the Elm runtime whenever their content is modified. Let’s add those messages to the `Msg` type in `EditPost.elm`.

[source,elm]
----
type Msg
    = PostReceived (WebData Post)
    | UpdateTitle String
    | UpdateAuthorName String
    | UpdateAuthorUrl String
----

Now add three separate branches to the `update` function in `EditPost.elm` for handling those messages.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        PostReceived post ->
            ...

        UpdateTitle newTitle ->
            let
                updateTitle =
                    RemoteData.map
                        (\postData ->
                            { postData | title = newTitle }
                        )
                        model.post
            in
            ( { model | post = updateTitle }, Cmd.none )

        UpdateAuthorName newName ->
            let
                updateAuthorName =
                    RemoteData.map
                        (\postData ->
                            { postData | authorName = newName }
                        )
                        model.post
            in
            ( { model | post = updateAuthorName }, Cmd.none )

        UpdateAuthorUrl newUrl ->
            let
                updateAuthorUrl =
                    RemoteData.map
                        (\postData ->
                            { postData | authorUrl = newUrl }
                        )
                        model.post
            in
            ( { model | post = updateAuthorUrl }, Cmd.none )
----

Since `post` is of type `+WebData Post+` we can’t simply use the syntax for modifying a record to update the `title`, `authorName`, and `authorUrl` fields like this:

[source,elm]
----
UpdateTitle newTitle ->
    let
        oldPost =
            model.post

        updateTitle =
            { oldPost | title = newTitle }
    in
    ( { model | post = updateTitle }, Cmd.none )
----

That’s why all three branches above have to use the `RemoteData.map` function. The following diagram illustrates how it works.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/remote-data-map-code.svg[]

Here’s another way of looking at how `RemoteData.map` transforms a value:

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/remote-data-map-work-flow.svg[]

And here’s how `RemoteData.map` is implemented behind the scenes:

[source,elm]
----
map : (a -> b) -> RemoteData e a -> RemoteData e b
map f data =
    case data of
        Success value ->
            Success (f value)

        Loading ->
            Loading

        NotAsked ->
            NotAsked

        Failure error ->
            Failure error
----

The `e` and `a` <<type-system, type variables>> represent the `Failure` and `Success` values respectively as shown in `RemoteData`’s definition below.

[source,elm]
----
type RemoteData e a
    = NotAsked
    | Loading
    | Failure e
    | Success a
----

==== Saving a Post

To save the modified post data, the user has to click the `Submit` button. When that happens, the `SavePost` message is sent to the Elm runtime.

[source,elm]
----
editForm : Post -> Html Msg
editForm post =
        .
        .
        , div []
            [ button [ type_ "button", onClick SavePost ]
                [ text "Submit" ]
            ]
        ]
----

Let’s add that message to the `Msg` type in `EditPost.elm`.

[source,elm]
----
type Msg
    .
    .
    | UpdateAuthorUrl String
    | SavePost
----

Now add a new branch to `update` in `EditPost.elm` for handling the `SavePost` message.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        UpdateAuthorUrl newUrl ->
            ...

        SavePost ->
            ( model, savePost model.post )
----

The `+SavePost ->+` branch asks the `savePost` function to create an HTTP request. Let’s implement that right below `update` in `EditPost.elm`.

[source,elm]
----
savePost : WebData Post -> Cmd Msg
savePost post =
    case post of
        RemoteData.Success postData ->
            let
                postUrl =
                    "http://localhost:5019/posts/"
                        ++ Post.idToString postData.id
            in
            Http.request
                { method = "PATCH"
                , headers = []
                , url = postUrl
                , body = Http.jsonBody (postEncoder postData)
                , expect = Http.expectJson PostSaved postDecoder
                , timeout = Nothing
                , tracker = Nothing
                }

        _ ->
            Cmd.none
----

If the value stored in `post` is `Success`, `savePost` returns a command for updating the post data.

[[httprequest]]
===== Http.request

Unfortunately, the `Http` module doesn’t provide a separate function for creating an update request. Therefore, we’re forced to construct our request using a low-level function called `Http.request`. The `Http.get` function we saw in <<fetching-data-using-get, chapter 6>> also uses `Http.request` behind the scenes.

[source,elm]
----
get : { url : String, expect : Expect msg } -> Cmd msg
get r =
    request
        { method = "GET"
        , headers = []
        , url = r.url
        , body = emptyBody
        , expect = r.expect
        , timeout = Nothing
        , tracker = Nothing
        }
----

`Http.request` takes a record with seven fields. Let’s go through those fields one by one.

*method* - To update a resource on the server, we need to use the `PATCH` method.

*headers* - The `headers` field allows us to send additional information to the server. Since we don’t want to send any headers, we’re giving it an empty list in `savePost`.

*url* - The location of the resource we want to modify.

*body* - This field contains the modified post data. But first we must translate that data from Elm values to JSON by using the module called `Json.Encode`. Let’s import it in `Post.elm`.

[source,elm]
----
module Post exposing
  ...

import Json.Encode as Encode
.
.
----

We can now create an encoder for `Post` by adding the following code to the bottom of `Post.elm`.

[source,elm]
----
postEncoder : Post -> Encode.Value
postEncoder post =
    Encode.object
        [ ( "id", encodeId post.id )
        , ( "title", Encode.string post.title )
        , ( "authorName", Encode.string post.authorName )
        , ( "authorUrl", Encode.string post.authorUrl )
        ]


encodeId : PostId -> Encode.Value
encodeId (PostId id) =
    Encode.int id
----

We need to expose `postEncoder` in `Post.elm` and `EditPost.elm`.

[source,elm]
----
module Post exposing
    .
    .
    , postEncoder
    )
----

[source,elm]
----
module Page.EditPost exposing (Model)

import Post exposing (Post, PostId, postDecoder, postEncoder)
.
.
----

The process of encoding Elm values to JSON is the exact opposite of <<decoding-json-part-1, decoding JSON to Elm values>>. We can’t assign the encoded value directly to the `body` field though. We need to explicitly tell `Http.request` that our encoded value is in JSON format by using the `Http.jsonBody` function.

[source,elm]
----
body = Http.jsonBody (postEncoder postData)
----

This will add the `+Content-Type: application/json+` header to our HTTP request behind the scenes. That is how the server knows the body of a request is in JSON format.

*expect* - By using the `Http.expectJson` function we’re letting Elm know that we expect the response body to be JSON as well. We’re using the same decoder we created in the <<decoding-json-part-2, Decoding Nested Objects>> section to decode the response.

[source,elm]
----
expect = Http.expectJson PostSaved postDecoder
----

*timeout* - Sometimes a server takes forever to return a response. If we don’t want our users to wait too long, we can specify a timeout like this:

[source,elm]
----
timeout = Just (Time.second 30)
----

`timeout` expects a `Maybe`. That’s why we need to wrap the value in `Just`. Since we don’t want to specify a timeout, we’re simply passing `Nothing`.

[source,elm]
----
timeout = Nothing
----

*tracker* - This field allows us to track the progress of a request. Since we aren’t interested in our request’s progress, we assigned `Nothing` to the `tracker` field.

[source,elm]
----
tracker = Nothing
----

===== PostSaved Message

We’ve covered everything in `savePost` except the `PostSaved` message. When the `PATCH` request is complete, the Elm runtime will send the `PostSaved` message to `update`. Let’s add it to the `Msg` type in `EditPost.elm`.

[source,elm]
----
type Msg
    .
    .
    | SavePost
    | PostSaved (Result Http.Error Post)
----

`PostSaved`’s payload doesn’t need to be of type `WebData` because unlike <<editing-a-post, `fetchPost`>> we aren’t interested in <<remote-data, tracking all the states>> our `PATCH` request goes through. All we need to know is whether the request is successful or not. The <<type-system, `Result`>> type is perfect for that. Let’s handle `PostSaved` by adding two new branches to `update` in `EditPost.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        SavePost ->
            ...

        PostSaved (Ok postData) ->
            let
                post =
                    RemoteData.succeed postData
            in
            ( { model | post = post }, Cmd.none )

        PostSaved (Err error) ->
            ( model, Cmd.none )
----

If the request is successful, `postData` will contain the updated `Post` record. Before we can assign that record to the `post` field in our model, we have to convert it to the `WebData` type. `RemoteData.succeed` is just what we need. It lifts an ordinary value into the realm of `RemoteData`.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/remote-data-succeed.svg[]

Here’s how the type signature of `RemoteData.succeed` looks:

[source,elm]
----
succeed : a -> RemoteData e a
----

===== Handling Post Save Error

The `+PostSaved (Err error) ->+` branch above simply returns an unmodified model which is not a good practice. We should always handle errors properly. Here’s what we’re going to do: we’ll save the error in our model and display it below the edit form. Let’s add a new field called `saveError` to the model in `EditPost.elm`.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    , post : WebData Post
    , saveError : Maybe String
    }
----

`saveError` is of type `Maybe` because there won’t be any error to display if the `PATCH` request is successful. Let’s initialize it to `Nothing` in `initialModel`.

[source,elm]
----
initialModel : Nav.Key -> Model
initialModel navKey =
    { navKey = navKey
    , post = RemoteData.Loading
    , saveError = Nothing
    }
----

Next we need to assign a proper value to the `saveError` field in two branches that handle the `PostSaved` message in `update`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        PostSaved (Ok postData) ->
            let
                post =
                    RemoteData.succeed postData
            in
            ( { model | post = post, saveError = Nothing }
            , Cmd.none
            )

        PostSaved (Err error) ->
            ( { model | saveError = Just (buildErrorMessage error) }
            , Cmd.none
            )
----

The only thing remaining is to display the error message. Add the following code below the `viewFetchError` function in `EditPost.elm`.

[source,elm]
----
viewSaveError : Maybe String -> Html msg
viewSaveError maybeError =
    case maybeError of
        Just error ->
            div []
                [ h3 [] [ text "Couldn't save post at this time." ]
                , text ("Error: " ++ error)
                ]

        Nothing ->
            text ""
----

And call `viewSaveError` from `view` in `EditPost.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ h3 [] [ text "Edit Post" ]
        , viewPost model.post
        , viewSaveError model.saveError
        ]
----

==== Taking Users Back to the ListPosts Page

It’d be great if we could take the users back to the `ListPosts` page after they’ve successfully updated a post. To do that we need to return a command from the `+PostSaved (Ok postData) ->+` branch in `update` using `Route.pushUrl` as shown below.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        PostSaved (Ok postData) ->
            let
                post =
                    RemoteData.succeed postData
            in
            ( { model | post = post, saveError = Nothing }
            , Route.pushUrl Route.Posts model.navKey
            )

        PostSaved (Err error) ->
            ...
----

We haven’t defined the `pushUrl` function yet. Let’s do that by adding the following code to the bottom of `Route.elm`.

[source,elm]
----
pushUrl : Route -> Nav.Key -> Cmd msg
pushUrl route navKey =
    routeToString route
        |> Nav.pushUrl navKey


routeToString : Route -> String
routeToString route =
    case route of
        NotFound ->
            "/not-found"

        Posts ->
            "/posts"

        Post postId ->
            "/posts/" ++ Post.idToString postId
----

All `Route.pushUrl` does is convert a route to a string path and call <<navigating-to-list-posts-page, `Nav.pushUrl`>> like we did in the `Main.update` function.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        ( LinkClicked urlRequest, _ ) ->
            case urlRequest of
                Browser.Internal url ->
                    ( model
                    , Nav.pushUrl model.navKey (Url.toString url)
                    )

                Browser.External url ->
                    ...
----

We need to expose `pushUrl` and also import the `Browser.Navigation` module in `Route.elm`.

[source,elm]
----
module Route exposing (Route(..), parseUrl, pushUrl)

import Browser.Navigation as Nav
.
.
----

We also need to import `Route` in `EditPost.elm`.

[source,elm]
----
module Page.EditPost exposing (Model)

import Route
.
.
----

==== Moving buildErrorMessage

Let’s do some housekeeping by moving the `buildErrorMessage` function to a new module. Both `EditPost.elm` and `ListPosts.elm` implement that function in exactly the same way. We’ll be using `buildErrorMessage` in other modules too in the future. Create a new file called `Error.elm` inside the `+post-app+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/create-error-file.png[]

[source,elm]
----
module Error exposing (buildErrorMessage)

import Http


buildErrorMessage : Http.Error -> String
buildErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "Unable to reach server."

        Http.BadStatus statusCode ->
            "Request failed with status code: " ++ String.fromInt statusCode

        Http.BadBody message ->
            message
----

Now remove `buildErrorMessage`’s definition from `EditPost.elm` and `ListPosts.elm`. After that import the `Error` module in both of those files.

[source,elm]
----
module Page.EditPost exposing (Model)

import Error exposing (buildErrorMessage)
.
.
----

[source,elm]
----
module Page.ListPosts exposing (Model, Msg, init, update, view)

import Error exposing (buildErrorMessage)
.
.
----

`EditPost.elm` only exposes `Model` right now, but we need to expose `Msg`, `init`, `update`, and `view` as well. Let’s do that.

[source,elm]
----
module Page.EditPost exposing (Model, Msg, init, update, view)
----

==== Adding EditPageMsg to Main

Now that we’re done implementing the `EditPost` page, we need to import it in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Page.EditPost as EditPost
.
.
----

Next we need to add `EditPageMsg` to the `Msg` type in `Main.elm`.

[source,elm]
----
type Msg
    .
    .
    | UrlChanged Url
    | EditPageMsg EditPost.Msg
----

And handle that message by adding a new branch to `update` in `Main.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( UrlChanged url, _ ) ->
            ...

        ( EditPageMsg subMsg, EditPage pageModel ) ->
            let
                ( updatedPageModel, updatedCmd ) =
                    EditPost.update subMsg pageModel
            in
            ( { model | page = EditPage updatedPageModel }
            , Cmd.map EditPageMsg updatedCmd
            )

        ( _, _ ) ->
            ...
----

The branch for handling `EditPageMsg` looks very similar to the one that handles `ListPageMsg` which is already covered in the <<navigating-to-list-posts-page, Updating Page Models>> section. This marks the completion of step 10 from the <<editing-a-post, sequence diagram>> above. Step 11 and 12 are also in place already.

==== Step 13 - 17: Return EditPost View

We can take care of the rest of the steps by adding a new branch for `EditPage` to the `currentView` function in `Main.elm`.

[source,elm]
----
currentView : Model -> Html Msg
currentView model =
    case model.page of
        .
        .
        ListPage pageModel ->
            ...

        EditPage pageModel ->
            EditPost.view pageModel
                |> Html.map EditPageMsg
----

If you don’t remember how `Html.map` works, you may want to review the <<navigating-to-list-posts-page, Displaying Current Page>> section.

==== Testing the EditPost Page

Phew. That was a lot of code we had to write to make the `EditPost` page work. We’re now ready to test it. Run `+json-server+` and `+elm-live+` from the `+beginning-elm+` directory in separate terminal windows if they aren’t running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019

$ elm-live post-app/Main.elm --pushstate
----

Check the `+elm-live+` window in terminal to make sure everything compiled successfully. Now go to http://localhost:8000[`+http://localhost:8000+`] and you should see a list of posts.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/edit-post-links.png[]

Click the `Edit` link next to `typicode` and you’ll be taken to the `EditPost` page. The URL in browser’s address bar will also change to http://localhost:8000/posts/1[`+http://localhost:8000/posts/1+`].

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/edit-post-page.png[]

Now update the title to `+json-server (modified)+` and click `Submit`.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/edit-post-page-modified.png[]

You should be taken back to the `ListPosts` page and there you should see the modified title.

image:https://elmprogramming.com/images/chapter-7/7.7-editing-a-post/list-posts-page-modified-title.png[]

==== Summary

In this section, we built a separate page for editing a post. We learned how to modify a resource on a server using the `PATCH` HTTP request. Along the way, we figured out how to properly navigate users to the `EditPost` page. We saw what an HTTP request is really made up of by understanding each field in the record given to `Http.request`. Finally, we learned how to encode Elm values into JSON using the `Json.Encode` module. In the next section, we’ll delete a post by sending a `DELETE` HTTP request to our server.


[[deleting-a-post]]
=== 7.8 Deleting a Post


In this section, we’ll learn how to delete a post by sending a `DELETE` HTTP request to our local `+json-server+`. Luckily, deleting a post takes much less effort than updating it.

==== Adding Delete Buttons

The first thing we need to do is add a delete button next to each row in `ListPosts.elm`.

[source,elm]
----
viewPost : Post -> Html Msg
viewPost post =
        .
        .
        , td []
            [ a [ href postPath ] [ text "Edit" ] ]
        , td []
            [ button [ type_ "button", onClick (DeletePost post.id) ]
                [ text "Delete" ]
            ]
        ]
----

When the _Delete_ button is clicked, it sends the `DeletePost` message to the Elm Runtime. Let’s add that message to the `Msg` type in `ListPosts.elm`.

[source,elm]
----
type Msg
    .
    .
    | PostsReceived (WebData (List Post))
    | DeletePost PostId
----

Add a new branch to the `update` function in `ListPosts.elm` to handle the `DeletePost` message.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        PostsReceived response ->
            ...

        DeletePost postId ->
            ( model, deletePost postId )
----

==== Creating Delete HTTP Request

The `+DeletePost postId ->+` branch delegates all work to the `deletePost` function. Let’s add that below `update` in `ListPosts.elm`.

[source,elm]
----
deletePost : PostId -> Cmd Msg
deletePost postId =
    Http.request
        { method = "DELETE"
        , headers = []
        , url = "http://localhost:5019/posts/" ++ Post.idToString postId
        , body = Http.emptyBody
        , expect = Http.expectString PostDeleted
        , timeout = Nothing
        , tracker = Nothing
        }
----

Once again, we’re using the low-level function `Http.request` to create a delete request. To delete a resource on the server, we’re required to use the `DELETE` method. The `url` for deleting and updating a resource is exactly the same. The only information a server needs to delete a resource is its URL. That’s why we’ve assigned `Http.emptyBody` to the `body` field.

`+json-server+` responds with `+{}+` — an empty JSON object — when asked to delete a resource. Since there’s nothing to decode inside an empty JSON object, we passed `Http.expectString` instead of `Http.expectJson` to the `expect` field. Next we need to add `PostDeleted` to the `Msg` type in `ListPosts.elm`.

[source,elm]
----
type Msg
    .
    .
    | DeletePost PostId
    | PostDeleted (Result Http.Error String)
----

Just like the <<editing-a-post, `PostSaved`>> message from `EditPost.elm`, the payload for `PostDeleted` doesn’t need to be of type `WebData`. We also aren’t interested in <<remote-data, tracking all the states>> our `DELETE` request goes through. All we need to know is whether the request is successful or not. The <<type-system, `Result`>> type is perfect for that. Let’s handle `PostDeleted` by adding two new branches to `update` in `ListPosts.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        DeletePost postId ->
            ...

        PostDeleted (Ok _) ->
            ( model, fetchPosts )

        PostDeleted (Err error) ->
            ( { model | deleteError = Just (buildErrorMessage error) }
            , Cmd.none
            )
----

After a post is deleted, we want to refresh the list by re-fetching remaining posts. That’s why we’re returning a command to fetch posts from the `+PostDeleted (Ok response) ->+` branch. However, if we encounter an error while deleting a post we need to save the error message in `deleteError`. Let’s add that field to our model in `ListPosts.elm`.

[source,elm]
----
type alias Model =
    { posts : WebData (List Post)
    , deleteError : Maybe String
    }
----

We also need to initialize it to `Nothing` in `init`. While we’re at it, let’s extract the code for initializing the model out to a separate function.

[source,elm]
----
init : ( Model, Cmd Msg )
init =
    ( initialModel, fetchPosts )


initialModel : Model
initialModel =
    { posts = RemoteData.Loading
    , deleteError = Nothing
    }
----

==== Displaying Delete Error

The only thing remaining is to display a delete error. Add the following code to the bottom of `ListPosts.elm`.

[source,elm]
----
viewDeleteError : Maybe String -> Html msg
viewDeleteError maybeError =
    case maybeError of
        Just error ->
            div []
                [ h3 [] [ text "Couldn't delete post at this time." ]
                , text ("Error: " ++ error)
                ]

        Nothing ->
            text ""
----

And call `viewDeleteError` from the `view` function in `ListPosts.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
        .
        .
        , viewPosts model.posts
        , viewDeleteError model.deleteError
        ]
----

==== Testing

We’re now ready to test the delete functionality. Run `+json-server+` and `+elm-live+` from the `+beginning-elm+` directory in separate terminal windows if they aren’t running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019

$ elm-live post-app/Main.elm --pushstate
----

Check the `+elm-live+` window in terminal to make sure everything compiled successfully. Now go to http://localhost:8000[`+http://localhost:8000+`] and you should see a delete button on each row.

image:https://elmprogramming.com/images/chapter-7/7.8-deleting-a-post/posts-before-deletion.png[]

Click the delete button in first row and that post should disappear from the page.

image:https://elmprogramming.com/images/chapter-7/7.8-deleting-a-post/posts-after-deletion.png[]

Its JSON representation should also disappear from the `+server/db.json+` file.

[source,json]
----
{
  "posts": [
    {
      "id": 2,
      "title": "http-server",
      "authorName": "indexzero",
      "authorUrl": "https://github.com/indexzero"
    }
  ],
  "comments": [],
  "profile": {
    "name": "typicode"
  }
}
----

Additionally, `+json-server+` deleted the following comment that was associated with the first post. Notice how the comment below uses `postId` field to tie itself to the post we just deleted.

[source,json]
----
{
  "id": 1,
  "body": "some comment",
  "postId": 1
}
----

This is a common behavior on the server-side. When a resource is deleted, it’s likely that other dependent resources also get deleted.

==== Summary

In this section, we learned how to delete a post using the `DELETE` HTTP method. Compared to other operations we have covered so far — fetching and updating — deleting a post is relatively easy. We don’t need to encode or decode any JSON value. All we need to do is specify the location of the resource. In the next section, we’ll build a separate page for creating a new post.


[[creating-a-new-post]]
=== 7.9 Creating a New Post


The only operation left to cover is creating a new post. In this section, we’ll build a new page designed specifically for that purpose.

==== Adding Create New Post Link

Here’s the plan: we’ll add a link that says _Create new post_ below the _Refresh posts_ button on the `ListPosts` page. When that link is clicked, we’ll take the user to a new page which will contain a form for creating a new post. Modify the `view` function in `ListPosts.elm` as shown below.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick FetchPosts ]
            [ text "Refresh posts" ]
        , br [] []
        , br [] []
        , a [ href "/posts/new" ]
            [ text "Create new post" ]
        , viewPosts model.posts
        , viewDeleteError model.deleteError
        ]
----

Run `+json-server+` and `+elm-live+` from the `+beginning-elm+` directory in separate terminal windows if they aren’t running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019

$ elm-live post-app/Main.elm --pushstate
----

Now go to http://localhost:8000[`+http://localhost:8000+`] and you should see the link for creating a new post.

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/create-new-post-link.png[]

The following sequence diagram shows all the steps our app goes through when the _Create new post_ link is clicked. It looks very similar to the <<editing-a-post, sequence diagram>> for an _edit post link_. We’ll use the following diagram as a guide for implementing the `NewPost` page.

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/create-new-post-navigation-flow.svg[]

==== Step 8: Extracting `NewPost` Route from URL

Steps 1 through 7 shown in the diagram above are already in place. Let’s implement step 8 by adding a new data constructor called `NewPost` to the `Route` type in `Route.elm`.

[source,elm]
----
type Route
    .
    .
    | Post PostId
    | NewPost
----

`NewPost` page’s path is quite simple as shown in the figure below.

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/new-post-page-path.svg[]

Let’s add a <<navigating-to-list-posts-page, parser>> to `matchRoute` in `Route.elm` for matching the new post path.

[source,elm]
----
matchRoute : Parser (Route -> a) a
matchRoute =
    oneOf
        .
        .
        , map Post (s "posts" </> Post.idParser)
        , map NewPost (s "posts" </> s "new")
        ]
----

The table below shows which parser in `matchRoute` is responsible for matching which path in a given URL.

[cols=",,,",options="header,autowidth",frame=ends,grid=rows]
|===
|*URL* |*Path* |*Parser* |*Route*
|`+http://localhost:8000+` | |`top` |`Posts`
|`+http://localhost:8000/posts+` |`+/posts+` |`+s "posts"+` |`Posts`
|`+http://localhost:8000/posts/1+` |`+/posts/1+` |`+s "posts" </> Post.idParser+` |`+Post PostId+`
|`+http://localhost:8000/posts/new+` |`+/posts/new+` |`+s "posts" </> s "new"+` |`NewPost`
|===

==== Step 10: Identify `NewPost` as the Next Page

Step 9 from the <<creating-a-new-post, sequence diagram>> above tells us to store `NewPost` in the `route` field in main model. We’ve already done that in the `Main.update` function.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( UrlChanged url, _ ) ->
            let
                newRoute =
                    Route.parseUrl url
            in
            ( { model | route = newRoute }, Cmd.none )
                |> initCurrentPage
        .
        .
----

And step 10 tells us to identify `NewPost` as the next page. We haven’t done that yet. Let’s add a new branch to `initCurrentPage` in `Main.elm` for the `NewPost` route.

[source,elm]
----
initCurrentPage : ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
initCurrentPage ( model, existingCmds ) =
    let
        ( currentPage, mappedPageCmds ) =
            case model.route of
                .
                .
                Route.Post postId ->
                    ...

                Route.NewPost ->
                    let
                        ( pageModel, pageCmd ) =
                            NewPost.init model.navKey
                    in
                    ( NewPage pageModel, Cmd.map NewPageMsg pageCmd )
    in
    ...
----

Now add `NewPage` to the `Page` type in `Main.elm`.

[source,elm]
----
type Page
    .
    .
    | EditPage EditPost.Model
    | NewPage NewPost.Model
----

==== Creating the `NewPost` Page

To fully implement step 10 we also need to create the `NewPost` page module. Create a new file called `NewPost.elm` inside the `Page` directory and add the following code to it.

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/create-new-post-page-file.png[]

[source,elm]
----
module Page.NewPost exposing (Model)


type alias Model =
    {}
----

Like <<editing-a-post, `EditPost`>>, the `NewPost` page module’s central type is also `Model` which is an empty record right now. We’ll expand it as we keep building the page.

The branch for the `NewPost` route in `Main.update` shows that the function for initializing the `NewPost` page takes a <<navigating-to-list-posts-page, navigation key>> as the only input.

[source,elm]
----
( pageModel, pageCmd ) =
    NewPost.init model.navKey
----

Let’s implement that function by adding the following code to the bottom of `NewPost.elm`.

[source,elm]
----
init : Nav.Key -> ( Model, Cmd Msg )
init navKey =
    ( initialModel navKey, Cmd.none )


initialModel : Nav.Key -> Model
initialModel navKey =
    { navKey = navKey
    }
----

We need access to `navKey` in `NewPost` to navigate users to the `ListPosts` page after a new post has been created. Let’s add that field to the model in `NewPost.elm`.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    }
----

`Key` is defined in the `Browser.Navigation` module, so we need to import it in `NewPost.elm`.

[source,elm]
----
module Page.NewPost exposing (Model)

import Browser.Navigation as Nav
.
.
----

==== Showing the New Post Form

We’re now ready to build a form through which the user will create a new post. Add the following code to the bottom of `NewPost.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ h3 [] [ text "Create New Post" ]
        , newPostForm
        ]


newPostForm : Html Msg
newPostForm =
    Html.form []
        [ div []
            [ text "Title"
            , br [] []
            , input [ type_ "text", onInput StoreTitle ] []
            ]
        , br [] []
        , div []
            [ text "Author Name"
            , br [] []
            , input [ type_ "text", onInput StoreAuthorName ] []
            ]
        , br [] []
        , div []
            [ text "Author URL"
            , br [] []
            , input [ type_ "text", onInput StoreAuthorUrl ] []
            ]
        , br [] []
        , div []
            [ button [ type_ "button", onClick CreatePost ]
                [ text "Submit" ]
            ]
        ]
----

We need to import the following modules in `NewPost.elm`.

[source,elm]
----
module Page.NewPost exposing (Model)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick, onInput)
.
.
----

===== onInput Messages

The `input` elements in `newPostForm` send separate messages to the Elm runtime whenever their content is modified. Let’s add those messages to a new type called `Msg`. The following code goes to the bottom of `NewPost.elm`.

[source,elm]
----
type Msg
    = StoreTitle String
    | StoreAuthorName String
    | StoreAuthorUrl String
----

Now add `update` to the bottom of `NewPost.elm` for handling those messages.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        StoreTitle title ->
            let
                oldPost =
                    model.post

                updateTitle =
                    { oldPost | title = title }
            in
            ( { model | post = updateTitle }, Cmd.none )

        StoreAuthorName name ->
            let
                oldPost =
                    model.post

                updateAuthorName =
                    { oldPost | authorName = name }
            in
            ( { model | post = updateAuthorName }, Cmd.none )

        StoreAuthorUrl url ->
            let
                oldPost =
                    model.post

                updateAuthorUrl =
                    { oldPost | authorUrl = url }
            in
            ( { model | post = updateAuthorUrl }, Cmd.none )
----

All three branches use the `post` field to store information. We haven’t added that field to the `Model` record in `NewPost.elm` yet. Let’s do that next.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    , post : Post
    }
----

For comparison, the `post` field in `EditPost.elm` had `WebData` as its type.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    , post : WebData Post
    , saveError : Maybe String
    }
----

The `EditPost` module needed to retrieve the post we wanted to edit from a server when the page was loading. By using `WebData`, we were able to <<remote-data, track all states>> our <<editing-a-post, fetch request>> went through.

In contrast, `NewPost` doesn’t retrieve a post when the page is loading. So how do we initialize the `post` field in `NewPost.elm`? We can do that by assigning it an empty post.

[source,elm]
----
initialModel : Nav.Key -> Model
initialModel navKey =
    { navKey = navKey
    , post = emptyPost
    }
----

Add the following code to the bottom of `Post.elm`.

[source,elm]
----
emptyPost : Post
emptyPost =
    { id = emptyPostId
    , title = ""
    , authorName = ""
    , authorUrl = ""
    }


emptyPostId : PostId
emptyPostId =
    PostId -1
----

We’re using `+-1+` as an empty post’s `id` to indicate that it’s temporary. The real `id` will be assigned later when the server actually creates a post. It’s highly unlikely that a real post will have a negative number as its `id`. Most servers start with a positive number as an `id` and keep incrementing it whenever a new resource is created. We need to expose `emptyPost` in `Post.elm` and `NewPost.elm`.

[source,elm]
----
module Post exposing
    .
    .
    , emptyPost
    )
----

[source,elm]
----
module Page.NewPost exposing (Model)

import Post exposing (Post, PostId, emptyPost, postDecoder)
.
.
----

===== Record Dot Syntax

Elm prohibits the use of <<record, dot syntax>> when updating a record field. That’s why we couldn’t use `model.post` inside `updateTitle` when handling the `StoreTitle` message like this:

[source,elm]
----
 title ->
    let
        updateTitle =
            { model.post | title = title }
    in
    ( { model | post = updateTitle }, Cmd.none )
----

That forced us to create a separate constant for holding the old post like this:

[source,elm]
----
StoreTitle title ->
    let
        oldPost =
            model.post

        updateTitle =
            { oldPost | title = title }
    in
    ( { model | post = updateTitle }, Cmd.none )
----

==== Creating a Post

To create a new post, the user has to click the `Submit` button. When that happens, the `CreatePost` message is sent to the Elm runtime.

[source,elm]
----
newPostForm : Html Msg
newPostForm =
        .
        .
        , div []
            [ button [ type_ "button", onClick CreatePost ]
                [ text "Submit" ]
            ]
        ]
----

Let’s add that message to the `Msg` type in `NewPost.elm`.

[source,elm]
----
type Msg
    .
    .
    | StoreAuthorUrl String
    | CreatePost
----

Now add a new branch to `update` in `NewPost.elm` for handling the `CreatePost` message.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        StoreAuthorUrl url ->
            ...

        CreatePost ->
            ( model, createPost model.post )
----

The `+CreatePost ->+` branch asks the `createPost` function to build an HTTP request. Let’s implement that right below `update` in `NewPost.elm`.

[source,elm]
----
createPost : Post -> Cmd Msg
createPost post =
    Http.post
        { url = "http://localhost:5019/posts"
        , body = Http.jsonBody (newPostEncoder post)
        , expect = Http.expectJson PostCreated postDecoder
        }
----

We need to import the `Http` module in `NewPost.elm`.

[source,elm]
----
module Page.NewPost exposing (Model)

import Http
.
.
----

[[httppost]]
===== Http.post

Luckily, Elm does provide a function called `Http.post` for creating an HTTP `POST` request which is used for creating a new resource on the server. The name of this request has nothing to do with the name we picked for our resource — `post`. It’s just a coincidence. Here’s what `Http.post`’s type signature looks like:

[source,elm]
----
post :
    { url : String
    , body : Body
    , expect : Expect msg
    }
    -> Cmd msg
----

For comparison, here’s what the type signature of `Http.get` we covered in the <<fetching-data-using-get, Fetching Data from an HTTP Server>> section looks like:

[source,elm]
----
get :
    { url : String
    , expect : Expect msg
    }
    -> Cmd msg
----

The only difference is `Http.post` takes a body whereas `Http.get` doesn’t. Just like the `PATCH` request we created for <<editing-a-post, saving a post>>, the `POST` request also uses the `Http.jsonBody` function to make it clear that the body of our request is in JSON format.

[source,elm]
----
body = Http.jsonBody (newPostEncoder post)
----

The `PATCH` request used the `postEncoder` function to encode Elm values to JSON. Here’s how it looks:

[source,elm]
----
postEncoder : Post -> Encode.Value
postEncoder post =
    Encode.object
        [ ( "id", encodeId post.id )
        , ( "title", Encode.string post.title )
        , ( "authorName", Encode.string post.authorName )
        , ( "authorUrl", Encode.string post.authorUrl )
        ]


encodeId : PostId -> Encode.Value
encodeId (PostId id) =
    Encode.int id
----

`createPost` can’t use that encoder because our new post doesn’t have a real `id` yet. The server is responsible for creating that. The JSON body that eventually gets sent to the server for creating a new post will look something like this:

[source,json]
----
{
  "title": "new-title",
  "authorName": "new-author-name",
  "authorUrl": "https://new-author-url.com"
}
----

Notice the `id` field is missing. Whereas the JSON for updating an existing post looks something like this:

[source,json]
----
{
  "id": 2,
  "title": "http-server (modified)",
  "authorName": "indexzero",
  "authorUrl": "https://github.com/indexzero"
}
----

`postEncoder` includes `id`. That’s why we can’t use it in `createPost`. What we need is a separate encoder called `newPostEncoder` that only includes `title`, `authorName`, and `authorUrl`. Let’s add that below `postEncoder` in `Post.elm`.

[source,elm]
----
newPostEncoder : Post -> Encode.Value
newPostEncoder post =
    Encode.object
        [ ( "title", Encode.string post.title )
        , ( "authorName", Encode.string post.authorName )
        , ( "authorUrl", Encode.string post.authorUrl )
        ]
----

We need to expose `newPostEncoder` in `Post.elm` and `NewPost.elm`.

[source,elm]
----
module Post exposing
    .
    .
    , newPostEncoder
    )
----

[source,elm]
----
module Page.NewPost exposing (Model)

import Post exposing (Post, PostId, emptyPost, newPostEncoder, postDecoder)
.
.
----

===== PostCreated Message

When the `POST` request is complete, the Elm runtime will send the `PostCreated` message to `update`. Let’s add it to the `Msg` type in `NewPost.elm`.

[source,elm]
----
type Msg
    .
    .
    | CreatePost
    | PostCreated (Result Http.Error Post)
----

Just like <<editing-a-post, `PostSaved`>>, `PostCreated`’s payload also doesn’t need to be of type `WebData`. A simple <<type-system, `Result`>> type is sufficient. Let’s handle `PostCreated` by adding two new branches to `update` in `NewPost.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        CreatePost ->
            ...

        PostCreated (Ok post) ->
            ( { model | post = post, createError = Nothing }
            , Cmd.none
            )

        PostCreated (Err error) ->
            ( { model | createError = Just (buildErrorMessage error) }
            , Cmd.none
            )
----

===== Handling Post Create Error

If the request is successful, we need to assign the newly created post to the `post` field. But if the request fails, we need to save an error message in the `createError` field. Let’s add that field to `Model` in `NewPost.elm`.

[source,elm]
----
type alias Model =
    { navKey : Nav.Key
    , post : Post
    , createError : Maybe String
    }
----

Now initialize `createError` to `Nothing` in `initialModel`.

[source,elm]
----
initialModel : Nav.Key -> Model
initialModel navKey =
    { navKey = navKey
    , post = emptyPost
    , createError = Nothing
    }
----

And import the `Route` and `Error` modules in `NewPost.elm`.

[source,elm]
----
module Page.NewPost exposing (Model, Msg, init, update, view)

import Error exposing (buildErrorMessage)
import Route
.
.
----

Next we need to display the error message. Add the following code below the `newPostForm` function in `NewPost.elm`.

[source,elm]
----
viewError : Maybe String -> Html msg
viewError maybeError =
    case maybeError of
        Just error ->
            div []
                [ h3 [] [ text "Couldn't create a post at this time." ]
                , text ("Error: " ++ error)
                ]

        Nothing ->
            text ""
----

And call `viewError` from `view` in `NewPost.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ h3 [] [ text "Create New Post" ]
        , newPostForm
        , viewError model.createError
        ]
----

==== Taking Users Back to the ListPosts Page

It makes sense to take the users back to the `ListPosts` page after a new post is created. To do that, we need to return a command from the `+PostCreated (Ok post) ->+` branch using `Route.pushUrl`. Modify that branch in `NewPost.update` as shown below.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        PostCreated (Ok post) ->
            ( { model | post = post, createError = Nothing }
            , Route.pushUrl Route.Posts model.navKey
            )

        PostCreated (Err error) ->
            ...
----

We already implemented `Route.pushUrl` in the <<editing-a-post, Creating Edit Post Page>> section, but we haven’t added a branch for the `NewPost` route in `routeToString` yet. Let’s do that in `Route.elm`.

[source,elm]
----
routeToString : Route -> String
routeToString route =
    case route of
        .
        .
        Post postId ->
            ...

        NewPost ->
            "/posts/new"
----

==== Adding NewPageMsg to Main

Now that we’re done implementing the `NewPost` page, we need to import it in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Page.NewPost as NewPost
.
.
----

Currently, the `NewPost` module exposes only `Model`. We need to expose `Msg`, `init`, `update`, and `view` too. Let’s do that.

[source,elm]
----
module Page.NewPost exposing (Model, Msg, init, update, view)
----

Next add `NewPageMsg` to the `Msg` type in `Main.elm`.

[source,elm]
----
type Msg
    .
    .
    | EditPageMsg EditPost.Msg
    | NewPageMsg NewPost.Msg
----

And handle that message by adding a new branch to `update` in `Main.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( EditPageMsg subMsg, EditPage pageModel ) ->
            ...

        ( NewPageMsg subMsg, NewPage pageModel ) ->
            let
                ( updatedPageModel, updatedCmd ) =
                    NewPost.update subMsg pageModel
            in
            ( { model | page = NewPage updatedPageModel }
            , Cmd.map NewPageMsg updatedCmd
            )

        ( _, _ ) ->
            ...
----

The branch for handling `NewPageMsg` looks very similar to the one that handles <<navigating-to-list-posts-page, `ListPageMsg`>> which is already covered in the <<navigating-to-list-posts-page, Updating Page Models>> section. This marks the completion of step 10 from the <<creating-a-new-post, sequence diagram>> above. Step 11 and 12 are also in place already.

==== Step 13 - 17: Return NewPost View

We can take care of the rest of the steps by adding a new branch for `NewPage` to the `currentView` function in `Main.elm`.

[source,elm]
----
currentView : Model -> Html Msg
currentView model =
    case model.page of
        .
        .
        EditPage pageModel ->
            ...

        NewPage pageModel ->
            NewPost.view pageModel
                |> Html.map NewPageMsg
----

If you don’t remember how `Html.map` works, you may want to review the <<navigating-to-list-posts-page, Displaying Current Page>> section.

==== Testing the NewPost Page

We’re now ready to test the `NewPost` page. Run `+json-server+` and `+elm-live+` from the `+beginning-elm+` directory in separate terminal windows if they aren’t running already.

[source,bash]
----
$ json-server --watch server/db.json -p 5019

$ elm-live post-app/Main.elm --pushstate
----

Check the `+elm-live+` window in terminal to make sure everything compiled successfully. Now go to http://localhost:8000[`+http://localhost:8000+`] and you should see the _Create new post_ link.

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/create-new-post-link.png[]

Click that link and you’ll be taken to the `NewPost` page. The URL in browser’s address bar will also change to http://localhost:8000/posts/new[`+http://localhost:8000/posts/new+`]. Enter the following info into the text fields and click `Submit`.

* Title: `+elm-live+`
* Author Name: `+wking-io+`
* Author URL: https://github.com/wking-io[`+https://github.com/wking-io+`]

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/create-post-page.png[]

If everything goes well, `+json-server+` will create a new post and you’ll be taken back to the `ListPosts` page.

image:https://elmprogramming.com/images/chapter-7/7.9-creating-a-new-post/new-post-created.png[]

`+json-server+` incremented the `id` by 1 to `3` and assigned it to the new post. Originally, we had two posts. We then deleted the first post in the <<deleting-a-post, Deleting a Post>> section. It’s uncommon for the server to reuse a deleted resource’s `id`. You can also verify the creation of a new post by checking the `+server/db.json+` file.

[source,json]
----
{
  "posts": [
    .
    .
    {
      "title": "elm-live",
      "authorName": "wking-io",
      "authorUrl": "https://github.com/wking-io",
      "id": 3
    }
  ],
  .
  .
}
----

==== Summary

In this section, we learned how to create a new resource by sending a `POST` HTTP request to the server. The process for creating a new resource is very similar to how we update an existing resource. One major difference is we can’t include the `id` of a new resource in JSON body.


[[single-page-apps-conclusion]]
=== 7.10 Conclusion


In this chapter, we learned what single-page apps are and how to build them in Elm. We also learned how to **C**reate, **R**ead, **U**pdate, and **D**elete (CRUD) resources on a server from an Elm app. The built-in modules — `Http`, `Json.Decode`, and `Json.Encode` — provide everything we need for creating CRUD requests.

As we started adding more features to our app, we realized that we needed to split our code into smaller modules. We followed a https://guide.elm-lang.org/webapps/structure.html[simple yet highly scalable structure] recommended by Evan Czaplicki — the creator of Elm — to organize our code.

We built separate pages for creating, updating, and retrieving resources from a server. The https://package.elm-lang.org/packages/elm/browser/latest/[`+elm/browser+`] and https://package.elm-lang.org/packages/elm/url/latest/[`+elm/url+`] packages allowed us to build a robust navigation system for routing users to correct pages based on paths.

In the next chapter, we’ll learn how to interact with JavaScript from Elm using ports.


[[interact-with-javascript-intro]]
== 8 Interact with JavaScript

=== 8.1 prelude

Elm provides many built-in as well as third-party http://package.elm-lang.org/[packages] for solving various problems that arise as we build client-side web applications. Even though Elm’s package catalog keeps growing, there are times when we need to rely on a JavaScript package to get things done.

Ideally, we should avoid using JavaScript packages in our Elm code base because they can cause runtime errors. Unfortunately, it’ll take a long time for Elm to catch up to the JavaScript ecosystem which has tens of thousands of https://www.npmjs.com/[packages] for solving a wide variety of problems. Therefore, it’s important for us to know how to interact with JavaScript code from Elm.

In this chapter, we’ll learn how to use ports and flags to safely communicate with JavaScript. We’ll also learn how to take advantage of custom elements built using https://www.webcomponents.org/introduction[Web Components].


[[sending-data-to-javascript]]
=== 8.2 Sending Data to JavaScript


In the <<pure-functions, Pure Functions>> section, we learned that JavaScript functions can cause side effects. Elm functions on the other hand are pure and as a result don’t cause any side effects. As nice as it is to have pure functions that are highly reliable, to do anything useful Elm programs must deal with the outside world which is riddled with side effects.

In the <<side-effects, Elm Runtime to the Rescue>> section, we learned how Elm uses <<commands, commands>>, <<subscriptions, subscriptions>>, and messages to properly manage side effects originated from interacting with the outside world.

image:https://elmprogramming.com/images/chapter-5/5.5-side-effects/elm-runtime.svg[]

The figure above shows that the way we interact with a JavaScript library is very similar to how we interact with an external service such as an HTTP server. In both cases we tell the Elm runtime to perform an operation by sending a command. When the operation is complete, the runtime sends a message back to our app.

To further understand this interaction, let’s create a simple Elm app that sends and receives data from JavaScript code. Create a file called `PortExamples.elm` inside the `+beginning-elm/src+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-8/8.2-sending-data-to-js/create-port-examples-file.png[]

[source,elm]
----
module PortExamples exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)


type alias Model =
    String


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        ]


type Msg
    = SendDataToJS


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, Cmd.none )


init : () -> ( Model, Cmd Msg )
init _ =
    ( "", Cmd.none )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----

The code above is quite simple. All it does is display a button titled _Send Data to JavaScript_. When that button is clicked, `update` receives the `SendDataToJS` message. To send data to JavaScript, we need to create a command inside the `+SendDataToJS ->+` branch in `update`.

Up until now we’ve been relying on a specific function such as <<commands, `Random.generate`>> and <<fetching-data-using-get, `Http.get`>> to create a command.

[source,elm]
----
Random.generate : (a -> msg) -> Generator a -> Cmd msg

Http.get : { url : String, expect : Expect msg } -> Cmd msg
----

To create a command for sending data to JavaScript we’ll have to use a different approach that involves a port. Let’s define a function called `sendData` below `update` in `PortExamples.elm`.

[source,elm]
----
port sendData : String -> Cmd msg
----

Wait a minute. That doesn’t look like a function. Where is the function body? And what is the `port` keyword doing in front of the function name? The diagram below answers those questions.

image:https://elmprogramming.com/images/chapter-8/8.2-sending-data-to-js/port-function-syntax.svg[]

There is something odd about `sendData`’s return type. If you compare its definition with the ones listed above for `Random.generate` and `Http.get`, you’ll notice that the type variable `msg` appears out of nowhere in `sendData`’s definition. Usually, if a type variable is included in a return type we can trace its origin back to a parameter, but that’s not the case here. `sendData`’s parameter is a simple `String` with no type variable.

What’s really going on is that unlike all other commands we’ve seen so far, the command generated by a port function doesn’t send a message back to the `update` function once the operation is complete. If you think about it, it actually makes sense not to send any messages back to our app. All we want to do is tell the Elm runtime to send some data to JavaScript. We’re not concerned with whether that data is indeed sent to JavaScript or not.

A command that doesn’t send any messages back to the app always has the type `+Cmd msg+`. If we had used `+Cmd Msg+` as the return type instead, we would be implying that the command sends a message of type `Msg` which is not true.

If you look inside the https://package.elm-lang.org/packages/elm/core/latest/Platform-Cmd#none[`Platform.Cmd`] module, you’ll notice that the `Cmd.none` value we’ve been using throughout this book to represent the absence of a command also uses `+Cmd msg+` as the return type.

[source,elm]
----
Cmd.none : Cmd msg
----

The difference between `Cmd.none` and the `sendData` port function is that the former doesn’t create any command, but the latter creates a command that doesn’t send any messages back to the app. Now that we know what `sendData` is and what it does, let’s use it in the `update` function to create a command.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, sendData "Hello JavaScript!" )
----

The syntax for calling a port function is identical to that of a <<function, regular function>>. When `update` receives the `SendDataToJs` message, it calls `sendData` to create a command that sends the string `+"Hello JavaScript"+` to, you guessed it, JavaScript.

Next we need to compile the Elm code in `PortExamples.elm`. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

Unfortunately, the compiler throws an error.

[source,elm]
----
------------ BAD PORT ------------ src/PortExamples.elm
You are declaring port `sendData` in a normal module.

24| port sendData : String -> Cmd msg
         ^^^^^^^^
It needs to be in a `port` module.
----

What exactly is a *port module*? It’s a module whose declaration is prefixed with the keyword `port`. Let’s make `PortExamples` a port module by adding that keyword to the module definition in `PortExamples.elm`.

[source,elm]
----
port module PortExamples exposing (main)
----

Run the following command one more time from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

The error should go away and the `elm.js` file in `+beginning-elm+` should be overwritten with the compiled code for `PortExamples`. Now we need to write some JavaScript code to receive the string sent by Elm app on the other end. Let’s replace the contents of `index.html` located inside the `+beginning-elm+` directory with the following.

[source,html]
----
<!DOCTYPE html>
<html>
<body>
    <div id="elm-code-is-loaded-here"></div>
        
    <script src="elm.js"></script>
    <script>
      var app = Elm.PortExamples.init({
        node: document.getElementById("elm-code-is-loaded-here")
      });

      app.ports.sendData.subscribe(function(data) {
        console.log("Data from Elm: ", data);
      });
    </script>
</body>
</html>
----

The first thing we did in `index.html` is create a `div` that will load the Elm app. We then included the `elm.js` file which contains the compiled code. Finally, the last `+<script>+` section is where the code for receiving the string sent by our Elm app goes. Let’s go through that code step by step.

*Step 1:* Get hold of the `div` with id `+elm-code-is-loaded-here+` and embed the Elm app from `PortExamples.elm` into that `div`.

[source,javascript]
----
var app = Elm.PortExamples.init({
    node: document.getElementById("elm-code-is-loaded-here")
});
----

*Step 2:* Listen to `sendData` port using the `subscribe` function. When the data arrives, print it to the browser console.

[source,javascript]
----
app.ports.sendData.subscribe(function(data) {
    console.log("Data from Elm: ", data);
});
----

All ports defined in our Elm app can be accessed through `app.ports`. We’re now ready to test. Open `index.html` in a browser and go to the browser console. Now click the *Send Data to JavaScript* button and you should see `+Data from Elm: Hello JavaScript!+` in the console.

image:https://elmprogramming.com/images/chapter-8/8.2-sending-data-to-js/data-from-elm.png[]

The following diagram illustrates the workflow we just implemented for sending data to JavaScript.

image:https://elmprogramming.com/images/chapter-8/8.2-sending-data-to-js/send-data-to-js-workflow.svg[]

==== Summary

In this section, we learned how to send data to JavaScript from an Elm app using a port. Elm treats JavaScript just like an HTTP server. That’s why we need to use a command to send data to JavaScript too. Elm doesn’t allow any code to pass through a port. All we can send is data. In the next section, we’ll learn what subscriptions are. Here is the entire code from `PortExamples.elm` for your reference:

[source,elm]
----
port module PortExamples exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)


type alias Model =
    String


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        ]


type Msg
    = SendDataToJS


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, sendData "Hello JavaScript!" )


port sendData : String -> Cmd msg


init : () -> ( Model, Cmd Msg )
init _ =
    ( "", Cmd.none )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[subscriptions]]
=== 8.3 Subscriptions


In this section, we’ll learn how a subscription works. Subscription is the last piece of the Elm Architecture puzzle. It’ll also come handy for <<receiving-data-from-javascript, receiving data from JavaScript>> in the next section.

Subscriptions allow us to listen to external events such as incoming https://en.wikipedia.org/wiki/WebSocket[WebSocket] messages, clock tick events, mouse/keyboard events, geolocation changes, and an output generated by a JavaScript library.

When we want to listen to an event all we have to do is create a subscription that specifies the type of event and which message to send to the `update` function when that event is triggered. We then hand that subscription over to the Elm runtime and wait for the event to occur. The runtime figures out how to listen to that event. All we need to do is handle the message it sends to our app. Let’s see how this works in practice through a simple example app that increments a counter every time a key is pressed.

==== Model

As usual we’ll start with the model. Create a new file called `EventListener.elm` in the `+beginning-elm/src+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-8/8.3-subscriptions/create-event-listener-file.png[]

[source,elm]
----
module EventListener exposing (Model)


type alias Model =
    Int
----

Our model is just an alias for the `Int` type. All we need to do is keep track of the number of key press events. Next, we need to create an initial model. Add the following code to the bottom of `EventListener.elm`.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( 0, Cmd.none )
----

==== View

The code for presenting our model to the user is also quite simple. Add the following code to the bottom of `EventListener.elm`.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ text (String.fromInt model) ]
----

All we’re doing here is display the model. Import the `Html` module in `EventListener.elm`.

[source,elm]
----
module EventListener exposing (Model)

import Html exposing (..)
.
.
----

==== Message

Whenever a key is pressed an event is generated. We want the Elm runtime to notify us about that event by sending the `KeyPressed` message. Let’s add its definition to the bottom of `EventListener.elm`.

[source,elm]
----
type Msg
    = KeyPressed
----

We aren’t interested in knowing which key was pressed. That’s why `KeyPressed` doesn’t have a payload. Later we’ll learn how to <<subscriptions, listen to a specific key press event>>.

==== Update

Next we’ll handle the `KeyPressed` message in `update`. Add the following code to the bottom of `EventListener.elm`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        KeyPressed ->
            ( model + 1, Cmd.none )
----

When the `KeyPressed` message arrives, we simply increment the model by `1`.

==== Subscription

Now we need to tell the Elm runtime to listen to a key press event. We can do that by creating a subscription. Add the following code to the bottom of `EventListener.elm`.

[source,elm]
----
subscriptions : Model -> Sub Msg
subscriptions model =
    onKeyPress (Decode.succeed KeyPressed)
----

The `Browser.Events` module provides a function called `onKeyPress` which is responsible for subscribing to all key press events. Here’s what its type signature looks like:

[source,elm]
----
onKeyPress : Decoder msg -> Sub msg
----

It takes a decoder as an input and returns a subscription. In the <<decoding-json-part-1, Decoding JSON - Part 1>> & <<decoding-json-part-2, Part 2>> sections, we used decoders to transform JSON values to Elm. `onKeyPress` uses the same decoders to translate underlying key codes to Elm values.

How do we let `onKeyPress` know that we don’t care about a specific key value? We can do that by using `Decode.succeed` which ignores its input and always returns the given Elm value. In the `subscriptions` function above, we asked it to always return the `KeyPressed` message.

****
NOTE: If you’re interested in seeing more examples of `Decode.succeed`, you may want to review the <<decoding-json-part-2, Decoding a JSON Object>> section from chapter 6.
****

Like <<commands, commands>>, we don’t tend to create subscriptions by using some constructor function. Instead, we just look for an appropriate function like `onKeyPress` in a module and use it to create a subscription. Here’s another example: let’s say we want to get the current time periodically. We can create a subscription for that by using the https://package.elm-lang.org/packages/elm/time/latest/Time#every[Time.every] function.

We need to import the `Browser.Events` and `Json.Decode` modules in `EventListener.elm`.

[source,elm]
----
module EventListener exposing (Model)

import Browser.Events exposing (onKeyPress)
import Json.Decode as Decode
.
.
----

===== Subscription Takes a Model

Notice how the `subscriptions` function takes a `model` as its only argument, but doesn’t use that argument in the function body at all. Why did we include an unused argument in the definition? That’s because Elm runtime expects the function responsible for creating a subscription to accept a model regardless of whether that model is used or not. Since we aren’t using that parameter, we should replace it with `_`.

[source,elm]
----
subscriptions : Model -> Sub Msg
subscriptions _ =
    onKeyPress (Decode.succeed KeyPressed)
----

Our example app is quite simple and doesn’t use the model to create a subscription. But other apps may use it to build complex subscriptions.

==== Wiring Everything Up

We’re now ready to wire everything together. Add the `main` function to the bottom of `EventListener.elm`.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
----

And import the `Browser` module.

[source,elm]
----
module EventListener exposing (Model)

import Browser
.
.
----

By assigning the name of the function that creates a subscription to the `subscriptions` field in `main`, we’re asking Elm runtime to start listening to the key press events as soon as the app is initialized.

We’re now ready to test. Run `+elm reactor+` from the `+beginning-elm+` directory in terminal and go to this URL in your browser: http://localhost:8000/src/EventListener.elm[`+http://localhost:8000/src/EventListener.elm+`]. You should see a page that just displays *0*.

image:https://elmprogramming.com/images/chapter-8/8.3-subscriptions/event-listener-view.png[]

Press any alphanumeric key and the counter will go up. Elm doesn’t require us to use `subscriptions` as the name for the function that creates a subscription. We used that name to make our code more readable. All Elm is looking for is a function that accepts a model and returns a subscription. In fact, we don’t even need to create a named function. We could simply assign an anonymous function to the `subscriptions` field directly like this:

[source,elm]
----
main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> onKeyPress (Decode.succeed KeyPressed)
        }
----

That being said, it’s cleaner to extract the code for creating a subscription out to a separate function, especially when we want to <<subscriptions, subscribe to multiple events>>.

==== Subscribing to a Specific Key Event

Let’s say we want to increment the counter only when the *i* key is pressed. Similarly, we want to decrement it only when the *d* key is pressed. To do that, we need to pay attention to the https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values[underlying value of a key]. Let’s replace `KeyPressed` with the following messages in the `Msg` type.

[source,elm]
----
type Msg
    = CharacterKey Char
    | ControlKey String
----

`CharacterKey` represents all character keys, for example `i`, `d`, `1`, `+++`, etc. And `ControlKey` represents special keys such as `Control`, `+Left Arrow+`, and `+Right Arrow+`. Next we’ll write a decoder that’s capable of making this distinction. Add the following code below the `subscriptions` function in `EventListener.elm`.

[source,elm]
----
keyDecoder : Decode.Decoder Msg
keyDecoder =
    Decode.map toKey (Decode.field "key" Decode.string)


toKey : String -> Msg
toKey keyValue =
    case String.uncons keyValue of
        Just ( char, "" ) ->
            CharacterKey char

        _ ->
            ControlKey keyValue
----

In the <<decoding-json-part-2, Decoding a JSON Object>> section, we learned how to decode an individual JSON field using the `field` decoder. When a key is pressed, the browser sends `onKeyPress` a JSON that looks something like this:

[source,json]
----
{
    "key": "keyValue"
}
----

The `+Decode.field "key" Decode.string+` expression in `keyDecoder` pulls `keyValue` out of JSON. After that `Decode.map` uses the `toKey` function to determine whether the user pressed a character or a control key.

[[stringuncons]]
===== String.uncons

The `String.uncons` function splits a non-empty string into its head and tail. Here’s what its type signature looks like:

image:https://elmprogramming.com/images/chapter-8/8.3-subscriptions/string-uncons-type-signature.svg[]

Let’s fire up <<elm-repl, `+elm repl+`>> from the `+beginning-elm+` directory and experiment with `uncons` to understand it better.

[source,elm]
----
> String.uncons "abc"
Just ('a',"bc") : Maybe ( Char, String )

> String.uncons "a"
Just ('a',"") : Maybe ( Char, String )

> String.uncons ""
Nothing : Maybe ( Char, String )
----

As you can see, `uncons` must return a value of type `Maybe` because the given string can be empty. We saw a similar pattern with the <<list, `List.head`>> function.

[source,elm]
----
> List.head [ "a", "b", "c" ]
Just "a" : Maybe String

> List.head [ "a" ]
Just "a" : Maybe String

> List.head []
Nothing : Maybe a
----

By splitting a string into its head and tail, `uncons` has given us the ability to <<pattern-matching, pattern match>> on strings exactly as we would on lists. In the <<pattern-matching, Pattern Matching Lists>> section, we saw how the `List` module uses pattern matching to elegantly implement the <<list, `foldl`>> function.

[source,elm]
----
foldl : (a -> b -> b) -> b -> List a -> b
foldl func acc list =
    case list of
        [] ->
            acc

        x :: xs ->
            foldl func (func x acc) xs
----

We can implement `foldl` for strings too using a similar pattern with the help of `uncons`.

[source,elm]
----
foldl : (Char -> b -> b) -> b -> String -> b
foldl func acc string =
    case String.uncons string of
        Nothing ->
            acc

        Just ( head, tail ) ->
            foldl func (func head acc) tail
----

[[exercise-831]]
===== Exercise 8.3.1

The inner workings of `List.foldl` has already been covered extensively in the <<pattern-matching, Pattern Matching Lists>> section. See if you can use that as a reference to figure out how the above implementation for `String.foldl` works.

===== CharacterKey

Let’s handle the `CharacterKey` message in `update` by replacing its current implementing with the following.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        CharacterKey 'i' ->
            ( model + 1, Cmd.none )

        CharacterKey 'd' ->
            ( model - 1, Cmd.none )

        _ ->
            ( model, Cmd.none )
----

The only thing remaining is to use `keyDecoder` in the `subscriptions` function.

[source,elm]
----
subscriptions : Model -> Sub Msg
subscriptions _ =
    onKeyPress keyDecoder
----

We’re now ready to test. Refresh the page at http://localhost:8000/src/EventListener.elm[`+http://localhost:8000/src/EventListener.elm+`]. When you press the *i* key, the counter should go up and when you press the *d* key, the counter should go down.

==== Subscribing to Multiple Events

Let’s extend our app by also listening to a mouse click event. When that event arrives we’ll increment the counter by `5`. The first thing we need to do is add a new message called `MouseClick` to the `Msg` type in `EventListener.elm`.

[source,elm]
----
type Msg
    = CharacterKey Char
    | ControlKey String
    | MouseClick
----

Next we’ll handle `MouseClick` by adding a new branch to the `update` function.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        CharacterKey 'd' ->
            ...

        MouseClick ->
            ( model + 5, Cmd.none )

        _ ->
            ...
----

When the `MouseClick` message arrives, we simply increment the model by `5`. It’s important to add the `+MouseClick ->+` branch above the <<case-expression, catch-all branch>>. Otherwise, it’ll be unreachable. Now let’s create a subscription by using the `onClick` function.

[source,elm]
----
subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.batch
        [ onKeyPress keyDecoder
        , onClick (Decode.succeed MouseClick)
        ]
----

`onClick` is also defined in the `Browser.Events` module. Let’s expose it in `EventListener.elm`.

[source,elm]
----
import Browser.Events exposing (onClick, onKeyPress)
----

When we have more than one subscription, we must batch them with `Sub.batch`. Here’s how its type signature looks:

[source,elm]
----
Sub.batch : List (Sub msg) -> Sub msg
----

It’s interesting to note that the return type of our `subscriptions` function didn’t change at all even though we’re now returning multiple subscriptions. We also saw this pattern with `Cmd.batch` in the <<navigating-to-list-posts-page, Navigating to List Posts Page>> section earlier.

[source,elm]
----
Cmd.batch : List (Cmd msg) -> Cmd msg
----

Refresh the page at http://localhost:8000/src/EventListener.elm[`+http://localhost:8000/src/EventListener.elm+`] and the counter should be incremented by `5` when you click anywhere on the page.

==== Summary

In this section, we learned how to use subscriptions to listen to various events. Subscriptions also cause <<side-effects, side effects>>. That’s why we have to let the Elm runtime manage them. Here is how the <<elm-architecture-intro, Elm Architecture>> looks with the introduction of subscriptions:

image:https://elmprogramming.com/images/chapter-8/8.3-subscriptions/mvu-subscription.svg[]

The following sequence diagram shows the interaction between the Elm runtime and our code.

image:https://elmprogramming.com/images/chapter-8/8.3-subscriptions/subscription-sequence-diagram.svg[]

Here’s the entire code from `EventListener.elm` for your reference:

[source,elm]
----
module EventListener exposing (Model)

import Browser
import Browser.Events exposing (onClick, onKeyPress)
import Html exposing (..)
import Json.Decode as Decode


type alias Model =
    Int


init : () -> ( Model, Cmd Msg )
init _ =
    ( 0, Cmd.none )


view : Model -> Html Msg
view model =
    div []
        [ text (String.fromInt model) ]


type Msg
    = CharacterKey Char
    | ControlKey String
    | MouseClick


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        CharacterKey 'i' ->
            ( model + 1, Cmd.none )

        CharacterKey 'd' ->
            ( model - 1, Cmd.none )

        MouseClick ->
            ( model + 5, Cmd.none )

        _ ->
            ( model, Cmd.none )


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.batch
        [ onKeyPress keyDecoder
        , onClick (Decode.succeed MouseClick)
        ]


keyDecoder : Decode.Decoder Msg
keyDecoder =
    Decode.map toKey (Decode.field "key" Decode.string)


toKey : String -> Msg
toKey keyValue =
    case String.uncons keyValue of
        Just ( char, "" ) ->
            CharacterKey char

        _ ->
            ControlKey keyValue


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
----


[[receiving-data-from-javascript]]
=== 8.4 Receiving Data from JavaScript


Earlier we learned how to http://localhost:4000/sending-data-to-javascript.html[send data from Elm to JavaScript]. In this section, we’ll go the other way and send data from JavaScript to Elm. The good news is we can use a port for that too. Let’s add a new port function called `receiveData` right below the `update` function in `+src/PortExamples.elm+`.

[source,elm]
----
port receiveData : (Model -> msg) -> Sub msg
----

****
NOTE: Going forward we’ll refer to the port for sending data to JavaScript as an _outgoing port_ and the port for receiving data from JavaScript as an _incoming port_.
****

The following diagram shows the difference between an outgoing and incoming port.

image:https://elmprogramming.com/images/chapter-8/8.4-receiving-data-from-js/incoming-vs-outgoing-ports.svg[]

Unlike the command (returned by the outgoing port), we actually want the subscription (returned by the incoming port) to send a message to our app whenever the JavaScript code sends some data.

image:https://elmprogramming.com/images/chapter-8/8.4-receiving-data-from-js/elm-to-javascript.svg[]

We’ll be storing whatever value JavaScript sends in our model. Let’s add a new data constructor called `ReceivedDataFromJS` to the `Msg` type in `PortExamples.elm` that takes the model as an input and returns a message.

[source,elm]
----
type Msg
    = SendDataToJS
    | ReceivedDataFromJS Model
----

Next we need to handle `ReceivedDataFromJS` in `update`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ...

        ReceivedDataFromJS data ->
            ( data, Cmd.none )
----

All we’re doing here is return whatever data JavaScript sends as the model. Now we need to display the model. Modify the `view` function in `PortExamples.elm` like this:

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        , br [] []
        , br [] []
        , text ("Data received from JavaScript: " ++ model)
        ]
----

Next we need to ask the Elm runtime to listen to the data coming from JavaScript by giving it the subscription returned by the `receiveData` port function. Create a function called `subscriptions` right below `update` in `PortExamples.elm`.

[source,elm]
----
subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveData ReceivedDataFromJS
----

Remember, the runtime passes the model to `subscriptions`. Since we don’t need anything in the model to create a subscription, we’re ignoring that parameter with `_`.

If you pay close attention to the return type of `subscriptions`, you’ll notice that it uses `Msg` whereas the return type of `receiveData` port uses `msg`. Shouldn’t they both match? Not in this case. Let’s try changing the return type of `subscriptions` in `PortExamples.elm` to `msg` and see what happens.

[source,elm]
----
subscriptions : Model -> Sub msg
subscriptions _ =
    receiveData ReceivedDataFromJS
----

Run the following command from the `+beginning-elm+` directory in terminal to compile `PortExamples.elm`.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

You should see the following error.

[source,elm]
----
---------------- TYPE MISMATCH ---------------- src/PortExamples.elm
Something is off with the body of the `subscriptions` definition:

36|     receiveData ReceivedDataFromJS
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This `receiveData` call produces:

    Sub Msg

But the type annotation on `subscriptions` says it should be:

    Sub msg

Hint: Your type annotation uses type variable `msg` which means ANY type of
value can flow through, but your code is saying it specifically wants a `Msg`
value. Maybe change your type annotation to be more specific? Maybe change the
code to be more general?
----

The error message tells us exactly why we must use `+Sub Msg+` as `subscriptions`’s return type. Let’s change the return type back to `+Sub Msg+`.

[source,elm]
----
subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveData ReceivedDataFromJS
----

What about `receiveData`’s return type? Can we change it to `+Sub Msg+` so they both match? Let’s try it.

[source,elm]
----
port receiveData : (Model -> Msg) -> Sub Msg
----

Once again run the following command from the `+beginning-elm+` directory in terminal to compile `PortExamples.elm`.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

Now you should see a different error.

[source,elm]
----
------------------ BAD PORT ----------------- src/PortExamples.elm
There is something off about this `receiveData` port declaration.

31| port receiveData : (Model -> msg) -> Sub Msg
         ^^^^^^^^^^^
To receive messages from JavaScript, you need to define a port like this:

    port receiveData : (Int -> msg) -> Sub msg

Now every time JS sends an `Int` to this port, it is converted to a `msg`. 
And if you subscribe, those `msg` values will be piped into your `update`
function. The only thing you can customize here is the `Int` type.
----

As it turns out, Elm expects us to use a particular format when defining a port and that format requires us to use a type variable `msg` instead of a concrete type such as `Msg`. Let’s change `receiveData`’s return type back to `+Sub msg+`.

[source,elm]
----
port receiveData : (Model -> msg) -> Sub msg
----

`msg` is less restrictive than `Msg`. That’s why Elm allows us to pass a data constructor with the type `+Model -> Msg+` to `receiveData` even if it’s expecting `+Model -> msg+`. The only thing remaining on the Elm side is to assign the `subscriptions` function to the `subscriptions` field in `main`.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
----

Recompile `PortExamples.elm` by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

Everything should compile fine. Now we need to write some JavaScript code for sending data to Elm. Modify the callback function we passed to `+app.ports.sendData.subscribe+` in `+beginning-elm/index.html+` like this:

[source,html]
----
<script>
    .
    .
    app.ports.sendData.subscribe(function(data) {
        console.log("Data from Elm: ", data);
        app.ports.receiveData.send("Hey Elm!");
    });
</script>
----

We can access all ports defined in our Elm app through `app.ports`. To send data to Elm, we need to use the `send` function instead of `subscribe`. Open `index.html` in a browser and click the _Send Data to JavaScript_ button. You should see `+Hey Elm!+` on the page.

image:https://elmprogramming.com/images/chapter-8/8.4-receiving-data-from-js/receive-data-from-javascript.png[]

The following diagram illustrates the entire workflow for sending and receiving data from JavaScript.

image:https://elmprogramming.com/images/chapter-8/8.4-receiving-data-from-js/send-receive-data-from-js.svg[]

==== Summary

In this section, we learned how to receive data from JavaScript using an incoming port. The incoming port returns a subscription which is given to the Elm runtime when the app is being initialized. Once the app is fully running, the runtime will start listening for any data coming from JavaScript. When data arrives, the runtime will route it to our `update` function by sending a message. Here is the entire code from `PortExamples.elm` for your reference:

[source,elm]
----
port module PortExamples exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)


type alias Model =
    String


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        , br [] []
        , br [] []
        , text ("Data received from JavaScript: " ++ model)
        ]


type Msg
    = SendDataToJS
    | ReceivedDataFromJS Model


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, sendData "Hello JavaScript!" )

        ReceivedDataFromJS data ->
            ( data, Cmd.none )


subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveData ReceivedDataFromJS


port sendData : String -> Cmd msg


port receiveData : (Model -> msg) -> Sub msg


init : () -> ( Model, Cmd Msg )
init _ =
    ( "", Cmd.none )


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
----


[[protecting-boundaries]]

=== 8.5 Protecting Boundaries between Elm and JavaScript


What happens if we send a number instead of a string from JavaScript to our Elm app? Let’s find out by replacing `+Hey Elm!+` with `10` in the callback function given to `+app.ports.sendData.subscribe+` inside `+beginning-elm/index.html+`.

[source,html]
----
<script>
    .
    .
    app.ports.sendData.subscribe(function(data) {
        console.log("Data from Elm: ", data);
        app.ports.receiveData.send(10);
    });
</script>
----

Reload `index.html` in a browser and click the _Send Data to JavaScript_ button. Number `10` doesn’t appear on the page. To find out why, open the browser console.

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/wrong-data-type-console-error.png[]

Unlike JavaScript, Elm is very strict about data types. Since we said the `receiveData` port will receive a value of type `Model`, which is just `String` behind the scenes, Elm doesn’t let any other types through that port.

[source,elm]
----
port receiveData : (Model -> msg) -> Sub msg
----

This is a great news because Elm has our back if the JavaScript code misbehaves by trying to sneak in a type we aren’t expecting. We can actually make this mismatched type detection process even better by displaying a helpful message to the users instead of just crashing our app.

==== Which Types are Allowed through Ports?

Before we improve our app by not letting it crash whenever a wrong type is received from JavaScript, let’s understand what types of data Elm allows through both incoming and outgoing ports.

Interacting with JavaScript code from an Elm app is very similar to how we interact with an HTTP server. Therefore, to keep things simple Elm prefers to stick with JSON when sending and receiving data from JavaScript as well.

JSON stands for **J**ava**S**cript **O**bject **N**otation and is derived from JavaScript. It’s not a coincidence that all of the valid types in JSON listed below — except `null` — are also available in JavaScript. This makes converting JSON values to JavaScript and vice versa incredibly easy.

****
NOTE: In JavaScript, `null` is a value whose type is `object`. Unfortunately, this is a bug in the language according to Brendan Eich — the creator of JavaScript. Luckily, JSON sidestepped this bug by creating a separate type for `null`.
****

* *string* - A string must be written in double quotes and looks very similar to an Elm string.
* *number* - A number must be an integer or a float.
* *boolean* - A boolean must be either `true` or `false`.
* *null* - `null` is used to indicate an absence of a value.
* *Array* - An array can contain any other JSON values including arrays themselves.
* *object* - An object consists of key value pairs.

Despite its roots in JavaScript, JSON is language independent. In fact, it was originally created to simplify the interchange of data between applications regardless of which language they were written in. Now you can see why the designers of Elm chose JSON for communicating with JavaScript code.

The table below shows the mapping between Elm and JSON values when we send and receive data from JavaScript via ports.

[cols=",,,,",options="header,autowidth",frame=ends,grid=rows]
|===
|*Elm Value* |*Elm Type* |*JSON Value* |*JSON Type* |*JavaScript Type*
|`+"Hello JavaScript"+` |`String` |`+"Hello JavaScript"+` |`string` |`string`
|`10` |`Int` |`10` |`number` |`number`
|`3.14` |`Float` |`3.14` |`number` |`number`
|`True` |`Bool` |`true` |`boolean` |`boolean`
|`Nothing` |`+Maybe a+` |`null` |`null` |`object`
|`+{ age = 25 }+` |`Record` |`+{"age" : 25}+` |`object` |`object`
|`+( 9, "Pam", False )+` |`Tuple` |`+[9, "Pam", False]+` |`array` |`Array`
|`+[ 1, 2 ]+` |`+List Int+` |`+[1, 2]+` |`array` |`Array`
|`+[ "Mr", "Robot" ]+` |`+List String+` |`+["Mr", "Robot"]+` |`array` |`Array`
|===

==== Decoding JSON Values Received from JavaScript

By default, the runtime is in charge of converting data between Elm and JavaScript. For example, when receiving data from JavaScript, the runtime first converts JavaScript values to JSON and then decodes the JSON into corresponding Elm values. That’s why we didn’t have to decode the data coming from JavaScript ourselves. Elm knew how to translate it properly just by looking at the type of our incoming port function.

[source,elm]
----
port receiveData : (Model -> msg) -> Sub msg
----

A downside of letting the runtime do the decoding behind the scenes is that if the JavaScript code sends an incorrect type, our app simply crashes. A better approach is to do the decoding ourselves. That way if anything goes wrong, we’ll be able to show a proper error message to the user.

===== Modifying Incoming Data’s Type

Let’s start by changing the type of `receiveData` incoming port from `Model` to `Value` in `PortExamples.elm`.

[source,elm]
----
port receiveData : (Value -> msg) -> Sub msg
----

The `Value` type represents a JSON value. It’s defined in the `Json.Encode` module, but the `Json.Decode` module also makes it available through the use of `+type alias+`.

[source,elm]
----
type alias Value =
    Value
----

This way we don’t have to import `Json.Encode` if all we’re doing is use the `Value` type. Import `Json.Decode` in `PortExamples.elm`.

[source,elm]
----
port module PortExamples exposing (main)

import Json.Decode exposing (Error(..), Value, decodeValue, string)
.
.
----

We’ve also exposed the `Error` type, `string` decoder and `decodeValue` function. We’ll use them later.

===== Handling `ReceivedDataFromJS` Differently

Now that the type of our incoming data has changed from `Model` to `Value`, we need to modify the `ReceivedDataFromJS` message in `PortExamples.elm`.

[source,elm]
----
type Msg
    = SendDataToJS
    | ReceivedDataFromJS Value
----

This means we can’t simply return incoming data as model inside the `+ReceivedDataFromJS data ->+` branch in `update` anymore. We need to decode the incoming JSON first. Let’s make that change.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        ReceivedDataFromJS value ->
            case decodeValue string value of
                Ok data ->
                    ( { model | dataFromJS = data }, Cmd.none )

                Err error ->
                    ( { model | jsonError = Just error }, Cmd.none )
----

===== decodeString vs decodeValue

In the <<decoding-json-part-1, Decoding JSON>> section, we used `decodeString` to parse a raw string fetched from an HTTP server into JSON and then used the `string` decoder to transform that JSON into an Elm string.

[source,elm]
----
> decodeString string "\"Beanie\""
Ok "Beanie" : Result String String
----

The figure below shows the process `decodeString` goes through while decoding values from a raw JSON string.

image:https://elmprogramming.com/images/chapter-6/6.3-decoding-json-part-1/decodeString-flow-chart.svg[]

The code we just added to the `+ReceivedDataFromJS value ->+` branch in `update` doesn’t use `decodeString`. It uses `decodeValue` instead. That’s because the data coming from JavaScript is already a _valid JSON_. An HTTP server on the other hand sends a _raw string_ which must be parsed first to make sure that it’s a valid JSON. That’s why we had to use `decodeString` in the <<decoding-json-part-1, Decoding JSON>> section. The `decodeValue` function skips the parsing altogether and focuses on transforming a valid JSON into an Elm value as shown in the figure below.

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/decodeValue-flow-chart.svg[]

Here’s how `decodeString` and `decodeValue`’s type signatures differ:

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/decodeString-vs-decodeValue.svg[]

===== Modifying the Model

We’re using a `case` expression to handle both success and failure scenarios inside the `+ReceivedDataFromJS value ->+` branch of `update`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        ReceivedDataFromJS value ->
            case decodeValue string value of
                Ok data ->
                    ( { model | dataFromJS = data }, Cmd.none )

                Err error ->
                    ( { model | errorMessage = Just error }, Cmd.none )
----

If decoding succeeds, the decoded value gets assigned to the `dataFromJS` field in our model. If it fails, we need to store the error in `jsonError` field. Let’s add those fields to `Model` in `PortExamples.elm`.

[source,elm]
----
type alias Model =
    { dataFromJS : String
    , jsonError : Maybe Error
    }
----

We also need to modify `init` to comply with the new model structure.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( initialModel, Cmd.none )


initialModel : Model
initialModel =
    { dataFromJS = ""
    , jsonError = Nothing
    }
----

===== Displaying Error Message

The only thing left is to display the error message produced by `decodeValue` if decoding fails. Replace the `view` function in `PortExamples.elm` with the following code.

[source,elm]
----
view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        , viewDataFromJSOrError model
        ]


viewDataFromJSOrError : Model -> Html Msg
viewDataFromJSOrError model =
    case model.jsonError of
        Just error ->
            viewError error

        Nothing ->
            viewDataFromJS model.dataFromJS


viewError : Error -> Html Msg
viewError jsonError =
    let
        errorHeading =
            "Couldn't receive data from JavaScript"

        errorMessage =
            case jsonError of
                Failure message _ ->
                    message

                _ ->
                    "Error: Invalid JSON"
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewDataFromJS : String -> Html msg
viewDataFromJS data =
    div []
        [ br [] []
        , strong [] [ text "Data received from JavaScript: " ]
        , text data
        ]
----

The `jsonError` field in our model is of type `+Json.Decode.Error+`. Here’s how it’s defined:

[source,elm]
----
type Error
    = Field String Error
    | Index Int Error
    | OneOf (List Error)
    | Failure String Value
----

****
NOTE: If you don’t remember how the `Error` type works, you may want to review the <<decoding-json-part-1, Decoding JSON - Part 1>> section.
****

The error message we’re interested in is inside `Failure`. That’s why we ignored all other data constructors.

===== Testing

We’re now ready to test. Recompile `PortExamples.elm` by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

Everything should compile fine. Reload the `+beginning-elm/index.html+` file in a browser and open browser console. Click the _Send Data to JavaScript_ button. Elm now shows a friendly error message on the page itself instead of crashing the app and pointing out what went wrong in the console.

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/friendly-javascript-error.png[]

Let’s fix that error by sending `+Hey Elm!+` instead of `10` from JavaScript in `index.html`.

[source,html]
----
<script>
    .
    .
    app.ports.sendData.subscribe(function(data) {
        console.log("Data from Elm: ", data);
        app.ports.receiveData.send("Hey Elm!");
    });
</script>
----

Reload `index.html` and click the _Send Data to JavaScript_ button. You should see `+Hey Elm!+`.

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/successful-data-exchange.png[]

You may be wondering why we had to go through such an elaborate process to receive a simple string from JavaScript. Actually the process for receiving more complex data from JavaScript is also very similar. The only difference is that we’ll need to write decoders that are much more sophisticated than `string`.

==== Sending Complex Data to JavaScript

The process for sending complex Elm data to JavaScript is quite similar to the one we used for sending a string in the <<sending-data-to-javascript, Sending Data to Javascript>> section. Why don’t we create some complex data in our Elm app and try to send it to JavaScript to understand this process better? Here’s how the data we want to send looks after it gets translated to JSON:

[source,json]
----
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": {
        "name": "typicode",
        "url": "https://github.com/typicode"
      }
    },
    {
      "id": 2,
      "title": "http-server",
      "author": {
        "name": "indexzero",
        "url": "https://github.com/indexzero"
      }
    }
  ],
  "comments": [
    {
      "id": 1,
      "body": "some comment",
      "postId": 1
    }
  ],
  "profile": {
    "name": "typicode"
  }
}
----

Let’s use records to represent various JSON objects shown above. Add the following code right below the `Model` type in `PortExamples.elm`.

[source,elm]
----
type alias ComplexData =
    { posts : List Post
    , comments : List Comment
    , profile : Profile
    }


type alias Post =
    { id : Int
    , title : String
    , author : Author
    }


type alias Author =
    { name : String
    , url : String
    }


type alias Comment =
    { id : Int
    , body : String
    , postId : Int
    }


type alias Profile =
    { name : String }
----

Next add a new field called `dataToJS` to `Model` in `PortExamples.elm`.

[source,elm]
----
type alias Model =
    { dataFromJS : String
    , dataToJS : ComplexData
    , jsonError : Maybe Error
    }
----

We need to update `init` to create an initial value for `dataToJS`. Replace the current implementation of `init` with the following in `PortExamples.elm`.

[source,elm]
----
init : () -> ( Model, Cmd Msg )
init _ =
    ( initialModel, Cmd.none )


initialModel : Model
initialModel =
    { dataFromJS = ""
    , dataToJS = complexData
    , jsonError = Nothing
    }


complexData : ComplexData
complexData =
    let
        post1 =
            Author "typicode" "https://github.com/typicode"
                |> Post 1 "json-server"

        post2 =
            Author "indexzero" "https://github.com/indexzero"
                |> Post 2 "http-server"
    in
    { posts = [ post1, post2 ]
    , comments = [ Comment 1 "some comment" 1 ]
    , profile = { name = "typicode" }
    }
----

Since we want to send more complex data to JavaScript, we need to change the type of `sendData` outgoing port from `String` to `ComplexData` in `PortExamples.elm`.

[source,elm]
----
port sendData : ComplexData -> Cmd msg
----

We also need to modify the `+SendDataToJS ->+` branch in `update` to use the `dataToJS` field in our model instead of `+"Hello JavaScript!"+`.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, sendData model.dataToJS )

        ReceivedDataFromJS value ->
            ...
----

We’re now ready to recompile `PortExamples.elm`. Run the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

Let’s make the console output easier to read by converting the JavaScript value sent by Elm to a raw JSON string. Replace `data` with `+JSON.stringify(data)+` in `index.html`.

[source,html]
----
<script>
    .
    .
    app.ports.sendData.subscribe(function(data) {
        console.log("Data from Elm: ", JSON.stringify(data));
        app.ports.receiveData.send("Hey Elm!");
    });
</script>
----

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/json-stringify-workflow.svg[]

Reload `index.html` and open browser console. Click _Send Data to JavaScript_ and you should see a JSON representation of the complex data sent from Elm in the console.

image:https://elmprogramming.com/images/chapter-8/8.5-protecting-boundaries/send-complex-data-to-js.png[]

The runtime translated individual Elm types contained in `complexData` to corresponding JSON types. All of that translation happened behind the scenes. We didn’t have to do anything other than hand Elm value over to the outgoing port.

==== Summary

One of the biggest advantages of using Elm is it guarantees there won’t be any type errors when an app is running. To fulfill that guarantee, Elm must reject all incorrectly typed values from entering the app. The runtime will throw an error as soon as it detects an incorrect type trying to sneak through an incoming port.

It’s not a good practice to let Elm crash our app if automatic decoding fails. We can prevent that by decoding the incoming data ourselves. This also allows us to display a friendly message to the user if decoding does fail. Here is the entire code from `PortExamples.elm` for your reference:

[source,elm]
----
port module PortExamples exposing (main)

import Browser
import Html exposing (..)
import Html.Events exposing (onClick)
import Json.Decode exposing (Error(..), Value, decodeValue, string)


type alias ComplexData =
    { posts : List Post
    , comments : List Comment
    , profile : Profile
    }


type alias Post =
    { id : Int
    , title : String
    , author : Author
    }


type alias Author =
    { name : String
    , url : String
    }


type alias Comment =
    { id : Int
    , body : String
    , postId : Int
    }


type alias Profile =
    { name : String }


type alias Model =
    { dataFromJS : String
    , dataToJS : ComplexData
    , jsonError : Maybe Error
    }


view : Model -> Html Msg
view model =
    div []
        [ button [ onClick SendDataToJS ]
            [ text "Send Data to JavaScript" ]
        , viewDataFromJSOrError model
        ]


viewDataFromJSOrError : Model -> Html Msg
viewDataFromJSOrError model =
    case model.jsonError of
        Just error ->
            viewError error

        Nothing ->
            viewDataFromJS model.dataFromJS


viewError : Error -> Html Msg
viewError jsonError =
    let
        errorHeading =
            "Couldn't receive data from JavaScript"

        errorMessage =
            case jsonError of
                Failure message _ ->
                    message

                _ ->
                    "Error: Invalid JSON"
    in
    div []
        [ h3 [] [ text errorHeading ]
        , text ("Error: " ++ errorMessage)
        ]


viewDataFromJS : String -> Html msg
viewDataFromJS data =
    div []
        [ br [] []
        , strong [] [ text "Data received from JavaScript: " ]
        , text data
        ]


type Msg
    = SendDataToJS
    | ReceivedDataFromJS Value


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        SendDataToJS ->
            ( model, sendData model.dataToJS )

        ReceivedDataFromJS value ->
            case decodeValue string value of
                Ok data ->
                    ( { model | dataFromJS = data }, Cmd.none )

                Err error ->
                    ( { model | jsonError = Just error }, Cmd.none )


subscriptions : Model -> Sub Msg
subscriptions _ =
    receiveData ReceivedDataFromJS


port sendData : ComplexData -> Cmd msg


port receiveData : (Value -> msg) -> Sub msg


init : () -> ( Model, Cmd Msg )
init _ =
    ( initialModel, Cmd.none )


initialModel : Model
initialModel =
    { dataFromJS = ""
    , dataToJS = complexData
    , jsonError = Nothing
    }


complexData : ComplexData
complexData =
    let
        post1 =
            Author "typicode" "https://github.com/typicode"
                |> Post 1 "json-server"

        post2 =
            Author "indexzero" "https://github.com/indexzero"
                |> Post 2 "http-server"
    in
    { posts = [ post1, post2 ]
    , comments = [ Comment 1 "some comment" 1 ]
    , profile = { name = "typicode" }
    }


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
----


[[saving-app-state]]
=== 8.6 Saving App State in Local Storage


In <<single-page-apps-intro, chapter 7>>, we built a single-page app for creating, reading, updating, and deleting posts from an HTTP server. What happens to the app when the server is unreachable? Let’s find out. Run the following commands from the `+beginning-elm+` directory in separate terminal windows to launch the app.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
$ elm-live post-app/Main.elm --pushstate
----

Now go to http://localhost:8000/[`+http://localhost:8000+`] in a browser and you should see two posts.

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/post-app.png[]

Stop `+json-server+` by pressing `+Ctrl + c+` and reload the page at http://localhost:8000/[`+http://localhost:8000+`]. You should now see an error.

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/server-unreachable.png[]

It would be great if we could display posts from the previous fetch as soon as our app loads even if the server is unreachable. As it turns out, all client-side web apps can in fact store data locally in a browser through the use of a technology called _Web Storage_ which provides two different ways for saving data:

* *Session Storage* - Data stored in session storage is available until the browser is closed.
* *Local Storage* - Data stored in local storage is available even if the browser is closed and reopened.

Let’s store the state of our app in local storage. Unfortunately, Elm doesn’t provide a package for directly accessing local storage. We’ll have to go through JavaScript.

****
NOTE: The Elm development team is working hard to expand support for all technologies included in the https://platform.html5.org/[Web Platform]. Local storage is one of them. In the meantime, the recommended approach is to use JavaScript APIs through ports.
****

==== Creating an Outgoing Port

Let’s start by defining an outgoing port for sending the app state to JavaScript. Create a new file called `Ports.elm` in the `+beginning-elm/post-app+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/create-ports-file.png[]

[source,elm]
----
port module Ports exposing (storePosts)


port storePosts : String -> Cmd msg
----

Our plan is to transform all `Post` records in our app to a JSON string and then store that string in local storage. That’s why the `storePosts` port takes a string as an input instead of a list of posts like this:

[source,elm]
----
port storePosts : List Post -> Cmd msg
----

In the <<model-view-update-part-1, Model View Update - Part 1>> section, we learned that the state of an app is typically represented by a model. So why are we storing only posts and not everything inside our main and page models? That’s because we just need to store enough data to bring the app back to a usable state. In our case, all we need is a list of posts.

Next we’ll write a function for transforming posts to a JSON string. Add the following code to the bottom of `Post.elm`.

[source,elm]
----
savePosts : List Post -> Cmd msg
savePosts posts =
    Encode.list postEncoder posts
        |> Encode.encode 0
        |> Ports.storePosts
----

`savePosts` not only transforms posts into JSON, but also calls the `storePosts` port function. So to send posts through that port all we have to do is call `savePosts`.

The `Encode.list` decoder converts an <<list, Elm list>> into a <<protecting-boundaries, JSON array>>. Here’s what its type signature looks like:

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/list-encoder-type-signature.svg[]

The `Encode.encode` function converts a `Value` into an actual JSON string. Here’s what its type signature looks like:

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/encode-type-signature.svg[]

All encoders we’ve used so far produce a `Value`. They don’t actually create a JSON string. That’s the job for `encode`.

[source,elm]
----
-- Transform an Elm string into a JSON string value
string : String -> Value

-- Transform an Elm int into a JSON number value
int : Int -> Value

-- Transform an Elm list into a JSON array value
list : (a -> Value) -> List a -> Value

-- Convert a Value to an actual JSON string
encode : Int -> Value -> String
----

We didn’t have to use `encode` when <<editing-a-post, editing>> and <<creating-a-new-post, creating a post>> in chapter 7 because the `Http.request` and `Http.post` functions converted an encoded `Value` to a JSON string for us behind the scenes. Here we have to do that conversion ourselves because ports don’t do it. Let’s expose `savePosts` and import the `Ports` module in `Post.elm`.

[source,elm]
----
module Post exposing
    .
    .
    , savePosts
    )

import Ports
.
.
----

==== Sending Posts to JavaScript

Where in our app would be a good place to initiate the process of saving posts in local storage? Since we always end up fetching all posts from the `ListPosts` page after creating a new post or editing an existing one, the `+PostsReceived response ->+` branch inside `ListPosts.elm`’s `update` function is a good place to call the `savePosts` function from.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        PostsReceived response ->
            ( { model | posts = response }
            , savePosts response
            )
        .
        .
----

Unfortunately that’s not going to work because `response` is of type `+WebData (List Post)+`. We need to pull posts out of `WebData`. Luckily, the `RemoteData` module provides a function called `withDefault` that does exactly what we need here. Here’s what its type signature looks like:

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/withDefault-type-signature.svg[]

Change the `+PostsReceived response ->+` branch in `update` to the following.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        PostsReceived response ->
            let
                actualPosts =
                    RemoteData.withDefault [] response
            in
            ( { model | posts = response }
            , savePosts actualPosts
            )
        .
        .
----

Although this implementation works, it introduces a subtle bug: An empty list is saved in local storage even if we failed to fetch posts from the server. We don’t want that. `savePosts` shouldn’t be called at all if we don’t have actual posts. Let’s use the following implementation instead.

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        .
        .
        PostsReceived response ->
            let
                savePostsCmd =
                    case response of
                        RemoteData.Success actualPosts ->
                            savePosts actualPosts

                        _ ->
                            Cmd.none
            in
            ( { model | posts = response }, savePostsCmd )
        .
        .
----

Now expose `savePosts` when importing the `Post` module in `ListPosts.elm`.

[source,elm]
----
import Post exposing (Post, PostId, postsDecoder, savePosts)
----

==== Storing Posts in Local Storage

That’s all we need to do on the Elm side. Check the `+elm-live+` window in terminal to make sure there are no errors. Now let’s turn our attention to JavaScript. Replace the contents of `+beginning-elm/index.html+` with the following.

[source,html]
----
<!DOCTYPE html>
<html>
<body>        
    <script src="elm.js"></script>
    <script>
      var app = Elm.Main.init();
    </script>
</body>
</html>
----

For comparison, here is the `index.html` file we used to <<sending-data-to-javascript, send data to JavaScript>> from a non-single-page Elm app:

[source,html]
----
<!DOCTYPE html>
<html>
<body>
    <div id="elm-code-is-loaded-here"></div>
        
    <script src="elm.js"></script>
    <script>
      var app = Elm.PortExamples.init({
        node: document.getElementById("elm-code-is-loaded-here")
      });
      .
      .
    </script>
</body>
</html>
----

Did you notice the difference? We had to embed our Elm app inside a `div` in the latter case. We don’t have to do that in a single-page app because it takes over the entire HTML document. Simply loading `elm.js` is enough.

Next we need to put the compiled code in `elm.js`. Stop `+elm-live+` by pressing `+Ctrl + c+` and restart it by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ elm-live post-app/Main.elm --pushstate -- --output=elm.js
----

In the previous sections of this chapter we used `+elm make+` to produce `elm.js` like this:

[source,bash]
----
$ elm make src/PortExamples.elm --output elm.js
----

Why can’t we use `+elm make+` here too? That’s because `+post-app+` is a single-page app and we need the `pushstate` feature from `+elm-live+` to be able to navigate between pages. That being said, `+elm-live+` actually calls `+elm make+` behind the scenes to compile our code.

It’s important to note that `+elm-live+` requires us to put all `+elm make+` specific flags after the `--` separator. If we don’t use the `+--output+` flag, `+elm make+` will automatically create a file called `index.html` in the directory from where it’s run and put the compiled code in that file instead. We don’t want that.

===== Listening to the storePosts Port

Now it’s time to subscribe to the `storePosts` port by adding the following code to the bottom of the `+<script>+` tag in `index.html`.

[source,html]
----
<script>
    .
    .
    app.ports.storePosts.subscribe(function(posts) {
        console.log("Posts: ", JSON.stringify(posts));
    });
</script>
----

We need to make sure the posts sent by our Elm app actually made it to the JavaScript side before we save them in local storage. That’s why we’re printing them in console first. Make sure both `+elm-live+` and `+json-server+` are running. Then go to http://localhost:8000[`+http://localhost:8000+`] and open the browser console. You should see the posts in raw JSON string format.

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/show-posts-in-console.png[]

Now update the callback function in `index.html` to actually save the posts in local storage.

[source,html]
----
<script>
    .
    .
    app.ports.storePosts.subscribe(function(posts) {
        if (posts.length > 0) {
            var postsJson = JSON.stringify(posts);
            localStorage.setItem('post-app-save', postsJson);
            console.log("Saved state: ", postsJson);
        }
    });
</script>
----

We’re using the `setItem` function in https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage[`localStorage`] to save the posts. `setItem` takes a key value pair. `+post-app-save+` is the key and the raw JSON string produced by `JSON.stringify` is the value.

If you are using Chrome, you can check whether or not the data was indeed saved in local storage by opening the developer tools and going to the _Application_ tab as shown in the figure below.

image:https://elmprogramming.com/images/chapter-8/8.6-saving-app-state/verify-local-storage.png[]

==== Summary

In this section, we learned how to save the state of our Elm app in browser’s local storage. Since Elm doesn’t provide a package for that, we had to send the app state through an outgoing port and use JavaScript API on the other end to actually save it. In the next section, we’ll learn how to restore the state when our app is being initialized.


[[retrieving-app-state]]
=== 8.7 Retrieving App State from Local Storage


In this section, we’ll retrieve the app state saved in browser’s local storage and initialize our Elm app with it.

==== Retrieving App State

Let’s start with JavaScript this time. Add the code for retrieving posts right above the line that creates the `app` variable in `+beginning-elm/index.html+`.

[source,html]
----
<script>
    var storedState = localStorage.getItem('post-app-save');
    console.log("Retrieved state: ", storedState);
    var startingState = storedState ? JSON.parse(storedState) : null;

    var app = Elm.Main.init();
    .
    .
</script>
----

The `localStorage.getItem` function retrieves our app’s state which is stored in raw JSON string format. `+post-app-save+` is the same key we used for <<saving-app-state, saving the state>>.

After retrieving the sate, we want to print it in the browser console so that we can see what it looks like. If the state does exist, the raw JSON string is parsed into JavaScript values using the `JSON.parse` function.

==== Sending App State to Elm via Flags

Next we need to pass `startingState` to our Elm app during initialization. How do we do that? By using _flags_. Update the line that initializes our Elm app in `+beginning-elm/index.html+` like this:

[source,html]
----
<script>
    .
    .
    var app = Elm.Main.init({flags: startingState});
    .
    .
</script>
----

Flags are different from an <<receiving-data-from-javascript, incoming port>> which creates a <<subscriptions, subscription>>. Flags on the other hand are delivered directly to the initialization function assigned to the `init` field in `main`.

[source,elm]
----
main : Program () Model Msg
main =
    Browser.application
        { init = init
        .
        .
----

Just like an incoming port, the JavaScript values passed as flags are automatically decoded by the runtime into corresponding Elm values. Let’s change the type of `flags` in `+post-app/Main.elm+` from `+()+` to `+Maybe String+`.

[source,elm]
----
init : Maybe String -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    ...
----

Flags are always passed as the first argument to the `init` function. Their type varies between applications. In our case, it’s `+Maybe String+`. It is possible that the app state might not have been saved in local storage. In that case, JavaScript will send `null`. To accommodate that, we need to use the `Maybe` type. Remember, `null` in JavaScript gets translated to `Nothing` in Elm.

[source,html]
----
<script>
    .
    .
    var startingState = storedState ? JSON.parse(storedState) : null;
    .
    .
</script>
----

We also need to replace `+()+` with `+Maybe String+` in the `main` function’s type annotation.

[source,elm]
----
main : Program (Maybe String) Model Msg
main =
    ...
----

As discussed in the <<model-view-update-part-1, main Function’s Type Annotation>> section from chapter 5, by using `+()+` — unit type — we were letting the compiler know that no values were passed to our app during initialization. But since we are actually sending `flags` from JavaScript now we need to reflect that in `main`’s type annotation.

==== Decoding Stored Posts JSON

Now we need to decode the JSON string into a list of `Post`. Let’s add a function called `decodeStoredPosts` below `init` in `Main.elm`.

[source,elm]
----
decodeStoredPosts : String -> WebData (List Post)
decodeStoredPosts postsJson =
    case decodeString postsDecoder postsJson of
        Ok posts ->
            RemoteData.succeed posts

        Err _ ->
            RemoteData.Loading
----

We’re using `postsDecoder` from `Post.elm` to decode JSON. `decodeString` produces a `Result`. If the process of decoding is successful we need to wrap `posts` in `WebData` type by calling the `RemoteData.succeed` function. Otherwise, we simply return the loading status. Later in `ListPosts.elm`, we’ll be fetching new posts right away if stored posts aren’t available and we need to display the `+Loading...+` text while the request is in flight.

****
NOTE: If you don’t remember how `decodeString` works, you may want to review the <<decoding-json-part-1, Decoding JSON>> section from chapter 6.
****

We need to import the `Json.Decode`, `Post`, and `RemoteData` modules in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Json.Decode as Decode exposing (decodeString)
import Post exposing (Post, postsDecoder)
import RemoteData exposing (WebData)
.
.
----

Now let’s use `decodeStoredPosts` in `Main.init`.

[source,elm]
----
init : Maybe String -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    let
        model =
            ...

        posts =
            case flags of
                Just postsJson ->
                    decodeStoredPosts postsJson

                Nothing ->
                    RemoteData.Loading
    in
    initCurrentPage posts ( model, Cmd.none )
----

==== Passing Stored Posts to ListPosts Page

Next we need to pass the stored `posts` to `ListPosts.init` inside `initCurrentPage` in `Main.elm`.

[source,elm]
----
initCurrentPage :
    WebData (List Post)
    -> ( Model, Cmd Msg )
    -> ( Model, Cmd Msg )
initCurrentPage posts ( model, existingCmds ) =
    let
        ( currentPage, mappedPageCmds ) =
            case model.route of
                .
                .
                Route.Posts ->
                    let
                        ( pageModel, pageCmds ) =
                            ListPosts.init posts
                    in
                    ( ListPage pageModel, Cmd.map ListPageMsg pageCmds )
                .
                .
    in
    ...
----

Currently `ListPosts.init` doesn’t take `posts` as an input. Let’s modify it in `ListPosts.elm`.

[source,elm]
----
init : WebData (List Post) -> ( Model, Cmd Msg )
init posts =
    ( initialModel posts, fetchPosts )


initialModel : WebData (List Post) -> Model
initialModel posts =
    { posts = posts
    , deleteError = Nothing
    }
----

Next we need to pass `RemoteData.Loading` as stored posts to `initCurrentPage` inside the `+( UrlChanged url, _ ) ->+` branch in `Main.update`

[source,elm]
----
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case ( msg, model.page ) of
        .
        .
        ( UrlChanged url, _ ) ->
            let
                ...
            in
            ( { model | route = newRoute }, Cmd.none )
                |> initCurrentPage RemoteData.Loading
        .
        .
----

==== Testing

We are now ready to test. Run the following command from the `+beginning-elm+` directory in terminal to compile the app.

[source,bash]
----
$ elm-live post-app/Main.elm --pushstate -- --output=elm.js
----

You shouldn’t see any errors. Also start `+json-server+` by running the following command from the `+beginning-elm+` directory in a separate terminal window.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
----

Now go to http://localhost:8000/[`+http://localhost:8000/+`] in a browser and open the browser console. You should see the retrieved state printed as JSON in the console.

image:https://elmprogramming.com/images/chapter-8/8.7-retrieving-app-state/retrieved-state-json-in-console.png[]

How do we verify that our app did get initialized with the stored state? Let’s stop `+json-server+` by pressing `+Ctrl + c+` and see how the app behaves when the server is unreachable. Refresh the page at http://localhost:8000/[`+http://localhost:8000/+`].

image:https://elmprogramming.com/images/chapter-8/8.7-retrieving-app-state/server-unreachable.png[]

Unfortunately, we see an error instead of the posts retrieved from local storage. How about we don’t fetch the posts from a server when the app is initialized? That way if we see a list of posts when the app is launched and the server is not running, we’ll definitely know that those posts are from local storage. Update the `init` function in `ListPosts.elm` like so:

[source,elm]
----
init : WebData (List Post) -> ( Model, Cmd Msg )
init posts =
    let
        initialCmd =
            if RemoteData.isSuccess posts then
                Cmd.none

            else
                fetchPosts
    in
    ( initialModel posts, initialCmd )
----

Now if you refresh the page at http://localhost:8000/[`+http://localhost:8000/+`], you should see the posts. Those are definitely loaded from local storage.

image:https://elmprogramming.com/images/chapter-8/8.7-retrieving-app-state/posts-loaded-from-local-storage.png[]

Bring `+json-sever+` back up by running the following command from the `+beginning-elm+` directory in terminal.

[source,bash]
----
$ json-server --watch server/db.json -p 5019
----

Click the _Refresh posts_ button from the home page. If you open the browser console, you should see both the saved and retrieved states. Whenever we retrieve posts from the server, they immediately get saved in local storage.

image:https://elmprogramming.com/images/chapter-8/8.7-retrieving-app-state/saved-and-retrieved-states-in-console.png[]

==== Verifying Flags

Let’s see what happens if we try to pass a non-string value to Elm using flags. Inside `+beginner-elm/index.html+`, replace `startingState` with `10` in line that initializes our Elm app.

[source,html]
----
<script>
    .
    .
    var app = Elm.Main.init({flags: 10});
    .
    .
</script>
----

Now refresh the page at http://localhost:8000/[`+http://localhost:8000/+`]. You should see the following error in browser console.

image:https://elmprogramming.com/images/chapter-8/8.7-retrieving-app-state/invalid-flag-type-error.png[]

Our `Main.init` function is expecting flags to be of type `+Maybe String+`, but we sent a number instead. Flags must be exactly what the `init` function expects, otherwise Elm throws an error on JavaScript side. Without this check, we could pass anything leading to runtime errors in Elm.

It’d be better to show a user friendly error message instead of crashing our app like this. To do that, we need to convert the JavaScript values to Elm values ourselves by changing the flags’ type from `+Maybe String+` to `Value` in `Main.init`.

[source,elm]
----
init : Value -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    ...
----

We also need to change `+Maybe String+` to `Value` in the `main` function’s type annotation.

[source,elm]
----
main : Program Value Model Msg
main =
    ...
----

As mentioned in <<protecting-boundaries, Protecting Boundaries between Elm and JavaScript>>, the `Value` type represents a JSON value. To decode a JSON value ourselves, we need to use the <<protecting-boundaries, `decodeValue`>> function. Replace the logic for computing `posts` in `let` area of `Main.init` with the following.

[source,elm]
----
init : Value -> Url -> Nav.Key -> ( Model, Cmd Msg )
init flags url navKey =
    let
        .
        .
        posts =
            case decodeValue Decode.string flags of
                Ok postsJson ->
                    decodeStoredPosts postsJson

                Err _ ->
                    Http.BadBody "Flags must be either string or null"
                        |> RemoteData.Failure
    in
    ...
----

If a flag of invalid type is sent from JavaScript, we need to create an error. The `WebData` type’s definition indicates that `RemoteData.Failure` requires the error to be of type `Http.Error`. That’s why we’re using the `Http.BadBody` data constructor to build an error.

[source,elm]
----
type alias WebData a =
    RemoteData Http.Error a


type RemoteData e a
    = NotAsked
    | Loading
    | Failure e
    | Success a
----

Let’s import the `Http` module and expose `Value` and `decodeValue` from `Json.Decode` in `Main.elm`.

[source,elm]
----
module Main exposing (main)

import Json.Decode as Decode exposing (Value, decodeString, decodeValue)
import Http
.
.
----

Stop `+json-server+` and refresh the page at http://localhost:8000/[`+http://localhost:8000/+`] and you shouldn’t see the decoding error in console anymore. Unfortunately, the error we see on the page says `+Unable to reach server+` instead of `+Flags must be either string or null+`. That’s because in `ListPosts.init` we’re firing the command for fetching posts unless the `posts` parameter is `RemoteData.Success`.

[source,elm]
----
init : WebData (List Post) -> ( Model, Cmd Msg )
init posts =
    let
        initialCmd =
            if RemoteData.isSuccess posts then
                Cmd.none

            else
                fetchPosts
    in
    ( initialModel posts, initialCmd )
----

Let’s also not fire the `fetchPosts` command when the `posts` parameter is `RemoteData.Failure` by updating the `if` expression to the following.

[source,elm]
----
init : WebData (List Post) -> ( Model, Cmd Msg )
init posts =
    let
        initialCmd =
            if RemoteData.isSuccess posts || RemoteData.isFailure posts then
                Cmd.none

            else
                fetchPosts
    in
    ( initialModel posts, initialCmd )
----

Refresh the page at http://localhost:8000/[`+http://localhost:8000/+`] one more time and you should see the `+Flags must be either string or null+` error.

image:https://elmprogramming.com/images/chapter-8/8.7-retrieving-app-state/flags-must-be-string.png[]

==== Summary

In this section, we learned how to retrieve the state of our app stored in browser’s local storage. We used the JavaScript function `+localStorage.getItem()+` to retrieve the state and sent it to our Elm app via flags. Elm runtime automatically decodes JavaScript values inside flags into corresponding Elm values before passing them to the `init` function. A more robust approach is to receive flags as `Value` and decode it ourselves.


[[interacting-with-web-components]]
=== 8.8 Interacting with Web Components


So far in this chapter, we have communicated with JavaScript using http://localhost:4000/sending-data-to-javascript.html[ports] and <<retrieving-app-state, flags>>. There is one other way: Web Components.

Web Components::
  Web Components are a set of APIs provided by the https://platform.html5.org/[Web Platform] for building reusable custom elements which contain all the necessary HTML, CSS, and JavaScript code. These custom elements can be used inside any framework — including Elm — that works with HTML and JavaScript. You can browse various custom elements on https://www.webcomponents.org/[webcomponents.org].

In this section, we’ll learn how to interact with custom elements from Elm by building an app that allows us to crop images. Here’s how the final app will look:

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/image-crop-app.png[]

https://unsplash.com/photos/zNN6ubHmruI[Photo by Robert Lukeman on Unsplash]

==== Installing Custom Elements

We can install custom elements from https://www.webcomponents.org/[webcomponents.org] by using `npm`. Before we do that though, we need to create a file called `package.json` in the `+beginning-elm+` directory.

In the <<building-a-simple-page-in-elm, Building a Simple Page with Elm>> section from chapter 2, we learned that the `elm.json` file is used to keep track of which Elm packages our project depends on. Similarly, `package.json` keeps track of all `npm` packages used in our project. We can create `package.json` by running the following command from `+beginning-elm+` directory in terminal.

[source,bash]
----
$ npm init -y
----

****
NOTE: The `+-y+` or `+--yes+` flag creates and _initializes_ a `package.json` file using information extracted from the current directory.
****

Now run the following command from `+beginning-elm+` directory in terminal to install the https://www.webcomponents.org/element/@github/image-crop-element[`+image-crop-element+`] custom element.

[source,bash]
----
$ npm install @github/image-crop-element
----

Once the installation is complete, open `package.json` from the `+beginning-elm+` directory and you should see `+image-crop-element+` listed under `dependencies`.

[source,json]
----
{
    .
    .
    "dependencies": {
        "@github/image-crop-element": "^2.0.0"
    }
}
----

You should also see a new directory called `node_modules` inside `+beginning-elm+`. That directory contains all the code necessary for the `+image-crop-element+` custom element to work.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/node_modules-folder.png[]

===== Installing NPM Packages Locally

This is the first time we ran the `+npm install+` command without the `+-g+` option. In earlier chapters, we installed various tools such as <<installation, `+elm-format+`>> and <<easy-to-test, `+elm-test+`>> using the `+-g+` option like this:

[source,bash]
----
$ npm install elm-format -g
$ npm install elm-test -g
----

The `+-g+` option installs packages globally so that we can use them from anywhere in the terminal. `+image-crop-element+` is meant to be used only inside our project. That’s why we didn’t use `+-g+`. When a package is installed without the `+-g+` option, `npm` assumes that it’s a local package and automatically adds it as a dependency to the `package.json` file. If you want to be explicit, you can use the `+--save+` option like this:

[source,bash]
----
$ npm install @github/image-crop-element --save
----

==== Importing Custom Elements

We can load custom elements in our app by using the `+<link>+` tag from the `+beginning-elm/index.html+` file. Replace the contents of that file with the following.

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <script
      type="module" 
      src="node_modules/@github/image-crop-element/dist/index.esm.js">
    </script>

    <link
      href="node_modules/@github/image-crop-element/index.css" 
      rel="stylesheet">

    <style>
      .wrapper {
        width: 500px;
        margin: 30px auto;
      }

      .center {
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div id="elm-app-is-loaded-here"></div>
    <script src="elm.js"></script>

    <script>
      var app = Elm.CustomElements.init({
        node: document.getElementById("elm-app-is-loaded-here")
      });
    </script>
  </body>
</html>
----

The first line inside `+<head>+` loads the JavaScript code necessary for running the https://www.webcomponents.org/element/@github/image-crop-element[`+image-crop-element+`] custom element.

[source,html]
----
<script
  type="module" 
  src="node_modules/@github/image-crop-element/dist/index.esm.js">
</script>
----

After that we need to load the CSS styles for `+image-crop-element+`.

[source,html]
----
<link
  href="node_modules/@github/image-crop-element/index.css" 
  rel="stylesheet">
----

We also need to define a couple of CSS classes that will be used later to make our UI look better.

[source,html]
----
<style>
  .wrapper {
    width: 500px;
    margin: 30px auto;
  }
  
  .center {
    text-align: center;
  }
</style>
----

==== Defining Model

Now that the custom element has been loaded, we’re ready to write the Elm code for interacting with that element. Create a new file called `CustomElements.elm` in the `+beginning-elm/src+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/create-custom-elements-elm-file.png[]

[source,elm]
----
module CustomElements exposing (CropData)

import Browser
import Html exposing (Attribute, Html, div, h2, strong, text)
import Html.Attributes exposing (class, src)
import Html.Events exposing (on)
import Json.Decode as Decode exposing (Decoder, int)
import Json.Decode.Pipeline exposing (requiredAt)


type alias CropData =
    { x : Int
    , y : Int
    , width : Int
    , height : Int
    }
----

We imported a bunch of modules needed by our app. We then defined a model which specifies the width and height of the crop area along with where it starts.

==== Defining Custom Element Nodes

What’s great about custom elements is that someone else writes the necessary code and all we have to do to take advantage of their hard work is include the tag, such as `+image-crop+`, in our app. Just like that our app acquires all the super powers possessed by those custom elements.

In Elm, a tag is nothing but a simple wrapper to the `+Elm.Kernel.VirtualDom.node+` function. If you peruse the `Html` module’s https://github.com/elm/html/blob/1.0.0/src/Html.elm[source code], you’ll notice that all of the functions we have used so far from that module do nothing more than apply the `node` function. For example, here is what the `button` and `input` functions’ implementations look like:

[source,elm]
----
button : List (Attribute msg) -> List (Html msg) -> Html msg
button =
    Elm.Kernel.VirtualDom.node "button"


input : List (Attribute msg) -> List (Html msg) -> Html msg
input =
    Elm.Kernel.VirtualDom.node "input"
----

To use custom elements inside an Elm app we need to convert them to virtual DOM nodes, but we aren’t allowed to use the `+Elm.Kernel.VirtualDom.node+` function directly for reasons mentioned in the <<virtual-dom, Elm Kernel>> section. We need to use the `Html.node` function instead. Add the following code to the bottom of `CustomElements.elm`.

[source,elm]
----
imageCrop : List (Attribute a) -> List (Html a) -> Html a
imageCrop =
    Html.node "image-crop"
----

==== Defining View

Let’s create our app’s view by using the `imageCrop` node we just defined. Add the following code to the bottom of `CustomElements.elm`.

[source,elm]
----
view : CropData -> Html Msg
view cropData =
    div [ class "center" ]
        [ h2 [] [ text "Image Crop" ]
        , imageCrop
            [ src "/assets/images/waterfall.jpg"
            , class "wrapper"
            ]
            []
        ]
----

The `view` function displays a header, an image, and a crop area. The `imageCrop` node represents both the original image that needs to be cropped and the crop area. Just like the https://package.elm-lang.org/packages/elm/html/latest/Html#img[`Html.img`] tag, `imageCrop` uses the `src` attribute to load the original image.

Create a new directory called `assets` inside `+beginning-elm+` and create another directory called `images` inside `assets`. After that download the `waterfall.jpg` image from https://github.com/pawanpoudel/beginning-elm-code/blob/master/chapter-8/8.8-interacting-with-web-components/beginning-elm/assets/images/waterfall.jpg[this repo] and put it inside `images`.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/waterfall-image-location.png[]

==== Creating the Asset Module

It’s not a good practice to directly expose the location of an image as we did in the `view` function above. A better approach is to hide the location inside a module called `Asset`. Let’s create that module inside the `+beginning-elm/src+` directory and add the code below to it.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/create-asset-module.png[]

[source,elm]
----
module Asset exposing (Image, src, waterfall)

import Html exposing (Attribute)
import Html.Attributes as Attr


type Image
    = Image String



-- IMAGES


waterfall : Image
waterfall =
    image "waterfall.jpg"


image : String -> Image
image filename =
    Image ("/assets/images/" ++ filename)



-- USING IMAGES


src : Image -> Attribute msg
src (Image url) =
    Attr.src url
----

Next, we need to replace the image location in `CustomElements.elm` with `Asset.waterfall`.

[source,elm]
----
view : CropData -> Html Msg
view cropData =
        .
        .
        , imageCrop
            [ Asset.src Asset.waterfall
            , class "wrapper"
            ]
            []
        ]
----

We also need to import the `Asset` module in `CustomElements.elm`.

[source,elm]
----
module CustomElements exposing (CropData)

import Asset
.
.
----

==== Update

There are no messages flowing through our app yet, so the `update` function will look very simple. Add the following code to the bottom of `CustomElements.elm`.

[source,elm]
----
type Msg
    = NoOp


update : Msg -> CropData -> ( CropData, Cmd Msg )
update msg cropData =
    case msg of
        NoOp ->
            ( cropData, Cmd.none )
----

`NoOp` means “no operation.” It’s just a placeholder message for now. We’ll replace it with a real one later.

==== Initial Model

Next, we need to create an initial model. Add the following code to the bottom of `CustomElements.elm`.

[source,elm]
----
initialModel : CropData
initialModel =
    { x = 297
    , y = 0
    , width = 906
    , height = 906
    }


init : () -> ( CropData, Cmd Msg )
init flags =
    ( initialModel, Cmd.none )
----

==== Wiring Everything Up

We’re ready to wire everything up by adding `main` to the bottom of `CustomElements.elm`.

[source,elm]
----
main : Program () CropData Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----

With that, we’re ready to test. Run `+elm-live+` from the `+beginning-elm+` directory in terminal using the following command.

[source,bash]
----
$ elm-live src/CustomElements.elm -- --output=elm.js
----

Go to http://localhost:8000/[`+http://localhost:8000+`] in a browser and you should see the following view.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/image-crop-without-crop-data.png[]

==== Handling Events Generated by Custom Elements

We can ask a custom element to notify us when something interesting happens by handling one of the published events. For example `+image-crop-element+` generates an event called `+image-crop-change+` whenever the crop area is moved. Let’s handle that event to understand how an Elm app receives event notifications from a custom element.

`+image-crop-change+` is a custom event, so the `Html.Events` module doesn’t know anything about it. In the previous chapters, we used functions such as `onClick` and `onInput` — defined in `Html.Events` — to handle events generated by the `button` and `input` elements respectively.

Although `Html.Events` doesn’t know about `+image-crop-change+`, it lets us handle that event through the use of `on` function which has the following type.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/on-function-type.svg[]

Add the following code above the `view` function in `CustomElements.elm`.

[source,elm]
----
onImageCropChange : Attribute Msg
onImageCropChange =
    cropDataDecoder
        |> Decode.map UpdateCropData
        |> on "image-crop-change"
----

`onImageCropChange` uses the `on` function to create a custom event handler. The first argument is the name of the event: `+image-crop-change+`. The second argument is a JSON decoder. Whenever the crop area is dragged around, `+image-crop-element+` sends an event object to the Elm app. The structure of the event object looks something like this:

[source,json]
----
{
    .
    .
    "detail" : {
        "x" : 297,
        "y" : 0,
        "width" : 906,
        "height" : 906
    }
}
----

The code for decoding crop data out of the event object is quite simple. Add the following code below `onImageCropChange` in `CustomElements.elm`.

[source,elm]
----
cropDataDecoder : Decoder CropData
cropDataDecoder =
    Decode.succeed CropData
        |> requiredAt [ "detail", "x" ] int
        |> requiredAt [ "detail", "y" ] int
        |> requiredAt [ "detail", "width" ] int
        |> requiredAt [ "detail", "height" ] int
----

We used the `requiredAt` function from the `+Json.Decode.Pipeline+` module to pull the crop data out of a <<decoding-json-part-2, nested JSON object>>. The code in `onImageCropChange`, however, looks a bit strange.

[source,elm]
----
onImageCropChange : Attribute Msg
onImageCropChange =
    cropDataDecoder
        |> Decode.map UpdateCropData
        |> on "image-crop-change"
----

Why are we using the `+Json.Decode.map+` function instead of passing `cropDataDecoder` directly to the `on` function like this:

[source,elm]
----
on "image-crop-change" cropDataDecoder
----

The answer lies in the `on` function’s type signature.

[source,elm]
----
on : String -> Decoder msg -> Attribute msg
----

Our decoder returns the `CropData` type, but the `on` function expects a decoder that returns a message. We need a function that can convert `CropData` to a message type. `+Json.Decode.map+` is that function. Here’s how its type signature looks:

[source,elm]
----
map : (a -> value) -> Decoder a -> Decoder value
----

`+Json.Decode.map+` translates the `CropData` type into `UpdateCropData` which is a message we need to define. Replace `NoOp` with `UpdateCropData` in the `Msg` type.

[source,elm]
----
type Msg
    = UpdateCropData CropData
----

Now do the same in the `update` function.

[source,elm]
----
update : Msg -> CropData -> ( CropData, Cmd Msg )
update msg oldCropData =
    case msg of
        UpdateCropData newCropData ->
            ( newCropData, Cmd.none )
----

Next we need to add the `onImageCropChange` custom event handler to the `imageCrop` node in `view`.

[source,elm]
----
view : CropData -> Html Msg
view cropData =
        .
        .
        , imageCrop
            [ Asset.src Asset.waterfall
            , class "wrapper"
            , onImageCropChange
            ]
            []
        ]
----

The only thing remaining is to display crop data when the crop area is dragged. Add the following code below the `view` function in `CustomElements.elm`.

[source,elm]
----
viewCropData : CropData -> Html Msg
viewCropData cropData =
    div []
        [ viewCropDataLabel "x" cropData.x
        , viewCropDataLabel "y" cropData.y
        , viewCropDataLabel "width" cropData.width
        , viewCropDataLabel "height" cropData.height
        ]


viewCropDataLabel : String -> Int -> Html Msg
viewCropDataLabel name value =
    div []
        [ strong [] [ text (name ++ " : ") ]
        , text (String.fromInt value)
        ]
----

And render `viewCropData` below the `imageCrop` node in `view`.

[source,elm]
----
view : CropData -> Html Msg
view cropData =
        .
        .
        , imageCrop
            [ Asset.src Asset.waterfall
            , class "wrapper"
            , onImageCropChange
            ]
            []
        , viewCropData cropData
        ]
----

Check the `+elm-live+` window in terminal to make sure there are no errors and go back to the page at http://localhost:8000/[`+http://localhost:8000+`]. The data displayed at the bottom of the page should change when you drag the crop area around.

image:https://elmprogramming.com/images/chapter-8/8.8-web-components/changing-crop-data.png[]

==== Summary

In this section, we discovered yet another way of interacting with JavaScript from an Elm app. Custom elements are reusable widgets built using the Web Components specification. They contain the necessary HTML, CSS, and JavaScript code. All we have to do is include the tag in our app. We can also listen to the events generated by a custom element using the `+Html.Events.on+` function.

Unfortunately, Elm can’t guarantee that the custom elements won’t cause runtime errors because they are written in JavaScript which doesn’t have a robust type system like Elm’s. So use them only if you don’t have a safer alternative. Here is the entire code from `CustomElements.elm` for your reference:

[source,elm]
----
module CustomElements exposing (main)

import Asset
import Browser
import Html exposing (Attribute, Html, div, h2, strong, text)
import Html.Attributes exposing (class, src)
import Html.Events exposing (on)
import Json.Decode as Decode exposing (Decoder, int)
import Json.Decode.Pipeline exposing (requiredAt)


type alias CropData =
    { x : Int
    , y : Int
    , width : Int
    , height : Int
    }


imageCrop : List (Attribute a) -> List (Html a) -> Html a
imageCrop =
    Html.node "image-crop"


onImageCropChange : Attribute Msg
onImageCropChange =
    cropDataDecoder
        |> Decode.map UpdateCropData
        |> on "image-crop-change"


cropDataDecoder : Decoder CropData
cropDataDecoder =
    Decode.succeed CropData
        |> requiredAt [ "detail", "x" ] int
        |> requiredAt [ "detail", "y" ] int
        |> requiredAt [ "detail", "width" ] int
        |> requiredAt [ "detail", "height" ] int


view : CropData -> Html Msg
view cropData =
    div [ class "center" ]
        [ h2 [] [ text "Image Crop" ]
        , imageCrop
            [ Asset.src Asset.waterfall
            , class "wrapper"
            , onImageCropChange
            ]
            []
        , viewCropData cropData
        ]


viewCropData : CropData -> Html Msg
viewCropData cropData =
    div []
        [ viewCropDataLabel "x" cropData.x
        , viewCropDataLabel "y" cropData.y
        , viewCropDataLabel "width" cropData.width
        , viewCropDataLabel "height" cropData.height
        ]


viewCropDataLabel : String -> Int -> Html Msg
viewCropDataLabel name value =
    div []
        [ strong [] [ text (name ++ " : ") ]
        , text (String.fromInt value)
        ]


type Msg
    = UpdateCropData CropData


update : Msg -> CropData -> ( CropData, Cmd Msg )
update msg oldCropData =
    case msg of
        UpdateCropData newCropData ->
            ( newCropData, Cmd.none )


initialModel : CropData
initialModel =
    { x = 297
    , y = 0
    , width = 906
    , height = 906
    }


init : () -> ( CropData, Cmd Msg )
init flags =
    ( initialModel, Cmd.none )


main : Program () CropData Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = \_ -> Sub.none
        }
----


[[interact-with-javascript-conclusion]]
=== 8.9 Conclusion


In this chapter, we learned how to interact with JavaScript from Elm using ports, flags, and custom elements. Whenever possible we should avoid using any JavaScript code in Elm because it can cause our app to crash during runtime. But if we must, Elm still has our back. It tries to minimize the damage by setting clear boundaries. JavaScript isn’t allowed to pass an arbitrary code or sneak in an incorrectly typed value through those boundaries. If it still attempts to do so despite the restrictions, Elm will throw an error immediately.

Letting our app crash because of some faulty JavaScript code is not desirable. That’s why we should always try to decode the values coming from JavaScript ourselves instead of the Elm runtime. That way we can graciously handle the errors as we encounter them.


[[where-to-go-from-here]]
=== 8.10 Where To Go From Here?


Congratulations for making this far! I hope you enjoyed learning Elm from this book as much as I enjoyed writing it. Give yourself a big tap on the back for sticking all the way to the end.

We have only scratched the surface of the Elm ecosystem. This book focused mainly on the conceptual aspects of Elm as a language and its architecture. There is so much more to learn before truly mastering Elm. The next step in your journey is to learn how to build sophisticated real world apps in Elm.

A good way to do that is to carefully study the code in https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa[this open-source single page app] built by Richard Feldman. Richard created that project specifically to showcase how to build a moderately-sized real world app in Elm.

Although this book covered the basics of Elm in great detail, it might be helpful for you to read Richard’s book _https://www.manning.com/books/elm-in-action[Elm in Action]_ before diving into his open source project. He does a wonderful job of explaining various concepts in Elm while building a fun app called Photo Groove. Reading _Elm in Action_ will also reinforce what you have learned from this book.

If you prefer watching videos to reading, Richard has also produced a really https://frontendmasters.com/courses/intro-elm/[good series] that teaches how to build an Elm app from start to finish.

The https://github.com/isRuslan/awesome-elm[Awesome Elm] repository on Github contains a community driven list of useful tutorials, example apps, libraries, and various other programs. You should definitely check it out.

Finally, if you get stuck and need help, don’t hesitate to reach out to the http://elm-lang.org/community[Elm community members]. They are very friendly and eager to share their knowledge with others.


== Source Codes

随书代码按每章内容对应一个工程目录的形式组织，各个工程的文件不一定会更新，也可能部分更新，使用 rsync 同步工具的 dry-run 模式来检查每个章节更新的代码文件：

    rsync --verbose --dry-run --checksum --stats --recursive --delete chapter-4/ chapter-3/

注意，目录使用结尾的斜杠，否则会将目录当作目标目录下的子目录进行处理。同时使用 --verbose 选项才会在控制台输出 dry-run 模式产生的信息。使用 --checksum 比较方式可以避免内容相同的文件因为日期差异而被当作有变动的文件被处理。可以在以下检查结果中看到，第二章只有 elm.json 文件增量更新，其它文件保持不变：

[source,bash]
----
rsync --verbose --dry-run --checksum --stats --recursive --delete chapter-2/2.3-building-a-simple-web-page/ chapter-2/2.10-elm-install/

sending incremental file list
beginning-elm/elm.json

Number of files: 10 (reg: 5, dir: 5)
Number of created files: 0
Number of deleted files: 0
Number of regular files transferred: 1
Total file size: 2,233 bytes
Total transferred file size: 516 bytes
Literal data: 0 bytes
Matched data: 0 bytes
File list size: 0
File list generation time: 0.001 seconds
File list transfer time: 0.000 seconds
Total bytes sent: 374
Total bytes received: 26

sent 374 bytes  received 26 bytes  800.00 bytes/sec
total size is 2,233  speedup is 5.58 (DRY RUN)
----

