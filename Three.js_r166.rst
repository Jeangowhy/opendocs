
.. code:: bash

   #pandoc -trst -rhtml https://threejs.org/ --column=90 --wrap=auto >> $0
   #pandoc -trst -rhtml https://threejs.org/examples --column=90 --wrap=auto >> $0
   while read -r page
   do
      echo ".. _$page" >> /pl/out.rst
      curl $page \
      | sed -n '/<h1>/,${p}' \
      | pandoc -trst -rhtml --column=90 --wrap=auto >> /pl/out.rst
   done << EOF
https://threejs.org/manual/en/primitives.html
https://threejs.org/manual/en/scenegraph.html
https://threejs.org/manual/en/materials.html
https://threejs.org/manual/en/textures.html
https://threejs.org/manual/en/lights.html
https://threejs.org/manual/en/cameras.html
https://threejs.org/manual/en/shadows.html
https://threejs.org/manual/en/fog.html
https://threejs.org/manual/en/rendertargets.html
https://threejs.org/manual/en/custom-buffergeometry.html
https://threejs.org/manual/en/rendering-on-demand.html
https://threejs.org/manual/en/debugging-javascript.html
https://threejs.org/manual/en/debugging-glsl.html
https://threejs.org/manual/en/tips.html#screenshot
https://threejs.org/manual/en/tips.html#preservedrawingbuffer
https://threejs.org/manual/en/tips.html#tabindex
https://threejs.org/manual/en/tips.html#transparent-canvas
https://threejs.org/manual/en/tips.html#html-background
https://threejs.org/manual/en/optimize-lots-of-objects.html
https://threejs.org/manual/en/optimize-lots-of-objects-animated.html
https://threejs.org/manual/en/offscreencanvas.html
https://threejs.org/manual/en/load-obj.html
https://threejs.org/manual/en/load-gltf.html
https://threejs.org/manual/en/backgrounds.html
https://threejs.org/manual/en/transparency.html
https://threejs.org/manual/en/multiple-scenes.html
https://threejs.org/manual/en/picking.html
https://threejs.org/manual/en/post-processing.html
https://threejs.org/manual/en/shadertoy.html
https://threejs.org/manual/en/align-html-elements-to-3d.html
https://threejs.org/manual/en/indexed-textures.html
https://threejs.org/manual/en/canvas-textures.html
https://threejs.org/manual/en/billboards.html
https://threejs.org/manual/en/cleanup.html
https://threejs.org/manual/en/voxel-geometry.html
https://threejs.org/manual/en/game.html
https://threejs.org/manual/en/webxr-basics.html
https://threejs.org/manual/en/webxr-look-to-select.html
https://threejs.org/manual/en/webxr-point-to-select.html
https://threejs.org/manual/en/material-table.html
EOF
   exit

Three.js JavaScript 3D Library
==============================

   *  `three.js r166 <http://github.com/mrdoob/three.js/releases>`__
   *  `docs <https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene>`__
   *  `examples <https://threejs.org/examples/#webgl_animation_keyframes>`__
   *  `submit project <https://discourse.threejs.org/c/showcase>`__

   * Mr.Doob 个人主页 https://mrdoob.com/

   *  Learn

      -  `documentation <https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene>`__
      -  `examples <https://threejs.org/examples/#webgl_animation_keyframes>`__
      -  `editor <https://threejs.org/editor/>`__
      -  `gpt <https://chat.openai.com/g/g-jGjqAMvED-three-js-mentor>`__

   *  Community

      -  `questions <https://stackoverflow.com/questions/tagged/three.js>`__
      -  `discord <https://discord.gg/56GBJwAnUS>`__
      -  `forum <https://discourse.threejs.org/>`__
      -  `twitter <https://twitter.com/threejs>`__

   *  Code

      -  `github <https://github.com/mrdoob/three.js/>`__
      -  `download <https://github.com/mrdoob/three.js/archive/master.zip>`__

   *  Resources

      -  `Three.js Fundamentals <https://threejs.org/manual/#en/fundamentals>`__
      -  `Three.js Journey <https://threejs-journey.xyz/>`__
      -  `Learn Three.js <https://www.packtpub.com/product/learn-threejs-fourth-edition/9781803233871>`__
      -  `初めてのThree.js <https://www.amazon.co.jp/初めてのThree-js-第2版-_WebGLのためのJavaScript-3Dライブラリ-Dirksen/dp/4873117704/>`__

   *  Merch

      -  `T-Shirts <https://teespring.com/stores/threejs-store>`__


Mr.Doob Website
===============

   https://mrdoob.com/

   =============================== =============================================
   Multiuser Sketchpad 2020/04/15  https://multiuser-sketchpad.glitch.me/
   Three.js Sketches 2016/02/12    https://mrdoob.neocities.org/
   Spin Painter 2015/05/10         https://mrdoob.com/lab/javascript/spinpainter/
   Dataworld 2015/03/05            https://xplsv.github.io/dataworld/
   Sporel 2013/12/24               https://mrdoob.github.io/sporel/
   Obsidian 2013/07/28             https://xplsv.github.io/obsidian/
   Beach Balls 2013/03/24          https://mrdoob.com/lab/javascript/beachballs/
   Google Space 2012/10/15         https://mrdoob.com/projects/chromeexperiments/google-space/
   Webcam Displacement 2012/08/25  https://mrdoob.com/lab/javascript/webcam/displace/
   Winning Solitaire 2012/05/07    https://mrdoob.com/lab/javascript/effects/solitaire/
   GLSL Sandbox 2011/11/09         https://glslsandbox.com/
   Voxels liquid 2011/10/17        https://mrdoob.com/lab/javascript/webgl/voxels_liquid/
   Sphere 2011/08/16               https://mrdoob.com/lab/javascript/webgl/sphere/
   Clouds 2011/03/25               https://mrdoob.com/lab/javascript/webgl/clouds/
   Disturb 2010/12/11              https://mrdoob.com/lab/javascript/effects/disturb/
   Voxels 2010/11/06               https://mrdoob.com/projects/voxels/#A/bnciaTraheakhacTSiahfaotaiafUscierhoShahfShahfafiWheSheUeWSfafhchhefffchhWffahherhpfXTbdUhUhUhVihShaffahfahhcfhYhaffYhahhaeeUhahhahhcdfShYhYhafhUheffdafhcjhShYfYfahfYfahfYfafhcjhYeahfShShWhfVbfdjjhaffaffaffafhafhafhahhahhahhahfahfeehhahfahfaffaffafhafhahhWhfahhWhfWffahhefXhUhehffahiaddbnfffYhcmfrfsaaiU
   Internet Explorer 6 2010/10/07  https://mrdoob.com/lab/javascript/effects/ie6/
   Or so they say... 2010/07/25    https://xplsv.com/prods/demos/xplsv_orsotheysay/
   Plane Deformations 2010/06/12   https://mrdoob.com/lab/javascript/effects/plane_deformations/
   Water Type 2010/06/4            https://mrdoob.com/lab/javascript/effects/water/02/
   Three.js 2010/04/23             https://threejs.org/
   Harmony 2010/03/08              https://mrdoob.com/projects/harmony/
   Zoom blur 2010/03/08            https://mrdoob.com/lab/javascript/effects/zoomblur/03/
   Rotozoomer 2010/02/26           https://mrdoob.com/lab/javascript/effects/rotozoomer/00/
   Fire 2010/02/15                 https://mrdoob.com/lab/javascript/effects/fire/01/
   Water Remix 2010/02/11          https://mrdoob.com/lab/javascript/effects/water/01/
   Water 2010/02/11                https://mrdoob.com/lab/javascript/effects/water/00/
   Branching 2009/11/29            https://mrdoob.com/lab/javascript/effects/branching/01_spite_mrdoob/
   Branching 2009/11/29            https://mrdoob.com/lab/javascript/effects/branching/01/
   Branching 2009/11/29            https://mrdoob.com/lab/javascript/effects/branching/00/
   3D Waveform 2009/11/09          https://mrdoob.com/lab/javascript/waveform/
   Checkbox Painter 2009/11/04     https://mrdoob.com/lab/javascript/checkbox_painter/
   Checkboxes Ball 2009/11/04      https://mrdoob.com/lab/javascript/checkboxes/
   Google Sphere 2009/05/28        https://mrdoob.com/projects/chromeexperiments/google-sphere/
   Google Gravity 2009/03/18       https://mrdoob.com/projects/chromeexperiments/google-gravity/
   Ball Pool 2009/02/12            https://mrdoob.com/projects/chromeexperiments/ball-pool/
   Slit Scan 2020/06/17            https://mrdoob.com/lab/javascript/webcam/slitscan/
   =============================== =============================================


Mr.Doob on neocities.org
========================

   Sketches done with `Three.js Editor <https://threejs.org/editor/>`__ 
   and uploaded to `Neocities <https://neocities.org/>`__.

   ============== =============== ============== ================
   |039.png|      |030.png|       |020.png|      |010.png| 
   |038.png|      |029.png|       |019.png|      |009.png| 
   |037.png|      |028.png|       |018.png|      |008.png| 
   |036.png|      |027.png|       |017.png|      |007.png| 
   |035.png|      |026.png|       |016.png|      |006.png| 
   |034.png|      |025.png|       |015.png|      |005.png| 
   |033.png|      |024.png|       |014.png|      |004.png| 
   |032.png|      |023.png|       |013.png|      |003.png| 
                  |022.png|       |012.png|      |002.png| 
                  |021.png|       |011.png|      |001.png| 
   ============== =============== ============== ================


.. |039.png| image:: https://mrdoob.neocities.org/files/039.png
   :target: https://mrdoob.neocities.org/039
   :alt: 039 ~ 21 03 17
.. |038.png| image::  https://mrdoob.neocities.org/files/038.png
   :target: https://mrdoob.neocities.org/038
   :alt: 038 ~ 21 03 10
.. |037.png| image::  https://mrdoob.neocities.org/files/037.png
   :target: https://mrdoob.neocities.org/037
   :alt: 037 ~ 20 01 05
.. |036.png| image::  https://mrdoob.neocities.org/files/036.png
   :target: https://mrdoob.neocities.org/036
   :alt: 036 ~ 20 01 04
.. |035.png| image::  https://mrdoob.neocities.org/files/035.png
   :target: https://mrdoob.neocities.org/035
   :alt: 035 ~ 20 01 01
.. |034.png| image::  https://mrdoob.neocities.org/files/034.png
   :target: https://mrdoob.neocities.org/034
   :alt: 034 ~ 19 12 30
.. |033.png| image::  https://mrdoob.neocities.org/files/033.png
   :target: https://mrdoob.neocities.org/033
   :alt: 033 ~ 19 11 02
.. |032.png| image::  https://mrdoob.neocities.org/files/032.png
   :target: https://mrdoob.neocities.org/032
   :alt: 032 ~ 19 11 01
.. |030.png| image::  https://mrdoob.neocities.org/files/030.png
   :target: https://mrdoob.neocities.org/030
   :alt: 030 ~ 17 11 03
.. |029.png| image::  https://mrdoob.neocities.org/files/029.png
   :target: https://mrdoob.neocities.org/029
   :alt: 029 ~ 17 11 02
.. |028.png| image::  https://mrdoob.neocities.org/files/028.png
   :target: https://mrdoob.neocities.org/028
   :alt: 028 ~ 17 11 01
.. |027.png| image::  https://mrdoob.neocities.org/files/027.png
   :target: https://mrdoob.neocities.org/027
   :alt: 027 ~ 17 11 01
.. |026.png| image::  https://mrdoob.neocities.org/files/026.png
   :target: https://mrdoob.neocities.org/026
   :alt: 026 ~ 17 10 21
.. |025.png| image::  https://mrdoob.neocities.org/files/025.png
   :target: https://mrdoob.neocities.org/025
   :alt: 025 ~ 16 08 17
.. |024.png| image::  https://mrdoob.neocities.org/files/024.png
   :target: https://mrdoob.neocities.org/024
   :alt: 024 ~ 16 08 15
.. |023.png| image::  https://mrdoob.neocities.org/files/023.png
   :target: https://mrdoob.neocities.org/023
   :alt: 023 ~ 16 06 03
.. |022.png| image::  https://mrdoob.neocities.org/files/022.png
   :target: https://mrdoob.neocities.org/022
   :alt: 022 ~ 16 03 13
.. |021.png| image::  https://mrdoob.neocities.org/files/021.png
   :target: https://mrdoob.neocities.org/021
   :alt: 021 ~ 16 03 10
.. |020.png| image::  https://mrdoob.neocities.org/files/020.png
   :target: https://mrdoob.neocities.org/020
   :alt: 020 ~ 16 03 09
.. |019.png| image::  https://mrdoob.neocities.org/files/019.png
   :target: https://mrdoob.neocities.org/019
   :alt: 019 ~ 16 03 06
.. |018.png| image::  https://mrdoob.neocities.org/files/018.png
   :target: https://mrdoob.neocities.org/018
   :alt: 018 ~ 16 02 11
.. |017.png| image::  https://mrdoob.neocities.org/files/017.png
   :target: https://mrdoob.neocities.org/017
   :alt: 017 ~ 16 02 09
.. |016.png| image::  https://mrdoob.neocities.org/files/016.png
   :target: https://mrdoob.neocities.org/016
   :alt: 016 ~ 16 02 09
.. |015.png| image::  https://mrdoob.neocities.org/files/015.png
   :target: https://mrdoob.neocities.org/015
   :alt: 015 ~ 15 11 28
.. |014.png| image::  https://mrdoob.neocities.org/files/014.png
   :target: https://mrdoob.neocities.org/014
   :alt: 014 ~ 15 11 22
.. |013.png| image::  https://mrdoob.neocities.org/files/013.png
   :target: https://mrdoob.neocities.org/013
   :alt: 013 ~ 15 11 20
.. |012.png| image::  https://mrdoob.neocities.org/files/012.png
   :target: https://mrdoob.neocities.org/012
   :alt: 012 ~ 15 11 20
.. |011.png| image::  https://mrdoob.neocities.org/files/011.png
   :target: https://mrdoob.neocities.org/011
   :alt: 011 ~ 15 11 18
.. |010.png| image::  https://mrdoob.neocities.org/files/010.png
   :target: https://mrdoob.neocities.org/010
   :alt: 010 ~ 15 11 17
.. |009.png| image::  https://mrdoob.neocities.org/files/009.png
   :target: https://mrdoob.neocities.org/009
   :alt: 009 ~ 15 11 17
.. |008.png| image::  https://mrdoob.neocities.org/files/008.png
   :target: https://mrdoob.neocities.org/008
   :alt: 008 ~ 15 11 16
.. |007.png| image::  https://mrdoob.neocities.org/files/007.png
   :target: https://mrdoob.neocities.org/007
   :alt: 007 ~ 15 11 15
.. |006.png| image::  https://mrdoob.neocities.org/files/006.png
   :target: https://mrdoob.neocities.org/006
   :alt: 006 ~ 15 11 14
.. |005.png| image::  https://mrdoob.neocities.org/files/005.png
   :target: https://mrdoob.neocities.org/005
   :alt: 005 ~ 15 11 13
.. |004.png| image::  https://mrdoob.neocities.org/files/004.png
   :target: https://mrdoob.neocities.org/004
   :alt: 004 ~ 15 11 12
.. |003.png| image::  https://mrdoob.neocities.org/files/003.png
   :target: https://mrdoob.neocities.org/003
   :alt: 003 ~ 15 11 12
.. |002.png| image::  https://mrdoob.neocities.org/files/002.png
   :target: https://mrdoob.neocities.org/002
   :alt: 002 ~ 15 11 11
.. |001.png| image::  https://mrdoob.neocities.org/files/001.png
   :target: https://mrdoob.neocities.org/001
   :alt: 001 ~ 15 11 11


Projects
========

   .. figure:: https://threejs.org/files/projects/junni.png
      :target: https://next.junni.co.jp/

   .. figure:: https://threejs.org/files/projects/stickittothestickman.png
      :target: https://www.stickittothestickman.com/

   .. figure:: https://threejs.org/files/projects/anumberfromtheghost.png
      :target: https://www.anumberfromtheghost.com/

   .. figure:: https://threejs.org/files/projects/relight.png
      :target: https://clipdrop.co/relight

   .. figure:: https://threejs.org/files/projects/theatrejs.png
      :target: https://www.theatrejs.com/

   .. figure:: https://threejs.org/files/projects/solar-system.png
      :target: https://eyes.nasa.gov/apps/solar-system/

   .. figure:: https://threejs.org/files/projects/needle.png
      :target: https://needle.tools/

   .. figure:: https://threejs.org/files/projects/vrseat.png
      :target: https://vrseat.vercel.app/

   .. figure:: https://threejs.org/files/projects/design-the-next-iphone.png
      :target: https://neal.fun/design-the-next-iphone/

   .. figure:: https://threejs.org/files/projects/coastalworld.png
      :target: https://coastalworld.com/

   .. figure:: https://threejs.org/files/projects/webgi-jewelry.png
      :target: https://webgi-jewelry.vercel.app/

   .. figure:: https://threejs.org/files/projects/celebrating-petanque.png
      :target: https://www.google.com/doodles/celebrating-petanque

   .. figure:: https://threejs.org/files/projects/bbcmicro.png
      :target: https://virtual.bbcmic.ro/?disc1=elite.ssd&autoboot

   .. figure:: https://threejs.org/files/projects/camera-webgi.png
      :target: https://camera-webgi.vercel.app/

   .. figure:: https://threejs.org/files/projects/annoyingmuseum.png
      :target: https://annoyingmuseum.zendesk.com/

   .. figure:: https://threejs.org/files/projects/futurecube.png
      :target: https://www.kubota.com/futurecube/

   .. figure:: https://threejs.org/files/projects/hsmkrt1996.png
      :target: https://hsmkrt1996.com/

   .. figure:: https://threejs.org/files/projects/choochooworld.png
      :target: https://choochooworld.com/

   .. figure:: https://threejs.org/files/projects/leap-for-mankind.png
      :target: https://leap-for-mankind.com/

   .. figure:: https://threejs.org/files/projects/henryheffernan.png
      :target: https://henryheffernan.com/

   .. figure:: https://threejs.org/files/projects/mothersday.png
      :target: https://www.pola.co.jp/wecaremore/mothersday/

   .. figure:: https://threejs.org/files/projects/david-hckh.png
      :target: https://david-hckh.com/

   .. figure:: https://threejs.org/files/projects/fungui.png
      :target: https://fungui.resn.co.nz/

   .. figure:: https://threejs.org/files/projects/nodetoy.png
      :target: https://nodetoy.co/

   .. figure:: https://threejs.org/files/projects/jesse-zhou.png
      :target: https://jesse-zhou.com/

   .. figure:: https://threejs.org/files/projects/exp-infinite-passerella.png
      :target: https://exp-infinite-passerella.lusion.co/

   .. figure:: https://threejs.org/files/projects/windland-neotix.png
      :target: https://windland-neotix.vercel.app/

   .. figure:: https://threejs.org/files/projects/polygonjs.png
      :target: https://polygonjs.com/

   .. figure:: https://threejs.org/files/projects/sougen.png
      :target: https://sougen.co/

   .. figure:: https://threejs.org/files/projects/matcap-editor.png
      :target: https://lab.julienverneaut.com/matcap-editor/

   .. figure:: https://threejs.org/files/projects/exp-gemini.png
      :target: https://exp-gemini.lusion.co/

   .. figure:: https://threejs.org/files/projects/exp-my-little-storybook.png
      :target: https://exp-my-little-storybook.lusion.co/

   .. figure:: https://threejs.org/files/projects/devaslife.png
      :target: https://www.youtube.com/watch?v=bSMZgXzC9AA

   .. figure:: https://threejs.org/files/projects/madbox.png
      :target: https://madbox.io/

   .. figure:: https://threejs.org/files/projects/market.png
      :target: https://market.pmnd.rs/

   .. figure:: https://threejs.org/files/projects/pendereckisgarden.png
      :target: https://pendereckisgarden.pl/en

   .. figure:: https://threejs.org/files/projects/rogueengine.png
      :target: https://rogueengine.io/

   .. figure:: https://threejs.org/files/projects/logartis.png
      :target: https://logartis.info/

   .. figure:: https://threejs.org/files/projects/blobmixer.png
      :target: https://blobmixer.14islands.com/

   .. figure:: https://threejs.org/files/projects/pioupiou.png
      :target: https://pioupiou.wmapan.com/

   .. figure:: https://threejs.org/files/projects/f-mmxx.png
      :target: http://spite.github.io/fuck-2020/

   .. figure:: https://threejs.org/files/projects/unshift.png
      :target: https://unshift.jp/

   .. figure:: https://threejs.org/files/projects/mars2020.png
      :target: https://eyes.nasa.gov/apps/mars2020/

   .. figure:: https://threejs.org/files/projects/threejs-journey.png
      :target: https://threejs-journey.xyz/

   .. figure:: https://threejs.org/files/projects/spline.png
      :target: https://spline.design/

   .. figure:: https://threejs.org/files/projects/procedural-gl.png
      :target: https://www.procedural.eu/

   .. figure:: https://threejs.org/files/projects/kodeclubs.png
      :target: https://www.kodeclubs.com/

   .. figure:: https://threejs.org/files/projects/midwam.png
      :target: https://www.midwam.com/en

   .. figure:: https://threejs.org/files/projects/medal-of-honor.png
      :target: https://www.oculus.com/medal-of-honor/

   .. figure:: https://threejs.org/files/projects/chartogne-taillet.png
      :target: https://chartogne-taillet.com/en

      红酒庄品牌推广

   .. figure:: https://threejs.org/files/projects/inkbots.png
      :target: https://3dcomic.shop/inkbots/s01e01/

   .. figure:: https://threejs.org/files/projects/pararty.png
      :target: https://pararty.com/

   .. figure:: https://threejs.org/files/projects/weedensenteret.png
      :target: https://weedensenteret.no/

   .. figure:: https://threejs.org/files/projects/voiceofracism.png
      :target: https://voiceofracism.co.nz/

   .. figure:: https://threejs.org/files/projects/nova.png
      :target: https://nova.app/

   .. figure:: https://threejs.org/files/projects/storyline.png
      :target: https://www.sbs.com.au/storyline/

   .. figure:: https://threejs.org/files/projects/aquarium.png
      :target: https://www.aquarium.ru/en

   .. figure:: https://threejs.org/files/projects/turbulent.png
      :target: https://turbulent.ca/

   .. figure:: https://threejs.org/files/projects/patrickheng.png
      :target: https://patrickheng.com

   .. figure:: https://threejs.org/files/projects/deepviewvideo.png
      :target: https://augmentedperception.github.io/deepviewvideo/

   .. figure:: https://threejs.org/files/projects/shutdown-gallery.png
      :target: https://shutdown.gallery/

   .. figure:: https://threejs.org/files/projects/iss-sim.png
      :target: https://iss-sim.spacex.com/

   .. figure:: https://threejs.org/files/projects/hubs.png
      :target: https://hubs.mozilla.com/

   .. figure:: https://threejs.org/files/projects/domenicobrz.png
      :target: https://domenicobrz.github.io/webgl/

   .. figure:: https://threejs.org/files/projects/webxr-sneakers.png
      :target: https://webxr-sneakers.lusion.co/

   .. figure:: https://threejs.org/files/projects/p5aholic.png
      :target: https://experiments.p5aholic.me/

   .. figure:: https://threejs.org/files/projects/guillaumegouessan.png
      :target: https://guillaumegouessan.com/

   .. figure:: https://threejs.org/files/projects/cineshader.png
      :target: https://cineshader.com/

   .. figure:: https://threejs.org/files/projects/hello-webxr.png
      :target: https://mixedreality.mozilla.org/hello-webxr/

   .. figure:: https://threejs.org/files/projects/turn-of-the-screw.png
      :target: https://www.operanorth.co.uk/turn-of-the-screw-immersive-trailer/

   .. figure:: https://threejs.org/files/projects/kentatoshikura.png
      :target: https://kentatoshikura.com/

   .. figure:: https://threejs.org/files/projects/richardmattka.png
      :target: https://richardmattka.com

   .. figure:: https://threejs.org/files/projects/bruno-simon.png
      :target: https://bruno-simon.com/

   .. figure:: https://threejs.org/files/projects/garden-eight.png
      :target: https://garden-eight.com/

   .. figure:: https://threejs.org/files/projects/1955horsebit.png
      :target: https://1955horsebit.gucci.com/

   .. figure:: https://threejs.org/files/projects/soletanche-bachy.png
      :target: https://experience.soletanche-bachy.com/

   .. figure:: https://threejs.org/files/projects/react-three-fiber.png
      :target: https://github.com/react-spring/react-three-fiber

   .. figure:: https://threejs.org/files/projects/lusion.png
      :target: https://lusion.co/

   .. figure:: https://threejs.org/files/projects/36days.png
      :target: https://36days.reflektor.digital/

   .. figure:: https://threejs.org/files/projects/veolia.png
      :target: https://experience.eau.veolia.fr/

   .. figure:: https://threejs.org/files/projects/modelviewer.png
      :target: https://modelviewer.dev/

   .. figure:: https://threejs.org/files/projects/hinderer-wolff.png
      :target: https://hinderer-wolff.fr/

   .. figure:: https://threejs.org/files/projects/robinmastromarino.png
      :target: http://robinmastromarino.com

   .. figure:: https://threejs.org/files/projects/jellymario.png
      :target: https://jellymar.io/

   .. figure:: https://threejs.org/files/projects/krunker.png
      :target: https://krunker.io/

   .. figure:: https://threejs.org/files/projects/dotbigbang.png
      :target: https://dotbigbang.com/

   .. figure:: https://threejs.org/files/projects/crossy-road.png
      :target: https://poki.com/en/g/crossy-road

   .. figure:: https://threejs.org/files/projects/hki.png
      :target: https://hki.paris/xp

   .. figure:: https://threejs.org/files/projects/epicskidmarks.png
      :target: https://epicskidmarks.com

   .. figure:: https://threejs.org/files/projects/track.png
      :target: https://demos.littleworkshop.fr/track

   .. figure:: https://threejs.org/files/projects/heraclos.png
      :target: https://heraclosgame.com/

   .. figure:: https://threejs.org/files/projects/goinghome.png
      :target: http://goinghome.302chanwoo.com/

   .. figure:: https://threejs.org/files/projects/mathis-biabiany.png
      :target: http://mathis-biabiany.fr/

   .. figure:: https://threejs.org/files/projects/dddance.png
      :target: https://dddance.party/

   .. figure:: https://threejs.org/files/projects/infinitown.png
      :target: http://demos.littleworkshop.fr/infinitown

   .. figure:: https://threejs.org/files/projects/taotajima.png
      :target: http://taotajima.jp/

   .. figure:: https://threejs.org/files/projects/bertrandcandas.png
      :target: http://bertrandcandas.com/

   .. figure:: https://threejs.org/files/projects/hajimewatanabe.png
      :target: https://hajimewatanabe.jp/portfolio/

   .. figure:: https://threejs.org/files/projects/shorttrip.png
      :target: https://alexanderperrin.com.au/paper/shorttrip/

   .. figure:: https://threejs.org/files/projects/ff.png
      :target: http://vr.ff.com/us/

   .. figure:: https://threejs.org/files/projects/dancetonite.png
      :target: https://tonite.dance/

   .. figure:: https://threejs.org/files/projects/emmitfenn.png
      :target: https://emmitfenn.com/

   .. figure:: https://threejs.org/files/projects/transmit5.png
      :target: https://panic.com/transmit/

   .. figure:: https://threejs.org/files/projects/webvrshowroom.png
      :target: http://showroom.littleworkshop.fr/

   .. figure:: https://threejs.org/files/projects/interland.png
      :target: https://beinternetawesome.withgoogle.com/interland

   .. figure:: https://threejs.org/files/projects/larsberg.png
      :target: http://www.larsberg.net/

   .. figure:: https://threejs.org/files/projects/ouigo.png
      :target: http://letsplay.ouigo.com/

   .. figure:: https://threejs.org/files/projects/nunustudio.png
      :target: https://nunustudio.org/

   .. figure:: https://threejs.org/files/projects/moments.png
      :target: https://moments.epic.net/

   .. figure:: https://threejs.org/files/projects/neonlights.png
      :target: https://within-unlimited.github.io/neon-lights/release/

   .. figure:: https://threejs.org/files/projects/samsylab.png
      :target: http://lab.samsy.ninja/

   .. figure:: https://threejs.org/files/projects/earth2050.png
      :target: https://2050.earth/

   .. figure:: https://threejs.org/files/projects/campoallecomete.png
      :target: http://campoallecomete.it/

   .. figure:: https://threejs.org/files/projects/saydnaya.png
      :target: https://saydnaya.amnesty.org/

   .. figure:: https://threejs.org/files/projects/lucyhardcastle.png
      :target: https://lucyhardcastle-thefifthsense.i-d.co/en_gb/

   .. figure:: https://threejs.org/files/projects/christmasexperiments2016.png
      :target: http://christmasexperiments.com/

   .. figure:: https://threejs.org/files/projects/paperworld.png
      :target: https://paperplanes.world/

   .. figure:: https://threejs.org/files/projects/robertadicamerino.png
      :target: http://www.mentaltoy.com/resources/rdc-fwa/index.html

   .. figure:: https://threejs.org/files/projects/deprogrammed.png
      :target: http://www.deprogrammed.org/

   .. figure:: https://threejs.org/files/projects/analysis.png
      :target: http://analysis.4sceners.de/

   .. figure:: https://threejs.org/files/projects/swissarmyman.png
      :target: http://swissarmyman.com/

   .. figure:: https://threejs.org/files/projects/aviator.png
      :target: http://tympanus.net/codrops/2016/04/26/the-aviator-animating-basic-3d-scene-threejs/

   .. figure:: https://threejs.org/files/projects/particlelove.png
      :target: http://particle-love.com/

   .. figure:: https://threejs.org/files/projects/virtualart.png
      :target: https://virtualart.chromeexperiments.com/

   .. figure:: https://threejs.org/files/projects/lhbzr.png
      :target: http://www.lhbzr.com/

   .. figure:: https://threejs.org/files/projects/falter.png
      :target: http://falter.wild.plus/

   .. figure:: https://threejs.org/files/projects/handswtf.png
      :target: http://hands.wtf/

   .. figure:: https://threejs.org/files/projects/ashortjourney.png
      :target: http://www.ashortjourney.com/

   .. figure:: https://threejs.org/files/projects/homunculus.png
      :target: http://homunculus.jp/

   .. figure:: https://threejs.org/files/projects/voidii.png
      :target: http://void-ii.hi-res.net/

   .. figure:: https://threejs.org/files/projects/makemepulse2016.png
      :target: http://2016.makemepulse.com/

   .. figure:: https://threejs.org/files/projects/aframe.png
      :target: https://aframe.io/

   .. figure:: https://threejs.org/files/projects/dejavu.png
      :target: https://kamra.invisi-dir.com/

   .. figure:: https://threejs.org/files/projects/crystallizedskins.png
      :target: http://crystallizedskins.com/

   .. figure:: https://threejs.org/files/projects/rainforest.png
      :target: http://rainforest.arkivert.no/

   .. figure:: https://threejs.org/files/projects/starmap.png
      :target: https://robertsspaceindustries.com/starmap

   .. figure:: https://threejs.org/files/projects/uberviz.png
      :target: https://www.uberviz.io/

   .. figure:: https://threejs.org/files/projects/networkeffect.png
      :target: http://networkeffect.io/

   .. figure:: https://threejs.org/files/projects/yume.png
      :target: http://unseen-music.com/yume/

   .. figure:: https://threejs.org/files/projects/playkeepout.png
      :target: http://www.playkeepout.com/

   .. figure:: https://threejs.org/files/projects/renaultespace.png
      :target: http://renaultespace.littleworkshop.fr/

   .. figure:: https://threejs.org/files/projects/void.png
      :target: http://void.hi-res.net/

   .. figure:: https://threejs.org/files/projects/enough.png
      :target: http://cabbi.bo/enough/

   .. figure:: https://threejs.org/files/projects/newslabtrends.png
      :target: http://news-lab-trends-experiment.appspot.com/

   .. figure:: https://threejs.org/files/projects/dennis.png
      :target: http://www.dennis.video/

   .. figure:: https://threejs.org/files/projects/fallenio.png
      :target: http://www.fallen.io/ww2/

   .. figure:: https://threejs.org/files/projects/theboat.png
      :target: http://www.sbs.com.au/theboat/

   .. figure:: https://threejs.org/files/projects/earth.png
      :target: http://earth.plus360degrees.com/

   .. figure:: https://threejs.org/files/projects/wipeout.png
      :target: http://phoboslab.org/wipeout/

   .. figure:: https://threejs.org/files/projects/vaalentin.png
      :target: http://vaalentin.github.io/2015/

   .. figure:: https://threejs.org/files/projects/wildflower.png
      :target: http://wildflower.resn.co.nz/

   .. figure:: https://threejs.org/files/projects/dilladimension.png
      :target: http://www.dilladimension.com/

   .. figure:: https://threejs.org/files/projects/cruciform.png
      :target: http://www.clicktorelease.com/code/cruciform/

   .. figure:: https://threejs.org/files/projects/waytogo.png
      :target: http://a-way-to-go.com/

   .. figure:: https://threejs.org/files/projects/heroforge.png
      :target: http://www.heroforge.com/

   .. figure:: https://threejs.org/files/projects/cabbibo.png
      :target: http://cabbi.bo/

   .. figure:: https://threejs.org/files/projects/pablotheflamingo.jpg
      :target: http://pablotheflamingo.com/

   .. figure:: https://threejs.org/files/projects/shapespark.png
      :target: http://www.shapespark.com/

   .. figure:: https://threejs.org/files/projects/potree.jpg
      :target: http://www.potree.org/

   .. figure:: https://threejs.org/files/projects/overthetinyhills.jpg
      :target: http://www.overthetinyhills.com/

   .. figure:: https://threejs.org/files/projects/gorescript.jpg
      :target: https://gorescript.github.io/classic/

   .. figure:: https://threejs.org/files/projects/rubiks-cube.jpg
      :target: https://stewartsmith.io/work/rubiks-cube

   .. figure:: https://threejs.org/files/projects/georgeandjonathan.jpg
      :target: http://www.georgeandjonathan.com/

   .. figure:: https://threejs.org/files/projects/genealogyofthefree.jpg
      :target: http://www.nike.com/xp/b/genealogyofthefree/zoetrope.html

   .. figure:: https://threejs.org/files/projects/classics.png
      :target: http://carvisualizer.plus360degrees.com/classics/

   .. figure:: https://threejs.org/files/projects/kiddisco.jpg
      :target: http://kiddisco.asmallgame.com/

   .. figure:: https://threejs.org/files/projects/clara.png
      :target: http://clara.io/

   .. figure:: https://threejs.org/files/projects/hellorun.jpg
      :target: https://helloenjoy.itch.io/hellorun

   .. figure:: https://threejs.org/files/projects/acko.jpg
      :target: https://acko.net/

   .. figure:: https://threejs.org/files/projects/zoetrope.jpg
      :target: http://lab.sehsucht.de/

   .. figure:: https://threejs.org/files/projects/hexgl.jpg
      :target: http://hexgl.bkcore.com/

   .. figure:: https://threejs.org/files/projects/carvisualizer.jpg
      :target: http://carvisualizer.plus360degrees.com/threejs/

   .. figure:: https://threejs.org/files/projects/livecodelab.jpg
      :target: http://www.sketchpatch.net/labs/livecodelabIntro.html

   .. figure:: https://threejs.org/files/projects/triggerrally.jpg
      :target: http://triggerrally.com/

   .. figure:: https://threejs.org/files/projects/threenodes.jpg
      :target: http://idflood.github.io/ThreeNodes.js/

   .. figure:: https://threejs.org/files/projects/lights.jpg
      :target: https://helloenjoy.itch.io/lights

   .. figure:: https://threejs.org/files/projects/rome.jpg
      :target: http://www.ro.me/

   .. figure:: https://threejs.org/files/projects/globe.jpg
      :target: https://experiments.withgoogle.com/chrome/globe



🟡 Three.js Wiki
================

   .. code:: bash

      git clone https://github.com/mrdoob/three.js.wiki


   **Introduction**

   *  `API Documentation and Manual  <https://threejs.org/docs/>`__
   *  `Home  <https://github.com/mrdoob/three.js/wiki/>`__
   *  `Build instructions  <https://github.com/mrdoob/three.js/wiki/Build-instructions>`__
   *  `Migration Guide  <https://github.com/mrdoob/three.js/wiki/Migration-Guide>`__

   **Developer Guide**

   *  `Owners  <https://github.com/mrdoob/three.js/wiki/Owners>`__
   *  `An introduction to using Git  <https://github.com/mrdoob/three.js/wiki/An-introduction-to-using-Git>`__
   *  `Mr.doob's Code Style™  <https://github.com/mrdoob/three.js/wiki/Mr.doob's-Code-Style%E2%84%A2>`__
   *  `Editor Manual  <https://github.com/mrdoob/three.js/wiki/Editor-Manual>`__
   *  `GUI Tools with Three.js  <https://github.com/mrdoob/three.js/wiki/GUI-Tools-with-Three.js>`__
   *  `Dev Branch Examples  <https://github.com/mrdoob/three.js/wiki/Dev-Branch-Examples>`__

   **Three.js JSON format schema**

   *  `JSON Geometry format 4  <https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4>`__
   *  `JSON Texture format 4  <https://github.com/mrdoob/three.js/wiki/JSON-Texture-format-4>`__
   *  `JSON Material format 4  <https://github.com/mrdoob/three.js/wiki/JSON-Material-format-4>`__
   *  `JSON Object Scene format 4  <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__

   **WebGPURenderer**

   *  `Three.js Shading Language  <https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language>`__

   **Articles**

   *  `Using SketchUp Models  <https://github.com/mrdoob/three.js/wiki/Using-SketchUp-Models>`__

   **Misc**

   *  `Demoscene  <https://github.com/mrdoob/three.js/wiki/Demoscene>`__


   [//]: # (sidebar.md generated by https://www.npmjs.com/package/github-wiki-sidebar)


Build instructions
------------------

   This page describes how to compile three.js into a compressed JavaScript file.

   **Quickstart**

   *  Install `Node.js  <https://nodejs.org/>`__.

   *  Clone repository, use --depth parameter to prevent fetching all commit history. 
       you can just download and unzip folder.


   .. code:: bash

      git clone --depth=30 https://github.com/mrdoob/three.js.git


   * Go into the three.js directory.


   .. code:: bash

      cd ./three.js


   * Install build dependencies


   .. code:: bash

      npm i


   * Run the build script.


   .. code:: bash

      npm run build


   The ESM build file is at `build/three.module.js`, with `build/three.js` being 
   the UMD version and `build/three.min.js` the compressed UMD version.

   ---

   When developing it is recommended to use `npm start` or `npm run dev`. This
   will host a local web server and watch the files in `src` folder and 
   automatically perform a build when source files are changed.

   **Why compression?**

   The source code of Three.js is deliberately easy to read. This means that 
   it's split into several files and classes. While that's great for developing 
   and hacking on Three.js, it's not that great when deploying code to the 
   production server. 

   In production, you want to 

   -  use the least amount of files possible (to minimize the number of connections to your server)
   -  transmit as few bytes as possible (to save on bandwidth and on wait-time on both sides)

   So how do we put all files into just one and make it smaller than the sum of 
   the parts? Well, the answer is the awesome combination of our build script 
   plus JavaScript compressors!


Migration Guide
---------------

   .. Warning::

   **⚠️ When updating old projects, it's recommended to update the library in increments of 10 ⚠️**
   Updating in steps helps manage API changes, as deprecation warnings last for 10 releases

   #🎨# r166 → r167

   -  The imports of `WebGPURenderer` and TSL have changed. Please read 
      https://github.com/mrdoob/three.js/pull/28650 for all details.

   -  Please load HDRJPEG/Ultra HDR textures with `UltraHDRLoader` now.

   #🎨# r165 → r166

   -  No migration tasks required.

   #🎨# r164 → r165

   -  The signature of `WebGLRenderer.copyTextureToTexture()` and 
      `WebGLRenderer.copyTextureToTexture3D()` has changed. It is now 
      `copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 )`. 
      For more information, check out the examples `webgl_materials_texture_partialupdate  
      <https://threejs.org/examples/webgl_materials_texture_partialupdate>`__ 
      and `webgl2_materials_texture3d_partialupdate  
      <https://threejs.org/examples/webgl2_materials_texture3d_partialupdate>`__.

   -  The signature of `WebGLRenderer.copyFramebufferToTexture()` has changed. 
      It is now `copyFramebufferToTexture( texture, position = null, level = 0 )`. 
      For more information, check out the example `webgl_framebuffer_texture  
      <https://threejs.org/examples/webgl_framebuffer_texture>`__.

   #🎨# r163 → r164

   -  `LWOLoader` uses a new conversion from left to right-handed coordinate system now. 
      That means imported LWO assets will be oriented differently than before. 
      Check out `#28029  <https://github.com/mrdoob/three.js/pull/28029>`__ 
      to see how the official example was updated to restore the previous look.

   -  The async parse method of `USDZLoader` has been renamed to `parseAsync()`. 
      The new `parse()` method can be used with classic callbacks.

   -  The shader chunk `lightmap_fragment` has been removed. If your custom material 
      relies on it, you have to inline the GLSL code into your shader.

   -  The legacy `WebGLNodeBuilder` class has been removed which enabled a limited 
      node material usage with `WebGLRenderer`. The node material can only be used 
      with `WebGPURenderer` now.

   #🎨# r162 → r163

   -  `WebGLRenderer` no longer supports WebGL 1.

   -  The `stencil` context attribute of `WebGLRenderer` is now `false` by default 
      for performance reasons. If you use stencil related logic in your app, 
      you have to enable `stencil` explicitly now. The corresponding `stencil` 
      property of `WebGPURenderer` is now `false` by default as well.

   -  The `height` parameter of `TextGeometry` has been renamed to `depth`.

   -  To attenuate `Scene.environment`, use the new property `Scene.environmentIntensity`.
      The `envMapIntensity` property of `MeshStandardMaterial` and `MeshPhysicalMaterial` 
      now attenuate only the material's `envMap`.

   #🎨# r161 → r162

   -  `WebGLMultipleRenderTargets` has been removed. Use the new `count` property 
      of the render target classes for MRT usage.

   -  Hand-Tracking is not requested as an optional feature by default anymore. 
      You have to do this manually on app level now like demonstrated in the 
      related `examples  <https://threejs.org/examples/?q=handinput>`__.

   -  The API of `InteractiveGroup` has been changed. You have to use the new 
      methods `listenToXRControllerEvents()` and `listenToPointerEvents()` 
      to register the internal event listeners.

   -  When using an instance of `HTMLImageElement` for a texture, the renderer 
      uses now `naturalWidth` and `naturalHeight` instead of `width` and `height` 
      for computing the image dimensions. This enables simplifications on app 
      level if the images are part of the DOM and resized with CSS.

   #🎨# r160 → r161

   -  The build files `build/three.js` and `build/three.min.js` have been removed. 
      Please use ES Modules or alternatives: 
      https://threejs.org/docs/index.html#manual/en/introduction/Installation

   -  `WebGLRenderer` now specifies precision qualifiers for all GLSL sampler types.

   -  `GroundProjectedSkybox` has been replaced with `GroundedSkybox`.

   -  When using equirectangular environment maps, `WebGLRenderer` automatically 
      converts to the cube map format with a larger texture size now. This avoids 
      undersampling resulting in blurry output but it requires more memory. 
      If you encounter performance issues, decrease the resolution of your 
      equirectangular environment map.

   #🎨# r159 → r160

   -  `HBAOPass` has been replaced with `GTAOPass`.

   -  `Triangle.getBarycoord()` and `Triangle.getInterpolation()` now return `null` 
      if the triangle is degenerate. (For degenerate triangles, the `target` 
      parameter is set to the zero-vector).

   #🎨# r158 → r159

   -  `BatchedMesh.applyGeometry()` has been replaced with `addGeometry()`.

   -  `BufferAttribute.updateRange` and `InterleavedBuffer.updateRange` have 
      been replaced with `updateRanges`. You can manage multiple update ranges 
      with the new methods `addUpdateRange()` and `clearUpdateRanges()`.

   -  `SkinnedMesh` is not supported with WebGL 1 anymore.

   #🎨# r157 → 158

   -  `Quaternion`s are now expected to be normalized.
   -  The material property `bumpScale` is now invariant to the scale of texture 
      coordinates. That means bump maps look now the same regardless of the 
      texture UV scale in world space. If you are using bump mapping, you 
      likely have to update the `bumpScale` value to achieve a similar look 
      like before. More details in https://github.com/mrdoob/three.js/pull/26899.

   #🎨# r156 → 157

   -  `AmbientLightProbe` and `HemisphereLightProbe` have been removed. 
      Use `AmbientLight` or `HemisphereLight`, instead.
   -  The GLSL struct `GeometricContext` has been removed from the GLSL code 
      base to make materials more compatible with Adreno mobile GPUs. When you 
      patch shaders via `onBeforeCompile()` or reuse shader chunks with custom 
      materials, you potentially have to remove references to `GeometricContext` 
      similar to https://github.com/mrdoob/three.js/pull/26805.
   -  `AnimationUtils.arraySlice()` has been removed. Internal code uses the 
      native `TypedArray.slice()` method instead.

   #🎨# r155 → 156

   -  The constructor of `FilmPass` has been changed. The parameters `scanlinesIntensity` 
      and `scanlinesCount` have been removed.
   -  The constructor of `SAOPass` has been changed. The parameters `useDepthTexture` 
      and `useNormals` have been removed.
   -  `SSAOPass` requires now the usage of a prior `RenderPass`.

   #🎨# r154 → 155

   -  `WebGLRenderer.useLegacyLights` is now set to `false` by default and deprecated. 
      Please read the following topic at the three.js forum for more information: 
      `Updates to lighting in three.js r155  <https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733>`__
   -  The inline tone mapping controlled via `WebGLRenderer.toneMapping` only works 
      when rendering to screen now (similar to `WebGLRenderer.outputColorSpace`). 
      In context of post processing, use `OutputPass` to apply tone mapping and 
      color space conversion.
   -  The constructor of `OutputPass` has no parameters anymore. Color space and 
      tone mapping settings are now extracted from the renderer.

   #🎨# r153 → 154

   -  The shader chunk `encodings_fragment` has been renamed to `colorspace_fragment`.
   -  The shader chunk `output_fragment` has been renamed to `opaque_fragment`.

   #🎨# r152 → 153

   -  WebGL 1 support in `WebGLRenderer` is now deprecated and will be removed in r163.
   -  The default render target texture type in context of post-processing 
      (`EffectComposer`) is now `THREE.HalfFloatType`.
   -  `AdaptiveToneMappingPass` has been removed. Consider to use the new 
      `OutputPass` for tone mapping and color space conversion.
   -  `ColladaExporter` has been removed.
   -  `PRWMLoader` has been removed.
   -  `LightningStrike` and `LightningStorm` have been removed.
   -  `CubeTextureLoader` loads cube textures in sRGB color space by default now.

   #🎨# r151 → 152

   -  The naming convention of `uv` buffer attributes has been changed. 
      `uv`, `uv2`, `uv3` and `uv4` are now `uv`, `uv1`, `uv2` and `uv3`.
   -  `WebGLRenderer.outputEncoding` has been replaced with `WebGLRenderer.outputColorSpace` 
      with `THREE.SRGBColorSpace` as the default value.
   -  `Texture.encoding` has been replaced with `Texture.colorSpace` with 
      `THREE.NoColorSpace` as the default value.
   -  `THREE.sRGBEncoding` is now `THREE.SRGBColorSpace`.
   -  `THREE.LinearEncoding` is now `THREE.LinearSRGBColorSpace`.
   -  `THREE.ColorManagement.enabled` is now `true` by default.
   -  It's now necessary to define the `renderOrder` property for loaded shapes via `SVGLoader`.

   _For more information, please see the `Updates to Color Management in three.js r152 
   <https://discourse.threejs.org/t/updates-to-color-management-in-three-js-r152/50791>`__ guide._

   #🎨# r150 → 151

   -  `Float16BufferAttribute` now automatically converts values to and from 
      half float in its setters/getters.
   -  `SkinnedMesh.boneTransform()` has been renamed to `applyBoneTransform()`.
   -  `InstancedMesh.frustumCulled` is now `true` by default since `InstancedMesh` 
      now supports bounding volume computations. If you update the transformation 
      of your instances, make sure to call `computeBoundingSphere()` to recompute 
      the bounding sphere which is required for correct view frustum culling and 
      ray casting. 
   -  `MapControls` is now located in its own module file `three/addons/controls/MapControls.js`.
   -  Tween.js is now imported via `import TWEEN from 'three/addons/libs/tween.module.js';`.
   -  `Triangle.getUV()` has been renamed to `Triangle.getInterpolation()`.
   -  `GroundProjectedEnv` has been renamed to `GroundProjectedSkybox`.
   -  `BufferGeometryUtils.mergeBufferAttributes()` has been renamed to `BufferGeometryUtils.mergeAttributes()`.
   -  `BufferGeometryUtils.mergeBufferGeometries()` has been renamed to `BufferGeometryUtils.mergeGeometries()`.
   -  The editor now uses the physically correct lighting mode (`WebGLRenderer.useLegacyLights = false`).
   -  `Points` now supports texture coordinates. When a `uv` attribute is present 
      in the geometry, the shader will use it to sample the color or alpha value 
      from `map` or `alphaMap` for a single point. Without a `uv` attribute, point 
      clouds are rendered as before. 
   -  `ShaderMaterial.forceSinglePass` is now `true` by default.
   -  `aoMap` and `lightMap` no longer use `uv2`. Set `material.lightMap.channel` 
      to `0` for `uv` and `1` for `uv2`. Consequently, the `uv2_*` shader chunks 
      have been removed.

   #🎨# r149 → 150

   -  The build files `build/three.js` and `build/three.min.js` are deprecated 
      with r150+, and will be removed with r160. Please use ES Modules or 
      alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation
   -  `BasisTextureLoader` has been removed. Use Basis Universal compression in 
      KTX2 (.ktx2) files with `KTX2Loader` instead.
   -  `ColorManagement.legacyMode=false` is now `ColorManagement.enabled=true`.
   -  `WebGLRenderer.physicallyCorrectLights = true` is now `WebGLRenderer.useLegacyLights = false`.

   #🎨# r148 → 149

   -  `Euler.DefaultOrder` has been renamed to `Euler.DEFAULT_ORDER`.
   -  `Euler.RotationOrders` has been removed.
   -  `Object3D.DefaultUp` has been renamed to `Object3D.DEFAULT_UP`.
   -  `Object3D.DefaultMatrixAutoUpdate` has been renamed to `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
   -  `Object3D.DefaultMatrixWorldAutoUpdate` has been renamed to `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
   -  `ViewHelper.controls` has been removed. Use the new `center` property to 
      define the helper's center.
   -  `THREE.TwoPassDoubleSide` has been removed. Double-sided, transparent 
      materials are now rendered with two draw calls by default. This behavior 
      can be disabled by setting `Material.forceSinglePass` to `true`.

   #🎨# r147 → 148

   -  The `examples/js` directory has been removed. Addons like `GLTFLoader` or 
      `OrbitControls` are now only available as ES6 modules in the `examples/jsm` 
      directory. Certain library files from `examples/js/libs` are moved to 
      `examples/jsm/libs`. Users of ammo.js, Draco and Basis have to update 
      their import paths (e.g. from `/examples/js/libs/draco/` to `/examples/jsm/libs/draco/`). 
      Also check out the `Installation  <https://threejs.org/docs/index.html#manual/en/introduction/Installation>`__ 
      guide in the documentation if you are using ES6 modules for the first time.
   -  The default `radial` values of `CircleGeometry`, `RingGeometry`, `CylinderGeometry`, 
      `ConeGeometry` and `TorusGeometry` have been increased.
   -  `GLTFLoader` now ensures the node order in loaded scenes matches the node 
      order in the glTF asset.
   -  `Material.side = DoubleSide` no longer renders a transparent object in 
      separate front and back passes. Use `TwoPassDoubleSide` for two-pass 
      transparent rendering.

   #🎨# r146 → 147

   -  The `decay` property of `PointLight` and `SpotLight` has now a physically 
      correct default value (`2`). This change will affect all scenes using 
      point and spot lights with no defined `decay`. Set the property back to 
      `1` if you want to restore the previous behavior.
   -  `BufferAttribute.onUploadCallback()` is now executed every time buffer 
      data are transferred to the GPU.
   -  Support for the `KHR_materials_pbrSpecularGlossiness` extensions has been 
      removed from `GLTFLoader` and `GLTFExporter`. Older glTF assets should be 
      losslessly `converted from spec/gloss to metal/rough  
      <https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough/>`__.
   -  `PixelShader` has been removed. Use `postprocessing/RenderPixelatedPass` instead.
   -  `numConstructionSteps` and `constructionStep` of `LDrawLoader` have been 
      renamed to `numBuildingSteps` and `buildingStep`.

   #🎨# r145 → 146

   -  The `resolution` constructor parameter of `BloomPass` has been removed.
   -  The `width` and `height` settings of the `params` constructor parameter 
      of `BokehPass` have been removed.
   -  `BufferGeometryUtils.mergeBufferGeometries()` does not honor 
      `BufferGeometry.userData` anymore.
   -  The `cube` shader in `ShaderLib` has different uniforms now. `envMap` 
      is now `tCube`, `flipEnvMap` is now `tFlip` and all other uniforms 
      except of `opacity` have been removed.

   #🎨# r144 → 145

   -  The `truncateDrawRange` option has been removed from `GLTFExporter.parse()`.
   -  `FlyControls` and `FirstPersonControls` have been moved to Pointer Events API.
   -  The `BufferGeometry` alias for geometry generators has been deprecated. 
      Use e.g. `BoxGeometry` instead of `BoxBufferGeometry`.

   #🎨# r143 → 144

   -  `BufferGeometry.merge()` has been removed. 
      Use `BufferGeometryUtils.mergeBufferGeometries()` instead.
   -  `copyColorsArray()`, `copyVector2sArray()`, `copyVector3sArray()` and 
      `copyVector4sArray()` have been removed from `BufferAttribute`.
   -  `MeshLambertMaterial` now uses per-fragment shading. Use the new 
      `MeshGouraudMaterial` in `examples/jsm/materials` if you need per-vertex shading.
   -  `BufferAttribute` getters and setters (`getX`, `setX`, etc) now respect 
      the normalized flag and transform values to and from normalized values 
      when reading and writing to the underlying array.
   -  `Scene.autoUpdate` has been replaced with `Object3D.matrixWorldAutoUpdate`.
   -  The `noHoles` parameter of `ShapePath.toShapes()` has been removed.

   #🎨# r142 → 143

   -  When importing `AnimationUtils` from `src/animation/AnimationUtils.js` 
      (instead of `three.module.js`), the import is now 
      `import * as AnimationUtils from '/src/animation/AnimationUtils.js';`.
   -  `PCDLoader` now always uses white as the default material color.

   #🎨# r141 → 142

   -  When importing `DataUtils` from `src/extras/DataUtils.js` (instead of 
      `three.module.js`), the import is now 
      `import * as DataUtils from '/src/extras/DataUtils.js';`.

   #🎨# r140 → 141

   -  The `embedImages` option of `GLTFExporter.parse()` has been removed. 
   -  Legacy code is going to be removed from the core after ten releases now. 
      If you plan to upgrade `three.js` in an existing project, try to avoid 
      too large upgrade steps. For example don't upgrade from `r70` to `r140` 
      but do it in a more incremental fashion instead (`r70` -> `r80` -> `r90` etc.).
   -  The parameter `selectionBox` has been removed from `SelectionHelper`'s constructor.
   -  The default `type` of `DepthTexture` is now `UnsignedIntType`.
   -  The `url` parameter of `PCDLoader.parse()` has been removed. The loader does 
      not extract the file name from the URL anymore.
   -  The deprecated `Geometry` class has been removed. 

   #🎨# r139 → 140

   -  `SkinnedMesh` requires floating point vertex textures now.
   -  The `fog` property has been moved from the abstract `Material` class to 
      materials which actually support it.

   #🎨# r138 → 139

   -  `CubeUVRefractionMapping` and `MeshStandardMaterial.refractionRatio` have 
      been removed. Use the transmission related properties of `MeshPhysicalMaterial`
      if you want to model refraction with a PBR material.

   #🎨# r137 → 138

   -  `WebGLMultisampleRenderTarget` has been removed. To use multisampling as before, 
      use `WebGLRenderTarget` and set the new `samples` property to a value greater `0`.
   -  The node material in `examples/jsm/nodes` has been replaced with a new implementation.
   -  `ColladaLoader`, `KMZLoader` and `PLYLoader` require a sRGB workflow now.
   -  `OBJExporter`, `ColladaExporter` and `PLYExporter` produce assets with sRGB encoded colors now.
   -  `VRMLoader` has been removed. Use `three-vrm  <https://github.com/pixiv/three-vrm>`__ instead.
   -  The second argument of `GLTFLoader`'s `parser.loadTextureImage()` has been 
      changed from image source definition to image source index.
   -  `Euler.toVector3()` has been removed. Use `Vector3.setFromEuler()` instead.
   -  `DataTexture3D` has been renamed to `Data3DTexture`.
   -  `DataTexture2DArray` has been renamed to `DataArrayTexture`.
   -  `WebGLRenderTarget.setTexture()` has been removed.
   -  The import of `CurveExtras` has been changed. It is now `import * as Curves from ...` 
      instead of `import { Curves } from ...`.

   #🎨# r136 → 137

   -  `WebGLRenderer` now creates the WebGL context with an alpha channel 
      regardless of the value of `alpha` passed in the constructor. However, 
      the value of `alpha` is still used by the renderer when clearing the 
      context first thing every frame.
   -  `RGBFormat` has been removed. Please use `RGBAFormat` instead.
   -  `RGBIntegerFormat` has been removed. Please use `RGBAIntegerFormat` instead.
   -  `UnsignedShort565Type` has been removed. Please use `UnsignedShort5551Type` instead.
   -  `BasisTextureLoader` has been deprecated. Please use `KTX2Loader` instead.
   -  The `SRGB8_ALPHA8_ASTC*` texture formats have been removed. If you want to 
      use sRGB ASTC formats, use the regular `RGBA_ASTC_*` formats and set the 
      `encoding` texture property to `sRGBEncoding`.
   -  With WebGL 2 uncompressed sRGB encoded textures have to use the `RGBAFormat` 
      with `UnsignedByteType` now.
   -  `RoughnessMipmapper` has been removed.
   -  `Material.format` has been removed.
   -  `GLTFExporter` does not support `RGBFormat` anymore. Please use `RGBAFormat` instead.
   -  The default texture format of `VideoTexture` is now `RGBAFormat` (instead of `RGBFormat`).
   -  sRGB decode in GLSL has been removed. sRGB texture always have to use 
      `RGBAFormat` + `UnsignedByteType` format now.
   -  The ES6 import of `three.js` and `examples/jsm` modules in web sites now 
      requires the usage of an import map to resolve the `three` bare import specifier.
   -  The ES6 import of `examples/jsm` and `examples/fonts` in certain bundlers 
      like esbuild now requires an extension on filenames.
   -  `OBJ/MTLLoader` requires a sRGB workflow now.
   -  Changing `Material.transparent` after its initial use requires setting `needsUpdate` to `true`.

   #🎨# r135 → 136

   -  HDR workflows with WebGL 1 now require half float texture extension support
      (`OES_texture_half_float/OES_texture_half_float_linear`).
   -  If you create an instance of `DataTexture`, `DataTexture2DArray` or 
      `DataTexture3D`, you have to set `needsUpdate` to `true` as soon as the 
      texture data are ready.
   -  `WebGLRenderer.copyFramebufferToTexture()` has to be used with the new 
      class `FramebufferTexture` now.
   -  ETC1 texture compression can now only be used with a WebGL 1 rendering context.
   -  The `keydown` event listener of `ArcballControls` has been removed. You have 
      to implement it on app level if necessary.
   -  `ArcballControls.setTarget()` has been removed. Update the `target` property instead.
   -  When changing `WebGLRenderer.toneMapping`, it is no longer necessary to set 
      `Material.needsUpdate` to `true`.
   -  `EXRLoader` no longer supports the data type `UnsignedByteType`. Use the 
      default data type `HalfFloatType` instead.
   -  `PMREMGenerator` now uses half float render targets internally, and no 
      longer uses `RGBEEncoding`.
   -  `RGBM7Encoding` and `RGBM16Encoding` have been removed. It is still 
      possible to load RGBM texture as FP16 or FP32 textures. The default 
      `type` is `HalfFloatType`.
   -  `RGBEEncoding` and `RGBEFormat` have been removed. `RGBELoader` and 
      `HDRCubeTextureLoader` no longer support the data type `UnsignedByteType`. 
      It is still possible to load RGBE texture as FP16 or FP32 textures. 
      The default `type` is `HalfFloatType`.
   -  `RGBDEncoding` has been removed.
   -  `WebGLRenderer.gammaFactor` and `THREE.GammaEncoding` have been removed. 
      Please use post processing (a gamma correction pass) if you need a special 
      gamma color space.

   #🎨# r134 → 135

   -  `dat.gui` has been replaced with `lil-gui`.
   -  The dimensions, format and type of a texture cannot be changed after the initial use now.
   -  `GLTFExporter.parse()` has a new signature. The third parameter is now an 
      error callback. The exporter options are now passed in as the fourth argument.
   -  `LogLuvEncoding` has been removed. Please use the new `LogLuvLoader` 
      for loading Logluv TIFF HDR images as (half precision) floating point textures.

   #🎨# r133 → 134

   -  `DeviceOrientationControls` has been removed.
   -  `ImmediateRenderObject` has been removed.
   -  `OrbitControls` no longer supports zooming (via mouse wheel) while rotating.
   -  `FileLoader` now uses `fetch` instead of `XMLHttpRequest`.

   #🎨# r132 → 133

   -  The `recursive` parameter of `Raycaster.intersectObject()` and 
      `Raycaster.intersectObjects()` is now `true` by default.
   -  Some default values of `ExtrudeGeometry`'s parameters have changed. 
      `depth` is now `1`, `bevelThickness` is now `0.2` and `bevelSize` is 
      now `bevelThickness - 0.1`. 
   -  `ParametricGeometry` has been removed from core. It is now located in 
      `examples/jsm/geometries/ParametricGeometry.js`.
   -  `TextGeometry` has been removed from core. It is now located in 
      `examples/jsm/geometries/TextGeometry.js`.
   -  `FontLoader` and `Font` have been removed from core. Both classes 
      are now located in `examples/jsm/loaders/FontLoader.js`.

   #🎨# r131 → 132

   -  `BufferGeometryUtils` is now imported using this pattern: 
      `import * as BufferGeometryUtils from './jsm/utils/BufferGeometryUtils.js';`
   -  `KTX2Loader` requires an updated version of the Basis Universal transcoder 
      from `examples/js/libs/basis  <https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/basis>`__
   -  `MeshPhysicalMaterial.sheen` has been renamed to `sheenTint`.
   -  `BufferGeometry.computeFaceNormals()` has been removed. The method was 
      not implemented and just a stub. Calling it did not affect the geometry.
   -  `MeshStandardMaterial` and `MeshPhysicalMaterial` shaders are now more 
      correct and may result in less shiny renders for models using rough materials.

   #🎨# r130 → 131

   -  The `morphTargets` and `morphNormals` property of materials has been removed.
   -  `MeshStandardMaterial.vertexTangents` has been removed.
   -  The default `widthSegments` and `heightSegment` properties of `SphereGeometry` 
      have been increased to `32` and `16`.
   -  The default type of textures loaded with `RGBELoader`, `HDRCubeTextureLoader` 
      and `EXRLoader` is now `THREE.HalfFloatType`.
   -  The `envMap` property of `MeshStandardMaterial` and `MeshPhysicalMaterial` 
      is now internally converted to a PMREM. It might be necessary to update 
      the scene's lighting if no PMREM was previously used.

   #🎨# r129 → 130

   -  Controls no longer call `preventDefault()` on pointer and mouse events.
   -  `DragControls`, `OrbitControls` and `TrackballControls` now use pointer 
      events for touch interaction.

   #🎨# r128 → 129

   -  The backward compatibility for the deprecated third and forth arguments 
      `renderTarget` and `forceClear` of `WebGLRenderer.render()` has been removed.

      - Use `WebGLRenderer.setRenderTarget()` and `WebGLRenderer.clear()` instead.

   -  The `skinning` property of materials has been removed.

      - The same material can now be reused between `Mesh` and `SkinnedMesh`.
     
   -  `Matrix4.makeShear()` has a new signature. Please make a note of it.

   #🎨# r127 → 128

   -  All central engine components like `Object3D`, `BufferGeometry` or 
      `ShaderMaterial` are now ES6 classes.

     -   This might impact your application if you derive custom classes from 
         `three.js` classes via ES5 syntax. In this case, you have to upgrade 
         your code to ES6 or transpile `three.js` to ES5. 

   -  The JavaScript code in `examples/js` generated from modules in 
      `examples/jsm` is now based on ES6.

     -   If you need ES5 code in your project, update the configuration in 
         `.babelrc.json  <https://github.com/mrdoob/three.js/blob/dev/utils/build/.babelrc.json>`__ 
         and regenerate `examples/js` by using `npm run build-examples`. 
         However, the better solution is to upgrade your code to ES6.

   -  NPM: ES6 modules in `examples/jsm` now import using the bare specifier `three`.

     -   This change breaks working with modules in cdns such as https://www.jsdelivr.com/ 
         and https://unpkg.com/. Please use https://www.skypack.dev/ instead.

   -  `XLoader` has been removed.


   #🎨# r126 → r127

   -  Controls no longer use `stopPropagation()` in their event listeners. 
      In certain use cases event listeners on application level are now able 
      to process events (which was not possible before).
   -  `Scene.background` no longer supports instances of `WebGLCubeRenderTarget`. 
      Please assign the `texture` property of render targets.
   -  `WebGLRenderer.setFramebuffer()` has been removed.
   -  `AssimpLoader` has been removed.
   -  `Plane.intersectLine()` now returns `null` when no intersection was found.
   -  `WebGLRenderer.maxMorphTargets` and `WebGLRenderer.maxMorphNormals` have been removed.
   -  When using `EventDispatcher`, `event.target` is only valid for the duration 
      of the listener callback now.

   #🎨# r125 → r126

   -  TypeScript type declaration files have been moved to `three-types/three-ts-types 
       <https://github.com/three-types/three-ts-types>`__.
   -  `Face3` has been removed from core. It is now located in `examples/jsm/deprecated/Geometry.js`.
   -  `Ocean` and `OceanShaders` have been removed.
   -  `polyfills.js` has been removed. The polyfills for `Array.from()`, `Function.name`, 
      `Number.EPSILON`, `Number.isInteger`, `Math.log2`, `Math.sign` and `Object.assign()` 
      need to be added at application level for IE11 support: `misc_legacy  
      <https://github.com/mrdoob/three.js/blob/4d90e23c8f1663842f789bf2b19638719134075c/examples/misc_legacy.html#L11>`__.
   -  `CSS3DRenderer` no longer supports IE11.
   -  `WebGLRenderer` now sets `gl.UNPACK_COLORSPACE_CONVERSION_WEBGL` to `gl.NONE`. 
      Embedded color space data (ICC-profiles) in texture images will now be ignored.

   #🎨# r124 → r125

   -  `Geometry` has been removed from the core. It is now located in 
      `examples/jsm/deprecated/Geometry.js`.
   -  Geometry generators like `BoxGeometry` now produce a `BufferGeometry`.
   -  `Mesh`, `Line` and `Points` no longer support raycasting with `Geometry`.
   -  `Line.computeLineDistances()` no longer supports `Geometry`.
   -  Exporters no longer support `Geometry`.
   -  `DecalGeometry`, `EdgesGeometry`, `WireframeGeometry`, `Projector`, 
      `LineGeometry`, `LineSegmentsGeometry`, `ConvexHull`, `EdgeSplitModifier` 
      and `TessellateModifier ` no longer support `Geometry`.
   -  `ConvexBufferGeometry` has been removed. Similar to `DecalGeometry`, 
      `ConvexGeometry` is now derived from `BufferGeometry`.
   -  `TeapotBufferGeometry` has been renamed to `TeapotGeometry`.
   -  `RoundedBoxBufferGeometry` has been renamed to `RoundedBoxGeometry`.
   -  `3MFLoader`, `AMFLoader`, `EXRLoader`, `FBXLoader`, `KMZLoader`, `NRRDLoader`, 
      `TiltLoader` and `VTKLoader` now depend on `fflate`. Other decompression 
      libs (`JSZip` and `ZLib`) are no longer used.
   -  `SubdivisionModifier` has been removed.
   -  `SimplifyModifier` no longer supports `Geometry` and now relies on `BufferGeometryUtils`.
   -  `OBJLoader2` has been removed. If you still need it, use this 
      `repository  <https://github.com/kaisalmen/WWOBJLoader>`__.
   -  `OrbitControls` no longer listens to key events by default. You have to 
      call `OrbitControls.listenToKeyEvents()` if your app requires key controls.
   -  `BufferGeometryUtils.computeTangents()` has been moved into the core. 
      You can now use `BufferGeometry.computeTangents()`.
   -  `RectAreaLightHelper.update()` has been removed.

   #🎨# r123 → r124

   -  `ColladaLoader` stores animation clips in `collada.scene.animations` now.
   -  `WebGLRenderer.getClearColor()` now expects a target argument.
   -  `TypedArrayUtils` and `webgl_nearestneighbour` demo have been removed.
   -  The converter scripts `fbx2three` and `obj2three` have been removed.

   #🎨# r122 → r123

   -  `Matrix3/4.getInverse()` has been deprecated. Please use the new method 
      `.invert()` with this pattern: `matrixInv.copy( matrix ).invert();`.
   -  `Quaternion.inverse()` has been renamed to `Quaternion.invert()`.
   -  The option `forcePowerOfTwoTextures` has been removed from `GLTFExporter`.
   -  The first parameter of `DRACOExporter.parse()` is now of type `Mesh` or `Points`.
   -  `DragControls` now use Pointer Events. This change might require that you 
      move your custom event listeners to Pointer Events, too.

   #🎨# r121 → r122

   -  `ExplodeModifier` has been removed.
   -  `Fire` and the respective `webgl_fire` example have been removed.

   #🎨# r120 → r121

   -  The `detail` parameter of `PolyhedronGeometry` is now more fine-grained. 
      Meaning it can produce now more different subdivisions.
   -  `LightShadow` has been removed from the public API. If you need to configure 
      a custom shadow frustum for spot lights, use the new `SpotLightShadow.focus` property.
   -  Geometry generator classes are now located in their own files. For example 
      `BoxGeometry` and `BoxBufferGeometry` no longer share a single file and are 
      now located in `src/geometries/BoxGeometry.js` and `src/geometries/BoxBufferGeometry.js`.
   -  `WebGLCubeRenderTarget.texture` is now of type `CubeTexture`.
   -  `TimelinerController` and the respective example `misc_animation_authoring` have been removed.
   -  `TypedGeometryExporter` has been removed.
   -  A performance improvement for `DRACOLoader` required an update of the DRACO library.

   #🎨# r119 → r120

   -  `Scene.dispose()` has been removed.
   -  `WebGLRenderTarget.stencilBuffer` and `WebGLCubeRenderTarget.stencilBuffer` 
      are now false by default. Enable the buffer by setting `stencilBuffer: true` 
      in the constructor options.
   -  When using `ShaderMaterial` and `RawShaderMaterial`, it's now necessary to 
      set the new `glslVersion` property to `THREE.GLSL3` if you want to write 
      GLSL 3.0 shader code. The GLSL version directive is not allowed in custom 
      shader code anymore. It's always added automatically by the engine.
   -  `SpotLightShadow` and `DirectionalLightShadow` have been removed from the public API.
   -  `CannonPhysics` has been removed.
   -  `OrbitControls`, `TrackballControls` and `TransformControls` now use 
      Pointer Events. This change might require that you move your custom event 
      listeners to Pointer Events, too.

   #🎨# r118 → r119

   -  `MeshPhysicalMaterial.transparency` has been renamed to `MeshPhysicalMaterial.transmission`.

   #🎨# r117 → r118

   -  `SphericalReflectionMapping` is no longer supported. Consider using a Matcap 
      texture with `MeshMatcapMaterial` instead.
   -  `WebGLRenderer.toneMappingWhitePoint` has been removed.
   -  `Uncharted2ToneMapping` has been removed. However, it's now possible to 
      define your own custom tone mapping function by using `CustomToneMapping`. 
      Check out the `tone mapping example  <https://threejs.org/examples/webgl_tonemapping>`__ 
      for more information.
   -  `WebGLRenderer` automatically creates a WebGL 2 rendering context now 
      (and fallbacks to WebGL 1 if necessary). If your project can only use WebGL 1, 
      you can use `WebGL1Renderer  <https://threejs.org/docs/index.html#api/en/renderers/WebGL1Renderer>`__.
   -  The default value of `OrbitControls.screenSpacePanning` is now `true`.
   -  `Water` can only be used when setting `WebGLRenderer.outputEncoding` to `THREE.LinearEncoding`.
   -  `shininess`, `specular` and `specularMap ` have been removed from `MeshToonMaterial`.

   #🎨# r116 → r117

   -  The TypeScript declaration for `Texture.mipmaps` is now `any[]` instead of `ImageData[]`.
   -  `InstancedBufferGeometry.maxInstancedCount` has been renamed to `InstancedBufferGeometry.instanceCount`.
   -  The constructor of `CubeCamera` has changed. It now expects an instance of
       WebGLCubeRenderTarget as third parameter. The fourth parameter `options` has been removed.

   #🎨# r115 → r116

   -  The default value of `WebGLRenderer.toneMapping` is now `NoToneMapping`.
   -  `Sphere.empty()` has been renamed to `Sphere.isEmpty()`.
   -  `TranslucentShader` has been renamed to `SubsurfaceScatteringShader`.
   -  `PDBLoader` no longer returns raw bonds data in the JSON result.
   -  The `options` parameter of `VRButton.createButton()` has been removed. 
      Please set the reference space type via `WebGLRenderer.xr.setReferenceSpaceType()` instead.

   #🎨# r114 → r115

   -  The `throwOnDegenerate` parameter of `Matrix3.getInverse()` and 
      `Matrix4.getInverse()` has been removed. In addition, the methods now return 
      the zero matrix if one tries to invert a matrix having a determinant of zero.
   -  The TypeScript declaration for `Geometry.boundingBox` and `Geometry.boundingSphere` 
      is now nullable, as it actually be.
   -  The shader syntax `#pragma unroll_loop` is now deprecated. 
      Use `#pragma unroll_loop_start/end  <https://threejs.org/docs/index.html#api/en/materials/ShaderMaterial>`__ instead.

   #🎨# r113 → r114

   -  `Material.vertexColors` is now a boolean. The default value is `false`.
   -  `Raycaster` honors now invisible 3D objects in intersection tests. 
      Use the new property `Raycaster.layers  <https://threejs.org/docs/index.html#api/en/core/Raycaster.layers>`__ 
      for selectively ignoring 3D objects during raycasting.
   -  `GLTFLoader` now returns an instance of `Group` instead of `Scene`.
   -  `GLTFLoader` now sets `depthWrite` to `false` for transparent materials.
   -  The `OBJ` and `FBX` converters now require the 
      `esm  <https://www.npmjs.com/package/esm>`__ npm package.

   #🎨# r112 → r113

   -  `Math` has been renamed to `MathUtils`, and `/examples/js/utils/MathUtils.js` 
      has been promoted to the core.
   -  `WebGLRenderTargetCube` has been renamed to `WebGLCubeRenderTarget`, and the 
      constructor signature is now `WebGLCubeRenderTarget( size, options )`.
   -  `Geometry.applyMatrix()` has been renamed to `Geometry.applyMatrix4()`.
   -  `BufferGeometry.applyMatrix()` has been renamed to `BufferGeometry.applyMatrix4()`.
   -  `Object3D.applyMatrix()` has been renamed to `Object3D.applyMatrix4()`.
   -  `LineSegmentsGeometry.applyMatrix()` has been renamed to `LineSegmentsGeometry.applyMatrix4()`.
   -  `Frustum.setFromMatrix()` has been renamed to `Frustum.setFromProjectionMatrix()`.
   -  `RaytracingRenderer` has been removed.
   -  `WebGLDeferredRenderer` has been removed.
   -  `GammaCorrectionShader` converts to `sRGB` now. 
   -  The color of the default material for `Mesh`, `Points`, `Line`, and all 
      derived classes, is now white.

   #🎨# r111 → r112

   -  `PMREMGenerator` has a new implementation and is now part of the core library. 
      Check out the `webgl_loader_gltf  <https://raw.githack.com/mrdoob/three.js/dev/examples/webgl_loader_gltf.html>`__ 
      example to understand the new workflow.
   -  `WebGLRenderer.gammaInput` has been removed.  Set the encoding for textures 
      via `Texture.encoding` instead.
   -  `WebGLRenderer.gammaOutput` has been removed. Please use 
      `WebGLRenderer.outputEncoding` instead.
   -  `MeshToonMaterial` does not support environment maps anymore.
   -  `Mesh.drawMode` and `Mesh.setDrawMode()` have been removed. `WebGLRenderer` 
      does render meshes always with `THREE.TrianglesDrawMode` now. 
      Please use `BufferGeometryUtils.toTrianglesDrawMode()` to transform 
      `THREE.TriangleStripDrawMode` and `THREE.TriangleFanDrawMode` of existing 
      geometries to `THREE.TrianglesDrawMode`.
   -  `TerrainShader`, `SkinShader` and `CarControls` have been removed.
   -  `WebVR` support has been removed. Please use `WebXR` instead.
   -  The default value of `MeshStandardMaterial.roughness` has changed from `0.5` to `1`.
   -  The default value of `MeshStandardMaterial.metalness` has changed from `0.5` to `0`.
   -  `FaceNormalsHelper`, `LightProbeHelper`, `PositionalAudioHelper`, `RectAreaLightHelper`, 
      `VertexNormalsHelper` and `VertexTangentsHelper` are now part of the examples.
   -  Instances of `BufferGeometry` require at least a position attribute _or_ index now.

   #🎨# r110 → r111

   -  The semantics of `Material.needsUpdate` has changed. Setting it to `true` 
      now increases the internal version counter (similar to `Texture` or 
      `BufferAttribute`). It's not possible anymore to use `Material.needsUpdate` 
      in conditional statements.
   -  `LegacyGLTFLoader` and `LegacyJSONLoader` have been removed.
   -  `WebVRManager.setPoseTarget()` has been removed.
   -  `WebVRManager` and `WebXRManager` do no longer modify the camera when not presenting.
   -  The default value of `Ray.direction` is now `( 0, 0, - 1)`.
   -  Instances of `BufferGeometry` require at least a position attribute now.

   #🎨# r109 → r110

   -  `BufferAttribute.dynamic` and `BufferAttribute.setDynamic()` have been 
      deprecated. Please use `BufferAttribute.usage` and `BufferAttribute.setUsage()` 
      instead.
   -  `BufferGeometry.addAttribute()` has been renamed to `BufferGeometry.setAttribute()`.
   -  `BufferGeometry.removeAttribute()` has been renamed to `BufferGeometry.deleteAttribute()`.
   -  `CubemapGenerator` has been removed. 
      Please use `WebGLRenderTargetCube.fromEquirectangularTexture()` instead.
   -  `EquirectangularToCubeGenerator` has been removed. 
      Please use `WebGLRenderTargetCube.fromEquirectangularTexture()` instead.
   -  The second constructor parameter `domElement` of `OrbitControls`, 
      `TrackballControls`, `TransformControls`, `FlyControls`, `PointerLockControls` 
      and `FirstPersonControls` is now mandatory.
   -  `OrbitControls` and `TrackballControls` do not support `document` as an 
      argument for `domElement` anymore. Please use the canvas element of the 
      renderer (`renderer.domElement`) instead.
   -  `Audio.startTime` has been removed. Please use `Audio.play( delay )` instead.
   -  When loading a `DataTexture` via `DataTextureLoader`, it's default `minFilter` 
      value is now `LinearFilter`.
   -  `AssimpJSONLoader` has been removed. Please use `AssimpLoader` instead.
   -  `SoftwareRenderer` has been removed.

   #🎨# r108 → r109

   -  `Loader.Handler` has been removed. Use `LoadingManager`'s `.addHandler()`, 
      `.removeHandler()` and `.getHandler()` instead.
   -  `BabylonLoader` has been removed.
   -  `PlayCanvasLoader` has been removed.
   -  `AWDLoader` has been removed.
   -  `SEA3DLoader` has been removed.
   -  `EditorControls` is now located in `editor/js`.
   -  `OrthographicTrackballControls` has been removed. `TrackballControls` now 
      supports orthographic cameras.
   -  `BufferAttribute.setArray()` has been removed.
   -  Displacement maps do not ignore the transformation of texture coordinates anymore.
   -  It's not necessary anymore to set `.needsUpdate` to `true` when creating 
      a `DataTexture` (assuming the data are provided at construction time as a
       constructor parameter).
   -  `BoxGeometry` and `BoxBufferGeometry` are now ES6 classes (except in 
      `three.js` and `three.min.js`).

   #🎨# r107 → r108

   -  `CTMLoader` has been removed.
   -  In `MeshPhysicalMaterial`, renamed `.clearCoat` to `.clearcoat` and 
      `.clearCoatRoughness` to `.clearcoatRoughness`.
   -  Removed `.initMaterials()` and `.createMaterial()` from `Loader`.
   -  The obsolete callbacks `onLoadStart()`, `onLoadProgress()` and `onLoadComplete()` 
      have been removed from `Loader`.
   -  `DRACOLoader.setDecoderPath()` and `DRACOLoader.setDecoderConfig()` are 
      now instance methods.

   #🎨# r106 → r107

   -  In the Texture Filter Constants, `MipMap` is now `Mipmap`.  For example, 
      `THREE.LinearMipMapLinearFilter` is now `THREE.LinearMipmapLinearFilter`.
      
   -  Renamed `WebGLRenderer.getActiveMipMapLevel()` to `WebGLRenderer.getActiveMipmapLevel()`.
   -  `WEBGL` (the namespace from `examples/js/WebGL.js`) is now in the `THREE` namespace.
   -  `WEBVR` (the namespace from `examples/js/vr/WebVR.js`) is now in the `THREE` namespace.
   -  The module `MapControls` is now part of `OrbitControls`. Check out the official 
      `example  <https://threejs.org/examples/misc_controls_map>`__ for more information.
   -  `OrbitControls` and `MapControls` now have a new default value for `dampingFactor`.
   -  `WebGLRenderer.context` has been removed. Please use `WebGLRenderer.getContext()` instead.

   -  `FBXLoader` now correctly sets the texture encoding. When using FBX assets in 
      your scene, you have to set `renderer.gammaOutput = true;` (unless you need 
      post-processing in linear colorspace).

   -  When loading an FBX asset with TGA textures, `FBXLoader` requires now the 
      following setup: `THREE.Loader.Handlers.add( /\.tga$/i, new TGALoader() );`.

   #🎨# r105 → r106

   -  All examples now use ES6 modules.
   -  `VRMLLoader` has a new implementation. It's necessary now to include 
      `chevrotain.min.js` into your code. Check out the `official example  
      <https://threejs.org/examples/webgl_loader_vrml.html>`__ for more details.

   -  The optional `update` arg has been removed from the public API of the 
      following methods: `Euler.setFromRotationMatrix( m, order )`, 
      `Euler.setFromQuaternion( q, order )`, and `Quaternion.setFromEuler( e )`.

   -  `GPUParticleSystem` has been removed.
   -  `DracoExporter` has been renamed to `DRACOExporter`.

   -  Objects of type `LOD` are now updated automatically by `WebGLRenderer`. 
      Set `LOD.autoUpdate` to `false` if you want to perform the update by yourself.

   -  MTL related functions like `.loadMtl()` have been removed from `OBJLoader2`. 
      Please use `MTLLoader` and `MtlObjBridge` as shown in basic obj2 example.

   -  `OBJLoader2` has been removed from `examples/js/loaders`. Please use 
      the module version in `examples/jsm/loaders`.

   #🎨# r104 → r105

   -  `WebGLRenderer.debug.checkShaderErrors` is now `true` by default.

   -  `EffectComposer.setSize()` now respects the pixel ratio. An instance 
      of `EffectComposer` can now be resized with the same `width` and `height` 
      values like `WebGLRenderer`.

   -  Renamed `QuickHull` to `ConvexHull`. The file is now located in `examples/js/math`.
   -  `SimplexNoise` and `ImprovedNoise` are now in the `THREE` namespace 
      and located in `examples/js/math`.
   -  `AnimationClipCreator` and `TimelinerController` are now located in `examples/js/animation`.
   -  `ParametricGeometries ` is now located in `examples/js/geometries`.
   -  `hilbert2d` and `hilbert3D` were removed. Please use `GeometryUtils.hilbert2D()` 
      and `GeometryUtils.hilbert3D()` instead.

   #🎨# r103 → r104

   -  For performance reasons, `WebGLRenderer` does no longer perform error 
      checking and reporting when shader programs are being compiled. You have 
      to set `renderer.debug.checkShaderErrors` to `true` to restore the previous behavior.

   -  `Object3D.applyMatrix()` now updates the local matrix if 
      `Object3D.matrixAutoUpdate` is set to `true`.

   #🎨# r102 → r103

   -  The `npm` script `npm run editor` was removed. The editor is now a 
      Progressive Web App (PWA).

   -  The callback parameter of `SVGLoader.onLoad()` is now an object (`data`) 
      containing the root node of the SVG document and an array of `ShapePath` 
      objects. Also, all paths are returned now (not only the ones with `fill` color)

   -  Removed `.allocTextureUnit()`, `.setTexture2D()`, `.setTexture()` and 
      `.setTextureCube()` from `WebGLRenderer`. These methods were never intended 
      to be part of `WebGLRenderer`'s public API and are now private (as a part of `WebGLTexture`).

   #🎨# r101 → r102

   -  Removed `renderTarget` and `forceClear` parameters from `WebGLRenderer.render()`. 
      Please use `.setRenderTarget()` and `.clear()` instead before you perform 
      the rendering. Be aware that it's now necessary to execute 
      `renderer.setRenderTarget( null )` in order to unset an active render target.

   -  Removed `.activeCubeFace` and `.activeMipMapLevel` from `WebGLRenderTargetCube`. 
      They are now parameters of `WebGLRenderer.setRenderTarget()`.

   -  In `WebGLRenderer.setViewport()` and `WebGLRenderer.setScissor()`, `(x, y)` 
      is the coordinate of the _lower left_ corner of the rectangular region.

   -  `WebGLRenderer.getSize()` now requires a `Vector2` argument.
   -  `WebGLRenderer.getCurrentViewport()` now requires a `Vector4` argument.

   #🎨# r100 → r101

   -  Added `FirstPersonControls.lookAt()`. `lat`, `lon`, `phi`, `theta` and 
      `target` were removed from the public API. `FirstPersonControls` also 
      respects the initial camera orientation now.

   -  `MeshStandardMaterial` and `MeshPhysicalMaterial` now preserve energy 
      for IBL lighting, resulting in brighter, more accurate colors for metallic 
      materials with high roughness values when lit via a map generated by PMREMGenerator.

   #🎨# r99 → r100

   -  `Octree` has been removed.
   -  Removed `Geometry` support from `Mesh.updateMorphTargets()`. Use `BufferGeometry` instead.
   -  The default orientation of `RectAreaLight` has changed. It now looks along the negative z-axis.

   #🎨# r98 → r99

   -  `WebGLRenderTarget.texture.generateMipmaps` is now set to `false` by default.
   -  There is a new (not backwards compatible) implementation for `SSAOShader` and `SSAOPass`.
   -  `JSONLoader` has been removed from core. It is now located in 
      `examples/js/loaders/deprecated/LegacyJSONLoader.js`.
   -  Removed `Geometry` support from `ObjectLoader`. You have to include 
      `LegacyJSONLoader` if you still want to load geometry data of type `Geometry`. 
   -  Removed `Geometry` support from `SkinnedMesh`. Use `BufferGeometry` instead.
   -  Removed `SkinnedMesh.initBones()`. The `SkinnedMesh` constructor does not 
      build the bone hierarchy anymore. You have to do this by yourself and then 
      call `SkinnedMesh.bind()  <https://threejs.org/docs/#api/en/objects/SkinnedMesh.bind>`__ 
      in order to bind the prepared skeleton.

   #🎨# r97 → r98

   -  Renamed `ObjectLoader.setTexturePath()` to `ObjectLoader.setResourcePath()`. 
      Added `ObjectLoader.setPath()`.

   -  `CanvasRenderer` has been removed.

   -  The order of `LoadingManager`'s callbacks has changed. `onError()` 
      is now called before `onLoad()`.

   #🎨# r96 → r97

   -  Removed `BinaryLoader`.
   -  `WebGLRenderer.clearTarget()` is now deprecated. Use `WebGLRenderer.setRenderTarget()` 
      in combination with `WebGLRenderer.clear()` instead.
   -  Renamed `JSONLoader.setTexturePath()` to `JSONLoader.setResourcePath()`.
   -  Renamed `MTLLoader.setTexturePath()` to `MTLLoader.setResourcePath()`.

   -  `GLTFLoader.setPath()` is now used for the original glTF file. 
      Use `GLTFLoader.setResourcePath()` if you want to change the path for 
      resources like textures.

   -  `TDSLoader.setPath()` is now used for the original 3DS file. 
      Use `TDSLoader.setResourcePath()` if you want to change the path for 
      resources like textures.

   -  Refactored `PointerLockControls`. Please have a look at the `official example 
      <https://threejs.org/examples/misc_controls_pointerlock.html>`__ to see the new API.

   -  `Detector.js` was refactored to `WebGL.js`.


   #🎨# r95 → r96

   -  `Object3D.lookAt()` now supports rotated parents.
   -  `EquirectangularToCubeGenerator` constructor args have changed.

   #🎨# r94 → r95

   -  `OrbitControls.mouseButtons` key-value pairs have been renamed. Please make 
      a note of it if you wish to change the mouse button bindings.

   -  `BufferSubdivisionModifier` has been removed. Use `SubdivisionModifier` instead.
   -  Sprites are now rendered concurrently with opaque and transparent objects.

   -  Keyframe tracks are no longer automatically validated and optimized. Users 
      need to explicitly call `.validate/optimize()`.

   -  Renamed shader chunk `lights_pars_maps` to `envmap_physical_pars_fragment`.

   #🎨# r93 → r94

   -  `TDSLoader` now produces `BufferGeometry`.
   -  `MD2Loader` now produces `BufferGeometry`.
   -  `XLoader` now produces `BufferGeometry`.
   -  Removed deprecated CTM, FBX, msgpack and UTF8 converters.
   -  Removed deprecated `UTF8Loader`.
   -  Renamed `EquiangularToCubeGenerator` to `EquirectangularToCubeGenerator`.
   -  Removed deprecated `VRControls` and `VREffect`.
   -  `DaydreamController` and `GearVRController` are now deprecated. The new 
      directory of these file is `examples/js/vr/deprecated/`.

   #🎨# r92 → r93

   -  Renamed option `amount` to `depth` in `ExtrudeBufferGeometry`.

   -  The Blender exporter has been removed. See `#12903  <https://github.com/mrdoob/three.js/issues/12903>`__ 
      and `#14117  <https://github.com/mrdoob/three.js/pull/14117>`__ for more 
      information. Also have a look at the new guide `Loading 3D models  
      <https://rawgit.com/mrdoob/three.js/dev/docs/#manual/introduction/Loading-3D-models>`__.

   -  `STLBinaryExporter` has been removed. It's now part of `STLExporter`.
   -  Renamed `WebGLRenderer.animate()` to `WebGLRenderer.setAnimationLoop()`.

   #🎨# r91 → r92
   -  Removed option `frames` from `ExtrudeBufferGeometry`.
   -  Removed `.getArrays()` from `ExtrudeBufferGeometry`.
   -  Removed `.addShapeList()` from `ExtrudeBufferGeometry`.
   -  Removed `.addShape()` from `ExtrudeBufferGeometry`.
   -  `ExtrudeGeometry.WorldUVGenerator` is now private.
   -  `SVGLoader` now parses SVG input and returns an array of `ShapePath` objects.

   #🎨# r90 → r91

   -  `Geometry.center()` and `BufferGeometry.center()` now return `this` instead of `offset`.
   -  `optionalTarget`s are now mandatory method parameters (with exception of curve classes).

   -  Split `ShaderChunk.lights_pars` into `ShaderChunks.lights_pars_begin` and 
      `ShaderChunks.lights_pars_maps`.

   -  Split `ShaderChunk.lights_template` into `ShaderChunks.lights_fragment_begin`, 
      `ShaderChunnks.lights_fragment_maps` and `ShaderChunks.lights_fragment_end`.

   -  Split `ShaderChunk.normal_fragment` into `ShaderChunks.normal_fragment_begin` 
      and `ShaderChunks.normal_fragment_maps`.

   -  The semantics of `AnimationAction.repetition` has changed. The first run 
      of the animation is now taken into account.

   -  Removed `copyIndicesArray()` from `BufferAttribute`.
   -  Removed `getWorldRotation()` from `Object3D`.
   -  Renamed `Triangle.area()` to `Triangle.getArea()`.
   -  Renamed `Triangle.barycoordFromPoint()` to `Triangle.getBarycoord()`.
   -  Renamed `Triangle.midpoint()` to `Triangle.getMidpoint()`.
   -  Renamed `Triangle.normal()` to `Triangle.getNormal()`.
   -  Renamed `Triangle.plane()` to `Triangle.getPlane()`.
   -  Removed options `material` and `extrudeMaterial` from `ExtrudeGeometry`.
   -  Removed `vertices` from `renderer.info.render`.
   -  BasicDepthPacking: Depth values at the near plane are now encoded as white. 
      Depth values at the far plane as black.

   #🎨# r89 → r90

   -  `Lensflare` has been moved out of the core. Please use `examples/js/objects/Lensflare.js 
      <https://github.com/mrdoob/three.js/blob/master/examples/js/objects/Lensflare.js>`__ 
      if you need lens flares in your scene. Also have a look at the official 
      `example  <https://threejs.org/examples/webgl_lensflares.html>`__ to see
       the new usage of `Lensflare`.

   -  `SceneUtils` has been moved out of the core. It is now located at 
      `examples/js/utils/SceneUtils.js  <https://github.com/mrdoob/three.js/blob/master/examples/js/utils/SceneUtils.js>`__.

   -  Removed `.shadowMap.renderReverseSided` from `WebGLRenderer`. Set `Material.shadowSide` instead.
   -  Removed `.shadowMap.renderSingleSided` from `WebGLRenderer`. Set `Material.shadowSide` instead.
   -  Removed `.setFaceCulling()` from `WebGLRenderer`.
   -  Removed the JSON exporters for Maya and 3ds Max.
   -  Removed `.computeLineDistances()` from `Geometry`. Use  `Line.computeLineDistances()` instead.

   #🎨# r88 → r89

   -  `ImageUtils` has been removed.
   -  Removed `extractUrlBase()` from `Loader`. Use `LoaderUtils.extractUrlBase()` instead.
   -  `ShapeUtils.triangulateShape()` uses a new and more robust polygon triangulation algorithm now.
   -  `ShapeUtils.triangulate()` has been removed.
   -  `Reflector`, `Refractor`, `Water` and `Water2` accept now any planar geometry 
      and not only rectangular ones. The respective constructors have a new signature.

   #🎨# r87 → r88

   -  `CombinedCamera` has been removed.
   -  `ColladaLoader2` has replaced `ColladaLoader`.
   -  `VRMLLoader` now produces `BufferGeometry`.

   -  `OBJLoader2` has a new dependency `LoaderSupport` 
      (see `example  <https://threejs.org/examples/webgl_loader_obj2.html>`__).

   -  `WebVR.js` was rewritten. Check out the corresponding 
      `examples  <https://threejs.org/examples/?q=webvr>`__ to see the new API.

   -  Renamed `CatmullRomCurve3`'s `type` to `curveType`.

   -  Removed `createPointsGeometry()` from `CurvePath`. Check out this 
      `example  <https://threejs.org/docs/index.html#api/extras/curves/CatmullRomCurve3>`__ 
      to see how to create a geometry from a series of points.

   -  Removed `createSpacedPointsGeometry()` from `CurvePath`. 
   -  Removed `createGeometry()` from `CurvePath`.
   -  Renamed `Path`'s `fromPoints()` to `setFromPoints()`.
   -  Removed `extractAllPoints()` from `Shape`.
   -  Renamed `Mirror` to `Reflector`.
   -  Renamed `lengthManhattan()` of `Vector2`, `Vector3` and `Vector4` to `manhattanLength()`.
   -  Renamed `distanceToManhattan()` of `Vector2` and `Vector3` to `manhattanDistanceTo()`.
   -  Renamed `AxisHelper` to `AxesHelper`.

   #🎨# r86 → r87

   -  `GLTF2Loader` has replaced `GLTFLoader`.

   -  The result of the `onLoad` callback of `PDBLoader` has changed. 
      Please have a look at the corresponding 
      `example  <https://threejs.org/examples/#webgl_loader_pdb>`__.

   -  `AssimpLoader` now uses `LoadingManager`.
   -  Removed `setPreferredShading()` from `ColladaLoader`.

   #🎨# r85 → r86

   -  Removed deprecated `Animation`, `AnimationHandler` and `KeyFrameAnimation`
   -  Swapped y in setViewport() and setScissor()

   #🎨# r84 → r85

   -  `MultiMaterial` has been removed. Use an Array instead.
   -  Removed `multiplyToArray()` from `Matrix4`.
   -  Removed deprecated `SceneLoader`.
   -  `BoxHelper update()` no longer has arguments. Use `.setFromObject()` 
      to assign a different object to the helper.
   -  `BoxHelper` no longer supports objects of type `Box3`.
   -  `DecalGeometry` now produces a `BufferGeometry`.

   #🎨# r83 → r84

   -  Removed `applyToVector3Array()` from `Matrix3`.
   -  Removed `applyToVector3Array()` from `Matrix4`.
   -  Removed `Spline`. Use `CatmullRomCurve3` instead.
   -  Removed `SplineCurve3 `. Use `CatmullRomCurve3` instead.
   -  Removed `applyProjection()` from `Vector3`. Use `applyMatrix4()` instead.
   -  Renamed `Vector2`'s `fromAttribute()` to `fromBufferAttribute()`.
   -  Renamed `Vector3`'s `fromAttribute()` to `fromBufferAttribute()`.
   -  Renamed `Vector4`'s `fromAttribute()` to `fromBufferAttribute()`.
   -  Renamed `BinaryTextureLoader` to `DataTextureLoader`.
   -  Changed `Matrix4 `'s `makeFrustum()` to `makePerspective()`.

   #🎨# r82 → r83

   -  `STLLoader` now produces a `BufferGeometry`.
   -  `PDBLoader ` now produces a `BufferGeometry`.
   -  `AssimpJSONLoader` now produces a `BufferGeometry`.
   -  Renamed `Matrix3`'s `applyToBuffer()` to `applyToBufferAttribute()`.
   -  Renamed `Matrix4`'s `applyToBuffer()` to `applyToBufferAttribute()`.
   -  `BoundingBoxHelper` has been removed. Use `BoxHelper` instead.
   -  Renamed `XHRLoader` to `FileLoader`.

   #🎨# r81 → r82

   -  `PLYLoader` now produces a `BufferGeometry`.
   -  The `taper` parameter in `TubeGeometry` has been removed.

   #🎨# r80 → r81

   -  Renamed `Box2`'s `center()` to `getCenter()`.
   -  Renamed `Box2`'s `size()` to `getSize()`.
   -  Renamed `Box3`'s `center()` to `getCenter()`.
   -  Renamed `Box3`'s `size()` to `getSize()`.
   -  Renamed `Line3`'s `center()` to `getCenter()`.


   #🎨# r76 → r77

   -  `THREE.GridHelper`: `setColors()` removed, pass them in the constructor 
      instead: `new THREE.GridHelper( size, step, color1, color2 )`.

   #🎨# r75 → r76

   -  `THREE.Audio` `.load` deprecated, use new `THREE.AudioLoader` instead.
   -  Uniforms no longer need a `.type` property.
   -  The uniform `boneGlobalMatrices` has been renamed to `boneMatrices`.

   #🎨# r74 → r75

   -  Changed `Vector3`'s `setFromMatrixColumn(index, m)` to `setFromMatrixColumn(m, index)`.
   -  Removed `WebGLRenderTarget`'s `shareDepthFrom`.

   #🎨# r73 → r74

   -  Renamed `enableScissorTest` to `setScissorTest`.
   -  Renamed `shadowBias` to `shadow.bias`.
   -  Renamed `shadowMapWidth` to `shadow.mapSize.width`.
   -  Renamed `shadowMapHeight` to `shadow.mapSize.height`.
   -  Renamed `shadowCameraNear` to `shadow.camera.near`.
   -  Renamed `shadowCameraFar` to `shadow.camera.far`.
   -  Renamed `shadowCameraFov` to `shadow.camera.fov`.
   -  Removed `shadowDarkness`. Add a `THREE.AmbientLight` to your scene instead.
   -  Removed `ClosedSplineCurve3`. Use `CatmullRomCurve3` with `closed` set to `true`.
   -  Removed `MeshPhongMaterial`'s `metal`.
   -  Renamed `Box2`'s `empty()` to `isEmpty()`.
   -  Renamed `Box3`'s `empty()` to `isEmpty()`.

   #🎨# r72 → r73

   -  Removed `morphColors` from `Geometry`.
   -  Removed `clampBottom` from `Math`.
   -  `FontUtils` and `TextGeometry` moved out of core.
   -  `shadowDarkness` default value is now `1`.
    
   #🎨# r71 → r72

   -  Renamed `PointCloud` to `Points`.
   -  Renamed `PointCloudMaterial` to `PointsMaterial`.
   -  Removed `computeTangents()` from `Geometry` and `BufferGeometry`.
   -  Moved all `shadowMap*` properties in `WebGLRenderer` to `shadowMap.*`.
   -  Removed `BufferGeometry`'s `drawcall.index`.
   -  `LineSegments( geometry, material )` should now be used instead of 
      `Line( geometry, material, THREE.LinePieces )`.

   #🎨# r70 → r71

   -  Removed `ambient` from `Material`.
   -  Removed `recursive` parameter from `getObjectBy*()`.

   #🎨# r69 → r70

   -  Removed `sortParticles` from `PointCloud`.
   -  Removed `renderDepth` from `Object3D`.
   -  `UVMapping`, `CubeReflectionMapping`, `CubeRefractionMapping`, 
      `SphericalReflectionMapping` and `SphericalRefractionMapping` are no longer functions.

   #🎨# r68 → r69

   -  `WebGLRenderer`'s `initMaterial` was made private.
   -  `ColladaLoader` now returns a `Scene` instead of an `Object3D`.

   #🎨# r67 → r68

   -  `Object3D`'s `position`, `rotation`, `quaternion` and `scale` properties 
      are now immutable.

   -  `BufferGeometry`'s `addAttribute` method now takes a `BufferAttribute` 
      instead of the various attribute types (e.g., `Int16Attribute`, `Float32Attribute`).

   #🎨# r66 → r67

   -  Removed `Face3`'s `centroid`.
   -  Removed `Geometry`'s `computeCentroids()`.
   -  Moved `GeometryUtils`'s `merge` to `Geometry`.

   #🎨# r65 → r66

   -  Renamed `CubeGeometry` to `BoxGeometry`.
   -  Removed `dynamic` property from `BufferGeometry`.

   #🎨# r64 → r65

   -  Removed `physicallyBasedShading` property from `WebGLRenderer`.

   #🎨# r62 → r63

   -  `WebGLRenderer` background to opaque (black) by default. Pass `{alpha=true}` 
      when creating WebGLRenderer for previous default behaviour.

   #🎨# r61 → r62

   -  `Particle` removed. Use `Sprite` instead.
   -  `ParticleMaterial` removed. Use `ParticleSystemMaterial` or `SpriteMaterial`.

   #🎨# r59 → r60

   -  `Face4` removed. Use 2 `Face3` to emulate it.
   -  `OrbitControls`'s `zoomIn()` and `zoomOut()` renamed to `dollyIn()` and `dollyOut()`.

   #🎨# r58 → r59

   -  `Object3D.rotation` is now of type `THREE.Euler`.
   -  Removed `Object3D.useQuaternion`. The library now uses quaternions by default. 
      However, there is some magic in place to keep `Object3D`'s `rotation` (`Euler`) working.
   -  Moved `Object3D.eulerOrder` to `Object3D.rotation.order`.
   -  Moved `Object3D.defaultEulerOrder` to `Euler.DefaultOrder`.
   -  Removed `setGeometry()` and `setMaterial()` from `Mesh`.
   -  Removed `Vector3.setEulerFromRotationMatrix()`, use `Euler.setFromRotationMatrix()` instead.
   -  Removed `Vector3.setEulerFromQuaternion()`, use `Euler.setFromQuaternion()` instead.

   #🎨# r57 → r58

   -  Removed `Matrix4`'s `translate()`, `rotateX()`, `rotateY()`, `rotateZ()`, `rotateByAxis()` and `crossVector()`.
   -  Removed `setClearColorHex()` from `CanvasRenderer` and `WebGLRenderer`. Use `setClearColor()` instead.
   -  Renamed `Matrix4`'s `extractPosition()` to `copyPosition()`.
   -  Renamed `Matrix4`'s `setRotationFrom*()` to `makeRotationFrom*()`.
   -  Renamed `Matrix4`'s `compose()` to `makeFromPositionQuaternionScale()`.
   -  Renamed `Object3D`'s `getChildByName()` to `getObjectByName()`.
   -  Removed `Object3D`'s `matrixRotationWorld` property.

   #🎨# r56 → r57

   -  For `BufferGeometry`

     - `geometry.verticesNeedUpdate` to `geometry.attributes.position.needsUpdate`
     - `geometry.elementsNeedUpdate` to `geometry.attributes.index.needsUpdate`
     - `geometry.normalsNeedUpdate` to `geometry.attributes.normal.needsUpdate`
     - `geometry.uvsNeedUpdate` to `geometry.attributes.uv.needsUpdate`
     - `geometry.colorsNeedUpdate` to `geometry.attributes.color.needsUpdate`
     - `geometry.tangentsNeedUpdate` to `geometry.attributes.tangent.needsUpdate`
     - `*` -> `geometry.attributes.custom.needsUpdate`

   -  Removed `Matrix4`'s `rotateAxis`. Use `Vector3.transformDirection( matrix )` instead.
   -  Removed `AsteriskGeometry`.
   -  Removed `Color`'s `setHSV`. Use `ColorConverter.setHSV( color, h, s, v )` instead.
   -  Renamed `JSONLoader`'s `createModel()` to `parse()`.

   #🎨# r55 → r56

   -  Removed `getPosition()` and `getColumn*()` from `Matrix4`
   -  `Color.setHSV()` and `Color.getHSV()` replaced by `.setHSL()` and `.getHSL()`
   -  Replaced `ColorUtils.adjustHSV()` with Color's `.offsetHSL()`
   -  Renamed `Box3/Line3/Plane/Ray/Sphere`'s `.transform()` to `applyMatrix4()`

   #🎨# r54 → r55

   -  `Matrix3.multiplyVector3()` changed to `Vector3.applyMatrix3()`
   -  `Matrix4.multiplyVector3()` changed to `Vector3.applyMatrix4()` and `Vector3.applyProjection()`
   -  `Matrix4.multiplyVector4()` changed to `Vector4.applyMatrix4()`
   -  `Quaternion.multiplyVector3()` changed to `Vector3.applyQuaternion()`
   -  Renamed `Color` methods:

     - `.lerpSelf()` to `.lerp()`

   -  Renamed `Vector2`, `Vector3` and `Vector4` methods:

     - `.add()` to `.addVectors()`
     - `.addSelf()` to `.add()`
     - `.sub()` to `.subVectors()`
     - `.subSelf()` to `.sub()`
     - `.cross()` to `.crossVectors()`
     - `.crossSelf()` to `.cross()`
     - `.minSelf()` to `.min()`
     - `.maxSelf()` to `.max()`
     - `.clampSelf()` to `.clamp()`
     - `.lerpSelf()` to `.lerp()`

   -  Renamed `Matrix4` methods:

     - `.multiply()` to `.multiplyMatrices()`
     - `.multiplySelf()` to `.multiply()`

   -  Renamed `Quaternion` methods:

     - `.multiply()` to `.multiplyQuaternions()`
     - `.multiplySelf()` to `.multiply()`

   -  Renamed `Frustum` methods:

     - `.contains()` to `.intersectsObject()`

   -  Moved `GeometryUtils.explode` to `ExplodeModifier`
   -  Moved `GeometryUtils.tessellate` to `TessellateModifier`
   -  Moved `ShaderUtils.lib` to `ShaderLib`
   -  `Matrix4.makeTranslation` and `Matrix4.makeScale` now take  three scalars instead of `Vector3`.



   #🎨# r53 → r54

   -  `Sprite` material properties are now in `SpriteMaterial`, used like this 
      `new THREE.Sprite( new THREE.SpriteMaterial( { color: 0xff0000, map: texture, alphaTest: 0.5 } ) )`.

   -  Renamed migrated sprite material properies: `Sprite.affectedByDistance` 
      => `SpriteMaterial.sizeAttenuation` and `Sprite.mergeWith3D` => `SpriteMaterial.depthTest`

   -  Renamed `renderer.shadowMapCullFrontFaces` => `renderer.shadowMapCullFace` 
      (default value `true` => `THREE.CullFaceFront`, other option `false` => `THREE.CullFaceBack`).

   -  Renamed `color.getContextStyle` to `color.getStyle`.
   -  Moved `Ray` casting methods to `Raycaster`.
   -  `Rectangle` replaced  with `Box2`.
   -  `UV` replaced with `Vector2`. This means `.u` and `.v` are now `.x` and `.y`.
   -  `Matrix4.makeTranslation` and `Matrix4.makeScale` now take `Vector3` instead of three scalars.
   -  Moved `SubdivisionModifier` out of the build to `examples/js/modifiers`.
   -  Renamed and moved `Renderer.deallocateObject()` => `Geometry.dispose()` and `BufferGeometry.dispose()`.
   -  Renamed and moved `Renderer.deallocateRenderTarget()` => `WebGLRenderTarget.dispose()`.

   #🎨# r52 → r53

   -  `Sprite`'s size is no longer automatically based on the image size, use 
      `sprite.scale.set( imageWidth, imageHeight, 1.0 )` to achieve the old behavior

   -  `SceneLoader` and scene format now use `widthSegments`, `heightSegments`, 
      `depthSegments` instead of `segmentsWidth`, `segmentsHeight`, `segmentsDepth` 
      for definitions of plane, cube and sphere geometries

   -  `SceneLoader`and scene format now use `material` property with single 
      material id string instead of `materials` array for meshes

   -  `MeshPhongMaterial` now uses `perPixel = true` by default

   -  `WebGLRenderer` constructor doesn't use anymore `maxLights` parameter: 
      shaders will be generated with the exact number of lights in the scene 
      (it's now up to the application layer to make sure shaders compile on a 
      particular system)

   -  `ColorUtils.rgbToHsv()` got moved into `Color.getHSV()`
   
   -  `Geometry` no longer has a `materials` property. `MeshFaceMaterials` usage 
      is now like this: `new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( [ material1, material2 ] ) )`. 
      Meaning that `face.materialIndex` will map the array passed to `MeshFaceMaterials`.

   -  Loader callbacks which previously only had `geometry` parameter, are now 
      also passed a second one: `materials`: `loader.load( 'file.js', function ( geometry, materials ) {} )`.

   -  `GeometryUtils.clone()` is now a method in `Geometry`.

   #🎨# r51 → r52

   -  `ShaderExtras` have been split in a different files. `CopyShader`, 
      `FXAAShader`, `NormalShader`, etc

   -  Replaced `SceneUtils.traverseHierarchy` with `object.traverse`.

   -  Removed `SceneUtils.showHierarchy`. 
      Use `object.traverse( function ( child ) { child.visible = false } )` instead.

   -  Moved `*Controls` to `examples/js/controls`.
   -  Split `SceneUtils.cloneObject` into `*.clone()`

   #🎨# r50 → r51

   -  `CameraHelper` API changes: helper is not anymore child of camera, instead 
      it uses reference to camera world matrix

   -  texture uniform changes: texture units are now assigned automatically, 
      texture object goes to `value` property instead of `texture` one 
      `{ type: "t", value: 0, texture: map }` => `{ type: "t", value: map }`

   -  `normalScale` uniform in normal map shader is now `Vector2` (to be able 
      to invert separately `x` and `y` to deal with different tangent bases)

   -  `CTMLoader.load` and  `CTMLoader.loadParts` now use single parameter object 
      for `useWorker` and `useBuffers`: `loader.load( url, callback, useWorker, useBuffers )` 
      => `loader.load( url, callback, { useWorker: true, useBuffers: true } )`

   -  `CTMLoader` now creates `BufferGeometry` by default, set `useBuffers` 
      parameter to `false` if you need `Geometry`

   -  type for non-procedural geometries changed in the scene format: `ascii_mesh` 
      => `ascii`, `bin_mesh` => `binary`, `embedded_mesh` => `embedded`

   -  `UTF8Loader` (and compressor) were changed to a newer version, supporting 
      more recent version of UTF8 format (`r100+`); loader doesn't create anymore 
      geometries but instead it returns hierarchy with potentially multiple meshes 
      created per each material (or by splitting large model)

   #🎨# r49 → r50 

   -  `Vector3's .getRotationFromMatrix( matrix, scale )` to 
      `Vector3's.setEulerFromRotationMatrix( matrix, order )`.

   -  `Vector3's .getEulerXYZFromQuaternion( quaternion )` and 
      `.getEulerYZXFromQuaternion( quaternion )` to `.setEulerFromQuaternion( quaternion, order )`.

   -  `DOMRenderer` and `SVGRenderer` no longer included in common build.

   -  texture coordinates aren't anymore flipped in the geometries, instead 
      textures have `flipY` property (true by default); all models need to be 
      re-exported / reconverted (tools have been updated as well).  
      workaround: ``uv.v = 1 - uv.v;``

   -  `PlaneGeometry` changed back to vertical orientation (facing screen 
      instead of laying on the ground).  
      workaround: ``mesh.rotation.x = - Math.PI / 2;`` or 
      ``geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );``

   -  `doubleSided` / `flipSided` properties moved from `Object3D` 
      to Material's `side` property (`THREE.FrontSide`, `THREE.BackSide` 
      and `THREE.DoubleSide`).

   -  `objectMatrix` in shaders was renamed to `modelMatrix`.
   -  JIT caching removed from `Animation`.
   -  `geometry.dynamic` is now `true` by default.
   -  `Three.js` build renamed to `three.min.js`.

   #🎨# r48 → r49

   -  changed `PlaneGeometry` from vertical to horizontal orientation.
   -  renamed `__dirtyXXX` attribute properties to `xxxNeedUpdate`.
   -  removed `Vertex` class, use `Vector3` instead.

   #🎨# r47 → r48

   -  Removed `intersectScene` from `Ray`. Use `intersectObjects( array )` instead.

   #🎨# r45 → r46

   -  `loader.load( { model: url, callback: callback } )` to `loader.load( url, callback )`.

Owners
------

   List of contributors which have taken ownership of parts of the library:

   `@arodic  <https://github.com/arodic>`__
    * TransformControls

   `@donmccurdy  <https://github.com/donmccurdy>`__
    * DRACOLoader
    * GLTFLoader

   `@fernandojsg  <https://github.com/fernandojsg>`__
    * GLTFExporter

   `@looeee  <https://github.com/looeee>`__
    * FBXLoader
    * LWOLoader

   `@Mugen87  <https://github.com/Mugen87>`__
    * 3MFLoader
    * ColladaLoader
    * VRMLLoader

   `@sunag  <https://github.com/sunag>`__
    * TSL
    * NodeMaterial

   `@takahirox  <https://github.com/takahirox>`__
    * MMDLoader

   `@yomboprime  <https://github.com/yomboprime>`__
    * SVGLoader


An introduction to using Git
----------------------------

Basic workflow creating a Pull Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In order to get started with your submission, you should do something like this:


   .. code:: shell

      $ git checkout dev # switch to dev branch
      $ git pull upstream dev # pull recent version
      $ git branch MyFeature # create a branch for your PR
      $ git checkout MyFeature # switch your feature branch


   Now you can edit.

   **Don't use your `dev` branch for PRs, even if it only contains minor changes.
   It is possible, but complicated, so don't!** I did this a couple of times and
      I always ended up regretting it.


   .. code:: shell

      $ git status


   will show your changes.

      In order to add your changes to your branch do


   .. code:: shell

      $ git add MyChangedFile MyAllNewFile dirWithChanges/ newDir/
      $ git commit


   . You can add as many commits as you like.


      Once you are done, push the branch to your fork at Github


   .. code:: shell

      $ git push origin MyFeature



   Visiting the three.js project, it will offer you to create a pull request.
   Make sure to select the `dev` branch for its base - **not** `master`.


      When your feature has been merged into `dev` you can delete the branch:


   .. code:: shell

      $ git checkout dev # switch back to dev
      $ git branch -D MyFeature



   Note that the commits are being combined into one ("squashed" in Git slang)
   when your PR is merged and therefore Git won't recognize whether your branch
   was merged or not. This is why you have to use `-D` (forced delete) rather
   than `-d` (normal delete).

      In order to remove a remote branch 


   .. code:: shell

      $ git push origin --delete MyFeature


   (you can also press a button on Github's web interface).

I accidentally staged (== `add`ed) a file but don't want to commit it. How to get rid of it?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



   .. code:: shell

      $ git reset HEAD


   unstages everything you added for the upcoming commit. It does not change your
   files. After running it you can re-add the changes for your commit.

How do I remove my (not yet `commit`ed) edits from a file?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



   .. code:: shell

      $ git checkout MyChangedFile


   resets the file back to its checked-in state. It also works with directories.

Github says my branch is conflicting and cannot be merged, what do?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A common reaction is to `merge upstream dev`, but this is not really so
   good of an idea, because it buries your changes underneath the merge.

   Instead of merging the changes in `dev` into your feature branch, you can
   often just rewrite your feature's history on top of current `dev`.

      Git provides an automation for this purpose:


   .. code:: shell

      $ git checkout dev # to my dev branch
      $ git pull upstream dev # pull changes
      $ git checkout MyFeature # back to my feature branch
      $ git rebase dev # let me rewrite it


   Git will guide you through the process of resolving conflicts at this point,
   and it's very similar to merging, except you're in fact rewriting your history,
   so your files will look like they did at the point of the conflicting commit.

   Once  your branch is rebased, test that everything is still working. Sometimes
   you may want to test intermediate steps while rebasing.

   When everything is fine


   .. code:: shell

      $ git push --force MyFeature


   to rewrite your PR.

   Note: In case you have multiple dependent PRs (that is, one includes changes
   of the other), you may have to use `git rebase --interactive` and remove the
   commits that were already merged. The commits in the PRs are combined into
   one, and thus Git can't match them automatically.

I'm new to Git and scared to try new things because I may screw up!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   It's important to realize that every commit refers to a complete and immutable
   state of the entire source tree. Therefore, as long as you remember a commit's
   ID you can always go back to that state.

   One way to remember it is by creating a temporary backup branch:


   .. code:: shell

      $ git branch MyBackup
      $ # e.g. to do your first rebase now


   Now when your branch was messed up you can undo whatever you did with


   .. code:: shell

      $ git reset --hard MyBackup


   The `reset` command makes the current branch point to a specific commit and
   there are various ways of specifying it (using another branch is one, you can
   also write the output of `git log` to a text file and use the IDs directly,
   for instance). The `--force` option tells Git to not just reset the current
   branch but also your files, so you have to be careful when there are changes
   that are not yet checked-in (see `git status`).

How do I "take the builds out"?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   I assume that you followed the advice given above and did not bury your changes
   under a merge. In case you did, you may want to resort to more extreme measures
   and read the next section instead.

   If you are feeling insecure, see the above section to know how to undo whatever
   can happen.

   First, make sure everything is checked-in. Then run


   .. code:: shell

      $ git log


   and identify the commit your branch is based on. Also remember the current
   HEAD of your branch (the topmost ID in the log). It could be useful to just
   write the log into a file:


   .. code:: shell

      $ git log >log_file.txt


   Now switch to the state before your commits


   .. code:: shell

      $ git reset --hard <ID of base commit>


   and copy `build/three.js` and `build/three.min.js`.

   Then switch back to the old HEAD:


   .. code:: shell

      $ git reset --hard <ID of last commit>


   Next, start an in-place rewrite of your history:


   .. code:: shell

      $ git rebase --interactive <ID of base commit>


   an editor will open. Now change `pick` to `edit` for the commits that include
   the builds.

   The rebase will stop at every commit you selected for editing. Every time it
   does, copy the builds from the base commit back to your working copy. Then


   .. code:: shell

      $ git add build/
      $ git commit --amend
      $ git rebase --continue


   and on to the next. Use


   .. code:: shell

      $ git push --force origin MyFeature


   once you have successfully rebased your branch.

Welcome to the time machine - rewriting history from scratch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Upfront a word of caution: You do not want to abuse this technique in the
   midst of a review. Make sure to keep things transparent for the reviewer in
   some way. In particular do not restructure your changes in a completely
   different way just because you can - it may cause confusion.

   There can be cases, however, where you want to give your feature branch
   a fresh history, e.g. after burying builds underneath a merge or when there
   are too many conflicting changes for rebase to be practical.

   Here is how it's done:


   .. code:: shell

      $ git checkout dev # switch to dev branch
      $ git pull upstream dev # update it
      $ git checkout MyFeature # switch back to the feature branch
      $ git merge dev # merge with dev
      $ # ... resolve conflicts here
      $ git commit
      $ # you can take backup measures here, see above
      $ git reset dev # do *not* use --force, keep your files!
      $ # repeat the following steps to rebuild your history
      $ git add <file(s)> 
      $ git commit


   If you have unrelated changes in a single file, you can use


   .. code:: shell

      $ git add --interactive <file(s)>


   and then use the **p**atched add option - to add these changes to different
   commits.

   Finally


   .. code:: shell

      $ git push --force origin MyFeature

   to Github.

Wait, does git never forget anything?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Run


   .. code:: shell

      $ git gc

   to invoke the garbage collector. It will remove commits that are no longer 
   referenced by any of your branches and older than 30 days (you can change 
   this default - see the manual for details). 

How do I keep Git from wear-leveling my SSDs?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Use a ramdisk. 

   The Linux kernel supports RAM-based the file systems `tmpfs` / `shmfs`, the
   HFS file system (Mac OS X) supports RAM-based images, and for Windows there
   is a (free & non-proprietary) RAM-based disk driver called
   `ImDisk  <http://www.ltr-data.se/opencode.html/#ImDisk>`__.


Mr.doob's Code Style™
----------------------

   # JavaScript CodeStyle

   ## Online Code Beautifier

   See the online `mrdoobapproves  <http://zz85.github.io/mrdoobapproves/>`__ 
   code beautifier.

   ## ESlint Plugin

   This style guide is also available as an `eslint plugin on NPM  
   <https://www.npmjs.com/package/eslint-config-mdcs>`__. 

   ## General Provisions

   -  ECMAScript 2018.
   -  Code should be in UTF-8.
   -  A new line should be  LF.
   -  Indentation should be tabs. 
   -  No extra spaces at the end of lines (set up your text editor, so that it 
      removes extra spaces when saving).

   ## Naming

   Naming should be as descriptive as possible. The only exception is the indexing 
   variable in a loop. That can be shortened to a single letter starting from i.

   -  variableNamesLikeThis
   -  functionNamesLikeThis
   -  ClassNamesLikeThis
   -  methodNamesLikeThis
   -  ConstantsLikeThis or CONSTANTS_LIKE_THIS (depending on use case)

   Private properties and methods of objects begin with an underscore _.

   ## Literals

   ### Objects

   -  Object should always be created by `{}` and not `new Object()`.
   -  When creating an empty Object, use `{}` without spaces.
   -  When creating an Object with keys, 
      - There should be a single space after the opening bracket.
      - There should be a single space before the closing bracket.
      - Keys should be written without quotes. The exception is when it is necessary.
      - There should be no space between the key word and the colon.
      - There should be a space between the colon and the value.
      - The comma should have no space before and 1 space behind itself.
      - The last value shouldn't be trailed with a comma.
      - The comma shouldn't start a new line. It should always trail the previous value.


   .. code:: javascript

      // good:
       var obj = { A: 1, b: 2, C: 3 };

       var obj = {
           A: 1, 
           b: 2, 
           C: 3 
       };


      // poor:
       var obj = {A:1,b:2,C:3};
       var obj = {A:1, b:2, C:3};
       var obj = {A : 1, b : 2, C : 3};
       var obj = { "A" : 1, "b" : 2, "C" : 3 };
       var obj = { A : 1, b : 2, C : 3 };
       var obj = { A :1, b :2, C :3 };
       var obj = { A : 1 , b : 2 , C : 3 };
       var obj = {
           A : 1, 
           b : 2, 
           C : 3, 
       };

       var obj = {
           A : 1 
         , b : 2
         , C : 3 
       };

   ### Classes

   -  Private properties should start with an underscore.

   ### Arrays

   -  Arrays should always be created by `[]` and not `new Array()`.
   -  When creating an empty Array, use `[]` without spaces.
   -  When creating an Array with values, 
      - There should be a single space after the opening bracket.
      - There should be a single space before the closing bracket.
      - The comma should have no space before and 1 space behind itself.
      - The last value shouldn't be trailed with a comma.
      - The comma shouldn't start a new line. It should always trail the previous value.

   .. code:: javascript

      // good:

       var arr = [ 1, 2, 3 ];

       var arr = [
           1, 
           2, 
           3 
       ];

      // poor:

       var arr = [1,2,3];
       var arr = [1, 2, 3];
       var arr = [ 1 , 2 , 3 ];
       var arr = [
           1, 
           2, 
           3,
       ];

       var arr = [
           1
         , 2
         , 3 
       ];

   ### Strings

   Strings are written using single quotes:

   .. code:: javascript

      // good:

       var  lyrics  =  'Never gonna Give you up, Never gonna Let you down' ;

   ### Semicolon

   Semicolons are always placed.

   ## Blocks

   -  The opening brackets should be followed by 1 empty line.
   -  The closing brackets should be behind 1 empty line.
   -  The opening brackets should always follow a space and not start at a new line

   .. code:: javascript

      // good:

       if ( a === 0 ) {

          // this is good
          return true;

       }

      // poor:

       if ( a === 0 ) {
           // this is bad: missing empty line after '{' 
           return true;

       }

       if ( a === 0 ) {

           // this is bad: missing empty line before '}'
           return true;
       }

       if ( a === 0 ) { // this is bad:  stuff after '{'

           return true;

       }

       if ( a === 0 ){

          // this is bad: no space before '{'
          return true;

       }


   ## Conditional instructions

   ### if statement

   -  The if keyword should always be followed with a space, an opening parenthesis and another space.
   -  The test should end with a space, a closing parenthesis and another space.
   -  The if statement should always contain a block.
   -  If there is an else statement, it should be on the same line as the closing bracket of the block.
   -  The else statement is followed by another block and should be separated 
      from both blocks with a single space on both sides.
   -  Assignment should not be used in a test.

   .. code:: javascript

      // good:

       if ( test ) { 

           // ... 

       } else { 

           // ... 

       }

      // poor:

       if (test) { 

           // ... 

       }

       if( test ) { 

           // ... 

       }

       if (test ) { 

           // ... 

       }

       if ( test) { 

           // ... 

       }

       if ( test ){ 

           // ... 

       }

       if ( test ) { 

           // ... 

       }else { 

           // ... 

       }

       if ( test ) { 

           // ... 

       } else{ 

           // ... 

       }


   ### switch

   -  The switch keyword should always be followed with a space, an opening parenthesis and another space.
   -  The test value should end with a space, a closing parenthesis and another space.
   -  Every case should have a break statement, except for the default case or when returning a value.
   -  Every case should have a space between the colon and the test.
   -  Before and after each case, there should be a new line.
   -  Assignment should not be used in a test.

   .. code:: javascript

      // good:

       switch ( value ) { 

           case 1 : 

               // ... 
               break ;

           case 2 : 

               // ... 
               break ;

           default : 

               // ... 
               // no break keyword on the last case 

       }

   ## Cycles

   ### for

   -  Be aware that `foreach` and `for in` are much slower than `for`.
   -  The for keyword should always be followed with a space, an opening parenthesis and another space.
   -  The assignment part should start with a space.
   -  The assignment part should end with a semicolon and a space.
   -  The test part should start with a space.
   -  The test part should end with a semicolon and a space.
   -  The update part should start with a space.
   -  The update part should end with a space, a closing parenthesis and another space 

   ## Operators

   ### with

   Operator `with` not used.

   ### The equality operator

   Always use strict equality `===` (inequality `!==` ).

   ### Ternary operator

   Always use spaces around the colon and question mark.

   ### Unary

   All unary operators are written together with the following operands:

   var  foo  =  ! bar;

   ### eval

   Avoid using eval. To parse json, use JSON.parse.

   ### undefined

   Check the value through a strict comparison.

   .. code:: javascript

      // Good:

       x === undefined;
      // Poor:

       / / In modern browsers already defined immutable undefined. 
       var undefined; 
       x === undefined;

       typeof x === 'undefined'

       x === void 0


Dev Branch Examples
-------------------

   You can view the examples for the current dev branch here: 
   https://raw.githack.com/mrdoob/three.js/dev/examples/


Demoscene
---------

   List of `demoscene  <https://en.wikipedia.org/wiki/Demoscene>`__ productions 
   using three.js (sorted by release date)


   * 2019

     * `"Ω" by jumalauta  <http://jumalauta.untergrund.net/omega/>`__
     * `"Konseptuaalinen kissa" by jumalauta  <http://rimina.kapsi.fi/JML-KonseptuaalinenKissa/>`__
     * `"Genesis" by Netro  <http://function2019.wponline.eu/>`__
     * `"AK-03: Hypertension" by AateKorjaamo  <http://rimina.kapsi.fi/AK-03-Hypertension/>`__
     * `"Construct" by Ninjadev  <http://arkt.is/construct.html>`__
     * `"Hatch" by Cookie Collective  <http://leon196.github.io/hatch/>`__
     * `"Flat Shade Society" by Ninjadev  <https://stianj.com/flat-shade-society/>`__
     * `"Acidia" by Dekadence & jumalauta  <http://rimina.kapsi.fi/Acidia/>`__
     * `"AK-02: Rorschach test #01" by AateKorjaamo  <http://rimina.kapsi.fi/demobit19/>`__
     * `"AK-01: Pareidolia" by AateKorjaamo  <http://rimina.kapsi.fi/skeneclubi19/>`__

   * 2018

     * `"Look closer" by Ninjadev  <https://stianj.com/look-closer/>`__
     * `"Pinky Frinky" by Ninjadev  <https://stianj.com/pinky-frinky.png.html>`__
     * `"run_grids" by Polyop  <http://polyop.uk/run_grids/>`__

   * 2017

     * `"No Invitation" by Ninjadev  <http://arkt.is/no-invitation/>`__
     * `"Crystal" by Mr.doob  <https://christmasexperiments.com/2017/08/crystal/>`__
     * `"Explore With Me"  <https://www.clicktorelease.com/code/explore-with-me/>`__
     * `"And The Crowd Gathered At Cookie"  <http://leon196.github.io/Cookie2017/>`__
     * `"Zeven" by Ninjadev  <https://stianj.com/zeven/>`__
     * `"BoxBufferGeometry" by Elude and Logicoma  <http://www.theelude.eu/boxbuffergeometry/>`__
     * `"Suddenly" by Elude  <http://www.theelude.eu/suddenly/>`__
     * `"What Are You Syncing About?" by Ninjadev  <https://stianj.com/what-are-you-syncing-about/>`__

   * 2016

     * `"Broken Mantra" by Mr.doob  <http://mrdoob.github.io/brokenmantra/>`__
     * `"Koherent" by Konvergence  <https://excaa.github.io/konvergence/koherent/>`__
     * `"Crankwork Steamfist" by Ninjadev  <https://stianj.com/crankwork-steamfist/>`__

   * 2015

     * `"Christmas Virus"  <https://www.clicktorelease.com/code/xmas-virus/>`__
     * `"Everything is fashion" by Ninjadev  <http://stianj.com/fashion/>`__
     * `"Monolith"  <https://www.clicktorelease.com/code/monolith/>`__
     * `"I Want To See Other Worlds" by Primitive  <http://primitive.be/prods/IWTSOW/>`__ (`video  <https://www.youtube.com/watch?v=tv8YHzTd98g>`__)

   * 2014

     * `"Beyond"  <http://b-e-y-o-n-d.com/>`__
     * `"Inakuwa Oasis" by Ninjadev  <http://arkt.is/inakuwa-oasis>`__
     * `"Thisway.js" by stravaganza  <http://fernandojsg.com/lab/thiswayjs/>`__

   * 2013

     * `"Dark Sunrise"  <http://acko.net/files/dark-sunrise/git/>`__
     * `"Obsidian" by xplsv  <https://xplsv.github.io/obsidian/>`__
     * `"Tunl-Mntn-Wter" by Ninjadev  <http://www.stianj.com/skog>`__

   * 2012

     * `"Microscopix" by LiteWerx.   <http://litewerx.dk/microscopix/>`__
     * `"Honeycomb" by Ninjadev  <http://arkt.is/honeycomb/>`__
     * `"State Zero-One" by dilemma  <https://dilemma.ws/demo/state-zero-one/>`__

   * 2011

     * `"Anaemia" by LiteWerx.  <http://litewerx.dk/anaemia/>`__

   * 2010

     * `"Or so they say..." by xplsv  <http://xplsv.com/prods/demos/xplsv_orsotheysay/>`__


GUI Tools with Three.js
-----------------------

   *  three.js editor - http://threejs.org/editor/
   *  ThreeScene - http://errolschwartz.com/projects/threescene/
   *  ThreeNodes - http://idflood.github.com/ThreeNodes.js/ 
   *  ThreeInspector - http://zz85.github.io/zz85-bookmarklets/threelabs
   *  ThreeFabs - http://blackjk3.github.com/threefab/


Editor Manual
-------------

   ### How to implement scripts

   Scripts enable the implementation of dynamic logic in editor-based applications. 
   For each 3D object in the scene graph, it is possible to add one or more scripts. 

   #### Lifecycle methods

   Each script can implement the following lifecycle methods:

   -  `update()`: Executed right before a frame is going to be rendered. 
      Its primary purpose is to update the state of the 3D object which owns the 
      script. The method has an `event` parameter which holds a `time` and `delta` 
      property. `time` represents the elapsed time in milliseconds and `delta` 
      represents the time between two frames in milliseconds. 
   -  `init()`: Executed once after the application has been loaded.
   -  `start()`: Executed once when the application is ready to start rendering.
   -  `stop()`: Executed once when the application is stopped.

   #### Events

   It is also possible to implement event listeners for selected browser events. 
   The following events are supported by the editor:

   -  `keydown`
   -  `keyup`
   -  `pointerdown`
   -  `pointerup`
   -  `pointermove`

   #### Script variables

   Certain application components are accessible in the scope of scripts as variables:

   -  `player`: A reference to the application player (a wrapper component which 
      executes the editor application).
   -  `renderer`: A reference to the renderer.
   -  `scene`: A reference to the scene graph.
   -  `camera`: A reference to the application's camera.

   #### Miscellaneous

   -  Code outside of lifecycle and event listeners is immediately executed when the script is loaded.
   -  The `this` reference can be used to refer to the 3D object which owns the script.


JSON Geometry format 4
----------------------

   Work in progress.

   Example of BufferGeometry


   .. code:: javascript

      {
         "metadata": {
            "version": 4,
            "type": "BufferGeometry",
            "generator": "BufferGeometryExporter"
         },
         "data": {
            "attributes": {
               "position": {
                  "itemSize": 3,
                  "type": "Float32Array",
                  "array": [50,50,50,...]
               },
               "normal": {
                  "itemSize": 3,
                  "type": "Float32Array",
                  "array": [1,0,0,...]
               },
               "uv": {
                  "itemSize": 2,
                  "type": "Float32Array",
                  "array": [0,1,...]
               }
            },
            "boundingSphere": {
               "center": [0,0,0],
               "radius": 86.60254037844386
            }
         }
      }

JSON Texture format 4
---------------------

   Work in progress.

   .. code:: javascript

       "images": [
           {
               "uuid": "A430CF4-AD77-11E3-914E-00248C62C323",
               "url": "concrete.co.png"
           }
       ],
       "textures" : [
           {
               "uuid": "F430CF4-AD77-11E3-914E-00248C62C323",
               "image": "A430CF4-AD77-11E3-914E-00248C62C323",
               "wrap": ["repeat", "repeat"],
               "repeat": [2, 2]
           }
       ],
       "materials": [
        {
            "uuid": "5C5C9C6A-4453-4827-869D-187C0BD53BCB",
            "name": "planeMAT",
            "type": "MeshPhongMaterial",
            "color": 16777215,
            "ambient": 16777215,
            "emissive": 0,
            "specular": 1118481,
            "shininess": 30,
            "side": 2,
            "opacity": 1,
            "transparent": false,
            "wireframe": false,
            "map": "F430CF4-AD77-11E3-914E-00248C62C323"
        },


JSON Material format 4
----------------------

   Work in progress.

   Example of MeshPhongMaterial


   .. code:: javascript

      {
         "metadata": {
            "version": 4.2,
            "type": "material",
            "generator": "MaterialExporter"
         },
         "type": "MeshPhongMaterial",
         "color": 16777215,
         "ambient": 16777215,
         "emissive": 0,
         "specular": 1118481,
         "shininess": 30,
         "opacity": 1,
         "transparent": false,
         "wireframe": false
      }


JSON Object Scene format 4
--------------------------

   Work in progress.

   ### Example of Scene with a Box and a Light.


   .. code:: javascript

      {
         "metadata": {
            "version": 4.3,
            "type": "Object",
            "generator": "ObjectExporter"
         },
         "geometries": [
            {
               "uuid": "C3BF1E70-0BE7-4E6D-B184-C9F1E84A3423",
               "type": "BufferGeometry",
               "data": {
                  "attributes": {
                     "position": {
                        "itemSize": 3,
                        "type": "Float32Array",
                        "array": [50,50,50,...]
                     },
                     "normal": {
                        "itemSize": 3,
                        "type": "Float32Array",
                        "array": [1,0,0,...]
                     },
                     "uv": {
                        "itemSize": 2,
                        "type": "Float32Array",
                        "array": [0,1,...]
                     }
                  },
                  "boundingSphere": {
                     "center": [0,0,0],
                     "radius": 86.60254037844386
                  }
               }
            }
         ],
         "materials": [
            {
               "uuid": "87D95D6C-6BB4-4B8F-8166-A3A6945BA5E3",
               "type": "MeshPhongMaterial",
               "color": 16777215,
               "ambient": 16777215,
               "emissive": 0,
               "specular": 1118481,
               "shininess": 30,
               "opacity": 1,
               "transparent": false,
               "wireframe": false
            }
         ],
         "object": {
            "uuid": "89529CC6-CBAC-412F-AFD1-FEEAE785BA19",
            "type": "Scene",
            "matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
            "children": [
               {
                  "uuid": "33FA38D9-0AAC-4657-9BBE-5E5780DDFB2F",
                  "name": "Box 1",
                  "type": "Mesh",
                  "geometry": "C3BF1E70-0BE7-4E6D-B184-C9F1E84A3423",
                  "material": "87D95D6C-6BB4-4B8F-8166-A3A6945BA5E3",
                  "matrix": [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
               },
               {
                  "uuid": "16F2E381-2B73-44C4-A7BB-38D7E1CD2381",
                  "name": "PointLight 1",
                  "type": "PointLight",
                  "color": 16777215,
                  "intensity": 1,
                  "distance": 0,
                  "matrix": [1,0,0,0,0,1,0,0,0,0,1,0,100,200,150,1]
               }
            ]
         }
      }

   ### Example of scene with a simple indexed BufferGeometry plane
   

   .. code:: javascript

      {
         "metadata": {
            "version": 4.3,
            "type": "Object",
            "generator": "ObjectExporter"
         },
         "textures": [],
         "images": [],
         "geometries": [
            {
               "uuid": "0A8F2988-626F-411C-BD6A-AC656C4E6878",
               "type": "BufferGeometry",
               "data": {
                  "attributes": {
                     "position": {
                        "itemSize": 3,
                        "type": "Float32Array",
                        "array": [1,1,0,1,-1,0,-1,-1,0,-1,1,0],
                        "normalized": false
                     },
                     "normal": {
                        "itemSize": 3,
                        "type": "Float32Array",
                        "array": [0,0,1,0,0,1,0,0,1,0,0,1],
                        "normalized": false
                     },
                     "uv": {
                        "itemSize": 2,
                        "type": "Float32Array",
                        "array": [1,1,1,0,0,0,0,1],
                        "normalized": false
                     }
                  },
                  // type of index must be Uint8Array or Uint16Array.
                  // # vertices thus cannot exceed 255 or 65535 respectively.
                  // The current parser is able to read the index array
                  // if it is nested in the attributes object, but such
                  // syntax is no longer encouraged.
                  "index": {
                     "type": "Uint16Array",
                     "array": [0,1,2,0,2,3]
                  },
                  "boundingSphere": {
                     "center": [0,0,0],
                     "radius": 1
                  }
               }
            }
         ],
         "materials": [],
         "object": {
            "uuid": "378FAA8D-0888-4249-8701-92D1C1F37C51",
            "type": "Scene",
            "matrix": [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ],
            "children": [
               {
                  "uuid": "E7B44C44-DD75-4C29-B571-21AD6AEF0CA9",
                  "name": "SharedVertexTest",
                  "type": "Mesh",
                  "geometry": "0A8F2988-626F-411C-BD6A-AC656C4E6878",
                  "matrix": [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]
               }
            ]
         }
      }


Three.js Shading Language
-------------------------


   - `Introduction  <#introduction>`__
     - `Why TSL?  <#why-tsl>`__
     - `Example  <#example>`__
     - `Architecture  <#architecture>`__
   - `Constants and explicit conversions  <#constants-and-explicit-conversions>`__
   - `Conversions  <#conversions>`__
   - `Uniform  <#uniform>`__
     - `onUpdate  <#uniformonupdate>`__
   - `Swizzle  <#swizzle>`__
   - `Operators  <#operators>`__
   - `Function  <#function>`__
   - `Conditional  <#conditional>`__
     - `If-else  <#if-else>`__
     - `Ternary  <#ternary>`__
   - `Math  <#math>`__
   - `Method chaining  <#method-chaining>`__
   - `Texture  <#texture>`__
   - `Attributes  <#attributes>`__
   - `Position  <#position>`__
   - `Normal  <#normal>`__
   - `Tangent  <#tangent>`__
   - `Bitangent  <#bitangent>`__


Introduction
~~~~~~~~~~~~

   ### Why TSL?

   Creating shaders has always been an advanced step for most developers, 
   many game developers have never created GLSL code from scratch. The 
   shader graph solution adopted today by the industry has allowed developers 
   more focused on dynamics to create the necessary graphic effects to meet 
   the demands of their projects.

   The aim of the project is to create an easy-to-use, environment for shader 
   creation. Even if for this we need to create complexity behind, this 
   happened initially with `Renderer` and now with the `TSL`.

   Other benefits that TSL brings besides simplifying shading creation is keeping 
   the `renderer agnostic`, while all the complexity of a material can be imported 
   into different modules and use `tree shaking` without breaking during the process.

   ### Example

   A `detail map` makes things look more real in games. It adds tiny details 
   like cracks or bumps to surfaces. In this example we will scale uv to 
   improve details when seen up close and multiply with a base texture.

   #### Old

      This is how we would achieve that using `.onBeforeCompile()`:


   .. code:: javascript

      const material = new THREE.MeshStandardMaterial();
      material.map = colorMap;
      material.onBeforeCompile = ( shader ) => {

         shader.uniforms.detailMap = { value: detailMap };

         let token = '#define STANDARD';

         let insert = /* glsl */`
            uniform sampler2D detailMap;
         `;

         shader.fragmentShader = shader.fragmentShader.replace( token, token + insert );

         token = '#include <map_fragment>';

         insert = /* glsl */`
            diffuseColor *= texture2D( detailMap, vMapUv * 10.0 );
         `;

         shader.fragmentShader = shader.fragmentShader.replace( token, token + insert );

      };


   Any simple change from this makes the code increasingly complicated using 
   `.onBeforeCompile`, the result we have today in the community are countless 
   types of parametric materials that do not communicate with each other, 
   and that need to be updated periodically to be operating, limiting the 
   creativity to create unique materials reusing modules in a simple way.

   #### New

      With `TSL` the code would look like this:


   .. code:: javascript

      import { texture, uv } from 'three/tsl';

      const detail = texture( detailMap, uv().mul( 10 ) );

      const material = new THREE.MeshStandardNodeMaterial();
      material.colorNode = texture( colorMap ).mul( detail );


   `TSL` is also capable of encoding code into different outputs such as 
   `WGSL`/ `GLSL` - `WebGPU`/ `WebGL`, in addition to optimizing the 
   shader graph automatically and through codes that can be inserted within 
   each `Node`. This allows the developer to focus on productivity and leave 
   the graphical management part to the `Node System`.

   Another important feature of a graph shader is that we will no longer 
   need to care about the sequence in which components are created, because 
   the `Node System` will only declare and include it once.

   Let's say that you import `positionWorld` into your code, even if another 
   component uses it, the calculations performed to obtain `position world` 
   will only be performed once, as is the case with any other renderer component 
   such as: `normalWorld`, `modelPosition`, etc.

   ### Architecture

   All `TSL` components are extended from `Node` class. The `Node` allows it 
   to communicate with any other, value conversions can be automatic or manual, 
   a `Node` can receive the output value expected by the parent `Node` and 
   modify its own output snippet. It's possible to modulate them using 
   `tree shaking` in the shader construction process, the `Node` will have 
   important information such as `geometry`, `material`, `renderer` as well 
   as the `backend`, which can influence the type and value of output.

   The build process is based on three pillars: `setup`, `analyze` and `generate`.

   *  `setup` 

      Use `TSL` to create a completely customized code for the `Node` output. 
      The `Node` can use many others within itself, have countless inputs, 
      but there will always be a single output.
   
   *  `analyze` 

      This proccess will check the `nodes` that were created in order to create 
      useful information for `generate` the snippet, such as the need to create 
      or not a cache/variable for optimizing a node. 
   
   *  `generate` 

      An output of `string` will be returned from each `node`. Any node will 
      also be able to create code in the flow of shader, supporting multiple lines.


   `Node` also have a native update process invoked by the `update()` function, 
   these events be called by `frame`, `render call` and `object draw`.

   It is also possible to serialize or deserialize a `Node` using `serialize()` 
   and `deserialize()` functions.


Constants and explicit conversions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Input functions can be used to create contants and do explicit conversions.

   Conversions are also performed automatically if the output and input are 
   of different types.

   ========================================================== ===============
   Name                                                       Returns a constant or convertion of type:
   float( node | number )                                     `float`
   int( node | number )                                       `int`
   uint( node | number )                                      `uint`
   bool( node | value )                                       `boolean`
   color( node | hex | r,g,b )                                `color`
   vec2( node | Vector2 | x,y )                               `vec2`
   vec3( node | Vector3 | x,y,z )                             `vec3`
   vec4( node | Vector4 | x,y,z,w )                           `vec4`
   mat2( node | Matrix2 | a,b,c,d )                           `mat2`
   mat3( node | Matrix3 | a,b,c,d,e,f,g,h,i )                 `mat3`
   mat4( node | Matrix4 | a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p )   `mat4`
   ========================================================== ===============
   
   Advanced 

   ========================================================== ===============
   Name                                                       Returns a constant or convertion of type:
   ivec2( node | x,y )                                          `ivec2`  
   ivec3( node | x,y,z )                                        `ivec3`  
   ivec4( node | x,y,z,w )                                      `ivec4`  
   uvec2( node | x,y )                                          `uvec2`  
   uvec3( node | x,y,z )                                        `uvec3`  
   uvec4( node | x,y,z,w )                                      `uvec4`  
   bvec2( node | x,y )                                          `bvec2`  
   bvec3( node | x,y,z )                                        `bvec3`  
   bvec4( node | x,y,z,w )                                      `bvec4`  
   imat2( node | Matrix2 | a,b,c,d )                            `imat2`  
   imat3( node | Matrix3 | a,b,c,d,e,f,g,h,i)                   `imat3`  
   imat4( node | Matrix4 | a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p )    `imat4`  
   umat2( node | Matrix2 | a,b,c,d )                            `umat2`  
   umat3( node | Matrix3 | a,b,c,d,e,f,g,h,i )                  `umat3`  
   umat4( node | Matrix4 | a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p )    `umat4`  
   bmat2( node | Matrix2 | a,b,c,d )                            `bmat2`  
   bmat3( node | Matrix3 | a,b,c,d,e,f,g,h,i )                  `bmat3`  
   bmat4( node | Matrix4 | a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p )    `bmat4`  
   ========================================================== ===============

   Example:


   .. code:: javascript

      import { color, vec2, positionWorld } from 'three/tsl';

      // constant
      material.colorNode = color( 0x0066ff );

      // conversion
      material.colorNode = vec2( positionWorld ); // result positionWorld.xy



Conversions
~~~~~~~~~~~

   It is also possible to perform conversions using the `method chaining`:

   ========================================================== ===============
   Name                                                       Returns a constant or convertion of type:
   .toFloat()                                                   `float`
   .toInt()                                                     `int`
   .toUint()                                                    `uint`
   .toBool()                                                    `boolean`
   .toColor()                                                   `color`
   .toVec2()                                                    `vec2`
   .toVec3()                                                    `vec3`
   .toVec4()                                                    `vec4`
   .toMat2()                                                    `mat2`
   .toMat3()                                                    `mat3`
   .toMat4()                                                    `mat4`
   ========================================================== ===============

   Advanced
   ========================================================== ===============
   Name                                                       Returns a constant or convertion of type:
   .toIvec2()                                                    `ivec2`
   .toIvec3()                                                    `ivec3`
   .toIvec4()                                                    `ivec4`
   .toUvec2()                                                    `uvec2`
   .toUvec3()                                                    `uvec3`
   .toUvec4()                                                    `uvec4`
   .toBvec2()                                                    `bvec2`
   .toBvec3()                                                    `bvec3`
   .toBvec4()                                                    `bvec4`
   .toImat2()                                                    `imat2`
   .toImat3()                                                    `imat3`
   .toImat4()                                                    `imat4`
   .toUmat2()                                                    `umat2`
   .toUmat3()                                                    `umat3`
   .toUmat4()                                                    `umat4`
   .toBmat2()                                                    `bmat2`
   .toBmat3()                                                    `bmat3`
   .toBmat4()                                                    `bmat4`
   ========================================================== ===============

   Example:


   .. code:: javascript

      import { positionWorld } from 'three/tsl';

      // conversion
      material.colorNode = positionWorld.toVec2(); // result positionWorld.xy



Uniform
~~~~~~~

   Uniforms are useful to update values of variables like colors, lighting, 
   or transformations without having to recreate the shader program. They are
   the true variables from a CPU's point of view.

   ====================================== ======================================
   Name                                   Description
   `uniform( boolean | number | Color | 
             Vector2 | Vector3 | 
             Vector4 | Matrix3 | Matrix4, 
             type = null )`               Dynamic values.
   ====================================== ======================================

   Example:


   .. code:: javascript

      const posY = uniform( mesh.position.y );

      // it's possible use posY.value to update manualy the value
      posY.value = mesh.position.y;

      material.colorNode = posY;


   ### `uniform.on*Update()`

   It is also possible to create update events on `uniforms`, which can be defined by the user:

   ================================ ============================================
   Name                             Description
   `.onObjectUpdate( function )`    It will be updated every time an object like 
                                    `Mesh` is rendered with this `node` in `Material`. 
   `.onRenderUpdate( function )`    It will be updated once per render, common and 
                                    shared materials, fog, tone mapping, etc. 
   `.onFrameUpdate( function )`     It will be updated only once per frame, recommended 
                                    for values ​​that will be updated only once per frame, 
                                    regardless of when `render pass` the frame has, 
                                    cases like `timer` for example. 
   ================================ ============================================

   Example:


   .. code:: javascript

      const posY = uniform( 0 ); // it's possible use uniform( 'number' )

      // or using event to be done automatically
      // { object } will be the current rendering object
      posY.onObjectUpdate( ( { object } ) => object.position.y );

      material.colorNode = posY;



Swizzle
~~~~~~~

      Swizzling is the technique that allows you to access, reorder, or duplicate 
      the components of a vector using a specific notation within TSL. This is 
      done by combining the identifiers:


   .. code:: javascript

      const original = vec3( 1.0, 2.0, 3.0 ); // (x, y, z)
      const swizzled = original.zyx; // swizzled = (3.0, 2.0, 1.0)


   It's possible use `xyzw`, `rgba` or `stpq`.


Operators
~~~~~~~~~

   =================================== ======================================
   Name                                Description
   `.add( node | value, ... )`         Return the addition of two or more value. 
   `.sub( node | value )`              Return the subraction of two or more value. 
   `.mul( node | value )`              Return the multiplication of two or more value. 
   `.div( node | value )`              Return the division of two or more value. 
   `.assign( node | value )`           Assign one or more value to a and return the same. 
   `.remainder( node | value )`        Computes the remainder of dividing the first node by the second. 
   `.equal( node | value )`            Checks if two nodes are equal. 
   `.notEqual( node | value )`         Checks if two nodes are not equal. 
   `.lessThan( node | value )`         Checks if the first node is less than the second. 
   `.greaterThan( node | value )`      Checks if the first node is greater than the second. 
   `.lessThanEqual( node | value )`    Checks if the first node is less than or equal to the second. 
   `.greaterThanEqual( node | value )` Checks if the first node is greater than or equal to the second. 
   `.and( node | value )`              Performs logical AND on two nodes. 
   `.or( node | value )`               Performs logical OR on two nodes. 
   `.not( node | value )`              Performs logical NOT on a node. 
   `.xor( node | value )`              Performs logical XOR on two nodes. 
   `.bitAnd( node | value )`           Performs bitwise AND on two nodes. 
   `.bitNot( node | value )`           Performs bitwise NOT on a node. 
   `.bitOr( node | value )`            Performs bitwise OR on two nodes. 
   `.bitXor( node | value )`           Performs bitwise XOR on two nodes. 
   `.shiftLeft( node | value )`        Shifts a node to the left. 
   `.shiftRight( node | value )`       Shifts a node to the right. 
   =================================== ======================================


   .. code:: javascript

      const a = float( 1 );
      const b = float( 2 );

      const result = a.add( b ); // output: 3



Function
~~~~~~~~

   ### `tslFn( function )`

   It is possible to use classic JS functions or a `tslFn()` interface. 
   The main difference is that `tslFn()` creates a controllable environment, 
   allowing the use of `stack` where you can use `assign` and `conditional`, 
   while the classic function only allows inline approaches.

   Example:


   .. code:: javascript

      // tsl function
      const oscSine = tslFn( ( [ timer = timerGlobal ] ) => {

         return timer.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );

      } );

      // inline function
      export const oscSine = ( timer = timerGlobal ) => timer.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );

   **Note:** Both above can be called with `oscSin( value )`.

   TSL allows the entry of parameters as objects, this is useful in functions 
   that have many optional arguments.

   Example:


   .. code:: javascript

      const oscSine = tslFn( ( { timer = timerGlobal } ) => {

         return timer.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );

      } );

      const value = oscSine( { timer: value } );


   If you want to use an export function compatible with `tree shaking`, 
   remember to use `/*@__PURE__*/`


   .. code:: javascript

      export const oscSawtooth = /*@__PURE__*/ tslFn( ( [ timer = timerGlobal ] ) => timer.fract() );



Conditional
~~~~~~~~~~~

   ### If-else

      `If-else` conditionals can be used within `tsnFn()`. Conditionals in `TSL` 
      are built using the `If` function:


   .. code:: javascript

      If( conditional, function )
      .elseif( conditional, function )
      .else( function )

   **Notice** here the `i` in `If` is capitalized.

   Example:

      In this example below, we will limit the y position of the geometry to 10.


   .. code:: javascript

      const limitPosition = tslFn( ( { position } ) => {

         const limit = 10;

         // Convert to variable using `.toVar()` to be able to use assignments.
         const result = position.toVec3().toVar();

         If( result.y.greaterThan( limit ), () => {

            position.y = limit;

         } );

         return result;

      } );

      material.positionNode = limitPosition( { position: positionLocal } );


   Example using `elseif`:


   .. code:: javascript

      const limitPosition = tslFn( ( { position } ) => {

         const limit = 10;

         // Convert to variable using `.toVar()` to be able to use assignments.
         const result = position.toVec3().toVar();

         If( result.y.greaterThan( limit ), () => {

            position.y = limit;

         } ).elseif( result.y.lessThan( limit ), () => {

            position.y = limit;

         } );

         return result;

      } );

      material.positionNode = limitPosition( { position: positionLocal } );


   ### Ternary

      Different from `if-else`, a ternary conditional will return a value and 
      can be used outside of `tslFn()`.


   .. code:: javascript

      const result = cond( value.greaterThan( 1 ), 1.0, value );

   *Note:* Equivalent in JavaScript should be: `value > 1 ? 1.0 : value`


Math
~~~~

   =================================== ======================================
   Name                                Description
   `EPSION`                            A small value used to handle floating-point precision errors. 
   `INFINITY`                          Represent infinity. 
   `abs( x )`                          Return the absolute value of the parameter. 
   `acos( x )`                         Return the arccosine of the parameter. 
   `all( x )`                          Return true if all components of x are true. 
   `any( x )`                          Return true if any component of x is true. 
   `asin( x )`                         Return the arcsine of the parameter. 
   `atan( x )`                         Return the arc-tangent of the parameters. 
   `atan2( y, x )`                     Return the arc-tangent of the quotient of its arguments. 
   `bitcast( x, y )`                   Reinterpret the bits of a value as a different type. 
   `cbrt( x )`                         Return the cube root of the parameter. 
   `ceil( x )`                         Find the nearest integer that is greater than or equal to the parameter. 
   `clamp( x, min, max )`              Constrain a value to lie between two further values. 
   `cos( x )`                          Return the cosine of the parameter. 
   `cross( x, y )`                     Calculate the cross product of two vectors. 
   `dFdx( p )`                         Return the partial derivative of an argument with respect to x. 
   `dFdy( p )`                         Return the partial derivative of an argument with respect to y. 
   `degrees( radians )`                Convert a quantity in radians to degrees. 
   `difference( x, y )`                Calculate the absolute difference between two values. 
   `distance( x, y )`                  Calculate the distance between two points. 
   `dot( x, y )`                       Calculate the dot product of two vectors. 
   `equals( x, y )`                    Return true if x equals y. 
   `exp( x )`                          Return the natural exponentiation of the parameter. 
   `exp2( x )`                         Return 2 raised to the power of the parameter. 
   `faceforward( N, I, Nref )`         Return a vector pointing in the same direction as another. 
   `floor( x )`                        Find the nearest integer less than or equal to the parameter. 
   `fract( x )`                        Compute the fractional part of the argument. 
   `fwidth( x )`                       Return the sum of the absolute derivatives in x and y. 
   `inverseSqrt( x )`                  Return the inverse of the square root of the parameter. 
   `invert( x )`                       Invert an alpha parameter ( 1. - x ). 
   `length( x )`                       Calculate the length of a vector. 
   `lengthSq( x )`                     Calculate the squared length of a vector. 
   `log( x )`                          Return the natural logarithm of the parameter. 
   `log2( x )`                         Return the base 2 logarithm of the parameter. 
   `max( x, y )`                       Return the greater of two values. 
   `min( x, y )`                       Return the lesser of two values. 
   `mix( x, y, a )`                    Linearly interpolate between two values. 
   `negate( x )`                       Negate the value of the parameter ( -x ). 
   `normalize( x )`                    Calculate the unit vector in the same direction as the original vector. 
   `oneMinus( x )`                     Return 1 minus the parameter. 
   `pow( x, y )`                       Return the value of the first parameter raised to the power of the second. 
   `pow2( x )`                         Return the square of the parameter. 
   `pow3( x )`                         Return the cube of the parameter. 
   `pow4( x )`                         Return the fourth power of the parameter. 
   `radians( degrees )`                Convert a quantity in degrees to radians. 
   `reciprocal( x )`                   Return the reciprocal of the parameter (1/x). 
   `reflect( I, N )`                   Calculate the reflection direction for an incident vector. 
   `refract( I, N, eta )`              Calculate the refraction direction for an incident vector. 
   `round( x )`                        Round the parameter to the nearest integer. 
   `saturate( x )`                     Constrain a value between 0 and 1. 
   `sign( x )`                         Extract the sign of the parameter. 
   `sin( x )`                          Return the sine of the parameter. 
   `smoothstep( e0, e1, x )`           Perform Hermite interpolation between two values. 
   `sqrt( x )`                         Return the square root of the parameter. 
   `step( edge, x )`                   Generate a step function by comparing two values. 
   `tan( x )`                          Return the tangent of the parameter. 
   `transformDirection( dir, matrix )` Transform the direction of a vector by a matrix and then normalize the result. 
   `trunc( x )`                        Truncate the parameter, removing the fractional part. 
   =================================== ======================================


   .. code:: javascript

      const value = float( -1 );

      // It's possible use `value.abs()` too.
      const positiveValue = abs( value ); // output: 1



Method chaining
~~~~~~~~~~~~~~~

   `Method chaining` will only be including operators, converters, math and 
   some core functions. These functions, however, can be used on any `node`.

   Example:

      `onMinus()` is a mathematical function like `abs()`, `sin()`. This example 
      uses `.onMinus()` as a built-in function in the class that returns a new class 
      component and not as a classic C function like `oneMinus( texture( map ).rgb )`, 
      it is called `method chaining`.


   .. code:: javascript

      // it will invert the texture color
      material.colorNode = texture( map ).rgb.oneMinus();



Texture
~~~~~~~


   *  `texture( texture, uv = uv(), level = null )` 
       Retrieves texels from a texture. 
       type `vec4` .
   *  `cubeTexture( texture, uvw = reflectVector, level = null )` 
       Retrieves texels from a cube texture. 
       type `vec4` .
   *  `triplanarTexture( textureX, textureY = null, textureZ = null, scale = float( 1 ), 
       position = positionLocal, normal = normalLocal )` 
       Computes texture using triplanar mapping based on provided parameters. 
       type `vec4` .



Attributes
~~~~~~~~~~

   *  `attribute( name, type = null, default = null )` 
      Getting geometry attribute using name and type. 
      type `any` .
   *  `uv( index = 0 )` 
      UV attribute named `uv + index`. 
      type `vec2` .
   *  `vertexColor( index = 0 )` 
      Vertex color node for the specified index. 
      type `color` .


Position
~~~~~~~~

   ======================== ====== ===================================
   Name                      Type   Description
   `positionGeometry`       `vec3`  Position attribute of geometry. 
   `positionLocal`          `vec3`  Local variable for position. 
   `positionWorld`          `vec3`  World position. 
   `positionWorldDirection` `vec3`  Normalized world direction. 
   `positionView`           `vec3`  View position. 
   `positionViewDirection`  `vec3`  Normalized view direction. 
   ======================== ====== ===================================

   **Note:** `positionLocal` represents the position after modifications made 
   by `skinning`, `morpher`, etc.


Normal
~~~~~~

   ================================ ====== ===================================
   Name                              Type   Description
   `normalGeometry`                 `vec3`  Normal attribute of geometry.
   `normalLocal`                    `vec3`  Local variable for normal.
   `normalView`                     `vec3`  Normalized view normal.
   `normalWorld`                    `vec3`  Normalized world normal.
   `transformedNormalView`          `vec3`  Transformed normal in view space.
   `transformedNormalWorld`         `vec3`  Normalized transformed normal in world space.
   `transformedClearcoatNormalView` `vec3`  Transformed clearcoat normal in view space.
   ================================ ====== ===================================

   **Note:** `transformed*` represents the normal after modifications made by 
   `skinning`, `morpher`, etc.


Tangent
~~~~~~~

   ================================ ====== ===================================
   Name                              Type   Description
   `tangentGeometry`                `vec4`  Tangent attribute of geometry. 
   `tangentLocal`                   `vec3`  Local variable for tangent. 
   `tangentView`                    `vec3`  Normalized view tangent. 
   `tangentWorld`                   `vec3`  Normalized world tangent. 
   `transformedTangentView`         `vec3`  Transformed tangent in view space. 
   `transformedTangentWorld`        `vec3`  Normalized transformed tangent in world space. 
   ================================ ====== ===================================


Bitangent
~~~~~~~~~

   ================================ ====== ===================================
   Name                             Type     Description 
   `bitangentGeometry`              `vec3`   Normalized bitangent in geometry space. 
   `bitangentLocal`                 `vec3`   Normalized bitangent in local space. 
   `bitangentView`                  `vec3`   Normalized bitangent in view space. 
   `bitangentWorld`                 `vec3`   Normalized bitangent in world space. 
   `transformedBitangentView`       `vec3`   Normalized transformed bitangent in view space. 
   `transformedBitangentWorld`      `vec3`   Normalized transformed bitangent in world space. 
   ================================ ====== ===================================


Camera
~~~~~~

   ================================ ======= ===================================
   Name                             Type     Description 
   `cameraNear`                     `float`  Near plane distance of the camera. 
   `cameraFar`                      `float`  Far plane distance of the camera. 
   `cameraLogDepth`                 `float`  Logarithmic depth value for the camera. 
   `cameraProjectionMatrix`         `mat4`   Projection matrix of the camera. 
   `cameraProjectionMatrixInverse`  `mat4`   Inverse projection matrix of the camera. 
   `cameraViewMatrix`               `mat4`   View matrix of the camera. 
   `cameraWorldMatrix`              `mat4`   World matrix of the camera. 
   `cameraNormalMatrix`             `mat3`   Normal matrix of the camera. 
   `cameraPosition`                 `vec3`   World position of the camera. 
   ================================ ======= ===================================


Model
~~~~~

   ================================ ====== ===================================
   Name                             Type     Description 
   `modelDirection`                 `vec3`   Direction of the model. 
   `modelViewMatrix`                `mat4`   View matrix of the model. 
   `modelNormalMatrix`              `mat4`   Normal matrix of the model. 
   `modelWorldMatrix`               `mat4`   World matrix of the model. 
   `modelPosition`                  `vec3`   Position of the model. 
   `modelScale`                     `vec3`   Scale of the model. 
   `modelViewPosition`              `vec3`   View position of the model. 
   `modelWorldMatrixInverse`        `mat4`   Inverse world matrix of the model. 
   ================================ ====== ===================================


Viewport
~~~~~~~~

   ================================ ====== ===================================
   Variable                         Type     Description 
   `viewportTopLeft`                `vec2`   Returns the top-left `uv` of the viewport. 
   `viewportBottomLeft`             `vec2`   Returns the bottom-left `uv` of the viewport. 
   `viewportTopRight`               `vec2`   Returns the top-right `uv` of the viewport. 
   `viewportBottomRight`            `vec2`   Returns the bottom-right `uv` of the viewport. 
   `viewport`                       `vec4`   Returns the viewport dimension. 
   `viewportCoordinate`             `vec2`   Returns the viewport coordinate. 
   `viewportResolution`             `vec2`   Returns the viewport resolution. 
   ================================ ====== ===================================


Blend Mode
~~~~~~~~~~

   ================================ ======= ===================================
   Variable                          Type    Description 
   `burn( a, b )`                   `color`  Returns the burn blend mode. 
   `dodge( a, b )`                  `color`  Returns the dodge blend mode. 
   `overlay( a, b )`                `color`  Returns the overlay blend mode. 
   `screen( a, b )`                 `color`  Returns the screen blend mode. 
   ================================ ======= ===================================


Reflect
~~~~~~~

   ================================ ======= ===================================
   Name                              Type    Description 
   `reflectView`                     `vec3`   Computes reflection direction in view space. 
   `reflectVector`                   `vec3`   Transforms the reflection direction to world space. 
   ================================ ======= ===================================


UV Utils
~~~~~~~~

   *  `matcapUV` 
      UV coordinates for matcap material computation. 
      type `vec2`
   *  `rotateUV( uv, rotation, centerNode = vec2( 0.5 ) )` 
      Rotates UV coordinates around a center point. 
      type `vec2`
   *  `spritesheetUV( count, uv = uv(), frame = float( 0 ) )` 
      Computes UV coordinates for a sprite sheet based on the number of frames, 
      UV coordinates, and frame index. 
      type `vec2`
   *  `equirectUV( direction = positionWorldDirection )` 
      Computes UV coordinates for equirectangular mapping based on the direction vector. 
      type `vec2`


   .. code:: javascript

      import { texture, matcapUV } from 'three/tsl';

      const matcap = texture( matcapMap, matcapUV );



Interpolation
~~~~~~~~~~~~~

   *  `remap( node, inLow, inHigh, outLow = float( 0 ), outHigh = float( 1 ) )` 
      Remaps a value from one range to another. 
      type `any`
   *  `remapClamp( node, inLow, inHigh, outLow = float( 0 ), outHigh = float( 1 ) )` 
      Remaps a value from one range to another, with clamping. 
      type `any`


Random
~~~~~~


   *  `hash( seed )` 
      Generates a hash value in the range [ 0, 1 ] from the given seed. 
      type `float` 
   *  `range( min, max )` 
      Generates a range `attribute` of values between min and max. 
      Attribute randomization is useful when you want to randomize values ​
      ​between instances and not between pixels. 
      type `any` 


Oscillator
~~~~~~~~~~


   ==================================== ======= ================================
   Variable                             Type    Description
   `oscSine( timer = timerGlobal )`     `float` Generates a sine wave oscillation based on a timer. 
   `oscSquare( timer = timerGlobal )`   `float` Generates a square wave oscillation based on a timer. 
   `oscTriangle( timer = timerGlobal )` `float` Generates a triangle wave oscillation based on a timer. 
   `oscSawtooth( timer = timerGlobal )` `float` Generates a sawtooth wave oscillation based on a timer. 
   ==================================== ======= ================================


Packing
~~~~~~~

   =========================== ========= =======================================
   Variable                     Type      Description
   `directionToColor( value )` `color`    Converts direction vector to color. 
   `colorToDirection( value )` `vec3`     Converts color to direction vector. 
   =========================== ========= =======================================


Functions
~~~~~~~~~

   ### `.toVar( name = null )`

   To create a variable from a node use `.toVar()`.

   The first parameter is used to add a name to it, otherwise the node 
   system will name it automatically, it can be useful in debugging or 
   access using `wgslFn`.


   .. code:: javascript

      const uvScaled = uv().mul( 10 ).toVar();

      material.colorNode = texture( map, uvScaled );



   ### `varying( node, name = null )`

   Let's suppose you want to optimize some calculation in the `vertex stage` 
   but are using it in a slot like `material.colorNode`.

   For example:


   .. code:: javascript

      // multiplication will be executed in vertex stage
      const normalView = varying( modelNormalMatrix.mul( normalLocal ) );

      // normalize will be executed in fragment stage
      // because .colorNode is fragment stage slot as default
      material.colorNode = normalView.normalize();


   The first parameter of `varying` `modelNormalMatrix.mul( normalLocal )` 
   will be executed in `vertex stage`, and the return from `varying()` will 
   be a `varying` as we are used in WGSL/GLSL, this can optimize extra calculations 
   in the `fragment stage`. The second parameter allows you to add a custom name to `varying`.

   If `varying()` is added only to `.positionNode`, it will only return a simple 
   variable and varying will not be created.


Transitioning common GLSL properties to TSL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ====================== ======================== ======
   GLSL                    TSL                     Type
   `position`             `positionGeometry`       `vec3`
   `transformed`          `positionLocal`          `vec3`
   `transformedNormal`    `normalLocal`            `vec3`
   `vWorldPosition`       `positionWorld`          `vec3`
   `vColor`               `vertexColor()`          `vec3`
   `vUv` | `uv`           `uv()`                   `vec2`
   `vNormal`              `normalView`             `vec3`
   `viewMatrix`           `cameraViewMatrix`       `mat4`
   `modelMatrix`          `modelWorldMatrix`       `mat4`
   `modelViewMatrix`      `modelViewMatrix`        `mat4`
   `projectionMatrix`     `cameraProjectionMatrix` `mat4`
   `diffuseColor`         `material.colorNode`     `vec4`
   `gl_FragColor`         `material.fragmentNode`  `vec4`
   ====================== ======================== ======



Using SketchUp Models
---------------------


Sketchup → Collada
~~~~~~~~~~~~~~~~~~


   1. Click on the menu item **File** > **Export** > **3D Model...**.
   2. Choose **COLLADA File (.dae)** as export type.
   3. If you want to export the textures, click on **Options** and make sure 
      that **Export Texture Maps** is checked.
   4. Click on **Export**.

   SketchUp will create a Collada file named `your-model.dae` and a folder 
   named `your-model` that contains the model's textures.

Collada → Three.js
~~~~~~~~~~~~~~~~~~

      Make sure you download `ColladaLoader` and include it into your project:


   .. code:: javascript

      <script type="text/javascript" src="Three.js"></script>
      <script type="text/javascript" src="ColladaLoader.js"></script>



   .. code:: javascript

      var loader = new THREE.ColladaLoader();
      loader.load( 'path/to/your/model.dae', function ( collada ) {

      scene.add( collada.scene );

      } );

   Note that this won't work locally because it loads the Collada file and the 
   textures using AJAX. Therefore you have to serve the files with HTTP or change 
   your browser's security settings as explained in `How to run things locally  
   <https://threejs.org/docs/#manual/introduction/How-to-run-things-locally>`__.



🟡 Three.js Fundamentals
========================


Basics
------

   -  [F01]_ `Fundamentals <https://threejs.org/manual/en/fundamentals.html>`__
   -  [F02]_ `Responsive Design <https://threejs.org/manual/en/responsive.html>`__
   -  [F03]_ `Prerequisites <https://threejs.org/manual/en/prerequisites.html>`__
   -  [F04]_ `Setup <https://threejs.org/manual/en/setup.html>`__


Fundamentals
------------

   -  [F05]_ `Primitives <https://threejs.org/manual/en/primitives.html>`__
   -  [F06]_ `Scenegraph <https://threejs.org/manual/en/scenegraph.html>`__
   -  [F07]_ `Materials <https://threejs.org/manual/en/materials.html>`__
   -  [F08]_ `Textures <https://threejs.org/manual/en/textures.html>`__
   -  [F09]_ `Lights <https://threejs.org/manual/en/lights.html>`__
   -  [F10]_ `Cameras <https://threejs.org/manual/en/cameras.html>`__
   -  [F11]_ `Shadows <https://threejs.org/manual/en/shadows.html>`__
   -  [F12]_ `Fog <https://threejs.org/manual/en/fog.html>`__
   -  [F13]_ `Render Targets <https://threejs.org/manual/en/rendertargets.html>`__
   -  [F14]_ `Custom BufferGeometry <https://threejs.org/manual/en/custom-buffergeometry.html>`__


Tips
----

   -  [F15]_ `Rendering On Demand <https://threejs.org/manual/en/rendering-on-demand.html>`__
   -  [F16]_ `Debugging JavaScript <https://threejs.org/manual/en/debugging-javascript.html>`__
   -  [F17]_ `Debugging GLSL <https://threejs.org/manual/en/debugging-glsl.html>`__
   -  [F18]_ `Taking a screenshot <https://threejs.org/manual/en/tips.html#screenshot>`__
   -  [F19]_ `Prevent the Canvas Being Cleared <https://threejs.org/manual/en/tips.html#preservedrawingbuffer>`__
   -  [F20]_ `Get Keyboard Input From a Canvas <https://threejs.org/manual/en/tips.html#tabindex>`__
   -  [F21]_ `Make the Canvas Transparent <https://threejs.org/manual/en/tips.html#transparent-canvas>`__
   -  [F22]_ `Use three.js as Background in HTML <https://threejs.org/manual/en/tips.html#html-background>`__


Optimization
------------

   -  [F23]_ `Optimizing Lots of Objects <https://threejs.org/manual/en/optimize-lots-of-objects.html>`__
   -  [F24]_ `Optimizing Lots of Objects Animated <https://threejs.org/manual/en/optimize-lots-of-objects-animated.html>`__
   -  [F25]_ `Using OffscreenCanvas in a Web Worker <https://threejs.org/manual/en/offscreencanvas.html>`__


Solutions
---------

   -  [F26]_ `Load an .OBJ file <https://threejs.org/manual/en/load-obj.html>`__
   -  [F27]_ `Load a .GLTF file <https://threejs.org/manual/en/load-gltf.html>`__
   -  [F28]_ `Add a Background or Skybox <https://threejs.org/manual/en/backgrounds.html>`__
   -  [F29]_ `How to Draw Transparent Objects <https://threejs.org/manual/en/transparency.html>`__
   -  [F30]_ `Multiple Canvases, Multiple Scenes <https://threejs.org/manual/en/multiple-scenes.html>`__
   -  [F31]_ `Picking Objects with the mouse <https://threejs.org/manual/en/picking.html>`__
   -  [F32]_ `Post Processing <https://threejs.org/manual/en/post-processing.html>`__
   -  [F33]_ `Using Shadertoy shaders <https://threejs.org/manual/en/shadertoy.html>`__
   -  [F34]_ `Aligning HTML Elements to 3D <https://threejs.org/manual/en/align-html-elements-to-3d.html>`__
   -  [F35]_ `Using Indexed Textures for Picking and Color <https://threejs.org/manual/en/indexed-textures.html>`__
   -  [F36]_ `Using A Canvas for Dynamic Textures <https://threejs.org/manual/en/canvas-textures.html>`__
   -  [F37]_ `Billboards and Facades <https://threejs.org/manual/en/billboards.html>`__
   -  [F38]_ `Freeing Resources <https://threejs.org/manual/en/cleanup.html>`__
   -  [F39]_ `Making Voxel Geometry (Minecraft) <https://threejs.org/manual/en/voxel-geometry.html>`__
   -  [F40]_ `Start making a Game <https://threejs.org/manual/en/game.html>`__


WebXR
-----

   -  [F41]_ `VR - Basics <https://threejs.org/manual/en/webxr-basics.html>`__
   -  [F42]_ `VR - Look To Select <https://threejs.org/manual/en/webxr-look-to-select.html>`__
   -  [F43]_ `VR - Point To Select <https://threejs.org/manual/en/webxr-point-to-select.html>`__


Reference
---------

   -  [F44]_ `Material Table <https://threejs.org/manual/en/material-table.html>`__


.. _F01:
Fundamentals
============

   -  `Fundamentals <https://threejs.org/manual/en/fundamentals.html>`__

   This is the first article in a series of articles about three.js. `Three.js` 
   is a 3D library that tries to make it as easy as possible to get 3D content 
   on a webpage.

   Three.js is often confused with WebGL since more often than not, but not always,
   three.js uses WebGL to draw 3D. `WebGL is a very low-level system that only draws
   points, lines, and triangles <https://webglfundamentals.org>`__. To do anything
   useful with WebGL generally requires quite a bit of code and that is where three.js
   comes in. It handles stuff like scenes, lights, shadows, materials, textures, 3d
   math, all things that you'd have to write yourself if you were to use WebGL
   directly.

   These tutorials assume you already know JavaScript and, for the most part they will
   use ES6 style. `See here for a terse list of things you're expected to already
   know <#prerequisites>`__. Most browsers that support three.js are auto-updated
   so most users should be able to run this code. If you'd like to make this code run
   on really old browsers look into a transpiler like `Babel <https://babeljs.io>`__.
   Of course users running really old browsers probably have machines that can't run
   three.js.

   When learning most programming languages the first thing people do is make the
   computer print ``"Hello World!"``. For 3D one of the most common first things to do
   is to make a 3D cube. So let's start with "Hello Cube!"

   Before we get started let's try to give you an idea of the structure of a three.js
   app. A three.js app requires you to create a bunch of objects and connect them
   together. Here's a diagram that represents a small three.js app

   .. code:: javascript

                                    ╭───────────╮
                                    │   Render  │               ╭──────────╮
                                    ╰─────┬─────╯               │  Camera  │
                                          │                     ╰──────────╯
                ╭────────────┬────────────┬───────────┬───────────╮ 
            ╭────────╮ ╭────────────╮ ╭────────╮ ╭─────────╮ ╭─────────╮
            │  Mesh  │ │  Object3D  │ │  Mesh  │ │  Group  │ │  Light  │
            ╰────────╯ ╰─────┬──────╯ ╰────────╯ ╰────┬────╯ ╰─────────╯
                │       ╭─────────╮      │     ╭─────────────╮
                │  ╭────────╮ ╭────────╮ │ ╭────────╮ ╭────────────╮
                │  │  Mesh  │ │  Mesh  │ │ │  Mesh  │ │  Object3D  │
                │  ╰────┬───╯ ╰────┬───╯ │ ╰───┬────╯ ╰──────┬─────╯
                │       │          │     │     │         ╭─────────╮     
                │       │          │     │     │   ╭────────╮ ╭────────╮
                │       │          │     │     │   │  Mesh  │ │  Mesh  │
                │       │          │     │     │   ╰────────╯ ╰────────╯
              ╭──<─────────────────────┬────────────────╯──────────╯
              │                        │
      ╭──────────────╮         ╭──────────────╮         ╭──────────────╮
      │   Geometry   │         │   Material   │────────>│  Texture     │
      ╰─╭──── ··· ─────╮       ╰╭──── ··· ─────╮        ╰─╭──────────────╮
        │   Geometry   │        │   Material   │─────────>│  Texture     │
        ╰──────────────╯        ╰──────────────╯          ╰──────────────╯

      .. figure:: https://threejs.org/manual/resources/images/threejs-structure.svg


   Things to notice about the diagram above.

   -  There is a `Renderer`. This is arguably the main object of three.js. You pass a
      `Scene` and a `Camera` to a `Renderer` and it renders (draws) the
      portion of the 3D scene that is inside the *frustum* of the camera as a 2D image
      to a canvas.

   -  There is a `scenegraph` which is a tree like structure, consisting of various 
      objects like a `Scene` object, multiple `Mesh` objects, `Light` objects, 
      `Group`, `Object3D`, and `Camera` objects. A `Scene` object defines the root of the
      scenegraph and contains properties like the background color and fog. These
      objects define a hierarchical parent/child tree like structure and represent
      where objects appear and how they are oriented. Children are positioned and
      oriented relative to their parent. For example the wheels on a car might be
      children of the car so that moving and orienting the car's object automatically
      moves the wheels. You can read more about this in `the article on scenegraphs`.

      Note in the diagram `Camera` is half in half out of the scenegraph. This is 
      to represent that in three.js, unlike the other objects, a `Camera` does not 
      have to be in the scenegraph to function. Just like other objects, a `Camera`, 
      as a child of some other object, will move and orient relative to its parent 
      object. There is an example of putting multiple `Camera` objects in a
      scenegraph at the end of `the article on scenegraphs`.

   -  `Mesh` objects represent drawing a specific ``Geometry`` with a specific `Material`.
      Both `Material` objects and ``Geometry`` objects can be used by multiple `Mesh`
      objects. For example to draw two blue cubes in different locations we could need
      two `Mesh` objects to represent the position and orientation of each cube. 
      We would only need one ``Geometry`` to hold the vertex data for a cube and 
      we would only need one `Material` to specify the color blue. Both `Mesh` 
      objects could reference the same ``Geometry`` object and the same
      `Material` object.

   -  ``Geometry`` objects represent the vertex data of some piece of geometry like a
      sphere, cube, plane, dog, cat, human, tree, building, etc... Three.js provides
      many kinds of built in `geometry primitives`. You can also `create custom geometry` 
      as well as `load geometry from files`.

   -  `Material` objects represent `the surface properties used to draw geometry`
      including things like the color to use and how shiny it is. A `Material` 
      can also reference one or more `Texture` objects which can be used,
      for example, to wrap an image onto the surface of a geometry.

   -  `Texture` objects generally represent images either `loaded from image files`, 
      `generated from a canvas` or `rendered from another scene`.

   -  `Light` objects represent `different kinds of lights`.

   Given all of that we're going to make the smallest *"Hello Cube"* setup that looks
   like this

   .. code:: javascript


                     ╭───────────────╮     ╭─────────────────────╮
                     │  WebGLRender  │ ==> │  PerspectiveCamera  │
                     ╰───────────────╯     ╰─────────────────────╯
            ╭──────────────────────────────────────────────────────╮
            │                                                      │
            │                      ╭─────────╮                     │
            │                      │  Scene  │                     │
            │                      ╰────┬────╯                     │
            │                           │                          │
            │                       ╭────────╮                     │
            │                       │  Mesh  │                     │
            │                       ╰─┬────┬─╯                     │
            │                         │    │                       │
            ╰─────────────────────────│────│───────────────────────╯
                                      │    │
                       ╭──<───────────╯    ╰──────────╮
                       │                              │
               ╭───────────────╮            ╭─────────────────────╮
               │  BoxGeometry  │            │  MeshBasciMaterial  │
               ╰───────────────╯            ╰─────────────────────╯

      .. figure:: https://threejs.org/manual/resources/images/threejs-1cube-no-light-scene.svg


   First let's load three.js

   .. code:: javascript

      <script type="module">
      import * as THREE from 'three';
      </script>

   It's important you put ``type="module"`` in the script tag. This enables us to use
   the ``import`` keyword to load three.js. As of r147, this is the only way to load
   three.js properly. Modules have the advantage that they can easily import other
   modules they need. That saves us from having to manually load extra scripts they are
   dependent on.

   Next we need is a ``<canvas>`` tag so...

   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      </body>

   We will ask three.js to draw into that canvas so we need to look it up.

   .. code:: javascript

      <script type="module">
      import * as THREE from 'three';

      +function main() {
      +  const canvas = document.querySelector('#c');
      +  const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      +  ...
      </script>

   After we look up the canvas we create a `WebGLRenderer`. The renderer is the
   thing responsible for actually taking all the data you provide and rendering it to
   the canvas.

   Note there are some esoteric details here. If you don't pass a canvas into three.js
   it will create one for you but then you have to add it to your document. Where to
   add it may change depending on your use case and you'll have to change your code so
   I find that passing a canvas to three.js feels a little more flexible. I can put the
   canvas anywhere and the code will find it whereas if I had code to insert the canvas
   into to the document I'd likely have to change that code if my use case changed.

   Next up we need a camera. We'll create a `PerspectiveCamera`.

   .. code:: javascript

      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      const far = 5;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

   ``fov`` is short for ``field of view``. In this case 75 degrees in the vertical
   dimension. Note that most angles in three.js are in radians but for some reason the
   perspective camera takes degrees.

   ``aspect`` is the display aspect of the canvas. We'll go over the details `in
   the responsive article` but by default a canvas is 300x150 pixels which
   makes the aspect 300/150 or 2.

   ``near`` and ``far`` represent the space in front of the camera that will be
   rendered. Anything before that range or after that range will be clipped (not
   drawn).

   Those four settings define a `"frustum"`. A *frustum* is the name of a 3d shape that
   is like a pyramid with the tip sliced off. In other words think of the word
   "frustum" as another 3D shape like sphere, cube, prism, frustum.

   .. code:: javascript

      ▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦▦
            \                  far                 /
             \                                    /
              \                                  /
               \                                /
                \                              /
                 \                            /
                  \                          /
                   \                        /
                  ▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤▤
                     \        near        /
                      \                  /
                       \                /
                        \              /
                         \   <-fov->  /
                          \          /
                           \        /
                            \      /
                             \    /
                              \  /
                               \/
                               👁‍🗨

      .. image:: https://threejs.org/manual/resources/frustum-3d.svg


   The height of the near and far planes are determined by the field of view. The width
   of both planes is determined by the field of view and the aspect.

   Anything inside the defined frustum will be drawn. Anything outside will not.

   The camera defaults to looking down the -Z axis with +Y up. We'll put our cube at
   the origin so we need to move the camera back a little from the origin in order to
   see anything.

   .. code:: javascript

      camera.position.z = 2;

   Here's what we're aiming for.

   .. code:: javascript

      ╭───────────────────────────────────┬───────────────────────────────────╮
      │                                   │                                   │
      │                                   │                                   │
      │                \                  │                  /                │
      │                 \                 │                 /                 │
      │                  \                │                /                  │
      │                   \               │               /                   │
      │                    \              │              /                    │
      │                     \             │             /                     │
      │                      \        ╭───│───╮        /                      │
      │                       \       │   │   │       /                       │
      ├────────────────────────\──────────┼──────────/────────────────────────┤
      │                         \     │   │   │     /                         │
      │                          \    ╰───│───╯    /                          │
      │                           \       │       /                           │
      │                            \      │      /                            │
      │                             \     │     /                             │
      │                              \    │    /                              │
      │                               \   │   /                               │
      │                                \  │  /                                │
      │                                 \ │ /                                 │
      │                                  \│/                                  │
      │                                [Camera]                               │
      ╰───────────────────────────────────┴───────────────────────────────────╯

      .. image:: https://threejs.org/manual/resources/scene-down.svg


   In the diagram above we can see our camera is at ``z = 2``. It's looking down the -Z
   axis. Our frustum starts 0.1 units from the front of the camera and goes to 5 units
   in front of the camera. Because in this diagram we are looking down, the field of
   view is affected by the aspect. Our canvas is twice as wide as it is tall so across
   the canvas the field of view will be much wider than our specified 75 degrees which
   is the vertical field of view.

   Next we make a `Scene`. A `Scene` in three.js is the root of a form of
   scene graph. Anything you want three.js to draw needs to be added to the scene.
   We'll cover more details of `how scenes work in a future article`.

   .. code:: javascript

      const scene = new THREE.Scene();

   Next up we create a `BoxGeometry` which contains the data for a box. Almost 
   anything we want to display in Three.js needs geometry which defines the 
   vertices that make up our 3D object.

   .. code:: javascript

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

   We then create a basic material and set its color. Colors can be specified using
   standard CSS style 6 digit hex color values.

   .. code:: javascript

      const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

   We then create a `Mesh`. A `Mesh` in three.js represents the combination of
   three things

   #. A ``Geometry`` (the shape of the object)
   #. A `Material` (how to draw the object,
      shiny or flat, what color, what texture(s) to apply. Etc.)
   #. The position, orientation, and scale of that object in the scene relative to its
      parent. In the code below that parent is the scene.

   .. code:: javascript

      const cube = new THREE.Mesh(geometry, material);

   And finally we add that mesh to the scene

   .. code:: javascript

      scene.add(cube);

   We can then render the scene by calling the renderer's render function and passing
   it the scene and the camera

   .. code:: javascript

      renderer.render(scene, camera);

   Here's a working example

      `click here to open in a separate window <https://threejs.org/manual/examples/fundamentals.html>`__

   It's kind of hard to tell that is a 3D cube since we're viewing it directly down the
   -Z axis and the cube itself is axis aligned so we're only seeing a single face.

   Let's animate it spinning and hopefully that will make it clear it's being drawn in
   3D. To animate it we'll render inside a render loop using
   `requestAnimationFrame <https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame>`__.

   Here's our loop

   .. code:: javascript

      function render(time) {
         time *= 0.001;  // convert time to seconds

         cube.rotation.x = time;
         cube.rotation.y = time;

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

   ``requestAnimationFrame`` is a request to the browser that you want to animate
   something. You pass it a function to be called. In our case that function is
   ``render``. The browser will call your function and if you update anything related
   to the display of the page the browser will re-render the page. In our case we are
   calling three's ``renderer.render`` function which will draw our scene.

   ``requestAnimationFrame`` passes the time since the page loaded to our function.
   That time is passed in milliseconds. I find it's much easier to work with seconds so
   here we're converting that to seconds.

   We then set the cube's X and Y rotation to the current time. These rotations are in
   `radians <https://en.wikipedia.org/wiki/Radian>`__. There are 2 pi radians in a
   circle so our cube should turn around once on each axis in about 6.28 seconds.

   We then render the scene and request another animation frame to continue our loop.

   Outside the loop we call ``requestAnimationFrame`` one time to start the loop.

      `click here to open in a separate window <https://threejs.org/manual/examples/fundamentals-with-animation.html>`__

   It's a little better but it's still hard to see the 3d. What would help is to add
   some lighting so let's add a light. There are many kinds of lights in three.js which
   we'll go over in `a future lighting article`. For now let's create a
   directional light.

   .. code:: javascript

      const color = 0xFFFFFF;
      const intensity = 3;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(-1, 2, 4);
      scene.add(light);

   Directional lights have a position and a target. Both default to 0, 0, 0. In our
   case we're setting the light's position to -1, 2, 4 so it's slightly on the left,
   above, and behind our camera. The target is still 0, 0, 0 so it will shine toward
   the origin.

   We also need to change the material. The `MeshBasicMaterial` is not
   affected by lights. Let's change it to a `MeshPhongMaterial` which is
   affected by lights.

   .. code:: javascript

      -const material = new THREE.MeshBasicMaterial({color: 0x44aa88});  // greenish blue
      +const material = new THREE.MeshPhongMaterial({color: 0x44aa88});  // greenish blue

   Here is our new program structure

   .. code:: javascript

                     ╭───────────────╮     ╭─────────────────────╮
                     │  WebGLRender  │ ==> │  perspectiveCamera  │
                     ╰───────────────╯     ╰─────────────────────╯
            ╭──────────────────────────────────────────────────────╮
            │                                                      │
            │                      ╭─────────╮                     │
            │                      │  Scene  │                     │
            │                      ╰────┬────╯                     │
            │                   ╭─────────────────╮                │
            │         ╭──────────────────╮   ╭────────╮            │
            │         │ DirectionalLight │   │  Mesh  │            │
            │         ╰──────────────────╯   ╰─┬────┬─╯            │
            │                                  │    │              │
            ╰──────────────────────────────────│────│──────────────╯
                                               │    │
                       ╭──<────────────────────╯    ╰─╮
                       │                              │
               ╭───────────────╮            ╭─────────────────────╮
               │  BoxGeometry  │            │  MeshPhongMaterial  │
               ╰───────────────╯            ╰─────────────────────╯

      .. image:: https://threejs.org/manual/resources/images/threejs-1cube-with-directionallight.svg

   And here it is working.

      `click here to open in a separate window <https://threejs.org/manual/examples/fundamentals-with-light.html>`__

   It should now be pretty clearly 3D.

   Just for the fun of it let's add 2 more cubes.

   We'll use the same geometry for each cube but make a different material so each cube
   can be a different color.

   First we'll make a function that creates a new material with the specified color.
   Then it creates a mesh using the specified geometry and adds it to the scene and
   sets its X position.

   .. code:: javascript

      function makeInstance(geometry, color, x) {
         const material = new THREE.MeshPhongMaterial({color});

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);

         cube.position.x = x;

         return cube;
      }

   Then we'll call it 3 times with 3 different colors and X positions saving the
   `Mesh` instances in an array.

   .. code:: javascript

      const cubes = [
         makeInstance(geometry, 0x44aa88,  0),
         makeInstance(geometry, 0x8844aa, -2),
         makeInstance(geometry, 0xaa8844,  2),
      ];

   Finally we'll spin all 3 cubes in our render function. We compute a slightly
   different rotation for each one.

   .. code:: javascript

      function render(time) {
         time *= 0.001;  // convert time to seconds

         cubes.forEach((cube, ndx) => {
            const speed = 1 + ndx * .1;
            const rot = time * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
         });

         ...

   and here's that.

      `click here to open in a separate window <https://threejs.org/manual/examples/fundamentals-3-cubes.html>`__

   If you compare it to the top down diagram above you can see it matches our
   expectations. With cubes at X = -2 and X = +2 they are partially outside our
   frustum. They are also somewhat exaggeratedly warped since the field of view across
   the canvas is so extreme.

   Our program now has this structure

   .. code:: javascript

                     ╭───────────────╮     ╭─────────────────────╮
                     │  WebGLRender  │ ==> │  perspectiveCamera  │
                     ╰───────────────╯     ╰─────────────────────╯
            ╭──────────────────────────────────────────────────────╮
            │                                                      │
            │                      ╭─────────╮                     │
            │                      │  Scene  │                     │
            │                      ╰────┬────╯                     │
            │                   ╭───────┬─────────┬─────────╮      │
            │ ╭──────────────────╮  ╭────────╮╭────────╮╭────────╮ │
            │ │ DirectionalLight │  │  Mesh  ││  Mesh  ││  Mesh  │ │
            │ ╰──────────────────╯  ╰─┬────┬─╯╰─┬────┬─╯╰─┬────┬─╯ │
            │                         │    │    │    │    │    │   │
            ╰─────────────────────────│────│────│────│────│────│───╯
                                      │    │    │    │    │    │
                       ╭──<────────────────┴─────────┴─────────╯    
                       │              ╰─────────┴─────┬───╯
               ╭───────────────╮            ╭─────────────────────╮
               │  BoxGeometry  │            │  MeshPhongMaterial  │
               ╰───────────────╯            ╰─╭─────────────────────╮
                                              │  MeshPhongMaterial  │
                                              ╰─╭─────────────────────╮
                                                │  MeshPhongMaterial  │
                                                ╰─────────────────────╯

      .. image:: https://threejs.org/manual/resources/images/threejs-3cubes-scene.svg


   As you can see we have 3 `Mesh` objects each referencing the same `BoxGeometry`.
   Each `Mesh` references a unique `MeshPhongMaterial` so that each
   cube can have a different color.

   I hope this short intro helps to get things started. `Next up we'll cover making our
   code responsive so it is adaptable to multiple situations`.

   .. Tip:: es6 modules, three.js, and folder structure

      As of version r147 the preferred way to use three.js is via 
      `es6 modules <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import>`__
      and import maps.

      es6 modules can be loaded via the ``import`` keyword in a script or inline via a
      ``<script type="module">`` tag. Here's an example

      .. code:: javascript

         <script type="module">
         import * as THREE from 'three';

         ...

         </script>

      Notice ``'three'`` specifier there. If you leave it as it is, it will likely
      produce an error. An *import map* should be used to tell the browser where to
      find three.js

      .. code:: javascript

         <script type="importmap">
         {
            "imports": {
               "three": "./path/to/three.module.js"
            }
         }
         </script>

      Note that path specifier can start only with ``./`` or ``../``.

      To import addons like `OrbitControls.js <https://github.com/mrdoob/three.js/blob/master/examples/jsm/controls/OrbitControls.js>`__
      use the following

      .. code:: javascript

         import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

      Don't forget to add addons to the import map like so

      .. code:: javascript

         <script type="importmap">
         {
            "imports": {
               "three": "./path/to/three.module.js",
               "three/addons/": "./different/path/to/examples/jsm/"
            }
         }
         </script>

      You can also use a CDN

      .. code:: javascript

         <script type="importmap">
         {
            "imports": {
               "three": "https://cdn.jsdelivr.net/npm/three@<version>/build/three.module.js",
               "three/addons/": "https://cdn.jsdelivr.net/npm/three@<version>/examples/jsm/"
            }
         }
         </script>

      To conclude, the recommended way of using three.js is

      .. code:: javascript

         <script type="importmap">
         {
            "imports": {
               "three": "./path/to/three.module.js",
               "three/addons/": "./different/path/to/examples/jsm/"
            }
         }
         </script>

         <script type="module">
         import * as THREE from 'three';
         import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

         ...

         </script>


.. _F02:
Responsive Design
=================

   -  `Responsive Design <https://threejs.org/manual/en/responsive.html>`__

   This is the second article in a series of articles about three.js. The first 
   article was `about fundamentals`. If you haven't read that yet you
   might want to start there.

   This article is about how to make your three.js app be responsive to any situation.
   Making a webpage responsive generally refers to the page displaying well on
   different sized displays from desktops to tablets to phones.

   For three.js there are even more situations to consider. For example, a 3D editor
   with controls on the left, right, top, or bottom is something we might want to
   handle. A live diagram in the middle of a document is another example.

   The last sample we had used a plain canvas with no CSS and no size

   .. code:: javascript

      <canvas id="c"></canvas>

   That canvas defaults to 300x150 CSS pixels in size.

   In the web platform the recommended way to set the size of something is to use CSS.

   Let's make the canvas fill the page by adding CSS

   .. code:: javascript

      <style>
      html, body {
         margin: 0;
         height: 100%;
      }
      #c {
         width: 100%;
         height: 100%;
         display: block;
      }
      </style>

   In HTML the body has a margin of 5 pixels by default so setting the margin to 0
   removes the margin. Setting the html and body height to 100% makes them fill the
   window. Otherwise they are only as large as the content that fills them.

   Next we tell the ``id=c`` element to be 100% the size of its container which in this
   case is the body of the document.

   Finally we set its ``display`` mode to ``block``. A canvas's default display mode is
   ``inline``. Inline elements can end up adding whitespace to what is displayed. By
   setting the canvas to ``block`` that issue goes away.

   Here's the result

      `click here to open in a separate window <https://threejs.org/manual/examples/responsive-no-resize.html>`__

   You can see the canvas is now filling the page but there are 2 problems. One our
   cubes are stretched. They are not cubes they are more like boxes. Too tall or too
   wide. Open the example in its own window and resize it. You'll see how the cubes get
   stretched wide and tall.

      .. image:: https://threejs.org/manual/resources/images/resize-incorrect-aspect.png
         :class: threejs_center nobg
         :width: 407px

   The second problem is they look low resolution or blocky and blurry. Stretch the
   window really large and you'll really see the issue.


      .. image:: https://threejs.org/manual/resources/images/resize-low-res.png
         :class: threejs_center nobg

   Let's fix the stretchy problem first. To do that we need to set the aspect of the
   camera to the aspect of the canvas's display size. We can do that by looking at the
   canvas's ``clientWidth`` and ``clientHeight`` properties.

   We'll update our render loop like this

   .. code:: javascript

      function render(time) {
         time *= 0.001;

      +  const canvas = renderer.domElement;
      +  camera.aspect = canvas.clientWidth / canvas.clientHeight;
      +  camera.updateProjectionMatrix();

         ...

   Now the cubes should stop being distorted.

      `click here to open in a separate window <https://threejs.org/manual/examples/responsive-update-camera.html>`__

   Open the example in a separate window and resize the window and you should see the
   cubes are no longer stretched tall or wide. They stay the correct aspect regardless
   of window size.

      .. image:: https://threejs.org/manual/resources/images/resize-correct-aspect.png
         :class: threejs_center nobg
         :width: 407px

   Now let's fix the blockiness.

   Canvas elements have 2 sizes. One size is the size the canvas is displayed on the
   page. That's what we set with CSS. The other size is the number of pixels in the
   canvas itself. This is no different than an image. For example we might have a
   128x64 pixel image and using CSS we might display as 400x200 pixels.

   .. code:: javascript

      <img src="some128x64image.jpg" style="width:400px; height:200px">

   A canvas's internal size, its resolution, is often called its drawingbuffer size. In
   three.js we can set the canvas's drawingbuffer size by calling ``renderer.setSize``.
   What size should we pick? The most obvious answer is "the same size the canvas is
   displayed". Again, to do that we can look at the canvas's ``clientWidth`` and
   ``clientHeight`` properties.

   Let's write a function that checks if the renderer's canvas is not already the size
   it is being displayed as and if so set its size.

   .. code:: javascript

      function resizeRendererToDisplaySize(renderer) {
         const canvas = renderer.domElement;
         const width = canvas.clientWidth;
         const height = canvas.clientHeight;
         const needResize = canvas.width !== width || canvas.height !== height;
         if (needResize) {
            renderer.setSize(width, height, false);
         }
         return needResize;
      }

   Notice we check if the canvas actually needs to be resized. Resizing the canvas is
   an interesting part of the canvas spec and it's best not to set the same size if
   it's already the size we want.

   Once we know if we need to resize or not we then call ``renderer.setSize`` and pass
   in the new width and height. It's important to pass ``false`` at the end.
   ``render.setSize`` by default sets the canvas's CSS size but doing so is not what we
   want. We want the browser to continue to work how it does for all other elements
   which is to use CSS to determine the display size of the element. We don't want
   canvases used by three to be different than other elements.

   Note that our function returns true if the canvas was resized. We can use this to
   check if there are other things we should update. Let's modify our render loop to
   use the new function

   .. code:: javascript

      function render(time) {
         time *= 0.001;

      +  if (resizeRendererToDisplaySize(renderer)) {
      +    const canvas = renderer.domElement;
      +    camera.aspect = canvas.clientWidth / canvas.clientHeight;
      +    camera.updateProjectionMatrix();
      +  }

         ...

   Since the aspect is only going to change if the canvas's display size changed we
   only set the camera's aspect if ``resizeRendererToDisplaySize`` returns ``true``.

      `click here to open in a separate window <https://threejs.org/manual/examples/responsive.html>`__

   It should now render with a resolution that matches the display size of the canvas.

   To make the point about letting CSS handle the resizing let's take our code and put
   it in a separate ``.js`` `file <https://threejs.org/manual/examples/threejs-responsive.js>`__. 
   Here then are a few more examples where we let CSS choose the size and notice 
   we had to change zero code for them to work.

   Let's put our cubes in the middle of a paragraph of text.

      `click here to open in a separate
      window <https://threejs.org/manual/examples/responsive-paragraph.html>`__

   and here's our same code used in an editor style layout where the control area on
   the right can be resized.

      `click here to open in a separate
      window <https://threejs.org/manual/examples/responsive-editor.html>`__

   The important part to notice is no code changed. Only our HTML and CSS changed.


Handling HD-DPI displays
------------------------

   HD-DPI stands for high-density dot per inch displays. That's most Macs nowadays and
   many Windows machines as well as pretty much all smartphones.

   The way this works in the browser is they use CSS pixels to set the sizes which are
   supposed to be the same regardless of how high res the display is. The browser will
   just render text with more detail but the same physical size.

   There are various ways to handle HD-DPI with three.js.

   The first one is just not to do anything special. This is arguably the most common.
   Rendering 3D graphics takes a lot of GPU processing power. Mobile GPUs have less
   power than desktops, at least as of 2018, and yet mobile phones often have very high
   resolution displays. The current top of the line phones have an HD-DPI ratio of 3x
   meaning for every one pixel from a non-HD-DPI display those phones have 9 pixels.
   That means they have to do 9x the rendering.

   Computing 9x the pixels is a lot of work so if we just leave the code as it is we'll
   compute 1x the pixels and the browser will just draw it at 3x the size (3x by 3x =
   9x pixels).

   For any heavy three.js app that's probably what you want otherwise you're likely to
   get a slow framerate.

   That said if you actually do want to render at the resolution of the device there
   are a couple of ways to do this in three.js.

   One is to tell three.js a resolution multiplier using ``renderer.setPixelRatio``.
   You ask the browser what the multiplier is from CSS pixels to device pixels and pass
   that to three.js

   .. code:: javascript

         renderer.setPixelRatio(window.devicePixelRatio);

   After that any calls to ``renderer.setSize`` will magically use the size you request
   multiplied by whatever pixel ratio you passed in. **This is strongly NOT
   RECOMMENDED**. See below

   The other way is to do it yourself when you resize the canvas.

   .. code:: javascript

         function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const pixelRatio = window.devicePixelRatio;
            const width  = Math.floor( canvas.clientWidth  * pixelRatio );
            const height = Math.floor( canvas.clientHeight * pixelRatio );
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
               renderer.setSize(width, height, false);
            }
            return needResize;
         }

   This second way is objectively better. Why? Because it means I get what I ask for.
   There are many cases when using three.js where we need to know the actual size of
   the canvas's drawingBuffer. For example when making a post processing filter, or if
   we are making a shader that accesses ``gl_FragCoord``, if we are making a
   screenshot, or reading pixels for GPU picking, for drawing into a 2D canvas, etc...
   There are many cases where if we use ``setPixelRatio`` then our actual size will be
   different than the size we requested and we'll have to guess when to use the size we
   asked for and when to use the size three.js is actually using. By doing it ourselves
   we always know the size being used is the size we requested. There is no special
   case where magic is happening behind the scenes.

   Here's an example using the code above.

      `click here to open in a separate
      window <https://threejs.org/manual/examples/responsive-hd-dpi.html>`__

   It might be hard to see the difference but if you have an HD-DPI display and you
   compare this sample to those above you should notice the edges are more crisp.

   This article covered a very basic but fundamental topic. Next up lets quickly 
   `go over the basic primitives that three.js provides`.



.. _F03:
Prerequisites
=============

   -  `Prerequisites <https://threejs.org/manual/en/prerequisites.html>`__

   These articles are meant to help you learn how to use three.js. They assume you know
   how to program in JavaScript. They assume you know what the DOM is, how to write
   HTML as well as create DOM elements in JavaScript. They assume you know how to use
   `es6 modules <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import>`__
   via import and via ``<script type="module">`` tags. They assume you know how to use
   import maps. They assume you know some CSS and that you know what `CSS selectors
   are <https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Selectors>`__.
   They also assume you know ES5, ES6 and maybe some ES7. They assume you know that the
   browser runs JavaScript only via events and callbacks. They assume you know what a
   closure is.

   Here's some brief refreshers and notes


es6 modules
-----------

   es6 modules can be loaded via the ``import`` keyword in a script or inline via a
   ``<script type="module">`` tag. Here's an example

   .. code:: javascript

      <script type="importmap">
      {
         "imports": {
            "three": "./path/to/three.module.js",
            "three/addons/": "./different/path/to/examples/jsm/"
         }
      }
      </script>

      <script type="module">
      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

      ...

      </script>

   See more details at the bottom of `this article <fundamentals.html>`.


``document.querySelector`` and ``document.querySelectorAll``
------------------------------------------------------------

   You can use ``document.querySelector`` to select the first element that matches a
   CSS selector. ``document.querySelectorAll`` returns all elements that match a CSS
   selector.


You don't need ``onload``
-------------------------

   Lots of 20yr old pages use HTML like

   .. code:: javascript

      <body onload="somefunction()">

   That style is deprecated. Put your scripts at the bottom of the page.

   .. code:: javascript

      <html>
         <head>
            ...
         </head>
         <body>
            ...
         </body>
         <script>
            // inline javascript
         </script>
      </html>

   or `use the defer property <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script>`__.


Know how closures work
----------------------

   .. code:: javascript

      function a(v) {
         const foo = v;
         return function() {
            return foo;
         };
      }

      const f = a(123);
      const g = a(456);
      console.log(f());  // prints 123
      console.log(g());  // prints 456

   In the code above the function ``a`` creates a new function every time it's called.
   That function *closes* over the variable ``foo``. 
   
   Here's `more info <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures>`__.


Understand how ``this`` works
-----------------------------

   ``this`` is not magic. It's effectively a variable that is automatically passed to
   functions just like an argument is passed to function. The simple explanation is
   when you call a function directly like

   .. code:: javascript

      somefunction(a, b, c);

   ``this`` will be ``null`` (when in `strict mode` or in a module) where as when you
   call a function via the dot operator ``.`` like this

   .. code:: javascript

      someobject.somefunction(a, b, c);

   ``this`` will be set to ``someobject``.

   The parts where people get confused is with callbacks.

   .. code:: javascript

         const callback = someobject.somefunction;
         loader.load(callback);

   doesn't work as someone inexperienced might expect because when ``loader.load``
   calls the callback it's not calling it with the dot ``.`` operator so by default
   ``this`` will be null (unless the loader explicitly sets it to something). If you
   want ``this`` to be ``someobject`` when the callback happens you need to tell
   JavaScript that by binding it to the function.

   .. code:: javascript

         const callback = someobject.somefunction.bind(someobject);
         loader.load(callback);

   `this article might help explain this 
   <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this>`__.


ES5/ES6/ES7 stuff
-----------------


``var`` is deprecated. Use ``const`` and/or ``let``
---------------------------------------------------

   There is no reason to use ``var`` **EVER** and at this point it's considered bad
   practice to use it at all. Use ``const`` if the variable will never be reassigned
   which is most of the time. Use ``let`` in those cases where the value changes. This
   will help avoid tons of bugs.


Use ``for(elem of collection)`` never ``for(elem in collection)``
-----------------------------------------------------------------

   ``for of`` is new, ``for in`` is old. ``for in`` had issues that are solved by
   ``for of``

   As one example you can iterate over all the key/value pairs of an object with

   .. code:: javascript

      for (const [key, value] of Object.entries(someObject)) {
         console.log(key, value);
      }


Use ``forEach``, ``map``, and ``filter`` where useful
-----------------------------------------------------

   Arrays added the functions
   `forEach <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>`__,
   `map <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map>`__,
   and `filter <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter>`__
   and are used fairly extensively in modern JavaScript.


Use destructuring
-----------------

   Assume an object ``const dims = {width: 300, height: 150}``

   old code

   .. code:: javascript

      const width = dims.width;
      const height = dims.height;

   new code

   .. code:: javascript

      const {width, height} = dims;

   Destructuring works with arrays too. Assume an array
   ``const position = [5, 6, 7, 1]``;

   old code

   .. code:: javascript

      const y = position[1];
      const z = position[2];

   new code

   .. code:: javascript

      const [, y, z] = position;

   Destructuring also works in function arguments

   .. code:: javascript

      const dims = {width: 300, height: 150};
      const vector = [3, 4];

      function lengthOfVector([x, y]) {
         return Math.sqrt(x * x + y * y);
      }

      const dist = lengthOfVector(vector);  // dist = 5

      function area({width, height}) {
         return width * height;
      }
      const a = area(dims);  // a = 45000


Use object declaration short cuts
---------------------------------

   old code

   .. code:: javascript

         const width = 300;
         const height = 150;
         const obj = {
         width: width,
         height: height,
         area: function() {
            return this.width * this.height
         },
         };

   new code

   .. code:: javascript

         const width = 300;
         const height = 150;
         const obj = {
         width,
         height,
         area() {
            return this.width * this.height;
         },
         };


Use the rest parameter and the spread operator ``...``
------------------------------------------------------

   The rest parameter can be used to consume any number of parameters. Example

   .. code:: javascript

         function log(className, ...args) {
            const elem = document.createElement('div');
            elem.className = className;
            elem.textContent = args.join(' ');
            document.body.appendChild(elem);
         }

   The spread operator can be used to expand an iterable into arguments

   .. code:: javascript

      const position = [1, 2, 3];
      someMesh.position.set(...position);

   or copy an array

   .. code:: javascript

      const copiedPositionArray = [...position];
      copiedPositionArray.push(4); // [1,2,3,4]
      console.log(position); // [1,2,3] position is unaffected

   or to merge objects

   .. code:: javascript

      const a = {abc: 123};
      const b = {def: 456};
      const c = {...a, ...b};  // c is now {abc: 123, def: 456}


Use ``class``
-------------

   The syntax for making class like objects pre ES5 was unfamiliar to most programmers.
   As of ES5 you can now `use the class keyword <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes>`__
   which is closer to the style of C++/C#/Java.


Understand getters and setters
------------------------------

   `Getters <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get>`__
   and `setters <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set>`__
   are common in most modern languages. The ``class`` syntax of ES5 makes them much
   easier than pre ES5.


Use arrow functions where appropriate
-------------------------------------

   This is especially useful with callbacks and promises.

   .. code:: javascript

      loader.load((texture) => {
         // use texture
      });

   Arrow functions bind ``this`` to the context in which you create the arrow function.

   .. code:: javascript

      const foo = (args) => {/* code */};

   is a shortcut for

   .. code:: javascript

      const foo = (function(args) {/* code */}).bind(this));

   See link above for more info on ``this``.


Promises as well as async/await
-------------------------------

   Promises help with asynchronous code. Async/await help use promises.

   It's too big a topic to go into here but you can `read up on promises
   here <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>`__
   and `async/await here <https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await>`__.


Use Template Literals
---------------------

   Template literals are strings using backticks instead of quotes.

   .. code:: javascript

      const foo = `this is a template literal`;

   Template literals have basically 2 features. One is they can be multi-line

   .. code:: javascript

      const foo = `this
      is
      a
      template
      literal`;
      const bar = "this\nis\na\ntemplate\nliteral";

   ``foo`` and ``bar`` above are the same.

   The other is that you can pop out of string mode and insert snippets of JavaScript
   using ``${javascript-expression}``. This is the template part. Example:

   .. code:: javascript

      const r = 192;
      const g = 255;
      const b = 64;
      const rgbCSSColor = `rgb(${r},${g},${b})`;

   or

   .. code:: javascript

      const color = [192, 255, 64];
      const rgbCSSColor = `rgb(${color.join(',')})`;

   or

   .. code:: javascript

      const aWidth = 10;
      const bWidth = 20;
      someElement.style.width = `${aWidth + bWidth}px`;


Learn JavaScript coding conventions.
------------------------------------

   While you're welcome to format your code any way you chose there is at least one
   convention you should be aware of. Variables, function names, method names, in
   JavaScript are all lowerCasedCamelCase. Constructors, the names of classes are
   CapitalizedCamelCase. If you follow this rule you code will match most other
   JavaScript. Many `linters <https://eslint.org>`__, programs that check for obvious
   errors in your code, will point out errors if you use the wrong case since by
   following the convention above they can know when you're using something
   incorrectly.

   .. code:: javascript

      const v = new vector(); // clearly an error if all classes start with a capital letter
      const v = Vector();     // clearly an error if all functions start with a lowercase letter.


Consider using Visual Studio Code
---------------------------------

   Of course use whatever editor you want but if you haven't tried it consider using
   `Visual Studio Code <https://code.visualstudio.com/>`__ for JavaScript and after
   installing it `setup eslint <https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint>`__.
   It might take a few minutes to setup but it will help you immensely with finding
   bugs in your JavaScript.

   Some examples

   If you enable `the no-undef rule <https://eslint.org/docs/rules/no-undef>`__
   then VSCode via ESLint will warn you of many undefined variables.


      .. image:: https://threejs.org/manual/resources/images/vscode-eslint-not-defined.png

   Above you can see I mis-spelled ``doTheThing`` as ``doThing``. There's a red
   squiggle under ``doThing`` and hovering over it it tells me it's undefined. One
   error avoided.

   If you're using ``<script>`` tags to include three.js you'll get warnings using
   ``THREE`` so add ``/* global THREE */`` at the top of your JavaScript files to tell
   eslint that ``THREE`` exists. (or better, use ``import`` 😉)


      .. image:: https://threejs.org/manual/resources/images/vscode-eslint-not-a-constructor.png

   Above you can see eslint knows the rule that ``UpperCaseNames`` are constructors and
   so you should be using ``new``. Another error caught and avoided. This is `the
   ``new-cap`` rule <https://eslint.org/docs/rules/new-cap>`__.

   There are `100s of rules you can turn on or off or
   customize <https://eslint.org/docs/rules/>`__. For example above I mentioned you
   should use ``const`` and ``let`` over ``var``.

   Here I used ``var`` and it warned me I should use ``let`` or ``const``


      .. image:: https://threejs.org/manual/resources/images/vscode-eslint-var.png

   Here I used ``let`` but it saw I never change the value so it suggested I use
   ``const``.


      .. image:: https://threejs.org/manual/resources/images/vscode-eslint-let.png

   Of course if you'd prefer to keep using ``var`` you can just turn off that rule. As
   I said above though I prefer to use ``const`` and ``let`` over ``var`` as they just
   work better and prevent bugs.

   For those cases where you really need to override a rule `you can add comments to
   disable them <https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments>`__
   for a single line or a section of code.


If you really need to support legacy browsers use a transpiler
--------------------------------------------------------------

   Most modern browsers are auto-updated so using all these features will help you be
   productive and avoid bugs. That said, if you're on a project that absolutely must
   support old browsers there are `tools that will take your ES5/ES6/ES7 code and
   transpile the code back to pre ES5 Javascript <https://babeljs.io>`__.


.. _F04:
Setup
=====

   -  `Setup <https://threejs.org/manual/en/setup.html>`__

   This article is one in a series of articles about three.js. The first article 
   was `about three.js fundamentals`. If you haven't read that yet you might want 
   to start there.

   Before we go any further we need to talk about setting up your computer as a
   development environment. In particular, for security reasons, WebGL cannot use
   images from your hard drive directly. That means in order to do development you need
   to use a web server. Fortunately development web servers are super easy to setup and
   use.

   First off if you'd like you can download this entire site from `this link 
   <https://github.com/gfxfundamentals/threejsfundamentals/archive/gh-pages.zip>`__.
   Once downloaded double click the zip file to unpack the files.

   Next download one of these simple web servers.

   If you'd prefer a web server with a user interface there's
   `Servez <https://greggman.github.io/servez>`__


      .. image:: https://threejs.org/manual/resources/servez.gif

   Just point it at the folder where you unzipped the files, click "Start", then go to
   in your browser `http://localhost:8080/ <http://localhost:8080/>`__ or if you'd
   like to browse the samples go to `http://localhost:8080/threejs <http://localhost:8080/threejs>`__.

   To stop serving click stop or quit Servez.

   If you prefer the command line (I do), another way is to use
   `node.js <https://nodejs.org>`__. Download it, install it, then open a command
   prompt / console / terminal window. If you're on Windows the installer will add a
   special "Node Command Prompt" so use that.

   Then install the `servez <https://github.com/greggman/servez-cli>`__ by typing

   .. code:: javascript

      npm -g install servez

   If you're on OSX use

   .. code:: javascript

      sudo npm -g install servez

   Once you've done that type

   .. code:: javascript

      servez path/to/folder/where/you/unzipped/files

   Or if you're like me

   .. code:: javascript

      cd path/to/folder/where/you/unzipped/files
      servez

   It should print something like


      .. image:: https://threejs.org/manual/resources/servez-response.png

   Then in your browser go to `http://localhost:8080/ <http://localhost:8080/>`__.

   If you don't specify a path then servez will serve the current folder.

   If either of those options are not to your liking `there are many other simple
   servers to choose from <https://stackoverflow.com/questions/12905426/what-is-a-faster-alternative-to-pythons-servez-or-simplehttpserver>`__.

   Now that you have a server setup we can move on to `textures <textures.html>`.



.. _F05:

Primitives
==========

   -  `Primitives <https://threejs.org/manual/en/primitives.html>`__

   .. Note::

      Three.js 官方文档维护是花了心思的，原始几何体（Primitives）的手册页面使用了可交互 HTML
      元素，可以拖拽控制条来改变 WebGL 渲染参数。为了节省资源，页面上众多的几何体渲染到一个画布
      （Canvas），内容说明处使用 div 元素占位并接收用户事件（拖动）来改变渲染图形的角度。这种
      通过 dvi 元素来定义多摄像机视图的方法在文档中很常用。

      直接在说明内容中的 HTML 标签子层是找不到 <canvas> 标签的，它会被附加在页面的底部，并且
      铺满整个页面，在占位元素的坐标区域绘制相应的几何体。可以使用 API 查询它，：

      .. code:: javascript

         document.querySelector("canvas")

         // <canvas id=​"c" data-engine=​"three.js r166" width=​"2966" height=​"960" 
         //         style=​"transform:​ translateY(33986.5px)​;​">​


   This article is one in a series of articles about three.js. The first article 
   was `about fundamentals`. If you haven't read that yet you might want to 
   start there.

   Three.js has a large number of primitives. Primitives are generally 3D shapes that
   are generated at runtime with a bunch of parameters.

   It's common to use primitives for things like a sphere for a globe or a bunch of
   boxes to draw a 3D graph. It's especially common to use primitives to experiment and
   get started with 3D. For the majority of 3D apps it's more common to have an artist
   make 3D models in a 3D modeling program like `Blender <https://blender.org>`__ or
   `Maya <https://www.autodesk.com/products/maya/>`__ or `Cinema
   4D <https://www.maxon.net/en-us/products/cinema-4d/>`__. Later in this series we'll
   cover making and loading data from several 3D modeling programs. For now let's go
   over some of the available primitives.

   Many of the primitives below have defaults for some or all of their parameters so
   you can use more or less depending on your needs.




#BoxGeometry
~~~~~~~~~~~~

   <div data-primitive="BoxGeometry">
      A Box
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-BoxGeometry>`__

   .. code:: javascript

      const width = 8;  
      const height = 8;  
      const depth = 8;  
      const geometry = new THREE.BoxGeometry( width, height, depth );

      const width = 8;  
      const height = 8;  
      const depth = 8;  
      const widthSegments = 4;  
      const heightSegments = 4;  
      const depthSegments = 4;  
      const geometry = new THREE.BoxGeometry(
                                 width, height, depth,
                                 widthSegments, heightSegments, depthSegments );


#CircleGeometry
~~~~~~~~~~~~~~~

   <div data-primitive="CircleGeometry">
      A flat circle
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-CircleGeometry>`__

   .. code:: javascript

      const radius = 7;  
      const segments = 24;  
      const geometry = new THREE.CircleGeometry( radius, segments );

      const radius = 7;  
      const segments = 24;  
      const thetaStart = Math.PI * 0.25;  
      const thetaLength = Math.PI * 1.5;  
      const geometry = new THREE.CircleGeometry(
                                 radius, segments, thetaStart, thetaLength );


#ConeGeometry
~~~~~~~~~~~~~

   <div data-primitive="ConeGeometry">
      A Cone
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-ConeGeometry>`__

   .. code:: javascript

      const radius = 6;  
      const height = 8;  
      const radialSegments = 16;  
      const geometry = new THREE.ConeGeometry( radius, height, radialSegments );

      const radius = 6;  
      const height = 8;  
      const radialSegments = 16;  
      const heightSegments = 2;  
      const openEnded = true;  
      const thetaStart = Math.PI * 0.25;  
      const thetaLength = Math.PI * 1.5;  
      const geometry = new THREE.ConeGeometry(
                                 radius, height,
                                 radialSegments, heightSegments,
                                 openEnded,
                                 thetaStart, thetaLength );


#CylinderGeometry
~~~~~~~~~~~~~~~~~

   <div data-primitive="CylinderGeometry">
      A Cylinder
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-CylinderGeometry>`__

   .. code:: javascript

      const radiusTop = 4;  
      const radiusBottom = 4;  
      const height = 8;  
      const radialSegments = 12;  
      const geometry = new THREE.CylinderGeometry(
                                 radiusTop, radiusBottom, height, radialSegments );

      const radiusTop = 4;  
      const radiusBottom = 4;  
      const height = 8;  
      const radialSegments = 12;  
      const heightSegments = 2;  
      const openEnded = false;  
      const thetaStart = Math.PI * 0.25;  
      const thetaLength = Math.PI * 1.5;  
      const geometry = new THREE.CylinderGeometry(
                                 radiusTop, radiusBottom, height,
                                 radialSegments, heightSegments,
                                 openEnded,
                                 thetaStart, thetaLength );


#DodecahedronGeometry
~~~~~~~~~~~~~~~~~~~~~

   <div data-primitive="DodecahedronGeometry">
      A dodecahedron (12 sides)
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-DodecahedronGeometry>`__

   .. code:: javascript

      const radius = 7;  
      const geometry = new THREE.DodecahedronGeometry( radius );

      const radius = 7;  
      const detail = 2;  
      const geometry = new THREE.DodecahedronGeometry( radius, detail );



#ExtrudeGeometry
~~~~~~~~~~~~~~~~

   <div data-primitive="ExtrudeGeometry">
      An extruded 2d shape with optional bevelling. Here we are extruding a heart 
      shape. Note this is the basis for ``TextGeometry````.
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-ExtrudeGeometry>`__

   .. code:: javascript

      const shape = new THREE.Shape();
      const x = -2.5;
      const y = -5;
      shape.moveTo(x + 2.5, y + 2.5);
      shape.bezierCurveTo(x + 2.5, y + 2.5, x + 2, y, x, y);
      shape.bezierCurveTo(x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5);
      shape.bezierCurveTo(x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5);
      shape.bezierCurveTo(x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5);
      shape.bezierCurveTo(x + 8, y + 3.5, x + 8, y, x + 5, y);
      shape.bezierCurveTo(x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5);

      const extrudeSettings = {
         steps: 2,  
         depth: 2,  
         bevelEnabled: true,  
         bevelThickness: 1,  
         bevelSize: 1,  
         bevelSegments: 2,  
      };
      const geometry = THREE.ExtrudeGeometry(shape, extrudeSettings);


      const outline = new THREE.Shape([
         [ -2, -0.1], [  2, -0.1], [ 2,  0.6],
         [1.6,  0.6], [1.6,  0.1], [-2,  0.1],
      ].map(p => new THREE.Vector2(...p)));
      const x = -2.5;
      const y = -5;
      const shape = new THREE.CurvePath();

      const points = [
         [x + 2.5, y + 2.5],
         [x + 2.5, y + 2.5], [x + 2,   y      ], [x,       y      ],
         [x - 3,   y      ], [x - 3,   y + 3.5], [x - 3,   y + 3.5],
         [x - 3,   y + 5.5], [x - 1.5, y + 7.7], [x + 2.5, y + 9.5],
         [x + 6,   y + 7.7], [x + 8,   y + 4.5], [x + 8,   y + 3.5],
         [x + 8,   y + 3.5], [x + 8,   y      ], [x + 5,   y      ],
         [x + 3.5, y      ], [x + 2.5, y + 2.5], [x + 2.5, y + 2.5],
      ].map(p => new THREE.Vector3(...p, 0));

      for (let i = 0; i < points.length; i += 3) {
         shape.add(new THREE.CubicBezierCurve3(...points.slice(i, i + 4)));
      }

      const extrudeSettings = {
         steps: 100,  
         bevelEnabled: false,
         extrudePath: shape,
      };
      const geometry =  new THREE.ExtrudeGeometry(outline, extrudeSettings);
      return geometry;


#IcosahedronGeometry
~~~~~~~~~~~~~~~~~~~~

   <div data-primitive="IcosahedronGeometry">
      An icosahedron (20 sides)
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-IcosahedronGeometry>`__

   .. code:: javascript

      const radius = 7;  
      const geometry = new THREE.IcosahedronGeometry( radius );

      const radius = 7;  
      const detail = 2;  
      const geometry = new THREE.IcosahedronGeometry( radius, detail );



#LatheGeometry
~~~~~~~~~~~~~~

   <div data-primitive="LatheGeometry">
      A shape generated by spinning a line. Examples would be: lamps, bowling pins, 
      candles, candle holders, wine glasses, drinking glasses, etc... You provide 
      the 2d silhouette as series of points and then tell three.js how many subdivisions 
      to make as it spins the silhouette around an axis.
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-LatheGeometry>`__

   .. code:: javascript

      const points = [];
      for ( let i = 0; i < 10; ++ i ) {

         points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 3 + 3, ( i - 5 ) * .8 ) );

      }
      const geometry = new THREE.LatheGeometry( points );

      const points = [];
      for ( let i = 0; i < 10; ++ i ) {

         points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 3 + 3, ( i - 5 ) * .8 ) );

      }
      const segments = 12;  
      const phiStart = Math.PI * 0.25;  
      const phiLength = Math.PI * 1.5;  
      const geometry = new THREE.LatheGeometry(
                                 points, segments, phiStart, phiLength );


#OctahedronGeometry
~~~~~~~~~~~~~~~~~~~

   <div data-primitive="OctahedronGeometry">
      An Octahedron (8 sides)
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-OctahedronGeometry>`__

   .. code:: javascript

      const radius = 7;  
      const geometry = new THREE.OctahedronGeometry( radius );

      const radius = 7;  
      const detail = 2;  
      const geometry = new THREE.OctahedronGeometry( radius, detail );



#ParametricGeometry
~~~~~~~~~~~~~~~~~~~

   <div data-primitive="ParametricGeometry">
      A surface generated by providing a function that takes a 2D point from 
      a grid and returns the corresponding 3d point.
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-ParametricGeometry>`__

   .. code:: javascript

      const slices = 25;  
      const stacks = 25;  


      // from: https://github.com/mrdoob/three.js/blob/b8d8a8625465bd634aa68e5846354d69f34d2ff5/examples/js/ParametricGeometries.js
      function klein( v, u, target ) {

         u *= Math.PI;
         v *= 2 * Math.PI;
         u = u * 2;

         let x;
         let z;

         if ( u < Math.PI ) {

            x = 3 * Math.cos( u ) * ( 1 + Math.sin( u ) ) + ( 2 * ( 1 - Math.cos( u ) / 2 ) ) * Math.cos( u ) * Math.cos( v );
            z = - 8 * Math.sin( u ) - 2 * ( 1 - Math.cos( u ) / 2 ) * Math.sin( u ) * Math.cos( v );

         } else {

            x = 3 * Math.cos( u ) * ( 1 + Math.sin( u ) ) + ( 2 * ( 1 - Math.cos( u ) / 2 ) ) * Math.cos( v + Math.PI );
            z = - 8 * Math.sin( u );

         }

         const y = - 2 * ( 1 - Math.cos( u ) / 2 ) * Math.sin( v );

         target.set( x, y, z ).multiplyScalar( 0.75 );

      }

      return new ParametricGeometry(
         klein, slices, stacks );


#PlaneGeometry
~~~~~~~~~~~~~~

   <div data-primitive="PlaneGeometry">
      A 2D plane
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-PlaneGeometry>`__

   .. code:: javascript

      const width = 9;  
      const height = 9;  
      const geometry = new THREE.PlaneGeometry( width, height );

      const width = 9;  
      const height = 9;  
      const widthSegments = 2;  
      const heightSegments = 2;  
      const geometry = new THREE.PlaneGeometry(
                                 width, height,
                                 widthSegments, heightSegments );


#PolyhedronGeometry
~~~~~~~~~~~~~~~~~~~

   <div data-primitive="PolyhedronGeometry">
      Takes a set of triangles centered around a point and projects them onto a sphere
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-PolyhedronGeometry>`__

   .. code:: javascript

      const verticesOfCube = [
         - 1, - 1, - 1, 1, - 1, - 1, 1, 1, - 1, - 1, 1, - 1,
         - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, - 1, 1, 1,
      ];
      const indicesOfFaces = [
         2, 1, 0, 0, 3, 2,
         0, 4, 7, 7, 3, 0,
         0, 1, 5, 5, 4, 0,
         1, 2, 6, 6, 5, 1,
         2, 3, 7, 7, 6, 2,
         4, 5, 6, 6, 7, 4,
      ];
      const radius = 7;  
      const detail = 2;  
      const geometry = new THREE.PolyhedronGeometry(
                                 verticesOfCube, indicesOfFaces, radius, detail );


#RingGeometry
~~~~~~~~~~~~~

   <div data-primitive="RingGeometry">
      A 2D disc with a hole in the center
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-RingGeometry>`__

   .. code:: javascript

      const innerRadius = 2;  
      const outerRadius = 7;  
      const thetaSegments = 18;  
      const geometry = new THREE.RingGeometry(
                                 innerRadius, outerRadius, thetaSegments );

      const innerRadius = 2;  
      const outerRadius = 7;  
      const thetaSegments = 18;  
      const phiSegments = 2;  
      const thetaStart = Math.PI * 0.25;  
      const thetaLength = Math.PI * 1.5;  
      const geometry = new THREE.RingGeometry(
                                 innerRadius, outerRadius,
                                 thetaSegments, phiSegments,
                                 thetaStart, thetaLength );


#ShapeGeometry
~~~~~~~~~~~~~~

   <div data-primitive="ShapeGeometry">
      A 2D outline that gets triangulated
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-ShapeGeometry>`__

   .. code:: javascript

      const shape = new THREE.Shape();
      const x = - 2.5;
      const y = - 5;
      shape.moveTo( x + 2.5, y + 2.5 );
      shape.bezierCurveTo( x + 2.5, y + 2.5, x + 2, y, x, y );
      shape.bezierCurveTo( x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5 );
      shape.bezierCurveTo( x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5 );
      shape.bezierCurveTo( x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5 );
      shape.bezierCurveTo( x + 8, y + 3.5, x + 8, y, x + 5, y );
      shape.bezierCurveTo( x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5 );
      const geometry = new THREE.ShapeGeometry( shape );

      const shape = new THREE.Shape();
      const x = - 2.5;
      const y = - 5;
      shape.moveTo( x + 2.5, y + 2.5 );
      shape.bezierCurveTo( x + 2.5, y + 2.5, x + 2, y, x, y );
      shape.bezierCurveTo( x - 3, y, x - 3, y + 3.5, x - 3, y + 3.5 );
      shape.bezierCurveTo( x - 3, y + 5.5, x - 1.5, y + 7.7, x + 2.5, y + 9.5 );
      shape.bezierCurveTo( x + 6, y + 7.7, x + 8, y + 4.5, x + 8, y + 3.5 );
      shape.bezierCurveTo( x + 8, y + 3.5, x + 8, y, x + 5, y );
      shape.bezierCurveTo( x + 3.5, y, x + 2.5, y + 2.5, x + 2.5, y + 2.5 );
      const curveSegments = 5;  
      const geometry = new THREE.ShapeGeometry( shape, curveSegments );



#SphereGeometry
~~~~~~~~~~~~~~~

   <div data-primitive="SphereGeometry">
      A sphere
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-SphereGeometry>`__

   .. code:: javascript

      const radius = 7;  
      const widthSegments = 12;  
      const heightSegments = 8;  
      const geometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments );

      const radius = 7;  
      const widthSegments = 12;  
      const heightSegments = 8;  
      const phiStart = Math.PI * 0.25;  
      const phiLength = Math.PI * 1.5;  
      const thetaStart = Math.PI * 0.25;  
      const thetaLength = Math.PI * 0.5;  
      const geometry = new THREE.SphereGeometry(
                                 radius,
                                 widthSegments, heightSegments,
                                 phiStart, phiLength,
                                 thetaStart, thetaLength );


#TetrahedronGeometry
~~~~~~~~~~~~~~~~~~~~

   <div data-primitive="TetrahedronGeometry">
      A tetrahedron (4 sides)
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-TetrahedronGeometry>`__

   .. code:: javascript

      const radius = 7;  
      const geometry = new THREE.TetrahedronGeometry( radius );

      const radius = 7;  
      const detail = 2;  
      const geometry = new THREE.TetrahedronGeometry( radius, detail );



#TextGeometry
~~~~~~~~~~~~~

   <div data-primitive="TextGeometry">
      3D text generated from a 3D font and a string
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-TextGeometry>`__

   .. code:: javascript

      const loader = new THREE.FontLoader();

      loader.load('../resources/threejs/fonts/helvetiker_regular.typeface.json', (font) => {
         const text = 'three.js';  // three.js
         const geometry = new THREE.TextGeometry(text, {

                                 font: font,
                                 size: 3,  
                                 depth: 0.2,  
                                 curveSegments: 12,  
                                 bevelEnabled: true,  
                                 bevelThickness: 0.15,  
                                 bevelSize: 0.3,  
                                 bevelSegments: 5,  

         });
         ...
      });


#TorusGeometry
~~~~~~~~~~~~~~

   <div data-primitive="TorusGeometry">
      A torus (donut)
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-TorusGeometry>`__

   .. code:: javascript

      const radius = 5;  
      const tubeRadius = 2;  
      const radialSegments = 8;  
      const tubularSegments = 24;  
      const geometry = new THREE.TorusGeometry(
                                 radius, tubeRadius,
                                 radialSegments, tubularSegments );


#TorusKnotGeometry
~~~~~~~~~~~~~~~~~~

   <div data-primitive="TorusKnotGeometry">
      A torus knot
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-TorusKnotGeometry>`__

   .. code:: javascript

      const radius = 3.5;  
      const tubeRadius = 1.5;  
      const radialSegments = 8;  
      const tubularSegments = 64;  
      const p = 2;  
      const q = 3;  
      const geometry = new THREE.TorusKnotGeometry(
                                 radius, tubeRadius, tubularSegments, radialSegments, p, q );


#TubeGeometry
~~~~~~~~~~~~~

   <div data-primitive="TubeGeometry">
      A circle traced down a path
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-TubeGeometry>`__

   .. code:: javascript


      class CustomSinCurve extends THREE.Curve {

         constructor( scale ) {

            super();
            this.scale = scale;

         }
         getPoint( t ) {

            const tx = t * 3 - 1.5;
            const ty = Math.sin( 2 * Math.PI * t );
            const tz = 0;
            return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

         }

      }
      const path = new CustomSinCurve( 4 );
      const tubularSegments = 20;  
      const radius = 1;  
      const radialSegments = 8;  
      const closed = false;  
      const geometry = new THREE.TubeGeometry(
            path, tubularSegments, radius, radialSegments, closed )


#EdgesGeometry
~~~~~~~~~~~~~~

   <div data-primitive="EdgesGeometry">
      A helper object that takes another geometry as input and generates edges 
      only if the angle between faces is greater than some threshold. For example 
      if you look at the box at the top it shows a line going through each face 
      showing every triangle that makes the box. Using an ``EdgesGeometry`` instead 
      the middle lines are removed. Adjust the thresholdAngle below and you'll 
      see the edges below that threshold disappear.
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-EdgesGeometry>`__


   .. code:: javascript

      const size = 8;
      const widthSegments = 2;
      const heightSegments = 2;
      const depthSegments = 2;
      const boxGeometry = new THREE.BoxGeometry(size, size, size, widthSegments, 
                                                heightSegments, depthSegments);
      const geometry = new THREE.EdgesGeometry(boxGeometry);


      const radius = 7;
      const widthSegments = 6;
      const heightSegments = 3;
      const sphereGeometry = new THREE.SphereGeometry(radius,
                                                    widthSegments, heightSegments);
      const thresholdAngle = 1;  

      const geometry = new THREE.EdgesGeometry(sphereGeometry, thresholdAngle);



#WireframeGeometry
~~~~~~~~~~~~~~~~~~

   <div data-primitive="WireframeGeometry">
      Generates geometry that contains one line segment (2 points) per edge in 
      the given geometry. Without this you'd often be missing edges or get extra 
      edges since WebGL generally requires 2 points per line segment. For example 
      if all you had was a single triangle there would only be 3 points. If you 
      tried to draw it using a material with ``wireframe: true`` you would only 
      get a single line. Passing that triangle geometry to a ``WireframeGeometry`` 
      will generate a new geometry that has 3 lines segments using 6 points..
   </div>

   `Have a look  <https://threejs.org/manual/en/primitives.html#Diagram-WireframeGeometry>`__


   .. code:: javascript

      const size = 8;
      const widthSegments = 2;  

      const heightSegments = 2;  

      const depthSegments = 2;  

      const geometry = new THREE.WireframeGeometry(
            new THREE.BoxGeometry(
               size, size, size,
               widthSegments, heightSegments, depthSegments));


   We'll go over creating custom geometry in `another article <custom-buffergeometry>`. 
   For now let's make an example creating each type of primitive. We'll start with 
   the `examples from the previous article <responsive>`.

   Near the top let's set a background color


   .. code:: javascript

      const scene = new THREE.Scene();
      + scene.background = new THREE.Color(0xAAAAAA);


   This tells three.js to clear to lightish gray.

   The camera needs to change position so that we can see all the objects.


   .. code:: javascript

      - const fov = 75;
      + const fov = 40;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      - const far = 5;
      + const far = 1000;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      - camera.position.z = 2;
      + camera.position.z = 120;


   Let's add a function, ``addObject``, that takes an x, y position and an
   ``Object3D`` and adds the object to the scene.


   .. code:: javascript

      const objects = [];
      const spread = 15;

      function addObject(x, y, obj) {
         obj.position.x = x * spread;
         obj.position.y = y * spread;

         scene.add(obj);
         objects.push(obj);
      }


   Let's also make a function to create a random colored material. We'll use a feature
   of ``Color`` that lets you set a color based on hue,
   saturation, and luminance.

   ``hue`` goes from 0 to 1 around the color wheel with red at 0, green at .33 and blue
   at .66. ``saturation`` goes from 0 to 1 with 0 having no color and 1 being most
   saturated. ``luminance`` goes from 0 to 1 with 0 being black, 1 being white and 0.5
   being the maximum amount of color. In other words as ``luminance`` goes from 0.0 to
   0.5 the color will go from black to ``hue``. From 0.5 to 1.0 the color will go from
   ``hue`` to white.


   .. code:: javascript

      function createMaterial() {
         const material = new THREE.MeshPhongMaterial({
            side: THREE.DoubleSide,
         });

         const hue = Math.random();
         const saturation = 1;
         const luminance = .5;
         material.color.setHSL(hue, saturation, luminance);

         return material;
      }


   We also passed ``side: THREE.DoubleSide`` to the material. This tells three to draw
   both sides of the triangles that make up a shape. For a solid shape like a sphere or
   a cube there's usually no reason to draw the back sides of triangles as they all
   face inside the shape. In our case though we are drawing a few things like the
   ``PlaneGeometry`` and the ``ShapeGeometry`` which are 2 dimensional and so have 
   no inside. Without setting ``side: THREE.DoubleSide`` they would disappear when 
   looking at their back sides.

   I should note that it's faster to draw when **not** setting ``side: THREE.DoubleSide`` 
   so ideally we'd set it only on the materials that really need it but in this case 
   we are not drawing too much so there isn't much reason to worry about it.

   Let's make a function, ``addSolidGeometry``, that we pass a geometry and it creates
   a random colored material via ``createMaterial`` and adds it to the scene via
   ``addObject``.


   .. code:: javascript

      function addSolidGeometry(x, y, geometry) {
         const mesh = new THREE.Mesh(geometry, createMaterial());
         addObject(x, y, mesh);
      }


   Now we can use this for the majority of the primitives we create. For example
   creating a box


   .. code:: javascript

      {
         const width = 8;
         const height = 8;
         const depth = 8;
         addSolidGeometry(-2, -2, new THREE.BoxGeometry(width, height, depth));
      }


   If you look in the code below you'll see a similar section for each type of
   geometry.

   Here's the result:


      `click here to open in a separate window <https://threejs.org/manual/examples/primitives.html>`__

   There are a couple of notable exceptions to the pattern above. The biggest is
   probably the ``TextGeometry``. It needs to load 3D font data before it can 
   generate a mesh for the text. That data loads asynchronously so we need to 
   wait for it to load before trying to create the geometry. By promisifiying 
   font loading we can make it mush easier. We create a ``FontLoader`` and then 
   a function ``loadFont`` that returns a promise that on resolve will give us 
   the font. We then create an ``async`` function called ``doit`` and load the 
   font using ``await``. And finally create the geometry and call ``addObject`` 
   to add it the scene.


   .. code:: javascript

      {
         const loader = new FontLoader();
         // promisify font loading
         function loadFont(url) {
            return new Promise((resolve, reject) => {
            loader.load(url, resolve, undefined, reject);
            });
         }

         async function doit() {
            const font = await loadFont('resources/threejs/fonts/helvetiker_regular.typeface.json');  /* threejs.org: url */
            const geometry = new TextGeometry('three.js', {
               font: font,
               size: 3.0,
               depth: .2,
               curveSegments: 12,
               bevelEnabled: true,
               bevelThickness: 0.15,
               bevelSize: .3,
               bevelSegments: 5,
            });
            const mesh = new THREE.Mesh(geometry, createMaterial());
            geometry.computeBoundingBox();
            geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1);

            const parent = new THREE.Object3D();
            parent.add(mesh);

            addObject(-1, -1, parent);
         }
         doit();
      }


   There's one other difference. We want to spin the text around its center but by
   default three.js creates the text such that its center of rotation is on the left
   edge. To work around this we can ask three.js to compute the bounding box of the
   geometry. We can then call the ``getCenter`` method of the bounding box and pass it
   our mesh's position object. ``getCenter`` copies the center of the box into the
   position. It also returns the position object so we can call ``multiplyScalar(-1)``
   to position the entire object such that its center of rotation is at the center of
   the object.

   If we then just called ``addSolidGeometry`` like with previous examples it would set
   the position again which is no good. So, in this case we create an ``Object3D`` 
   which is the standard node for the three.js scene graph. ``Mesh`` is inherited 
   from ``Object3D`` as well. We'll cover `how the scene graph works in another article 
   <scenegraph>`. For now it's enough to know that like DOM nodes, children are 
   drawn relative to their parent. By making an ``Object3D`` and making our mesh a 
   child of that we can position the ``Object3D`` wherever we want and still keep 
   the center offset we set earlier.

   If we didn't do this the text would spin off center.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/primitives-text.html>`__

   Notice the one on the left is not spinning around its center whereas the one on 
   the right is.

   The other exceptions are the 2 line based examples for ``EdgesGeometry`` and
    ``WireframeGeometry``. Instead of calling ``addSolidGeometry`` they call 
    ``addLineGeometry`` which looks like this


   .. code:: javascript

      function addLineGeometry(x, y, geometry) {
         const material = new THREE.LineBasicMaterial({color: 0x000000});
         const mesh = new THREE.LineSegments(geometry, material);
         addObject(x, y, mesh);
      }


   It creates a black ``LineBasicMaterial`` and then creates a ``LineSegments`` 
   object which is a wrapper for ``Mesh`` that helps three know you're rendering 
   line segments (2 points per segment).

   Each of the primitives has several parameters you can pass on creation and it's best
   to `look in the documentation <https://threejs.org/docs/>`__ for all of them rather
   than repeat them here. You can also click the links above next to each shape to take
   you directly to the docs for that shape.

   There is one other pair of classes that doesn't really fit the patterns above. Those
   are the ``PointsMaterial`` and the ``Points`` class. ``Points`` is like ``LineSegments`` 
   above in that it takes a a ``BufferGeometry`` but draws points at each vertex 
   instead of lines. To use it you also need to pass it a ``PointsMaterial`` which 
   take a ``size`` for how large to make the points.


   .. code:: javascript

      const radius = 7;
      const widthSegments = 12;
      const heightSegments = 8;
      const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
      const material = new THREE.PointsMaterial({
            color: 'red',
            size: 0.2,     // in world units
      });
      const points = new THREE.Points(geometry, material);
      scene.add(points);


   You can turn off ``sizeAttenuation`` by setting it to false if you want the 
   points to be the same size regardless of their distance from the camera.


   .. code:: javascript

      const material = new THREE.PointsMaterial({
            color: 'red',
      +     sizeAttenuation: false,
      +     size: 3,       // in pixels
      -     size: 0.2,     // in world units
      });
      ...


   .. container:: spread

      <div data-diagram="PointsUniformSize" style="touch-action: none;"></div>


   One other thing that's important to cover is that almost all shapes have various
   settings for how much to subdivide them. A good example might be the sphere
   geometries. Spheres take parameters for how many divisions to make around and how
   many top to bottom. For example

   .. container:: spread

      <div data-diagram="SphereGeometryLow" style="touch-action: none;"></div>
      <div data-diagram="SphereGeometryMedium" style="touch-action: none;"></div>
      <div data-diagram="SphereGeometryHigh" style="touch-action: none;"></div>


   The first sphere has 5 segments around and 3 high which is 15 segments or 30
   triangles. The second sphere has 24 segments by 10. That's 240 segments or 480
   triangles. The last one has 50 by 50 which is 2500 segments or 5000 triangles.

   It's up to you to decide how many subdivisions you need. It might look like you need
   a high number of segments but remove the lines and the flat shading and we get this

   .. container:: spread

      <div data-diagram="SphereGeometryLowSmooth" style="touch-action: none;"></div>
      <div data-diagram="SphereGeometryMediumSmooth" style="touch-action: none;"></div>
      <div data-diagram="SphereGeometryHighSmooth" style="touch-action: none;"></div>

   It's now not so clear that the one on the right with 5000 triangles is entirely
   better than the one in the middle with only 480. If you're only drawing a few
   spheres, like say a single globe for a map of the earth, then a single 10000
   triangle sphere is not a bad choice. If on the other hand you're trying to draw 1000
   spheres then 1000 spheres times 10000 triangles each is 10 million triangles. To
   animate smoothly you need the browser to draw at 60 frames per second so you'd be
   asking the browser to draw 600 million triangles per second. That's a lot of
   computing.

   Sometimes it's easy to choose. For example you can also choose to subdivide a plane.

   .. container:: spread

      <div data-diagram="PlaneGeometryLow" style="touch-action: none;"></div>
      <div data-diagram="PlaneGeometryHigh" style="touch-action: none;"></div>

   The plane on the left is 2 triangles. The plane on the right is 200 triangles.
   Unlike the sphere there is really no trade off in quality for most use cases of a
   plane. You'd most likely only subdivide a plane if you expected to want to modify or
   warp it in some way. A box is similar.

   So, choose whatever is appropriate for your situation. The less subdivisions you
   choose the more likely things will run smoothly and the less memory they'll take.
   You'll have to decide for yourself what the correct tradeoff is for your particular
   situation.

   If none of the shapes above fit your use case you can load geometry for example from
   a `.obj file <load-obj>` or a `.gltf file <load-gltf>`. You can also
   create your own `custom BufferGeometry <custom-buffergeometry>`.

   Next up let's go over `how three's scene graph works and how to use it <scenegraph>`.



.. _F06:

Scenegraph
==========

   -  `Scenegraph <https://threejs.org/manual/en/scenegraph.html>`__

   This article is part of a series of articles about three.js. The first article is
   `three.js fundamentals <fundamentals>`. If you haven't read that yet you might 
   want to consider starting there.

   Three.js's core is arguably its scene graph. A scene graph in a 3D engine is a
   hierarchy of nodes in a graph where each node represents a local space.

   .. code:: javascript

                                 ╭──────────────╮
                                 │ Root (scene) │
                                 ╰───────┬──────╯
                           ╭────────────────────────────╮
                     ╭────────────╮               ╭────────────╮
                     │   child1   │               │   child2   │
                     ╰─────┬──────╯               ╰─────┬──────╯
            ╭──────────────────────────╮                │
      ╭────────────╮             ╭────────────╮   ╭────────────╮
      │  child1_1  │             │  child1_2  │   │  child2_1  │
      ╰────────────╯             ╰─────┬──────╯   ╰────────────╯
                                       │
                                 ╭────────────╮
                                 │ child1_2_1 │
                                 ╰────────────╯

      .. image:: https://threejs.org/manual/resources/images/scenegraph-generic.svg

   That's kind of abstract so let's try to give some examples.

   One example might be solar system, sun, earth, moon.

   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │
                                 ╰───────┬───────╯
                                         │
                                   ╭────────────╮
                                   │    sun     │
                                   ╰─────┬──────╯
                                         │
                                   ╭────────────╮
                                   │   earth    │
                                   ╰─────┬──────╯
                                         │
                                   ╭────────────╮
                                   │    moon    │
                                   ╰────────────╯

   .. image:: https://threejs.org/manual/resources/images/scenegraph-solarsystem.svg

   The Earth orbits the Sun. The Moon orbits the Earth. The Moon moves in a circle
   around the Earth. From the Moon's point of view it's rotating in the "local space"
   of the Earth. Even though its motion relative to the Sun is some crazy spirograph
   like curve from the Moon's point of view it just has to concern itself with rotating
   around the Earth's local space.

      https://threejs.org/manual/resources/moon-orbit.html

   To think of it another way, you living on the Earth do not have to think about the
   Earth's rotation on its axis nor its rotation around the Sun. You just walk or drive
   or swim or run as though the Earth is not moving or rotating at all. You walk,
   drive, swim, run, and live in the Earth's "local space" even though relative to the
   sun you are spinning around the earth at around 1000 miles per hour and around the
   sun at around 67,000 miles per hour. Your position in the solar system is similar to
   that of the moon above but you don't have to concern yourself. You just worry about
   your position relative to the earth in its "local space".

   Let's take it one step at a time. Imagine we want to make a diagram of the sun,
   earth, and moon. We'll start with the sun by just making a sphere and putting it at
   the origin. Note: We're using sun, earth, moon as a demonstration of how to use a
   scene graph. Of course the real sun, earth, and moon use physics but for our
   purposes we'll fake it with a scene graph.


   .. code:: javascript

      // an array of objects whose rotation to update
      const objects = [];

      // use just one sphere for everything
      const radius = 1;
      const widthSegments = 6;
      const heightSegments = 6;
      const sphereGeometry = new THREE.SphereGeometry(
            radius, widthSegments, heightSegments);

      const sunMaterial = new THREE.MeshPhongMaterial({emissive: 0xFFFF00}); // yellow sun
      const sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial);
      sunMesh.scale.set(5, 5, 5);  // make the sun large
      scene.add(sunMesh);
      objects.push(sunMesh);


   We're using a really low-polygon sphere. Only 6 subdivisions around its equator.
   This is so it's easy to see the rotation.

   We're going to reuse the same sphere for everything so we'll set a scale for the sun
   mesh of 5x.

   We also set the phong material's ``emissive`` property to yellow. A phong material's
   emissive property is basically the color that will be drawn with no light hitting
   the surface. Light is added to that color.

   Let's also put a single point light in the center of the scene. We'll go into more
   details about point lights later but for now the simple version is a point light
   represents light that emanates from a single point.


   .. code:: javascript

      {
         const color = 0xFFFFFF;
         const intensity = 3;
         const light = new THREE.PointLight(color, intensity);
         scene.add(light);
      }


   To make it easy to see we're going to put the camera directly above the origin
   looking down. The easiest way to do that is to use the ``lookAt`` function. The
   ``lookAt`` function will orient the camera from its position to "look at" the
   position we pass to ``lookAt``. Before we do that though we need to tell the camera
   which way the top of the camera is facing or rather which way is "up" for the
   camera. For most situations positive Y being up is good enough but since we are
   looking straight down we need to tell the camera that positive Z is up.


   .. code:: javascript

      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 50, 0);
      camera.up.set(0, 0, 1);
      camera.lookAt(0, 0, 0);


   In the render loop, adapted from previous examples, we're rotating all objects in
   our ``objects`` array with this code.


   .. code:: javascript

      objects.forEach((obj) => {
         obj.rotation.y = time;
      });


   Since we added the ``sunMesh`` to the ``objects`` array it will rotate.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun.html>`__

   Now let's add in the earth.


   .. code:: javascript

      const earthMaterial = new THREE.MeshPhongMaterial({color: 0x2233FF, emissive: 0x112244});
      const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial);
      earthMesh.position.x = 10;
      scene.add(earthMesh);
      objects.push(earthMesh);


   We make a material that is blue but we gave it a small amount of *emissive* blue so
   that it will show up against our black background.

   We use the same ``sphereGeometry`` with our new blue ``earthMaterial`` to make an
   ``earthMesh``. We position that 10 units to the left of the sun and add it to the
   scene. Since we added it to our ``objects`` array it will rotate too.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun-earth.html>`__

   You can see both the sun and the earth are rotating but the earth is not going
   around the sun. Let's make the earth a child of the sun


   .. code:: javascript

      - scene.add(earthMesh);
      + sunMesh.add(earthMesh);


   and...


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun-earth-orbit.html>`__

   What happened? Why is the earth the same size as the sun and why is it so far away?
   I actually had to move the camera from 50 units above to 150 units above to see the
   earth.

   We made the ``earthMesh`` a child of the ``sunMesh``. The ``sunMesh`` has its scale
   set to 5x with ``sunMesh.scale.set(5, 5, 5)``. That means the ``sunMesh``\ s local
   space is 5 times as big. Anything put in that space will be multiplied by 5. That
   means the earth is now 5x larger and its distance from the sun
   (``earthMesh.position.x = 10``) is also 5x as well.

   Our scene graph currently looks like this

   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │
                                 ╰───────┬───────╯
                                         │
                                  ╭──────────────╮
                                  │ sunMesh (5x) │
                                  ╰──────┬───────╯
                                         │
                                   ╭────────────╮
                                   │ earthMesh  │
                                   ╰────────────╯

      .. image:: https://threejs.org/manual/resources/images/scenegraph-sun-earth.svg


   To fix it let's add an empty scene graph node. We'll parent both the sun and the
   earth to that node.


   .. code:: javascript

      + const solarSystem = new THREE.Object3D();
      + scene.add(solarSystem);
      + objects.push(solarSystem);

      const sunMaterial = new THREE.MeshPhongMaterial({emissive: 0xFFFF00});
      const sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial);
      sunMesh.scale.set(5, 5, 5);
      - scene.add(sunMesh);
      + solarSystem.add(sunMesh);
      objects.push(sunMesh);

      const earthMaterial = new THREE.MeshPhongMaterial({color: 0x2233FF, emissive: 0x112244});
      const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial);
      earthMesh.position.x = 10;
      - sunMesh.add(earthMesh);
      + solarSystem.add(earthMesh);
      objects.push(earthMesh);


   Here we made an ``Object3D``. Like a ``Mesh`` it is also a node in the scene graph but
   unlike a ``Mesh`` it has no material or geometry. It just represents a local space.

   Our new scene graph looks like this

   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │
                                 ╰───────┬───────╯
                                         │
                                  ╭─────────────╮
                                  │ solarSystem │
                                  ╰──────┬──────╯
                                         │
                                ╭─────────────────╮
                        ╭──────────────╮    ╭────────────╮
                        │ sunMesh (5x) │    │ earthMesh  │
                        ╰──────────────╯    ╰────────────╯

      .. image:: https://threejs.org/manual/resources/images/scenegraph-sun-earth-fixed.svg


   Both the ``sunMesh`` and the ``earthMesh`` are children of the ``solarSystem``. All
   3 are being rotated and now because the ``earthMesh`` is not a child of the
   ``sunMesh`` it is no longer scaled by 5x.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun-earth-orbit-fixed.html>`__

   Much better. The earth is smaller than the sun and it's rotating around the sun and
   rotating itself.

   Continuing that same pattern let's add a moon.


   .. code:: javascript

      + const earthOrbit = new THREE.Object3D();
      + earthOrbit.position.x = 10;
      + solarSystem.add(earthOrbit);
      + objects.push(earthOrbit);

      const earthMaterial = new THREE.MeshPhongMaterial({color: 0x2233FF, emissive: 0x112244});
      const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial);
      - earthMesh.position.x = 10; // note that this offset is already set in its parent's THREE.Object3D object "earthOrbit"
      - solarSystem.add(earthMesh);
      + earthOrbit.add(earthMesh);
      objects.push(earthMesh);

      + const moonOrbit = new THREE.Object3D();
      + moonOrbit.position.x = 2;
      + earthOrbit.add(moonOrbit);

      + const moonMaterial = new THREE.MeshPhongMaterial({color: 0x888888, emissive: 0x222222});
      + const moonMesh = new THREE.Mesh(sphereGeometry, moonMaterial);
      + moonMesh.scale.set(.5, .5, .5);
      + moonOrbit.add(moonMesh);
      + objects.push(moonMesh);


   Again we added more invisible scene graph nodes. The first, an
   ``Object3D`` called ``earthOrbit`` and added both
   the ``earthMesh`` and the ``moonOrbit`` to it, also new. We then added the
   ``moonMesh`` to the ``moonOrbit``. The new scene graph looks like this.


   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │
                                 ╰───────┬───────╯
                                         │
                                  ╭─────────────╮
                                  │ solarSystem │
                                  ╰──────┬──────╯
                                         │
                                ╭─────────────────╮
                        ╭──────────────╮    ╭────────────╮
                        │ sunMesh (5x) │    │ earthOrbit │
                        ╰──────────────╯    ╰─────┬──────╯
                                                  │
                                          ╭─────────────────╮
                                    ╭──────────────╮  ╭────────────╮
                                    │   earthMesh  │  │  moonOrbit │
                                    ╰──────────────╯  ╰─────┬──────╯
                                                      ╭────────────╮
                                                      │  moonMesh  │
                                                      ╰────────────╯

      .. image:: https://threejs.org/manual/resources/images/scenegraph-sun-earth-moon.svg


   and here's that


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun-earth-moon.html>`__

   You can see the moon follows the spirograph pattern shown at the top of this article
   but we didn't have to manually compute it. We just setup our scene graph to do it
   for us.

   It is often useful to draw something to visualize the nodes in the scene graph.
   Three.js has some helpful ummmm, helpers to ummm, ... help with this.

   One is called an ``AxesHelper``. It draws 3 lines representing the local X, Y, 
   and Z axes. Let's add one to every node we created.


   .. code:: javascript

      // add an AxesHelper to each node
      objects.forEach((node) => {
         const axes = new THREE.AxesHelper();
         axes.material.depthTest = false;
         axes.renderOrder = 1;
         node.add(axes);
      });


   On our case we want the axes to appear even though they are inside the spheres. To
   do this we set their material's ``depthTest`` to false which means they will not
   check to see if they are drawing behind something else. We also set their
   ``renderOrder`` to 1 (the default is 0) so that they get drawn after all the
   spheres. Otherwise a sphere might draw over them and cover them up.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun-earth-moon-axes.html>`__

   We can see the x (red) and z (blue) axes. Since we are looking straight down and
   each of our objects is only rotating around its y axis we don't see much of the y
   (green) axes.

   It might be hard to see some of them as there are 2 pairs of overlapping axes. Both
   the ``sunMesh`` and the ``solarSystem`` are at the same position. Similarly the
   ``earthMesh`` and ``earthOrbit`` are at the same position. Let's add some simple
   controls to allow us to turn them on/off for each node. While we're at it let's also
   add another helper called the ``GridHelper``.
   It makes a 2D grid on the X,Z plane. By default the grid is 10x10 units.

   We're also going to use `lil-gui <https://github.com/georgealways/lil-gui>`__ which
   is a UI library that is very popular with three.js projects. lil-gui takes an object
   and a property name on that object and based on the type of the property
   automatically makes a UI to manipulate that property.

   We want to make both a ``GridHelper`` and an ``AxesHelper`` for each node. We need a 
   label for each node so we'll get rid of the old loop and switch to calling some 
   function to add the helpers for each node


   .. code:: javascript

      - // add an AxesHelper to each node
      - objects.forEach((node) => {
      -  const axes = new THREE.AxesHelper();
      -  axes.material.depthTest = false;
      -  axes.renderOrder = 1;
      -  node.add(axes);
      - });

      + function makeAxisGrid(node, label, units) {
      +   const helper = new AxisGridHelper(node, units);
      +   gui.add(helper, 'visible').name(label);
      + }
      + 
      + makeAxisGrid(solarSystem, 'solarSystem', 25);
      + makeAxisGrid(sunMesh, 'sunMesh');
      + makeAxisGrid(earthOrbit, 'earthOrbit');
      + makeAxisGrid(earthMesh, 'earthMesh');
      + makeAxisGrid(moonOrbit, 'moonOrbit');
      + makeAxisGrid(moonMesh, 'moonMesh');


   ``makeAxisGrid`` makes an ``AxisGridHelper`` which is a class we'll create to make
   lil-gui happy. Like it says above lil-gui will automagically make a UI that
   manipulates the named property of some object. It will create a different UI
   depending on the type of property. We want it to create a checkbox so we need to
   specify a ``bool`` property. But, we want both the axes and the grid to
   appear/disappear based on a single property so we'll make a class that has a getter
   and setter for a property. That way we can let lil-gui think it's manipulating a
   single property but internally we can set the visible property of both the
   ``AxesHelper`` and ``GridHelper`` for a node.


   .. code:: javascript

      // Turns both axes and grid visible on/off
      // lil-gui requires a property that returns a bool
      // to decide to make a checkbox so we make a setter
      // and getter for `visible` which we can tell lil-gui
      // to look at.
      class AxisGridHelper {
         constructor(node, units = 10) {
            const axes = new THREE.AxesHelper();
            axes.material.depthTest = false;
            axes.renderOrder = 2;  // after the grid
            node.add(axes);

            const grid = new THREE.GridHelper(units, units);
            grid.material.depthTest = false;
            grid.renderOrder = 1;
            node.add(grid);

            this.grid = grid;
            this.axes = axes;
            this.visible = false;
         }
         get visible() {
            return this._visible;
         }
         set visible(v) {
            this._visible = v;
            this.grid.visible = v;
            this.axes.visible = v;
         }
      }


   One thing to notice is we set the ``renderOrder`` of the ``AxesHelper`` to 2 
   and for the ``GridHelper`` to 1 so that the axes get drawn after the grid. 
   Otherwise the grid might overwrite the axes. **The smallest order draw first.**


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-sun-earth-moon-axes-grids.html>`__

   Turn on the ``solarSystem`` and you'll see how the earth is exactly 10 units out
   from the center just like we set above. You can see how the earth is in the *local
   space* of the ``solarSystem``. Similarly if you turn on the ``earthOrbit`` you'll
   see how the moon is exactly 2 units from the center of the *local space* of the
   ``earthOrbit``.

   A few more examples of scene graphs. An automobile in a simple game world might have
   a scene graph like this

   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │
                                 ╰───────┬───────╯
                                         │
                                  ╭─────────────╮
                                  │   Car body  │
                                  ╰──────┬──────╯
                                         │
               ╭──────────────────┬────────────────┬─────────────────╮
         ╭──────────────╮  ╭─────────────╮  ╭─────────────╮   ╭─────────────╮
         │  Left front  │  │ Right front │  │  Left back  │   │ Right back  │
         │    wheel     │  │    wheel    │  │   wheel     │   │     wheel   │
         ╰──────────────╯  ╰─────────────╯  ╰─────────────╯   ╰─────────────╯

   .. image:: https://threejs.org/manual/resources/images/scenegraph-car.svg


   If you move the car's body all the wheels will move with it. If you wanted the body
   to bounce separate from the wheels you might parent the body and the wheels to a
   "frame" node that represents the car's frame.

   Another example is a human in a game world.

   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │
                                 ╰───────┬───────╯
                                         │
                                 ╭───────────────╮
                                 │ Human (spot   │
                                 │ between feet) │
                                 ╰──────┬────────╯
                                        │
                                   ╭─────────╮
                                   │  Waist  │
                                   ╰────┬────╯
                        ╭─────────────────────────────┬─────────────────╮
                 ╭────────────╮                ╭─────────────╮   ╭─────────────╮
                 │   Torso    │                │  Left thigh │   │ Right thigh │
                 ╰────────────╯                ╰──────┬──────╯   ╰──────┬──────╯
          ╭────────────┬─────────────╮                │                 │
      ╭────────╮ ╭───────────╮ ╭───────────╮    ╭───────────╮     ╭───────────╮
      │  Neck  │ │    Left   │ │   Right   │    │    Left   │     │   Right   │
      ╰───┬────╯ │ upper arm │ │ upper arm │    │ lower leg │     │ lower leg │
      ╭────────╮ ╰─────┬─────╯ ╰─────┬─────╯    ╰─────┬─────╯     ╰─────┬─────╯
      │  Head  │ ╭───────────╮ ╭────────────╮  ╭─────────────╮   ╭─────────────╮
      ╰────────╯ │ Left hand │ │ Right hand │  │   Left foot │   │  Right foot │
                 ╰───────────╯ ╰────────────╯  ╰─────────────╯   ╰─────────────╯

      .. image:: https://threejs.org/manual/resources/images/scenegraph-human.svg

   You can see the scene graph gets pretty complex for a human. In fact that scene
   graph above is simplified. For example you might extend it to cover every finger (at
   least another 28 nodes) and every toe (yet another 28 nodes) plus ones for the face
   and jaw, the eyes and maybe more.

   Let's make one semi-complex scene graph. We'll make a tank. The tank will have 6
   wheels and a turret. The tank will follow a path. There will be a sphere that moves
   around and the tank will target the sphere.

   Here's the scene graph. The meshes are colored in green, the ``Object3D``\ s 
   in blue, the lights in gold, and the cameras in purple. One camera has not been 
   added to the scene graph.


   .. code:: javascript

                                 ╭───────────────╮
                                 │  Root (scene) │               ╭────────╮
                                 ╰───────┬───────╯               │ Camera │
                                         │                       ╰────────╯
             ╭──────────────┬──────────────┬──────────┬────────┬────────╮
      ╭─────────────╮╭──────────────╮╭────────────╮╭──────╮╭───────╮╭───────╮
      │ targetOrbit ││ splineObject ││ groundMesh ││ tank ││ light ││ light │
      ╰──────┬──────╯╰──────────────╯╰────────────╯╰───┬──╯╰───────╯╰───────╯
             │                                         │
      ╭───────────╮                              ╭──────────╮
      │   target  │                              │ bodyMesh │
      │ Eleavtion │                              ╰─────┬────╯
      ╰─────┬─────╯          ╭─────────────┬────────────┬──────────┬────────┬───────╮
      ╭───────────╮   ╭────────────╮╭─────────────╮╭──────────╮╭───────╮╭───────╮╭─────╮
      │ targetBob │   │ tankCamera ││ turretPivot ││ demoMesh ││ whell ││ whell ││ ··· │
      ╰─────┬─────╯   ╰────────────╯╰──────┬──────╯╰──────────╯╰───────╯╰───────╯╰─────╯
            ├─────────────────╮            ╰───────╮
      ╭───────────────────╮╭────────────╮   ╭─────────────╮
      │ targetCameraPivot ││ targetMesh │   │ turretMesh  │
      ╰─────┬─────────────╯╰────────────╯   ╰──────┬──────╯
      ╭────────────╮                        ╭──────────────╮
      │ tankCamera │                        │ turretCamera │
      ╰────────────╯                        ╰──────────────╯

      .. image:: https://threejs.org/manual/resources/images/scenegraph-tank.svg

   Look in the code to see the setup of all of these nodes.

   For the target, the thing the tank is aiming at, there is a ``targetOrbit``
   ``Object3D``) which just rotates similar to the ``earthOrbit`` above. 
   A ``targetElevation`` ``Object3D``) which is a child of the ``targetOrbit`` 
   provides an offset from the ``targetOrbit`` and a base elevation. Childed to 
   that is another ``Object3D`` called ``targetBob`` which just bobs up and down
   relative to the ``targetElevation``. Finally there's the ``targetMesh`` which 
   is just a cube we rotate and change its colors


   .. code:: javascript

      // move target
      targetOrbit.rotation.y = time * .27;
      targetBob.position.y = Math.sin(time * 2) * 4;
      targetMesh.rotation.x = time * 7;
      targetMesh.rotation.y = time * 13;
      targetMaterial.emissive.setHSL(time * 10 % 1, 1, .25);
      targetMaterial.color.setHSL(time * 10 % 1, 1, .25);


   For the tank there's an ``Object3D`` called ``tank`` which is used to move 
   everything below it around. The code uses a ``SplineCurve`` which it can ask for
   positions along that curve. 0.0 is the start of the curve. 1.0 is the end of the
   curve. It asks for the current position where it puts the tank. It then asks for a
   position slightly further down the curve and uses that to point the tank in that
   direction using ``Object3D.lookAt``.


   .. code:: javascript

      const tankPosition = new THREE.Vector2();
      const tankTarget = new THREE.Vector2();

      ...

      // move tank
      const tankTime = time * .05;
      curve.getPointAt(tankTime % 1, tankPosition);
      curve.getPointAt((tankTime + 0.01) % 1, tankTarget);
      tank.position.set(tankPosition.x, 0, tankPosition.y);
      tank.lookAt(tankTarget.x, 0, tankTarget.y);


   The turret on top of the tank is moved automatically by being a child of the tank.
   To point it at the target we just ask for the target's world position and then again
   use ``Object3D.lookAt``


   .. code:: javascript

      const targetPosition = new THREE.Vector3();

      ...

      // face turret at target
      targetMesh.getWorldPosition(targetPosition);
      turretPivot.lookAt(targetPosition);


   There's a ``turretCamera`` which is a child of the ``turretMesh`` so it will 
   move up and down and rotate with the turret. We make that aim at the target.


   .. code:: javascript

      // make the turretCamera look at target
      turretCamera.lookAt(targetPosition);


   There is also a ``targetCameraPivot`` which is a child of ``targetBob`` so it floats
   around with the target. We aim that back at the tank. Its purpose is to allow the
   ``targetCamera`` to be offset from the target itself. If we instead made the camera
   a child of ``targetBob`` and just aimed the camera itself it would be inside the
   target.


   .. code:: javascript

      // make the targetCameraPivot look at the tank
      tank.getWorldPosition(targetPosition);
      targetCameraPivot.lookAt(targetPosition);


   Finally we rotate all the wheels


   .. code:: javascript

      wheelMeshes.forEach((obj) => {
         obj.rotation.x = time * 3;
      });


   For the cameras we setup an array of all 4 cameras at init time with descriptions.


   .. code:: javascript

      const cameras = [
         { cam: camera, desc: 'detached camera', },
         { cam: turretCamera, desc: 'on turret looking at target', },
         { cam: targetCamera, desc: 'near target looking at tank', },
         { cam: tankCamera, desc: 'above back of tank', },
      ];

      const infoElem = document.querySelector('#info');


   and cycle through our cameras at render time.


   .. code:: javascript

      const camera = cameras[time * .25 % cameras.length | 0];
      infoElem.textContent = camera.desc;


      `click here to open in a separate
      window <https://threejs.org/manual/examples/scenegraph-tank.html>`__


   I hope this gives some idea of how scene graphs work and how you might use them.
   Making ``Object3D`` nodes and parenting things to
   them is an important step to using a 3D engine like three.js well. Often it might
   seem like some complex math is necessary to make something move and rotate the way
   you want. For example without a scene graph computing the motion of the moon or
   where to put the wheels of the car relative to its body would be very complicated
   but using a scene graph it becomes much easier.

   `Next up we'll go over materials <materials>`.



.. _F07:

Materials
=========

   -  `Materials <https://threejs.org/manual/en/materials.html>`__


   This article is part of a series of articles about three.js. The first article 
   is `three.js fundamentals <fundamentals>`. If you haven't read that yet and
   you're new to three.js you might want to consider starting there.

   Three.js provides several types of materials. They define how objects will appear in
   the scene. Which materials you use really depends on what you're trying to
   accomplish.

   There are 2 ways to set most material properties. One at creation time which we've
   seen before.


   .. code:: javascript

      const material = new THREE.MeshPhongMaterial({
         color: 0xFF0000,    // red (can also use a CSS color string here)
         flatShading: true,
      });


   The other is after creation


   .. code:: javascript

      const material = new THREE.MeshPhongMaterial();
      material.color.setHSL(0, 1, .5);  // red
      material.flatShading = true;


   note that properties of type ``THREE.Color`` have multiple ways to be set.


   .. code:: javascript

      material.color.set(0x00FFFF);    // same as CSS's #RRGGBB style
      material.color.set(cssString);   // any CSS color, eg 'purple', '#F32',
                                       // 'rgb(255, 127, 64)',
                                       // 'hsl(180, 50%, 25%)'
      material.color.set(someColor)    // some other THREE.Color
      material.color.setHSL(h, s, l)   // where h, s, and l are 0 to 1
      material.color.setRGB(r, g, b)   // where r, g, and b are 0 to 1


   And at creation time you can pass either a hex number or a CSS string


   .. code:: javascript

      const m1 = new THREE.MeshBasicMaterial({color: 0xFF0000});         // red
      const m2 = new THREE.MeshBasicMaterial({color: 'red'});            // red
      const m3 = new THREE.MeshBasicMaterial({color: '#F00'});           // red
      const m4 = new THREE.MeshBasicMaterial({color: 'rgb(255,0,0)'});   // red
      const m5 = new THREE.MeshBasicMaterial({color: 'hsl(0,100%,50%)'}); // red


   So let's go over three.js's set of materials.

   The ``MeshBasicMaterial`` is not affected by lights. The ``MeshLambertMaterial`` 
   computes lighting only at the vertices versus the ``MeshPhongMaterial`` which 
   computes lighting at every pixel. The ``MeshPhongMaterial`` also supports
   specular highlights.


   .. container:: spread

      Basic   <div data-diagram="MeshBasicMaterial" style="touch-action: none;"></div>
      Lambert <div data-diagram="MeshLambertMaterial" style="touch-action: none;"></div>
      Phong   <div data-diagram="MeshPhongMaterial" style="touch-action: none;"></div>

   .. container:: spread

         <div data-diagram="MeshBasicMaterialLowPoly" style="touch-action: none;"></div>
         <div data-diagram="MeshLambertMaterialLowPoly" style="touch-action: none;"></div>
         <div data-diagram="MeshPhongMaterialLowPoly" style="touch-action: none;"></div>

      low-poly models with same materials

   The ``shininess`` setting of the ``MeshPhongMaterial`` determines the
   *shininess* of the specular highlight. It defaults to 30.

   .. container:: spread

      shininess: 0     <div data-diagram="MeshPhongMaterialShininess0"></div>
      shininess: 30    <div data-diagram="MeshPhongMaterialShininess30"></div>
      shininess: 150   <div data-diagram="MeshPhongMaterialShininess150"></div>


   Note that setting the ``emissive`` property to a color on either a
   ``MeshLambertMaterial`` or a ``MeshPhongMaterial`` and setting the ``color`` 
   to black (and ``shininess`` to 0 for phong) ends up looking just like
   the ``MeshBasicMaterial``.

   .. container:: spread

      <div data-diagram="MeshBasicMaterialCompare"></div>
      Basic
      color: 'purple'

      <div data-diagram="MeshLambertMaterialCompare"></div>
      Lambert
      color: 'black'
      emissive: 'purple'

      <div data-diagram="MeshPhongMaterialCompare"></div>
      Phong
      color: 'black'
      emissive: 'purple'
      shininess: 0


   Why have all 3 when ``MeshPhongMaterial`` can do the same things as ``MeshBasicMaterial``
   and ``MeshLambertMaterial``? The reason is the more sophisticated material 
   takes more GPU power to draw. On a slower GPU like say a mobile phone you might 
   want to reduce the GPU power needed to draw your scene by using one of the less 
   complex materials. It also follows that if you don't need the extra features 
   then use the simplest material. If you don't need the lighting and the specular 
   highlight then use the ``MeshBasicMaterial``.

   The ``MeshToonMaterial`` is similar to the ``MeshPhongMaterial`` with
   one big difference. Rather than shading smoothly it uses a gradient map (an X by 1
   texture) to decide how to shade. The default uses a gradient map that is 70%
   brightness for the first 70% and 100% after but you can supply your own gradient
   map. This ends up giving a 2 tone look that looks like a cartoon.

   .. container:: spread

      <div data-diagram="MeshToonMaterial" style="touch-action: none;"></div>

   Next up there are 2 *physically based rendering* materials. Physically Based
   Rendering is often abbreviated PBR.

   The materials above use simple math to make materials that look 3D but they aren't
   what actually happens in real world. The 2 PBR materials use much more complex math
   to come close to what actually happens in the real world.

   The first one is ``MeshStandardMaterial``. The biggest difference between 
   ``MeshPhongMaterial`` and ``MeshStandardMaterial`` is it uses different 
   parameters. ``MeshPhongMaterial`` had a ``shininess`` setting. 
   ``MeshStandardMaterial`` has 2 settings ``roughness`` and ``metalness``.

   At a basic level ``roughness`` is the opposite of ``shininess``. Something 
   that has a high roughness, like a baseball doesn't have hard reflections 
   whereas something that's not rough, like a billiard ball, is very shiny. 
   Roughness goes from 0 to 1.

   The other setting, ``metalness``, says how metal the material is. Metals 
   behave differently than non-metals. 0 for non-metal and 1 for metal.

   Here's a quick sample of ``MeshStandardMaterial`` with ``roughness`` from 
   0 to 1 across and ``metalness`` from 0 to 1 down.

   .. container:: spread

      <div data-diagram="MeshStandardMaterial" style="min-height: 400px"></div>

   The ``MeshPhysicalMaterial`` is same as the ``MeshStandardMaterial`` but it
   adds a ``clearcoat`` parameter that goes from 0 to 1 for how much to apply a
   clearcoat gloss layer and a ``clearCoatRoughness`` parameter that specifies how
   rough the gloss layer is.

   Here's the same grid of ``roughness`` by ``metalness`` as above but with
   ``clearcoat`` and ``clearCoatRoughness`` settings.

   .. container:: spread

      <div data-diagram="MeshPhysicalMaterial" style="min-height: 400px">
      clearcoat           0.00 - 1.00     <input type="range" min="0" max="100">
      clearcoatRoughness  0.00 - 1.00     <input type="range" min="0" max="100">
      </div>

   The various standard materials progress from fastest to slowest
   ``MeshBasicMaterial`` ➡ ``MeshLambertMaterial`` ➡ ``MeshPhongMaterial`` ➡
   ``MeshStandardMaterial`` ➡ ``MeshPhysicalMaterial``. The slower materials can 
   make more realistic looking scenes but you might need to design your code to 
   use the faster materials on low powered or mobile machines.

   There are 3 materials that have special uses. ``ShadowMaterial`` is used to get the
   data created from shadows. We haven't covered shadows yet. When we do we'll use this
   material to take a peek at what's happening behind the scenes.

   The ``MeshDepthMaterial`` renders the depth of each pixel where pixels at negative
   ``near`` of the camera are 0 and negative ``far`` are 1. Certain special effects 
   can use this data which we'll get into at another time.

   .. container:: spread

      <div data-diagram="MeshDepthMaterial" style="touch-action: none;"></div>

   The ``MeshNormalMaterial`` will show you the *normals* of geometry. *Normals* 
   are the direction a particular triangle or pixel faces. ``MeshNormalMaterial`` 
   draws the view space normals (the normals relative to the camera). x is red, 
   y is green, and z is blue so things facing to the right will be pink, to the 
   left will be aqua, up will be light green, down will be purple, and toward 
   the screen will be lavender.

   .. container:: spread

      <div data-diagram="MeshNormalMaterial" style="touch-action: none;"></div>

   ``ShaderMaterial`` is for making custom materials using the three.js shader system.
   ``RawShaderMaterial`` is for making entirely custom shaders with no help from 
   three.js. Both of these topics are large and will be covered later.

   Most materials share a bunch of settings all defined by ``Material``. See the
   three.js API docs for all of them but let's go over two of the most commonly 
   used properties.

   ``flatShading``: whether or not the object looks faceted or smooth. default = ``false``.

   .. container:: spread

      ``flatShading: false``
      <div data-diagram="smoothShading" style="touch-action: none;"></div>
   
      ``flatShading: true``
      <div data-diagram="flatShading" style="touch-action: none;"></div>
   

   ``side``: which sides of triangles to show. The default is ``THREE.FrontSide``. 
   Other options are ``THREE.BackSide`` and ``THREE.DoubleSide`` (both sides). 
   Most 3D objects drawn in three are probably opaque solids so the back sides 
   (the sides facing inside the solid) do not need to be drawn. The most common 
   reason to set ``side`` is for planes or other non-solid objects where it is 
   common to see the back sides of triangles.

   Here are 6 planes drawn with ``THREE.FrontSide`` and ``THREE.DoubleSide``.

   .. container:: spread

      ``side: THREE.FrontSide``
      <div data-diagram="sideDefault" style="height: 250px; touch-action: none;"></div>

      ``side: THREE.DoubleSide``
      <div data-diagram="sideDouble" style="height: 250px; touch-action: none;"></div>


   There's really a lot to consider with materials and we actually still have a bunch
   more to go. In particular we've mostly ignored textures which open up a whole slew
   of options. Before we cover textures though we need to take a break and cover
   `setting up your development environment <setup>`


material.needsUpdate
~~~~~~~~~~~~~~~~~~~~

      This topic rarely affects most three.js apps but just as an FYI... Three.js
      applies material settings when a material is used where "used" means "something
      is rendered that uses the material". Some material settings are only applied once
      as changing them requires lots of work by three.js. In those cases you need to
      set ``material.needsUpdate = true`` to tell three.js to apply your material
      changes. The most common settings that require you to set ``needsUpdate`` if you
      change the settings after using the material are:

      -   ``flatShading``

      -  adding or removing a texture

         Changing a texture is ok, but if want to switch from using no texture to using
         a texture or from using a texture to using no texture then you need to set
         ``needsUpdate = true``.

         In the case of going from texture to no-texture it is often just better to use
         a 1x1 pixel white texture.

      As mentioned above most apps never run into these issues. Most apps do not switch
      between flat shaded and non flat shaded. Most apps also either use textures or a
      solid color for a given material, they rarely switch from using one to using the
      other.



.. _F08:

Textures
========

   -  `Textures <https://threejs.org/manual/en/textures.html>`__


   This article is one in a series of articles about three.js. The first article was
   `about three.js fundamentals <fundamentals>`. The `previous article <setup>` 
   was about setting up for this article. If you haven't read that yet you might 
   want to start there.

   Textures are a kind of large topic in Three.js and I'm not 100% sure at what level
   to explain them but I will try. There are many topics and many of them interrelate
   so it's hard to explain them all at once. Here's quick table of contents for this
   article.

   -  Hello Texture
   -  6 textures, a different one on each face of a cube
   -  Loading textures

      -  The easy way
      -  Waiting for a texture to load
      -  Waiting for multiple textures to load
      -  Loading textures from other origins

   -  Memory usage
   -  JPG vs PNG
   -  Filtering and mips
   -  Repeating, offseting, rotating, wrapping


Hello Texture
-------------

   Textures are *generally* images that are most often created in some 3rd party
   program like Photoshop or GIMP. For example let's put this image on cube.


   .. image:: https://threejs.org/manual/examples/resources/images/wall.jpg
      :class: border


   We'll modify one of our first samples. All we need to do is create a
   ``TextureLoader``. Call its ``load`` method with the URL of an image and set 
   the material's ``map`` property to the result instead of setting its ``color``.


   .. code:: javascript

      + const loader = new THREE.TextureLoader();
      + const texture = loader.load( 'resources/images/wall.jpg' );
      + texture.colorSpace = THREE.SRGBColorSpace;

      const material = new THREE.MeshBasicMaterial({
      -  color: 0xFF8844,
      +   map: texture,
      });


   Note that we're using ``MeshBasicMaterial`` so no need for any lights.


      `click here to open in a separate window <https://threejs.org/manual/examples/textured-cube.html>`__


6 Textures, a different one on each face of a cube
--------------------------------------------------

   How about 6 textures, one on each face of a cube?

   .. container:: threejs_center

      |flower-1.jpg| |flower-2.jpg| |flower-3.jpg|

      |flower-4.jpg| |flower-5.jpg| |flower-6.jpg|

.. |flower-1.jpg| image:: https://threejs.org/manual/examples/resources/images/flower-1.jpg
   :class: border
.. |flower-2.jpg| image:: https://threejs.org/manual/examples/resources/images/flower-2.jpg
   :class: border
.. |flower-3.jpg| image:: https://threejs.org/manual/examples/resources/images/flower-3.jpg
   :class: border
.. |flower-4.jpg| image:: https://threejs.org/manual/examples/resources/images/flower-4.jpg
   :class: border
.. |flower-5.jpg| image:: https://threejs.org/manual/examples/resources/images/flower-5.jpg
   :class: border
.. |flower-6.jpg| image:: https://threejs.org/manual/examples/resources/images/flower-6.jpg
   :class: border



   We just make 6 materials and pass them as an array when we create the ``Mesh``


   .. code:: javascript

      const loader = new THREE.TextureLoader();
      - const texture = loader.load( 'resources/images/wall.jpg' );
      - texture.colorSpace = THREE.SRGBColorSpace;

      - const material = new THREE.MeshBasicMaterial({
      -  map: texture,
      - });
      + const materials = [
      +   new THREE.MeshBasicMaterial({map: loadColorTexture('resources/images/flower-1.jpg')}),
      +   new THREE.MeshBasicMaterial({map: loadColorTexture('resources/images/flower-2.jpg')}),
      +   new THREE.MeshBasicMaterial({map: loadColorTexture('resources/images/flower-3.jpg')}),
      +   new THREE.MeshBasicMaterial({map: loadColorTexture('resources/images/flower-4.jpg')}),
      +   new THREE.MeshBasicMaterial({map: loadColorTexture('resources/images/flower-5.jpg')}),
      +   new THREE.MeshBasicMaterial({map: loadColorTexture('resources/images/flower-6.jpg')}),
      + ];
      - const cube = new THREE.Mesh(geometry, material);
      + const cube = new THREE.Mesh(geometry, materials);

      + function loadColorTexture( path ) {
      +   const texture = loader.load( path );
      +   texture.colorSpace = THREE.SRGBColorSpace;
      +   return texture;
      + }


   It works!


      `click here to open in a separate
      window <https://threejs.org/manual/examples/textured-cube-6-textures.html>`__

   It should be noted though that not all geometry types supports multiple materials.
   ``BoxGeometry`` can use 6 materials one for each face. ``ConeGeometry`` can use
   2 materials, one for the bottom and one for the cone. ``CylinderGeometry`` can use 3
   materials, bottom, top, and side. For other cases you will need to build or load
   custom geometry and/or modify texture coordinates.

   It's far more common in other 3D engines and far more performant to use a `Texture
   Atlas <https://en.wikipedia.org/wiki/Texture_atlas>`__ if you want to allow multiple
   images on a single geometry. A Texture atlas is where you put multiple images in a
   single texture and then use texture coordinates on the vertices of your geometry to
   select which parts of a texture are used on each triangle in your geometry.

   What are texture coordinates? They are data added to each vertex of a piece of
   geometry that specify what part of the texture corresponds to that specific vertex.
   We'll go over them when we start `building custom geometry <custom-buffergeometry>`.


Loading Textures
----------------


The Easy Way
~~~~~~~~~~~~

   Most of the code on this site uses the easiest method of loading textures. We create
   a ``TextureLoader`` and then call its ``load`` method. This returns a ``Texture`` object.


   .. code:: javascript

      const texture = loader.load('resources/images/flower-1.jpg');


   It's important to note that using this method our texture will be transparent until
   the image is loaded asynchronously by three.js at which point it will update the
   texture with the downloaded image.

   This has the big advantage that we don't have to wait for the texture to load and
   our page will start rendering immediately. That's probably okay for a great many use
   cases but if we want we can ask three.js to tell us when the texture has finished
   downloading.


Waiting for a texture to load
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To wait for a texture to load the ``load`` method of the texture loader takes a
   callback that will be called when the texture has finished loading. Going back to
   our top example we can wait for the texture to load before creating our
   ``Mesh`` and adding it to scene like this


   .. code:: javascript

      const loader = new THREE.TextureLoader();
      loader.load('resources/images/wall.jpg', (texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
         const material = new THREE.MeshBasicMaterial({
            map: texture,
         });
         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);
         cubes.push(cube);  // add to our list of cubes to rotate
      });


   Unless you clear your browser's cache and have a slow connection you're unlikely to
   see the any difference but rest assured it is waiting for the texture to load.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/textured-cube-wait-for-texture.html>`__


Waiting for multiple textures to load
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To wait until all textures have loaded you can use a ``LoadingManager``. Create one
   and pass it to the ``TextureLoader`` then set its ``onLoad`` property to a callback.


   .. code:: javascript

      + const loadManager = new THREE.LoadingManager();
      * const loader = new THREE.TextureLoader(loadManager);

      const materials = [
         new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-1.jpg')}),
         new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-2.jpg')}),
         new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-3.jpg')}),
         new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-4.jpg')}),
         new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-5.jpg')}),
         new THREE.MeshBasicMaterial({map: loader.load('resources/images/flower-6.jpg')}),
      ];

      + loadManager.onLoad = () => {
      +   const cube = new THREE.Mesh(geometry, materials);
      +   scene.add(cube);
      +   cubes.push(cube);  // add to our list of cubes to rotate
      + };


   The ``LoadingManager`` also has an ``onProgress`` property we can set to 
   another callback to show a progress indicator.

   First we'll add a progress bar in HTML


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="loading">
      +     <div class="progress"><div class="progressbar"></div></div>
      +   </div>
      </body>


   and the CSS for it


   .. code:: javascript

      #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
      }
      #loading .progress {
            margin: 1.5em;
            border: 1px solid white;
            width: 50vw;
      }
      #loading .progressbar {
            margin: 2px;
            background: white;
            height: 1em;
            transform-origin: top left;
            transform: scaleX(0);
      }


   Then in the code we'll update the scale of the ``progressbar`` in our ``onProgress``
   callback. It gets called with the URL of the last item loaded, the number of items
   loaded so far, and the total number of items loaded.


   .. code:: javascript

      + const loadingElem = document.querySelector('#loading');
      + const progressBarElem = loadingElem.querySelector('.progressbar');

      loadManager.onLoad = () => {
      +   loadingElem.style.display = 'none';
         const cube = new THREE.Mesh(geometry, materials);
         scene.add(cube);
         cubes.push(cube);  // add to our list of cubes to rotate
      };

      + loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
      +   const progress = itemsLoaded / itemsTotal;
      +   progressBarElem.style.transform = `scaleX(${progress})`;
      + };


   Unless you clear your cache and have a slow connection you might not see the loading
   bar.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/textured-cube-wait-for-all-textures.html>`__


Loading textures from other origins
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To use images from other servers those servers need to send the correct headers. If
   they don't you cannot use the images in three.js and will get an error. If you run
   the server providing the images make sure it `sends the correct headers 
   <https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>`__. If you don't
   control the server hosting the images and it does not send the permission headers
   then you can't use the images from that server.

   For example `imgur <https://imgur.com>`__, `flickr <https://flickr.com>`__, and
   `github <https://github.com>`__ all send headers allowing you to use images hosted
   on their servers in three.js. Most other websites do not.


Memory Usage
------------

   Textures are often the part of a three.js app that use the most memory. It's
   important to understand that *in general*, textures take
   ``width * height * 4 * 1.33`` bytes of memory.

   Notice that says nothing about compression. I can make a .jpg image and set its
   compression super high. For example let's say I was making a scene of a house.
   Inside the house there is a table and I decide to put this wood texture on the top
   surface of the table

   .. image:: https://threejs.org/manual/resources/images/compressed-but-large-wood-texture.jpg
      :class: border


   That image is only 157k so it will download relatively quickly but it is actually
   3024 x 3761 pixels in size of `<resources/images/compressed-but-large-wood-texture.jpg>`. 
   Following the equation above that's


   .. code:: javascript

      3024 * 3761 * 4 * 1.33 = 60505764.5


   That image will take **60 MEG OF MEMORY!** in three.js. A few textures like that and
   you'll be out of memory.

   I bring this up because it's important to know that using textures has a hidden
   cost. In order for three.js to use the texture it has to hand it off to the GPU and
   the GPU *in general* requires the texture data to be uncompressed.

   The moral of the story is make your textures small in dimensions not just small in
   file size. Small in file size = fast to download. Small in dimensions = takes less
   memory. How small should you make them? As small as you can and still look as good
   as you need them to look.


JPG vs PNG
----------

   This is pretty much the same as regular HTML in that JPGs have lossy compression,
   PNGs have lossless compression so PNGs are generally slower to download. But, PNGs
   support transparency. PNGs are also probably the appropriate format for non-image
   data like normal maps, and other kinds of non-image maps which we'll go over later.

   It's important to remember that a JPG doesn't use less memory than a PNG in WebGL.
   See above.


Filtering and Mips
------------------

   Let's apply this 16x16 texture

   .. image:: https://threejs.org/manual/resources/images/mip-low-res-enlarged.png
      :class: nobg

   To a cube

   .. container:: spread

      <div data-diagram="filterCube" style="touch-action: none;"></div>

   Let's draw that cube really small

   .. container:: spread

      <div data-diagram="filterCubeSmall" style="touch-action: none;"></div>

   Hmmm, I guess that's hard to see. Let's magnify that tiny cube

   .. container:: spread

      <div data-diagram="filterCubeSmallLowRes" style="touch-action: none;"></div>

   How does the GPU know which colors to make each pixel it's drawing for the tiny
   cube? What if the cube was so small that it's just 1 or 2 pixels?

   This is what filtering is about.

   If it was Photoshop, Photoshop would average nearly all the pixels together to
   figure out what color to make those 1 or 2 pixels. That would be a very slow
   operation. GPUs solve this issue using mipmaps.

   Mips are copies of the texture, each one half as wide and half as tall as the
   previous mip where the pixels have been blended to make the next smaller mip. Mips
   are created until we get all the way to a 1x1 pixel mip. For the image above all of
   the mips would end up being something like this

   .. image:: https://threejs.org/manual/resources/images/mipmap-low-res-enlarged.png
      :class: nobg

   Now, when the cube is drawn so small that it's only 1 or 2 pixels large the GPU can
   choose to use just the smallest or next to smallest mip level to decide what color
   to make the tiny cube.

   In three.js you can choose what happens both when the texture is drawn larger than
   its original size and what happens when it's drawn smaller than its original size.

   For setting the filter when the texture is drawn larger than its original size you
   set ``texture.magFilter`` property to either ``THREE.NearestFilter`` or 
   ``THREE.LinearFilter``. ``NearestFilter`` means just pick the closet single 
   pixel from the original texture. With a low resolution texture this gives you 
   a very pixelated look like Minecraft.

   ``LinearFilter`` means choose the 4 pixels from the texture that are closest to the
   where we should be choosing a color from and blend them in the appropriate
   proportions relative to how far away the actual point is from each of the 4 pixels.

   .. container:: spread

      **Nearest**
          <div data-diagram="filterCubeMagNearest" style="height: 250px; touch-action: none;"></div>

      **Linear**
          <div data-diagram="filterCubeMagLinear" style="height: 250px; touch-action: none;"></div>


   For setting the filter when the texture is drawn smaller than its original size you
   set the ``texture.minFilter`` property to one of 6 values.

   ==================================== ========================================
   ``THREE.NearestFilter``              same as above, choose the closest pixel in the texture
   ``THREE.LinearFilter``               same as above, choose 4 pixels from the texture and blend them
   ``THREE.NearestMipmapNearestFilter`` choose the appropriate mip then choose one pixel
   ``THREE.NearestMipmapLinearFilter``  choose 2 mips, choose one pixel from each, blend the 2 pixels
   ``THREE.LinearMipmapNearestFilter``  chose the appropriate mip then choose 4 pixels and blend them
   ``THREE.LinearMipmapLinearFilter``   choose 2 mips, choose 4 pixels from each and blend all 8 into 1 pixel
   ==================================== ========================================

   Here's an example showing all 6 settings

   .. container:: spread

      <div data-diagram="filterModes" style="height: 450px; position: relative;">
         <div class="filter-caption" style="left: 0.5em; top: 0.5em;">nearest</div>
         <div class="filter-caption" style="width: 100%;  text-align: center;    top: 0.5em;">linear</div>
         <div class="filter-caption" style="right: 0.5em; text-align: right;     top: 0.5em;">nearest<br>mipmap<br>nearest</div>
         <div class="filter-caption" style="left: 0.5em;  text-align: left;   bottom: 0.5em;">nearest<br>mipmap<br>linear</div>
         <div class="filter-caption" style="width: 100%;  text-align: center; bottom: 0.5em;">linear<br>mipmap<br>nearest</div>
         <div class="filter-caption" style="right: 0.5em; text-align: right;  bottom: 0.5em;">linear<br>mipmap<br>linear</div>
      </div>


   One thing to notice is the top left and top middle using ``NearestFilter`` and
   ``LinearFilter`` don't use the mips. Because of that they flicker in the distance
   because the GPU is picking pixels from the original texture. On the left just one
   pixel is chosen and in the middle 4 are chosen and blended but it's not enough come
   up with a good representative color. The other 4 strips do better with the bottom
   right, ``LinearMipmapLinearFilter`` being best.

   If you click the picture above it will toggle between the texture we've been using
   above and a texture where every mip level is a different color.

   .. container:: threejs_center

      <div data-texture-diagram="differentColoredMips">
         <canvas width="256" height="256" class="border" style="margin: 1px;"></canvas>
         <canvas width="128" height="128" class="border" style="margin: 1px;"></canvas>
         <canvas width="64"  height="64"  class="border" style="margin: 1px;"></canvas>
         <canvas width="32"  height="32"  class="border" style="margin: 1px;"></canvas>
         <canvas width="16"  height="16"  class="border" style="margin: 1px;"></canvas>
         <canvas width="8"   height="8"   class="border" style="margin: 1px;"></canvas>
         <canvas width="4"   height="4"   class="border" style="margin: 1px;"></canvas>
      </div>

   This makes it more clear what is happening. You can see in the top left and top
   middle the first mip is used all the way into the distance. The top right and bottom
   middle you can clearly see where a different mip is used.

   Switching back to the original texture you can see the bottom right is the
   smoothest, highest quality. You might ask why not always use that mode. The most
   obvious reason is sometimes you want things to be pixelated for a retro look or some
   other reason. The next most common reason is that reading 8 pixels and blending them
   is slower than reading 1 pixel and blending. While it's unlikely that a single
   texture is going to be the difference between fast and slow as we progress further
   into these articles we'll eventually have materials that use 4 or 5 textures all at
   once. 4 textures * 8 pixels per texture is looking up 32 pixels for ever pixel
   rendered. This can be especially important to consider on mobile devices.


Repeating, offseting, rotating, wrapping a texture
--------------------------------------------------

   Textures have settings for repeating, offseting, and rotating a texture.

   By default textures in three.js do not repeat. To set whether or not a texture
   repeats there are 2 properties, ``wrapS`` for horizontal wrapping and ``wrapT`` 
   for vertical wrapping.

   They can be set to one of:

   ================================ ============================================
   ``THREE.ClampToEdgeWrapping``    the last pixel on each edge is repeated forever
   ``THREE.RepeatWrapping``         the texture is repeated
   ``THREE.MirroredRepeatWrapping`` the texture is mirrored and repeated
   ================================ ============================================

   For example to turn on wrapping in both directions:


   .. code:: javascript

      someTexture.wrapS = THREE.RepeatWrapping;
      someTexture.wrapT = THREE.RepeatWrapping;


   Repeating is set with the [repeat] repeat property.


   .. code:: javascript

      const timesToRepeatHorizontally = 4;
      const timesToRepeatVertically = 2;
      someTexture.repeat.set(timesToRepeatHorizontally, timesToRepeatVertically);


   Offseting the texture can be done by setting the ``offset`` property. Textures are
   offset with units where 1 unit = 1 texture size. On other words 0 = no offset and 1
   = offset one full texture amount.


   .. code:: javascript

      const xOffset = .5;   // offset by half the texture
      const yOffset = .25;  // offset by 1/4 the texture
      someTexture.offset.set(xOffset, yOffset);


   Rotating the texture can be set by setting the ``rotation`` property in radians as
   well as the ``center`` property for choosing the center of rotation. It defaults to
   0,0 which rotates from the bottom left corner. Like offset these units are in
   texture size so setting them to ``.5, .5`` would rotate around the center of the
   texture.


   .. code:: javascript

      someTexture.center.set(.5, .5);
      someTexture.rotation = THREE.MathUtils.degToRad(45);


   Let's modify the top sample above to play with these values

   First we'll keep a reference to the texture so we can manipulate it


   .. code:: javascript

      + const texture = loader.load('resources/images/wall.jpg');
      const material = new THREE.MeshBasicMaterial({
      -  map: loader.load('resources/images/wall.jpg');
      +   map: texture,
      });


   Then we'll use `lil-gui <https://github.com/georgealways/lil-gui>`__ again to
   provide a simple interface.


   .. code:: javascript

      import {GUI} from 'three/addons/libs/lil-gui.module.min.js';


   As we did in previous lil-gui examples we'll use a simple class to give lil-gui an
   object that it can manipulate in degrees but that will set a property in radians.


   .. code:: javascript

      class DegRadHelper {
         constructor(obj, prop) {
            this.obj = obj;
            this.prop = prop;
         }
         get value() {
            return THREE.MathUtils.radToDeg(this.obj[this.prop]);
         }
         set value(v) {
            this.obj[this.prop] = THREE.MathUtils.degToRad(v);
         }
      }


   We also need a class that will convert from a string like ``"123"`` into a number
   like ``123`` since three.js requires numbers for enum settings like ``wrapS`` and
   ``wrapT`` but lil-gui only uses strings for enums.


   .. code:: javascript

      class StringToNumberHelper {
         constructor(obj, prop) {
            this.obj = obj;
            this.prop = prop;
         }
         get value() {
            return this.obj[this.prop];
         }
         set value(v) {
            this.obj[this.prop] = parseFloat(v);
         }
      }


   Using those classes we can setup a simple GUI for the settings above


   .. code:: javascript

      const wrapModes = {
         'ClampToEdgeWrapping': THREE.ClampToEdgeWrapping,
         'RepeatWrapping': THREE.RepeatWrapping,
         'MirroredRepeatWrapping': THREE.MirroredRepeatWrapping,
      };

      function updateTexture() {
         texture.needsUpdate = true;
      }

      const gui = new GUI();
      gui.add(new StringToNumberHelper(texture, 'wrapS'), 'value', wrapModes)
         .name('texture.wrapS')
         .onChange(updateTexture);
      gui.add(new StringToNumberHelper(texture, 'wrapT'), 'value', wrapModes)
         .name('texture.wrapT')
         .onChange(updateTexture);
      gui.add(texture.repeat, 'x', 0, 5, .01).name('texture.repeat.x');
      gui.add(texture.repeat, 'y', 0, 5, .01).name('texture.repeat.y');
      gui.add(texture.offset, 'x', -2, 2, .01).name('texture.offset.x');
      gui.add(texture.offset, 'y', -2, 2, .01).name('texture.offset.y');
      gui.add(texture.center, 'x', -.5, 1.5, .01).name('texture.center.x');
      gui.add(texture.center, 'y', -.5, 1.5, .01).name('texture.center.y');
      gui.add(new DegRadHelper(texture, 'rotation'), 'value', -360, 360)
         .name('texture.rotation');


   The last thing to note about the example is that if you change ``wrapS`` or
   ``wrapT`` on the texture you must also set ``texture.needsUpdate`` so three.js
   knows to apply those settings. The other settings are automatically applied.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/textured-cube-adjust.html>`__

   This is only one step into the topic of textures. At some point we'll go over
   texture coordinates as well as 9 other types of textures that can be applied to
   materials.

   For now let's move on to `lights <lights>`.



.. _F09:

Lights
======

   -  `Lights <https://threejs.org/manual/en/lights.html>`__

   *  ``AmbientLight``
   *  ``HemisphereLight``
   *  ``DirectionalLight``
   *  ``PointLight``
   *  ``SpotLight``
   *  ``RectAreaLight``

   This article is part of a series of articles about three.js. The first article is
   `three.js fundamentals <fundamentals>`. If you haven't read that yet and
   you're new to three.js you might want to consider starting there and also the
   article on `setting up your environment <setup>`. The `previous article was
   about textures <textures>`.

   Let's go over how to use the various kinds of lights in three.

   Starting with one of our previous samples let's update the camera. We'll set the
   field of view to 45 degrees, the far plane to 100 units, and we'll move the camera
   10 units up and 20 units back from the origin


   .. code:: javascript

      * const fov = 45;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      * const far = 100;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      + camera.position.set(0, 10, 20);


   Next let's add `OrbitControls <https://threejs.org/docs/examples/en/controls/OrbitControls.html>`__.
   `OrbitControls` let the user spin or *orbit* the camera around some point. 
   The `OrbitControls` are an optional feature of three.js so first we need to 
   include them in our page


   .. code:: javascript

      import * as THREE from 'three';
      + import {OrbitControls} from 'three/addons/controls/OrbitControls.js';


   Then we can use them. We pass the `OrbitControls` a camera to control
   and the DOM element to use to get input events


   .. code:: javascript

      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 5, 0);
      controls.update();


   We also set the target to orbit around to 5 units above the origin and then call
   ``controls.update`` so the controls will use the new target.

   Next up let's make some things to light up. First we'll make ground plane. We'll
   apply a tiny 2x2 pixel checkerboard texture that looks like this


   .. image:: https://threejs.org/manual/examples/resources/images/checker.png
      :class: border


   First we load the texture, set it to repeating, set the filtering to nearest, and
   set how many times we want it to repeat. Since the texture is a 2x2 pixel
   checkerboard, by repeating and setting the repeat to half the size of the plane each
   check on the checkerboard will be exactly 1 unit large;


   .. code:: javascript

      const planeSize = 40;

      const loader = new THREE.TextureLoader();
      const texture = loader.load('resources/images/checker.png');
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.magFilter = THREE.NearestFilter;
      texture.colorSpace = THREE.SRGBColorSpace;
      const repeats = planeSize / 2;
      texture.repeat.set(repeats, repeats);


   We then make a plane geometry, a material for the plane, and a mesh to insert it in
   the scene. Planes default to being in the XY plane but the ground is in the XZ plane
   so we rotate it.


   .. code:: javascript

      const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
      const planeMat = new THREE.MeshPhongMaterial({
         map: texture,
         side: THREE.DoubleSide,
      });
      const mesh = new THREE.Mesh(planeGeo, planeMat);
      mesh.rotation.x = Math.PI * -.5;
      scene.add(mesh);


   Let's add a cube and a sphere so we have 3 things to light including the plane


   .. code:: javascript

      {
         const cubeSize = 4;
         const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
         const cubeMat = new THREE.MeshPhongMaterial({color: '#8AC'});
         const mesh = new THREE.Mesh(cubeGeo, cubeMat);
         mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
         scene.add(mesh);
      }
      {
         const sphereRadius = 3;
         const sphereWidthDivisions = 32;
         const sphereHeightDivisions = 16;
         const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
         const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
         const mesh = new THREE.Mesh(sphereGeo, sphereMat);
         mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
         scene.add(mesh);
      }


   Now that we have a scene to light up let's add lights!


``AmbientLight``
----------------

   First let's make an ``AmbientLight``


   .. code:: javascript

      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.AmbientLight(color, intensity);
      scene.add(light);


   Let's also make it so we can adjust the light's parameters. We'll use
   `lil-gui <https://github.com/georgealways/lil-gui>`__ again. To be able to adjust
   the color via lil-gui we need a small helper that presents a property to lil-gui
   that looks like a CSS hex color string (eg: ``#FF8844``). Our helper will get the
   color from a named property, convert it to a hex string to offer to lil-gui. When
   lil-gui tries to set the helper's property we'll assign the result back to the
   light's color.

   Here's the helper:


   .. code:: javascript

      class ColorGUIHelper {
         constructor(object, prop) {
            this.object = object;
            this.prop = prop;
         }
         get value() {
            return `#${this.object[this.prop].getHexString()}`;
         }
         set value(hexString) {
            this.object[this.prop].set(hexString);
         }
      }


   And here's our code setting up lil-gui


   .. code:: javascript

      const gui = new GUI();
      gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      gui.add(light, 'intensity', 0, 2, 0.01);


   And here's the result


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lights-ambient.html>`__

   Click and drag in the scene to *orbit* the camera.

   Notice there is no definition. The shapes are flat. The
   ``AmbientLight`` effectively just multiplies
   the material's color by the light's color times the intensity.


   .. code:: javascript

      color = materialColor * light.color * light.intensity;


   That's it. It has no direction. This style of ambient lighting is actually not all
   that useful as lighting as it's 100% even so other than changing the color of
   everything in the scene it doesn't look much like *lighting*. What it does help with
   is making the darks not too dark.


``HemisphereLight``
-------------------

   Let's switch the code to a ``HemisphereLight``. A ``HemisphereLight`` takes a 
   sky color and a ground color and just multiplies the material's color between 
   those 2 colors—the sky color if the surface of the object is pointing up and 
   the ground color if the surface of the object is pointing down.

   Here's the new code


   .. code:: javascript

      - const color = 0xFFFFFF;
      + const skyColor = 0xB1E1FF;     // light blue
      + const groundColor = 0xB97A20;  // brownish orange
      const intensity = 1;
      - const light = new THREE.AmbientLight(color, intensity);
      + const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
      scene.add(light);


   Let's also update the lil-gui code to edit both colors


   .. code:: javascript

      const gui = new GUI();
      - gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      + gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('skyColor');
      + gui.addColor(new ColorGUIHelper(light, 'groundColor'), 'value').name('groundColor');
      gui.add(light, 'intensity', 0, 2, 0.01);


   The result:


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lights-hemisphere.html>`__

   Notice again there is almost no definition, everything looks kind of flat. The
   ``HemisphereLight`` used in combination with another light can help give a nice 
   kind of influence of the color of the sky and ground. In that way it's best 
   used in combination with some other light or a substitute for an ``AmbientLight``.


``DirectionalLight``
--------------------

   Let's switch the code to a ``DirectionalLight``. A ``DirectionalLight`` is often 
   used to represent the sun.


   .. code:: javascript

      const color = 0xFFFFFF;
      const intensity = 1;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(0, 10, 0);
      light.target.position.set(-5, 0, 0);
      scene.add(light);
      scene.add(light.target);


   Notice that we had to add the ``light`` and the ``light.target`` to the scene. 
   A three.js ``DirectionalLight`` will shine in the direction of its target.

   Let's make it so we can move the target by adding it to our GUI.


   .. code:: javascript

      const gui = new GUI();
      gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      gui.add(light, 'intensity', 0, 2, 0.01);
      gui.add(light.target.position, 'x', -10, 10);
      gui.add(light.target.position, 'z', -10, 10);
      gui.add(light.target.position, 'y', 0, 10);


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lights-directional.html>`__


   It's kind of hard to see what's going on. Three.js has a bunch of helper objects 
   we can add to our scene to help visualize invisible parts of a scene. In this case
   we'll use the ``DirectionalLightHelper`` which will draw a plane, to represent 
   the light, and a line from the light to the target. We just pass it the light 
   and add it to the scene.


   .. code:: javascript

      const helper = new THREE.DirectionalLightHelper(light);
      scene.add(helper);


   While we're at it let's make it so we can set both the position of the light 
   and the target. To do this we'll make a function that given a ``Vector3`` will 
   adjust its ``x``, ``y``, and ``z`` properties using ``lil-gui``.


   .. code:: javascript

      function makeXYZGUI(gui, vector3, name, onChangeFn) {
         const folder = gui.addFolder(name);
         folder.add(vector3, 'x', -10, 10).onChange(onChangeFn);
         folder.add(vector3, 'y', 0, 10).onChange(onChangeFn);
         folder.add(vector3, 'z', -10, 10).onChange(onChangeFn);
         folder.open();
      }


   Note that we need to call the helper's ``update`` function anytime we change
   something so the helper knows to update itself. As such we pass in an ``onChangeFn``
   function to get called anytime lil-gui updates a value.

   Then we can use that for both the light's position and the target's position like
   this


   .. code:: javascript

      + function updateLight() {
      +   light.target.updateMatrixWorld();
      +   helper.update();
      + }
      + updateLight();

      const gui = new GUI();
      gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      gui.add(light, 'intensity', 0, 2, 0.01);

      + makeXYZGUI(gui, light.position, 'position', updateLight);
      + makeXYZGUI(gui, light.target.position, 'target', updateLight);


   Now we can move the light, and its target


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lights-directional-w-helper.html>`__

   Orbit the camera and it gets easier to see. The plane represents a ``DirectionalLight``
   because a directional light computes light coming in one direction. There is no *point* 
   the light comes from, it's an infinite plane of light shooting out parallel rays of light.


``PointLight``
--------------

   A ``PointLight`` is a light that sits at a point and shoots light in all 
   directions from that point. Let's change the code.


   .. code:: javascript

      const color = 0xFFFFFF;
      - const intensity = 1;
      + const intensity = 150;
      - const light = new THREE.DirectionalLight(color, intensity);
      + const light = new THREE.PointLight(color, intensity);
      light.position.set(0, 10, 0);
      - light.target.position.set(-5, 0, 0);
      scene.add(light);
      - scene.add(light.target);


   Let's also switch to a ``PointLightHelper``


   .. code:: javascript

      - const helper = new THREE.DirectionalLightHelper(light);
      + const helper = new THREE.PointLightHelper(light);
      scene.add(helper);


   and as there is no target the ``onChange`` function can be simpler.


   .. code:: javascript

      function updateLight() {
      -  light.target.updateMatrixWorld();
         helper.update();
      }
      - updateLight();


   Note that at some level a ``PointLightHelper`` has no um, point. It just 
   draws a small wireframe diamond. It could just as easily be any shape you want,
   just add a mesh to the light itself.

   A ``PointLight`` has the added property of ``distance``. If the ``distance`` is
   0 then the ``PointLight`` shines to infinity. If the ``distance`` is greater 
   than 0 then the light shines its full intensity at the light and fades to no 
   influence at ``distance`` units away from the light.

   Let's setup the GUI so we can adjust the distance.


   .. code:: javascript

      const gui = new GUI();
      gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      gui.add(light, 'intensity', 0, 2, 0.01);
      + gui.add(light, 'distance', 0, 40).onChange(updateLight);

      makeXYZGUI(gui, light.position, 'position', updateLight);
      - makeXYZGUI(gui, light.target.position, 'target', updateLight);


   And now try it out.


      `click here to open in a separate window <https://threejs.org/manual/examples/lights-point.html>`__

   Notice when ``distance`` is > 0 how the light fades out.


``SpotLight``
-------------

   Spotlights are effectively a point light with a cone attached where the light only
   shines inside the cone. There's actually 2 cones. An outer cone and an inner cone.
   Between the inner cone and the outer cone the light fades from full intensity to
   zero.

   To use a ``SpotLight`` we need a target just like the directional light. The 
   light's cone will open toward the target.

   Modifying our ``DirectionalLight`` with helper from above


   .. code:: javascript

      const color = 0xFFFFFF;
      - const intensity = 1;
      + const intensity = 150;
      - const light = new THREE.DirectionalLight(color, intensity);
      + const light = new THREE.SpotLight(color, intensity);
      scene.add(light);
      scene.add(light.target);

      - const helper = new THREE.DirectionalLightHelper(light);
      + const helper = new THREE.SpotLightHelper(light);
      scene.add(helper);


   The spotlight's cone's angle is set with the ``angle`` property in radians. We'll use
   our ``DegRadHelper`` from the `texture article <textures>` to present a UI in degrees.


   .. code:: javascript

      gui.add(new DegRadHelper(light, 'angle'), 'value', 0, 90).name('angle').onChange(updateLight);


   The inner cone is defined by setting the ``penumbra`` property as a percentage
   from the outer cone. In other words when ``penumbra`` is 0 then the inner cone is
   the same size (0 = no difference) from the outer cone. When the ``penumbra`` is 1
   then the light fades starting in the center of the cone to the outer cone. When
   ``penumbra`` is .5 then the light fades starting from 50% between the center of the
   outer cone.


   .. code:: javascript

      gui.add(light, 'penumbra', 0, 1, 0.01);


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lights-spot-w-helper.html>`__


   Notice with the default ``penumbra`` of 0 the spotlight has a very sharp edge
   whereas as you adjust the ``penumbra`` toward 1 the edge blurs.

   It might be hard to see the *cone* of the spotlight. The reason is it's below the
   ground. Shorten the distance to around 5 and you'll see the open end of the cone.


``RectAreaLight``
-----------------

   There's one more type of light, the ``RectAreaLight``, which represents exactly
   what it sounds like, a rectangular area of light like a long fluorescent light or
   maybe a frosted sky light in a ceiling.

   The ``RectAreaLight`` only works with the ``MeshStandardMaterial`` and the
   ``MeshPhysicalMaterial`` so let's change all our materials to
   ``MeshStandardMaterial``


   .. code:: javascript

         ...

         const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
      -  const planeMat = new THREE.MeshPhongMaterial({
      +  const planeMat = new THREE.MeshStandardMaterial({
            map: texture,
            side: THREE.DoubleSide,
         });
         const mesh = new THREE.Mesh(planeGeo, planeMat);
         mesh.rotation.x = Math.PI * -.5;
         scene.add(mesh);
      }
      {
         const cubeSize = 4;
         const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      -  const cubeMat = new THREE.MeshPhongMaterial({color: '#8AC'});
      +  const cubeMat = new THREE.MeshStandardMaterial({color: '#8AC'});
         const mesh = new THREE.Mesh(cubeGeo, cubeMat);
         mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
         scene.add(mesh);
      }
      {
         const sphereRadius = 3;
         const sphereWidthDivisions = 32;
         const sphereHeightDivisions = 16;
         const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
      -  const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
      +  const sphereMat = new THREE.MeshStandardMaterial({color: '#CA8'});
         const mesh = new THREE.Mesh(sphereGeo, sphereMat);
         mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
         scene.add(mesh);
      }


   To use the ``RectAreaLight`` we need to include some extra three.js optional 
   data and we'll include the ``RectAreaLightHelper`` to help us visualize the light


   .. code:: javascript

      import * as THREE from 'three';
      + import {RectAreaLightUniformsLib} from 'three/addons/lights/RectAreaLightUniformsLib.js';
      + import {RectAreaLightHelper} from 'three/addons/helpers/RectAreaLightHelper.js';


   and we need to call ``RectAreaLightUniformsLib.init``


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      +   RectAreaLightUniformsLib.init();


   If you forget the data the light will still work but it will look funny so be sure
   to remember to include the extra data.

   Now we can create the light


   .. code:: javascript

      const color = 0xFFFFFF;
      * const intensity = 5;
      + const width = 12;
      + const height = 4;
      * const light = new THREE.RectAreaLight(color, intensity, width, height);
      light.position.set(0, 10, 0);
      + light.rotation.x = THREE.MathUtils.degToRad(-90);
      scene.add(light);

      * const helper = new RectAreaLightHelper(light);
      * light.add(helper);


   One thing to notice is that unlike the ``DirectionalLight`` and the ``SpotLight``, 
   the ``RectAreaLight`` does not use a target. It just uses its rotation. Another 
   thing to notice is the helper needs to be a child of the light. It is not a child 
   of the scene like other helpers.

   Let's also adjust the GUI. We'll make it so we can rotate the light and adjust its
   ``width`` and ``height``


   .. code:: javascript

      const gui = new GUI();
      gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      gui.add(light, 'intensity', 0, 10, 0.01);
      gui.add(light, 'width', 0, 20);
      gui.add(light, 'height', 0, 20);
      gui.add(new DegRadHelper(light.rotation, 'x'), 'value', -180, 180).name('x rotation');
      gui.add(new DegRadHelper(light.rotation, 'y'), 'value', -180, 180).name('y rotation');
      gui.add(new DegRadHelper(light.rotation, 'z'), 'value', -180, 180).name('z rotation');

      makeXYZGUI(gui, light.position, 'position');


   And here is that.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lights-rectarea.html>`__

   It's important to note each light you add to the scene slows down how fast three.js
   renders the scene so you should always try to use as few as possible to achieve your
   goals.

   Next up let's go over `dealing with cameras <cameras>`.



.. _F10:

Cameras
=======

   -  `Cameras <https://threejs.org/manual/en/cameras.html>`__


   This article is one in a series of articles about three.js. The first article was
   `about fundamentals <fundamentals>`. If you haven't read that yet you might
   want to start there.

   Let's talk about cameras in three.js. We covered some of this in the `first
   article <fundamentals>` but we'll cover it in more detail here.

   The most common camera in three.js and the one we've been using up to this point 
   is the ``PerspectiveCamera``. It gives a 3d view where things in the distance 
   appear smaller than things up close.

   The ``PerspectiveCamera`` defines a *frustum*. `A frustum is a solid pyramid 
   shape with the tip cut off <https://en.wikipedia.org/wiki/Frustum>`__. By name 
   of a solid I mean for example a cube, a cone, a sphere, a cylinder, and a 
   frustum are all names of different kinds of solids.

   .. container:: spread

      **cube**     <div data-diagram="shapeCube" style="touch-action: none;"></div> 
      **cone**     <div data-diagram="shapeCone" style="touch-action: none;"></div> 
      **sphere**   <div data-diagram="shapeSphere" style="touch-action: none;"></div> 
      **cylinder** <div data-diagram="shapeCylinder" style="touch-action: none;"></div> 
      **frustum**  <div data-diagram="shapeFrustum" style="touch-action: none;"></div> 

   I only point that out because I didn't know it for years. Some book or page would
   mention *frustum* and my eyes would glaze over. Understanding it's the name of a
   type of solid shape made those descriptions suddenly make more sense 😅

   A ``PerspectiveCamera`` defines its frustum based on 4 properties. ``near`` 
   defines where the front of the frustum starts. ``far`` defines where it ends. 
   ``fov``, the field of view, defines how tall the front and back of the frustum 
   are by computing the correct height to get the specified field of view at 
   ``near`` units from the camera. The ``aspect`` defines how wide the front and 
   back of the frustum are. The width of the frustum is just the height multiplied 
   by the aspect.

   .. image:: https://threejs.org/manual/resources/frustum-3d.svg
      :class: threejs_center
      :width: 500px

   Let's use the scene from `the previous article <lights>` that has a ground
   plane, a sphere, and a cube and make it so we can adjust the camera's settings.

   To do that we'll make a ``MinMaxGUIHelper`` for the ``near`` and ``far`` settings so
   ``far`` is always greater than ``near``. It will have ``min`` and ``max`` properties
   that lil-gui will adjust. When adjusted they'll set the 2 properties we specify.


   .. code:: javascript

      class MinMaxGUIHelper {
         constructor(obj, minProp, maxProp, minDif) {
            this.obj = obj;
            this.minProp = minProp;
            this.maxProp = maxProp;
            this.minDif = minDif;
         }
         get min() {
            return this.obj[this.minProp];
         }
         set min(v) {
            this.obj[this.minProp] = v;
            this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
         }
         get max() {
            return this.obj[this.maxProp];
         }
         set max(v) {
            this.obj[this.maxProp] = v;
            this.min = this.min;  // this will call the min setter
         }
      }


   Now we can setup our GUI like this


   .. code:: javascript

      function updateCamera() {
         camera.updateProjectionMatrix();
      }

      const gui = new GUI();
      gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
      const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
      gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
      gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);


   Anytime the camera's settings change we need to call the camera's
   ``updateProjectionMatrix`` function so we made a function called ``updateCamera`` 
   add passed it to lil-gui to call it when things change.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cameras-perspective.html>`__

   You can adjust the values and see how they work. Note we didn't make ``aspect``
   settable since it's taken from the size of the window so if you want to adjust the
   aspect open the example in a new window and then size the window.

   Still, I think it's a little hard to see so let's change the example so it has 2
   cameras. One will show our scene as we see it above, the other will show another
   camera looking at the scene the first camera is drawing and showing that camera's
   frustum.

   To do this we can use the scissor function of three.js. Let's change it to draw 2
   scenes with 2 cameras side by side using the scissor function.

   First off let's use some HTML and CSS to define 2 side by side elements. This will
   also help us with events so both cameras can easily have their own `OrbitControls`.


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div class="split">
      +      <div id="view1" tabindex="1"></div>
      +      <div id="view2" tabindex="2"></div>
      +   </div>
      </body>


   And the CSS that will make those 2 views show up side by side overlaid on top of the
   canvas


   .. code:: javascript

      .split {
         position: absolute;
         left: 0;
         top: 0;
         width: 100%;
         height: 100%;
         display: flex;
      }
      .split>div {
         width: 100%;
         height: 100%;
      }


   Then in our code we'll add a ``CameraHelper``. A ``CameraHelper`` draws the 
   frustum for a ``Camera``


   .. code:: javascript

      const cameraHelper = new THREE.CameraHelper(camera);

      ...

      scene.add(cameraHelper);


   Now let's look up the 2 view elements.


   .. code:: javascript

      const view1Elem = document.querySelector('#view1');
      const view2Elem = document.querySelector('#view2');


   And we'll set our existing `OrbitControls` to respond to the
   first view element only.


   .. code:: javascript

      - const controls = new OrbitControls(camera, canvas);
      + const controls = new OrbitControls(camera, view1Elem);


   Let's make a second ``PerspectiveCamera`` and a second `OrbitControls`. 
   The second `OrbitControls` is tied to the second camera and gets input from 
   the second view element.


   .. code:: javascript

      const camera2 = new THREE.PerspectiveCamera(
         60,  // fov
         2,   // aspect
         0.1, // near
         500, // far
      );
      camera2.position.set(40, 10, 30);
      camera2.lookAt(0, 5, 0);

      const controls2 = new OrbitControls(camera2, view2Elem);
      controls2.target.set(0, 5, 0);
      controls2.update();


   Finally we need to render the scene from the point of view of each camera using the
   scissor function to only render to part of the canvas.

   Here is a function that given an element will compute the rectangle of that element
   that overlaps the canvas. It will then set the scissor and viewport to that
   rectangle and return the aspect for that size.


   .. code:: javascript

      function setScissorForElement(elem) {
         const canvasRect = canvas.getBoundingClientRect();
         const elemRect = elem.getBoundingClientRect();

         // compute a canvas relative rectangle
         const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
         const left = Math.max(0, elemRect.left - canvasRect.left);
         const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
         const top = Math.max(0, elemRect.top - canvasRect.top);

         const width = Math.min(canvasRect.width, right - left);
         const height = Math.min(canvasRect.height, bottom - top);

         // setup the scissor to only render to that part of the canvas
         const positiveYUpBottom = canvasRect.height - bottom;
         renderer.setScissor(left, positiveYUpBottom, width, height);
         renderer.setViewport(left, positiveYUpBottom, width, height);

         // return the aspect
         return width / height;
      }


   And now we can use that function to draw the scene twice in our ``render`` function


   .. code:: javascript

         function render() {

      -     if (resizeRendererToDisplaySize(renderer)) {
      -       const canvas = renderer.domElement;
      -       camera.aspect = canvas.clientWidth / canvas.clientHeight;
      -       camera.updateProjectionMatrix();
      -     }

      +     resizeRendererToDisplaySize(renderer);
      + 
      +     // turn on the scissor
      +     renderer.setScissorTest(true);
      + 
      +     // render the original view
      +     {
      +       const aspect = setScissorForElement(view1Elem);
      + 
      +       // adjust the camera for this aspect
      +       camera.aspect = aspect;
      +       camera.updateProjectionMatrix();
      +       cameraHelper.update();
      + 
      +       // don't draw the camera helper in the original view
      +       cameraHelper.visible = false;
      + 
      +       scene.background.set(0x000000);
      + 
      +       // render
      +       renderer.render(scene, camera);
      +     }
      + 
      +     // render from the 2nd camera
      +     {
      +       const aspect = setScissorForElement(view2Elem);
      + 
      +       // adjust the camera for this aspect
      +       camera2.aspect = aspect;
      +       camera2.updateProjectionMatrix();
      + 
      +       // draw the camera helper in the 2nd view
      +       cameraHelper.visible = true;
      + 
      +       scene.background.set(0x000040);
      + 
      +       renderer.render(scene, camera2);
      +     }

      -     renderer.render(scene, camera);

            requestAnimationFrame(render);
         }

         requestAnimationFrame(render);
      }


   The code above sets the background color of the scene when rendering the second view
   to dark blue just to make it easier to distinguish the two views.

   We can also remove our ``updateCamera`` code since we're updating everything in the
   ``render`` function.


   .. code:: javascript

      - function updateCamera() {
      -  camera.updateProjectionMatrix();
      - }

      const gui = new GUI();
      - gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
      + gui.add(camera, 'fov', 1, 180);
      const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
      - gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
      - gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
      + gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near');
      + gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far');


   And now you can use one view to see the frustum of the other.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cameras-perspective-2-scenes.html>`__

   On the left you can see the original view and on the right you can see a view
   showing the frustum of the camera on the left. As you adjust ``near``, ``far``,
   ``fov`` and move the camera with mouse you can see that only what's inside the
   frustum shown on the right appears in the scene on the left.

   Adjust ``near`` up to around 20 and you'll easily see the front of objects disappear
   as they are no longer in the frustum. Adjust ``far`` below about 35 and you'll start
   to see the ground plane disappear as it's no longer in the frustum.

   This brings up the question, why not just set ``near`` to 0.0000000001 and ``far``
   to 10000000000000 or something like that so you can just see everything? The reason
   is your GPU only has so much precision to decide if something is in front or behind
   something else. That precision is spread out between ``near`` and ``far``. Worse, by
   default the precision close the camera is detailed and the precision far from the
   camera is coarse. The units start with ``near`` and slowly expand as they approach
   ``far``.

   Starting with the top example, let's change the code to insert 20 spheres in a row.


   .. code:: javascript

      {
         const sphereRadius = 3;
         const sphereWidthDivisions = 32;
         const sphereHeightDivisions = 16;
         const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
         const numSpheres = 20;
         for (let i = 0; i < numSpheres; ++i) {
            const sphereMat = new THREE.MeshPhongMaterial();
            sphereMat.color.setHSL(i * .73, 1, 0.5);
            const mesh = new THREE.Mesh(sphereGeo, sphereMat);
            mesh.position.set(-sphereRadius - 1, sphereRadius + 2, i * sphereRadius * -2.2);
            scene.add(mesh);
         }
      }


   and let's set ``near`` to 0.00001


   .. code:: javascript

      const fov = 45;
      const aspect = 2;  // the canvas default
      - const near = 0.1;
      + const near = 0.00001;
      const far = 100;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);


   We also need to tweak the GUI code a little to allow 0.00001 if the value is edited


   .. code:: javascript

      - gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
      + gui.add(minMaxGUIHelper, 'min', 0.00001, 50, 0.00001).name('near').onChange(updateCamera);


   What do you think will happen?


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cameras-z-fighting.html>`__

   This is an example of *z fighting* where the GPU on your computer does not have
   enough precision to decide which pixels are in front and which pixels are behind.

   Just in case the issue doesn't show on your machine here's what I see on mine


   .. image:: https://threejs.org/manual/resources/images/z-fighting.png


   One solution is to tell three.js use to a different method to compute which pixels
   are in front and which are behind. We can do that by enabling
   ``logarithmicDepthBuffer`` when we create the ``WebGLRenderer``


   .. code:: javascript

      - const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      + const renderer = new THREE.WebGLRenderer({
      +   antialias: true,
      +   canvas,
      +   logarithmicDepthBuffer: true,
      + });


   and with that it might work


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cameras-logarithmic-depth-buffer.html>`__

   If this didn't fix the issue for you then you've run into one reason why you can't
   always use this solution. That reason is because only certain GPUs support it. As of
   September 2018 almost no mobile devices support this solution whereas most desktops
   do.

   Another reason not to choose this solution is it can be significantly slower than
   the standard solution.

   Even with this solution there is still limited resolution. Make ``near`` even
   smaller or ``far`` even bigger and you'll eventually run into the same issues.

   What that means is that you should always make an effort to choose a ``near`` and
   ``far`` setting that fits your use case. Set ``near`` as far away from the camera as
   you can and not have things disappear. Set ``far`` as close to the camera as you can
   and not have things disappear. If you're trying to draw a giant scene and show a
   close up of someone's face so you can see their eyelashes while in the background
   you can see all the way to mountains 50 kilometers in the distance well then you'll
   need to find other creative solutions that maybe we'll go over later. For now, just
   be aware you should take care to choose appropriate ``near`` and ``far`` values for
   your needs.

   The 2nd most common camera is the ``OrthographicCamera``. Rather than specify 
   a frustum it specifies a box with the settings ``left``, ``right`` ``top``,
   ``bottom``, ``near``, and ``far``. Because it's projecting a box there is no
   perspective.

   Let's change the 2 view example above to use an ``OrthographicCamera`` in the 
   first view.

   First let's setup an ``OrthographicCamera``.


   .. code:: javascript

      const left = -1;
      const right = 1;
      const top = 1;
      const bottom = -1;
      const near = 5;
      const far = 50;
      const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
      camera.zoom = 0.2;


   We set ``left`` and ``bottom`` to -1 and ``right`` and ``top`` to 1. This would make
   a box 2 units wide and 2 units tall but we're going to adjust the ``left`` and
   ``top`` by the aspect of the rectangle we're drawing to. We'll use the ``zoom``
   property to make it easy to adjust how many units are actually shown by the camera.

   Let's add a GUI setting for ``zoom``


   .. code:: javascript

      const gui = new GUI();
      + gui.add(camera, 'zoom', 0.01, 1, 0.01).listen();


   The call to ``listen`` tells lil-gui to watch for changes. This is here because the
   `OrbitControls` can also control zoom. For example the scroll wheel on a mouse will 
   zoom via the `OrbitControls`.

   Last we just need to change the part that renders the left side to update the
   ``OrthographicCamera``.


   .. code:: javascript

      {
         const aspect = setScissorForElement(view1Elem);

         // update the camera for this aspect
      -  camera.aspect = aspect;
      +  camera.left   = -aspect;
      +  camera.right  =  aspect;
         camera.updateProjectionMatrix();
         cameraHelper.update();

         // don't draw the camera helper in the original view
         cameraHelper.visible = false;

         scene.background.set(0x000000);
         renderer.render(scene, camera);
      }


   and now you can see an
   ``OrthographicCamera`` at work.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cameras-orthographic-2-scenes.html>`__

   An ``OrthographicCamera`` is most often used if using three.js to draw 2D things. 
   You'd decide how many units you want the camera to show. For example if you want 
   one pixel of canvas to match one unit in the camera you could do something like.

   To put the origin at the center and have 1 pixel = 1 three.js unit something like


   .. code:: javascript

      camera.left = -canvas.width / 2;
      camera.right = canvas.width / 2;
      camera.top = canvas.height / 2;
      camera.bottom = -canvas.height / 2;
      camera.near = -1;
      camera.far = 1;
      camera.zoom = 1;


   Or if we wanted the origin to be in the top left just like a 2D canvas we could use
   this


   .. code:: javascript

      camera.left = 0;
      camera.right = canvas.width;
      camera.top = 0;
      camera.bottom = canvas.height;
      camera.near = -1;
      camera.far = 1;
      camera.zoom = 1;


   In which case the top left corner would be 0,0 just like a 2D canvas

   Let's try it! First let's set the camera up


   .. code:: javascript

      const left = 0;
      const right = 300;  // default canvas size
      const top = 0;
      const bottom = 150;  // default canvas size
      const near = -1;
      const far = 1;
      const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
      camera.zoom = 1;


   Then let's load 6 textures and make 6 planes, one for each texture. We'll parent
   each plane to a ``THREE.Object3D`` to make it easy to offset the plane so its 
   center appears to be at its top left corner.

   If you're running locally you'll also need to have `setup <setup>`. You might
   also want to read about `using textures <textures>`.


   .. code:: javascript

      const loader = new THREE.TextureLoader();
      const textures = [
         loader.load('resources/images/flower-1.jpg'),
         loader.load('resources/images/flower-2.jpg'),
         loader.load('resources/images/flower-3.jpg'),
         loader.load('resources/images/flower-4.jpg'),
         loader.load('resources/images/flower-5.jpg'),
         loader.load('resources/images/flower-6.jpg'),
      ];
      const planeSize = 256;
      const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
      const planes = textures.map((texture) => {
         const planePivot = new THREE.Object3D();
         scene.add(planePivot);
         texture.magFilter = THREE.NearestFilter;
         const planeMat = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
         });
         const mesh = new THREE.Mesh(planeGeo, planeMat);
         planePivot.add(mesh);
         // move plane so top left corner is origin
         mesh.position.set(planeSize / 2, planeSize / 2, 0);
         return planePivot;
      });


   and we need to update the camera if the size of the canvas changes.


   .. code:: javascript

      function render() {

         if (resizeRendererToDisplaySize(renderer)) {
            camera.right = canvas.width;
            camera.bottom = canvas.height;
            camera.updateProjectionMatrix();
         }

         ...


   planes is an array of ``THREE.Mesh``, one for each plane. Let's move them around 
   based on the time.


   .. code:: javascript

      function render(time) {
         time *= 0.001;  // convert to seconds;

         ...

         const distAcross = Math.max(20, canvas.width - planeSize);
         const distDown = Math.max(20, canvas.height - planeSize);

         // total distance to move across and back
         const xRange = distAcross * 2;
         const yRange = distDown * 2;
         const speed = 180;

         planes.forEach((plane, ndx) => {
            // compute a unique time for each plane
            const t = time * speed + ndx * 300;

            // get a value between 0 and range
            const xt = t % xRange;
            const yt = t % yRange;

            // set our position going forward if 0 to half of range
            // and backward if half of range to range
            const x = xt < distAcross ? xt : xRange - xt;
            const y = yt < distDown   ? yt : yRange - yt;

            plane.position.set(x, y, 0);
         });

         renderer.render(scene, camera);


   And you can see the images bounce pixel perfect off the edges of the canvas using
   pixel math just like a 2D canvas


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cameras-orthographic-canvas-top-left-origin.html>`__

   Another common use for an ``OrthographicCamera`` is to draw the up, down, left, 
   right, front, back views of a 3D modeling program or a game engine's editor.

   .. image:: https://threejs.org/manual/resources/images/quad-viewport.png

   In the screenshot above you can see 1 view is a perspective view and 3 views are
   orthographic views.

   That's the fundamentals of cameras. We'll cover a few common ways to move cameras in
   other articles. For now let's move on to `shadows <shadows>`.


.. _F11:

Shadows
=======

   -  `Shadows <https://threejs.org/manual/en/shadows.html>`__


   This article is part of a series of articles about three.js. The first article is
   `three.js fundamentals <fundamentals>`. If you haven't read that yet and
   you're new to three.js you might want to consider starting there. The `previous
   article was about cameras <cameras>` which is important to have read before
   you read this article as well as the `article before that one about lights <lights>`.

   Shadows on computers can be a complicated topic. There are various solutions and all
   of them have tradeoffs including the solutions available in three.js.

   Three.js by default uses *shadow maps*. The way a shadow map works is, *for every
   light that casts shadows all objects marked to cast shadows are rendered from the
   point of view of the light*. **READ THAT AGAIN!** and let it sink in.

   In other words, if you have 20 objects, and 5 lights, and all 20 objects are casting
   shadows and all 5 lights are casting shadows then your entire scene will be drawn 6
   times. All 20 objects will be drawn for light #1, then all 20 objects will be drawn
   for light #2, then #3, etc and finally the actual scene will be drawn using data
   from the first 5 renders.

   It gets worse, if you have a point light casting shadows the scene has to be drawn 6
   times just for that light!

   For these reasons it's common to find other solutions than to have a bunch of lights
   all generating shadows. One common solution is to have multiple lights but only one
   directional light generating shadows.


Lightmaps
---------

   Yet another solution is to use lightmaps and or ambient occlusion maps to
   pre-compute the effects of lighting offline. This results in static lighting or
   static lighting hints but at least it's fast. We'll cover both of those in another
   article.

   Another solution is to use fake shadows. Make a plane, put a grayscale texture in
   the plane that approximates a shadow, draw it above the ground below your object.

   .. Note::

      计算机图形学是计算机领域的一大研究方向，而物理真实的光照则是重点方向。由于光照的复杂性极高，
      通过计算（路径追踪）实现的照片级渲染是非常消耗 CPU 时间，一般电影工业离线渲染（offline）
      较常见。随着 GPU 技术的进步，越来越多的游戏也尝试使用光线追踪技术来获得越真实的游戏画面。
      真实光照会随着场景中的光源数量、物体数量、反射次数呈指数级增长，光线追踪算法需要不断优化。

      一般游戏制作的过程中，为了优化性能，通常避免直接通过计算来获得光照效果，而是使用其它更节省
      计算的方法，比如光照效果烘焙，将渲染好的光照数据保存起来直接、重复使用，避免动态计算。还有
      光照贴图，通过制作阴影、光效果图像，并在场景中合理使用它们，达到以假乱真的效果，又避免了实时
      光照计算的消耗。

      例如，three.js 关于阴影这部分的文档，就演示了一个弹球场景的阴影贴图的应用，一方面提升了
      渲染效果，另一方面双节省的算力消耗。当然，这个弹球场景较简易，目的是用于教学演示，实现项目
      中很少有这么简单的场景。物体阴影形状相对规则，没有复杂的投射面需要处理。示范中，会将阴影
      贴图加入到材质 ``shadowMat``，并设置给 ``shadowMesh``。球体弹跳过程靠近地面的时候，
      按高度调整阴影的透明度，并根据球体落点、光源方向移动阴影贴图。文档还提到了《动物森友会》，
      Animal Crossing Pocket Camp 这是任天堂出品的一款优秀游戏作品，阴影处理就是类似技术。

      注意，有两个和透明度相关的属性： ``transparent`` 表示半透明物体，启用它之后的物体才拥有
      透明度效果，并可以通过 ``opacity`` 调整物体的不透明度。

   For example let's use this texture as a fake shadow

   .. image:: https://threejs.org/manual/examples/resources/images/roundshadow.png

   We'll use some of the code from `the previous article <cameras>`.

   Let's set the background color to white.


   .. code:: javascript

      const scene = new THREE.Scene();
      + scene.background = new THREE.Color('white');


   Then we'll setup the same checkerboard ground but this time it's using a
   ``MeshBasicMaterial`` as we don't need lighting for the ground.


   .. code:: javascript

      + const loader = new THREE.TextureLoader();

      {
         const planeSize = 40;

      -  const loader = new THREE.TextureLoader();
         const texture = loader.load('resources/images/checker.png');
         texture.wrapS = THREE.RepeatWrapping;
         texture.wrapT = THREE.RepeatWrapping;
         texture.magFilter = THREE.NearestFilter;
         const repeats = planeSize / 2;
         texture.repeat.set(repeats, repeats);

         const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
         const planeMat = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
         });
      +  planeMat.color.setRGB(1.5, 1.5, 1.5);
         const mesh = new THREE.Mesh(planeGeo, planeMat);
         mesh.rotation.x = Math.PI * -.5;
         scene.add(mesh);
      }


   Note we're setting the color to ``1.5, 1.5, 1.5``. This will multiply the
   checkerboard texture's colors by 1.5, 1.5, 1.5. Since the texture's colors are
   0x808080 and 0xC0C0C0 which is medium gray and light gray, multiplying them by 1.5
   will give us a white and light grey checkerboard.

   Let's load the shadow texture


   .. code:: javascript

      const shadowTexture = loader.load('resources/images/roundshadow.png');


   and make an array to remember each sphere and associated objects.


   .. code:: javascript

      const sphereShadowBases = [];


   Then we'll make a sphere geometry


   .. code:: javascript

      const sphereRadius = 1;
      const sphereWidthDivisions = 32;
      const sphereHeightDivisions = 16;
      const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);


   And a plane geometry for the fake shadow


   .. code:: javascript

      const planeSize = 1;
      const shadowGeo = new THREE.PlaneGeometry(planeSize, planeSize);


   Now we'll make a bunch of spheres. For each sphere we'll create a ``base``
   ``THREE.Object3D`` and we'll make both the shadow plane mesh and the sphere mesh 
   children of the base. That way if we move the base both the sphere and the shadow 
   will move. We need to put the shadow slightly above the ground to prevent z-fighting. 
   We also set ``depthWrite`` to false so that the shadows don't mess each other up. 
   We'll go over both of these issues in `another article <transparency>`. The shadow 
   is a ``MeshBasicMaterial`` because it doesn't need lighting.

   We make each sphere a different hue and then save off the base, the sphere mesh, the
   shadow mesh and the initial y position of each sphere.


   .. code:: javascript

      const numSpheres = 15;
      for (let i = 0; i < numSpheres; ++i) {
         // make a base for the shadow and the sphere
         // so they move together.
         const base = new THREE.Object3D();
         scene.add(base);

         // add the shadow to the base
         // note: we make a new material for each sphere
         // so we can set that sphere's material transparency
         // separately.
         const shadowMat = new THREE.MeshBasicMaterial({
            map: shadowTexture,
            transparent: true,    // so we can see the ground
            depthWrite: false,    // so we don't have to sort
         });
         const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
         shadowMesh.position.y = 0.001;  // so we're above the ground slightly
         shadowMesh.rotation.x = Math.PI * -.5;
         const shadowSize = sphereRadius * 4;
         shadowMesh.scale.set(shadowSize, shadowSize, shadowSize);
         base.add(shadowMesh);

         // add the sphere to the base
         const u = i / numSpheres;   // goes from 0 to 1 as we iterate the spheres.
         const sphereMat = new THREE.MeshPhongMaterial();
         sphereMat.color.setHSL(u, 1, .75);
         const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
         sphereMesh.position.set(0, sphereRadius + 2, 0);
         base.add(sphereMesh);

         // remember all 3 plus the y position
         sphereShadowBases.push({base, sphereMesh, shadowMesh, y: sphereMesh.position.y});
      }


   We setup 2 lights. One is a ``HemisphereLight`` with the intensity set to 2 to 
   really brighten things up.


   .. code:: javascript

      {
         const skyColor = 0xB1E1FF;  // light blue
         const groundColor = 0xB97A20;  // brownish orange
         const intensity = 2;
         const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
         scene.add(light);
      }


   The other is a ``DirectionalLight`` so the spheres get some definition


   .. code:: javascript

      {
         const color = 0xFFFFFF;
         const intensity = 1;
         const light = new THREE.DirectionalLight(color, intensity);
         light.position.set(0, 10, 5);
         light.target.position.set(-5, 0, 0);
         scene.add(light);
         scene.add(light.target);
      }


   It would render as is but let's animate there spheres. For each sphere, shadow, base
   set we move the base in the xz plane, we move the sphere up and down using
   ``Math.abs(Math.sin(time))`` which gives us a bouncy animation. And, we also set 
   the shadow material's opacity so that as each sphere goes higher its shadow fades out.


   .. code:: javascript

      function render(time) {
         time *= 0.001;  // convert to seconds

         ...

         sphereShadowBases.forEach((sphereShadowBase, ndx) => {
            const {base, sphereMesh, shadowMesh, y} = sphereShadowBase;

            // u is a value that goes from 0 to 1 as we iterate the spheres
            const u = ndx / sphereShadowBases.length;

            // compute a position for the base. This will move
            // both the sphere and its shadow
            const speed = time * .2;
            const angle = speed + u * Math.PI * 2 * (ndx % 1 ? 1 : -1);
            const radius = Math.sin(speed - ndx) * 10;
            base.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

            // yOff is a value that goes from 0 to 1
            const yOff = Math.abs(Math.sin(time * 2 + ndx));
            // move the sphere up and down
            sphereMesh.position.y = y + THREE.MathUtils.lerp(-2, 2, yOff);
            // fade the shadow as the sphere goes up
            shadowMesh.material.opacity = THREE.MathUtils.lerp(1, .25, yOff);
         });

         ...


   And here's 15 kind of bouncing balls.


      `click here to open in a separate window <https://threejs.org/manual/examples/shadows-fake.html>`__

   In some apps it's common to use a round or oval shadow for everything but of course
   you could also use different shaped shadow textures. You might also give the shadow
   a harder edge. A good example of using this type of shadow is `Animal Crossing
   Pocket Camp <https://www.bing.com/search?q=animal+crossing+pocket+camp+screenshots>`__
   where you can see each character has a simple round shadow. It's effective and
   cheap. `Monument Valley <https://www.bing.com/search?q=monument+valley+screenshots`__
   appears to also use this kind of shadow for the main character.

Shadow casting
--------------

   So, moving on to shadow maps, there are 3 lights which can cast shadows. The
   ``DirectionalLight``, the ``PointLight``, and the ``SpotLight``.

   Let's start with the ``DirectionalLight`` with the helper example from 
   `the lights article <lights>`.

   The first thing we need to do is turn on shadows in the renderer.


   .. code:: javascript

      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      + renderer.shadowMap.enabled = true;


   Then we also need to tell the light to cast a shadow


   .. code:: javascript

      const light = new THREE.DirectionalLight(color, intensity);
      + light.castShadow = true;


   We also need to go to each mesh in the scene and decide if it should both cast
   shadows and/or receive shadows.

   Let's make the plane (the ground) only receive shadows since we don't really care
   what happens underneath.


   .. code:: javascript

      const mesh = new THREE.Mesh(planeGeo, planeMat);
      mesh.receiveShadow = true;


   For the cube and the sphere let's have them both receive and cast shadows


   .. code:: javascript

      const mesh = new THREE.Mesh(cubeGeo, cubeMat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      ...

      const mesh = new THREE.Mesh(sphereGeo, sphereMat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;


   And then we run it.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadows-directional-light.html>`__

   What happened? Why are parts of the shadows missing?

   The reason is shadow maps are created by rendering the scene from the point of view
   of the light. In this case there is a camera at the ``DirectionalLight`` that is 
   looking at its target. Just like `the camera's we previously covered <cameras>` the
   light's shadow camera defines an area inside of which the shadows get rendered. In
   the example above that area is too small.

   In order to visualize that area we can get the light's shadow camera and add a
   ``CameraHelper`` to the scene.


   .. code:: javascript

      const cameraHelper = new THREE.CameraHelper(light.shadow.camera);
      scene.add(cameraHelper);


   And now you can see the area for which shadows are cast and received.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadows-directional-light-with-camera-helper.html>`__

   Adjust the target x value back and forth and it should be pretty clear that only
   what's inside the light's shadow camera box is where shadows are drawn.

   We can adjust the size of that box by adjusting the light's shadow camera.

   Let's add some GUI setting to adjust the light's shadow camera box. Since a
   ``DirectionalLight`` represents light all going in a parallel direction, the
   ``DirectionalLight`` uses an ``OrthographicCamera`` for its shadow camera. We went over 
   how an ``OrthographicCamera`` works in `the previous article about cameras <cameras>`.

   Recall an ``OrthographicCamera`` defines its box or *view frustum* by its 
   ``left``, ``right``, ``top``, ``bottom``, ``near``, ``far``, and ``zoom`` properties.

   Again let's make a helper class for the lil-gui. We'll make a ``DimensionGUIHelper``
   that we'll pass an object and 2 properties. It will present one property that
   lil-gui can adjust and in response will set the two properties one positive and one
   negative. We can use this to set ``left`` and ``right`` as ``width`` and ``up`` and
   ``down`` as ``height``.


   .. code:: javascript

      class DimensionGUIHelper {
         constructor(obj, minProp, maxProp) {
            this.obj = obj;
            this.minProp = minProp;
            this.maxProp = maxProp;
         }
         get value() {
            return this.obj[this.maxProp] * 2;
         }
         set value(v) {
            this.obj[this.maxProp] = v /  2;
            this.obj[this.minProp] = v / -2;
         }
      }


   We'll also use the ``MinMaxGUIHelper`` we created in the `camera article <cameras>` 
   to adjust ``near`` and ``far``.


   .. code:: javascript

      const gui = new GUI();
      gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
      gui.add(light, 'intensity', 0, 2, 0.01);
      + {
      +   const folder = gui.addFolder('Shadow Camera');
      +   folder.open();
      +   folder.add(new DimensionGUIHelper(light.shadow.camera, 'left', 'right'), 'value', 1, 100)
      +     .name('width')
      +     .onChange(updateCamera);
      +   folder.add(new DimensionGUIHelper(light.shadow.camera, 'bottom', 'top'), 'value', 1, 100)
      +     .name('height')
      +     .onChange(updateCamera);
      +   const minMaxGUIHelper = new MinMaxGUIHelper(light.shadow.camera, 'near', 'far', 0.1);
      +   folder.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
      +   folder.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
      +   folder.add(light.shadow.camera, 'zoom', 0.01, 1.5, 0.01).onChange(updateCamera);
      + }


   We tell the GUI to call our ``updateCamera`` function anytime anything changes.
   Let's write that function to update the light, the helper for the light, the light's
   shadow camera, and the helper showing the light's shadow camera.


   .. code:: javascript

      function updateCamera() {
         // update the light target's matrixWorld because it's needed by the helper
         light.target.updateMatrixWorld();
         helper.update();
         // update the light's shadow camera's projection matrix
         light.shadow.camera.updateProjectionMatrix();
         // and now update the camera helper we're using to show the light's shadow camera
         cameraHelper.update();
      }
      updateCamera();


   And now that we've given the light's shadow camera a GUI we can play with the
   values.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadows-directional-light-with-camera-gui.html>`__

   Set the ``width`` and ``height`` to about 30 and you can see the shadows are correct
   and the areas that need to be in shadow for this scene are entirely covered.

   But this brings up the question, why not just set ``width`` and ``height`` to some
   giant numbers to just cover everything? Set the ``width`` and ``height`` to 100 and
   you might see something like this

   .. image:: https://threejs.org/manual/resources/images/low-res-shadow-map.png


   What's going on with these low-res shadows?!

   This issue is yet another shadow related setting to be aware of. Shadow maps are
   textures the shadows get drawn into. Those textures have a size. The shadow camera's
   area we set above is stretched across that size. That means the larger area you set,
   the more blocky your shadows will be.

   You can set the resolution of the shadow map's texture by setting
   ``light.shadow.mapSize.width`` and ``light.shadow.mapSize.height``. They default to
   512x512. The larger you make them the more memory they take and the slower they are
   to compute so you want to set them as small as you can and still make your scene
   work. The same is true with the light's shadow camera area. Smaller means better
   looking shadows so make the area as small as you can and still cover your scene. Be
   aware that each user's machine has a maximum texture size allowed which is available
   on the renderer as ``renderer.capabilities.maxTextureSize``.

   Switching to the ``SpotLight`` the light's shadow camera becomes a
   ``PerspectiveCamera``. Unlike the ``DirectionalLight``'s shadow camera where 
   we could manually set most its settings, ``SpotLight``'s shadow camera is controlled 
   by the ``SpotLight`` itself. The ``fov`` for the shadow camera is directly connected 
   to the ``SpotLight``'s ``angle`` setting. The ``aspect`` is set automatically based 
   on the size of the shadow map.


   .. code:: javascript

      - const light = new THREE.DirectionalLight(color, intensity);
      + const light = new THREE.SpotLight(color, intensity);


   and we added back in the ``penumbra`` and ``angle`` settings from our 
   `article about lights <lights>`.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadows-spot-light-with-camera-gui.html>`__

   And finally there's shadows with a ``PointLight``. Since a ``PointLight`` shines in 
   all directions the only relevant settings are ``near`` and ``far``. Otherwise the
   ``PointLight`` shadow is effectively 6 ``SpotLight`` shadows each one pointing to the
   face of a cube around the light. This means ``PointLight`` shadows are much slower since
   the entire scene must be drawn 6 times, one for each direction.

   Let's put a box around our scene so we can see shadows on the walls and ceiling.
   We'll set the material's ``side`` property to ``THREE.BackSide`` so we render the
   inside of the box instead of the outside. Like the floor we'll set it only to
   receive shadows. Also we'll set the position of the box so its bottom is slightly
   below the floor so the floor and the bottom of the box don't z-fight.


   .. code:: javascript

      {
         const cubeSize = 30;
         const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
         const cubeMat = new THREE.MeshPhongMaterial({
            color: '#CCC',
            side: THREE.BackSide,
         });
         const mesh = new THREE.Mesh(cubeGeo, cubeMat);
         mesh.receiveShadow = true;
         mesh.position.set(0, cubeSize / 2 - 0.1, 0);
         scene.add(mesh);
      }


   And of course we need to switch the light to a ``PointLight``.


   .. code:: javascript

      - const light = new THREE.SpotLight(color, intensity);
      + const light = new THREE.PointLight(color, intensity);

      ....

      // so we can easily see where the point light is
      + const helper = new THREE.PointLightHelper(light);
      + scene.add(helper);


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadows-point-light.html>`__


   Use the ``position`` GUI settings to move the light around and you'll see the
   shadows fall on all the walls. You can also adjust ``near`` and ``far`` settings and
   see just like the other shadows when things are closer than ``near`` they no longer
   receive a shadow and they are further than ``far`` they are always in shadow.



.. _F12:

Fog
===

   -  `Fog <https://threejs.org/manual/en/fog.html>`__


   This article is part of a series of articles about three.js. The first article is
   `three.js fundamentals <fundamentals>`. If you haven't read that yet and
   you're new to three.js you might want to consider starting there. If you haven't
   read about cameras you might want to start with `this article <cameras>`.

   Fog in a 3D engine is generally a way of fading to a specific color based on the
   distance from the camera. In three.js you add fog by creating ``Fog`` or ``FogExp2`` 
   object and setting it on the scene's ``fog`` property.

   ``Fog`` lets you choose ``near`` and ``far`` settings which are distances from the 
   camera. Anything closer than ``near`` is unaffected by fog. Anything further than 
   ``far`` is completely the fog color. Parts between ``near`` and ``far`` fade from 
   their material color to the fog color.

   There's also ``FogExp2`` which grows exponentially with distance from the camera.

   To use either type of fog you create one and and assign it to the scene as in


   .. code:: javascript

      const scene = new THREE.Scene();
      {
         const color = 0xFFFFFF;  // white
         const near = 10;
         const far = 100;
         scene.fog = new THREE.Fog(color, near, far);
      }


   or for ``FogExp2`` it would be


   .. code:: javascript

      const scene = new THREE.Scene();
      {
         const color = 0xFFFFFF;
         const density = 0.1;
         scene.fog = new THREE.FogExp2(color, density);
      }


   ``FogExp2`` is closer to reality but ``Fog`` is used more commonly since it lets you
   choose a place to apply the fog so you can decide to show a clear scene up to a
   certain distance and then fade out to some color past that distance.

   .. container:: spread

      ``THREE.Fog``
      <div data-diagram="fog" style="height: 300px; touch-action: none;"></div>

      ``THREE.FogExp2``
      <div data-diagram="fogExp2" style="height: 300px; touch-action: none;"></div>


   It's important to note that the fog is applied to *things that are rendered*. It is
   part of the calculation of each pixel of the color of the object. What that means is
   if you want your scene to fade to a certain color you need to set the fog **and**
   the background color to the same color. The background color is set using the
   ``scene.background`` property. To pick a
   background color you attach a ``THREE.Color`` to it.
   For example


   .. code:: javascript

      scene.background = new THREE.Color('#F00');  // red


   .. container:: spread


      **fog blue, background red**
      <div data-diagram="fogBlueBackgroundRed" style="height: 300px; touch-action: none;" class="border"></div>

      **fog blue, background blue**
      <div data-diagram="fogBlueBackgroundBlue" style="height: 300px; touch-action: none;" class="border"></div>


   Here is one of our previous examples with fog added. The only addition is right
   after setting up the scene we add the fog and set the scene's background color


   .. code:: javascript

      const scene = new THREE.Scene();

      + {
      +   const near = 1;
      +   const far = 2;
      +   const color = 'lightblue';
      +   scene.fog = new THREE.Fog(color, near, far);
      +   scene.background = new THREE.Color(color);
      + }


   In the example below the camera's ``near`` is 0.1 and its ``far`` is 5. The camera
   is at ``z = 2``. The cubes are 1 unit large and at Z = 0. This means with a fog
   setting of ``near = 1`` and ``far = 2`` the cubes will fade out right around their
   center.


      `click here to open in a separate window <https://threejs.org/manual/examples/fog.html>`__

   Let's add an interface so we can adjust the fog. Again we'll use
   `lil-gui <https://github.com/georgealways/lil-gui>`__. lil-gui takes an object and a
   property and automagically makes an interface for that type of property. We could
   just simply let it manipulate the fog's ``near`` and ``far`` properties but it's
   invalid to have ``near`` be greater than ``far`` so let's make a helper so lil-gui
   can manipulate a ``near`` and ``far`` property but we'll make sure ``near`` is less
   than or equal to ``far`` and ``far`` is greater than or equal ``near``.


   .. code:: javascript

      // We use this class to pass to lil-gui
      // so when it manipulates near or far
      // near is never > far and far is never < near
      class FogGUIHelper {
         constructor(fog) {
            this.fog = fog;
         }
         get near() {
            return this.fog.near;
         }
         set near(v) {
            this.fog.near = v;
            this.fog.far = Math.max(this.fog.far, v);
         }
         get far() {
            return this.fog.far;
         }
         set far(v) {
            this.fog.far = v;
            this.fog.near = Math.min(this.fog.near, v);
         }
      }


   We can then add it like this


   .. code:: javascript

      {
         const near = 1;
         const far = 2;
         const color = 'lightblue';
         scene.fog = new THREE.Fog(color, near, far);
         scene.background = new THREE.Color(color);
      + 
      +   const fogGUIHelper = new FogGUIHelper(scene.fog);
      +   gui.add(fogGUIHelper, 'near', near, far).listen();
      +   gui.add(fogGUIHelper, 'far', near, far).listen();
      }


   The ``near`` and ``far`` parameters set the minimum and maximum values for adjusting
   the fog. They are set when we setup the camera.

   The ``.listen()`` at the end of the last 2 lines tells lil-gui to *listen* for
   changes. That way when we change ``near`` because of an edit to ``far`` or we change
   ``far`` in response to an edit to ``near`` lil-gui will update the other property's
   UI for us.

   It might also be nice to be able to change the fog color but like was mentioned
   above we need to keep both the fog color and the background color in sync. So, let's
   add another *virtual* property to our helper that will set both colors when lil-gui
   manipulates it.

   lil-gui can manipulate colors in 4 ways, as a CSS 6 digit hex string (eg: ``#112233``). 
   As an hue, saturation, value, object (eg: ``{h: 60, s: 1, v: }``). As an RGB array 
   (eg: ``[255, 128, 64]``). Or, as an RGBA array (eg: ``[127, 200, 75, 0.3]``).

   It's easiest for our purpose to use the hex string version since that way lil-gui is
   only manipulating a single value. Fortunately ``THREE.Color`` as a ``getHexString`` 
   method we get use to easily get such a string, we just have to prepend a '#' to the front.


   .. code:: javascript

      // We use this class to pass to lil-gui
      // so when it manipulates near or far
      // near is never > far and far is never < near
      + // Also when lil-gui manipulates color we'll
      + // update both the fog and background colors.
      class FogGUIHelper {
      *  constructor(fog, backgroundColor) {
            this.fog = fog;
      +     this.backgroundColor = backgroundColor;
         }
         get near() {
            return this.fog.near;
         }
         set near(v) {
            this.fog.near = v;
            this.fog.far = Math.max(this.fog.far, v);
         }
         get far() {
            return this.fog.far;
         }
         set far(v) {
            this.fog.far = v;
            this.fog.near = Math.min(this.fog.near, v);
         }
      +  get color() {
      +    return `#${this.fog.color.getHexString()}`;
      +  }
      +  set color(hexString) {
      +    this.fog.color.set(hexString);
      +    this.backgroundColor.set(hexString);
      +  }
      }


   We then call ``gui.addColor`` to add a color UI for our helper's virtual property.


   .. code:: javascript

      {
         const near = 1;
         const far = 2;
         const color = 'lightblue';
         scene.fog = new THREE.Fog(color, near, far);
         scene.background = new THREE.Color(color);

      *  const fogGUIHelper = new FogGUIHelper(scene.fog, scene.background);
         gui.add(fogGUIHelper, 'near', near, far).listen();
         gui.add(fogGUIHelper, 'far', near, far).listen();
      +  gui.addColor(fogGUIHelper, 'color');
      }


      `click here to open in a separate window <https://threejs.org/manual/examples/fog-gui.html>`__


   You can see setting ``near`` to like 1.9 and ``far`` to 2.0 gives a very sharp
   transition between un-fogged and completely fogged. where as ``near`` = 1.1 and
   ``far`` = 2.9 should just about be the smoothest given our cubes are spinning 2
   units away from the camera.

   One last thing, there is a boolean ``fog`` property on a material for
   whether or not objects rendered with that material are affected by fog. It defaults
   to ``true`` for most materials. As an example of why you might want to turn the fog
   off, imagine you're making a 3D vehicle simulator with a view from the driver's seat
   or cockpit. You probably want the fog off for everything inside the vehicle when
   viewing from inside the vehicle.

   A better example might be a house and thick fog outside house. Let's say the fog is
   set to start 2 meters away (near = 2) and completely fogged out at 4 meters (far =
   4). Rooms are longer than 2 meters and the house is probably longer than 4 meters so
   you need to set the materials for the inside of the house to not apply fog otherwise
   when standing inside the house looking outside the wall at the far end of the room
   will look like it's in the fog.

   .. container:: spread


      **fog: true, all**
      <div data-diagram="fogHouseAll" style="height: 300px;" class="border"></div>

   Notice the walls and ceiling at the far end of the room are getting fog applied. By
   turning fog off on the materials for the house we can fix that issue.

   .. container:: spread


      **fog: true, only outside materials**
      <div data-diagram="fogHouseInsideNoFog" style="height: 300px;" class="border"></div>



.. _F13:

Render Targets
==============

   -  `Render Targets <https://threejs.org/manual/en/rendertargets.html>`__


   A render target in three.js is basically a texture you can render to. After you
   render to it you can use that texture like any other texture.

   Let's make a simple example. We'll start with an example from `the article on
   responsiveness <responsive>`.

   Rendering to a render target is almost exactly the same as normal rendering. 
   First we create a ``WebGLRenderTarget``.


   .. code:: javascript

      const rtWidth = 512;
      const rtHeight = 512;
      const renderTarget = new THREE.WebGLRenderTarget(rtWidth, rtHeight);


   Then we need a ``Camera`` and a
   ``Scene``


   .. code:: javascript

      const rtFov = 75;
      const rtAspect = rtWidth / rtHeight;
      const rtNear = 0.1;
      const rtFar = 5;
      const rtCamera = new THREE.PerspectiveCamera(rtFov, rtAspect, rtNear, rtFar);
      rtCamera.position.z = 2;

      const rtScene = new THREE.Scene();
      rtScene.background = new THREE.Color('red');


   Notice we set the aspect to the aspect for the render target, not the canvas. The
   correct aspect to use depends on what we are rendering for. In this case we'll use
   the render target's texture on the side of a cube. Since faces of the cube are
   square we want an aspect of 1.0.

   We fill the scene with stuff. In this case we're using the light and the 3 cubes
   `from the previous article <responsive>`.


   .. code:: javascript

      {
         const color = 0xFFFFFF;
         const intensity = 1;
         const light = new THREE.DirectionalLight(color, intensity);
         light.position.set(-1, 2, 4);
      *  rtScene.add(light);
      }

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

      function makeInstance(geometry, color, x) {
         const material = new THREE.MeshPhongMaterial({color});

         const cube = new THREE.Mesh(geometry, material);
      *  rtScene.add(cube);

         cube.position.x = x;

         return cube;
      }

      *  const rtCubes = [
         makeInstance(geometry, 0x44aa88,  0),
         makeInstance(geometry, 0x8844aa, -2),
         makeInstance(geometry, 0xaa8844,  2),
      ];


   The ``Scene`` and ``Camera`` from the previous article are still there. 
   We'll use them to render to the canvas. We just need to add stuff to render.

   Let's add a cube that uses the render target's texture.


   .. code:: javascript

      const material = new THREE.MeshPhongMaterial({
         map: renderTarget.texture,
      });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);


   Now at render time first we render the render target scene to the render target.


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         ...

         // rotate all the cubes in the render target scene
         rtCubes.forEach((cube, ndx) => {
            const speed = 1 + ndx * .1;
            const rot = time * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
         });

         // draw render target scene to render target
         renderer.setRenderTarget(renderTarget);
         renderer.render(rtScene, rtCamera);
         renderer.setRenderTarget(null);


   Then we render the scene with the single cube that is using the render target's
   texture to the canvas.


   .. code:: javascript

         // rotate the cube in the scene
         cube.rotation.x = time;
         cube.rotation.y = time * 1.1;

         // render the scene to the canvas
         renderer.render(scene, camera);


   And voilà


      `click here to open in a separate window <https://threejs.org/manual/examples/render-target.html>`__

   The cube is red because we set the ``background`` of the ``rtScene`` to red so the
   render target's texture is being cleared to red.

   Render targets are used for all kinds of things. `Shadows <shadows>` use
   render targets. `Picking can use a render target <picking>`. Various kinds of
   `post processing effects <post-processing>` require render targets. Rendering
   a rear view mirror in a car or a live view on a monitor inside a 3D scene might use
   a render target.

   A few notes about using ``WebGLRenderTarget``.

   -  By default ``WebGLRenderTarget``
      creates 2 textures. A color texture and a depth/stencil texture. If you don't
      need the depth or stencil textures you can request to not create them by passing
      in options. Example:


      .. code:: javascript

            const rt = new THREE.WebGLRenderTarget(width, height, {
               depthBuffer: false,
               stencilBuffer: false,
            });


   -  You might need to change the size of a render target

      In the example above we make a render target of a fixed size, 512x512. For things
      like post processing you generally need to make a render target the same size as
      your canvas. In our code that would mean when we change the canvas size we would
      also update both the render target size and the camera we're using when rendering
      to the render target. Example:


      .. code:: javascript

         function render(time) {
            time *= 0.001;

            if (resizeRendererToDisplaySize(renderer)) {
               const canvas = renderer.domElement;
               camera.aspect = canvas.clientWidth / canvas.clientHeight;
               camera.updateProjectionMatrix();

         +    renderTarget.setSize(canvas.width, canvas.height);
         +    rtCamera.aspect = camera.aspect;
         +    rtCamera.updateProjectionMatrix();
         }



.. _F14:

Custom BufferGeometry
=====================

   -  `Custom BufferGeometry <https://threejs.org/manual/en/custom-buffergeometry.html>`__


   ``BufferGeometry`` is three.js's way of representing all geometry. A
   ``BufferGeometry`` essentially a collection *named* of ``BufferAttribute``\ s. Each
   ``BufferAttribute`` represents an array of one type of data: positions, normals, 
   colors, uv, etc... Together, the named ``BufferAttribute``\ s represent *parallel
   arrays* of all the data for each vertex.


   .. code:: javascript

                                             vertex4
                                          ┌───────────┐
      ┌───────────────────────────────────┬───────────┬───────────────────────┐
      │ position                          │           │                       │
      ├───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┤
      │ x │ y │ z │ x │ y │ z │ x │ y │ z │ x │ y │ z │ x │ y │ z │ x │ y │ z │
      └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
      ┌───────────────────────────────────┬───────────┬───────────────────────┐
      │ normal                            │           │                       │
      ├───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┤
      │ x │ y │ z │ x │ y │ z │ x │ y │ z │ x │ y │ z │ x │ y │ z │ x │ y │ z │
      └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
      ┌───────────────────────────────────┬───────────┬───────────────────────┐
      │ color                             │           │                       │
      ├───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┤
      │ r │ g │ b │ r │ g │ b │ r │ g │ b │ r │ g │ b │ r │ g │ b │ r │ g │ b │
      └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
      ┌───────────────────────────────────┬───────────┬───────────────────────┐
      │ uv                                │           │                       │
      ├─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┤
      │  u  │  v  │  u  │  v  │  u  │  v  │  u  │  v  │  u  │  v  │  u  │  v  │
      └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
                                          └───────────┘

      .. image:: https://threejs.org/manual/resources/threejs-attributes.svg


   Above you can see we have 4 attributes: ``position``, ``normal``, ``color``, ``uv``.
   They represent *parallel arrays* which means that the Nth set of data in each
   attribute belongs to the same vertex. The vertex at index = 4 is highlighted to show
   that the parallel data across all attributes defines one vertex.

   This brings up a point, here's a diagram of a cube with one corner highlighted.

   .. image:: https://threejs.org/manual/resources/cube-faces-vertex.svg


   Thinking about it that single corner needs a different normal for each face of the
   cube. A normal is info about which direction something faces. In the diagram the
   normals are presented by the arrows around the corner vertex showing that each face
   that shares that vertex position needs a normal that points in a different
   direction.

   That corner needs different UVs for each face as well. UVs are texture coordinates
   that specify which part of a texture being drawn on a triangle corresponds to that
   vertex position. You can see the green face needs that vertex to have a UV that
   corresponds to the top right corner of the F texture, the blue face needs a UV that
   corresponds to the top left corner of the F texture, and the red face needs a UV
   that corresponds to the bottom left corner of the F texture.

   A single *vertex* is the combination of all of its parts. If a vertex needs any part
   to be different then it must be a different vertex.

   As a simple example let's make a cube using ``BufferGeometry``. A cube is interesting
   because it appears to share vertices at the corners but really does not. For our
   example we'll list out all the vertices with all their data and then convert that
   data into parallel arrays and finally use those to make ``BufferAttribute``\ s and 
   add them to a ``BufferGeometry``.

   We start with a list of all the data needed for the cube. Remember again that if a
   vertex has any unique parts it has to be a separate vertex. As such to make a cube
   requires 36 vertices. 2 triangles per face, 3 vertices per triangle, 6 faces = 36
   vertices.


   .. code:: javascript

      const vertices = [
         // front
         { pos: [-1, -1,  1], norm: [ 0,  0,  1], uv: [0, 0], },
         { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 0], },
         { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 1], },

         { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 1], },
         { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 0], },
         { pos: [ 1,  1,  1], norm: [ 0,  0,  1], uv: [1, 1], },
         // right
         { pos: [ 1, -1,  1], norm: [ 1,  0,  0], uv: [0, 0], },
         { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 0], },
         { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 1], },

         { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 1], },
         { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 0], },
         { pos: [ 1,  1, -1], norm: [ 1,  0,  0], uv: [1, 1], },
         // back
         { pos: [ 1, -1, -1], norm: [ 0,  0, -1], uv: [0, 0], },
         { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 0], },
         { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 1], },

         { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 1], },
         { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 0], },
         { pos: [-1,  1, -1], norm: [ 0,  0, -1], uv: [1, 1], },
         // left
         { pos: [-1, -1, -1], norm: [-1,  0,  0], uv: [0, 0], },
         { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 0], },
         { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 1], },

         { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 1], },
         { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 0], },
         { pos: [-1,  1,  1], norm: [-1,  0,  0], uv: [1, 1], },
         // top
         { pos: [ 1,  1, -1], norm: [ 0,  1,  0], uv: [0, 0], },
         { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 0], },
         { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 1], },

         { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 1], },
         { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 0], },
         { pos: [-1,  1,  1], norm: [ 0,  1,  0], uv: [1, 1], },
         // bottom
         { pos: [ 1, -1,  1], norm: [ 0, -1,  0], uv: [0, 0], },
         { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 0], },
         { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 1], },

         { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 1], },
         { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 0], },
         { pos: [-1, -1, -1], norm: [ 0, -1,  0], uv: [1, 1], },
      ];


   We can then translate all of that into 3 parallel arrays


   .. code:: javascript

      const positions = [];
      const normals = [];
      const uvs = [];
      for (const vertex of vertices) {
         positions.push(...vertex.pos);
         normals.push(...vertex.norm);
         uvs.push(...vertex.uv);
      }


   Finally we can create a ``BufferGeometry`` and then a ``BufferAttribute`` for each
   array and add it to the ``BufferGeometry``.


   .. code:: javascript

         const geometry = new THREE.BufferGeometry();
         const positionNumComponents = 3;
         const normalNumComponents = 3;
         const uvNumComponents = 2;
         geometry.setAttribute(
            'position',
            new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
         geometry.setAttribute(
            'normal',
            new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
         geometry.setAttribute(
            'uv',
            new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));


   Note that the names are significant. You must name your attributes the names that
   match what three.js expects (unless you are creating a custom shader). In this case
   ``position``, ``normal``, and ``uv``. If you want vertex colors then name your
   attribute ``color``.

   Above we created 3 JavaScript native arrays, ``positions``, ``normals`` and ``uvs``.
   We then convert those into `TypedArrays <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray>`__
   of type ``Float32Array``. A ``BufferAttribute`` requires a TypedArray not a native 
   array. A ``BufferAttribute`` also requires you to tell it how many components there 
   are per vertex. For the positions and normals we have 3 components per vertex, x, y, 
   and z. For the UVs we have 2, u and v.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/custom-buffergeometry-cube.html>`__

   That's a lot of data. A small thing we can do is use indices to reference the
   vertices. Looking back at our cube data, each face is made from 2 triangles with 3
   vertices each, 6 vertices total, but 2 of those vertices are exactly the same; The
   same position, the same normal, and the same uv. So, we can remove the matching
   vertices and then reference them by index. First we remove the matching vertices.


   .. code:: javascript

      const vertices = [
         // front
         { pos: [-1, -1,  1], norm: [ 0,  0,  1], uv: [0, 0], }, // 0
         { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 0], }, // 1
         { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 1], }, // 2
      - 
      -  { pos: [-1,  1,  1], norm: [ 0,  0,  1], uv: [0, 1], },
      -  { pos: [ 1, -1,  1], norm: [ 0,  0,  1], uv: [1, 0], },
         { pos: [ 1,  1,  1], norm: [ 0,  0,  1], uv: [1, 1], }, // 3
         // right
         { pos: [ 1, -1,  1], norm: [ 1,  0,  0], uv: [0, 0], }, // 4
         { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 0], }, // 5
      - 
      -  { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 1], },
      -  { pos: [ 1, -1, -1], norm: [ 1,  0,  0], uv: [1, 0], },
         { pos: [ 1,  1,  1], norm: [ 1,  0,  0], uv: [0, 1], }, // 6
         { pos: [ 1,  1, -1], norm: [ 1,  0,  0], uv: [1, 1], }, // 7
         // back
         { pos: [ 1, -1, -1], norm: [ 0,  0, -1], uv: [0, 0], }, // 8
         { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 0], }, // 9
      - 
      -  { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 1], },
      -  { pos: [-1, -1, -1], norm: [ 0,  0, -1], uv: [1, 0], },
         { pos: [ 1,  1, -1], norm: [ 0,  0, -1], uv: [0, 1], }, // 10
         { pos: [-1,  1, -1], norm: [ 0,  0, -1], uv: [1, 1], }, // 11
         // left
         { pos: [-1, -1, -1], norm: [-1,  0,  0], uv: [0, 0], }, // 12
         { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 0], }, // 13
      - 
      -  { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 1], },
      -  { pos: [-1, -1,  1], norm: [-1,  0,  0], uv: [1, 0], },
         { pos: [-1,  1, -1], norm: [-1,  0,  0], uv: [0, 1], }, // 14
         { pos: [-1,  1,  1], norm: [-1,  0,  0], uv: [1, 1], }, // 15
         // top
         { pos: [ 1,  1, -1], norm: [ 0,  1,  0], uv: [0, 0], }, // 16
         { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 0], }, // 17
      - 
      -  { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 1], },
      -  { pos: [-1,  1, -1], norm: [ 0,  1,  0], uv: [1, 0], },
         { pos: [ 1,  1,  1], norm: [ 0,  1,  0], uv: [0, 1], }, // 18
         { pos: [-1,  1,  1], norm: [ 0,  1,  0], uv: [1, 1], }, // 19
         // bottom
         { pos: [ 1, -1,  1], norm: [ 0, -1,  0], uv: [0, 0], }, // 20
         { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 0], }, // 21
      - 
      -  { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 1], },
      -   { pos: [-1, -1,  1], norm: [ 0, -1,  0], uv: [1, 0], },
         { pos: [ 1, -1, -1], norm: [ 0, -1,  0], uv: [0, 1], }, // 22
         { pos: [-1, -1, -1], norm: [ 0, -1,  0], uv: [1, 1], }, // 23
      ];


   So now we have 24 unique vertices. Then we specify 36 indices for the 36 vertices we
   need drawn to make 12 triangles by calling ``BufferGeometry.setIndex`` with an
   array of indices.


   .. code:: javascript

      geometry.setAttribute(
            'position',
            new THREE.BufferAttribute(positions, positionNumComponents));
      geometry.setAttribute(
            'normal',
            new THREE.BufferAttribute(normals, normalNumComponents));
      geometry.setAttribute(
            'uv',
            new THREE.BufferAttribute(uvs, uvNumComponents));

      + geometry.setIndex([
      +    0,  1,  2,   2,  1,  3,  // front
      +    4,  5,  6,   6,  5,  7,  // right
      +    8,  9, 10,  10,  9, 11,  // back
      +   12, 13, 14,  14, 13, 15,  // left
      +   16, 17, 18,  18, 17, 19,  // top
      +   20, 21, 22,  22, 21, 23,  // bottom
      + ]);


      `click here to open in a separate
      window <https://threejs.org/manual/examples/custom-buffergeometry-cube-indexed.html>`__


   ``BufferGeometry`` has a ``computeVertexNormals`` method for computing normals 
   if you are not supplying them. Unfortunately, since positions can not be shared 
   if any other part of a vertex is different, the results of calling ``computeVertexNormals`` 
   will generate seams if your geometry is supposed to connect to itself like a 
   sphere or a cylinder.

   .. container:: spread

      <div data-diagram="bufferGeometryCylinder" style="touch-action: none;"></div>

   For the cylinder above the normals were created using ``computeVertexNormals``. If
   you look closely there is a seam on the cylinder. This is because there is no way to
   share the vertices at the start and end of the cylinder since they require different
   UVs so the function to compute them has no idea those are the same vertices to
   smooth over them. Just a small thing to be aware of. The solution is to supply your
   own normals.

   We can also use `TypedArrays <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray>`__
   from the start instead of native JavaScript arrays. The disadvantage to TypedArrays
   is you must specify their size up front. Of course that's not that large of a burden
   but with native arrays we can just ``push`` values onto them and look at what size
   they end up by checking their ``length`` at the end. With TypedArrays there is no
   push function so we need to do our own bookkeeping when adding values to them.

   In this example knowing the length up front is pretty easy since we're using a big
   block of static data to start.


   .. code:: javascript

      - const positions = [];
      - const normals = [];
      - const uvs = [];
      + const numVertices = vertices.length;
      + const positionNumComponents = 3;
      + const normalNumComponents = 3;
      + const uvNumComponents = 2;
      + const positions = new Float32Array(numVertices * positionNumComponents);
      + const normals = new Float32Array(numVertices * normalNumComponents);
      + const uvs = new Float32Array(numVertices * uvNumComponents);
      + let posNdx = 0;
      + let nrmNdx = 0;
      + let uvNdx = 0;
      for (const vertex of vertices) {
      -  positions.push(...vertex.pos);
      -  normals.push(...vertex.norm);
      -  uvs.push(...vertex.uv);
      +   positions.set(vertex.pos, posNdx);
      +   normals.set(vertex.norm, nrmNdx);
      +   uvs.set(vertex.uv, uvNdx);
      +   posNdx += positionNumComponents;
      +   nrmNdx += normalNumComponents;
      +   uvNdx += uvNumComponents;
      }

      geometry.setAttribute(
            'position',
      -     new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      +     new THREE.BufferAttribute(positions, positionNumComponents));
      geometry.setAttribute(
            'normal',
      -     new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      +     new THREE.BufferAttribute(normals, normalNumComponents));
      geometry.setAttribute(
            'uv',
      -     new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      +     new THREE.BufferAttribute(uvs, uvNumComponents));

      geometry.setIndex([
         0,  1,  2,   2,  1,  3,  // front
         4,  5,  6,   6,  5,  7,  // right
         8,  9, 10,  10,  9, 11,  // back
         12, 13, 14,  14, 13, 15,  // left
         16, 17, 18,  18, 17, 19,  // top
         20, 21, 22,  22, 21, 23,  // bottom
      ]);


      `click here to open in a separate
      window <https://threejs.org/manual/examples/custom-buffergeometry-cube-typedarrays.html>`__


   A good reason to use typedarrays is if you want to dynamically update any part of
   the vertices.

   I couldn't think of a really good example of dynamically updating the vertices so I
   decided to make a sphere and move each quad in and out from the center. Hopefully
   it's a useful example.

   Here's the code to generate positions and indices for a sphere. The code is sharing
   vertices within a quad but it's not sharing vertices between quads because we want
   to be able to move each quad separately.

   Because I'm lazy I used a small hierarchy of 3 ``Object3D`` objects to compute 
   sphere points. How this works is explained in `the article on optimizing lots of
   objects <optimize-lots-of-objects>`.


   .. code:: javascript

      function makeSpherePositions(segmentsAround, segmentsDown) {
         const numVertices = segmentsAround * segmentsDown * 6;
         const numComponents = 3;
         const positions = new Float32Array(numVertices * numComponents);
         const indices = [];

         const longHelper = new THREE.Object3D();
         const latHelper = new THREE.Object3D();
         const pointHelper = new THREE.Object3D();
         longHelper.add(latHelper);
         latHelper.add(pointHelper);
         pointHelper.position.z = 1;
         const temp = new THREE.Vector3();

         function getPoint(lat, long) {
            latHelper.rotation.x = lat;
            longHelper.rotation.y = long;
            longHelper.updateMatrixWorld(true);
            return pointHelper.getWorldPosition(temp).toArray();
         }

         let posNdx = 0;
         let ndx = 0;
         for (let down = 0; down < segmentsDown; ++down) {
            const v0 = down / segmentsDown;
            const v1 = (down + 1) / segmentsDown;
            const lat0 = (v0 - 0.5) * Math.PI;
            const lat1 = (v1 - 0.5) * Math.PI;

            for (let across = 0; across < segmentsAround; ++across) {
            const u0 = across / segmentsAround;
            const u1 = (across + 1) / segmentsAround;
            const long0 = u0 * Math.PI * 2;
            const long1 = u1 * Math.PI * 2;

            positions.set(getPoint(lat0, long0), posNdx);  posNdx += numComponents;
            positions.set(getPoint(lat1, long0), posNdx);  posNdx += numComponents;
            positions.set(getPoint(lat0, long1), posNdx);  posNdx += numComponents;
            positions.set(getPoint(lat1, long1), posNdx);  posNdx += numComponents;

            indices.push(
               ndx, ndx + 1, ndx + 2,
               ndx + 2, ndx + 1, ndx + 3,
            );
            ndx += 4;
            }
         }
         return {positions, indices};
      }


   We can then call it like this


   .. code:: javascript

      const segmentsAround = 24;
      const segmentsDown = 16;
      const {positions, indices} = makeSpherePositions(segmentsAround, segmentsDown);


   Because positions returned are unit sphere positions so they are exactly the same
   values we need for normals so we can just duplicated them for the normals.


   .. code:: javascript

      const normals = positions.slice();


   And then we setup the attributes like before


   .. code:: javascript

      const geometry = new THREE.BufferGeometry();
      const positionNumComponents = 3;
      const normalNumComponents = 3;

      + const positionAttribute = new THREE.BufferAttribute(positions, positionNumComponents);
      + positionAttribute.setUsage(THREE.DynamicDrawUsage);
      geometry.setAttribute(
            'position',
      +     positionAttribute);
      geometry.setAttribute(
            'normal',
            new THREE.BufferAttribute(normals, normalNumComponents));
      geometry.setIndex(indices);


   I've highlighted a few differences. We save a reference to the position attribute.
   We also mark it as dynamic. This is a hint to THREE.js that we're going to be
   changing the contents of the attribute often.

   In our render loop we update the positions based off their normals every frame.


   .. code:: javascript

      const temp = new THREE.Vector3();

      ...

      for (let i = 0; i < positions.length; i += 3) {
         const quad = (i / 12 | 0);
         const ringId = quad / segmentsAround | 0;
         const ringQuadId = quad % segmentsAround;
         const ringU = ringQuadId / segmentsAround;
         const angle = ringU * Math.PI * 2;
         temp.fromArray(normals, i);
         temp.multiplyScalar(THREE.MathUtils.lerp(1, 1.4, Math.sin(time + ringId + angle) * .5 + .5));
         temp.toArray(positions, i);
      }
      positionAttribute.needsUpdate = true;


   And we set ``positionAttribute.needsUpdate`` to tell THREE.js to use our changes.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/custom-buffergeometry-dynamic.html>`__

   I hope these were useful examples of how to use ``BufferGeometry`` directly to make 
   your own geometry and how to dynamically update the contents of a ``BufferAttribute``.

   .. image:: https://threejs.org/manual/resources/threejs-geometry.svg



.. _F15:

Rendering On Demand
===================

   -  `Rendering On Demand <https://threejs.org/manual/en/rendering-on-demand.html>`__


   The topic might be obvious to many people but just in case ... most Three.js
   examples render continuously. In other words they setup a ``requestAnimationFrame``
   loop or "*rAF loop*" something like this


   .. code:: javascript

      function render() {
         ...
         requestAnimationFrame(render);
      }
      requestAnimationFrame(render);


   For something that animates this makes sense but what about for something that does
   not animate? In that case rendering continuously is a waste of the devices power and
   if the user is on portable device it wastes the user's battery.

   The most obvious way to solve this is to render once at the start and then render
   only when something changes. Changes include textures or models finally loading,
   data arriving from some external source, the user adjusting a setting or the camera
   or giving other relevant input.

   Let's take an example from `the article on responsiveness <responsive>` and
   modify it to render on demand.

   First we'll add in the `OrbitControls` so there is something that could change 
   that we can render in response to.


   .. code:: javascript

      import * as THREE from 'three';
      + import {OrbitControls} from 'three/addons/controls/OrbitControls.js';


   and set them up


   .. code:: javascript

      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      const far = 5;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.z = 2;

      + const controls = new OrbitControls(camera, canvas);
      + controls.target.set(0, 0, 0);
      + controls.update();


   Since we won't be animating the cubes anymore we no longer need to keep track of
   them


   .. code:: javascript

      - const cubes = [
      -  makeInstance(geometry, 0x44aa88,  0),
      -  makeInstance(geometry, 0x8844aa, -2),
      -  makeInstance(geometry, 0xaa8844,  2),
      - ];
      + makeInstance(geometry, 0x44aa88,  0);
      + makeInstance(geometry, 0x8844aa, -2);
      + makeInstance(geometry, 0xaa8844,  2);


   We can remove the code to animate the cubes and the calls to
   ``requestAnimationFrame``


   .. code:: javascript

      - function render(time) {
      -  time *= 0.001;
      + function render() {

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

      -  cubes.forEach((cube, ndx) => {
      -     const speed = 1 + ndx * .1;
      -     const rot = time * speed;
      -     cube.rotation.x = rot;
      -     cube.rotation.y = rot;
      -   });

         renderer.render(scene, camera);

      -  requestAnimationFrame(render);
      }

      - requestAnimationFrame(render);


   then we need to render once


   .. code:: javascript

      render();


   We need to render anytime the `OrbitControls` change the camera settings. Fortunately 
   the `OrbitControls` dispatch a ``change`` event anytime something changes.


   .. code:: javascript

      controls.addEventListener('change', render);


   We also need to handle the case where the user resizes the window. That was handled
   automatically before since we were rendering continuously but now what we are not we
   need to render when the window changes size.


   .. code:: javascript

      window.addEventListener('resize', render);


   And with that we get something that renders on demand.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/render-on-demand.html>`__

   The `OrbitControls` have options to add a kind of inertia to make them feel less stiff. 
   We can enable this by setting the ``enableDamping`` property to true.


   .. code:: javascript

      controls.enableDamping = true;


   With ``enableDamping`` on we need to call ``controls.update`` in our render function
   so that the `OrbitControls` can continue to give us new camera settings as they 
   smooth out the movement. But, that means we can't call ``render`` directly from 
   the ``change`` event because we'll end up in an infinite loop. The controls will 
   send us a ``change`` event and call ``render``, ``render`` will call ``controls.update``. 
   ``controls.update`` will send another ``change`` event.

   We can fix that by using ``requestAnimationFrame`` to call ``render`` but we need to
   make sure we only ask for a new frame if one has not already been requested which we
   can do by keeping a variable that tracks if we've already requested a frame.


   .. code:: javascript

      + let renderRequested = false;

      function render() {
      +  renderRequested = false;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

         renderer.render(scene, camera);
      }
      render();

      + function requestRenderIfNotRequested() {
      +   if (!renderRequested) {
      +     renderRequested = true;
      +     requestAnimationFrame(render);
      +   }
      + }

      - controls.addEventListener('change', render);
      + controls.addEventListener('change', requestRenderIfNotRequested);


   We should probably also use ``requestRenderIfNotRequested`` for resizing as well


   .. code:: javascript

      - window.addEventListener('resize', render);
      + window.addEventListener('resize', requestRenderIfNotRequested);


   It might be hard to see the difference. Try clicking on the example below and use
   the arrow keys to move around or dragging to spin. Then try clicking on the example
   above and do the same thing and you should be able to tell the difference. The one
   above snaps when you press an arrow key or drag, the one below slides.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/render-on-demand-w-damping.html>`__

   Let's also add a simple lil-gui GUI and make its changes render on demand.


   .. code:: javascript

      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      + import {GUI} from 'three/addons/libs/lil-gui.module.min.js';


   Let's allow setting the color and x scale of each cube. To be able to set the color
   we'll use the ``ColorGUIHelper`` we created in the `article on lights <lights>`.

   First we need to create a GUI


   .. code:: javascript

      const gui = new GUI();


   and then for each cube we'll create a folder and add 2 controls, one for
   ``material.color`` and another for ``cube.scale.x``.


   .. code:: javascript

      function makeInstance(geometry, color, x) {
         const material = new THREE.MeshPhongMaterial({color});

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);

         cube.position.x = x;

      +   const folder = gui.addFolder(`Cube${x}`);
      +   folder.addColor(new ColorGUIHelper(material, 'color'), 'value')
      +       .name('color')
      +       .onChange(requestRenderIfNotRequested);
      +   folder.add(cube.scale, 'x', .1, 1.5)
      +       .name('scale x')
      +       .onChange(requestRenderIfNotRequested);
      +   folder.open();

         return cube;
      }


   You can see above lil-gui controls have an ``onChange`` method that you can pass a
   callback to be called when the GUI changes a value. In our case we just need it to
   call ``requestRenderIfNotRequested``. The call to ``folder.open`` makes the folder
   start expanded.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/render-on-demand-w-gui.html>`__

   I hope this gives some idea of how to make three.js render on demand instead of
   continuously. Apps/pages that render three.js on demand are not as common as most
   pages using three.js are either games or 3D animated art but examples of pages that
   might be better rendering on demand would be say a map viewer, a 3d editor, a 3d
   graph generator, a product catalog, etc...


.. _F16:

Debugging JavaScript
====================

   -  `Debugging JavaScript <https://threejs.org/manual/en/debugging-javascript.html>`__


   Most of this article is not directly about THREE.js but is rather about debugging
   JavaScript in general. It seemed important in that many people just starting with
   THREE.js are also just starting with JavaScript so I hope this can help them more
   easily solve any issues they run into.

   Debugging is a big topic and I probably can't begin to cover everything there is to
   know but if you're new to JavaScript then here's an attempt to give a few pointers.
   I strongly suggest you take some time to learn them. They'll help you enormously in
   your learning.

   *  Learn your Browser's Developer Tools
   *  Turn off the cache
   *  Use the JavaScript console
   *  Put data on screen
   *  Query Parameters
   *  Learn to use the Debugger
   *  Check for ``NaN`` in the debugger or elsewhere
   *  Look In the Code!
   *  Put ``requestAnimationFrame`` at bottom of your render function.
   *  Check your units!
   *  Making a *Minimal, Complete, Verifiable, Example* for Stack Overflow
   *  Use a ``MeshBasicMaterial``
   *  Check your ``near`` and ``far`` settings for your camera
   *  Check your scene is in front of the camera
   *  Put something in front of the camera


Learn your Browser's Developer Tools
------------------------------------

   All browsers have developer tools.
   `Chrome <https://developers.google.cn/web/tools/chrome-devtools/>`__,
   `Firefox <https://developer.mozilla.org/en-US/docs/Tools>`__,
   `Safari <https://developer.apple.com/safari/tools/>`__,
   `Edge <https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide>`__.

   In Chrome you can click the the ``⋮`` icon, pick More Tools->Developer Tools to get
   to the developer tools. A keyboard shortcut is also shown there.


   .. image:: https://threejs.org/manual/resources/images/devtools-chrome.jpg
      :class: border

   In Firefox you click the ``☰`` icon, pick "Web Developer", then pick "Toggle Tools"


   .. image:: https://threejs.org/manual/resources/images/devtools-firefox.jpg
      :class: border

   In Safari you first have to enable the Develop menu from the Advanced Safari
   Preferences.


   .. image:: https://threejs.org/manual/resources/images/devtools-enable-safari.jpg
      :class: border

   Then in the Develop menu you can pick "Show/Connect Web Inspector".


   .. image:: https://threejs.org/manual/resources/images/devtools-safari.jpg
      :class: border

   With Chrome you can also `use Chrome on your computer to debug webpages running on
   Chrome on your Android phone or tablet <https://developers.google.cn/web/tools/chrome-devtools/remote-debugging/>`__.
   Similarly with Safari you can `use your computer to debug webpages running on Safari
   on iPhones and iPads <https://www.bing.com/search?q=safari+remote+debugging+ios>`__.

   I'm most familiar with Chrome so this guide will be using Chrome as an example when
   referring to tools but most browsers have similar features so it should be easy to
   apply anything here to all browsers.


Turn off the cache
------------------

   Browsers try to reuse data they've already downloaded. This is great for users so if
   you visit a website a second time many of the files used to display the site will
   not have be downloaded again.

   On the other hand this can be bad for web development. You change a file on your
   computer, reload the page, and you don't see the changes because the browser uses
   the version it got last time.

   One solution during web development is to turn off the cache. This way the browser
   will always get the newest versions of your files.

   First pick settings from the corner menu

   .. image:: https://threejs.org/manual/resources/images/devtools-chrome-settings.jpg
      :class: border


   Then pick "Disable Cache (while DevTools is open)".


   .. image:: https://threejs.org/manual/resources/images/devtools-chrome-disable-cache.jpg
      :class: border




Use the JavaScript console
--------------------------

   Inside all devtools is a *console*. It shows warnings and error messages.

   **READ THE MESSAGES!!**

   Typically there should be only 1 or 2 messages.

   .. image:: https://threejs.org/manual/resources/images/devtools-no-errors.jpg
      :class: border


   If you see any others **READ THEM**. For example:


   .. image:: https://threejs.org/manual/resources/images/devtools-errors.jpg
      :class: border

   I mis-spelled "three" as "threee"

   You can also print your own info to the console with with ``console.log`` as in


   .. code:: javascript

      console.log(someObject.position.x, someObject.position.y, someObject.position.z);

 
   Even cooler, if you log an object you can inspect it. For example if we log the root
   scene object from `the gLTF article <load-gltf>`


   .. code:: javascript

         {
            const gltfLoader = new GLTFLoader();
            gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) => {
            const root = gltf.scene;
            scene.add(root);
      +     console.log(root);


   Then we can expand that object in the JavaScript console


   .. image:: https://threejs.org/manual/resources/images/devtools-console-object.gif
      :class: border


   You can also use ``console.error`` which reports the message in red in includes a
   stack trace.


Put data on screen
------------------

   Another obvious but often overlooked way is to add ``<div>`` or ``<pre>`` tags and
   put data in them.

   The most obvious way is to make some HTML elements


   .. code:: javascript

      <canvas id="c"></canvas>
      + <div id="debug">
      +   <div>x:<span id="x"></span></div>
      +   <div>y:<span id="y"></span></div>
      +   <div>z:<span id="z"></span></div>
      + </div>


   Style them so they stay on top of the canvas. (assuming your canvas fills the page)


   .. code:: javascript

      <style>
      #debug {
         position: absolute;
         left: 1em;
         top: 1em;
         padding: 1em;
         background: rgba(0, 0, 0, 0.8);
         color: white;
         font-family: monospace;
      }
      </style>


   And then looking the elements up and setting their content.


   .. code:: javascript

      // at init time
      const xElem = document.querySelector('#x');
      const yElem = document.querySelector('#y');
      const zElem = document.querySelector('#z');

      // at render or update time
      xElem.textContent = someObject.position.x.toFixed(3);
      yElem.textContent = someObject.position.y.toFixed(3);
      zElem.textContent = someObject.position.z.toFixed(3);


   This is more useful for real time values


      `click here to open in a separate
      window <https://threejs.org/manual/examples/debug-js-html-elements.html>`__

   Another way to put data on the screen is to make a clearing logger. I just made that
   term up but lots of games I've worked on have used this solution. The idea is you
   have a buffer that displays messages for only one frame. Any part of your code that
   wants to display data calls some function to add data to that buffer every frame.
   This is much less work than making an element per piece of data above.

   For example let's change the HTML from above to just this


   .. code:: javascript

      <canvas id="c"></canvas>
      <div id="debug">
         <pre></pre>
      </div>


   And let's make simple class to manage this *clear back buffer*.


   .. code:: javascript

      class ClearingLogger {
         constructor(elem) {
            this.elem = elem;
            this.lines = [];
         }
         log(...args) {
            this.lines.push([...args].join(' '));
         }
         render() {
            this.elem.textContent = this.lines.join('\n');
            this.lines = [];
         }
      }


   Then let's make a simple example that every time we click the mouse makes a mesh
   that moves in a random direction for 2 seconds. We'll start with one of the examples
   from the article on `making things responsive <responsive>`

   Here's the code that adds a new ``Mesh`` every time we click the mouse


   .. code:: javascript

      const geometry = new THREE.SphereGeometry();
      const material = new THREE.MeshBasicMaterial({color: 'red'});

      const things = [];

      function rand(min, max) {
         if (max === undefined) {
            max = min;
            min = 0;
         }
         return Math.random() * (max - min) + min;
      }

      function createThing() {
         const mesh = new THREE.Mesh(geometry, material);
         scene.add(mesh);
         things.push({
            mesh,
            timer: 2,
            velocity: new THREE.Vector3(rand(-5, 5), rand(-5, 5), rand(-5, 5)),
         });
      }

      canvas.addEventListener('click', createThing);


   And here's the code that moves the meshes we created, logs them, and removes them
   when their timer has run out


   .. code:: javascript

      const logger = new ClearingLogger(document.querySelector('#debug pre'));

      let then = 0;
      function render(now) {
         now *= 0.001;  // convert to seconds
         const deltaTime = now - then;
         then = now;

         ...

         logger.log('fps:', (1 / deltaTime).toFixed(1));
         logger.log('num things:', things.length);
         for (let i = 0; i < things.length;) {
            const thing = things[i];
            const mesh = thing.mesh;
            const pos = mesh.position;
            logger.log(
               'timer:', thing.timer.toFixed(3),
               'pos:', pos.x.toFixed(3), pos.y.toFixed(3), pos.z.toFixed(3));
            thing.timer -= deltaTime;
            if (thing.timer <= 0) {
               // remove this thing. Note we don't advance `i`
               things.splice(i, 1);
               scene.remove(mesh);
            } else {
               mesh.position.addScaledVector(thing.velocity, deltaTime);
               ++i;
            }
         }

         renderer.render(scene, camera);
         logger.render();

         requestAnimationFrame(render);
      }


   Now click the mouse a bunch in the example below


      `click here to open in a separate
      window <https://threejs.org/manual/examples/debug-js-clearing-logger.html>`__


Query Parameters
----------------

   Another thing to remember is that webpages can have data passed into them either via
   query parameters or the anchor, sometimes called the search and the hash.


   .. code:: javascript

      https://domain/path/?query#anchor


   You can use this to make features optional or pass in parameters.

   For example let's take the previous example and make it so the debug stuff only
   shows up if we put ``?debug=true`` in the URL.

   First we need some code to parse the query string


   .. code:: javascript

      /**
         * Returns the query parameters as a key/value object.
         * Example: If the query parameters are
         *
         *    abc=123&def=456&name=gman
         *
         * Then `getQuery()` will return an object like
         *
         *    {
         *      abc: '123',
         *      def: '456',
         *      name: 'gman',
         *    }
         */
      function getQuery() {
         return Object.fromEntries(new URLSearchParams(window.location.search).entries());
      }


   Then we might make the debug element not show by default


   .. code:: javascript

      <canvas id="c"></canvas>
      + <div id="debug" style="display: none;">
         <pre></pre>
      </div>


   Then in the code we read the params and choose to un-hide the debug info if and only
   if ``?debug=true`` is passed in


   .. code:: javascript

      const query = getQuery();
      const debug = query.debug === 'true';
      const logger = debug
         ? new ClearingLogger(document.querySelector('#debug pre'))
         : new DummyLogger();
      if (debug) {
         document.querySelector('#debug').style.display = '';
      }


   We also made a ``DummyLogger`` that does nothing and chose to use it if
   ``?debug=true`` has not been passed in.


   .. code:: javascript

      class DummyLogger {
         log() {}
         render() {}
      }


   You can see if we use this url:

   `debug-js-params.html <https://threejs.org/manual/examples/debug-js-params.html>`__

   there is no debug info but if we use this url:

   `debug-js-params.html?debug=true <https://threejs.org/manual/examples/debug-js-params.html?debug=true>`__

   there is debug info.

   Multiple parameters can be passed in by separating with '&' as in
   ``somepage.html?someparam=somevalue&someotherparam=someothervalue``. Using
   parameters like this we can pass in all kinds of options. Maybe ``speed=0.01`` to
   slow down our app for making it easier to understand something or ``showHelpers=true`` 
   for whether or not to add helpers that show the lights, shadow, or camera frustum 
   seen in other lessons.


Learn to use the Debugger
-------------------------

   Every browser has a debugger where you can pause your program step through line by
   line and inspect all the variables.

   Teaching you how to use a debugger is too big a topic for this article but here's a
   few links

   -  `Get Started with Debugging JavaScript in Chrome DevTools <https://developer.chrome.google.cn/docs/devtools/>`__
   -  `Debugging in Chrome <https://javascript.info/debugging-chrome>`__
   -  `Tips and Tricks for Debugging in Chrome Developer Tools <https://hackernoon.com/tips-and-tricks-for-debugging-in-chrome-developer-tools-458ade27c7ab>`__


Check for ``NaN`` in the debugger or elsewhere
----------------------------------------------

   ``NaN`` is short for Not A Number. It's what JavaScript will assign as a value when
   you do something that doesn't make sense mathwise.

   As a simple example

   .. code:: javascript

      > v = 123 / 'banana'
      « NaN
      
      .. image:: https://threejs.org/manual/resources/images/nan-banana.png
         :class: border


   Often when I'm making something and nothing appears on the screen I'll check some
   values and if I see ``NaN`` I will instantly have a place to start looking.

   As an example when I first started making the path for the `article about loading
   gLTF files <load-gltf>` I made a curve using the ``SplineCurve`` class which makes 
   a 2D curve.

   I then used that curve to move the cars like this


   .. code:: javascript

      curve.getPointAt(zeroToOnePointOnCurve, car.position);


   Internally ``curve.getPointAt`` calls the ``set`` function on the object passed as
   the second argument. In this case that second argument is ``car.position`` which is
   a ``Vector3``. ``Vector3``'s ``set`` function requires 3 arguments, x, y, and z but
   ``SplineCurve`` is a 2D curve and so it calls ``car.position.set`` with just x and y.

   The result is that ``car.position.set`` sets x to x, y to y, and z to ``undefined``.

   A quick glance in the debugger looking at the car's ``matrixWorld`` showed a bunch
   of ``NaN`` values.

   .. image:: https://threejs.org/manual/resources/images/debugging-nan.gif
      :class: border


   Seeing the matrix had ``NaN``\ s in it suggested something like ``position``,
   ``rotation``, ``scale`` or some other function that affects that matrix had bad
   data. Working backward from their it was easy to track down the issue.

   In top of ``NaN`` there's also ``Infinity`` which is a similar sign there is a math
   bug somewhere.


Look In the Code!
-----------------

   THREE.js is Open Source. Don't be afraid to look inside the code! You can look
   inside on `github <https://github.com/mrdoob/three.js>`__. You can also look inside
   by stepping into functions in the debugger.


Put ``requestAnimationFrame`` at bottom of your render function.
----------------------------------------------------------------

   I see this pattern often


   .. code:: javascript

      function render() {
         requestAnimationFrame(render);

         // -- do stuff --

         renderer.render(scene, camera);
      }
      requestAnimationFrame(render);


   I'd suggest that putting the call to ``requestAnimationFrame`` at the bottom as in


   .. code:: javascript

      function render() {
         // -- do stuff --

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }
      requestAnimationFrame(render);


   The biggest reason is it means your code will stop if you have an error. Putting
   ``requestAnimationFrame`` at the top means your code will keep running even if you
   have an error since you already requested another frame. IMO it's better to find
   those errors than to ignore them. They could easily be the reason something is not
   appearing as you expect it to but unless your code stops you might not even notice.


Check your units!
-----------------

   This basically means knowing for example when to use degrees vs when to use radians.
   It's unfortunate that THREE.js does not consistently use the same units everywhere.
   Off the top of my head the camera's field of view is in degrees. All other angles
   are in radians.

   The other place to look out is your world unit size. Until recently 3D apps could
   choose any unit size they wanted. One app might choose 1 unit = 1cm. Another might
   choose 1 unit = 1 foot. It's actually still true that you can chose any units you
   want for certain applications. That said, THREE.js assumes 1 unit = 1 meter. This is
   important for things like physically based rendering which uses meters to compute
   lighting effects. It's also important for AR and VR which need to deal with real
   world units like where your phone is or where the VR controllers are.


Making a *Minimal, Complete, Verifiable, Example* for Stack Overflow
--------------------------------------------------------------------

   If you decide to ask a question about THREE.js it's almost always required for you
   to provide an MCVE which stands for `Minimal, Complete, Verifiable, Example`.

   The **Minimal** part is important. Let's say you where having an issue with the path
   movement in the last example of the `loading a gLTF article <load-gltf>`.
   That example has many parts. Listing them out it has

   #. A bunch of HTML
   #. Some CSS
   #. Lights
   #. Shadows
   #. lil-gui code to manipulate shadows
   #. Code to load a .GLTF file
   #. Code to resize the canvas.
   #. Code to move the cars along paths

   That's pretty huge. If your question is only about the path following part you can
   remove most of the HTML as you only need a ``<canvas>`` and a ``<script>`` tag for
   THREE.js. You can remove the CSS and the resizing code. You can remove .GLTF code
   because you only care about the path. You can remove the lights and the shadows by
   using a ``MeshBasicMaterial``. You can certainly remove the lil-gui code. The code 
   makes a ground plane with a texture. It would be easier to use a ``GridHelper``. 
   Finally if our question is about moving things on a path we could just use cubes on
   the path instead of loaded car models.

   Here's a more minimal example taking all the above into account. It shrunk from 271
   lines to 135. We might consider shrinking it even more by simplifying our path.
   Maybe a path with 3 or 4 points would work just as well as our path with 21 points.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/debugging-mcve.html>`__

   I kept the ``OrbitController`` just because it's useful for others to move the
   camera and figure out what's going on but depending on your issue you might be able
   to remove that as well.

   The best thing about making an MCVE is we'll often solve our own problem. The
   process of removing everything that's not needed and making the smallest example we
   can that reproduces the issue more often than not leads us to our bug.

   On top of that it's respectful of all the people's time who you are asking to look
   at your code on Stack Overflow. By making the minimal example you make it much
   easier for them to help you. You'll also learn in the process.

   Also important, when you go to Stack Overflow to post your question **put your
   code** `in a snippet <https://stackoverflow.blog/2014/09/16/introducing-runnable-javascript-css-and-html-code-snippets/>`__.
   Of course you are welcome to use JSFiddle or Codepen or similar site to test out
   your MCVE but once you actually get to posting your question on Stack Overflow
   you're required to put the code to reproduce your issue **in the question itself**.
   By making a snippet you satisfy that requirement.

   Also note all the live examples on this site should run as snippets. Just copy the
   HTML, CSS, and JavaScript parts to their respective parts of the `snippet
   editor <https://stackoverflow.blog/2014/09/16/introducing-runnable-javascript-css-and-html-code-snippets/>`__.
   Just remember to try to remove the parts that are not relevant to your issue and try
   to make your code the minimal amount needed.

   Follow these suggestions and you're far more likely to get help with your issue.


Use a ``MeshBasicMaterial``
---------------------------

   Because the ``MeshBasicMaterial`` uses no lights this is one way to remove reasons 
   something might not be showing up. If your objects show up using ``MeshBasicMaterial`` 
   but not with whatever materials you were using then you know the issue is likely with 
   the materials or the lights and not some other part of the code.


Check your ``near`` and ``far`` settings for your camera
--------------------------------------------------------

   A ``PerspectiveCamera`` has ``near`` and ``far`` settings which are covered in the 
   `article on cameras <cameras>`. Make sure they are set to fit the space that contains 
   your objects. Maybe even just **temporarily** set them to something large like 
   ``near`` = 0.001 and ``far`` = 1000000. You will likely run into depth resolution 
   issues but you'll at least be able to see your objects provided they are in front 
   of the camera.


Check your scene is in front of the camera
------------------------------------------

   Sometimes things don't appear because they are not in front of the camera. If your
   camera is not controllable try adding camera control like the ``OrbitController`` so
   you can look around and find your scene. Or, try framing the scene using code which
   is covered in `this article <load-obj>`. That code finds the size of part of
   the scene and then moves the camera and adjusts the ``near`` and ``far`` settings to
   make it visible. You can then look in the debugger or add some ``console.log``
   messages to print the size and center of the scene.


Put something in front of the camera
------------------------------------

   This is just another way of saying if all else fails start with something that works
   and then slowly add stuff back in. If you get a screen with nothing on it then try
   putting something directly in front of the camera. Make a sphere or box, give it a
   simple material like the ``MeshBasicMaterial`` and make sure you can get that on the 
   screen. Then start adding things back a little at time and testing. Eventually you'll
   either reproduce your bug or you'll find it on the way.


   These were a few tips for debugging JavaScript. Let's also go over `some tips for
   debugging GLSL <debugging-glsl>`.


.. _F17:

Debugging GLSL
==============

   -  `Debugging GLSL <https://threejs.org/manual/en/debugging-glsl.html>`__


   This site so far does not teach GLSL just like it does not teach JavaScript. Those
   are really large topics. If you want to learn GLSL consider checking out `these
   articles <https://webglfundamentals.org>`__ as a starting place.

   If you already know GLSL then here are a few tips for debugging.

   When I'm making a new GLSL shader and nothing appears generally the first thing I do
   is change the fragment shader to return a solid color. For example at the very
   bottom of the shader I might put


   .. code:: javascript

      void main() {

         ...

         gl_FragColor = vec4(1, 0, 0, 1);  // red
      }


   If I see the object I was trying to draw then I know the issue is related to my
   fragment shader. It could be anything like bad textures, uninitialized uniforms,
   uniforms with the wrong values but at least I have a direction to look.

   To test some of those I might start trying to draw some of the inputs. For example
   if I'm using normals in the fragment shader then I might add


   .. code:: javascript

      gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1);


   Normals go from -1 to +1 so by multiplying by 0.5 and adding 0.5 we get values that
   go from 0.0 to 1.0 which makes them useful for colors.

   Try this with some things you know work and you'll start getting an idea of what
   normals *normally* look like. If your normals don't look normal then you have some
   clue where to look. If you're manipulating normals in the fragments shader you can
   use the same technique to draw the result of that manipulation.


   .. image:: https://threejs.org/manual/resources/images/standard-primitive-normals.jpg

   Similarly if we're using textures there will be texture coordinates and we can draw
   them with something like


   .. code:: javascript

      gl_FragColor = vec4(fract(vUv), 0, 1);


   The ``fract`` is there in case we're using texture coordinates that go outside the 0
   to 1 range. This is common if ``texture.repeat`` is set to something greater than 1.


   .. image:: https://threejs.org/manual/resources/images/standard-primitive-uvs.jpg

   You can do similar things for all values in your fragment shader. Figure out what
   their range is likely to be, add some code to set ``gl_FragColor`` with that range
   scaled to 0.0 to 1.0

   To check textures try a ``CanvasTexture`` or a ``DataTexture`` that you know works.

   Conversely, if after setting ``gl_FragColor`` to red I still see nothing then I have
   a hint my issue might be in the direction of the things related to the vertex
   shader. Some matrices might be wrong or my attributes might have bad data or be
   setup incorrectly.

   I'd first look at the matrices. I might put a breakpoint right after my call to
   ``renderer.render(scene, camera)`` and then start expanding things in the inspector.
   Is the camera's world matrix and projection matrix at least not full of ``NaN``\ s?
   Expanding the scene and looking at its ``children`` I'd check that the world
   matrices look reasonable (no ``NaN``\ s) and last 4 values of each matrix look
   reasonable for my scene. If I expect my scene to be 50x50x50 units and some matrix
   shows 552352623.123 clearly something is wrong there.


   .. image:: https://threejs.org/manual/resources/images/inspect-matrices.gif

   Just like we did for the fragment shader we can also draw values from the vertex
   shader by passing them to the fragment shader. Declare a varying in both and pass
   the value you're not sure is correct. In fact if my shader use using normals I'll
   change the fragment shader to display them like is mentioned above and then just set
   ``vNormal`` to the value I want to display but scaled so the values go from 0.0 to
   1.0. I then look at the results and see if they fit my expectations.

   Another good thing to do is use a simpler shader. Can you draw your data with
   ``MeshBasicMaterial``? If you can then try it and make sure it shows up as expected.

   If not what's the simplest vertex shader that will let you visualize your geometry?
   Usually it's as simple as


   .. code:: javascript

      gl_Position = projection * modelView * vec4(position.xyz, 1);


   If that works start adding in your changes a little at a time.

   Yet another thing you can do is use the `Shader Editor extension for
   Chrome <https://chrome.google.com/webstore/detail/shader-editor/ggeaidddejpbakgafapihjbgdlbbbpob?hl=en>`__
   or similar for other browsers. It's a great way to look at how other shaders are
   working. It's also good as you can make some of the changes suggested above live
   while the code is running.



.. _F18:

Taking a screenshot
===================

   -  `Taking a screenshot <https://threejs.org/manual/en/tips.html#screenshot>`__


   This article is a collection of small issues you might run into using three.js that
   seemed too small to have their own article.


Taking A Screenshot of the Canvas
---------------------------------

   In the browser there are effectively 2 functions that will take a screenshot. The
   old one `canvas.toDataURL <https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL>`__
   and the new better one `canvas.toBlob <https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob>`__

   So you'd think it would be easy to take a screenshot by just adding some code like


   .. code:: javascript

      <canvas id="c"></canvas>
      + <button id="screenshot" type="button">Save...</button>



   .. code:: javascript

      const elem = document.querySelector('#screenshot');
      elem.addEventListener('click', () => {
         canvas.toBlob((blob) => {
            saveBlob(blob, `screencapture-${canvas.width}x${canvas.height}.png`);
         });
      });

      const saveBlob = (function() {
         const a = document.createElement('a');
         document.body.appendChild(a);
         a.style.display = 'none';
         return function saveData(blob, fileName) {
            const url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = fileName;
            a.click();
         };
      }());


   Here's the example from `the article on responsiveness <responsive>` with the
   code above added and some CSS to place the button


      `click here to open in a separate
      window <https://threejs.org/manual/examples/tips-screenshot-bad.html>`__

   When I tried it I got this screenshot

   .. image:: https://threejs.org/manual/resources/images/screencapture-413x313.png


   Yes, it's just a black image.

   It's possible it worked for you depending on your browser/OS but in general it's not
   likely to work.

   The issue is that for performance and compatibility reasons, by default the browser
   will clear a WebGL canvas's drawing buffer after you've drawn to it.

   The solution is to call your rendering code just before capturing.

   In our code we need to adjust a few things. First let's separate out the rendering
   code.


   .. code:: javascript

      + const state = {
      +   time: 0,
      + };

      - function render(time) {
      -  time *= 0.001;
      + function render() {
         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

         cubes.forEach((cube, ndx) => {
            const speed = 1 + ndx * .1;
      -     const rot = time * speed;
      +     const rot = state.time * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
         });

         renderer.render(scene, camera);

      -  requestAnimationFrame(render);
      }

      + function animate(time) {
      +   state.time = time * 0.001;
      + 
      +   render();
      + 
      +   requestAnimationFrame(animate);
      + }
      + requestAnimationFrame(animate);


   Now that ``render`` is only concerned with actually rendering we can call it just
   before capturing the canvas.


   .. code:: javascript

      const elem = document.querySelector('#screenshot');
      elem.addEventListener('click', () => {
      +   render();
         canvas.toBlob((blob) => {
            saveBlob(blob, `screencapture-${canvas.width}x${canvas.height}.png`);
         });
      });


   And now it should work.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/tips-screenshot-good.html>`__

   For a different solution see the next item.


.. _F19:

Preventing the canvas being cleared
-----------------------------------

   Let's say you wanted to let the user paint with an animated object. You need to pass
   in ``preserveDrawingBuffer: true`` when you create the ``WebGLRenderer``. This prevents 
   the browser from clearing the canvas. You also need to tell three.js not to clear the
   canvas as well.


   .. code:: javascript

      const canvas = document.querySelector('#c');
      - const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      + const renderer = new THREE.WebGLRenderer({
      +   canvas,
      +   preserveDrawingBuffer: true,
      +   alpha: true,
      + });
      + renderer.autoClearColor = false;


      `click here to open in a separate
      window <https://threejs.org/manual/examples/tips-preservedrawingbuffer.html>`__


   Note that if you were serious about making a drawing program this would not be a
   solution as the browser will still clear the canvas anytime we change its
   resolution. We're changing is resolution based on its display size. Its display size
   changes when the window changes size. That includes when the user downloads a file,
   even in another tab, and the browser adds a status bar. It also includes when the
   user turns their phone and the browser switches from portrait to landscape.

   If you really wanted to make a drawing program you'd `render to a texture using a
   render target <rendertargets>`.


.. _F20:

Getting Keyboard Input
----------------------

   Throughout these tutorials we've often attached event listeners to the ``canvas``.
   While many events work, one that does not work by default is keyboard events.

   To get keyboard events, set the `tabindex <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex>`__
   of the canvas to 0 or more. Eg.


   .. code:: javascript

      <canvas tabindex="0"></canvas>


   This ends up causing a new issue though. Anything that has a ``tabindex`` set will
   get highlighted when it has the focus. To fix that set its focus CSS outline to none


   .. code:: javascript

      canvas:focus {
         outline:none;
      }


   To demonstrate here are 3 canvases


   .. code:: javascript

      <canvas id="c1"></canvas>
      <canvas id="c2" tabindex="0"></canvas>
      <canvas id="c3" tabindex="1"></canvas>


   and some css just for the last canvas


   .. code:: javascript

      #c3:focus {
            outline: none;
      }


   Let's attach the same event listeners to all of them


   .. code:: javascript

      document.querySelectorAll('canvas').forEach((canvas) => {
         const ctx = canvas.getContext('2d');

         function draw(str) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(str, canvas.width / 2, canvas.height / 2);
         }
         draw(canvas.id);

         canvas.addEventListener('focus', () => {
            draw('has focus press a key');
         });

         canvas.addEventListener('blur', () => {
            draw('lost focus');
         });

         canvas.addEventListener('keydown', (e) => {
            draw(`keyCode: ${e.keyCode}`);
         });
      });


   Notice you can't get the first canvas to accept keyboard input. The second canvas
   you can but it gets highlighted. The 3rd canvas has both solutions applied.


      `click here to open in a separate window <https://threejs.org/manual/examples/tips-tabindex.html>`__


.. _F21:

Making the Canvas Transparent
-----------------------------

   By default THREE.js makes the canvas opaque. If you want the canvas to be
   transparent pass in ``alpha:true`` when you create the ``WebGLRenderer``


   .. code:: javascript

      const canvas = document.querySelector('#c');
      - const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      + const renderer = new THREE.WebGLRenderer({
      +   canvas,
      +   alpha: true,
      + });


   You probably also want to tell it that your results are **not** using premultiplied
   alpha


   .. code:: javascript

      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({
         canvas,
         alpha: true,
      +   premultipliedAlpha: false,
      });


   Three.js defaults to the canvas using ``premultipliedAlpha: true``
   but defaults to materials outputting ``premultipliedAlpha: false``.

   If you'd like a better understanding of when and when not to use premultiplied alpha
   here's `a good article on it <https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre>`__.

   In any case let's setup a simple example with a transparent canvas.

   We applied the settings above to the example from `the article on responsiveness <responsive>`. 
   Let's also make the materials more transparent.


   .. code:: javascript

      function makeInstance(geometry, color, x) {
      -  const material = new THREE.MeshPhongMaterial({color});
      +   const material = new THREE.MeshPhongMaterial({
      +     color,
      +     opacity: 0.5,
      +   });

      ...


   And let's add some HTML content


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="content">
      +     <div>
      +       <h1>Cubes-R-Us!</h1>
      +       <p>We make the best cubes!</p>
      +     </div>
      +   </div>
      </body>


   as well as some CSS to put the canvas in front


   .. code:: javascript

      body {
            margin: 0;
      }
      #c {
            width: 100%;
            height: 100%;
            display: block;
      +     position: fixed;
      +     left: 0;
      +     top: 0;
      +     z-index: 2;
      +     pointer-events: none;
      }
      + #content {
      +   font-size: 7vw;
      +   font-family: sans-serif;
      +   text-align: center;
      +   width: 100%;
      +   height: 100%;
      +   display: flex;
      +   justify-content: center;
      +   align-items: center;
      + }


   note that ``pointer-events: none`` makes the canvas invisible to the mouse and touch
   events so you can select the text beneath.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/tips-transparent-canvas.html>`__


.. _F22:

Making your background a three.js animation
-------------------------------------------

   A common question is how to make a three.js animation be the background of a
   webpage.

   There are 2 obvious ways.

   -  Set the canvas CSS ``position`` to ``fixed`` as in


   .. code:: javascript

      #c {
         position: fixed;
         left: 0;
         top: 0;
         ...
      }


   You can basically see this exact solution on the previous example. Just set
   ``z-index`` to -1 and the cubes will appear behind the text.

   A small disadvantage to this solution is your JavaScript must integrate with the
   page and if you have a complex page then you need to make sure none of the
   JavaScript in your three.js visualization conflict with the JavaScript doing other
   things in the page.

   -  Use an ``iframe``

   This is the solution used on `the front page of this site </>`__.

   In your webpage just insert an iframe, for example


   .. code:: javascript

      <iframe id="background" src="responsive.html">
      <div>
         Your content goes here.
      </div>


   Then style the iframe to fill the window and be in the background which is basically
   the same code as we used above for the canvas except we also need to set ``border``
   to ``none`` since iframes have a border by default.


   .. code:: javascript

      #background {
            position: fixed;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            z-index: -1;
            border: none;
            pointer-events: none;
      }


      `click here to open in a separate
      window <https://threejs.org/manual/examples/tips-html-background.html>`__




.. _F23:

Optimizing Lots of Objects
==========================

   -  `Optimizing Lots of Objects <https://threejs.org/manual/en/optimize-lots-of-objects.html>`__


   This article is part of a series of articles about three.js. The first article is
   `three.js fundamentals <fundamentals>`. If you haven't read that yet and
   you're new to three.js you might want to consider starting there.

   There are many ways to optimize things for three.js. One way is often referred to as
   *merging geometry*. Every ``Mesh`` you create and
   three.js represents 1 or more requests by the system to draw something. Drawing 2
   things has more overhead than drawing 1 even if the results are the same so one way
   to optimize is to merge meshes.

   Let's show an example of when this is a good solution for an issue. Let's re-create
   the `WebGL Globe <https://globe.chromeexperiments.com/>`__.

   The first thing we need to do is get some data. The WebGL Globe said the data they
   use comes from `SEDAC <http://sedac.ciesin.columbia.edu/gpw/>`__. Checking out the
   site I saw there was `demographic data in a grid
   format <https://beta.sedac.ciesin.columbia.edu/data/set/gpw-v4-basic-demographic-characteristics-rev10>`__.
   I downloaded the data at 60 minute resolution. Then I took a look at the data

   It looks like this


   .. code:: javascript

         ncols         360
         nrows         145
         xllcorner     -180
         yllcorner     -60
         cellsize      0.99999999999994
         NODATA_value  -9999
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...
         9.241768 8.790958 2.095345 -9999 0.05114867 -9999 -9999 -9999 -9999 -999...
         1.287993 0.4395509 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999...
         -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 -9999 ...


   There's a few lines that are like key/value pairs followed by lines with a value per
   grid point, one line for each row of data points.

   To make sure we understand the data let's try to plot it in 2D.

   First some code to load the text file


   .. code:: javascript

      async function loadFile(url) {
         const res = await fetch(url);
         return res.text();
      }


   The code above returns a ``Promise`` with the contents of the file at ``url``;

   Then we need some code to parse the file


   .. code:: javascript

      function parseData(text) {
         const data = [];
         const settings = {data};
         let max;
         let min;
         // split into lines
         text.split('\n').forEach((line) => {
            // split the line by whitespace
            const parts = line.trim().split(/\s+/);
            if (parts.length === 2) {
            // only 2 parts, must be a key/value pair
            settings[parts[0]] = parseFloat(parts[1]);
            } else if (parts.length > 2) {
            // more than 2 parts, must be data
            const values = parts.map((v) => {
               const value = parseFloat(v);
               if (value === settings.NODATA_value) {
                  return undefined;
               }
               max = Math.max(max === undefined ? value : max, value);
               min = Math.min(min === undefined ? value : min, value);
               return value;
            });
            data.push(values);
            }
         });
         return Object.assign(settings, {min, max});
      }


   The code above returns an object with all the key/value pairs from the file as well
   as a ``data`` property with all the data in one large array and the ``min`` and
   ``max`` values found in the data.

   Then we need some code to draw that data


   .. code:: javascript

      function drawData(file) {
         const {min, max, data} = file;
         const range = max - min;
         const ctx = document.querySelector('canvas').getContext('2d');
         // make the canvas the same size as the data
         ctx.canvas.width = ncols;
         ctx.canvas.height = nrows;
         // but display it double size so it's not too small
         ctx.canvas.style.width = px(ncols * 2);
         ctx.canvas.style.height = px(nrows * 2);
         // fill the canvas to dark gray
         ctx.fillStyle = '#444';
         ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
         // draw each data point
         data.forEach((row, latNdx) => {
            row.forEach((value, lonNdx) => {
            if (value === undefined) {
               return;
            }
            const amount = (value - min) / range;
            const hue = 1;
            const saturation = 1;
            const lightness = amount;
            ctx.fillStyle = hsl(hue, saturation, lightness);
            ctx.fillRect(lonNdx, latNdx, 1, 1);
            });
         });
      }

      function px(v) {
         return `${v | 0}px`;
      }

      function hsl(h, s, l) {
         return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`;
      }


   And finally gluing it all together


   .. code:: javascript

      loadFile('resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc')
         .then(parseData)
         .then(drawData);


   Gives us this result


      `click here to open in a separate
      window <https://threejs.org/manual/examples/gpw-data-viewer.html>`__

   So that seems to work.

   Let's try it in 3D. Starting with the code from `rendering on
   demand <rendering-on-demand>` We'll make one box per data in the file.

   First let's make a simple sphere with a texture of the world. Here's the texture

   .. container:: threejs_center

      |image1|

   And the code to set it up.


   .. code:: javascript

      {
         const loader = new THREE.TextureLoader();
         const texture = loader.load('resources/images/world.jpg', render);
         const geometry = new THREE.SphereGeometry(1, 64, 32);
         const material = new THREE.MeshBasicMaterial({map: texture});
         scene.add(new THREE.Mesh(geometry, material));
      }


   Notice the call to ``render`` when the texture has finished loading. We need this
   because we're `rendering on demand <rendering-on-demand>` instead of
   continuously so we need to render once when the texture is loaded.

   Then we need to change the code that drew a dot per data point above to instead make
   a box per data point.


   .. code:: javascript

      function addBoxes(file) {
         const {min, max, data} = file;
         const range = max - min;

         // make one box geometry
         const boxWidth = 1;
         const boxHeight = 1;
         const boxDepth = 1;
         const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
         // make it so it scales away from the positive Z axis
         geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 0.5));

         // these helpers will make it easy to position the boxes
         // We can rotate the lon helper on its Y axis to the longitude
         const lonHelper = new THREE.Object3D();
         scene.add(lonHelper);
         // We rotate the latHelper on its X axis to the latitude
         const latHelper = new THREE.Object3D();
         lonHelper.add(latHelper);
         // The position helper moves the object to the edge of the sphere
         const positionHelper = new THREE.Object3D();
         positionHelper.position.z = 1;
         latHelper.add(positionHelper);

         const lonFudge = Math.PI * .5;
         const latFudge = Math.PI * -0.135;
         data.forEach((row, latNdx) => {
            row.forEach((value, lonNdx) => {
            if (value === undefined) {
               return;
            }
            const amount = (value - min) / range;
            const material = new THREE.MeshBasicMaterial();
            const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
            const saturation = 1;
            const lightness = THREE.MathUtils.lerp(0.1, 1.0, amount);
            material.color.setHSL(hue, saturation, lightness);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // adjust the helpers to point to the latitude and longitude
            lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge;
            latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge;

            // use the world matrix of the position helper to
            // position this mesh.
            positionHelper.updateWorldMatrix(true, false);
            mesh.applyMatrix4(positionHelper.matrixWorld);

            mesh.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));
            });
         });
      }


   The code is mostly straight forward from our test drawing code.

   We make one box and adjust its center so it scales away from positive Z. If we
   didn't do this it would scale from the center but we want them to grow away from the
   origin.

   .. container:: spread

      .. container::

         .. container::

         .. container:: code

            default

      .. container::

         .. container::

         .. container:: code

            adjusted

   Of course we could also solve that by parenting the box to more
   ``THREE.Object3D`` objects like we covered in
   `scene graphs <scenegraph>` but the more nodes we add to a scene graph the
   slower it gets.

   We also setup this small hierarchy of nodes of ``lonHelper``, ``latHelper``, and
   ``positionHelper``. We use these objects to compute a position around the sphere
   were to place the box.

   .. container:: spread

      .. container::

   Above the green bar represents ``lonHelper`` and is used to rotate toward longitude
   on the equator. The blue bar represents ``latHelper`` which is used to rotate to a
   latitude above or below the equator. The red sphere represents the offset that that
   ``positionHelper`` provides.

   We could do all of the math manually to figure out positions on the globe but doing
   it this way leaves most of the math to the library itself so we don't need to deal
   with.

   For each data point we create a
   ``MeshBasicMaterial`` and a
   ``Mesh`` and then we ask for the world matrix of
   the ``positionHelper`` and apply that to the new
   ``Mesh``. Finally we scale the mesh at its new
   position.

   Like above, we could also have created a ``latHelper``, ``lonHelper``, and
   ``positionHelper`` for every new box but that would be even slower.

   There are up to 360x145 boxes we're going to create. That's up to 52000 boxes.
   Because some data points are marked as "NO_DATA" the actual number of boxes we're
   going to create is around 19000. If we added 3 extra helper objects per box that
   would be nearly 80000 scene graph nodes that THREE.js would have to compute
   positions for. By instead using one set of helpers to just position the meshes we
   save around 60000 operations.

   A note about ``lonFudge`` and ``latFudge``. ``lonFudge`` is π/2 which is a quarter
   of a turn. That makes sense. It just means the texture or texture coordinates start
   at a different offset around the globe. ``latFudge`` on the other hand I have no
   idea why it needs to be π \* -0.135, that's just an amount that made the boxes line
   up with the texture.

   The last thing we need to do is call our loader


   .. code:: javascript

      loadFile('resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc')
         .then(parseData)
      -   .then(drawData)
      +   .then(addBoxes)
      +   .then(render);


   Once the data has finished loading and parsing then we need to render at least once
   since we're `rendering on demand <rendering-on-demand>`.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lots-of-objects-slow.html>`__

   If you try to rotate the example above by dragging on the sample you'll likely
   notice it's slow.

   We can check the framerate by `opening the devtools <debugging-javascript>`
   and turning on the browser's frame rate meter.

   .. container:: threejs_center

      |image2|

   On my machine I see a framerate under 20fps.

   .. container:: threejs_center

      |image3|

   That doesn't feel very good to me and I suspect many people have slower machines
   which would make it even worse. We'd better look into optimizing.

   For this particular problem we can merge all the boxes into a single geometry. We're
   currently drawing around 19000 boxes. By merging them into a single geometry we'd
   remove 18999 operations.

   Here's the new code to merge the boxes into a single geometry.


   .. code:: javascript

      function addBoxes(file) {
         const {min, max, data} = file;
         const range = max - min;

      -   // make one box geometry
      -  const boxWidth = 1;
      -  const boxHeight = 1;
      -  const boxDepth = 1;
      -  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      -   // make it so it scales away from the positive Z axis
      -  geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 0.5));

         // these helpers will make it easy to position the boxes
         // We can rotate the lon helper on its Y axis to the longitude
         const lonHelper = new THREE.Object3D();
         scene.add(lonHelper);
         // We rotate the latHelper on its X axis to the latitude
         const latHelper = new THREE.Object3D();
         lonHelper.add(latHelper);
         // The position helper moves the object to the edge of the sphere
         const positionHelper = new THREE.Object3D();
         positionHelper.position.z = 1;
         latHelper.add(positionHelper);
      +   // Used to move the center of the box so it scales from the position Z axis
      +   const originHelper = new THREE.Object3D();
      +   originHelper.position.z = 0.5;
      +   positionHelper.add(originHelper);

         const lonFudge = Math.PI * .5;
         const latFudge = Math.PI * -0.135;
      +   const geometries = [];
         data.forEach((row, latNdx) => {
            row.forEach((value, lonNdx) => {
            if (value === undefined) {
               return;
            }
            const amount = (value - min) / range;

      -       const material = new THREE.MeshBasicMaterial();
      -       const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
      -       const saturation = 1;
      -       const lightness = THREE.MathUtils.lerp(0.1, 1.0, amount);
      -       material.color.setHSL(hue, saturation, lightness);
      -       const mesh = new THREE.Mesh(geometry, material);
      -       scene.add(mesh);

      +       const boxWidth = 1;
      +       const boxHeight = 1;
      +       const boxDepth = 1;
      +       const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

            // adjust the helpers to point to the latitude and longitude
            lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge;
            latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge;

      -       // use the world matrix of the position helper to
      -       // position this mesh.
      -       positionHelper.updateWorldMatrix(true, false);
      -       mesh.applyMatrix4(positionHelper.matrixWorld);
      - 
      -       mesh.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));

      +       // use the world matrix of the origin helper to
      +       // position this geometry
      +       positionHelper.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));
      +       originHelper.updateWorldMatrix(true, false);
      +       geometry.applyMatrix4(originHelper.matrixWorld);
      + 
      +       geometries.push(geometry);
            });
         });

      +   const mergedGeometry = BufferGeometryUtils.mergeGeometries(
      +       geometries, false);
      +   const material = new THREE.MeshBasicMaterial({color:'red'});
      +   const mesh = new THREE.Mesh(mergedGeometry, material);
      +   scene.add(mesh);

      }


   Above we removed the code that was changing the box geometry's center point and are
   instead doing it by adding an ``originHelper``. Before we were using the same
   geometry 19000 times. This time we are creating new geometry for every single box
   and since we are going to use ``applyMatrix`` to move the vertices of each box
   geometry we might as well do it once instead of twice.

   At the end we pass an array of all the geometries to
   ``BufferGeometryUtils.mergeGeometries`` which will combined all of them into a
   single mesh.

   We also need to include the ``BufferGeometryUtils``


   .. code:: javascript

      import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';


   And now, at least on my machine, I get 60 frames per second


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lots-of-objects-merged.html>`__

   So that worked but because it's one mesh we only get one material which means we
   only get one color where as before we had a different color on each box. We can fix
   that by using vertex colors.

   Vertex colors add a color per vertex. By setting all the colors of each vertex of
   each box to specific colors every box will have a different color.


   .. code:: javascript

      + const color = new THREE.Color();

      const lonFudge = Math.PI * .5;
      const latFudge = Math.PI * -0.135;
      const geometries = [];
      data.forEach((row, latNdx) => {
         row.forEach((value, lonNdx) => {
            if (value === undefined) {
            return;
            }
            const amount = (value - min) / range;

            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

            // adjust the helpers to point to the latitude and longitude
            lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge;
            latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge;

            // use the world matrix of the origin helper to
            // position this geometry
            positionHelper.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));
            originHelper.updateWorldMatrix(true, false);
            geometry.applyMatrix4(originHelper.matrixWorld);

      +     // compute a color
      +     const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
      +     const saturation = 1;
      +     const lightness = THREE.MathUtils.lerp(0.4, 1.0, amount);
      +     color.setHSL(hue, saturation, lightness);
      +     // get the colors as an array of values from 0 to 255
      +     const rgb = color.toArray().map(v => v * 255);
      + 
      +     // make an array to store colors for each vertex
      +     const numVerts = geometry.getAttribute('position').count;
      +     const itemSize = 3;  // r, g, b
      +     const colors = new Uint8Array(itemSize * numVerts);
      + 
      +     // copy the color into the colors array for each vertex
      +     colors.forEach((v, ndx) => {
      +       colors[ndx] = rgb[ndx % 3];
      +     });
      + 
      +     const normalized = true;
      +     const colorAttrib = new THREE.BufferAttribute(colors, itemSize, normalized);
      +     geometry.setAttribute('color', colorAttrib);

            geometries.push(geometry);
         });
      });


   The code above looks up the number or vertices needed by getting the ``position``
   attribute from the geometry. We then create a ``Uint8Array`` to put the colors in.
   It then adds that as an attribute by calling ``geometry.setAttribute``.

   Lastly we need to tell three.js to use the vertex colors.


   .. code:: javascript

      const mergedGeometry = BufferGeometryUtils.mergeGeometries(
            geometries, false);
      - const material = new THREE.MeshBasicMaterial({color:'red'});
      + const material = new THREE.MeshBasicMaterial({
      +   vertexColors: true,
      + });
      const mesh = new THREE.Mesh(mergedGeometry, material);
      scene.add(mesh);


   And with that we get our colors back


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lots-of-objects-merged-vertexcolors.html>`__

   Merging geometry is a common optimization technique. For example rather than 100
   trees you might merge the trees into 1 geometry, a pile of individual rocks into a
   single geometry of rocks, a picket fence from individual pickets into one fence
   mesh. Another example in Minecraft it doesn't likely draw each cube individually but
   rather creates groups of merged cubes and also selectively removing faces that are
   never visible.

   The problem with making everything one mesh though is it's no longer easy to move
   any part that was previously separate. Depending on our use case though there are
   creative solutions. We'll explore one in `another
   article <optimize-lots-of-objects-animated>`.

.. |image1| image:: https://threejs.org/manual/examples/resources/images/world.jpg
.. |image2| image:: https://threejs.org/manual/resources/images/bring-up-fps-meter.gif
.. |image3| image:: https://threejs.org/manual/resources/images/fps-meter.gif


.. _F24:

Optimizing Lots of Objects Animated
===================================

   -  `Optimizing Lots of Objects Animated <https://threejs.org/manual/en/optimize-lots-of-objects-animated.html>`__


   This article is a continuation of `an article about optimizing lots of
   objects <optimize-lots-of-objects>` . If you haven't read that yet please
   read it before proceeding.

   In the previous article we merged around 19000 cubes into a single geometry. This
   had the advantage that it optimized our drawing of 19000 cubes but it had the
   disadvantage of make it harder to move any individual cube.

   Depending on what we are trying to accomplish there are different solutions. In this
   case let's graph multiple sets of data and animate between the sets.

   The first thing we need to do is get multiple sets of data. Ideally we'd probably
   pre-process data offline but in this case let's load 2 sets of data and generate 2
   more

   Here's our old loading code


   .. code:: javascript

      loadFile('resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc')
         .then(parseData)
         .then(addBoxes)
         .then(render);


   Let's change it to something like this


   .. code:: javascript

      async function loadData(info) {
         const text = await loadFile(info.url);
         info.file = parseData(text);
      }

      async function loadAll() {
         const fileInfos = [
            {name: 'men',   hueRange: [0.7, 0.3], url: 'resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc' },
            {name: 'women', hueRange: [0.9, 1.1], url: 'resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014ft_2010_cntm_1_deg.asc' },
         ];

         await Promise.all(fileInfos.map(loadData));

         ...
      }
      loadAll();


   The code above will load all the files in ``fileInfos`` and when done each object in
   ``fileInfos`` will have a ``file`` property with the loaded file. ``name`` and
   ``hueRange`` we'll use later. ``name`` will be for a UI field. ``hueRange`` will be
   used to choose a range of hues to map over.

   The two files above are apparently the number of men per area and the number of
   women per area as of 2010. Note, I have no idea if this data is correct but it's not
   important really. The important part is showing different sets of data.

   Let's generate 2 more sets of data. One being the places where the number men are
   greater than the number of women and visa versa, the places where the number of
   women are greater than the number of men.

   The first thing let's write a function that given a 2 dimensional array of arrays
   like we had before will map over it to generate a new 2 dimensional array of arrays


   .. code:: javascript

      function mapValues(data, fn) {
         return data.map((row, rowNdx) => {
            return row.map((value, colNdx) => {
            return fn(value, rowNdx, colNdx);
            });
         });
      }


   Like the normal ``Array.map`` function the ``mapValues`` function calls a function
   ``fn`` for each value in the array of arrays. It passes it the value and both the
   row and column indices.

   Now let's make some code to generate a new file that is a comparison between 2 files


   .. code:: javascript

      function makeDiffFile(baseFile, otherFile, compareFn) {
         let min;
         let max;
         const baseData = baseFile.data;
         const otherData = otherFile.data;
         const data = mapValues(baseData, (base, rowNdx, colNdx) => {
            const other = otherData[rowNdx][colNdx];
            if (base === undefined || other === undefined) {
               return undefined;
            }
            const value = compareFn(base, other);
            min = Math.min(min === undefined ? value : min, value);
            max = Math.max(max === undefined ? value : max, value);
            return value;
         });
         // make a copy of baseFile and replace min, max, and data
         // with the new data
         return {...baseFile, min, max, data};
      }


   The code above uses ``mapValues`` to generate a new set of data that is a comparison
   based on the ``compareFn`` function passed in. It also tracks the ``min`` and
   ``max`` comparison results. Finally it makes a new file with all the same properties
   as ``baseFile`` except with a new ``min``, ``max`` and ``data``.

   Then let's use that to make 2 new sets of data


   .. code:: javascript

      {
         const menInfo = fileInfos[0];
         const womenInfo = fileInfos[1];
         const menFile = menInfo.file;
         const womenFile = womenInfo.file;

         function amountGreaterThan(a, b) {
            return Math.max(a - b, 0);
         }
         fileInfos.push({
            name: '>50%men',
            hueRange: [0.6, 1.1],
            file: makeDiffFile(menFile, womenFile, (men, women) => {
            return amountGreaterThan(men, women);
            }),
         });
         fileInfos.push({
            name: '>50% women',
            hueRange: [0.0, 0.4],
            file: makeDiffFile(womenFile, menFile, (women, men) => {
            return amountGreaterThan(women, men);
            }),
         });
      }


   Now let's generate a UI to select between these sets of data. First we need some UI
   html


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="ui"></div>
      </body>


   and some CSS to make it appear in the top left area


   .. code:: javascript

      #ui {
         position: absolute;
         left: 1em;
         top: 1em;
      }
      #ui>div {
         font-size: 20pt;
         padding: 1em;
         display: inline-block;
      }
      #ui>div.selected {
         color: red;
      }


   Then we can go over each file and generate a set of merged boxes per set of data and
   an element which when hovered over will show that set and hide all others.


   .. code:: javascript

      // show the selected data, hide the rest
      function showFileInfo(fileInfos, fileInfo) {
         fileInfos.forEach((info) => {
            const visible = fileInfo === info;
            info.root.visible = visible;
            info.elem.className = visible ? 'selected' : '';
         });
         requestRenderIfNotRequested();
      }

      const uiElem = document.querySelector('#ui');
      fileInfos.forEach((info) => {
         const boxes = addBoxes(info.file, info.hueRange);
         info.root = boxes;
         const div = document.createElement('div');
         info.elem = div;
         div.textContent = info.name;
         uiElem.appendChild(div);
         div.addEventListener('mouseover', () => {
            showFileInfo(fileInfos, info);
         });
      });
      // show the first set of data
      showFileInfo(fileInfos, fileInfos[0]);


   The one more change we need from the previous example is we need to make
   ``addBoxes`` take a ``hueRange``


   .. code:: javascript

      - function addBoxes(file) {
      + function addBoxes(file, hueRange) {

         ...

            // compute a color
      -     const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
      +     const hue = THREE.MathUtils.lerp(...hueRange, amount);

         ...


   and with that we should be able to show 4 sets of data. Hover the mouse over the
   labels or touch them to switch sets


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lots-of-objects-multiple-data-sets.html>`__

   Note, there are a few strange data points that really stick out. I wonder what's up
   with those!??! In any case how do we animate between these 4 sets of data.

   Lots of ideas.

   -  Just fade between them using
      ``Material.opacity``

      The problem with this solution is the cubes perfectly overlap which means there
      will be z-fighting issues. It's possible we could fix that by changing the depth
      function and using blending. We should probably look into it.

   -  Scale up the set we want to see and scale down the other sets

      Because all the boxes have their origin at the center of the planet if we scale
      them below 1.0 they will sink into the planet. At first that sounds like a good
      idea but the issue is all the low height boxes will disappear almost immediately
      and not be replaced until the new data set scales up to 1.0. This makes the
      transition not very pleasant. We could maybe fix that with a fancy custom shader.

   -  Use Morphtargets

      Morphtargets are a way were we supply multiple values for each vertex in the
      geometry and *morph* or lerp (linear interpolate) between them. Morphtargets are
      most commonly used for facial animation of 3D characters but that's not their
      only use.

   Let's try morphtargets.

   We'll still make a geometry for each set of data but we'll then extract the
   ``position`` attribute from each one and use them as morphtargets.

   First let's change ``addBoxes`` to just make and return the merged geometry.


   .. code:: javascript

      - function addBoxes(file, hueRange) {
      + function makeBoxes(file, hueRange) {
         const {min, max, data} = file;
         const range = max - min;

         ...

      -  const mergedGeometry = BufferGeometryUtils.mergeGeometries(
      -       geometries, false);
      -  const material = new THREE.MeshBasicMaterial({
      -     vertexColors: true,
      -   });
      -  const mesh = new THREE.Mesh(mergedGeometry, material);
      -  scene.add(mesh);
      -  return mesh;
      +   return BufferGeometryUtils.mergeGeometries(
      +      geometries, false);
      }


   There's one more thing we need to do here though. Morphtargets are required to all
   have exactly the same number of vertices. Vertex #123 in one target needs have a
   corresponding Vertex #123 in all other targets. But, as it is now different data
   sets might have some data points with no data so no box will be generated for that
   point which would mean no corresponding vertices for another set. So, we need to
   check across all data sets and either always generate something if there is data in
   any set or, generate nothing if there is data missing in any set. Let's do the
   latter.


   .. code:: javascript

      + function dataMissingInAnySet(fileInfos, latNdx, lonNdx) {
      +   for (const fileInfo of fileInfos) {
      +     if (fileInfo.file.data[latNdx][lonNdx] === undefined) {
      +       return true;
      +     }
      +   }
      +   return false;
      + }

      - function makeBoxes(file, hueRange) {
      + function makeBoxes(file, hueRange, fileInfos) {
         const {min, max, data} = file;
         const range = max - min;

         ...

         const geometries = [];
         data.forEach((row, latNdx) => {
            row.forEach((value, lonNdx) => {
      +       if (dataMissingInAnySet(fileInfos, latNdx, lonNdx)) {
      +         return;
      +       }
            const amount = (value - min) / range;

         ...


   Now we'll change the code that was calling ``addBoxes`` to use ``makeBoxes`` and
   setup morphtargets


   .. code:: javascript

      + // make geometry for each data set
      + const geometries = fileInfos.map((info) => {
      +   return makeBoxes(info.file, info.hueRange, fileInfos);
      + });
      + 
      + // use the first geometry as the base
      + // and add all the geometries as morphtargets
      + const baseGeometry = geometries[0];
      + baseGeometry.morphAttributes.position = geometries.map((geometry, ndx) => {
      +   const attribute = geometry.getAttribute('position');
      +   const name = `target${ndx}`;
      +   attribute.name = name;
      +   return attribute;
      + });
      + baseGeometry.morphAttributes.color = geometries.map((geometry, ndx) => {
      +   const attribute = geometry.getAttribute('color');
      +   const name = `target${ndx}`;
      +   attribute.name = name;
      +   return attribute;
      + });
      + const material = new THREE.MeshBasicMaterial({
      +   vertexColors: true,
      + });
      + const mesh = new THREE.Mesh(baseGeometry, material);
      + scene.add(mesh);

      const uiElem = document.querySelector('#ui');
      fileInfos.forEach((info) => {
      -  const boxes = addBoxes(info.file, info.hueRange);
      -  info.root = boxes;
         const div = document.createElement('div');
         info.elem = div;
         div.textContent = info.name;
         uiElem.appendChild(div);
         function show() {
            showFileInfo(fileInfos, info);
         }
         div.addEventListener('mouseover', show);
         div.addEventListener('touchstart', show);
      });
      // show the first set of data
      showFileInfo(fileInfos, fileInfos[0]);


   Above we make geometry for each data set, use the first one as the base, then get a
   ``position`` attribute from each geometry and add it as a morphtarget to the base
   geometry for ``position``.

   Now we need to change how we're showing and hiding the various data sets. Instead of
   showing or hiding a mesh we need to change the influence of the morphtargets. For
   the data set we want to see we need to have an influence of 1 and for all the ones
   we don't want to see to we need to have an influence of 0.

   We could just set them to 0 or 1 directly but if we did that we wouldn't see any
   animation, it would just snap which would be no different than what we already have.
   We could also write some custom animation code which would be easy but because the
   original webgl globe uses `an animation
   library <https://github.com/tweenjs/tween.js/>`__ let's use the same one here.

   We need to include the library


   .. code:: javascript

      import * as THREE from 'three';
      import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      + import TWEEN from 'three/addons/libs/tween.module.js';


   And then create a ``Tween`` to animate the influences.


   .. code:: javascript

      // show the selected data, hide the rest
      function showFileInfo(fileInfos, fileInfo) {
      +   const targets = {};
      -  fileInfos.forEach((info) => {
      +   fileInfos.forEach((info, i) => {
            const visible = fileInfo === info;
      -     info.root.visible = visible;
            info.elem.className = visible ? 'selected' : '';
      +     targets[i] = visible ? 1 : 0;
         });
      +   const durationInMs = 1000;
      +   new TWEEN.Tween(mesh.morphTargetInfluences)
      +     .to(targets, durationInMs)
      +     .start();
         requestRenderIfNotRequested();
      }


   We're also suppose to call ``TWEEN.update`` every frame inside our render loop but
   that points out a problem. "tween.js" is designed for continuous rendering but we
   are `rendering on demand <rendering-on-demand>`. We could switch to
   continuous rendering but it's sometimes nice to only render on demand as it well
   stop using the user's power when nothing is happening so let's see if we can make it
   animate on demand.

   We'll make a ``TweenManager`` to help. We'll use it to create the ``Tween``\ s and
   track them. It will have an ``update`` method that will return ``true`` if we need
   to call it again and ``false`` if all the animations are finished.


   .. code:: javascript

      class TweenManger {
         constructor() {
            this.numTweensRunning = 0;
         }
         _handleComplete() {
            --this.numTweensRunning;
            console.assert(this.numTweensRunning >= 0);
         }
         createTween(targetObject) {
            const self = this;
            ++this.numTweensRunning;
            let userCompleteFn = () => {};
            // create a new tween and install our own onComplete callback
            const tween = new TWEEN.Tween(targetObject).onComplete(function(...args) {
            self._handleComplete();
            userCompleteFn.call(this, ...args);
            });
            // replace the tween's onComplete function with our own
            // so we can call the user's callback if they supply one.
            tween.onComplete = (fn) => {
            userCompleteFn = fn;
            return tween;
            };
            return tween;
         }
         update() {
            TWEEN.update();
            return this.numTweensRunning > 0;
         }
      }


   To use it we'll create one


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      +   const tweenManager = new TweenManger();

         ...


   We'll use it to create our ``Tween``\ s.


   .. code:: javascript

      // show the selected data, hide the rest
      function showFileInfo(fileInfos, fileInfo) {
         const targets = {};
         fileInfos.forEach((info, i) => {
            const visible = fileInfo === info;
            info.elem.className = visible ? 'selected' : '';
            targets[i] = visible ? 1 : 0;
         });
         const durationInMs = 1000;
      -  new TWEEN.Tween(mesh.morphTargetInfluences)
      +   tweenManager.createTween(mesh.morphTargetInfluences)
            .to(targets, durationInMs)
            .start();
         requestRenderIfNotRequested();
      }


   Then we'll update our render loop to update the tweens and keep rendering if there
   are still animations running.


   .. code:: javascript

      function render() {
         renderRequested = false;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

      +   if (tweenManager.update()) {
      +     requestRenderIfNotRequested();
      +   }

         controls.update();
         renderer.render(scene, camera);
      }
      render();


   And with that we should be animating between data sets.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/lots-of-objects-morphtargets.html>`__

   I hope going through this was helpful. Using morphtargets is a common technique to
   move lots of objects. As an example we could give every cube a random place in
   another target and morph from that to their first positions on the globe. That might
   be a cool way to introduce the globe.

   Next you might be interested in adding labels to a globe which is covered in
   `Aligning HTML Elements to 3D <align-html-elements-to-3d>`.

   Note: We could try to just graph percent of men or percent of women or the raw
   difference but based on how we are displaying the info, cubes that grow from the
   surface of the earth, we'd prefer most cubes to be low. If we used one of these
   other comparisons most cubes would be about 1/2 their maximum height which would not
   make a good visualization. Feel free to change the ``amountGreaterThan`` from
   ``Math.max(a - b, 0)`` to
   something like ``(a - b)`` "raw difference" or ``a / (a + b)`` "percent" and you'll
   see what I mean.


.. _F25:

Using OffscreenCanvas in a Web Worker
=====================================

   -  `Using OffscreenCanvas in a Web Worker <https://threejs.org/manual/en/offscreencanvas.html>`__


   `OffscreenCanvas <https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas>`__
   is a relatively new browser feature currently only available in Chrome but
   apparently coming to other browsers. ``OffscreenCanvas`` allows a web worker to
   render to a canvas. This is a way to offload heavy work, like rendering a complex 3D
   scene, to a web worker so as not to slow down the responsiveness of the browser. It
   also means data is loaded and parsed in the worker so possibly less jank while the
   page loads.

   Getting *started* using it is pretty straight forward. Let's port the 3 spinning
   cube example from `the article on responsiveness <responsive>`.

   Workers generally have their code separated into another script file whereas most of
   the examples on this site have had their scripts embedded into the HTML file of the
   page they are on.

   In our case we'll make a file called ``offscreencanvas-cubes.js`` and copy all the
   JavaScript from `the responsive example <responsive>` into it. We'll then
   make the changes needed for it to run in a worker.

   We still need some JavaScript in our HTML file. The first thing we need to do there
   is look up the canvas and then transfer control of that canvas to be offscreen by
   calling ``canvas.transferControlToOffscreen``.


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const offscreen = canvas.transferControlToOffscreen();

         ...


   We can then start our worker with ``new Worker(pathToScript, {type: 'module'})``.
   and pass the ``offscreen`` object to it.


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const offscreen = canvas.transferControlToOffscreen();
         const worker = new Worker('offscreencanvas-cubes.js', {type: 'module'});
         worker.postMessage({type: 'main', canvas: offscreen}, [offscreen]);
      }
      main();


   It's important to note that workers can't access the ``DOM``. They can't look at
   HTML elements nor can they receive mouse events or keyboard events. The only thing
   they can generally do is respond to messages sent to them and send messages back to
   the page.

   To send a message to a worker we call
   `worker.postMessage <https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage>`__
   and pass it 1 or 2 arguments. The first argument is a JavaScript object that will be
   `cloned <https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm>`__
   and sent to the worker. The second argument is an optional array of objects that are
   part of the first object that we want *transferred* to the worker. These objects
   will not be cloned. Instead they will be *transferred* and will cease to exist in
   the main page. Cease to exist is the probably the wrong description, rather they are
   neutered. Only certain types of objects can be transferred instead of cloned. They
   include ``OffscreenCanvas`` so once transferred the ``offscreen`` object back in the
   main page is useless.

   Workers receive messages from their ``onmessage`` handler. The object we passed to
   ``postMessage`` arrives on ``event.data`` passed to the ``onmessage`` handler on the
   worker. The code above declares a ``type: 'main'`` in the object it passes to the
   worker. This object has no meaning to the browser. It's entirely for our own usage.
   We'll make a handler that based on ``type`` calls a different function in the
   worker. Then we can add functions as needed and easily call them from the main page.


   .. code:: javascript

      const handlers = {
         main,
      };

      self.onmessage = function(e) {
         const fn = handlers[e.data.type];
         if (typeof fn !== 'function') {
            throw new Error('no handler for type: ' + e.data.type);
         }
         fn(e.data);
      };


   You can see above we just look up the handler based on the ``type`` pass it the
   ``data`` that was sent from the main page.

   So now we just need to start changing the ``main`` we pasted into
   ``offscreencanvas-cubes.js`` from `the responsive article <responsive>`.

   Instead of looking up the canvas from the DOM we'll receive it from the event data.


   .. code:: javascript

      - function main() {
      -  const canvas = document.querySelector('#c');
      + function main(data) {
      +   const {canvas} = data;
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});

         ...


   Remembering that workers can't see the DOM at all the first problem we run into is
   ``resizeRendererToDisplaySize`` can't look at ``canvas.clientWidth`` and
   ``canvas.clientHeight`` as those are DOM values. Here's the original code


   .. code:: javascript

      function resizeRendererToDisplaySize(renderer) {
         const canvas = renderer.domElement;
         const width = canvas.clientWidth;
         const height = canvas.clientHeight;
         const needResize = canvas.width !== width || canvas.height !== height;
         if (needResize) {
            renderer.setSize(width, height, false);
         }
         return needResize;
      }


   Instead we'll need to send sizes as they change to the worker. So, let's add some
   global state and keep the width and height there.


   .. code:: javascript

      const state = {
         width: 300,  // canvas default
         height: 150,  // canvas default
      };


   Then let's add a ``'size'`` handler to update those values.


   .. code:: javascript

      + function size(data) {
      +   state.width = data.width;
      +   state.height = data.height;
      + }

      const handlers = {
         main,
      +   size,
      };


   Now we can change ``resizeRendererToDisplaySize`` to use ``state.width`` and
   ``state.height``


   .. code:: javascript

      function resizeRendererToDisplaySize(renderer) {
         const canvas = renderer.domElement;
      -  const width = canvas.clientWidth;
      -  const height = canvas.clientHeight;
      +   const width = state.width;
      +   const height = state.height;
         const needResize = canvas.width !== width || canvas.height !== height;
         if (needResize) {
            renderer.setSize(width, height, false);
         }
         return needResize;
      }


   and where we compute the aspect we need similar changes


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         if (resizeRendererToDisplaySize(renderer)) {
      -     camera.aspect = canvas.clientWidth / canvas.clientHeight;
      +     camera.aspect = state.width / state.height;
            camera.updateProjectionMatrix();
         }

         ...


   Back in the main page we'll send a ``size`` event anytime the page changes size.


   .. code:: javascript

      const worker = new Worker('offscreencanvas-picking.js', {type: 'module'});
      worker.postMessage({type: 'main', canvas: offscreen}, [offscreen]);

      + function sendSize() {
      +   worker.postMessage({
      +     type: 'size',
      +     width: canvas.clientWidth,
      +     height: canvas.clientHeight,
      +   });
      + }
      + 
      + window.addEventListener('resize', sendSize);
      + sendSize();


   We also call it once to send the initial size.

   And with just those few changes, assuming your browser fully supports
   ``OffscreenCanvas`` it should work. Before we run it though let's check if the
   browser actually supports ``OffscreenCanvas`` and if not display an error. First
   let's add some HTML to display the error.


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="noOffscreenCanvas" style="display:none;">
      +     <div>no OffscreenCanvas support</div>
      +   </div>
      </body>


   and some CSS for that


   .. code:: javascript

      #noOffscreenCanvas {
            display: flex;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
            background: red;
            color: white;
      }


   and then we can check for the existence of ``transferControlToOffscreen`` to see if
   the browser supports ``OffscreenCanvas``


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
      +   if (!canvas.transferControlToOffscreen) {
      +     canvas.style.display = 'none';
      +     document.querySelector('#noOffscreenCanvas').style.display = '';
      +     return;
      +   }
         const offscreen = canvas.transferControlToOffscreen();
         const worker = new Worker('offscreencanvas-picking.js', {type: 'module});
         worker.postMessage({type: 'main', canvas: offscreen}, [offscreen]);

         ...


   and with that, if your browser supports ``OffscreenCanvas`` this example should work


      `click here to open in a separate
      window <https://threejs.org/manual/examples/offscreencanvas.html>`__

   So that's great but since not every browser supports ``OffscreenCanvas`` at the
   moment let's change the code to work with both ``OffscreenCanvas`` and if not then
   fallback to using the canvas in the main page like normal.

      As an aside, if you need OffscreenCanvas to make your page responsive then it's
      not clear what the point of having a fallback is. Maybe based on if you end up
      running on the main page or in a worker you might adjust the amount of work done
      so that when running in a worker you can do more than when running in the main
      page. What you do is really up to you.

   The first thing we should probably do is separate out the three.js code from the
   code that is specific to the worker. That way we can use the same code on both the
   main page and the worker. In other words we will now have 3 files

   #. our html file.

      ``threejs-offscreencanvas-w-fallback.html``

   #. a JavaScript that contains our three.js code.

      ``shared-cubes.js``

   #. our worker support code

      ``offscreencanvas-worker-cubes.js``

   ``shared-cubes.js`` and ``offscreencanvas-worker-cubes.js`` are basically the split
   of our previous ``offscreencanvas-cubes.js`` file. First we copy all of
   ``offscreencanvas-cubes.js`` to ``shared-cube.js``. Then we rename ``main`` to
   ``init`` since we already have a ``main`` in our HTML file and we need to export
   ``init`` and ``state``


   .. code:: javascript

      import * as THREE from 'three';

      - const state = {
      + export const state = {
         width: 300,   // canvas default
         height: 150,  // canvas default
      };

      - function main(data) {
      + export function init(data) {
         const {canvas} = data;
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});


   and cut out the just the non three.js relates parts


   .. code:: javascript

      - function size(data) {
      -  state.width = data.width;
      -  state.height = data.height;
      - }
      - 
      - const handlers = {
      -  main,
      -  size,
      - };
      - 
      - self.onmessage = function(e) {
      -  const fn = handlers[e.data.type];
      -  if (typeof fn !== 'function') {
      -     throw new Error('no handler for type: ' + e.data.type);
      -   }
      -  fn(e.data);
      - };


   Then we copy those parts we just deleted to ``offscreencanvas-worker-cubes.js`` and
   import ``shared-cubes.js`` as well as call ``init`` instead of ``main``.


   .. code:: javascript

      import {init, state} from './shared-cubes.js';

      function size(data) {
         state.width = data.width;
         state.height = data.height;
      }

      const handlers = {
      -  main,
      +   init,
         size,
      };

      self.onmessage = function(e) {
         const fn = handlers[e.data.type];
         if (typeof fn !== 'function') {
            throw new Error('no handler for type: ' + e.data.type);
         }
         fn(e.data);
      };


   Similarly we need to include ``shared-cubes.js`` in the main page


   .. code:: javascript

      <script type="module">
      + import {init, state} from './shared-cubes.js';


   We can remove the HTML and CSS we added previously


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      -   <div id="noOffscreenCanvas" style="display:none;">
      -     <div>no OffscreenCanvas support</div>
      -   </div>
      </body>


   and some CSS for that


   .. code:: javascript

      - #noOffscreenCanvas {
      -     display: flex;
      -     width: 100%;
      -     height: 100%;
      -     align-items: center;
      -     justify-content: center;
      -     background: red;
      -     color: white;
      - }


   Then let's change the code in the main page to call one start function or another
   depending on if the browser supports ``OffscreenCanvas``.


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
      -  if (!canvas.transferControlToOffscreen) {
      -     canvas.style.display = 'none';
      -     document.querySelector('#noOffscreenCanvas').style.display = '';
      -     return;
      -   }
      -  const offscreen = canvas.transferControlToOffscreen();
      -  const worker = new Worker('offscreencanvas-picking.js', {type: 'module'});
      -  worker.postMessage({type: 'main', canvas: offscreen}, [offscreen]);
      +   if (canvas.transferControlToOffscreen) {
      +     startWorker(canvas);
      +   } else {
      +     startMainPage(canvas);
      +   }
         ...


   We'll move all the code we had to setup the worker inside ``startWorker``


   .. code:: javascript

      function startWorker(canvas) {
         const offscreen = canvas.transferControlToOffscreen();
         const worker = new Worker('offscreencanvas-worker-cubes.js', {type: 'module'});
         worker.postMessage({type: 'main', canvas: offscreen}, [offscreen]);

         function sendSize() {
            worker.postMessage({
            type: 'size',
            width: canvas.clientWidth,
            height: canvas.clientHeight,
            });
         }

         window.addEventListener('resize', sendSize);
         sendSize();

         console.log('using OffscreenCanvas');
      }


   and send ``init`` instead of ``main``


   .. code:: javascript

      -  worker.postMessage({type: 'main', canvas: offscreen}, [offscreen]);
      +   worker.postMessage({type: 'init', canvas: offscreen}, [offscreen]);


   for starting in the main page we can do this


   .. code:: javascript

      function startMainPage(canvas) {
         init({canvas});

         function sendSize() {
            state.width = canvas.clientWidth;
            state.height = canvas.clientHeight;
         }
         window.addEventListener('resize', sendSize);
         sendSize();

         console.log('using regular canvas');
      }


   and with that our example will run either in an OffscreenCanvas or fallback to
   running in the main page.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/offscreencanvas-w-fallback.html>`__

   So that was relatively easy. Let's try picking. We'll take some code from the
   ``RayCaster`` example from `the article on picking <picking>` and make it
   work offscreen.

   Let's copy the ``shared-cube.js`` to ``shared-picking.js`` and add the picking
   parts. We copy in the ``PickHelper``


   .. code:: javascript

      class PickHelper {
         constructor() {
            this.raycaster = new THREE.Raycaster();
            this.pickedObject = null;
            this.pickedObjectSavedColor = 0;
         }
         pick(normalizedPosition, scene, camera, time) {
            // restore the color if there is a picked object
            if (this.pickedObject) {
            this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
            this.pickedObject = undefined;
            }

            // cast a ray through the frustum
            this.raycaster.setFromCamera(normalizedPosition, camera);
            // get the list of objects the ray intersected
            const intersectedObjects = this.raycaster.intersectObjects(scene.children);
            if (intersectedObjects.length) {
            // pick the first object. It's the closest one
            this.pickedObject = intersectedObjects[0].object;
            // save its color
            this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
            // set its emissive color to flashing red/yellow
            this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
            }
         }
      }

      const pickPosition = {x: 0, y: 0};
      const pickHelper = new PickHelper();


   We updated ``pickPosition`` from the mouse like this


   .. code:: javascript

      function getCanvasRelativePosition(event) {
         const rect = canvas.getBoundingClientRect();
         return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
         };
      }

      function setPickPosition(event) {
         const pos = getCanvasRelativePosition(event);
         pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
         pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
      }
      window.addEventListener('mousemove', setPickPosition);


   A worker can't read the mouse position directly so just like the size code let's
   send a message with the mouse position. Like the size code we'll send the mouse
   position and update ``pickPosition``


   .. code:: javascript

      function size(data) {
         state.width = data.width;
         state.height = data.height;
      }

      + function mouse(data) {
      +   pickPosition.x = data.x;
      +   pickPosition.y = data.y;
      + }

      const handlers = {
         init,
      +   mouse,
         size,
      };

      self.onmessage = function(e) {
         const fn = handlers[e.data.type];
         if (typeof fn !== 'function') {
            throw new Error('no handler for type: ' + e.data.type);
         }
         fn(e.data);
      };


   Back in our main page we need to add code to pass the mouse to the worker or the
   main page.


   .. code:: javascript

      + let sendMouse;

      function startWorker(canvas) {
         const offscreen = canvas.transferControlToOffscreen();
         const worker = new Worker('offscreencanvas-worker-picking.js', {type: 'module'});
         worker.postMessage({type: 'init', canvas: offscreen}, [offscreen]);

      +   sendMouse = (x, y) => {
      +     worker.postMessage({
      +       type: 'mouse',
      +       x,
      +       y,
      +     });
      +   };

         function sendSize() {
            worker.postMessage({
            type: 'size',
            width: canvas.clientWidth,
            height: canvas.clientHeight,
            });
         }

         window.addEventListener('resize', sendSize);
         sendSize();

         console.log('using OffscreenCanvas');  /* eslint-disable-line no-console */
      }

      function startMainPage(canvas) {
         init({canvas});

      +   sendMouse = (x, y) => {
      +     pickPosition.x = x;
      +     pickPosition.y = y;
      +   };

         function sendSize() {
            state.width = canvas.clientWidth;
            state.height = canvas.clientHeight;
         }
         window.addEventListener('resize', sendSize);
         sendSize();

         console.log('using regular canvas');  /* eslint-disable-line no-console */
      }


   Then we can copy in all the mouse handling code to the main page and make just minor
   changes to use ``sendMouse``


   .. code:: javascript

      function setPickPosition(event) {
         const pos = getCanvasRelativePosition(event);
      -  pickPosition.x = (pos.x / canvas.clientWidth ) *  2 - 1;
      -  pickPosition.y = (pos.y / canvas.clientHeight) * -2 + 1;  // note we flip Y
      +   sendMouse(
      +       (pos.x / canvas.clientWidth ) *  2 - 1,
      +       (pos.y / canvas.clientHeight) * -2 + 1);  // note we flip Y
      }

      function clearPickPosition() {
         // unlike the mouse which always has a position
         // if the user stops touching the screen we want
         // to stop picking. For now we just pick a value
         // unlikely to pick something
      -  pickPosition.x = -100000;
      -  pickPosition.y = -100000;
      +   sendMouse(-100000, -100000);
      }
      window.addEventListener('mousemove', setPickPosition);
      window.addEventListener('mouseout', clearPickPosition);
      window.addEventListener('mouseleave', clearPickPosition);

      window.addEventListener('touchstart', (event) => {
         // prevent the window from scrolling
         event.preventDefault();
         setPickPosition(event.touches[0]);
      }, {passive: false});

      window.addEventListener('touchmove', (event) => {
         setPickPosition(event.touches[0]);
      });

      window.addEventListener('touchend', clearPickPosition);


   and with that picking should be working with ``OffscreenCanvas``.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/offscreencanvas-w-picking.html>`__

   Let's take it one more step and add in the
   `OrbitControls`. This will be little
   more involved. The `OrbitControls`
   use the DOM pretty extensively checking the mouse, touch events, and the keyboard.

   Unlike our code so far we can't really use a global ``state`` object without
   re-writing all the OrbitControls code to work with it. The OrbitControls take an
   ``HTMLElement`` to which they attach most of the DOM events they use. Maybe we could
   pass in our own object that has the same API surface as a DOM element. We only need
   to support the features the OrbitControls need.

   Digging through the `OrbitControls source
   code <https://github.com/mrdoob/three.js/blob/master/examples/jsm/controls/OrbitControls.js>`__
   it looks like we need to handle the following events.

   -  contextmenu
   -  pointerdown
   -  pointermove
   -  pointerup
   -  touchstart
   -  touchmove
   -  touchend
   -  wheel
   -  keydown

   For the pointer events we need the ``ctrlKey``, ``metaKey``, ``shiftKey``,
   ``button``, ``pointerType``, ``clientX``, ``clientY``, ``pageX``, and ``pageY``,
   properties.

   For the keydown events we need the ``ctrlKey``, ``metaKey``, ``shiftKey``, and
   ``keyCode`` properties.

   For the wheel event we only need the ``deltaY`` property.

   And for the touch events we only need ``pageX`` and ``pageY`` from the ``touches``
   property.

   So, let's make a proxy object pair. One part will run in the main page, get all
   those events, and pass on the relevant property values to the worker. The other part
   will run in the worker, receive those events and pass them on using events that have
   the same structure as the original DOM events so the OrbitControls won't be able to
   tell the difference.

   Here's the code for the worker part.


   .. code:: javascript

      import {EventDispatcher} from 'three';

      class ElementProxyReceiver extends EventDispatcher {
         constructor() {
            super();
         }
         handleEvent(data) {
            this.dispatchEvent(data);
         }
      }


   All it does is if it receives a message it dispatches it. It inherits from
   ``EventDispatcher`` which provides methods
   like ``addEventListener`` and ``removeEventListener`` just like a DOM element so if
   we pass it to the OrbitControls it should work.

   ``ElementProxyReceiver`` handles 1 element. In our case we only need one but it's
   best to think head so lets make a manager to manage more than one of them.


   .. code:: javascript

      class ProxyManager {
         constructor() {
            this.targets = {};
            this.handleEvent = this.handleEvent.bind(this);
         }
         makeProxy(data) {
            const {id} = data;
            const proxy = new ElementProxyReceiver();
            this.targets[id] = proxy;
         }
         getProxy(id) {
            return this.targets[id];
         }
         handleEvent(data) {
            this.targets[data.id].handleEvent(data.data);
         }
      }


   We can make a instance of ``ProxyManager`` and call its ``makeProxy`` method with an
   id which will make an ``ElementProxyReceiver`` that responds to messages with that
   id.

   Let's hook it up to our worker's message handler.


   .. code:: javascript

      const proxyManager = new ProxyManager();

      function start(data) {
         const proxy = proxyManager.getProxy(data.canvasId);
         init({
            canvas: data.canvas,
            inputElement: proxy,
         });
      }

      function makeProxy(data) {
         proxyManager.makeProxy(data);
      }

      ...

      const handlers = {
      -  init,
      -  mouse,
      +   start,
      +   makeProxy,
      +   event: proxyManager.handleEvent,
         size,
      };

      self.onmessage = function(e) {
         const fn = handlers[e.data.type];
         if (typeof fn !== 'function') {
            throw new Error('no handler for type: ' + e.data.type);
         }
         fn(e.data);
      };


   In our shared three.js code we need to import the
   `OrbitControls` and set them up.


   .. code:: javascript

      import * as THREE from 'three';
      + import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

      export function init(data) {
      -  const {canvas} = data;
      +   const {canvas, inputElement} = data;
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});

      +   const controls = new OrbitControls(camera, inputElement);
      +   controls.target.set(0, 0, 0);
      +   controls.update();


   Notice we're passing the OrbitControls our proxy via ``inputElement`` instead of
   passing in the canvas like we do in other non-OffscreenCanvas examples.

   Next we can move all the picking event code from the HTML file to the shared
   three.js code as well while changing ``canvas`` to ``inputElement``.


   .. code:: javascript

      function getCanvasRelativePosition(event) {
      -  const rect = canvas.getBoundingClientRect();
      +   const rect = inputElement.getBoundingClientRect();
         return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
         };
      }

      function setPickPosition(event) {
         const pos = getCanvasRelativePosition(event);
      -  sendMouse(
      -       (pos.x / canvas.clientWidth ) *  2 - 1,
      -       (pos.y / canvas.clientHeight) * -2 + 1);  // note we flip Y
      +   pickPosition.x = (pos.x / inputElement.clientWidth ) *  2 - 1;
      +   pickPosition.y = (pos.y / inputElement.clientHeight) * -2 + 1;  // note we flip Y
      }

      function clearPickPosition() {
         // unlike the mouse which always has a position
         // if the user stops touching the screen we want
         // to stop picking. For now we just pick a value
         // unlikely to pick something
      -  sendMouse(-100000, -100000);
      +   pickPosition.x = -100000;
      +   pickPosition.y = -100000;
      }

      * inputElement.addEventListener('mousemove', setPickPosition);
      * inputElement.addEventListener('mouseout', clearPickPosition);
      * inputElement.addEventListener('mouseleave', clearPickPosition);

      * inputElement.addEventListener('touchstart', (event) => {
         // prevent the window from scrolling
         event.preventDefault();
         setPickPosition(event.touches[0]);
      }, {passive: false});

      * inputElement.addEventListener('touchmove', (event) => {
         setPickPosition(event.touches[0]);
      });

      * inputElement.addEventListener('touchend', clearPickPosition);


   Back in the main page we need code to send messages for all the events we enumerated
   above.


   .. code:: javascript

      let nextProxyId = 0;
      class ElementProxy {
         constructor(element, worker, eventHandlers) {
            this.id = nextProxyId++;
            this.worker = worker;
            const sendEvent = (data) => {
            this.worker.postMessage({
               type: 'event',
               id: this.id,
               data,
            });
            };

            // register an id
            worker.postMessage({
            type: 'makeProxy',
            id: this.id,
            });
            for (const [eventName, handler] of Object.entries(eventHandlers)) {
            element.addEventListener(eventName, function(event) {
               handler(event, sendEvent);
            });
            }
         }
      }


   ``ElementProxy`` takes the element who's events we want to proxy. It then registers
   an id with the worker by picking one and sending it via the ``makeProxy`` message we
   setup earlier. The worker will make an ``ElementProxyReceiver`` and register it to
   that id.

   We then have an object of event handlers to register. This way we can pass handlers
   only for these events we want to forward to the worker.

   When we start the worker we first make a proxy and pass in our event handlers.


   .. code:: javascript

      function startWorker(canvas) {
         const offscreen = canvas.transferControlToOffscreen();
         const worker = new Worker('offscreencanvas-worker-orbitcontrols.js', {type: 'module'});

      +   const eventHandlers = {
      +     contextmenu: preventDefaultHandler,
      +     mousedown: mouseEventHandler,
      +     mousemove: mouseEventHandler,
      +     mouseup: mouseEventHandler,
      +     pointerdown: mouseEventHandler,
      +     pointermove: mouseEventHandler,
      +     pointerup: mouseEventHandler,
      +     touchstart: touchEventHandler,
      +     touchmove: touchEventHandler,
      +     touchend: touchEventHandler,
      +     wheel: wheelEventHandler,
      +     keydown: filteredKeydownEventHandler,
      +   };
      +   const proxy = new ElementProxy(canvas, worker, eventHandlers);
         worker.postMessage({
            type: 'start',
            canvas: offscreen,
      +     canvasId: proxy.id,
         }, [offscreen]);
         console.log('using OffscreenCanvas');  /* eslint-disable-line no-console */
      }


   And here are the event handlers. All they do is copy a list of properties from the
   event they receive. They are passed a ``sendEvent`` function to which they pass the
   data they make. That function will add the correct id and send it to the worker.


   .. code:: javascript

      const mouseEventHandler = makeSendPropertiesHandler([
         'ctrlKey',
         'metaKey',
         'shiftKey',
         'button',
         'pointerType',
         'clientX',
         'clientY',
         'pageX',
         'pageY',
      ]);
      const wheelEventHandlerImpl = makeSendPropertiesHandler([
         'deltaX',
         'deltaY',
      ]);
      const keydownEventHandler = makeSendPropertiesHandler([
         'ctrlKey',
         'metaKey',
         'shiftKey',
         'keyCode',
      ]);

      function wheelEventHandler(event, sendFn) {
         event.preventDefault();
         wheelEventHandlerImpl(event, sendFn);
      }

      function preventDefaultHandler(event) {
         event.preventDefault();
      }

      function copyProperties(src, properties, dst) {
         for (const name of properties) {
            dst[name] = src[name];
         }
      }

      function makeSendPropertiesHandler(properties) {
         return function sendProperties(event, sendFn) {
            const data = {type: event.type};
            copyProperties(event, properties, data);
            sendFn(data);
         };
      }

      function touchEventHandler(event, sendFn) {
         const touches = [];
         const data = {type: event.type, touches};
         for (let i = 0; i < event.touches.length; ++i) {
            const touch = event.touches[i];
            touches.push({
            pageX: touch.pageX,
            pageY: touch.pageY,
            });
         }
         sendFn(data);
      }

      // The four arrow keys
      const orbitKeys = {
         '37': true,  // left
         '38': true,  // up
         '39': true,  // right
         '40': true,  // down
      };
      function filteredKeydownEventHandler(event, sendFn) {
         const {keyCode} = event;
         if (orbitKeys[keyCode]) {
            event.preventDefault();
            keydownEventHandler(event, sendFn);
         }
      }


   This seems close to running but if we actually try it we'll see that the
   `OrbitControls` need a few more
   things.

   One is they call ``element.focus``. We don't need that to happen in the worker so
   let's just add a stub.


   .. code:: javascript

      class ElementProxyReceiver extends THREE.EventDispatcher {
         constructor() {
            super();
         }
         handleEvent(data) {
            this.dispatchEvent(data);
         }
      +   focus() {
      +     // no-op
      +   }
      }


   Another is they call ``event.preventDefault`` and ``event.stopPropagation``. We're
   already handling that in the main page so those can also be a noop.


   .. code:: javascript

      + function noop() {
      + }

      class ElementProxyReceiver extends THREE.EventDispatcher {
         constructor() {
            super();
         }
         handleEvent(data) {
      +     data.preventDefault = noop;
      +     data.stopPropagation = noop;
            this.dispatchEvent(data);
         }
         focus() {
            // no-op
         }
      }


   Another is they look at ``clientWidth`` and ``clientHeight``. We were passing the
   size before but we can update the proxy pair to pass that as well.

   In the worker...


   .. code:: javascript

      class ElementProxyReceiver extends THREE.EventDispatcher {
         constructor() {
            super();
         }
      +   get clientWidth() {
      +     return this.width;
      +   }
      +   get clientHeight() {
      +     return this.height;
      +   }
      +   getBoundingClientRect() {
      +     return {
      +       left: this.left,
      +       top: this.top,
      +       width: this.width,
      +       height: this.height,
      +       right: this.left + this.width,
      +       bottom: this.top + this.height,
      +     };
      +   }
         handleEvent(data) {
      +     if (data.type === 'size') {
      +       this.left = data.left;
      +       this.top = data.top;
      +       this.width = data.width;
      +       this.height = data.height;
      +       return;
      +     }
            data.preventDefault = noop;
            data.stopPropagation = noop;
            this.dispatchEvent(data);
         }
         focus() {
            // no-op
         }
      }


   back in the main page we need to send the size and the left and top positions as
   well. Note that as is we don't handle if the canvas moves, only if it resizes. If
   you wanted to handle moving you'd need to call ``sendSize`` anytime something moved
   the canvas.


   .. code:: javascript

      class ElementProxy {
         constructor(element, worker, eventHandlers) {
            this.id = nextProxyId++;
            this.worker = worker;
            const sendEvent = (data) => {
            this.worker.postMessage({
               type: 'event',
               id: this.id,
               data,
            });
            };

            // register an id
            worker.postMessage({
            type: 'makeProxy',
            id: this.id,
            });
      +     sendSize();
            for (const [eventName, handler] of Object.entries(eventHandlers)) {
            element.addEventListener(eventName, function(event) {
               handler(event, sendEvent);
            });
            }

      +     function sendSize() {
      +       const rect = element.getBoundingClientRect();
      +       sendEvent({
      +         type: 'size',
      +         left: rect.left,
      +         top: rect.top,
      +         width: element.clientWidth,
      +         height: element.clientHeight,
      +       });
      +     }
      + 
      +     window.addEventListener('resize', sendSize);
         }
      }


   and in our shared three.js code we no longer need ``state``


   .. code:: javascript

      - export const state = {
      -  width: 300,   // canvas default
      -  height: 150,  // canvas default
      - };

      ...

      function resizeRendererToDisplaySize(renderer) {
         const canvas = renderer.domElement;
      -  const width = state.width;
      -  const height = state.height;
      +   const width = inputElement.clientWidth;
      +   const height = inputElement.clientHeight;
         const needResize = canvas.width !== width || canvas.height !== height;
         if (needResize) {
            renderer.setSize(width, height, false);
         }
         return needResize;
      }

      function render(time) {
         time *= 0.001;

         if (resizeRendererToDisplaySize(renderer)) {
      -     camera.aspect = state.width / state.height;
      +     camera.aspect = inputElement.clientWidth / inputElement.clientHeight;
            camera.updateProjectionMatrix();
         }

         ...


   A few more hacks. The OrbitControls add ``pointermove`` and ``pointerup`` events to
   the ``ownerDocument`` of the element to handle mouse capture (when the mouse goes
   outside the window).

   Further the code references the global ``document`` but there is no global document
   in a worker.

   We can solve all of these with a 2 quick hacks. In our worker code we'll re-use our
   proxy for both problems.


   .. code:: javascript

      function start(data) {
         const proxy = proxyManager.getProxy(data.canvasId);
      +   proxy.ownerDocument = proxy; // HACK!
      +   self.document = {} // HACK!
         init({
            canvas: data.canvas,
            inputElement: proxy,
         });
      }


   This will give the `OrbitControls`
   something to inspect which matches their expectations.

   I know that was kind of hard to follow. The short version is: ``ElementProxy`` runs
   on the main page and forwards DOM events to ``ElementProxyReceiver`` in the worker
   which masquerades as an ``HTMLElement`` that we can use both with the
   `OrbitControls` and with our own
   code.

   The final thing is our fallback when we are not using OffscreenCanvas. All we have
   to do is pass the canvas itself as our ``inputElement``.


   .. code:: javascript

      function startMainPage(canvas) {
      -  init({canvas});
      +   init({canvas, inputElement: canvas});
         console.log('using regular canvas');
      }


   and now we should have OrbitControls working with OffscreenCanvas


      `click here to open in a separate
      window <https://threejs.org/manual/examples/offscreencanvas-w-orbitcontrols.html>`__

   This is probably the most complicated example on this site. It's a little hard to
   follow because there are 3 files involved for each sample. The HTML file, the worker
   file, the shared three.js code.

   I hope it wasn't too difficult to understand and that it provided some useful
   examples of working with three.js, OffscreenCanvas and web workers.


.. _F26:

Load an .OBJ file
=================

   -  `Load an .OBJ file <https://threejs.org/manual/en/load-obj.html>`__


   One of the most common things people want to do with three.js is to load and display
   3D models. A common format is the .OBJ 3D format so let's try loading one.

   Searching the net I found `this CC-BY-NC 3.0 windmill 3D model <https://www.blendswap.com/blends/view/69174>`__ 
   by `ahedov <https://www.blendswap.com/user/ahedov>`__.

   .. image:: https://threejs.org/manual/resources/images/windmill-obj.jpg


   I downloaded the .blend file from that site, loaded it into `Blender <https://blender.org>`__ 
   and exported it as an .OBJ file.

   .. image:: https://threejs.org/manual/resources/images/windmill-export-as-obj.jpg


   .. Note::

      Note: If you've never used Blender you might be in for a surprise in that Blender
      does things differently than just about every other program you've ever used.
      Just be aware you might need to set aside some time to read some basic UI
      navigation for Blender.

      Let me also add that 3D programs in general are giant beasts with 1000s of
      features. They are some of the most complicated software there is. When I first
      learned 3D Studio Max in 1996 I read through 70% of the 600 page manual spending
      a few hours a day for around 3 weeks. That paid off in that when I learned Maya a
      few years later some of the lessons learned before were applicable to Maya. So,
      just be aware that if you really want to be able to use 3D software to either
      build 3D assets or to modify existing ones put it on your schedule and clear
      sometime to really go through some lessons.

   In any case I used these export options

   .. image:: https://threejs.org/manual/resources/images/windmill-export-options.jpg


   Let's try to display it!

   I started with the directional lighting example from `the lights article <lights>` 
   and I combined it with the hemispherical lighting example so I ended up with one
   ``HemisphereLight`` and one ``DirectionalLight``. I also removed all
   the GUI stuff related to adjusting the lights. I also removed the cube and sphere
   that were being added to the scene.

   From that the first thing we need to do is include the `OBJLoader` loader in our script.


   .. code:: javascript

      import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';


   Then to load the .OBJ file we create an instance of `OBJLoader`, pass it the URL of 
   our .OBJ file, and pass in a callback that adds the loaded model to our scene.


   .. code:: javascript

      {
         const objLoader = new OBJLoader();
         objLoader.load('resources/models/windmill/windmill.obj', (root) => {
            scene.add(root);
         });
      }


   If we run that what happens?


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-obj-no-materials.html>`__

   Well it's close but we're getting errors about materials since we haven't given the
   scene any materials and .OBJ files don't have material parameters.

   The .OBJ loader can be passed an object of name / material pairs. When it loads the
   .OBJ file, any material name it finds it will look for the corresponding material in
   the map of materials set on the loader. If it finds a material that matches by name
   it will use that material. If not it will use the loader's default material.

   Sometimes .OBJ files come with a .MTL file that defines materials. In our case the
   exporter also created a .MTL file. .MTL format is plain ASCII so it's easy to look
   at. Looking at it here


   .. code:: javascript

      # Blender MTL File: 'windmill_001.blend'
      # Material Count: 2

      newmtl Material
      Ns 0.000000
      Ka 1.000000 1.000000 1.000000
      Kd 0.800000 0.800000 0.800000
      Ks 0.000000 0.000000 0.000000
      Ke 0.000000 0.000000 0.000000
      Ni 1.000000
      d 1.000000
      illum 1
      map_Kd windmill_001_lopatky_COL.jpg
      map_Bump windmill_001_lopatky_NOR.jpg

      newmtl windmill
      Ns 0.000000
      Ka 1.000000 1.000000 1.000000
      Kd 0.800000 0.800000 0.800000
      Ks 0.000000 0.000000 0.000000
      Ke 0.000000 0.000000 0.000000
      Ni 1.000000
      d 1.000000
      illum 1
      map_Kd windmill_001_base_COL.jpg
      map_Bump windmill_001_base_NOR.jpg
      map_Ns windmill_001_base_SPEC.jpg


   We can see there are 2 materials referencing 5 jpg textures but where are the
   texture files?

   .. image:: https://threejs.org/manual/resources/images/windmill-exported-files.png


   All we got was an .OBJ file and an .MTL file.

   At least for this model it turns out the textures are embedded in the .blend file we
   downloaded. We can ask blender to export those files to by picking **File->External
   Data->Unpack All Into Files**

   .. image:: https://threejs.org/manual/resources/images/windmill-export-textures.jpg


   and then choosing **Write Files to Current Directory**

   .. image:: https://threejs.org/manual/resources/images/windmill-overwrite.jpg


   This ends up writing the files in the same folder as the .blend file in a sub folder
   called **textures**.

   .. image:: https://threejs.org/manual/resources/images/windmill-exported-texture-files.png


   I copied those textures into the same folder I exported the .OBJ file to.

   .. image:: https://threejs.org/manual/resources/images/windmill-exported-files-with-textures.png


   Now that we have the textures available we can load the .MTL file.

   First we need to include the `MTLLoader </docs/#examples/loaders/MTLLoader>`__;


   .. code:: javascript

      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';
      + import {MTLLoader} from 'three/addons/loaders/MTLLoader.js';


   Then we first load the .MTL file. When it's finished loading we add the just loaded 
   materials on to the `OBJLoader` itself via the ``setMaterials`` and then load the .OBJ file.


   .. code:: javascript

      {
      +   const mtlLoader = new MTLLoader();
      +   mtlLoader.load('resources/models/windmill/windmill.mtl', (mtl) => {
      +     mtl.preload();
      +     objLoader.setMaterials(mtl);
            objLoader.load('resources/models/windmill/windmill.obj', (root) => {
               scene.add(root);
            });
      +   });
      }


   And if we try that...


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-obj-materials.html>`__

   Note that if we spin the model around you'll see the windmill cloth disappears

   .. image:: https://threejs.org/manual/resources/images/windmill-missing-cloth.jpg


   We need the material on the blades to be double sided, something we went over in
   `the article on materials <materials>`. There is no easy way to fix this in
   the .MTL file. Off the top of my head I can think of 3 ways to fix this.

   1. Loop over all the materials after loading them and set them all to double sided.


      .. code:: javascript

            const mtlLoader = new MTLLoader();
            mtlLoader.load('resources/models/windmill/windmill.mtl', (mtl) => {
            mtl.preload();
            for (const material of Object.values(mtl.materials)) {
               material.side = THREE.DoubleSide;
            }
            ...

      This solution works but ideally we only want materials that need to be double
      sided to be double sided because drawing double sided is slower than single
      sided.


   2. Manually set a specific material

      Looking in the .MTL file there are 2 materials. One called ``"windmill"`` and the
      other called ``"Material"``. Through trial and error I figured out the blades use
      the material called ``"Material"``\ so we could set that one specifically


      .. code:: javascript

            const mtlLoader = new MTLLoader();
            mtlLoader.load('resources/models/windmill/windmill.mtl', (mtl) => {
            mtl.preload();
            mtl.materials.Material.side = THREE.DoubleSide;
            ...


   3. Realizing that the .MTL file is limited we could just not use it and instead
      create materials ourselves.

      In this case we'd need to look up the ``Mesh`` object after loading the obj file.


      .. code:: javascript

         objLoader.load('resources/models/windmill/windmill.obj', (root) => {
            const materials = {
               Material: new THREE.MeshPhongMaterial({...}),
               windmill: new THREE.MeshPhongMaterial({...}),
            };
            root.traverse(node => {
               const material = materials[node.material?.name];
               if (material) {
                  node.material = material;
               }
            })
            scene.add(root);
         });


   Which one you pick is up to you. 1 is easiest. 3 is most flexible. 2 somewhere in
   between. For now I'll pick 2.

   And with that change you should still see the cloth on the blades when looking from
   behind but there's one more issue. If we zoom in close we see things are turning
   blocky.

   .. image:: https://threejs.org/manual/resources/images/windmill-blocky.jpg


   What's going on?

   Looking at the textures there are 2 textures labelled NOR for NORmal map. And
   looking at them they look like normal maps. Normal maps are generally purple where
   as bump maps are black and white. Normal maps represent the direction of the surface
   where as bump maps represent the height of the surface.

   .. image:: https://threejs.org/manual/examples/resources/models/windmill/windmill_001_base_NOR.jpg


   Looking at `the source for the MTLLoader <https://github.com/mrdoob/three.js/blob/1a560a3426e24bbfc9ca1f5fb0dfb4c727d59046/examples/js/loaders/MTLLoader.js#L432>`__
   it expects the keyword ``norm`` for normal maps so let's edit the .MTL file


   .. code:: javascript

      # Blender MTL File: 'windmill_001.blend'
      # Material Count: 2

      newmtl Material
      Ns 0.000000
      Ka 1.000000 1.000000 1.000000
      Kd 0.800000 0.800000 0.800000
      Ks 0.000000 0.000000 0.000000
      Ke 0.000000 0.000000 0.000000
      Ni 1.000000
      d 1.000000
      illum 1
      map_Kd windmill_001_lopatky_COL.jpg
      - map_Bump windmill_001_lopatky_NOR.jpg
      + norm windmill_001_lopatky_NOR.jpg

      newmtl windmill
      Ns 0.000000
      Ka 1.000000 1.000000 1.000000
      Kd 0.800000 0.800000 0.800000
      Ks 0.000000 0.000000 0.000000
      Ke 0.000000 0.000000 0.000000
      Ni 1.000000
      d 1.000000
      illum 1
      map_Kd windmill_001_base_COL.jpg
      - map_Bump windmill_001_base_NOR.jpg
      + norm windmill_001_base_NOR.jpg
      map_Ns windmill_001_base_SPEC.jpg


   and now when we load it it will be using the normal maps as normal maps and we can
   see the back of the blades.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-obj-materials-fixed.html>`__

   Let's load a different file.

   Searching the net I found this `CC-BY-NC <https://creativecommons.org/licenses/by-nc/4.0/>`__ 
   windmill 3D model made by `Roger Gerzner / GERIZ.3D Art <http://www.gerzi.ch/>`__.

   .. image:: https://threejs.org/manual/resources/images/windmill-obj-2.jpg


   It had a .OBJ version already available. Let's load it up (note I removed the .MTL
   loader for now)


   .. code:: javascript

      -  objLoader.load('resources/models/windmill/windmill.obj', ...
      +   objLoader.load('resources/models/windmill-2/windmill.obj', ...


      `click here to open in a separate window <https://threejs.org/manual/examples/load-obj-wat.html>`__


   Hmmm, nothing appears. What's the problem? I wonder what size the model is? We can
   ask THREE.js what size the model is and try to set our camera automatically.

   First off we can ask THREE.js to compute a box that contains the scene we just
   loaded and ask for its size and center


   .. code:: javascript

      objLoader.load('resources/models/windmill_2/windmill.obj', (root) => {
         scene.add(root);

      +   const box = new THREE.Box3().setFromObject(root);
      +   const boxSize = box.getSize(new THREE.Vector3()).length();
      +   const boxCenter = box.getCenter(new THREE.Vector3());
      +   console.log(boxSize);
      +   console.log(boxCenter);


   Looking in `the JavaScript console <debugging-javascript>` I see


   .. code:: javascript

      size 2123.6499788469982
      center p {x: -0.00006103515625, y: 770.0909731090069, z: -3.313507080078125}


   Our camera is currently only showing about 100 units with ``near`` at 0.1 and
   ``far`` at 100. Our ground plane is only 40 units across so basically this windmill
   model is so big, 2000 units, that it's surrounding our camera and all parts of it
   our outside our frustum.

   .. image:: https://threejs.org/manual/resources/images/camera-inside-windmill.svg


   We could manually fix that but we could also make the camera auto frame our scene.
   Let's try that. We can then use the box we just computed adjust the camera settings
   to view the entire scene. Note that there is no *right* answer on where to put the
   camera. We could be facing the scene from any direction at any altitude so we'll
   just have to pick something.

   As we went over in `the article on cameras <cameras>` the camera defines a
   frustum. That frustum is defined by the field of view (``fov``) and the ``near`` and
   ``far`` settings. We want to know given whatever field of view the camera currently
   has, how far away does the camera need to be so the box containing the scene fits
   inside the frustum assuming the frustum extended forever. In other words let's
   assume ``near`` is 0.00000001 and ``far`` is infinity.

   Since we know the size of the box and we know the field of view we have this
   triangle

   .. image:: https://threejs.org/manual/resources/images/camera-fit-scene.svg


   You can see on the left is the camera and the blue frustum is projecting out in
   front of it. We just computed the box that contains the the windmill. We need to
   compute how far way the camera should be from the box so that the box appears inside
   the frustum.

   Using basic *right triangle* trigonometry and `SOHCAHTOA <https://www.bing.com/search?q=SOHCAHTOA>`__, 
   given we know the field of view for the frustum and we know the size of the box 
   we can compute the *distance*.

   .. image:: https://threejs.org/manual/resources/images/field-of-view-camera.svg


   Based on that diagram the formula for computing distance is


   .. code:: javascript

      distance = halfSizeToFitOnScreen / tangent(halfFovY)


   Let's translate that to code. First let's make a function that will compute
   ``distance`` and then move the camera that ``distance`` units from the center of the
   box. We'll then point the camera at the ``center`` of the box.


   .. code:: javascript

      function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
         const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
         const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
         const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);

         // compute a unit vector that points in the direction the camera is now
         // from the center of the box
         const direction = (new THREE.Vector3()).subVectors(camera.position, boxCenter).normalize();

         // move the camera to a position distance units way from the center
         // in whatever direction the camera was from the center already
         camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

         // pick some near and far values for the frustum that
         // will contain the box.
         camera.near = boxSize / 100;
         camera.far = boxSize * 100;

         camera.updateProjectionMatrix();

         // point the camera to look at the center of the box
         camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
      }


   We pass in 2 sizes. The ``boxSize`` and the ``sizeToFitOnScreen``. If we just passed
   in ``boxSize`` and used that as ``sizeToFitOnScreen`` then the math would make the
   box fit perfectly inside the frustum. We want a little extra space above and below
   so we'll pass in a slightly larger size.


   .. code:: javascript

      {
         const objLoader = new OBJLoader();
         objLoader.load('resources/models/windmill_2/windmill.obj', (root) => {
            scene.add(root);
      +     // compute the box that contains all the stuff
      +     // from root and below
      +     const box = new THREE.Box3().setFromObject(root);
      + 
      +     const boxSize = box.getSize(new THREE.Vector3()).length();
      +     const boxCenter = box.getCenter(new THREE.Vector3());
      + 
      +     // set the camera to frame the box
      +     frameArea(boxSize * 1.2, boxSize, boxCenter, camera);
      + 
      +     // update the Trackball controls to handle the new size
      +     controls.maxDistance = boxSize * 10;
      +     controls.target.copy(boxCenter);
      +     controls.update();
         });
      }


   You can see above we pass in ``boxSize * 1.2`` to give us 20% more space above and
   below the box when trying to fit it inside the frustum. We also updated the
   `OrbitControls` so the camera will
   orbit the center of the scene.

   Now if we try that we get...


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-obj-auto-camera.html>`__

   This almost works. Use the mouse to rotate the camera and you should see the
   windmill. The problem is the windmill is large and the box's center is at about (0,
   770, 0). So, when we move the camera from where it starts (0, 10, 20) to
   ``distance`` units way from the center in the direction the camera is relative to
   the center that's moving the camera almost straight down below the windmill.

   .. image:: https://threejs.org/manual/resources/images/computed-camera-position.svg


   Let's change it to move sideways from the center of the box to in whatever direction
   the camera is from the center. All we need to do to do that is zero out the ``y``
   component of the vector from the box to the camera. Then, when we normalize that
   vector it will become a vector parallel to the XZ plane. In other words parallel to
   the ground.


   .. code:: javascript

      - // compute a unit vector that points in the direction the camera is now
      - // from the center of the box
      - const direction = (new THREE.Vector3()).subVectors(camera.position, boxCenter).normalize();
      + // compute a unit vector that points in the direction the camera is now
      + // in the xz plane from the center of the box
      + const direction = (new THREE.Vector3())
      +     .subVectors(camera.position, boxCenter)
      +     .multiply(new THREE.Vector3(1, 0, 1))
      +     .normalize();


   If you look at the bottom of the windmill you'll see a small square. That is our
   ground plane.

   .. image:: https://threejs.org/manual/resources/images/tiny-ground-plane.jpg


   It's only 40x40 units and so is way too small relative to the windmill. Since the
   windmill is over 2000 units big let's change the size of the ground plane to
   something more fitting. We also need to adjust the repeat otherwise our checkerboard
   will be so fine we won't even be able to see it unless we zoom way way in.


   .. code:: javascript

      - const planeSize = 40;
      + const planeSize = 4000;

      const loader = new THREE.TextureLoader();
      const texture = loader.load('resources/images/checker.png');
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.magFilter = THREE.NearestFilter;
      - const repeats = planeSize / 2;
      + const repeats = planeSize / 200;
      texture.repeat.set(repeats, repeats);


   and now we can see this windmill


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-obj-auto-camera-xz.html>`__

   Let's add the materials back. Like before there is a .MTL file that references some
   textures but looking at the files I quickly see an issue.


   .. code:: javascript

         $ ls -l windmill
         -rw-r--r--@ 1 gregg  staff       299 May 20  2009 windmill.mtl
         -rw-r--r--@ 1 gregg  staff    142989 May 20  2009 windmill.obj
         -rw-r--r--@ 1 gregg  staff  12582956 Apr 19  2009 windmill_diffuse.tga
         -rw-r--r--@ 1 gregg  staff  12582956 Apr 20  2009 windmill_normal.tga
         -rw-r--r--@ 1 gregg  staff  12582956 Apr 19  2009 windmill_spec.tga


   There are TARGA (.tga) files and they are giant!

   THREE.js actually has a TGA loader but it's arguably wrong to use it for most use
   cases. If you're making a viewer where you want to allow users to view random 3D
   files they find on the net then maybe, just maybe, you might want to load TGA files.
   (`\* <#loading-scenes>`__)

   One problem with TGA files are they can't be compressed well at all. TGA only
   supports very simple compression and looking above we can see the files are not
   compressed at all as the odds of them being all exactly the same size are extremely
   low. Further they are 12 megabytes each!!! If we used those files the user would
   have to download 36meg to see the windmill.

   Another issue with TGA is the browser itself has no support for them so loading them
   is likely going to be slower than loading supported formats like .JPG and .PNG

   I'm pretty sure for our purposes converting them to .JPG will be the best option.
   Looking inside I see they are 3 channels each, RGB, there is no alpha channel. JPG
   only supports 3 channels so that's a good fit. JPG also supports lossy compression
   so we can make the files much smaller to download

   Loading the files up they were each 2048x2048. That seemed like a waste to me but of
   course it depends on your use case. I made them each 1024x1024 and saved them at a
   50% quality setting in Photoshop. Getting a file listing


   .. code:: javascript

         $ ls -l ../threejs.org/manual/examples/resources/models/windmill
         -rw-r--r--@ 1 gregg  staff     299 May 20  2009 windmill.mtl
         -rw-r--r--@ 1 gregg  staff  142989 May 20  2009 windmill.obj
         -rw-r--r--@ 1 gregg  staff  259927 Nov  7 18:37 windmill_diffuse.jpg
         -rw-r--r--@ 1 gregg  staff   98013 Nov  7 18:38 windmill_normal.jpg
         -rw-r--r--@ 1 gregg  staff  191864 Nov  7 18:39 windmill_spec.jpg


   We went from 36meg to 0.55meg! Of course the artist might not be pleased with this
   compression so be sure to consult with them to discuss the tradeoffs.

   Now, to use the .MTL file we need to edit it to reference the .JPG files instead of
   the .TGA files. Fortunately it's a simple text file so it's easy to edit


   .. code:: javascript

      newmtl blinn1SG
      Ka 0.10 0.10 0.10

      Kd 0.00 0.00 0.00
      Ks 0.00 0.00 0.00
      Ke 0.00 0.00 0.00
      Ns 0.060000
      Ni 1.500000
      d 1.000000
      Tr 0.000000
      Tf 1.000000 1.000000 1.000000
      illum 2
      - map_Kd windmill_diffuse.tga
      + map_Kd windmill_diffuse.jpg

      - map_Ks windmill_spec.tga
      + map_Ks windmill_spec.jpg

      - map_bump windmill_normal.tga
      - bump windmill_normal.tga
      + map_bump windmill_normal.jpg
      + bump windmill_normal.jpg


   Now that the .MTL file points to some reasonable size textures we need to load it so
   we'll just do like we did above, first load the materials and then set them on the `OBJLoader`


   .. code:: javascript

      {
      +   const mtlLoader = new MTLLoader();
      +   mtlLoader.load('resources/models/windmill_2/windmill-fixed.mtl', (mtl) => {
      +     mtl.preload();
      +     const objLoader = new OBJLoader();
      +     objLoader.setMaterials(mtl);
            objLoader.load('resources/models/windmill/windmill.obj', (root) => {
            root.updateMatrixWorld();
            scene.add(root);
            // compute the box that contains all the stuff
            // from root and below
            const box = new THREE.Box3().setFromObject(root);

            const boxSize = box.getSize(new THREE.Vector3()).length();
            const boxCenter = box.getCenter(new THREE.Vector3());

            // set the camera to frame the box
            frameArea(boxSize * 1.2, boxSize, boxCenter, camera);

            // update the Trackball controls to handle the new size
            controls.maxDistance = boxSize * 10;
            controls.target.copy(boxCenter);
            controls.update();
            });
      +   });
      }


   Before we actually try it out I ran into some issues that rather than show a failure
   I'm just going to go over them.

   Issue #1: The three `MTLLoader` creates materials that multiply the material's diffuse 
   color by the diffuse texture map.

   That's a useful feature but looking a the .MTL file above the line


   .. code:: javascript

      Kd 0.00 0.00 0.00


   sets the diffuse color to 0. Texture map * 0 = black! It's possible the modeling
   tool used to make the windmill did not multiply the diffuse texture map by the
   diffuse color. That's why it worked for the artists that made this windmill.

   To fix this we can change the line to


   .. code:: javascript

      Kd 1.00 1.00 1.00


   since Texture Map * 1 = Texture Map.

   Issue #2: The specular color is also black

   The line that starts with ``Ks`` specifies the specular color. It's likely the
   modeling software used to make the windmill did something similar as it did with
   diffuse maps in that it used the specular map's color for specular highlights.
   Three.js uses only the red channel of a specular map as input to how much of the
   specular color to reflect but three still needs a specular color set.

   Like above we can fix that by editing the .MTL file like this.


   .. code:: javascript

      - Ks 0.00 0.00 0.00
      + Ks 1.00 1.00 1.00


   Issue #3: The ``windmill_normal.jpg`` is a normal map not a bump map.

   Just like above we just need to edit the .MTL file


   .. code:: javascript

      - map_bump windmill_normal.jpg
      - bump windmill_normal.jpg
      + norm windmill_normal.jpg


   Given all that if we now try it out it should load up with materials.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-obj-materials-windmill2.html>`__

   Loading models often runs into these kinds of issues. Common issues include:

   -  Needing to know the size

      Above we made the camera try to frame the scene but that's not always the
      appropriate thing to do. Generally the most appropriate thing to do is to make
      your own models or download the models, load them up in some 3D software and look
      at their scale and adjust if need be.

   -  Orientation Wrong

      THREE.js is generally Y = up. Some modeling packages default to Z = up, some Y =
      up. Some are settable. If you run into this case where you load a model and it's
      on its side. You can either hack your code to rotate the model after loading (not
      recommended), or you can load the model into your favorite modeling package or
      use some command line tools to rotate the object in the orientation you need it
      to be just like you'd edit an image for your website rather than download it and
      apply code to adjust it. Blender even has options when you export to change the
      orientation.

   -  No .MTL file or wrong materials or incompatible parameters

      Above we used a .MTL file above which helped us load materials but there were
      issues. We manually edited the .MTL file to fix. It's also common to look inside
      the .OBJ file to see what materials there are, or to load the .OBJ file in
      THREE.js and walk the scene and print out all the materials. Then, go modify the
      code to make custom materials and assign them where appropriate either by making
      a name/material pair object to pass to the loader instead of loading the .MTL
      file, OR, after the scene has loaded, walking the scene and fixing things.

   -  Textures too large

      Most 3D models are made for either architecture, movies and commercials, or
      games. For architecture and movies no one really cares about the size of the
      textures since. For games people care because games have limited memory but most
      games run locally. Webpages though you want to load as fast as possible and so
      you need to look at the textures and try to make them as small as possible and
      still look good. In fact the first windmill we should arguably done something
      about the textures. They are currently a total of 10meg!!!

      Also remember like we mentioned in the `article on textures <textures>`
      that textures take memory so a 50k JPG that expands to 4096x4096 will download
      fast but still take a ton of memory.

   The last thing I wanted to show is spinning the windmills. Unfortunately, .OBJ files
   have no hierarchy. That means all parts of each windmill are basically considered 1
   single mesh. You can't spin the blades of the mill as they aren't separated from the
   rest of the building.

   This is one of the main reasons why .OBJ is not really a good format. If I was to
   guess, the reason it's more common than other formats is because it's simple and
   doesn't support many features it works more often than not. Especially if you're
   making something still like an architectural image and there's no need to animate
   anything it's not a bad way to get static props into a scene.

   Next up we'll try `loading a gLTF scene <load-gltf>`. The gLTF format
   supports many more features.



.. _F27:

Load a .GLTF file
=================

   -  `Load a .GLTF file <https://threejs.org/manual/en/load-gltf.html>`__


   In a previous lesson we `loaded an .OBJ file <load-obj>`. If you haven't read
   it you might want to check it out first.

   As pointed out over there the .OBJ file format is very old and fairly simple. It
   provides no scene graph so everything loaded is one large mesh. It was designed
   mostly as a simple way to pass data between 3D editors.

   `The gLTF format <https://github.com/KhronosGroup/glTF>`__ is actually a format
   designed from the ground up for be used for displaying graphics. 3D formats can be
   divided into 3 or 4 basic types.

   -  3D Editor Formats

      This are formats specific to a single app. .blend (Blender), .max (3d Studio
      Max), .mb and .ma (Maya), etc...

   -  Exchange formats

      These are formats like .OBJ, .DAE (Collada), .FBX. They are designed to help
      exchange information between 3D editors. As such they are usually much larger
      than needed with extra info used only inside 3d editors

   -  App formats

      These are usually specific to certain apps, usually games.

   -  Transmission formats

      gLTF might be the first true transmission format. I suppose VRML might be
      considered one but VRML was actually a pretty poor format.

      gLTF is designed to do some things well that all those other formats don't do

      #. Be small for transmission

         For example this means much of their large data, like vertices, is stored in
         binary. When you download a .gLTF file that data can be uploaded to the GPU
         with zero processing. It's ready as is. This is in contrast to say VRML, .OBJ,
         or .DAE where vertices are stored as text and have to be parsed. Text vertex
         positions can easily be 3x to 5x larger than binary.

      #. Be ready to render

         This again is different from other formats except maybe App formats. The data
         in a glTF file is mean to be rendered, not edited. Data that's not important
         to rendering has generally been removed. Polygons have been converted to
         triangles. Materials have known values that are supposed to work everywhere.

   gLTF was specifically designed so you should be able to download a glTF file and
   display it with a minimum of trouble. Let's cross our fingers that's truly the case
   as none of the other formats have been able to do this.

   I wasn't really sure what I should show. At some level loading and displaying a gLTF
   file is simpler than an .OBJ file. Unlike a .OBJ file materials are directly part of
   the format. That said I thought I should at least load one up and I think going over
   the issues I ran into might provide some good info.

   Searching the net I found `this low-poly city <https://sketchfab.com/models/edd1c604e1e045a0a2a552ddd9a293e6>`__ 
   by `antonmoek <https://sketchfab.com/antonmoek>`__ which seemed like if we're lucky
   might make a good example.

   .. image:: https://threejs.org/manual/resources/images/cartoon_lowpoly_small_city_free_pack.jpg


   Starting with `an example from the .OBJ article <load-obj>` I removed the
   code for loading .OBJ and replaced it with code for loading .GLTF

   The old .OBJ code was


   .. code:: javascript

      const mtlLoader = new MTLLoader();
      mtlLoader.loadMtl('resources/models/windmill/windmill-fixed.mtl', (mtl) => {
         mtl.preload();
         mtl.materials.Material.side = THREE.DoubleSide;
         objLoader.setMaterials(mtl);
         objLoader.load('resources/models/windmill/windmill.obj', (event) => {
            const root = event.detail.loaderRootNode;
            scene.add(root);
            ...
         });
      });


   The new .GLTF code is


   .. code:: javascript

      {
         const gltfLoader = new GLTFLoader();
         const url = 'resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf';
         gltfLoader.load(url, (gltf) => {
            const root = gltf.scene;
            scene.add(root);
            ...
         });


   I kept the auto framing code as before

   We also need to include the `GLTFLoader </docs/#examples/loaders/GLTFLoader>`__ and we can get rid of the `OBJLoader`.


   .. code:: javascript

      - import {LoaderSupport} from 'three/addons/loaders/LoaderSupport.js';
      - import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';
      - import {MTLLoader} from 'three/addons/loaders/MTLLoader.js';
      + import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';


   And running that we get


      `click here to open in a separate window <https://threejs.org/manual/examples/load-gltf.html>`__

   Magic! It just works, textures and all.

   Next I wanted to see if I could animate the cars driving around so I needed to check
   if the scene had the cars as separate entities and if they were setup in a way I
   could use them.

   I wrote some code to dump put the scenegraph to the `JavaScript console <debugging-javascript>`.

   Here's the code to print out the scenegraph.


   .. code:: javascript

      function dumpObject(obj, lines = [], isLast = true, prefix = '') {
         const localPrefix = isLast ? '└─' : '├─';
         lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
         const newPrefix = prefix + (isLast ? '  ' : '│ ');
         const lastNdx = obj.children.length - 1;
         obj.children.forEach((child, ndx) => {
            const isLast = ndx === lastNdx;
            dumpObject(child, lines, isLast, newPrefix);
         });
         return lines;
      }


   And I just called it right after loading the scene.


   .. code:: javascript

      const gltfLoader = new GLTFLoader();
      gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) => {
         const root = gltf.scene;
         scene.add(root);
         console.log(dumpObject(root).join('\n'));


   `Running that <https://threejs.org/manual/examples/load-gltf-dump-scenegraph.html>`__ I got this listing


   .. code:: javascript

      OSG_Scene [Scene]
         └─RootNode_(gltf_orientation_matrix) [Object3D]
            └─RootNode_(model_correction_matrix) [Object3D]
            └─4d4100bcb1c640e69699a87140df79d7fbx [Object3D]
               └─RootNode [Object3D]
                  │ ...
                  ├─Cars [Object3D]
                  │ ├─CAR_03_1 [Object3D]
                  │ │ └─CAR_03_1_World_ap_0 [Mesh]
                  │ ├─CAR_03 [Object3D]
                  │ │ └─CAR_03_World_ap_0 [Mesh]
                  │ ├─Car_04 [Object3D]
                  │ │ └─Car_04_World_ap_0 [Mesh]
                  │ ├─CAR_03_2 [Object3D]
                  │ │ └─CAR_03_2_World_ap_0 [Mesh]
                  │ ├─Car_04_1 [Object3D]
                  │ │ └─Car_04_1_World_ap_0 [Mesh]
                  │ ├─Car_04_2 [Object3D]
                  │ │ └─Car_04_2_World_ap_0 [Mesh]
                  │ ├─Car_04_3 [Object3D]
                  │ │ └─Car_04_3_World_ap_0 [Mesh]
                  │ ├─Car_04_4 [Object3D]
                  │ │ └─Car_04_4_World_ap_0 [Mesh]
                  │ ├─Car_08_4 [Object3D]
                  │ │ └─Car_08_4_World_ap8_0 [Mesh]
                  │ ├─Car_08_3 [Object3D]
                  │ │ └─Car_08_3_World_ap9_0 [Mesh]
                  │ ├─Car_04_1_2 [Object3D]
                  │ │ └─Car_04_1_2_World_ap_0 [Mesh]
                  │ ├─Car_08_2 [Object3D]
                  │ │ └─Car_08_2_World_ap11_0 [Mesh]
                  │ ├─CAR_03_1_2 [Object3D]
                  │ │ └─CAR_03_1_2_World_ap_0 [Mesh]
                  │ ├─CAR_03_2_2 [Object3D]
                  │ │ └─CAR_03_2_2_World_ap_0 [Mesh]
                  │ ├─Car_04_2_2 [Object3D]
                  │ │ └─Car_04_2_2_World_ap_0 [Mesh]
                  ...


   From that we can see all the cars happen to be under a parent called ``"Cars"``


   .. code:: javascript

      *           ├─Cars [Object3D]
                  │ ├─CAR_03_1 [Object3D]
                  │ │ └─CAR_03_1_World_ap_0 [Mesh]
                  │ ├─CAR_03 [Object3D]
                  │ │ └─CAR_03_World_ap_0 [Mesh]
                  │ ├─Car_04 [Object3D]
                  │ │ └─Car_04_World_ap_0 [Mesh]


   So as a simple test I thought I would just try rotating all the children of the
   "Cars" node around their Y axis.

   I looked up the "Cars" node after loading the scene and saved the result.


   .. code:: javascript

      + let cars;
      {
         const gltfLoader = new GLTFLoader();
         gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) => {
            const root = gltf.scene;
            scene.add(root);
      +     cars = root.getObjectByName('Cars');


   Then in the ``render`` function we can just set the rotation of each child of ``cars``.


   .. code:: javascript

      + function render(time) {
      +   time *= 0.001;  // convert to seconds

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

      +   if (cars) {
      +     for (const car of cars.children) {
      +       car.rotation.y = time;
      +     }
      +   }

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   And we get


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-gltf-rotate-cars.html>`__

   Hmmm, it looks like unfortunately this scene wasn't designed to animate the cars as
   their origins are not setup for that purpose. The trucks are rotating in the wrong
   direction.

   This brings up an important point which is if you're going to do something in 3D you
   need to plan ahead and design your assets so they have their origins in the correct
   places, so they are the correct scale, etc.

   Since I'm not an artist and I don't know blender that well I will hack this example.
   We'll take each car and parent it to another ``Object3D``. We will then move those
   ``Object3D`` objects to move the cars but separately we can set the car's original
   ``Object3D`` to re-orient it so it's about where we really need it.

   Looking back at the scene graph listing it looks like there are really only 3 types
   of cars, "Car_08", "CAR_03", and "Car_04". Hopefully each type of car will work with
   the same adjustments.

   I wrote this code to go through each car, parent it to a new ``Object3D``, parent 
   that new ``Object3D`` to the scene, and apply some per car *type* settings to fix 
   its orientation, and add the new ``Object3D`` a ``cars`` array.


   .. code:: javascript

      - let cars;
      + const cars = [];
      {
         const gltfLoader = new GLTFLoader();
         gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) => {
            const root = gltf.scene;
            scene.add(root);

      -     cars = root.getObjectByName('Cars');
      +     const loadedCars = root.getObjectByName('Cars');
      +     const fixes = [
      +       { prefix: 'Car_08', rot: [Math.PI * .5, 0, Math.PI * .5], },
      +       { prefix: 'CAR_03', rot: [0, Math.PI, 0], },
      +       { prefix: 'Car_04', rot: [0, Math.PI, 0], },
      +     ];
      + 
      +     root.updateMatrixWorld();
      +     for (const car of loadedCars.children.slice()) {
      +       const fix = fixes.find(fix => car.name.startsWith(fix.prefix));
      +       const obj = new THREE.Object3D();
      +       car.getWorldPosition(obj.position);
      +       car.position.set(0, 0, 0);
      +       car.rotation.set(...fix.rot);
      +       obj.add(car);
      +       scene.add(obj);
      +       cars.push(obj);
      +     }
            ...


   This fixes the orientation of the cars.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-gltf-rotate-cars-fixed.html>`__

   Now let's drive them around.

   Making even a simple driving system is too much for this post but it seems instead
   we could just make one convoluted path that drives down all the roads and then put
   the cars on the path. Here's a picture from Blender about half way through building
   the path.

   .. image:: https://threejs.org/manual/resources/images/making-path-for-cars.jpg


   I needed a way to get the data for that path out of Blender. Fortunately I was able
   to select just my path and export .OBJ checking "write nurbs".

   .. image:: https://threejs.org/manual/resources/images/blender-export-obj-write-nurbs.jpg


   Opening the .OBJ file I was able to get a list of points which I formatted into this


   .. code:: javascript

      const controlPoints = [
         [1.118281, 5.115846, -3.681386],
         [3.948875, 5.115846, -3.641834],
         [3.960072, 5.115846, -0.240352],
         [3.985447, 5.115846, 4.585005],
         [-3.793631, 5.115846, 4.585006],
         [-3.826839, 5.115846, -14.736200],
         [-14.542292, 5.115846, -14.765865],
         [-14.520929, 5.115846, -3.627002],
         [-5.452815, 5.115846, -3.634418],
         [-5.467251, 5.115846, 4.549161],
         [-13.266233, 5.115846, 4.567083],
         [-13.250067, 5.115846, -13.499271],
         [4.081842, 5.115846, -13.435463],
         [4.125436, 5.115846, -5.334928],
         [-14.521364, 5.115846, -5.239871],
         [-14.510466, 5.115846, 5.486727],
         [5.745666, 5.115846, 5.510492],
         [5.787942, 5.115846, -14.728308],
         [-5.423720, 5.115846, -14.761919],
         [-5.373599, 5.115846, -3.704133],
         [1.004861, 5.115846, -3.641834],
      ];


   THREE.js has some curve classes. The ``CatmullRomCurve3`` seemed like it might work. 
   The thing about that kind of curve is it tries to make a smooth curve going through 
   the points.

   In fact putting those points in directly will generate a curve like this

   .. image:: https://threejs.org/manual/resources/images/car-curves-before.png


   but we want a sharper corners. It seemed like if we computed some extra points we
   could get what we want. For each pair of points we'll compute a point 10% of the way
   between the 2 points and another 90% of the way between the 2 points and pass the
   result to ``CatmullRomCurve3``.

   This will give us a curve like this

   .. image:: https://threejs.org/manual/resources/images/car-curves-after.png


   Here's the code to make the curve


   .. code:: javascript

      let curve;
      let curveObject;
      {
         const controlPoints = [
            [1.118281, 5.115846, -3.681386],
            [3.948875, 5.115846, -3.641834],
            [3.960072, 5.115846, -0.240352],
            [3.985447, 5.115846, 4.585005],
            [-3.793631, 5.115846, 4.585006],
            [-3.826839, 5.115846, -14.736200],
            [-14.542292, 5.115846, -14.765865],
            [-14.520929, 5.115846, -3.627002],
            [-5.452815, 5.115846, -3.634418],
            [-5.467251, 5.115846, 4.549161],
            [-13.266233, 5.115846, 4.567083],
            [-13.250067, 5.115846, -13.499271],
            [4.081842, 5.115846, -13.435463],
            [4.125436, 5.115846, -5.334928],
            [-14.521364, 5.115846, -5.239871],
            [-14.510466, 5.115846, 5.486727],
            [5.745666, 5.115846, 5.510492],
            [5.787942, 5.115846, -14.728308],
            [-5.423720, 5.115846, -14.761919],
            [-5.373599, 5.115846, -3.704133],
            [1.004861, 5.115846, -3.641834],
         ];
         const p0 = new THREE.Vector3();
         const p1 = new THREE.Vector3();
         curve = new THREE.CatmullRomCurve3(
            controlPoints.map((p, ndx) => {
            p0.set(...p);
            p1.set(...controlPoints[(ndx + 1) % controlPoints.length]);
            return [
               (new THREE.Vector3()).copy(p0),
               (new THREE.Vector3()).lerpVectors(p0, p1, 0.1),
               (new THREE.Vector3()).lerpVectors(p0, p1, 0.9),
            ];
            }).flat(),
            true,
         );
         {
            const points = curve.getPoints(250);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({color: 0xff0000});
            curveObject = new THREE.Line(geometry, material);
            scene.add(curveObject);
         }
      }


   The first part of that code makes a curve. The second part of that code generates
   250 points from the curve and then creates an object to display the lines made by
   connecting those 250 points.

   Running `the example <https://threejs.org/manual/examples/load-gltf-car-path.html>`__ 
   I didn't see the curve. To make it visible I made it ignore the depth test and render last


   .. code:: javascript

            curveObject = new THREE.Line(geometry, material);
      +     material.depthTest = false;
      +     curveObject.renderOrder = 1;


   And that's when I discovered it was way too small.

   .. image:: https://threejs.org/manual/resources/images/car-curves-too-small.png


   Checking the hierarchy in Blender I found out that the artist had scaled the node
   all the cars are parented to.

   .. image:: https://threejs.org/manual/resources/images/cars-scale-0.01.png


   Scaling is bad for real time 3D apps. It causes all kinds of issues and ends up
   being no end of frustration when doing real time 3D. Artists often don't know this
   because it's so easy to scale an entire scene in a 3D editing program but if you
   decide to make a real time 3D app I suggest you request your artists to never scale
   anything. If they change the scale they should find a way to apply that scale to the
   vertices so that when it ends up making it to your app you can ignore scale.

   And, not just scale, in this case the cars are rotated and offset by their parent,
   the ``Cars`` node. This will make it hard at runtime to move the cars around in
   world space. To be clear, in this case we want cars to drive around in world space
   which is why these issues are coming up. If something that is meant to be
   manipulated in a local space, like the moon revolving around the earth this is less
   of an issue.

   Going back to the function we wrote above to dump the scene graph, let's dump the
   position, rotation, and scale of each node.


   .. code:: javascript

      + function dumpVec3(v3, precision = 3) {
      +   return `${v3.x.toFixed(precision)}, ${v3.y.toFixed(precision)}, ${v3.z.toFixed(precision)}`;
      + }

      function dumpObject(obj, lines, isLast = true, prefix = '') {
         const localPrefix = isLast ? '└─' : '├─';
         lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
      +   const dataPrefix = obj.children.length
      +      ? (isLast ? '  │ ' : '│ │ ')
      +      : (isLast ? '    ' : '│   ');
      +   lines.push(`${prefix}${dataPrefix}  pos: ${dumpVec3(obj.position)}`);
      +   lines.push(`${prefix}${dataPrefix}  rot: ${dumpVec3(obj.rotation)}`);
      +   lines.push(`${prefix}${dataPrefix}  scl: ${dumpVec3(obj.scale)}`);
         const newPrefix = prefix + (isLast ? '  ' : '│ ');
         const lastNdx = obj.children.length - 1;
         obj.children.forEach((child, ndx) => {
            const isLast = ndx === lastNdx;
            dumpObject(child, lines, isLast, newPrefix);
         });
         return lines;
      }


   And the result from `running
   it <https://threejs.org/manual/examples/load-gltf-dump-scenegraph-extra.html>`__


   .. code:: javascript

      OSG_Scene [Scene]
         │   pos: 0.000, 0.000, 0.000
         │   rot: 0.000, 0.000, 0.000
         │   scl: 1.000, 1.000, 1.000
         └─RootNode_(gltf_orientation_matrix) [Object3D]
            │   pos: 0.000, 0.000, 0.000
            │   rot: -1.571, 0.000, 0.000
            │   scl: 1.000, 1.000, 1.000
            └─RootNode_(model_correction_matrix) [Object3D]
            │   pos: 0.000, 0.000, 0.000
            │   rot: 0.000, 0.000, 0.000
            │   scl: 1.000, 1.000, 1.000
            └─4d4100bcb1c640e69699a87140df79d7fbx [Object3D]
               │   pos: 0.000, 0.000, 0.000
               │   rot: 1.571, 0.000, 0.000
               │   scl: 1.000, 1.000, 1.000
               └─RootNode [Object3D]
                  │   pos: 0.000, 0.000, 0.000
                  │   rot: 0.000, 0.000, 0.000
                  │   scl: 1.000, 1.000, 1.000
                  ├─Cars [Object3D]
      *           │ │   pos: -369.069, -90.704, -920.159
      *           │ │   rot: 0.000, 0.000, 0.000
      *           │ │   scl: 1.000, 1.000, 1.000
                  │ ├─CAR_03_1 [Object3D]
                  │ │ │   pos: 22.131, 14.663, -475.071
                  │ │ │   rot: -3.142, 0.732, 3.142
                  │ │ │   scl: 1.500, 1.500, 1.500
                  │ │ └─CAR_03_1_World_ap_0 [Mesh]
                  │ │       pos: 0.000, 0.000, 0.000
                  │ │       rot: 0.000, 0.000, 0.000
                  │ │       scl: 1.000, 1.000, 1.000


   This shows us that ``Cars`` in the original scene has had its rotation and scale
   removed and applied to its children. That suggests either whatever exporter was used
   to create the .GLTF file did some special work here or more likely the artist
   exported a different version of the file than the corresponding .blend file, which
   is why things don't match.

   The moral of that is I should have probably downloaded the .blend file and exported
   myself. Before exporting I should have inspected all the major nodes and removed any
   transformations.

   All these nodes at the top


   .. code:: javascript

      OSG_Scene [Scene]
         │   pos: 0.000, 0.000, 0.000
         │   rot: 0.000, 0.000, 0.000
         │   scl: 1.000, 1.000, 1.000
         └─RootNode_(gltf_orientation_matrix) [Object3D]
            │   pos: 0.000, 0.000, 0.000
            │   rot: -1.571, 0.000, 0.000
            │   scl: 1.000, 1.000, 1.000
            └─RootNode_(model_correction_matrix) [Object3D]
            │   pos: 0.000, 0.000, 0.000
            │   rot: 0.000, 0.000, 0.000
            │   scl: 1.000, 1.000, 1.000
            └─4d4100bcb1c640e69699a87140df79d7fbx [Object3D]
               │   pos: 0.000, 0.000, 0.000
               │   rot: 1.571, 0.000, 0.000
               │   scl: 1.000, 1.000, 1.000


   are also a waste.

   Ideally the scene would consist of a single "root" node with no position, rotation,
   or scale. At runtime I could then pull all the children out of that root and parent
   them to the scene itself. There might be children of the root like "Cars" which
   would help me find all the cars but ideally it would also have no translation,
   rotation, or scale so I could re-parent the cars to the scene with the minimal
   amount of work.

   In any case the quickest though maybe not the best fix is to just adjust the object
   we're using to view the curve.

   Here's what I ended up with.

   First I adjusted the position of the curve and found values that seemed to work. I
   then hid it.


   .. code:: javascript

      {
         const points = curve.getPoints(250);
         const geometry = new THREE.BufferGeometry().setFromPoints(points);
         const material = new THREE.LineBasicMaterial({color: 0xff0000});
         curveObject = new THREE.Line(geometry, material);
      +  curveObject.scale.set(100, 100, 100);
      +  curveObject.position.y = -621;
      +  curveObject.visible = false;
         material.depthTest = false;
         curveObject.renderOrder = 1;
         scene.add(curveObject);
      }


   Then I wrote code to move the cars along the curve. For each car we pick a position
   from 0 to 1 along the curve and compute a point in world space using the
   ``curveObject`` to transform the point. We then pick another point slightly further
   down the curve. We set the car's orientation using ``lookAt`` and put the car at the
   mid point between the 2 points.


   .. code:: javascript

      // create 2 Vector3s we can use for path calculations
      const carPosition = new THREE.Vector3();
      const carTarget = new THREE.Vector3();

      function render(time) {
         ...

      -  for (const car of cars) {
      -     car.rotation.y = time;
      -   }

      +   {
      +     const pathTime = time * .01;
      +     const targetOffset = 0.01;
      +     cars.forEach((car, ndx) => {
      +       // a number between 0 and 1 to evenly space the cars
      +       const u = pathTime + ndx / cars.length;
      + 
      +       // get the first point
      +       curve.getPointAt(u % 1, carPosition);
      +       carPosition.applyMatrix4(curveObject.matrixWorld);
      + 
      +       // get a second point slightly further down the curve
      +       curve.getPointAt((u + targetOffset) % 1, carTarget);
      +       carTarget.applyMatrix4(curveObject.matrixWorld);
      + 
      +       // put the car at the first point (temporarily)
      +       car.position.copy(carPosition);
      +       // point the car the second point
      +       car.lookAt(carTarget);
      + 
      +       // put the car between the 2 points
      +       car.position.lerpVectors(carPosition, carTarget, 0.5);
      +     });
      +   }


   and when I ran it I found out for each type of car, their height above their origins
   are not consistently set and so I needed to offset each one a little.


   .. code:: javascript

      const loadedCars = root.getObjectByName('Cars');
      const fixes = [
      -   { prefix: 'Car_08', rot: [Math.PI * .5, 0, Math.PI * .5], },
      -   { prefix: 'CAR_03', rot: [0, Math.PI, 0], },
      -   { prefix: 'Car_04', rot: [0, Math.PI, 0], },
      +   { prefix: 'Car_08', y: 0,  rot: [Math.PI * .5, 0, Math.PI * .5], },
      +   { prefix: 'CAR_03', y: 33, rot: [0, Math.PI, 0], },
      +   { prefix: 'Car_04', y: 40, rot: [0, Math.PI, 0], },
      ];

      root.updateMatrixWorld();
      for (const car of loadedCars.children.slice()) {
         const fix = fixes.find(fix => car.name.startsWith(fix.prefix));
         const obj = new THREE.Object3D();
         car.getWorldPosition(obj.position);
      -  car.position.set(0, 0, 0);
      +   car.position.set(0, fix.y, 0);
         car.rotation.set(...fix.rot);
         obj.add(car);
         scene.add(obj);
         cars.push(obj);
      }


   And the result.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-gltf-animated-cars.html>`__

   Not bad for a few minutes work.

   The last thing I wanted to do is turn on shadows.

   To do this I grabbed all the GUI code from the ``DirectionalLight`` shadows example in
   `the article on shadows <shadows>` and pasted it into our latest code.

   Then, after loading, we need to turn on shadows on all the objects.


   .. code:: javascript

      {
         const gltfLoader = new GLTFLoader();
         gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) => {
            const root = gltf.scene;
            scene.add(root);

      +     root.traverse((obj) => {
      +       if (obj.castShadow !== undefined) {
      +         obj.castShadow = true;
      +         obj.receiveShadow = true;
      +       }
      +     });


   I then spent nearly 4 hours trying to figure out why the shadow helpers were not
   working. It was because I forgot to enable shadows with


   .. code:: javascript

      renderer.shadowMap.enabled = true;


   😭

   I then adjusted the values until our ``DirectionLight``'s shadow camera had a
   frustum that covered the entire scene. These are the settings I ended up with.


   .. code:: javascript

      {
         const color = 0xFFFFFF;
         const intensity = 1;
         const light = new THREE.DirectionalLight(color, intensity);
      +   light.castShadow = true;
      *   light.position.set(-250, 800, -850);
      *   light.target.position.set(-550, 40, -450);

      +   light.shadow.bias = -0.004;
      +   light.shadow.mapSize.width = 2048;
      +   light.shadow.mapSize.height = 2048;

         scene.add(light);
         scene.add(light.target);
      +   const cam = light.shadow.camera;
      +   cam.near = 1;
      +   cam.far = 2000;
      +   cam.left = -1500;
      +   cam.right = 1500;
      +   cam.top = 1500;
      +   cam.bottom = -1500;
      ...


   and I set the background color to light blue.


   .. code:: javascript

      const scene = new THREE.Scene();
      - scene.background = new THREE.Color('black');
      + scene.background = new THREE.Color('#DEFEFF');


   And ... shadows


      `click here to open in a separate
      window <https://threejs.org/manual/examples/load-gltf-shadows.html>`__

   I hope walking through this project was useful and showed some good examples of
   working though some of the issues of loading a file with a scenegraph.

   One interesting thing is that comparing the .blend file to the .gltf file, the
   .blend file has several lights but they are not lights after being loaded into the
   scene. A .GLTF file is just a JSON file so you can easily look inside. It consists
   of several arrays of things and each item in an array is referenced by index else
   where. While there are extensions in the works they point to a problem with almost
   all 3d formats. **They can never cover every case**.

   There is always a need for more data. For example we manually exported a path for
   the cars to follow. Ideally that info could have been in the .GLTF file but to do
   that we'd need to write our own exporter and some how mark nodes for how we want
   them exported or use a naming scheme or something along those lines to get data from
   whatever tool we're using to create the data into our app.

   All of that is left as an exercise to the reader.



.. _F28:

Add a Background or Skybox
==========================

   -  `Add a Background or Skybox <https://threejs.org/manual/en/backgrounds.html>`__


   Most of the articles here use a solid color for a background.

   Adding as static background can be as simple as setting some CSS. Taking an example
   from `the article on making THREE.js responsive <responsive>` we only need to
   change 2 things.

   We need to add some CSS to our canvas to set its background to an image


   .. code:: javascript

      <style>
      body {
            margin: 0;
      }
      #c {
            width: 100%;
            height: 100%;
            display: block;
      +     background: url(resources/images/daikanyama.jpg) no-repeat center center;
      +     background-size: cover;
      }
      </style>


   and we need to tell the ``WebGLRenderer`` to use ``alpha`` so places we are 
   not drawing anything are transparent.


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
      -  const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      +   const renderer = new THREE.WebGLRenderer({
      +     antialias: true,
      +     canvas,
      +     alpha: true,
      +   });


   And we get a background.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/background-css.html>`__

   If we want the background to be able to be affected by `post processing effects 
   <post-processing>` then we need to draw the background using THREE.js.

   THREE.js makes this some what simple. We can just set the background of the scene to
   a texture.


   .. code:: javascript

      const loader = new THREE.TextureLoader();
      const bgTexture = loader.load('resources/images/daikanyama.jpg');
      bgTexture.colorSpace = THREE.SRGBColorSpace;
      scene.background = bgTexture;


   which gives us


      `click here to open in a separate
      window <https://threejs.org/manual/examples/background-scene-background.html>`__

   This gets us a background image but its stretched to fit the screen.

   We can solve this issue by setting the ``repeat`` and ``offset`` properties of the
   texture to show only a portion of image.


   .. code:: javascript

      function render(time) {

         ...

      +   // Set the repeat and offset properties of the background texture
      +   // to keep the image's aspect correct.
      +   // Note the image may not have loaded yet.
      +   const canvasAspect = canvas.clientWidth / canvas.clientHeight;
      +   const imageAspect = bgTexture.image ? bgTexture.image.width / bgTexture.image.height : 1;
      +   const aspect = imageAspect / canvasAspect;
      + 
      +   bgTexture.offset.x = aspect > 1 ? (1 - 1 / aspect) / 2 : 0;
      +   bgTexture.repeat.x = aspect > 1 ? 1 / aspect : 1;
      + 
      +   bgTexture.offset.y = aspect > 1 ? 0 : (1 - aspect) / 2;
      +   bgTexture.repeat.y = aspect > 1 ? 1 : aspect;

         ...

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   and now THREE.js drawing the background. There is no visible difference from the CSS
   version at the top but now if we used a `post processing
   effect <post-processing>` the background would be affected too.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/background-scene-background-fixed-aspect.html>`__

   Of course a static background is not usually what we want in a 3D scene. Instead we
   usually want some kind of *skybox*. A skybox is just that, box with the sky draw on
   it. We put the camera inside the box and it looks like there is a sky in the
   background.

   The most common way to implement a skybox is to make a cube, apply a texture to it,
   draw it from the inside. On each side of the cube put a texture (using texture
   coordinates) that looks like some image of the horizon. It's also often common to
   use a sky sphere or a sky dome with a texture drawn on it. You can probably figure
   that one out on your own. Just make a cube or sphere, `apply a
   texture <textures>`, mark it as ``THREE.BackSide`` so we render the inside
   instead of the outside, and either put it in your scene directly or like above, or,
   make 2 scenes, a special one to draw the skybox/sphere/dome and the normal one to
   draw everything else. You'd use your normal
   ``PerspectiveCamera`` to draw. No need
   for the ``OrthographicCamera``.

   Another solution is to use a *Cubemap*. A Cubemap is a special kind of texture that
   has 6 sides, the sides of a cube. Instead of using standard texture coordinates it
   uses a direction from the center pointing outward to decide where to get a color.

   Here are the 6 images of a cubemap from the computer history museum in Mountain
   View, California.

   .. container:: threejs_center

      |pos-x.jpg| |neg-x.jpg| |pos-y.jpg|

   .. container:: threejs_center

      |neg-y.jpg| |pos-z.jpg| |neg-z.jpg|

.. |pos-x.jpg| image:: https://threejs.org/manual/examples/resources/images/cubemaps/computer-history-museum/pos-x.jpg
.. |neg-x.jpg| image:: https://threejs.org/manual/examples/resources/images/cubemaps/computer-history-museum/neg-x.jpg
.. |pos-y.jpg| image:: https://threejs.org/manual/examples/resources/images/cubemaps/computer-history-museum/pos-y.jpg
.. |neg-y.jpg| image:: https://threejs.org/manual/examples/resources/images/cubemaps/computer-history-museum/neg-y.jpg
.. |pos-z.jpg| image:: https://threejs.org/manual/examples/resources/images/cubemaps/computer-history-museum/pos-z.jpg
.. |neg-z.jpg| image:: https://threejs.org/manual/examples/resources/images/cubemaps/computer-history-museum/neg-z.jpg

   To use them we use ``CubeTextureLoader`` to load them and then use that as a 
   the scene's background.


   .. code:: javascript

      {
         const loader = new THREE.CubeTextureLoader();
         const texture = loader.load([
            'resources/images/cubemaps/computer-history-museum/pos-x.jpg',
            'resources/images/cubemaps/computer-history-museum/neg-x.jpg',
            'resources/images/cubemaps/computer-history-museum/pos-y.jpg',
            'resources/images/cubemaps/computer-history-museum/neg-y.jpg',
            'resources/images/cubemaps/computer-history-museum/pos-z.jpg',
            'resources/images/cubemaps/computer-history-museum/neg-z.jpg',
         ]);
         scene.background = texture;
      }


   At render time we don't need to adjust the texture like we did above


   .. code:: javascript

      function render(time) {

         ...

      -   // Set the repeat and offset properties of the background texture
      -   // to keep the image's aspect correct.
      -   // Note the image may not have loaded yet.
      -  const canvasAspect = canvas.clientWidth / canvas.clientHeight;
      -  const imageAspect = bgTexture.image ? bgTexture.image.width / bgTexture.image.height : 1;
      -  const aspect = imageAspect / canvasAspect;
      - 
      -  bgTexture.offset.x = aspect > 1 ? (1 - 1 / aspect) / 2 : 0;
      -  bgTexture.repeat.x = aspect > 1 ? 1 / aspect : 1;
      - 
      -  bgTexture.offset.y = aspect > 1 ? 0 : (1 - aspect) / 2;
      -  bgTexture.repeat.y = aspect > 1 ? 1 : aspect;

         ...

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   Let's add some controls in so we can rotate the camera.


   .. code:: javascript

      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';


      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      - const far = 5;
      + const far = 100;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      - camera.position.z = 2;
      + camera.position.z = 3;

      + const controls = new OrbitControls(camera, canvas);
      + controls.target.set(0, 0, 0);
      + controls.update();


   and try it out. Drag on the example to rotate the camera and see the cubemap
   surrounds us.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/background-cubemap.html>`__

   Another option is to use an Equirectangular map. This is the kind of picture a `360
   camera <https://bing.com/search?q=360+camera>`__ takes.

   `Here's one <https://hdrihaven.com/hdri/?h=tears_of_steel_bridge>`__ I found from
   `this site <https://hdrihaven.com>`__.

   .. image:: https://threejs.org/manual/examples/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg



   .. code:: javascript

      {
      -  const loader = new THREE.CubeTextureLoader();
      -  const texture = loader.load([
      -     'resources/images/cubemaps/computer-history-museum/pos-x.jpg',
      -     'resources/images/cubemaps/computer-history-museum/neg-x.jpg',
      -     'resources/images/cubemaps/computer-history-museum/pos-y.jpg',
      -     'resources/images/cubemaps/computer-history-museum/neg-y.jpg',
      -     'resources/images/cubemaps/computer-history-museum/pos-z.jpg',
      -     'resources/images/cubemaps/computer-history-museum/neg-z.jpg',
      -   ]);
      -  scene.background = texture;
      +   const loader = new THREE.TextureLoader();
      +   const texture = loader.load(
      +     'resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg',
      +     () => {
      +       texture.mapping = THREE.EquirectangularReflectionMapping;
      +       texture.colorSpace = THREE.SRGBColorSpace;
      +       scene.background = texture;
      +     });
      }


   And that's all there is to it.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/background-equirectangularmap.html>`__

   Rather than do it at load time you can also convert an equirectangular image to a
   cubemap beforehand. `Here's a site that will do it for
   you <https://matheowis.github.io/HDRI-to-CubeMap/>`__.



.. _F29:

How to Draw Transparent Objects
===============================

   -  `How to Draw Transparent Objects <https://threejs.org/manual/en/transparency.html>`__


   Transparency in three.js is both easy and hard.

   First we'll go over the easy part. Let's make a scene with 8 cubes placed in a 2x2x2
   grid.

   We'll start with the example from `the article on rendering on demand <rendering-on-demand>` 
   which had 3 cubes and modify it to have 8. First let's change our ``makeInstance`` 
   function to take an x, y, and z


   .. code:: javascript

      - function makeInstance(geometry, color) {
      + function makeInstance(geometry, color, x, y, z) {
         const material = new THREE.MeshPhongMaterial({color});

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);

      -  cube.position.x = x;
      +   cube.position.set(x, y, z);

         return cube;
      }


   Then we can create 8 cubes


   .. code:: javascript

      + function hsl(h, s, l) {
      +   return (new THREE.Color()).setHSL(h, s, l);
      + }

      - makeInstance(geometry, 0x44aa88,  0);
      - makeInstance(geometry, 0x8844aa, -2);
      - makeInstance(geometry, 0xaa8844,  2);

      + {
      +   const d = 0.8;
      +   makeInstance(geometry, hsl(0 / 8, 1, .5), -d, -d, -d);
      +   makeInstance(geometry, hsl(1 / 8, 1, .5),  d, -d, -d);
      +   makeInstance(geometry, hsl(2 / 8, 1, .5), -d,  d, -d);
      +   makeInstance(geometry, hsl(3 / 8, 1, .5),  d,  d, -d);
      +   makeInstance(geometry, hsl(4 / 8, 1, .5), -d, -d,  d);
      +   makeInstance(geometry, hsl(5 / 8, 1, .5),  d, -d,  d);
      +   makeInstance(geometry, hsl(6 / 8, 1, .5), -d,  d,  d);
      +   makeInstance(geometry, hsl(7 / 8, 1, .5),  d,  d,  d);
      + }


   I also adjusted the camera


   .. code:: javascript

      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      - const far = 5;
      + const far = 25;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      - camera.position.z = 4;
      + camera.position.z = 2;


   Set the background to white


   .. code:: javascript

      const scene = new THREE.Scene();
      + scene.background = new THREE.Color('white');


   And added a second light so all sides of the cubes get some lighting.


   .. code:: javascript

      - {
      + function addLight(...pos) {
         const color = 0xFFFFFF;
         const intensity = 1;
         const light = new THREE.DirectionalLight(color, intensity);
      -  light.position.set(-1, 2, 4);
      +   light.position.set(...pos);
         scene.add(light);
      }
      + addLight(-1, 2, 4);
      + addLight( 1, -1, -2);


   To make the cubes transparent we just need to set the ``transparent`` flag and to set
   an ``opacity`` level with 1 being completely opaque and 0 being completely transparent.


   .. code:: javascript

      function makeInstance(geometry, color, x, y, z) {
      -  const material = new THREE.MeshPhongMaterial({color});
      +   const material = new THREE.MeshPhongMaterial({
      +     color,
      +     opacity: 0.5,
      +     transparent: true,
      +   });

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);

         cube.position.set(x, y, z);

         return cube;
      }


   and with that we get 8 transparent cubes


      `click here to open in a separate window <https://threejs.org/manual/examples/transparency.html>`__

   Drag on the example to rotate the view.

   So it seems easy but ... look closer. The cubes are missing their backs.

   .. figure:: https://threejs.org/manual/resources/images/transparency-cubes-no-backs.png

      no backs

   We learned about the ``side`` material
   property in `the article on materials <materials>`. So, let's set it to
   ``THREE.DoubleSide`` to get both sides of each cube to be drawn.


   .. code:: javascript

      const material = new THREE.MeshPhongMaterial({
         color,
         map: loader.load(url),
         opacity: 0.5,
         transparent: true,
      +   side: THREE.DoubleSide,
      });


   And we get


      `click here to open in a separate
      window <https://threejs.org/manual/examples/transparency-doubleside.html>`__

   Give it a spin. It kind of looks like it's working as we can see backs except on
   closer inspection sometimes we can't.

   .. figure:: https://threejs.org/manual/resources/images/transparency-cubes-some-backs.png

      the left back face of each cube is missing

   This happens because of the way 3D objects are generally drawn. For each geometry
   each triangle is drawn one at a time. When each pixel of the triangle is drawn 2
   things are recorded. One, the color for that pixel and two, the depth of that pixel.
   When the next triangle is drawn, for each pixel if the depth is deeper than the
   previously recorded depth no pixel is drawn.

   This works great for opaque things but it fails for transparent things.

   The solution is to sort transparent things and draw the stuff in back before drawing
   the stuff in front. THREE.js does this for objects like ``Mesh`` otherwise the very 
   first example would have failed between cubes with some cubes blocking out others. 
   Unfortunately for individual triangles shorting would be extremely slow.

   The cube has 12 triangles, 2 for each face, and the order they are drawn is `the
   same order they are built in the geometry <custom-buffergeometry>` so depending 
   on which direction we are looking the triangles closer to the camera might
   get drawn first. In that case the triangles in the back aren't drawn. This is why
   sometimes we don't see the backs.

   For a convex object like a sphere or a cube one kind of solution is to add every
   cube to the scene twice. Once with a material that draws only the back facing
   triangles and another with a material that only draws the front facing triangles.


   .. code:: javascript

      function makeInstance(geometry, color, x, y, z) {
      +   [THREE.BackSide, THREE.FrontSide].forEach((side) => {
            const material = new THREE.MeshPhongMaterial({
            color,
            opacity: 0.5,
            transparent: true,
      +       side,
            });

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            cube.position.set(x, y, z);
      +   });
      }


   Any with that it *seems* to work.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/transparency-doubleside-hack.html>`__

   It assumes that the three.js's sorting is stable. Meaning that because we added the
   ``side: THREE.BackSide`` mesh first and because it's at the exact same position that
   it will be drawn before the ``side: THREE.FrontSide`` mesh.

   Let's make 2 intersecting planes (after deleting all the code related to cubes).
   We'll `add a texture <textures>` to each plane.


   .. code:: javascript

      const planeWidth = 1;
      const planeHeight = 1;
      const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

      const loader = new THREE.TextureLoader();

      function makeInstance(geometry, color, rotY, url) {
         const texture = loader.load(url, render);
         const material = new THREE.MeshPhongMaterial({
            color,
            map: texture,
            opacity: 0.5,
            transparent: true,
            side: THREE.DoubleSide,
         });

         const mesh = new THREE.Mesh(geometry, material);
         scene.add(mesh);

         mesh.rotation.y = rotY;
      }

      makeInstance(geometry, 'pink',       0,             'resources/images/happyface.png');
      makeInstance(geometry, 'lightblue',  Math.PI * 0.5, 'resources/images/hmmmface.png');


   This time we can use ``side: THREE.DoubleSide`` since we can only ever see one side
   of a plane at a time. Also note we pass our ``render`` function to the texture
   loading function so that when the texture finishes loading we re-render the scene.
   This is because this sample is `rendering on demand <rendering-on-demand>`
   instead of rendering continuously.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/transparency-intersecting-planes.html>`__

   And again we see a similar issue.

   .. figure:: https://threejs.org/manual/resources/images/transparency-planes.png

      half a face is missing


   The solution here is to manually split the each pane into 2 panes so that there
   really is no intersection.


   .. code:: javascript

      function makeInstance(geometry, color, rotY, url) {
      +   const base = new THREE.Object3D();
      +   scene.add(base);
      +   base.rotation.y = rotY;

      +   [-1, 1].forEach((x) => {
            const texture = loader.load(url, render);
      +     texture.offset.x = x < 0 ? 0 : 0.5;
      +     texture.repeat.x = .5;
            const material = new THREE.MeshPhongMaterial({
            color,
            map: texture,
            opacity: 0.5,
            transparent: true,
            side: THREE.DoubleSide,
            });

            const mesh = new THREE.Mesh(geometry, material);
      -     scene.add(mesh);
      +     base.add(mesh);

      -     mesh.rotation.y = rotY;
      +     mesh.position.x = x * .25;
         });
      }


   How you accomplish that is up to you. If I was using modeling package like
   `Blender <https://blender.org>`__ I'd probably do this manually by adjusting texture
   coordinates. Here though we're using ``PlaneGeometry`` which by default
   stretches the texture across the plane. Like we `covered before <textures>`
   By setting the ``texture.repeat`` and ``texture.offset`` we can scale and move
   the texture to get the correct half of the face texture on each plane.

   The code above also makes a ``Object3D`` and parents the 2 planes to it. It seemed 
   easier to rotate a parent ``Object3D`` than to do the math required do it without.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/transparency-intersecting-planes-fixed.html>`__

   This solution really only works for simple things like 2 planes that are not
   changing their intersection position.

   For textured objects one more solution is to set an alpha test.

   An alpha test is a level of *alpha* below which three.js will not draw the pixel. If
   we don't draw a pixel at all then the depth issues mentioned above disappear. For
   relatively sharp edged textures this works pretty well. Examples include leaf
   textures on a plant or tree or often a patch of grass.

   Let's try on the 2 planes. First let's use different textures. The textures above
   were 100% opaque. These 2 use transparency.

   .. container:: spread

      .. image:: https://threejs.org/manual/examples/resources/images/tree-01.png

      .. image:: https://threejs.org/manual/examples/resources/images/tree-02.png


   Going back to the 2 planes that intersect (before we split them) let's use these
   textures and set an ``alphaTest``.


   .. code:: javascript

      function makeInstance(geometry, color, rotY, url) {
         const texture = loader.load(url, render);
         const material = new THREE.MeshPhongMaterial({
            color,
            map: texture,
      -     opacity: 0.5,
            transparent: true,
      +     alphaTest: 0.5,
            side: THREE.DoubleSide,
         });

         const mesh = new THREE.Mesh(geometry, material);
         scene.add(mesh);

         mesh.rotation.y = rotY;
      }

      - makeInstance(geometry, 'pink',       0,             'resources/images/happyface.png');
      - makeInstance(geometry, 'lightblue',  Math.PI * 0.5, 'resources/images/hmmmface.png');
      + makeInstance(geometry, 'white', 0,             'resources/images/tree-01.png');
      + makeInstance(geometry, 'white', Math.PI * 0.5, 'resources/images/tree-02.png');


   Before we run this let's add a small UI so we can more easily play with the
   ``alphaTest`` and ``transparent`` settings. We'll use lil-gui like we introduced in
   the `article on three.js's scenegraph <scenegraph>`.

   First we'll make a helper for lil-gui that sets every material in the scene to a
   value


   .. code:: javascript

      class AllMaterialPropertyGUIHelper {
         constructor(prop, scene) {
            this.prop = prop;
            this.scene = scene;
         }
         get value() {
            const {scene, prop} = this;
            let v;
            scene.traverse((obj) => {
            if (obj.material && obj.material[prop] !== undefined) {
               v = obj.material[prop];
            }
            });
            return v;
         }
         set value(v) {
            const {scene, prop} = this;
            scene.traverse((obj) => {
            if (obj.material && obj.material[prop] !== undefined) {
               obj.material[prop] = v;
               obj.material.needsUpdate = true;
            }
            });
         }
      }


   Then we'll add the gui


   .. code:: javascript

      const gui = new GUI();
      gui.add(new AllMaterialPropertyGUIHelper('alphaTest', scene), 'value', 0, 1)
            .name('alphaTest')
            .onChange(requestRenderIfNotRequested);
      gui.add(new AllMaterialPropertyGUIHelper('transparent', scene), 'value')
            .name('transparent')
            .onChange(requestRenderIfNotRequested);


   and of course we need to include lil-gui


   .. code:: javascript

      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      + import {GUI} from 'three/addons/libs/lil-gui.module.min.js';


   and here's the results


      `click here to open in a separate
      window <https://threejs.org/manual/examples/transparency-intersecting-planes-alphatest.html>`__

   You can see it works but zoom in and you'll see one plane has white lines.

   .. image:: https://threejs.org/manual/resources/images/transparency-alphatest-issues.png


   This is the same depth issue from before. That plane was drawn first so the plane
   behind is not drawn. There is no perfect solution. Adjust the ``alphaTest`` and/or
   turn off ``transparent`` to find a solution that fits your use case.

   The take way from this article is perfect transparency is hard. There are issues and
   trade offs and workarounds.

   For example say you have a car. Cars usually have windshields on all 4 sides. If you
   want to avoid the sorting issues above you'd have to make each window its own object
   so that three.js can sort the windows and draw them in the correct order.

   If you are making some plants or grass the alpha test solution is common.

   Which solution you pick depends on your needs.



.. _F30:

Multiple Canvases, Multiple Scenes
==================================

   -  `Multiple Canvases, Multiple Scenes <https://threejs.org/manual/en/multiple-scenes.html>`__


   A common question is how to use THREE.js with multiple canvases. Let's say you want
   to make an e-commerce site or you want to make a page with lots of 3D diagrams. At
   first glance it appears easy. Just make a canvas every where you want a diagram. For
   each canvas make a ``Renderer``.

   You'll quickly find though that you run into problems.

   #. The browser limits how many WebGL contexts you can have.

      Typically that limit is around 8 of them. As soon as you create the 9th context
      the oldest one will be lost.

   #. WebGL resources can not be shared across contexts

      That means if you want to load a 10 meg model into 2 canvases and that model uses
      20 meg of textures your 10 meg model will have to be loaded twice and your
      textures will also be loaded twice. Nothing can be shared across contexts. This
      also means things have to be initialized twice, shaders compiled twice, etc. It
      gets worse as there are more canvases.

   So what's the solution?

   The solution is one canvas that fills the viewport in the background and some other
   element to represent each "virtual" canvas. We make a single
   ``Renderer`` and then one
   ``Scene`` for each virtual canvas. We'll then check
   the positions of the virtual canvas elements and if they are on the screen we'll
   tell THREE.js to draw their scene at the correct place.

   With this solution there is only 1 canvas so we solve both problem 1 and 2 above. We
   won't run into the WebGL context limit because we will only be using one context. We
   also won't run into the sharing issues for the same reasons.

   Let's start with a simple example with just 2 scenes. First we'll make the HTML


   .. code:: javascript

      <canvas id="c"></canvas>
      <p>
         <span id="box" class="diagram left"></span>
         I love boxes. Presents come in boxes.
         When I find a new box I'm always excited to find out what's inside.
      </p>
      <p>
         <span id="pyramid" class="diagram right"></span>
         When I was a kid I dreamed of going on an expedition inside a pyramid
         and finding a undiscovered tomb full of mummies and treasure.
      </p>


   Then we can setup the CSS maybe something like this


   .. code:: javascript

      #c {
         position: fixed;
         left: 0;
         top: 0;
         width: 100%;
         height: 100%;
         display: block;
         z-index: -1;
      }
      .diagram {
         display: inline-block;
         width: 5em;
         height: 3em;
         border: 1px solid black;
      }
      .left {
         float: left;
         margin-right: .25em;
      }
      .right {
         float: right;
         margin-left: .25em;
      }


   We set the canvas to fill the screen and we set its ``z-index`` to -1 to make it
   appear behind other elements. We also need to specify some kind of width and height
   for our virtual canvas elements since there is nothing inside to give them any size.

   Now we'll make 2 scenes each with a light and a camera. To one scene we'll add a
   cube and to another a diamond.


   .. code:: javascript

      function makeScene(elem) {
         const scene = new THREE.Scene();

         const fov = 45;
         const aspect = 2;  // the canvas default
         const near = 0.1;
         const far = 5;
         const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
         camera.position.z = 2;
         camera.position.set(0, 1, 2);
         camera.lookAt(0, 0, 0);

         {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1, 2, 4);
            scene.add(light);
         }

         return {scene, camera, elem};
      }

      function setupScene1() {
         const sceneInfo = makeScene(document.querySelector('#box'));
         const geometry = new THREE.BoxGeometry(1, 1, 1);
         const material = new THREE.MeshPhongMaterial({color: 'red'});
         const mesh = new THREE.Mesh(geometry, material);
         sceneInfo.scene.add(mesh);
         sceneInfo.mesh = mesh;
         return sceneInfo;
      }

      function setupScene2() {
         const sceneInfo = makeScene(document.querySelector('#pyramid'));
         const radius = .8;
         const widthSegments = 4;
         const heightSegments = 2;
         const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
         const material = new THREE.MeshPhongMaterial({
            color: 'blue',
            flatShading: true,
         });
         const mesh = new THREE.Mesh(geometry, material);
         sceneInfo.scene.add(mesh);
         sceneInfo.mesh = mesh;
         return sceneInfo;
      }

      const sceneInfo1 = setupScene1();
      const sceneInfo2 = setupScene2();


   And then we'll make a function to render each scene only if the element is on the
   screen. We can tell THREE.js to only render to part of the canvas by turning on the
   *scissor* test with
   ``Renderer.setScissorTest``
   and then setting both the scissor and the viewport with
   ``Renderer.setViewport`` and
   ``Renderer.setScissor``.


   .. code:: javascript

      function renderSceneInfo(sceneInfo) {
         const {scene, camera, elem} = sceneInfo;

         // get the viewport relative position of this element
         const {left, right, top, bottom, width, height} =
            elem.getBoundingClientRect();

         const isOffscreen =
            bottom < 0 ||
            top > renderer.domElement.clientHeight ||
            right < 0 ||
            left > renderer.domElement.clientWidth;

         if (isOffscreen) {
            return;
         }

         camera.aspect = width / height;
         camera.updateProjectionMatrix();

         const positiveYUpBottom = canvasRect.height - bottom;
         renderer.setScissor(left, positiveYUpBottom, width, height);
         renderer.setViewport(left, positiveYUpBottom, width, height);

         renderer.render(scene, camera);
      }


   And then our render function will just first clear the screen and then render each
   scene.


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         resizeRendererToDisplaySize(renderer);

         renderer.setScissorTest(false);
         renderer.clear(true, true);
         renderer.setScissorTest(true);

         sceneInfo1.mesh.rotation.y = time * .1;
         sceneInfo2.mesh.rotation.y = time * .1;

         renderSceneInfo(sceneInfo1);
         renderSceneInfo(sceneInfo2);

         requestAnimationFrame(render);
      }


   And here it is


      `click here to open in a separate
      window <https://threejs.org/manual/examples/multiple-scenes-v1.html>`__

   You can see where the first ``<span>`` is there's a red cube and where the second
   ``span`` is there's a blue diamond.

Syncing up
----------

   The code above works but there is one minor issue. If your scenes are complicated or
   if for whatever reason it takes too long to render, the position of the scenes drawn
   into the canvas will lag behind the rest of the page.

   If we give each area a border


   .. code:: javascript

      .diagram {
         display: inline-block;
         width: 5em;
         height: 3em;
      +   border: 1px solid black;
      }


   And we set the background of each scene


   .. code:: javascript

      const scene = new THREE.Scene();
      + scene.background = new THREE.Color('red');


   And if we `quickly scroll up and down <https://threejs.org/manual/examples/multiple-scenes-v2.html>`__ we'll
   see the issue. Here's a animation of scrolling slowed down by 10x.

   .. container:: threejs_center

      |image1|

   We can switch to a different method which has a different tradeoff. We'll switch the
   canvas's CSS from ``position: fixed`` to ``position: absolute``.


   .. code:: javascript

      #c {
      -  position: fixed;
      +   position: absolute;


   Then we'll set the canvas's transform to move it so the top of the canvas is at the
   top of whatever part the page is currently scrolled to.


   .. code:: javascript

      function render(time) {
         ...

         const transform = `translateY(${window.scrollY}px)`;
         renderer.domElement.style.transform = transform;


   ``position: fixed`` kept the canvas from scrolling at all while the rest of the page
   scrolled over it. ``position: absolute`` will let the canvas scroll with the rest of
   the page which means whatever we draw will stick with the page as it scrolls even if
   we're too slow to render. When we finally get a chance to render then we move the
   canvas so it matches where the page has been scrolled and then we re-render. This
   means only the edges of the window will show some un-rendered bits for a moment but
   `the stuff in the middle of the page should match
   up <https://threejs.org/manual/examples/multiple-scenes-v2.html>`__ and not slide. Here's a view of the
   results of the new method slowed down 10x.

   .. container:: threejs_center

      |image2|

Making it more Generic
----------------------

   Now that we've gotten multiple scenes working let's make this just slightly more
   generic.

   We could make it so the main render function, the one managing the canvas, just has
   a list of elements and their associated render function. For each element it would
   check if the element is on screen and if so call the corresponding render function.
   In this way we'd have a generic system where individual scenes aren't really aware
   they are being rendered in some smaller space.

   Here's the main render function


   .. code:: javascript

      const sceneElements = [];
      function addScene(elem, fn) {
         sceneElements.push({elem, fn});
      }

      function render(time) {
         time *= 0.001;

         resizeRendererToDisplaySize(renderer);

         renderer.setScissorTest(false);
         renderer.setClearColor(clearColor, 0);
         renderer.clear(true, true);
         renderer.setScissorTest(true);

         const transform = `translateY(${window.scrollY}px)`;
         renderer.domElement.style.transform = transform;

         for (const {elem, fn} of sceneElements) {
            // get the viewport relative position of this element
            const rect = elem.getBoundingClientRect();
            const {left, right, top, bottom, width, height} = rect;

            const isOffscreen =
               bottom < 0 ||
               top > renderer.domElement.clientHeight ||
               right < 0 ||
               left > renderer.domElement.clientWidth;

            if (!isOffscreen) {
            const positiveYUpBottom = renderer.domElement.clientHeight - bottom;
            renderer.setScissor(left, positiveYUpBottom, width, height);
            renderer.setViewport(left, positiveYUpBottom, width, height);

            fn(time, rect);
            }
         }

         requestAnimationFrame(render);
      }


   You can see it loops over ``sceneElements`` which it expects is an array of objects
   each of which have an ``elem`` and ``fn`` property.

   It checks if the element is on screen. If it is it calls ``fn`` and passes it the
   current time and its rectangle.

   Now the setup code for each scene just adds itself to the list of scenes


   .. code:: javascript

      {
         const elem = document.querySelector('#box');
         const {scene, camera} = makeScene();
         const geometry = new THREE.BoxGeometry(1, 1, 1);
         const material = new THREE.MeshPhongMaterial({color: 'red'});
         const mesh = new THREE.Mesh(geometry, material);
         scene.add(mesh);
         addScene(elem, (time, rect) => {
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            mesh.rotation.y = time * .1;
            renderer.render(scene, camera);
         });
      }

      {
         const elem = document.querySelector('#pyramid');
         const {scene, camera} = makeScene();
         const radius = .8;
         const widthSegments = 4;
         const heightSegments = 2;
         const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
         const material = new THREE.MeshPhongMaterial({
            color: 'blue',
            flatShading: true,
         });
         const mesh = new THREE.Mesh(geometry, material);
         scene.add(mesh);
         addScene(elem, (time, rect) => {
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            mesh.rotation.y = time * .1;
            renderer.render(scene, camera);
         });
      }


   With that we no longer need ``sceneInfo1`` and ``sceneInfo2`` and the code that was
   rotating the meshes is now specific to each scene.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/multiple-scenes-generic.html>`__

Using HTML Dataset
------------------

   One last even more generic thing we can do is use HTML
   `dataset <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset>`__.
   This is a way to add your own data to an HTML element. Instead of using ``id="..."``
   we'll use ``data-diagram="..."`` like this


   .. code:: javascript

      <canvas id="c"></canvas>
      <p>
      -   <span id="box" class="diagram left"></span>
      +   <span data-diagram="box" class="left"></span>
         I love boxes. Presents come in boxes.
         When I find a new box I'm always excited to find out what's inside.
      </p>
      <p>
      -   <span id="pyramid" class="diagram left"></span>
      +   <span data-diagram="pyramid" class="right"></span>
         When I was a kid I dreamed of going on an expedition inside a pyramid
         and finding a undiscovered tomb full of mummies and treasure.
      </p>


   We can them change the CSS selector to select for that


   .. code:: javascript

      - .diagram
      + *[data-diagram] {
         display: inline-block;
         width: 5em;
         height: 3em;
      }


   We'll change the scene setup code to just be a map of names to *scene initialization
   functions* that return a *scene render function*.


   .. code:: javascript

      const sceneInitFunctionsByName = {
         'box': () => {
            const {scene, camera} = makeScene();
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({color: 'red'});
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            return (time, rect) => {
            mesh.rotation.y = time * .1;
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
            };
         },
         'pyramid': () => {
            const {scene, camera} = makeScene();
            const radius = .8;
            const widthSegments = 4;
            const heightSegments = 2;
            const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
            const material = new THREE.MeshPhongMaterial({
            color: 'blue',
            flatShading: true,
            });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            return (time, rect) => {
            mesh.rotation.y = time * .1;
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
            };
         },
      };


   And to init we can just use ``querySelectorAll`` to find all the diagrams and call
   the corresponding init function for that diagram.


   .. code:: javascript

      document.querySelectorAll('[data-diagram]').forEach((elem) => {
         const sceneName = elem.dataset.diagram;
         const sceneInitFunction = sceneInitFunctionsByName[sceneName];
         const sceneRenderFunction = sceneInitFunction(elem);
         addScene(elem, sceneRenderFunction);
      });


   No change to the visuals but the code is even more generic.

Adding Controls to each element
-------------------------------

   Adding interactively, for example a ``TrackballControls`` is just as easy. First we
   add the script for the control.


   .. code:: javascript

      import {TrackballControls} from 'three/addons/controls/TrackballControls.js';


   And then we can add a ``TrackballControls`` to each scene passing in the element
   associated with that scene.


   .. code:: javascript

      - function makeScene() {
      + function makeScene(elem) {
         const scene = new THREE.Scene();

         const fov = 45;
         const aspect = 2;  // the canvas default
         const near = 0.1;
         const far = 5;
         const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
         camera.position.set(0, 1, 2);
         camera.lookAt(0, 0, 0);
      +   scene.add(camera);

      +   const controls = new TrackballControls(camera, elem);
      +   controls.noZoom = true;
      +   controls.noPan = true;

         {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1, 2, 4);
      -     scene.add(light);
      +     camera.add(light);
         }

      -  return {scene, camera};
      +  return {scene, camera, controls};
      }


   You'll notice we added the camera to the scene and the light to the camera. This
   makes the light relative to the camera. Since the ``TrackballControls`` are moving
   the camera this is probably what we want. It keeps the light shining on the side of
   the object we are looking at.

   We need up update those controls in our render functions


   .. code:: javascript

      const sceneInitFunctionsByName = {
      -  'box': () => {
      -     const {scene, camera} = makeScene();
      +  'box': (elem) => {
      +     const {scene, camera, controls} = makeScene(elem);
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({color: 'red'});
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            return (time, rect) => {
            mesh.rotation.y = time * .1;
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
      +       controls.handleResize();
      +       controls.update();
            renderer.render(scene, camera);
            };
         },
      -   'pyramid': () => {
      -     const {scene, camera} = makeScene();
      +   'pyramid': (elem) => {
      +     const {scene, camera, controls} = makeScene(elem);
            const radius = .8;
            const widthSegments = 4;
            const heightSegments = 2;
            const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
            const material = new THREE.MeshPhongMaterial({
            color: 'blue',
            flatShading: true,
            });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            return (time, rect) => {
            mesh.rotation.y = time * .1;
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
      +       controls.handleResize();
      +       controls.update();
            renderer.render(scene, camera);
            };
         },
      };


   And now if you drag the objects they'll rotate.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/multiple-scenes-controls.html>`__

   These techniques are used on this site itself. In particular `the article about
   primitives <primitives>` and `the article about materials <materials>`
   use this technique to add the various examples throughout the article.

   One more solution would be to render to an off screen canvas and copy the result to
   a 2D canvas at each element. The advantage to this solution is there is no limit on
   how you can composite each separate area. With the previous solution we and a single
   canvas in the background. With this solution we have normal HTML elements.

   The disadvantage is it's slower because a copy has to happen for each area. How much
   slower depends on the browser and the GPU.

   The changes needed are pretty small

   First we'll change HTML as we no longer need a canvas in the page


   .. code:: javascript

      <body>
      -   <canvas id="c"></canvas>
         ...
      </body>


   then we'll change the CSS


   .. code:: javascript

      - #c {
      -  position: absolute;
      -  left: 0;
      -  top: 0;
      -  width: 100%;
      -  height: 100%;
      -  display: block;
      -  z-index: -1;
      - }
      canvas {
         width: 100%;
         height: 100%;
         display: block;
      }
      * [data-diagram] {
         display: inline-block;
         width: 5em;
         height: 3em;
      }


   We've made all canvases fill their container.

   Now let's change the JavaScript. First we no longer look up the canvas. Instead we
   create one. We also just turn on the scissor test at the beginning.


   .. code:: javascript

      function main() {
      -  const canvas = document.querySelector('#c');
      +   const canvas = document.createElement('canvas');
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas, alpha: true});
      +   renderer.setScissorTest(true);

         ...


   Then for each scene we create a 2D rendering context and append its canvas to the
   element for that scene


   .. code:: javascript

      const sceneElements = [];
      function addScene(elem, fn) {
      +   const ctx = document.createElement('canvas').getContext('2d');
      +   elem.appendChild(ctx.canvas);
      -  sceneElements.push({elem, fn});
      +   sceneElements.push({elem, ctx, fn});
      }


   Then when rendering, if the renderer's canvas is not big enough to render this area
   we increase its size. As well if this area's canvas is the wrong size we change its
   size. Finally we set the scissor and viewport, render the scene for this area, then
   copy the result to the area's canvas.


   .. code:: javascript

      function render(time) {
         time *= 0.001;

      -  resizeRendererToDisplaySize(renderer);
      - 
      -  renderer.setScissorTest(false);
      -  renderer.setClearColor(clearColor, 0);
      -  renderer.clear(true, true);
      -  renderer.setScissorTest(true);
      - 
      -  const transform = `translateY(${window.scrollY}px)`;
      -  renderer.domElement.style.transform = transform;

      -  for (const {elem, fn} of sceneElements) {
      +   for (const {elem, fn, ctx} of sceneElements) {
            // get the viewport relative position of this element
            const rect = elem.getBoundingClientRect();
            const {left, right, top, bottom, width, height} = rect;
      +     const rendererCanvas = renderer.domElement;

            const isOffscreen =
               bottom < 0 ||
      -         top > renderer.domElement.clientHeight ||
      +         top > window.innerHeight ||
               right < 0 ||
      -         left > renderer.domElement.clientWidth;
      +         left > window.innerWidth;

            if (!isOffscreen) {
      -       const positiveYUpBottom = renderer.domElement.clientHeight - bottom;
      -       renderer.setScissor(left, positiveYUpBottom, width, height);
      -       renderer.setViewport(left, positiveYUpBottom, width, height);

      +       // make sure the renderer's canvas is big enough
      +       if (rendererCanvas.width < width || rendererCanvas.height < height) {
      +         renderer.setSize(width, height, false);
      +       }
      + 
      +       // make sure the canvas for this area is the same size as the area
      +       if (ctx.canvas.width !== width || ctx.canvas.height !== height) {
      +         ctx.canvas.width = width;
      +         ctx.canvas.height = height;
      +       }
      + 
      +       renderer.setScissor(0, 0, width, height);
      +       renderer.setViewport(0, 0, width, height);

            fn(time, rect);

      +       // copy the rendered scene to this element's canvas
      +       ctx.globalCompositeOperation = 'copy';
      +       ctx.drawImage(
      +           rendererCanvas,
      +           0, rendererCanvas.height - height, width, height,  // src rect
      +           0, 0, width, height);                              // dst rect
            }
         }

         requestAnimationFrame(render);
      }


   The result looks the same


      `click here to open in a separate
      window <https://threejs.org/manual/examples/multiple-scenes-copy-canvas.html>`__

   One other advantage to this solution is you could potentially use
   `OffscreenCanvas <https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas>`__
   to render from a web worker and still use this technique. Unfortunately as of July
   2020 ``OffscreenCanvas`` is only supported by Chrome.

.. |image1| image:: https://threejs.org/manual/resources/images/multi-view-skew.gif
:class: border
.. |image2| image:: https://threejs.org/manual/resources/images/multi-view-fixed.gif
:class: border


.. _F31:

Picking Objects with the mouse
==============================

   -  `Picking Objects with the mouse <https://threejs.org/manual/en/picking.html>`__


   *Picking* refers to the process of figuring out which object a user clicked on or
   touched. There are tons of ways to implement picking each with their tradeoffs.
   Let's go over the 2 most common.

   Probably the most common way of *picking* is by doing raycasting which means to
   *cast* a ray from the mouse through the frustum of the scene and computing which
   objects that ray intersects. Conceptually it's very simple.

   First we'd take the position of the mouse. We'd convert that into world space by
   applying the camera's projection and orientation. We'd compute a ray from the near
   plane of the camera's frustum to the far plane. Then, for every triangle of every
   object in the scene we'd check if that ray intersects that triangle. If your scene
   has 1000 objects and each object has 1000 triangles then 1 million triangles will
   need to be checked.

   A few optimizations would include first checking if the ray intersects with an
   object's bounding sphere or bounding box, the sphere or box that contains the entire
   object. If the ray doesn't intersect one of those then we don't have to check the
   triangles of that object.

   THREE.js provides a ``RayCaster`` class that does exactly this.

   Let's make a scene with a 100 objects and try picking them. We'll start with an
   example from `the article on responsive pages <responsive>`

   A few changes

   We'll parent the camera to another object so we can spin that other object and the
   camera will move around the scene just like a selfie stick.


   .. code:: javascript

      * const fov = 60;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      * const far = 200;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      * camera.position.z = 30;

      const scene = new THREE.Scene();
      + scene.background = new THREE.Color('white');

      + // put the camera on a pole (parent it to an object)
      + // so we can spin the pole to move the camera around the scene
      + const cameraPole = new THREE.Object3D();
      + scene.add(cameraPole);
      + cameraPole.add(camera);


   and in the ``render`` function we'll spin the camera pole.


   .. code:: javascript

      cameraPole.rotation.y = time * .1;


   Also let's put the light on the camera so the light moves with it.


   .. code:: javascript

      - scene.add(light);
      + camera.add(light);


   Let's generate 100 cubes with random colors in random positions, orientations, and
   scales.


   .. code:: javascript

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

      function rand(min, max) {
         if (max === undefined) {
            max = min;
            min = 0;
         }
         return min + (max - min) * Math.random();
      }

      function randomColor() {
         return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
      }

      const numObjects = 100;
      for (let i = 0; i < numObjects; ++i) {
         const material = new THREE.MeshPhongMaterial({
            color: randomColor(),
         });

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);

         cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
         cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
         cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));
      }


   And finally let's pick.

   Let's make a simple class to manage the picking


   .. code:: javascript

      class PickHelper {
         constructor() {
            this.raycaster = new THREE.Raycaster();
            this.pickedObject = null;
            this.pickedObjectSavedColor = 0;
         }
         pick(normalizedPosition, scene, camera, time) {
            // restore the color if there is a picked object
            if (this.pickedObject) {
            this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
            this.pickedObject = undefined;
            }

            // cast a ray through the frustum
            this.raycaster.setFromCamera(normalizedPosition, camera);
            // get the list of objects the ray intersected
            const intersectedObjects = this.raycaster.intersectObjects(scene.children);
            if (intersectedObjects.length) {
            // pick the first object. It's the closest one
            this.pickedObject = intersectedObjects[0].object;
            // save its color
            this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
            // set its emissive color to flashing red/yellow
            this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
            }
         }
      }


   You can see we create a ``RayCaster`` and then we can call the ``pick`` function to
   cast a ray through the scene. If the ray hits something we change the color of the
   first thing it hits.

   Of course we could call this function only when the user pressed the mouse *down*
   which is probably usually what you want but for this example we'll pick every frame
   whatever is under the mouse. To do this we first need to track where the mouse is


   .. code:: javascript

      const pickPosition = {x: 0, y: 0};
      clearPickPosition();

      ...

      function getCanvasRelativePosition(event) {
         const rect = canvas.getBoundingClientRect();
         return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
         };
      }

      function setPickPosition(event) {
         const pos = getCanvasRelativePosition(event);
         pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
         pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
      }

      function clearPickPosition() {
         // unlike the mouse which always has a position
         // if the user stops touching the screen we want
         // to stop picking. For now we just pick a value
         // unlikely to pick something
         pickPosition.x = -100000;
         pickPosition.y = -100000;
      }

      window.addEventListener('mousemove', setPickPosition);
      window.addEventListener('mouseout', clearPickPosition);
      window.addEventListener('mouseleave', clearPickPosition);


   Notice we're recording a normalized mouse position. Regardless of the size of the
   canvas we need a value that goes from -1 on the left to +1 on the right. Similarly
   we need a value that goes from -1 on the bottom to +1 on the top.

   While we're at it lets support mobile as well


   .. code:: javascript

      window.addEventListener('touchstart', (event) => {
         // prevent the window from scrolling
         event.preventDefault();
         setPickPosition(event.touches[0]);
      }, {passive: false});

      window.addEventListener('touchmove', (event) => {
         setPickPosition(event.touches[0]);
      });

      window.addEventListener('touchend', clearPickPosition);


   And finally in our ``render`` function we call the ``PickHelper``'s ``pick``
   function.


   .. code:: javascript

      + const pickHelper = new PickHelper();

      function render(time) {
         time *= 0.001;  // convert to seconds;

         ...

      +   pickHelper.pick(pickPosition, scene, camera, time);

         renderer.render(scene, camera);

         ...


   and here's the result


      `click here to open in a separate
      window <https://threejs.org/manual/examples/picking-raycaster.html>`__

   This appears to work great and it probably does for many use cases but there are
   several issues.

   #. It's CPU based.

      JavaScript is going through each object and checking if the ray intersects that
      object's bounding box or bounding sphere. If it does then JavaScript has to go
      through each and every triangle in that object and check if the ray intersects
      the triangle.

      The good part of this is JavaScript can easily compute exactly where the ray
      intersected the triangle and provide us with that data. For example if you wanted
      to put a marker where the intersection happened.

      The bad part is that's a lot of work for the CPU to do. If you have objects with
      lots of triangles it might be slow.

   #. It doesn't handle any strange shaders or displacements.

      If you have a shader that deforms or morphs the geometry JavaScript has no
      knowledge of that deformation and so will give the wrong answer. For example
      AFAIK you can't use this method with skinned objects.

   #. It doesn't handle transparent holes.

   As an example let's apply this texture to the cubes.

   .. image:: https://threejs.org/manual/examples/resources/images/frame.png


   We'll just make these changes


   .. code:: javascript

      + const loader = new THREE.TextureLoader();
      + const texture = loader.load('resources/images/frame.png');

      const numObjects = 100;
      for (let i = 0; i < numObjects; ++i) {
         const material = new THREE.MeshPhongMaterial({
            color: randomColor(),
            +map: texture,
            +transparent: true,
            +side: THREE.DoubleSide,
            +alphaTest: 0.1,
         });

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);

         ...


   And running that you should quickly see the issue


      `click here to open in a separate
      window <https://threejs.org/manual/examples/picking-raycaster-transparency.html>`__

   Try to pick something through a box and you can't

   .. image:: https://threejs.org/manual/resources/images/picking-transparent-issue.jpg


   This is because JavaScript can't easily look into the textures and materials and
   figure out if part of your object is really transparent or not.

   A solution all of these issues is to use GPU based picking. Unfortunately while it
   is conceptually simple it is more complicated to use than the ray casting method
   above.

   To do GPU picking we render each object in a unique color offscreen. We then look up
   the color of the pixel corresponding to the mouse position. The color tells us which
   object was picked.

   This can solve issue 2 and 3 above. As for issue 1, speed, it really depends. Every
   object has to be drawn twice. Once to draw it for viewing and again to draw it for
   picking. It's possible with fancier solutions maybe both of those could be done at
   the same time but we're not going to try that.

   One thing we can do though is since we're only going to be reading one pixel we can
   just setup the camera so only that one pixel is drawn. We can do this using
   ``PerspectiveCamera.setViewOffset``
   which lets us tell THREE.js to compute a camera that just renders a smaller part of
   a larger rectangle. This should save some time.

   To do this type of picking in THREE.js at the moment requires we create 2 scenes.
   One we will fill with our normal meshes. The other we'll fill with meshes that use
   our picking material.

   So, first create a second scene and make sure it clears to black.


   .. code:: javascript

      const scene = new THREE.Scene();
      scene.background = new THREE.Color('white');
      const pickingScene = new THREE.Scene();
      pickingScene.background = new THREE.Color(0);


   Then, for each cube we place in the main scene we make a corresponding "picking
   cube" at the same position as the original cube, put it in the ``pickingScene``, and
   set its material to something that will draw the object's id as its color. Also we
   keep a map of ids to objects so when we look up an id later we can map it back to
   its corresponding object.


   .. code:: javascript

      const idToObject = {};
      + const numObjects = 100;
      for (let i = 0; i < numObjects; ++i) {
      +   const id = i + 1;
         const material = new THREE.MeshPhongMaterial({
            color: randomColor(),
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.1,
         });

         const cube = new THREE.Mesh(geometry, material);
         scene.add(cube);
      +   idToObject[id] = cube;

         cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
         cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
         cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));

      +   const pickingMaterial = new THREE.MeshPhongMaterial({
      +     emissive: new THREE.Color().setHex(id, THREE.NoColorSpace),
      +     color: new THREE.Color(0, 0, 0),
      +     specular: new THREE.Color(0, 0, 0),
      +     map: texture,
      +     transparent: true,
      +     side: THREE.DoubleSide,
      +     alphaTest: 0.5,
      +     blending: THREE.NoBlending,
      +   });
      +   const pickingCube = new THREE.Mesh(geometry, pickingMaterial);
      +   pickingScene.add(pickingCube);
      +   pickingCube.position.copy(cube.position);
      +   pickingCube.rotation.copy(cube.rotation);
      +   pickingCube.scale.copy(cube.scale);
      }


   Note that we are abusing the ``MeshPhongMaterial`` here. By setting its ``emissive`` 
   to our id and the ``color`` and ``specular`` to 0 that will end up rendering the id 
   only where the texture's alpha is greater than ``alphaTest``. We also need to set 
   ``blending`` to ``NoBlending`` so that the id is not multiplied by alpha.

   Note that abusing the ``MeshPhongMaterial`` might not be
   the best solution as it will still calculate all our lights when drawing the picking
   scene even though we don't need those calculations. A more optimized solution would
   make a custom shader that just writes the id where the texture's alpha is greater
   than ``alphaTest``.

   Because we're picking from pixels instead of ray casting we can change the code that
   sets the pick position to just use pixels.


   .. code:: javascript

      function setPickPosition(event) {
         const pos = getCanvasRelativePosition(event);
      -  pickPosition.x = (pos.x / canvas.clientWidth ) *  2 - 1;
      -  pickPosition.y = (pos.y / canvas.clientHeight) * -2 + 1;  // note we flip Y
      +   pickPosition.x = pos.x;
      +   pickPosition.y = pos.y;
      }


   Then let's change the ``PickHelper`` into a ``GPUPickHelper``. It will use a
   ``WebGLRenderTarget`` like we
   covered the `article on render targets <rendertargets>`. Our render target
   here is only a single pixel in size, 1x1.


   .. code:: javascript

      - class PickHelper {
      + class GPUPickHelper {
         constructor() {
      -     this.raycaster = new THREE.Raycaster();
      +     // create a 1x1 pixel render target
      +     this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
      +     this.pixelBuffer = new Uint8Array(4);
            this.pickedObject = null;
            this.pickedObjectSavedColor = 0;
         }
         pick(cssPosition, scene, camera, time) {
      +     const {pickingTexture, pixelBuffer} = this;

            // restore the color if there is a picked object
            if (this.pickedObject) {
            this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
            this.pickedObject = undefined;
            }

      +     // set the view offset to represent just a single pixel under the mouse
      +     const pixelRatio = renderer.getPixelRatio();
      +     camera.setViewOffset(
      +         renderer.getContext().drawingBufferWidth,   // full width
      +         renderer.getContext().drawingBufferHeight,  // full top
      +         cssPosition.x * pixelRatio | 0,             // rect x
      +         cssPosition.y * pixelRatio | 0,             // rect y
      +         1,                                          // rect width
      +         1,                                          // rect height
      +     );
      +     // render the scene
      +     renderer.setRenderTarget(pickingTexture)
      +     renderer.render(scene, camera);
      +     renderer.setRenderTarget(null);
      + 
      +     // clear the view offset so rendering returns to normal
      +     camera.clearViewOffset();
      +     //read the pixel
      +     renderer.readRenderTargetPixels(
      +         pickingTexture,
      +         0,   // x
      +         0,   // y
      +         1,   // width
      +         1,   // height
      +         pixelBuffer);
      + 
      +     const id =
      +         (pixelBuffer[0] << 16) |
      +         (pixelBuffer[1] <<  8) |
      +         (pixelBuffer[2]      );

      -     // cast a ray through the frustum
      -     this.raycaster.setFromCamera(normalizedPosition, camera);
      -     // get the list of objects the ray intersected
      -     const intersectedObjects = this.raycaster.intersectObjects(scene.children);
      -     if (intersectedObjects.length) {
      -       // pick the first object. It's the closest one
      -       this.pickedObject = intersectedObjects[0].object;

      +     const intersectedObject = idToObject[id];
      +     if (intersectedObject) {
      +       // pick the first object. It's the closest one
      +       this.pickedObject = intersectedObject;
            // save its color
            this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
            // set its emissive color to flashing red/yellow
            this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
            }
         }
      }


   Then we just need to use it


   .. code:: javascript

      - const pickHelper = new PickHelper();
      + const pickHelper = new GPUPickHelper();


   and pass it the ``pickScene`` instead of the ``scene``.


   .. code:: javascript

      -  pickHelper.pick(pickPosition, scene, camera, time);
      +   pickHelper.pick(pickPosition, pickScene, camera, time);


   And now it should let you pick through the transparent parts


      `click here to open in a separate window <https://threejs.org/manual/examples/picking-gpu.html>`__

   I hope that gives some idea of how to implement picking. In a future article maybe
   we can cover how to manipulate objects with the mouse.



.. _F32:

Post Processing
===============

   -  `Post Processing <https://threejs.org/manual/en/post-processing.html>`__


   *Post processing* generally refers to applying some kind of effect or filter to a 2D
   image. In the case of THREE.js we have a scene with a bunch of meshes in it. We
   render that scene into a 2D image. Normally that image is rendered directly into the
   canvas and displayed in the browser but instead we can `render it to a render
   target <rendertargets>` and then apply some *post processing* effects to the
   result before drawing it to the canvas. It's called post processing because it
   happens after (post) the main scene processing.

   Examples of post processing are Instagram like filters, Photoshop filters, etc...

   THREE.js has some example classes to help setup a post processing pipeline. The way
   it works is you create an ``EffectComposer`` and to it you add multiple ``Pass``
   objects. You then call ``EffectComposer.render`` and it renders your scene to a
   `render target <rendertargets>` and then applies each ``Pass``.

   Each ``Pass`` can be some post processing effect like adding a vignette, blurring,
   applying a bloom, applying film grain, adjusting the hue, saturation, contrast,
   etc... and finally rendering the result to the canvas.

   It's a little bit important to understand how ``EffectComposer`` functions. It
   creates two `render targets <rendertargets>`. Let's call them **rtA** and
   **rtB**.

   Then, you call ``EffectComposer.addPass`` to add each pass in the order you want to
   apply them. The passes are then applied *something like* this.

   .. image:: https://threejs.org/manual/resources/images/threejs-postprocessing.svg


   First the scene you passed into ``RenderPass`` is rendered to **rtA**, then **rtA**
   is passed to the next pass, whatever it is. That pass uses **rtA** as input to do
   whatever it does and writes the results to **rtB**. **rtB** is then passed to the
   next pass which uses **rtB** as input and writes back to **rtA**. This continues
   through all the passes.

   Each ``Pass`` has 4 basic options

   =================== =========================================================
   ``enabled``         Whether or not to use this pass
   ``needsSwap``       Whether or not to swap ``rtA`` and ``rtB`` after finishing this pass
   ``clear``           Whether or not to clear before rendering this pass
   ``renderToScreen``  Whether or not to render to the canvas instead the current destination 
                       render target. In most use cases you do not set this flag explicitly 
                       since the last pass in the pass chain is automatically rendered to screen.
   =================== =========================================================

   Let's put together a basic example. We'll start with the example from `the article
   on responsiveness <responsive>`.

   To that first we create an ``EffectComposer``.


   .. code:: javascript

      const composer = new EffectComposer(renderer);


   Then as the first pass we add a ``RenderPass`` that will render our scene with our
   camera into the first render target.


   .. code:: javascript

      composer.addPass(new RenderPass(scene, camera));


   Next we add a ``BloomPass``. A ``BloomPass`` renders its input to a generally
   smaller render target and blurs the result. It then adds that blurred result on top
   of the original input. This makes the scene *bloom*


   .. code:: javascript

      const bloomPass = new BloomPass(
            1,    // strength
            25,   // kernel size
            4,    // sigma ?
            256,  // blur render target resolution
      );
      composer.addPass(bloomPass);


   Next we had a ``FilmPass`` that draws noise and scanlines on top of its input.


   .. code:: javascript

      const filmPass = new FilmPass(
            0.5,   // intensity
            false,  // grayscale
      );
      composer.addPass(filmPass);


   Finally we had a ``OutputPass`` which performs color space conversion to sRGB and
   optional tone mapping. This pass is usually the last pass of the pass chain.


   .. code:: javascript

      const outputPass = new OutputPass();
      composer.addPass(outputPass);


   To use these classes we need to import a bunch of scripts.


   .. code:: javascript

      import {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';
      import {RenderPass} from 'three/addons/postprocessing/RenderPass.js';
      import {BloomPass} from 'three/addons/postprocessing/BloomPass.js';
      import {FilmPass} from 'three/addons/postprocessing/FilmPass.js';
      import {OutputPass} from 'three/addons/postprocessing/OutputPass.js';


   For pretty much any post processing ``EffectComposer.js``, ``RenderPass.js`` and
   ``OutputPass.js`` are required.

   The last things we need to do are to use ``EffectComposer.render`` instead of
   ``WebGLRenderer.render`` *and* to tell the ``EffectComposer`` to match the size 
   of the canvas.


   .. code:: javascript

      - function render(now) {
      -  time *= 0.001;
      +  let then = 0;
      + function render(now) {
      +  now *= 0.001;  // convert to seconds
      +  const deltaTime = now - then;
      +  then = now;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
      +     composer.setSize(canvas.width, canvas.height);
         }

         cubes.forEach((cube, ndx) => {
            const speed = 1 + ndx * .1;
      -     const rot = time * speed;
      +     const rot = now * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
         });

      -  renderer.render(scene, camera);
      +  composer.render(deltaTime);

         requestAnimationFrame(render);
      }


   ``EffectComposer.render`` takes a ``deltaTime`` which is the time in seconds since
   the last frame was rendered. It passes this to the various effects in case any of
   them are animated. In this case the ``FilmPass`` is animated.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/postprocessing.html>`__

   To change effect parameters at runtime usually requires setting uniform values.
   Let's add a gui to adjust some of the parameters. Figuring out which values you can
   easily adjust and how to adjust them requires digging through the code for that
   effect.

   Looking inside `BloomPass.js <https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/BloomPass.js>`__
   I found this line:


   .. code:: javascript

      this.copyUniforms[ "opacity" ].value = strength;


   So we can set the strength by setting


   .. code:: javascript

      bloomPass.copyUniforms.opacity.value = someValue;


   Similarly looking in `FilmPass.js <https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/FilmPass.js>`__
   I found these lines:


   .. code:: javascript

      this.uniforms.intensity.value = intensity;
      this.uniforms.grayscale.value = grayscale;


   So which makes it pretty clear how to set them.

   Let's make a quick GUI to set those values


   .. code:: javascript

      import {GUI} from 'three/addons/libs/lil-gui.module.min.js';


   and


   .. code:: javascript

      const gui = new GUI();
      {
         const folder = gui.addFolder('BloomPass');
         folder.add(bloomPass.copyUniforms.opacity, 'value', 0, 2).name('strength');
         folder.open();
      }
      {
         const folder = gui.addFolder('FilmPass');
         folder.add(filmPass.uniforms.grayscale, 'value').name('grayscale');
         folder.add(filmPass.uniforms.intensity, 'value', 0, 1).name('intensity');
         folder.open();
      }


   and now we can adjust those settings


      `click here to open in a separate
      window <https://threejs.org/manual/examples/postprocessing-gui.html>`__

   That was a small step to making our own effect.

   Post processing effects use shaders. Shaders are written in a language called 
   `GLSL (Graphics Library Shading Language) <https://www.khronos.org/files/opengles_shading_language.pdf>`__. 
   Going over the entire language is way too large a topic for these articles. A few
   resources to get start from would be maybe `this article <https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html>`__
   and maybe `the Book of Shaders <https://thebookofshaders.com/>`__.

   I think an example to get you started would be helpful though so let's make a simple
   GLSL post processing shader. We'll make one that lets us multiply the image by a
   color.

   For post processing THREE.js provides a useful helper called the ``ShaderPass``. It
   takes an object with info defining a vertex shader, a fragment shader, and the
   default inputs. It will handling setting up which texture to read from to get the
   previous pass's results and where to render to, either one of the
   ``EffectComposer``\ s render target or the canvas.

   Here's a simple post processing shader that multiplies the previous pass's result by
   a color.


   .. code:: javascript

      const colorShader = {
         uniforms: {
            tDiffuse: { value: null },
            color:    { value: new THREE.Color(0x88CCFF) },
         },
         vertexShader: `
            varying vec2 vUv;
            void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
            }
         `,
         fragmentShader: `
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec3 color;
            void main() {
            vec4 previousPassColor = texture2D(tDiffuse, vUv);
            gl_FragColor = vec4(
                  previousPassColor.rgb * color,
                  previousPassColor.a);
            }
         `,
      };


   Above ``tDiffuse`` is the name that ``ShaderPass`` uses to pass in the previous
   pass's result texture so we pretty much always need that. We then declare ``color``
   as a THREE.js ``Color``.

   Next we need a vertex shader. For post processing the vertex shader shown here is
   pretty much standard and rarely needs to be changed. Without going into too many
   details (see articles linked above) the variables ``uv``, ``projectionMatrix``,
   ``modelViewMatrix`` and ``position`` are all magically added by THREE.js.

   Finally we create a fragment shader. In it we get a pixel color from the previous
   pass with this line


   .. code:: javascript

      vec4 previousPassColor = texture2D(tDiffuse, vUv);


   we multiply it by our color and set ``gl_FragColor`` to the result


   .. code:: javascript

      gl_FragColor = vec4(
            previousPassColor.rgb * color,
            previousPassColor.a);


   Adding some simple GUI to set the 3 values of the color


   .. code:: javascript

      const gui = new GUI();
      gui.add(colorPass.uniforms.color.value, 'r', 0, 4).name('red');
      gui.add(colorPass.uniforms.color.value, 'g', 0, 4).name('green');
      gui.add(colorPass.uniforms.color.value, 'b', 0, 4).name('blue');


   Gives us a simple postprocessing effect that multiplies by a color.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/postprocessing-custom.html>`__

   As mentioned about all the details of how to write GLSL and custom shaders is too
   much for these articles. If you really want to know how WebGL itself works then
   check out `these articles <https://webglfundamentals.org>`__. Another great
   resources is just to `read through the existing post processing shaders in the
   THREE.js repo <https://github.com/mrdoob/three.js/tree/master/examples/jsm/shaders>`__. Some
   are more complicated than others but if you start with the smaller ones you can
   hopefully get an idea of how they work.

   Most of the post processing effects in the THREE.js repo are unfortunately
   undocumented so to use them you'll have to `read through the
   examples <https://github.com/mrdoob/three.js/tree/master/examples>`__ or 
   `the code for the effects themselves <https://github.com/mrdoob/three.js/tree/master/examples/jsm/postprocessing>`__.
   Hopefully these simple example and the article on `render
   targets <rendertargets>` provide enough context to get started.



.. _F33:

Using Shadertoy shaders
=======================

   -  `Using Shadertoy shaders <https://threejs.org/manual/en/shadertoy.html>`__


   `Shadertoy <https://shadertoy.com>`__ is a famous website hosting amazing shader
   experiments. People often ask how they can use those shaders with Three.js.

   It's important to recognize it's called Shader **TOY** for a reason. In general
   shadertoy shaders are not about best practices. Rather they are a fun challenge
   similar to say `dwitter <https://dwitter.net>`__ (write code in 140 characters) or
   `js13kGames <https://js13kgames.com>`__ (make a game in 13k or less).

   In the case of Shadertoy the puzzle is, *write a function that for a given pixel
   location outputs a color that draws something interesting*. It's a fun challenge and
   many of the result are amazing. But, it is not best practice.

   Compare `this amazing shadertoy shader that draws an entire
   city <https://www.shadertoy.com/view/XtsSWs>`__

   .. image:: https://threejs.org/manual/resources/images/shadertoy-skyline.png


   Fullscreen on my GPU it runs at about 5 frames a second. Contrast that to `a game
   like Cities: Skylines <https://store.steampowered.com/app/255710/Cities_Skylines/>`__

   .. image:: https://threejs.org/manual/resources/images/cities-skylines.jpg


   This game runs 30-60 frames a second on the same machine because it uses more
   traditional techniques, drawing buildings made from triangles with textures on them,
   etc...

   Still, let's go over using a Shadertoy shader with three.js.

   This is the default shadertoy shader if you `pick "New" on
   shadertoy.com <https://www.shadertoy.com/new>`__, at least as of January 2019.


   .. code:: javascript

      // By iq: https://www.shadertoy.com/user/iq
      // license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
            // Normalized pixel coordinates (from 0 to 1)
            vec2 uv = fragCoord/iResolution.xy;

            // Time varying pixel color
            vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

            // Output to screen
            fragColor = vec4(col,1.0);
      }


   One thing important to understand about shaders is they are written in a language
   called GLSL (Graphics Library Shading Language) designed for 3D math which includes
   special types. Above we see ``vec4``, ``vec2``, ``vec3`` as 3 such special types. A
   ``vec2`` has 2 values, a ``vec3`` 3, a ``vec4`` 4 values. They can be addressed in a
   bunch of ways. The most common ways are with ``x``, ``y``, ``z``, and ``w`` as in


   .. code:: javascript

      vec4 v1 = vec4(1.0, 2.0, 3.0, 4.0);
      float v2 = v1.x + v1.y;  // adds 1.0 + 2.0


   Unlike JavaScript, GLSL is more like C/C++ where variables have to have their type
   declared so instead of ``var v = 1.2;`` it's ``float v = 1.2;`` declaring ``v`` to
   be a floating point number.

   Explaining GLSL in detail is more than we can do in this article. For a quick
   overview see `this article <https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html>`__
   and maybe follow that up with `this series <https://thebookofshaders.com/>`__.

   It should be noted that, at least as of January 2019,
   `shadertoy.com <https://shadertoy.com>`__ only concerns itself with *fragment
   shaders*. A fragment shader's responsibility is, given a pixel location output a
   color for that pixel.

   Looking at the function above we can see the shader has an ``out`` parameter called
   ``fragColor``. ``out`` stands for ``output``. It's a parameter the function is
   expected to provide a value for. We need to set this to some color.

   It also has an ``in`` (for input) parameter called ``fragCoord``. This is the pixel
   coordinate that is about to be drawn. We can use that coordinate to decide on a
   color. If the canvas we're drawing to is 400x300 pixels then the function will be
   called 400x300 times or 120,000 times. Each time ``fragCoord`` will be a different
   pixel coordinate.

   There are 2 more variables being used that are not defined in the code. One is
   ``iResolution``. This is set to the resolution of the canvas. If the canvas is
   400x300 then ``iResolution`` would be 400,300 so as the pixel coordinates change
   that makes ``uv`` go from 0.0 to 1.0 across and up the texture. Working with
   *normalized* values often makes things easier and so the majority of shadertoy
   shaders start with something like this.

   The other undefined variable in the shader is ``iTime``. This is the time since the
   page loaded in seconds.

   In shader jargon these global variables are called *uniform* variables. They are
   called *uniform* because they don't change, they stay uniform from one iteration of
   the shader to the next. It's important to note all of them are specific to
   shadertoy. They not *official* GLSL variables. They are variables the makers of
   shadertoy made up.

   The `Shadertoy docs define several more <https://www.shadertoy.com/howto>`__. For
   now let's write something that handles the two being used in the shader above.

   The first thing to do is let's make a single plane that fills the canvas. If you
   haven't read it yet we did this in `the article on backgrounds <backgrounds>`
   so let's grab that example but remove the cubes. It's pretty short so here's the
   entire thing


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
         renderer.autoClearColor = false;

         const camera = new THREE.OrthographicCamera(
            -1, // left
            1, // right
            1, // top
            -1, // bottom
            -1, // near,
            1, // far
         );
         const scene = new THREE.Scene();
         const plane = new THREE.PlaneGeometry(2, 2);
         const material = new THREE.MeshBasicMaterial({
            color: 'red',
         });
         scene.add(new THREE.Mesh(plane, material));

         function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
               renderer.setSize(width, height, false);
            }
            return needResize;
         }

         function render() {
            resizeRendererToDisplaySize(renderer);

            renderer.render(scene, camera);

            requestAnimationFrame(render);
         }

         requestAnimationFrame(render);
      }

      main();


   As `explained in the backgrounds article <backgrounds>` an ``OrthographicCamera`` 
   with these parameters and a 2 unit plane will fill the canvas. For now all we'll 
   get is a red canvas as our plane is using a red ``MeshBasicMaterial``.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadertoy-prep.html>`__

   Now that we have something working let's add the shadertoy shader.


   .. code:: javascript

      const fragmentShader = `
      #include <common>

      uniform vec3 iResolution;
      uniform float iTime;

      // By iq: https://www.shadertoy.com/user/iq
      // license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
            // Normalized pixel coordinates (from 0 to 1)
            vec2 uv = fragCoord/iResolution.xy;

            // Time varying pixel color
            vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

            // Output to screen
            fragColor = vec4(col,1.0);
      }

      void main() {
         mainImage(gl_FragColor, gl_FragCoord.xy);
      }
      `;


   Above we declared the 2 uniform variables we talked about. Then we inserted the
   shader GLSL code from shadertoy. Finally we called ``mainImage`` passing it
   ``gl_FragColor`` and ``gl_FragCoord.xy``. ``gl_FragColor`` is an official WebGL
   global variable the shader is responsible for setting to whatever color it wants the
   current pixel to be. ``gl_FragCoord`` is another official WebGL global variable that
   tells us the coordinate of the pixel we're currently choosing a color for.

   We then need to setup three.js uniforms so we can supply values to the shader.


   .. code:: javascript

      const uniforms = {
         iTime: { value: 0 },
         iResolution:  { value: new THREE.Vector3() },
      };


   Each uniform in THREE.js has ``value`` parameter. That value has to match the type
   of the uniform.

   Then we pass both the fragment shader and uniforms to a ``ShaderMaterial``.


   .. code:: javascript

      - const material = new THREE.MeshBasicMaterial({
      -     color: 'red',
      - });
      + const material = new THREE.ShaderMaterial({
      +   fragmentShader,
      +   uniforms,
      + });


   and before rendering we need to set the values of the uniforms


   .. code:: javascript

      - function render() {
      + function render(time) {
      +   time *= 0.001;  // convert to seconds

         resizeRendererToDisplaySize(renderer);

      +   const canvas = renderer.domElement;
      +   uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
      +   uniforms.iTime.value = time;

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   ..

      Note: I have no idea why ``iResolution`` is a ``vec3`` and what's in the 3rd
      value `is not documented on shadertoy.com <https://www.shadertoy.com/howto>`__.
      It's not used above so just setting it to 1 for now. ¯\\\_(ツ)\_/¯


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadertoy-basic.html>`__

   This `matches what we see on Shadertoy for a new shader <https://www.shadertoy.com/new>`__, 
   at least as of January 2019 😉. What's the shader above doing?

   -  ``uv`` goes from 0 to 1.
   -  ``cos(uv.xyx)`` gives us 3 cosine values as a ``vec3``. One for ``uv.x``, another
      for ``uv.y`` and another for ``uv.x`` again.
   -  Adding in the time, ``cos(iTime+uv.xyx)`` makes them animate.
   -  Adding in ``vec3(0,2,4)`` as in ``cos(iTime+uv.xyx+vec3(0,2,4))`` offsets the
      cosine waves
   -  ``cos`` goes from -1 to 1 so the ``0.5 * 0.5 + cos(...)`` converts from -1 <-> 1
      to 0.0 <-> 1.0
   -  the results are then used as the RGB color for the current pixel

   A minor change will make it easier to see the cosine waves. Right now ``uv`` only
   goes from 0 to 1. A cosine repeats at 2π so let's make it go from 0 to 40 by
   multiplying by 40.0. That should make it repeat about 6.3 times.


   .. code:: javascript

      - vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));
      + vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx*40.0+vec3(0,2,4));


   Counting below I see about 6.3 repeats. We can see the blue between the red since
   it's offset by 4 via the ``+vec3(0,2,4)``. Without that the blue and red would
   overlap perfectly making purple.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadertoy-basic-x40.html>`__

   Knowing how simple the inputs are and then seeing results like 
   `a city canal <https://www.shadertoy.com/view/MdXGW2>`__, 
   `a forest <https://www.shadertoy.com/view/4ttSWf>`__, 
   `a snail <https://www.shadertoy.com/view/ld3Gz2>`__, 
   `a mushroom <https://www.shadertoy.com/view/4tBXR1>`__ make the challenge all that much
   more impressive. Hopefully they also make it clear why it's not generally the right
   approach vs the more traditional ways of making scenes from triangles. The fact that
   so much math has to be put into computing the color of every pixel means those
   examples run very slow.

   Some shadertoy shaders take textures as inputs like `this
   one <https://www.shadertoy.com/view/MsXSzM>`__.


   .. code:: javascript

      // By Daedelus: https://www.shadertoy.com/user/Daedelus
      // license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
      #define TIMESCALE 0.25
      #define TILES 8
      #define COLOR 0.7, 1.6, 2.8

      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
            vec2 uv = fragCoord.xy / iResolution.xy;
            uv.x *= iResolution.x / iResolution.y;

            vec4 noise = texture2D(iChannel0, floor(uv * float(TILES)) / float(TILES));
            float p = 1.0 - mod(noise.r + noise.g + noise.b + iTime * float(TIMESCALE), 1.0);
            p = min(max(p * 3.0 - 1.8, 0.1), 2.0);

            vec2 r = mod(uv * float(TILES), 1.0);
            r = vec2(pow(r.x - 0.5, 2.0), pow(r.y - 0.5, 2.0));
            p *= 1.0 - pow(min(1.0, 12.0 * dot(r, r)), 2.0);

            fragColor = vec4(COLOR, 1.0) * p;
      }


   Passing a texture into a shader is similar to `passing one into a normal
   material <textures>` but we need to set up the texture on the uniforms.

   First we'll add the uniform for the texture to the shader. They're referred to as
   ``sampler2D`` in GLSL.


   .. code:: javascript

      const fragmentShader = `
      #include <common>

      uniform vec3 iResolution;
      uniform float iTime;
      + uniform sampler2D iChannel0;

      ...


   Then we can load a texture like we covered `here <textures>` and assign the
   uniform's value.


   .. code:: javascript

      + const loader = new THREE.TextureLoader();
      + const texture = loader.load('resources/images/bayer.png');
      + texture.minFilter = THREE.NearestFilter;
      + texture.magFilter = THREE.NearestFilter;
      + texture.wrapS = THREE.RepeatWrapping;
      + texture.wrapT = THREE.RepeatWrapping;
      const uniforms = {
         iTime: { value: 0 },
         iResolution:  { value: new THREE.Vector3() },
      +   iChannel0: { value: texture },
      };


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadertoy-bleepy-blocks.html>`__


   So far we've been using Shadertoy shaders as they are used on
   `Shadertoy.com <https://shadertoy.com>`__, namely drawing to cover the canvas.
   There's no reason we need to limit it to just that use case though. The important
   part to remember is the functions people write on shadertoy generally just take a
   ``fragCoord`` input and a ``iResolution``. ``fragCoord`` does not have to come from
   pixel coordinates, we could use something else like texture coordinates instead and
   could then use them kind of like other textures. This technique of using a function
   to generate textures is often called a `procedural
   texture <https://www.bing.com/search?q=procedural+texture>`__.

   Let's change the shader above to do this. The simplest thing to do might be to take
   the texture coordinates that three.js normally supplies, multiply them by
   ``iResolution`` and pass that in for ``fragCoords``.

   To do that we add in a *varying*. A varying is a value passed from the vertex shader
   to the fragment shader that gets interpolated (or varied) between vertices. To use
   it in our fragment shader we declare it. Three.js refers to its texture coordinates
   as ``uv`` with the ``v`` in front meaning *varying*.


   .. code:: javascript

      ...

      + varying vec2 vUv;

      void main() {
      -  mainImage(gl_FragColor, gl_FragCoord.xy);
      +   mainImage(gl_FragColor, vUv * iResolution.xy);
      }


   Then we need to also provide our own vertex shader. Here is a fairly common minimal
   three.js vertex shader. Three.js declares and will provide values for ``uv``,
   ``projectionMatrix``, ``modelViewMatrix``, and ``position``.


   .. code:: javascript

      const vertexShader = `
         varying vec2 vUv;
         void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
         }
      `;


   We need to pass the vertex shader to the ``ShaderMaterial``


   .. code:: javascript

      const material = new THREE.ShaderMaterial({
         vertexShader,
         fragmentShader,
         uniforms,
      });


   We can set the ``iResolution`` uniform value at init time since it will no longer
   change.


   .. code:: javascript

      const uniforms = {
         iTime: { value: 0 },
      -  iResolution:  { value: new THREE.Vector3() },
      +   iResolution:  { value: new THREE.Vector3(1, 1, 1) },
         iChannel0: { value: texture },
      };


   and we no longer need to set it at render time


   .. code:: javascript

      - const canvas = renderer.domElement;
      - uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
      uniforms.iTime.value = time;


   Otherwise I copied back in the original camera and code that sets up 3 rotating
   cubes from `the article on responsiveness <responsive>`. The result:


      `click here to open in a separate
      window <https://threejs.org/manual/examples/shadertoy-as-texture.html>`__

   I hope this at least gets you started on how to use a shadertoy shader with
   three.js. Again, it's important to remember that most shadertoy shaders are an
   interesting challenge (draw everything with a single function) rather than the
   recommended way to actually display things in a performant way. Still, they are
   amazing, impressive, beautiful, and you can learn a ton by seeing how they work.



.. _F34:

Aligning HTML Elements to 3D
============================

   -  `Aligning HTML Elements to 3D <https://threejs.org/manual/en/align-html-elements-to-3d.html>`__


   This article is part of a series of articles about three.js. The first article is
   `three.js fundamentals <fundamentals>`. If you haven't read that yet and
   you're new to three.js you might want to consider starting there.

   Sometimes you'd like to display some text in your 3D scene. You have many options
   each with pluses and minuses.

   -  Use 3D text

      If you look at the `primitives article <primitives>` you'll see
      ``TextGeometry`` which makes 3D text.
      This might be useful for flying logos but probably not so useful for stats, info,
      or labelling lots of things.

   -  Use a texture with 2D text drawn into it.

      The article on `using a Canvas as a texture <canvas-textures>` shows using
      a canvas as a texture. You can draw text into a canvas and `display it as a
      billboard <billboards>`. The plus here might be that the text is
      integrated into the 3D scene. For something like a computer terminal shown in a
      3D scene this might be perfect.

   -  Use HTML Elements and position them to match the 3D

      The benefits to this approach is you can use all of HTML. Your HTML can have
      multiple elements. It can by styled with CSS. It can also be selected by the user
      as it is actual text.

   This article will cover this last approach.

   Let's start simple. We'll make a 3D scene with a few primitives and then add a label
   to each primitive. We'll start with an example from `the article on responsive
   pages <responsive>`

   We'll add some `OrbitControls` like we did in `the article on lighting <lights>`.


   .. code:: javascript

      import * as THREE from 'three';
      + import {OrbitControls} from 'three/addons/controls/OrbitControls.js';



   .. code:: javascript

      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 0, 0);
      controls.update();


   We need to provide an HTML element to contain our label elements


   .. code:: javascript

      <body>
      -   <canvas id="c"></canvas>
      +   <div id="container">
      +     <canvas id="c"></canvas>
      +     <div id="labels"></div>
      +   </div>
      </body>


   By putting both the canvas and the ``<div id="labels">`` inside a parent container
   we can make them overlap with this CSS


   .. code:: javascript

      #c {
      -     width: 100%;
      -     height: 100%;
      +     width: 100%;  /* let our container decide our size */
      +     height: 100%;
            display: block;
      }
      + #container {
      +   position: relative;  /* makes this the origin of its children */
      +   width: 100%;
      +   height: 100%;
      +   overflow: hidden;
      + }
      + #labels {
      +   position: absolute;  /* let us position ourself inside the container */
      +   left: 0;             /* make our position the top left of the container */
      +   top: 0;
      +   color: white;
      + }


   let's also add some CSS for the labels themselves


   .. code:: javascript

      #labels>div {
         position: absolute;  /* let us position them inside the container */
         left: 0;             /* make their default position the top left of the container */
         top: 0;
         cursor: pointer;     /* change the cursor to a hand when over us */
         font-size: large;
         user-select: none;   /* don't let the text get selected */
         text-shadow:         /* create a black outline */
            -1px -1px 0 #000,
            0   -1px 0 #000,
            1px -1px 0 #000,
            1px  0   0 #000,
            1px  1px 0 #000,
            0    1px 0 #000,
            -1px  1px 0 #000,
            -1px  0   0 #000;
      }
      #labels>div:hover {
         color: red;
      }


   Now into our code we don't have to add too much. We had a function ``makeInstance``
   that we used to generate cubes. Let's make it so it also adds a label element.


   .. code:: javascript

      + const labelContainerElem = document.querySelector('#labels');

      - function makeInstance(geometry, color, x) {
      + function makeInstance(geometry, color, x, name) {
            const material = new THREE.MeshPhongMaterial({color});

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            cube.position.x = x;

      +     const elem = document.createElement('div');
      +     elem.textContent = name;
      +     labelContainerElem.appendChild(elem);

      -     return cube;
      +     return {cube, elem};
         }


   As you can see we're adding a ``<div>`` to the container, one for each cube. We're
   also returning an object with both the ``cube`` and the ``elem`` for the label.

   Calling it we need to provide a name for each


   .. code:: javascript

      const cubes = [
      -  makeInstance(geometry, 0x44aa88,  0),
      -  makeInstance(geometry, 0x8844aa, -2),
      -  makeInstance(geometry, 0xaa8844,  2),
      +  makeInstance(geometry, 0x44aa88,  0, 'Aqua'),
      +  makeInstance(geometry, 0x8844aa, -2, 'Purple'),
      +  makeInstance(geometry, 0xaa8844,  2, 'Gold'),
      ];


   What remains is positioning the label elements at render time


   .. code:: javascript

      const tempV = new THREE.Vector3();

      ...

      - cubes.forEach((cube, ndx) => {
      + cubes.forEach((cubeInfo, ndx) => {
      +   const {cube, elem} = cubeInfo;
         const speed = 1 + ndx * .1;
         const rot = time * speed;
         cube.rotation.x = rot;
         cube.rotation.y = rot;

      +   // get the position of the center of the cube
      +   cube.updateWorldMatrix(true, false);
      +   cube.getWorldPosition(tempV);
      + 
      +   // get the normalized screen coordinate of that position
      +   // x and y will be in the -1 to +1 range with x = -1 being
      +   // on the left and y = -1 being on the bottom
      +   tempV.project(camera);
      + 
      +   // convert the normalized position to CSS coordinates
      +   const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
      +   const y = (tempV.y * -.5 + .5) * canvas.clientHeight;
      + 
      +   // move the elem to that position
      +   elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
      });


   And with that we have labels aligned to their corresponding objects.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/align-html-to-3d.html>`__

   There are a couple of issues we probably want to deal with.

   One is that if we rotate the objects so they overlap all the labels overlap as well.

   .. image:: https://threejs.org/manual/resources/images/overlapping-labels.png


   Another is that if we zoom way out so that the objects go outside the frustum the
   labels will still appear.

   A possible solution to the problem of overlapping objects is to use the `picking
   code from the article on picking <picking>`. We'll pass in the position of
   the object on the screen and then ask the ``RayCaster`` to tell us which objects
   were intersected. If our object is not the first one then we are not in the front.


   .. code:: javascript

      const tempV = new THREE.Vector3();
      + const raycaster = new THREE.Raycaster();

      ...

      cubes.forEach((cubeInfo, ndx) => {
         const {cube, elem} = cubeInfo;
         const speed = 1 + ndx * .1;
         const rot = time * speed;
         cube.rotation.x = rot;
         cube.rotation.y = rot;

         // get the position of the center of the cube
         cube.updateWorldMatrix(true, false);
         cube.getWorldPosition(tempV);

         // get the normalized screen coordinate of that position
         // x and y will be in the -1 to +1 range with x = -1 being
         // on the left and y = -1 being on the bottom
         tempV.project(camera);

      +   // ask the raycaster for all the objects that intersect
      +   // from the eye toward this object's position
      +   raycaster.setFromCamera(tempV, camera);
      +   const intersectedObjects = raycaster.intersectObjects(scene.children);
      +   // We're visible if the first intersection is this object.
      +   const show = intersectedObjects.length && cube === intersectedObjects[0].object;
      + 
      +   if (!show) {
      +     // hide the label
      +     elem.style.display = 'none';
      +   } else {
      +     // un-hide the label
      +     elem.style.display = '';

            // convert the normalized position to CSS coordinates
            const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
            const y = (tempV.y * -.5 + .5) * canvas.clientHeight;

            // move the elem to that position
            elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
      +   }
      });


   This handles overlapping.

   To handle going outside the frustum we can add this check if the origin of the
   object is outside the frustum by checking ``tempV.z``


   .. code:: javascript

      -  if (!show) {
      +   if (!show || Math.abs(tempV.z) > 1) {
            // hide the label
            elem.style.display = 'none';


   This *kind of* works because the normalized coordinates we computed include a ``z``
   value that goes from -1 when at the ``near`` part of our camera frustum to +1 when
   at the ``far`` part of our camera frustum.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/align-html-to-3d-w-hiding.html>`__

   For the frustum check, the solution above fails as we're only checking the origin of
   the object. For a large object. That origin might go outside the frustum but half of
   the object might still be in the frustum.

   A more correct solution would be to check if the object itself is in the frustum or
   not. Unfortunate that check is slow. For 3 cubes it will not be a problem but for
   many objects it might be.

   Three.js provides some functions to check if an object's bounding sphere is in a
   frustum


   .. code:: javascript

      // at init time
      const frustum = new THREE.Frustum();
      const viewProjection = new THREE.Matrix4();

      ...

      // before checking
      camera.updateMatrix();
      camera.updateMatrixWorld();
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

      ...

      // then for each mesh
      someMesh.updateMatrix();
      someMesh.updateMatrixWorld();

      viewProjection.multiplyMatrices(
            camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(viewProjection);
      const inFrustum = frustum.contains(someMesh));


   Our current overlapping solution has similar issues. Picking is slow. We could use
   gpu based picking like we covered in the `picking article <picking>` but that
   is also not free. Which solution you chose depends on your needs.

   Another issue is the order the labels appear. If we change the code to have longer
   labels


   .. code:: javascript

      const cubes = [
      -  makeInstance(geometry, 0x44aa88,  0, 'Aqua'),
      -  makeInstance(geometry, 0x8844aa, -2, 'Purple'),
      -  makeInstance(geometry, 0xaa8844,  2, 'Gold'),
      +  makeInstance(geometry, 0x44aa88,  0, 'Aqua Colored Box'),
      +  makeInstance(geometry, 0x8844aa, -2, 'Purple Colored Box'),
      +  makeInstance(geometry, 0xaa8844,  2, 'Gold Colored Box'),
      ];


   and set the CSS so these don't wrap


   .. code:: javascript

      #labels>div {
      +   white-space: nowrap;


   Then we can run into this issue

   .. image:: https://threejs.org/manual/resources/images/label-sorting-issue.png


   You can see above the purple box is in the back but its label is in front of the
   aqua box.

   We can fix this by setting the ``zIndex`` of each element. The projected position
   has a ``z`` value that goes from -1 in front to positive 1 in back. ``zIndex`` is
   required to be an integer and goes the opposite direction meaning for ``zIndex``
   greater values are in front so the following code should work.


   .. code:: javascript

      // convert the normalized position to CSS coordinates
      const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
      const y = (tempV.y * -.5 + .5) * canvas.clientHeight;

      // move the elem to that position
      elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;

      + // set the zIndex for sorting
      + elem.style.zIndex = (-tempV.z * .5 + .5) * 100000 | 0;


   Because of the way the projected z value works we need to pick a large number to
   spread out the values otherwise many will have the same value. To make sure the
   labels don't overlap with other parts of the page we can tell the browser to create
   a new `stacking context <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context>`__
   by setting the ``z-index`` of the container of the labels


   .. code:: javascript

      #labels {
         position: absolute;  /* let us position ourself inside the container */
      +   z-index: 0;          /* make a new stacking context so children don't sort with rest of page */
         left: 0;             /* make our position the top left of the container */
         top: 0;
         color: white;
         z-index: 0;
      }


   and now the labels should always be in the correct order.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/align-html-to-3d-w-sorting.html>`__

   While we're at it let's do one more example to show one more issue. Let's draw a
   globe like Google Maps and label the countries.

   I found `this data <http://thematicmapping.org/downloads/world_borders.php>`__ which
   contains the borders of countries. It's licensed as
   `CC-BY-SA <http://creativecommons.org/licenses/by-sa/3.0/>`__.

   I `wrote some
   code <https://github.com/mrdoob/three.js/blob/master/manual/resources/tools/geo-picking/>`__
   to load the data, and generate country outlines and some JSON data with the names of
   the countries and their locations.

   .. image:: https://threejs.org/manual/examples/resources/data/world/country-outlines-4k.png


   The JSON data is an array of entries something like this


   .. code:: javascript
      [
         {
            "name": "Algeria",
            "min": [
            -8.667223,
            18.976387
            ],
            "max": [
            11.986475,
            37.091385
            ],
            "area": 238174,
            "lat": 28.163,
            "lon": 2.632,
            "population": {
            "2005": 32854159
            }
         },
         ...


   where min, max, lat, lon, are all in latitude and longitude degrees.

   Let's load it up. The code is based on the examples from `optimizing lots of
   objects <optimize-lots-of-objects>` though we are not drawing lots of objects
   we'll be using the same solutions for `rendering on demand <rendering-on-demand>`.

   The first thing is to make a sphere and use the outline texture.


   .. code:: javascript

      {
         const loader = new THREE.TextureLoader();
         const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
         const geometry = new THREE.SphereGeometry(1, 64, 32);
         const material = new THREE.MeshBasicMaterial({map: texture});
         scene.add(new THREE.Mesh(geometry, material));
      }


   Then let's load the JSON file by first making a loader


   .. code:: javascript

      async function loadJSON(url) {
         const req = await fetch(url);
         return req.json();
      }


   and then calling it


   .. code:: javascript

      let countryInfos;
      async function loadCountryData() {
         countryInfos = await loadJSON('resources/data/world/country-info.json');
            ...
         }
         requestRenderIfNotRequested();
      }
      loadCountryData();


   Now let's use that data to generate and place the labels.

   In the article on `optimizing lots of objects <optimize-lots-of-objects>` we
   had setup a small scene graph of helper objects to make it easy to compute latitude
   and longitude positions on our globe. See that article for an explanation of how
   they work.


   .. code:: javascript

      const lonFudge = Math.PI * 1.5;
      const latFudge = Math.PI;
      // these helpers will make it easy to position the boxes
      // We can rotate the lon helper on its Y axis to the longitude
      const lonHelper = new THREE.Object3D();
      // We rotate the latHelper on its X axis to the latitude
      const latHelper = new THREE.Object3D();
      lonHelper.add(latHelper);
      // The position helper moves the object to the edge of the sphere
      const positionHelper = new THREE.Object3D();
      positionHelper.position.z = 1;
      latHelper.add(positionHelper);


   We'll use that to compute a position for each label


   .. code:: javascript

      const labelParentElem = document.querySelector('#labels');
      for (const countryInfo of countryInfos) {
         const {lat, lon, name} = countryInfo;

         // adjust the helpers to point to the latitude and longitude
         lonHelper.rotation.y = THREE.MathUtils.degToRad(lon) + lonFudge;
         latHelper.rotation.x = THREE.MathUtils.degToRad(lat) + latFudge;

         // get the position of the lat/lon
         positionHelper.updateWorldMatrix(true, false);
         const position = new THREE.Vector3();
         positionHelper.getWorldPosition(position);
         countryInfo.position = position;

         // add an element for each country
         const elem = document.createElement('div');
         elem.textContent = name;
         labelParentElem.appendChild(elem);
         countryInfo.elem = elem;


   The code above looks very similar to the code we wrote for making cube labels making
   an element per label. When we're done we have an array, ``countryInfos``, with one
   entry for each country to which we've added an ``elem`` property for the label
   element for that country and a ``position`` with its position on the globe.

   Just like we did for the cubes we need to update the position of the labels and
   render time.


   .. code:: javascript

      const tempV = new THREE.Vector3();

      function updateLabels() {
         // exit if we have not yet loaded the JSON file
         if (!countryInfos) {
            return;
         }

         for (const countryInfo of countryInfos) {
            const {position, elem} = countryInfo;

            // get the normalized screen coordinate of that position
            // x and y will be in the -1 to +1 range with x = -1 being
            // on the left and y = -1 being on the bottom
            tempV.copy(position);
            tempV.project(camera);

            // convert the normalized position to CSS coordinates
            const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
            const y = (tempV.y * -.5 + .5) * canvas.clientHeight;

            // move the elem to that position
            elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;

            // set the zIndex for sorting
            elem.style.zIndex = (-tempV.z * .5 + .5) * 100000 | 0;
         }
      }


   You can see the code above is substantially similar to the cube example before. The
   only major difference is we pre-computed the label positions at init time. We can do
   this because the globe never moves. Only our camera moves.

   Lastly we need to call ``updateLabels`` in our render loop


   .. code:: javascript

      function render() {
         renderRequested = false;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

         controls.update();

      +   updateLabels();

         renderer.render(scene, camera);
      }


   And this is what we get


      `click here to open in a separate
      window <https://threejs.org/manual/examples/align-html-elements-to-3d-globe-too-many-labels.html>`__

   That is way too many labels!

   We have 2 problems.

   #. Labels facing away from us are showing up.

   #. There are too many labels.

   For issue #1 we can't really use the ``RayCaster`` like we did above as there is
   nothing to intersect except the sphere. Instead what we can do is check if that
   particular country is facing away from us or not. This works because the label
   positions are around a sphere. In fact we're using a unit sphere, a sphere with a
   radius of 1.0. That means the positions are already unit directions making the math
   relatively easy.


   .. code:: javascript

      const tempV = new THREE.Vector3();
      + const cameraToPoint = new THREE.Vector3();
      + const cameraPosition = new THREE.Vector3();
      + const normalMatrix = new THREE.Matrix3();

      function updateLabels() {
         // exit if we have not yet loaded the JSON file
         if (!countryInfos) {
            return;
         }

      +   const minVisibleDot = 0.2;
      +   // get a matrix that represents a relative orientation of the camera
      +   normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
      +   // get the camera's position
      +   camera.getWorldPosition(cameraPosition);
         for (const countryInfo of countryInfos) {
            const {position, elem} = countryInfo;

      +     // Orient the position based on the camera's orientation.
      +     // Since the sphere is at the origin and the sphere is a unit sphere
      +     // this gives us a camera relative direction vector for the position.
      +     tempV.copy(position);
      +     tempV.applyMatrix3(normalMatrix);
      + 
      +     // compute the direction to this position from the camera
      +     cameraToPoint.copy(position);
      +     cameraToPoint.applyMatrix4(camera.matrixWorldInverse).normalize();
      + 
      +     // get the dot product of camera relative direction to this position
      +     // on the globe with the direction from the camera to that point.
      +     // 1 = facing directly towards the camera
      +     // 0 = exactly on tangent of the sphere from the camera
      +     // < 0 = facing away
      +     const dot = tempV.dot(cameraToPoint);
      + 
      +     // if the orientation is not facing us hide it.
      +     if (dot < minVisibleDot) {
      +       elem.style.display = 'none';
      +       continue;
      +     }
      + 
      +     // restore the element to its default display style
      +     elem.style.display = '';

            // get the normalized screen coordinate of that position
            // x and y will be in the -1 to +1 range with x = -1 being
            // on the left and y = -1 being on the bottom
            tempV.copy(position);
            tempV.project(camera);

            // convert the normalized position to CSS coordinates
            const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
            const y = (tempV.y * -.5 + .5) * canvas.clientHeight;

            // move the elem to that position
            countryInfo.elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;

            // set the zIndex for sorting
            elem.style.zIndex = (-tempV.z * .5 + .5) * 100000 | 0;
         }
      }


   Above we use the positions as a direction and get that direction relative to the
   camera. Then we get the camera relative direction from the camera to that position
   on the globe and take the *dot product*. The dot product returns the cosine of the
   angle between the to vectors. This gives us a value from -1 to +1 where -1 means the
   label is facing the camera, 0 means the label is directly on the edge of the sphere
   relative to the camera, and anything greater than zero is behind. We then use that
   value to show or hide the element.

   .. container:: spread

      <div data-diagram="dotProduct" style="height: 400px"></div>

   In the diagram above we can see the dot product of the direction the label is facing
   to direction from the camera to that position. If you rotate the direction you'll
   see the dot product is -1.0 when the direction is directly facing the camera, it's
   0.0 when exactly on the tangent of the sphere relative to the camera or to put it
   another way it's 0 when the 2 vectors are perpendicular to each other, 90 degrees
   It's greater than zero with the label is behind the sphere.

   For issue #2, too many labels we need some way to decide which labels to show. One
   way would be to only show labels for large countries. The data we're loading
   contains min and max values for the area a country covers. From that we can compute
   an area and then use that area to decide whether or not to display the country.

   At init time let's compute the area


   .. code:: javascript

      const labelParentElem = document.querySelector('#labels');
      for (const countryInfo of countryInfos) {
         const {lat, lon, min, max, name} = countryInfo;

         // adjust the helpers to point to the latitude and longitude
         lonHelper.rotation.y = THREE.MathUtils.degToRad(lon) + lonFudge;
         latHelper.rotation.x = THREE.MathUtils.degToRad(lat) + latFudge;

         // get the position of the lat/lon
         positionHelper.updateWorldMatrix(true, false);
         const position = new THREE.Vector3();
         positionHelper.getWorldPosition(position);
         countryInfo.position = position;

      +   // compute the area for each country
      +   const width = max[0] - min[0];
      +   const height = max[1] - min[1];
      +   const area = width * height;
      +   countryInfo.area = area;

         // add an element for each country
         const elem = document.createElement('div');
         elem.textContent = name;
         labelParentElem.appendChild(elem);
         countryInfo.elem = elem;
      }


   Then at render time let's use the area to decide to display the label or not


   .. code:: javascript

      + const large = 20 * 20;
      const maxVisibleDot = 0.2;
      // get a matrix that represents a relative orientation of the camera
      normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
      // get the camera's position
      camera.getWorldPosition(cameraPosition);
      for (const countryInfo of countryInfos) {
      -  const {position, elem} = countryInfo;
      +   const {position, elem, area} = countryInfo;
      +   // large enough?
      +   if (area < large) {
      +     elem.style.display = 'none';
      +     continue;
      +   }

         ...


   Finally, since I'm not sure what good values are for these settings lets add a GUI
   so we can play with them


   .. code:: javascript

      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      + import {GUI} from 'three/addons/libs/lil-gui.module.min.js';



   .. code:: javascript

      + const settings = {
      +   minArea: 20,
      +   maxVisibleDot: -0.2,
      + };
      + const gui = new GUI({width: 300});
      + gui.add(settings, 'minArea', 0, 50).onChange(requestRenderIfNotRequested);
      + gui.add(settings, 'maxVisibleDot', -1, 1, 0.01).onChange(requestRenderIfNotRequested);

      function updateLabels() {
         if (!countryInfos) {
            return;
         }

      -  const large = 20 * 20;
      -  const maxVisibleDot = -0.2;
      +   const large = settings.minArea * settings.minArea;
         // get a matrix that represents a relative orientation of the camera
         normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
         // get the camera's position
         camera.getWorldPosition(cameraPosition);
         for (const countryInfo of countryInfos) {

            ...

            // if the orientation is not facing us hide it.
      -     if (dot > maxVisibleDot) {
      +     if (dot > settings.maxVisibleDot) {
            elem.style.display = 'none';
            continue;
            }


   and here's the result


      `click here to open in a separate
      window <https://threejs.org/manual/examples/align-html-elements-to-3d-globe.html>`__

   You can see as you rotate the earth labels that go behind disappear. Adjust the
   ``minVisibleDot`` to see the cutoff change. You can also adjust the ``minArea``
   value to see larger or smaller countries appear.

   The more I worked on this the more I realized just how much work is put into Google
   Maps. They have also have to decide which labels to show. I'm pretty sure they use
   all kinds of criteria. For example your current location, your default language
   setting, your account settings if you have an account, they probably use population
   or popularity, they might give priority to the countries in the center of the view,
   etc ... Lots to think about.

   In any case I hope these examples gave you some idea of how to align HTML elements
   with your 3D. A few things I might change.

   Next up let's make it so you can `pick and highlight a country <indexed-textures>`.



.. _F35:

Using Indexed Textures for Picking and Color
============================================

   -  `Using Indexed Textures for Picking and Color <https://threejs.org/manual/en/indexed-textures.html>`__


   This article is a continuation of `an article about aligning html elements to
   3d <align-html-elements-to-3d>`. If you haven't read that yet you should
   start there before continuing here.

   Sometimes using three.js requires coming up with creative solutions. I'm not sure
   this is a great solution but I thought I'd share it and you can see if it suggests
   any solutions for your needs.

   In the `previous article <align-html-elements-to-3d>` we displayed country
   names around a 3d globe. How would we go about letting the user select a country and
   show their selection?

   The first idea that comes to mind is to generate geometry for each country. We could
   `use a picking solution <picking>` like we covered before. We'd build 3D
   geometry for each country. If the user clicks on the mesh for that country we'd know
   what country was clicked.

   So, just to check that solution I tried generating 3D meshes of all the countries
   using the same data I used to generate the outlines `in the previous
   article <align-html-elements-to-3d>`. The result was a 15.5meg binary GLTF
   (.glb) file. Making the user download 15.5meg sounds like too much to me.

   There are lots of ways to compress the data. The first would probably be to apply
   some algorithm to lower the resolution of the outlines. I didn't spend any time
   pursuing that solution. For borders of the USA that's probably a huge win. For a
   borders of Canada probably much less.

   Another solution would be to use just actual data compression. For example gzipping
   the file brought it down to 11meg. That's 30% less but arguably not enough.

   We could store all the data as 16bit ranged values instead of 32bit float values. Or
   we could use something like `draco compression <https://google.github.io/draco/>`__
   and maybe that would be enough. I didn't check and I would encourage you to check
   yourself and tell me how it goes as I'd love to know. 😅

   In my case I thought about `the GPU picking solution <picking>` we covered at
   the end of `the article on picking <picking>`. In that solution we drew every
   mesh with a unique color that represented that mesh's id. We then drew all the
   meshes and looked at the color that was clicked on.

   Taking inspiration from that we could pre-generate a map of countries where each
   country's color is its index number in our array of countries. We could then use a
   similar GPU picking technique. We'd draw the globe off screen using this index
   texture. Looking at the color of the pixel the user clicks would tell us the country
   id.

   So, I `wrote some code <https://github.com/mrdoob/three.js/blob/master/manual/resources/tools/geo-picking/>`__
   to generate such a texture. Here it is.

   .. image:: https://threejs.org/manual/examples/resources/data/world/country-index-texture.png


   Note: The data used to generate this texture comes from `this
   website <http://thematicmapping.org/downloads/world_borders.php>`__ and is therefore
   licensed as `CC-BY-SA <http://creativecommons.org/licenses/by-sa/3.0/>`__.

   It's only 217k, much better than the 14meg for the country meshes. In fact we could
   probably even lower the resolution but 217k seems good enough for now.

   So let's try using it for picking countries.

   Grabbing code from the `gpu picking example <picking>` we need a scene for
   picking.


   .. code:: javascript

      const pickingScene = new THREE.Scene();
      pickingScene.background = new THREE.Color(0);


   and we need to add the globe with the our index texture to the picking scene.


   .. code:: javascript

      {
         const loader = new THREE.TextureLoader();
         const geometry = new THREE.SphereGeometry(1, 64, 32);

      +   const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
      +   indexTexture.minFilter = THREE.NearestFilter;
      +   indexTexture.magFilter = THREE.NearestFilter;
      + 
      +   const pickingMaterial = new THREE.MeshBasicMaterial({map: indexTexture});
      +   pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

         const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
         const material = new THREE.MeshBasicMaterial({map: texture});
         scene.add(new THREE.Mesh(geometry, material));
      }


   Then let's copy over the ``GPUPickingHelper`` class we used before with a few minor
   changes.


   .. code:: javascript

      class GPUPickHelper {
         constructor() {
            // create a 1x1 pixel render target
            this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
            this.pixelBuffer = new Uint8Array(4);
      -     this.pickedObject = null;
      -     this.pickedObjectSavedColor = 0;
         }
         pick(cssPosition, scene, camera) {
            const {pickingTexture, pixelBuffer} = this;

            // set the view offset to represent just a single pixel under the mouse
            const pixelRatio = renderer.getPixelRatio();
            camera.setViewOffset(
               renderer.getContext().drawingBufferWidth,   // full width
               renderer.getContext().drawingBufferHeight,  // full top
               cssPosition.x * pixelRatio | 0,             // rect x
               cssPosition.y * pixelRatio | 0,             // rect y
               1,                                          // rect width
               1,                                          // rect height
            );
            // render the scene
            renderer.setRenderTarget(pickingTexture);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null);
            // clear the view offset so rendering returns to normal
            camera.clearViewOffset();
            //read the pixel
            renderer.readRenderTargetPixels(
               pickingTexture,
               0,   // x
               0,   // y
               1,   // width
               1,   // height
               pixelBuffer);

      +     const id =
      +         (pixelBuffer[0] << 16) |
      +         (pixelBuffer[1] <<  8) |
      +         (pixelBuffer[2] <<  0);
      + 
      +     return id;
      -     const id =
      -         (pixelBuffer[0] << 16) |
      -         (pixelBuffer[1] <<  8) |
      -         (pixelBuffer[2]      );
      -     const intersectedObject = idToObject[id];
      -     if (intersectedObject) {
      -       // pick the first object. It's the closest one
      -       this.pickedObject = intersectedObject;
      -       // save its color
      -       this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
      -       // set its emissive color to flashing red/yellow
      -       this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
      -     }
         }
      }


   Now we can use that to pick countries.


   .. code:: javascript

      const pickHelper = new GPUPickHelper();

      function getCanvasRelativePosition(event) {
         const rect = canvas.getBoundingClientRect();
         return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
         };
      }

      function pickCountry(event) {
         // exit if we have not loaded the data yet
         if (!countryInfos) {
            return;
         }

         const position = getCanvasRelativePosition(event);
         const id = pickHelper.pick(position, pickingScene, camera);
         if (id > 0) {
            // we clicked a country. Toggle its 'selected' property
            const countryInfo = countryInfos[id - 1];
            const selected = !countryInfo.selected;
            // if we're selecting this country and modifiers are not
            // pressed unselect everything else.
            if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
            unselectAllCountries();
            }
            numCountriesSelected += selected ? 1 : -1;
            countryInfo.selected = selected;
         } else if (numCountriesSelected) {
            // the ocean or sky was clicked
            unselectAllCountries();
         }
         requestRenderIfNotRequested();
      }

      function unselectAllCountries() {
         numCountriesSelected = 0;
         countryInfos.forEach((countryInfo) => {
            countryInfo.selected = false;
         });
      }

      canvas.addEventListener('pointerup', pickCountry);


   The code above sets/unsets the ``selected`` property on the array of countries. If
   ``shift`` or ``ctrl`` or ``cmd`` is pressed then you can select more than one
   country.

   All that's left is showing the selected countries. For now let's just update the
   labels.


   .. code:: javascript

      function updateLabels() {
         // exit if we have not loaded the data yet
         if (!countryInfos) {
            return;
         }

         const large = settings.minArea * settings.minArea;
         // get a matrix that represents a relative orientation of the camera
         normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
         // get the camera's position
         camera.getWorldPosition(cameraPosition);
         for (const countryInfo of countryInfos) {
      -     const {position, elem, area} = countryInfo;
      -     // large enough?
      -     if (area < large) {
      +     const {position, elem, area, selected} = countryInfo;
      +     const largeEnough = area >= large;
      +     const show = selected || (numCountriesSelected === 0 && largeEnough);
      +     if (!show) {
            elem.style.display = 'none';
            continue;
            }

            ...


   and with that we should be able to pick countries


      `click here to open in a separate
      window <https://threejs.org/manual/examples/indexed-textures-picking.html>`__

   The code stills shows countries based on their area but if you click one just that
   one will have a label.

   So that seems like a reasonable solution for picking countries but what about
   highlighting the selected countries?

   For that we can take inspiration from *paletted graphics*.

   `Paletted graphics <https://en.wikipedia.org/wiki/Palette_%28computing%29>`__ or
   `Indexed Color <https://en.wikipedia.org/wiki/Indexed_color>`__ is what older
   systems like the Atari 800, Amiga, NES, Super Nintendo, and even older IBM PCs used.
   Instead of storing bitmaps as RGBA colors 8bits per color, 32 bytes per pixel or
   more, they stored bitmaps as 8bit values or less. The value for each pixel was an
   index into a palette. So for example a value of 3 in the image means "display color
   3". What color color#3 is is defined somewhere else called a "palette".

   In JavaScript you can think of it like this


   .. code:: javascript

      const face7x7PixelImageData = [
         0, 1, 1, 1, 1, 1, 0,
         1, 0, 0, 0, 0, 0, 1,
         1, 0, 2, 0, 2, 0, 1,
         1, 0, 0, 0, 0, 0, 1,
         1, 0, 3, 3, 3, 0, 1,
         1, 0, 0, 0, 0, 0, 1,
         0, 1, 1, 1, 1, 1, 1,
      ];

      const palette = [
         [255, 255, 255],  // white
         [  0,   0,   0],  // black
         [  0, 255, 255],  // cyan
         [255,   0,   0],  // red
      ];


   Where each pixel in the image data is an index into palette. If you interpreted the
   image data through the palette above you'd get this image

   .. image:: https://threejs.org/manual/resources/images/7x7-indexed-face.png


   In our case we already have a texture above that has a different id per country. So,
   we could use that same texture through a palette texture to give each country its
   own color. By changing the palette texture we can color each individual country. For
   example by setting the entire palette texture to black and then for one country's
   entry in the palette a different color, we can highlight just that country.

   To do paletted index graphics requires some custom shader code. Let's modify the
   default shaders in three.js. That way we can use lighting and other features if we
   want.

   Like we covered in `the article on animating lots of
   objects <optimize-lots-of-objects-animated>` we can modify the default
   shaders by adding a function to a material's ``onBeforeCompile`` property.

   The default fragment shader looks something like this before compiling.


   .. code:: javascript

      #include <common>
      #include <color_pars_fragment>
      #include <uv_pars_fragment>
      #include <map_pars_fragment>
      #include <alphamap_pars_fragment>
      #include <aomap_pars_fragment>
      #include <lightmap_pars_fragment>
      #include <envmap_pars_fragment>
      #include <fog_pars_fragment>
      #include <specularmap_pars_fragment>
      #include <logdepthbuf_pars_fragment>
      #include <clipping_planes_pars_fragment>
      void main() {
            #include <clipping_planes_fragment>
            vec4 diffuseColor = vec4( diffuse, opacity );
            #include <logdepthbuf_fragment>
            #include <map_fragment>
            #include <color_fragment>
            #include <alphamap_fragment>
            #include <alphatest_fragment>
            #include <specularmap_fragment>
            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
            #ifdef USE_LIGHTMAP
               reflectedLight.indirectDiffuse += texture2D( lightMap, vLightMapUv ).xyz * lightMapIntensity;
            #else
               reflectedLight.indirectDiffuse += vec3( 1.0 );
            #endif
            #include <aomap_fragment>
            reflectedLight.indirectDiffuse *= diffuseColor.rgb;
            vec3 outgoingLight = reflectedLight.indirectDiffuse;
            #include <envmap_fragment>
            gl_FragColor = vec4( outgoingLight, diffuseColor.a );
            #include <premultiplied_alpha_fragment>
            #include <tonemapping_fragment>
            #include <colorspace_fragment>
            #include <fog_fragment>
      }


   `Digging through all those snippets <https://github.com/mrdoob/three.js/tree/dev/src/renderers/shaders/ShaderChunk>`__
   we find that three.js uses a variable called ``diffuseColor`` to manage the base
   material color. It sets this in the ``<color_fragment>``
   `snippet <https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js>`__
   so we should be able to modify it after that point.

   ``diffuseColor`` at that point in the shader should already be the color from our
   outline texture so we can look up the color from a palette texture and mix them for
   the final result.

   Like we `did before <optimize-lots-of-objects-animated>` we'll make an array
   of search and replacement strings and apply them to the shader in
   ``Material.onBeforeCompile``.


   .. code:: javascript

      {
         const loader = new THREE.TextureLoader();
         const geometry = new THREE.SphereGeometry(1, 64, 32);

         const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
         indexTexture.minFilter = THREE.NearestFilter;
         indexTexture.magFilter = THREE.NearestFilter;

         const pickingMaterial = new THREE.MeshBasicMaterial({map: indexTexture});
         pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

      +   const fragmentShaderReplacements = [
      +     {
      +       from: '#include <common>',
      +       to: `
      +         #include <common>
      +         uniform sampler2D indexTexture;
      +         uniform sampler2D paletteTexture;
      +         uniform float paletteTextureWidth;
      +       `,
      +     },
      +     {
      +       from: '#include <color_fragment>',
      +       to: `
      +         #include <color_fragment>
      +         {
      +           vec4 indexColor = texture2D(indexTexture, vUv);
      +           float index = indexColor.r * 255.0 + indexColor.g * 255.0 * 256.0;
      +           vec2 paletteUV = vec2((index + 0.5) / paletteTextureWidth, 0.5);
      +           vec4 paletteColor = texture2D(paletteTexture, paletteUV);
      +           // diffuseColor.rgb += paletteColor.rgb;   // white outlines
      +           diffuseColor.rgb = paletteColor.rgb - diffuseColor.rgb;  // black outlines
      +         }
      +       `,
      +     },
      +   ];

         const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
         const material = new THREE.MeshBasicMaterial({map: texture});
      +   material.onBeforeCompile = function(shader) {
      +     fragmentShaderReplacements.forEach((rep) => {
      +       shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
      +     });
      +   };
         scene.add(new THREE.Mesh(geometry, material));
      }


   Above can see above we add 3 uniforms, ``indexTexture``, ``paletteTexture``, and
   ``paletteTextureWidth``. We get a color from the ``indexTexture`` and convert it to
   an index. ``vUv`` is the texture coordinates provided by three.js. We then use that
   index to get a color out of the palette texture. We then mix the result with the
   current ``diffuseColor``. The ``diffuseColor`` at this point is our black and white
   outline texture so if we add the 2 colors we'll get white outlines. If we subtract
   the current diffuse color we'll get black outlines.

   Before we can render we need to setup the palette texture and these 3 uniforms.

   For the palette texture it just needs to be wide enough to hold one color per
   country + one for the ocean (id = 0). There are 240 something countries. We could
   wait until the list of countries loads to get an exact number or look it up. There's
   not much harm in just picking some larger number so let's choose 512.

   Here's the code to create the palette texture


   .. code:: javascript

      const maxNumCountries = 512;
      const paletteTextureWidth = maxNumCountries;
      const paletteTextureHeight = 1;
      const palette = new Uint8Array(paletteTextureWidth * 4);
      const paletteTexture = new THREE.DataTexture(
            palette, paletteTextureWidth, paletteTextureHeight);
      paletteTexture.minFilter = THREE.NearestFilter;
      paletteTexture.magFilter = THREE.NearestFilter;


   A ``DataTexture`` let's us give a texture
   raw data. In this case we're giving it 512 RGBA colors, 4 bytes each where each byte
   is red, green, and blue respectively using values that go from 0 to 255.

   Let's fill it with random colors just to see it work


   .. code:: javascript

      for (let i = 1; i < palette.length; ++i) {
         palette[i] = Math.random() * 256;
      }
      // set the ocean color (index #0)
      palette.set([100, 200, 255, 255], 0);
      paletteTexture.needsUpdate = true;


   Anytime we want three.js to update the palette texture with the contents of the
   ``palette`` array we need to set ``paletteTexture.needsUpdate`` to ``true``.

   And then we still need to set the uniforms on the material.


   .. code:: javascript

      const geometry = new THREE.SphereGeometry(1, 64, 32);
      const material = new THREE.MeshBasicMaterial({map: texture});
      material.onBeforeCompile = function(shader) {
         fragmentShaderReplacements.forEach((rep) => {
            shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
         });
      +   shader.uniforms.paletteTexture = {value: paletteTexture};
      +   shader.uniforms.indexTexture = {value: indexTexture};
      +   shader.uniforms.paletteTextureWidth = {value: paletteTextureWidth};
      };
      scene.add(new THREE.Mesh(geometry, material));


   and with that we get randomly colored countries.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/indexed-textures-random-colors.html>`__

   Now that we can see the index and palette textures are working let's manipulate the
   palette for highlighting.

   First let's make function that will let us pass in a three.js style color and give
   us values we can put in the palette texture.


   .. code:: javascript

      const tempColor = new THREE.Color();
      function get255BasedColor(color) {
         tempColor.set(color);
         const base = tempColor.toArray().map(v => v * 255);
         base.push(255); // alpha
         return base;
      }


   Calling it like this ``color = get255BasedColor('red')`` will return an array like
   ``[255, 0, 0, 255]``.

   Next let's use it to make a few colors and fill out the palette.


   .. code:: javascript

      const selectedColor = get255BasedColor('red');
      const unselectedColor = get255BasedColor('#444');
      const oceanColor = get255BasedColor('rgb(100,200,255)');
      resetPalette();

      function setPaletteColor(index, color) {
         palette.set(color, index * 4);
      }

      function resetPalette() {
         // make all colors the unselected color
         for (let i = 1; i < maxNumCountries; ++i) {
            setPaletteColor(i, unselectedColor);
         }

         // set the ocean color (index #0)
         setPaletteColor(0, oceanColor);
         paletteTexture.needsUpdate = true;
      }


   Now let's use those functions to update the palette when a country is selected


   .. code:: javascript

      function getCanvasRelativePosition(event) {
         const rect = canvas.getBoundingClientRect();
         return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
         };
      }

      function pickCountry(event) {
         // exit if we have not loaded the data yet
         if (!countryInfos) {
            return;
         }

         const position = getCanvasRelativePosition(event);
         const id = pickHelper.pick(position, pickingScene, camera);
         if (id > 0) {
            const countryInfo = countryInfos[id - 1];
            const selected = !countryInfo.selected;
            if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
            unselectAllCountries();
            }
            numCountriesSelected += selected ? 1 : -1;
            countryInfo.selected = selected;
      +     setPaletteColor(id, selected ? selectedColor : unselectedColor);
      +     paletteTexture.needsUpdate = true;
         } else if (numCountriesSelected) {
            unselectAllCountries();
         }
         requestRenderIfNotRequested();
      }

      function unselectAllCountries() {
         numCountriesSelected = 0;
         countryInfos.forEach((countryInfo) => {
            countryInfo.selected = false;
         });
      +   resetPalette();
      }


   and we that we should be able to highlight 1 or more countries.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/indexed-textures-picking-and-highlighting.html>`__

   That seems to work!

   One minor thing is we can't spin the globe without changing the selection state. If
   we select a country and then want to rotate the globe the selection will change.

   Let's try to fix that. Off the top of my head we can check 2 things. How much time
   passed between clicking and letting go. Another is did the user actually move the
   mouse. If the time is short or if they didn't move the mouse then it was probably a
   click. Otherwise they were probably trying to drag the globe.


   .. code:: javascript

      + const maxClickTimeMs = 200;
      + const maxMoveDeltaSq = 5 * 5;
      + const startPosition = {};
      + let startTimeMs;
      + 
      + function recordStartTimeAndPosition(event) {
      +   startTimeMs = performance.now();
      +   const pos = getCanvasRelativePosition(event);
      +   startPosition.x = pos.x;
      +   startPosition.y = pos.y;
      + }

      function getCanvasRelativePosition(event) {
         const rect = canvas.getBoundingClientRect();
         return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
         };
      }

      function pickCountry(event) {
         // exit if we have not loaded the data yet
         if (!countryInfos) {
            return;
         }

      +   // if it's been a moment since the user started
      +   // then assume it was a drag action, not a select action
      +   const clickTimeMs = performance.now() - startTimeMs;
      +   if (clickTimeMs > maxClickTimeMs) {
      +     return;
      +   }
      + 
      +   // if they moved assume it was a drag action
      +   const position = getCanvasRelativePosition(event);
      +   const moveDeltaSq = (startPosition.x - position.x) ** 2 +
      +                       (startPosition.y - position.y) ** 2;
      +   if (moveDeltaSq > maxMoveDeltaSq) {
      +     return;
      +   }

      -  const position = {x: event.clientX, y: event.clientY};
         const id = pickHelper.pick(position, pickingScene, camera);
         if (id > 0) {
            const countryInfo = countryInfos[id - 1];
            const selected = !countryInfo.selected;
            if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
            unselectAllCountries();
            }
            numCountriesSelected += selected ? 1 : -1;
            countryInfo.selected = selected;
            setPaletteColor(id, selected ? selectedColor : unselectedColor);
            paletteTexture.needsUpdate = true;
         } else if (numCountriesSelected) {
            unselectAllCountries();
         }
         requestRenderIfNotRequested();
      }

      function unselectAllCountries() {
         numCountriesSelected = 0;
         countryInfos.forEach((countryInfo) => {
            countryInfo.selected = false;
         });
         resetPalette();
      }

      + canvas.addEventListener('pointerdown', recordStartTimeAndPosition);
      canvas.addEventListener('pointerup', pickCountry);


   and with those changes it *seems* like it works to me.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/indexed-textures-picking-debounced.html>`__

   I'm not a UX expert so I'd love to hear if there is a better solution.

   I hope that gave you some idea of how indexed graphics can be useful and how you can
   modify the shaders three.js makes to add simple features. How to use GLSL, the
   language the shaders are written in, is too much for this article. There are a few
   links to some info in `the article on post processing <post-processing>`.



.. _F36:

Using A Canvas for Dynamic Textures
===================================

   -  `Using A Canvas for Dynamic Textures <https://threejs.org/manual/en/canvas-textures.html>`__


   This article continues from `the article on textures <textures>`. If you
   haven't read that yet you should probably start there.

   In `the previous article on textures <textures>` we mostly used image files
   for textures. Sometimes though we want to generate a texture at runtime. One way to
   do this is to use a ``CanvasTexture``.

   A canvas texture takes a ``<canvas>`` as its input. If you don't know how to draw
   with the 2D canvas API on a canvas `there's a good tutorial on
   MDN <https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial>`__.

   Let's make a simple canvas program. Here's one that draws dots at random places in
   random colors.


   .. code:: javascript

      const ctx = document.createElement('canvas').getContext('2d');
      document.body.appendChild(ctx.canvas);
      ctx.canvas.width = 256;
      ctx.canvas.height = 256;
      ctx.fillStyle = '#FFF';
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      function randInt(min, max) {
         if (max === undefined) {
            max = min;
            min = 0;
         }
         return Math.random() * (max - min) + min | 0;
      }

      function drawRandomDot() {
         ctx.fillStyle = `#${randInt(0x1000000).toString(16).padStart(6, '0')}`;
         ctx.beginPath();

         const x = randInt(256);
         const y = randInt(256);
         const radius = randInt(10, 64);
         ctx.arc(x, y, radius, 0, Math.PI * 2);
         ctx.fill();
      }

      function render() {
         drawRandomDot();
         requestAnimationFrame(render);
      }
      requestAnimationFrame(render);


   it's pretty straight forward.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/canvas-random-dots.html>`__

   Now let's use it to texture something. We'll start with the example of texturing a
   cube from `the previous article <textures>`. We'll remove the code that loads
   an image and instead use our canvas by creating a ``CanvasTexture`` and passing it the
   canvas we created.


   .. code:: javascript

      const cubes = [];  // just an array we can use to rotate the cubes
      - const loader = new THREE.TextureLoader();
      - 
      + const ctx = document.createElement('canvas').getContext('2d');
      + ctx.canvas.width = 256;
      + ctx.canvas.height = 256;
      + ctx.fillStyle = '#FFF';
      + ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      + const texture = new THREE.CanvasTexture(ctx.canvas);

      const material = new THREE.MeshBasicMaterial({
      -  map: loader.load('resources/images/wall.jpg'),
      +   map: texture,
      });
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      cubes.push(cube);  // add to our list of cubes to rotate


   And then call the code to draw a random dot in our render loop


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

      +   drawRandomDot();
      +   texture.needsUpdate = true;

         cubes.forEach((cube, ndx) => {
            const speed = .2 + ndx * .1;
            const rot = time * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
         });

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   The only extra thing we need to do is set the ``needsUpdate`` property of the
   ``CanvasTexture`` to tell three.js to
   update the texture with the latest contents of the canvas.

   And with that we have a canvas textured cube


      `click here to open in a separate
      window <https://threejs.org/manual/examples/canvas-textured-cube.html>`__

   Note that if you want to use three.js to draw into the canvas you're better off
   using a ``RenderTarget`` which is covered in `this article <rendertargets>`.

   A common use case for canvas textures is to provide text in a scene. For example if
   you wanted to put a person's name on their character's badge you might use a canvas
   texture to texture the badge.

   Let's make a scene with 3 people and give each person a badge or label.

   Let's take the example above and remove all the cube related stuff. Then let's set
   the background to white and add two `lights <lights>`.


   .. code:: javascript

      const scene = new THREE.Scene();
      + scene.background = new THREE.Color('white');
      + 
      + function addLight(position) {
      +   const color = 0xFFFFFF;
      +   const intensity = 1;
      +   const light = new THREE.DirectionalLight(color, intensity);
      +   light.position.set(...position);
      +   scene.add(light);
      +   scene.add(light.target);
      + }
      + addLight([-3, 1, 1]);
      + addLight([ 2, 1, .5]);


   Let's make some code to make a label using canvas 2D


   .. code:: javascript

      + function makeLabelCanvas(size, name) {
      +   const borderSize = 2;
      +   const ctx = document.createElement('canvas').getContext('2d');
      +   const font =  `${size}px bold sans-serif`;
      +   ctx.font = font;
      +   // measure how long the name will be
      +   const doubleBorderSize = borderSize * 2;
      +   const width = ctx.measureText(name).width + doubleBorderSize;
      +   const height = size + doubleBorderSize;
      +   ctx.canvas.width = width;
      +   ctx.canvas.height = height;
      + 
      +   // need to set font again after resizing canvas
      +   ctx.font = font;
      +   ctx.textBaseline = 'top';
      + 
      +   ctx.fillStyle = 'blue';
      +   ctx.fillRect(0, 0, width, height);
      +   ctx.fillStyle = 'white';
      +   ctx.fillText(name, borderSize, borderSize);
      + 
      +   return ctx.canvas;
      + }


   Then we'll make simple people from a cylinder for the body, a sphere for the head,
   and a plane for the label.

   First let's make the shared geometry.


   .. code:: javascript

      + const bodyRadiusTop = .4;
      + const bodyRadiusBottom = .2;
      + const bodyHeight = 2;
      + const bodyRadialSegments = 6;
      + const bodyGeometry = new THREE.CylinderGeometry(
      +     bodyRadiusTop, bodyRadiusBottom, bodyHeight, bodyRadialSegments);
      + 
      + const headRadius = bodyRadiusTop * 0.8;
      + const headLonSegments = 12;
      + const headLatSegments = 5;
      + const headGeometry = new THREE.SphereGeometry(
      +     headRadius, headLonSegments, headLatSegments);
      + 
      + const labelGeometry = new THREE.PlaneGeometry(1, 1);


   Then let's make a function to build a person from these parts.


   .. code:: javascript

      + function makePerson(x, size, name, color) {
      +   const canvas = makeLabelCanvas(size, name);
      +   const texture = new THREE.CanvasTexture(canvas);
      +   // because our canvas is likely not a power of 2
      +   // in both dimensions set the filtering appropriately.
      +   texture.minFilter = THREE.LinearFilter;
      +   texture.wrapS = THREE.ClampToEdgeWrapping;
      +   texture.wrapT = THREE.ClampToEdgeWrapping;
      + 
      +   const labelMaterial = new THREE.MeshBasicMaterial({
      +     map: texture,
      +     side: THREE.DoubleSide,
      +     transparent: true,
      +   });
      +   const bodyMaterial = new THREE.MeshPhongMaterial({
      +     color,
      +     flatShading: true,
      +   });
      + 
      +   const root = new THREE.Object3D();
      +   root.position.x = x;
      + 
      +   const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      +   root.add(body);
      +   body.position.y = bodyHeight / 2;
      + 
      +   const head = new THREE.Mesh(headGeometry, bodyMaterial);
      +   root.add(head);
      +   head.position.y = bodyHeight + headRadius * 1.1;
      + 
      +   const label = new THREE.Mesh(labelGeometry, labelMaterial);
      +   root.add(label);
      +   label.position.y = bodyHeight * 4 / 5;
      +   label.position.z = bodyRadiusTop * 1.01;
      + 
      +   // if units are meters then 0.01 here makes size
      +   // of the label into centimeters.
      +   const labelBaseScale = 0.01;
      +   label.scale.x = canvas.width  * labelBaseScale;
      +   label.scale.y = canvas.height * labelBaseScale;
      + 
      +   scene.add(root);
      +   return root;
      + }


   You can see above we put the body, head, and label on a root ``Object3D`` and adjust 
   their positions. This would let us move the root object if we wanted to move the 
   people. The body is 2 units high. If 1 unit equals 1 meter then the code above tries 
   to make the label in centimeters so they will be size centimeters tall and however 
   wide is needed to fit the text.

   We can then make people with labels


   .. code:: javascript

      + makePerson(-3, 32, 'Purple People Eater', 'purple');
      + makePerson(-0, 32, 'Green Machine', 'green');
      + makePerson(+3, 32, 'Red Menace', 'red');


   What's left is to add some `OrbitControls` so we can move the camera.


   .. code:: javascript

      import * as THREE from 'three';
      + import {OrbitControls} from 'three/addons/controls/OrbitControls.js';



   .. code:: javascript

      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      - const far = 5;
      + const far = 50;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      - camera.position.z = 2;
      + camera.position.set(0, 2, 5);

      + const controls = new OrbitControls(camera, canvas);
      + controls.target.set(0, 2, 0);
      + controls.update();


   and we get simple labels.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/canvas-textured-labels.html>`__

   Some things to notice.

   -  If you zoom in the labels get pretty low-res.

   There is no easy solution. There are more complex font rendering techniques but I
   know of no plugin solutions. Plus they will require the user download font data
   which would be slow.

   One solution is to increase the resolution of the labels. Try setting the size
   passed into to double what it is now and setting ``labelBaseScale`` to half what it
   currently is.

   -  The labels get longer the longer the name.

   If you wanted to fix this you'd instead choose a fixed sized label and then squish
   the text.

   This is pretty easy. Pass in a base width and scale the text to fit that width like
   this


   .. code:: javascript

      - function makeLabelCanvas(size, name) {
      + function makeLabelCanvas(baseWidth, size, name) {
         const borderSize = 2;
         const ctx = document.createElement('canvas').getContext('2d');
         const font =  `${size}px bold sans-serif`;
         ctx.font = font;
         // measure how long the name will be
      +   const textWidth = ctx.measureText(name).width;

         const doubleBorderSize = borderSize * 2;
      -  const width = ctx.measureText(name).width + doubleBorderSize;
      +   const width = baseWidth + doubleBorderSize;
         const height = size + doubleBorderSize;
         ctx.canvas.width = width;
         ctx.canvas.height = height;

         // need to set font again after resizing canvas
         ctx.font = font;
      -  ctx.textBaseline = 'top';
      +   ctx.textBaseline = 'middle';
      +   ctx.textAlign = 'center';

         ctx.fillStyle = 'blue';
         ctx.fillRect(0, 0, width, height);

      +   // scale to fit but don't stretch
      +   const scaleFactor = Math.min(1, baseWidth / textWidth);
      +   ctx.translate(width / 2, height / 2);
      +   ctx.scale(scaleFactor, 1);
         ctx.fillStyle = 'white';
         ctx.fillText(name, borderSize, borderSize);

         return ctx.canvas;
      }


   Then we can pass in a width for the labels


   .. code:: javascript

      - function makePerson(x, size, name, color) {
      -  const canvas = makeLabelCanvas(size, name);
      + function makePerson(x, labelWidth, size, name, color) {
      +   const canvas = makeLabelCanvas(labelWidth, size, name);

      ...

      }

      - makePerson(-3, 32, 'Purple People Eater', 'purple');
      - makePerson(-0, 32, 'Green Machine', 'green');
      - makePerson(+3, 32, 'Red Menace', 'red');
      + makePerson(-3, 150, 32, 'Purple People Eater', 'purple');
      + makePerson(-0, 150, 32, 'Green Machine', 'green');
      + makePerson(+3, 150, 32, 'Red Menace', 'red');


   and we get labels where the text is centered and scaled to fit


      `click here to open in a separate
      window <https://threejs.org/manual/examples/canvas-textured-labels-scale-to-fit.html>`__

   Above we used a new canvas for each texture. Whether or not to use a canvas per
   texture is up to you. If you need to update them often then having one canvas per
   texture is probably the best option. If they are rarely or never updated then you
   can choose to use a single canvas for multiple textures by forcing three.js to use
   the texture. Let's change the code above to do just that.


   .. code:: javascript

      + const ctx = document.createElement('canvas').getContext('2d');

      function makeLabelCanvas(baseWidth, size, name) {
         const borderSize = 2;
      -  const ctx = document.createElement('canvas').getContext('2d');
         const font =  `${size}px bold sans-serif`;

         ...

      }

      + const forceTextureInitialization = function() {
      +   const material = new THREE.MeshBasicMaterial();
      +   const geometry = new THREE.PlaneGeometry();
      +   const scene = new THREE.Scene();
      +   scene.add(new THREE.Mesh(geometry, material));
      +   const camera = new THREE.Camera();
      + 
      +   return function forceTextureInitialization(texture) {
      +     material.map = texture;
      +     renderer.render(scene, camera);
      +   };
      + }();

      function makePerson(x, labelWidth, size, name, color) {
         const canvas = makeLabelCanvas(labelWidth, size, name);
         const texture = new THREE.CanvasTexture(canvas);
         // because our canvas is likely not a power of 2
         // in both dimensions set the filtering appropriately.
         texture.minFilter = THREE.LinearFilter;
         texture.wrapS = THREE.ClampToEdgeWrapping;
         texture.wrapT = THREE.ClampToEdgeWrapping;
      +   forceTextureInitialization(texture);

         ...


      `click here to open in a separate
      window <https://threejs.org/manual/examples/canvas-textured-labels-one-canvas.html>`__


   Another issue is that the labels don't always face the camera. If you're using
   labels as badges that's probably a good thing. If you're using labels to put names
   over players in a 3D game maybe you want the labels to always face the camera. We'll
   cover how to do that in `an article on billboards <billboards>`.

   For labels in particular, `another solution is to use
   HTML <align-html-elements-to-3d>`. The labels in this article are *inside the
   3D world* which is good if you want them to be hidden by other objects where as
   `HTML labels <align-html-elements-to-3d>` are always on top.


.. _F37:

Billboards and Facades
======================

   -  `Billboards and Facades <https://threejs.org/manual/en/billboards.html>`__


   In `a previous article <canvas-textures>` we used a ``CanvasTexture`` to make 
   labels / badges on characters. Sometimes we'd like to make labels or other things 
   that always face the camera. Three.js provides the ``Sprite`` and ``SpriteMaterial`` 
   to make this happen.

   Let's change the badge example from `the article on canvas textures <canvas-textures>` 
   to use ``Sprite`` and ``SpriteMaterial``


   .. code:: javascript

      function makePerson(x, labelWidth, size, name, color) {
         const canvas = makeLabelCanvas(labelWidth, size, name);
         const texture = new THREE.CanvasTexture(canvas);
         // because our canvas is likely not a power of 2
         // in both dimensions set the filtering appropriately.
         texture.minFilter = THREE.LinearFilter;
         texture.wrapS = THREE.ClampToEdgeWrapping;
         texture.wrapT = THREE.ClampToEdgeWrapping;

      -  const labelMaterial = new THREE.MeshBasicMaterial({
      +  const labelMaterial = new THREE.SpriteMaterial({
            map: texture,
      -     side: THREE.DoubleSide,
            transparent: true,
         });

         const root = new THREE.Object3D();
         root.position.x = x;

         const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
         root.add(body);
         body.position.y = bodyHeight / 2;

         const head = new THREE.Mesh(headGeometry, bodyMaterial);
         root.add(head);
         head.position.y = bodyHeight + headRadius * 1.1;

      -  const label = new THREE.Mesh(labelGeometry, labelMaterial);
      +  const label = new THREE.Sprite(labelMaterial);
         root.add(label);
         label.position.y = bodyHeight * 4 / 5;
         label.position.z = bodyRadiusTop * 1.01;


   and the labels now always face the camera


      `click here to open in a separate
      window <https://threejs.org/manual/examples/billboard-labels-w-sprites.html>`__

   One problem is from certain angles the labels now intersect the characters.

   .. image:: https://threejs.org/manual/resources/images/billboard-label-z-issue.png


   We can move the position of the labels to fix.


   .. code:: javascript

      + // if units are meters then 0.01 here makes size
      + // of the label into centimeters.
      + const labelBaseScale = 0.01;
      const label = new THREE.Sprite(labelMaterial);
      root.add(label);
      - label.position.y = bodyHeight * 4 / 5;
      - label.position.z = bodyRadiusTop * 1.01;
      + label.position.y = head.position.y + headRadius + size * labelBaseScale;

      - // if units are meters then 0.01 here makes size
      - // of the label into centimeters.
      - const labelBaseScale = 0.01;
      label.scale.x = canvas.width  * labelBaseScale;
      label.scale.y = canvas.height * labelBaseScale;


      `click here to open in a separate
      window <https://threejs.org/manual/examples/billboard-labels-w-sprites-adjust-height.html>`__


   Another thing we can do with billboards is draw facades.

   Instead of drawing 3D objects we draw 2D planes with an image of 3D objects. This is
   often faster than drawing 3D objects.

   For example let's make a scene with grid of trees. We'll make each tree from a
   cylinder for the base and a cone for the top.

   First we make the cone and cylinder geometry and materials that all the trees will
   share


   .. code:: javascript

      const trunkRadius = .2;
      const trunkHeight = 1;
      const trunkRadialSegments = 12;
      const trunkGeometry = new THREE.CylinderGeometry(
            trunkRadius, trunkRadius, trunkHeight, trunkRadialSegments);

      const topRadius = trunkRadius * 4;
      const topHeight = trunkHeight * 2;
      const topSegments = 12;
      const topGeometry = new THREE.ConeGeometry(
            topRadius, topHeight, topSegments);

      const trunkMaterial = new THREE.MeshPhongMaterial({color: 'brown'});
      const topMaterial = new THREE.MeshPhongMaterial({color: 'green'});


   Then we'll make a function that makes a ``Mesh``
   each for the trunk and top of a tree and parents both to an
   ``Object3D``.


   .. code:: javascript

      function makeTree(x, z) {
         const root = new THREE.Object3D();
         const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
         trunk.position.y = trunkHeight / 2;
         root.add(trunk);

         const top = new THREE.Mesh(topGeometry, topMaterial);
         top.position.y = trunkHeight + topHeight / 2;
         root.add(top);

         root.position.set(x, 0, z);
         scene.add(root);

         return root;
      }


   Then we'll make a loop to place a grid of trees.


   .. code:: javascript

      for (let z = -50; z <= 50; z += 10) {
         for (let x = -50; x <= 50; x += 10) {
            makeTree(x, z);
         }
      }


   Let's also add a ground plane while we're at it


   .. code:: javascript

      // add ground
      {
         const size = 400;
         const geometry = new THREE.PlaneGeometry(size, size);
         const material = new THREE.MeshPhongMaterial({color: 'gray'});
         const mesh = new THREE.Mesh(geometry, material);
         mesh.rotation.x = Math.PI * -0.5;
         scene.add(mesh);
      }


   and change the background to light blue


   .. code:: javascript

      const scene = new THREE.Scene();
      - scene.background = new THREE.Color('white');
      + scene.background = new THREE.Color('lightblue');


   and we get a grid of trees


      `click here to open in a separate
      window <https://threejs.org/manual/examples/billboard-trees-no-billboards.html>`__

   There are 11x11 or 121 trees. Each tree is made from a 12 polygon cone and a 48
   polygon trunk so each tree is 60 polygons. 121 * 60 is 7260 polygons. That's not
   that many but of course a more detailed 3D tree might be 1000-3000 polygons. If they
   were 3000 polygons each then 121 trees would be 363000 polygons to draw.

   Using facades we can bring that number down.

   We could manually create a facade in some painting program but let's write some code
   to try to generate one.

   Let's write some code to render an object to a texture using a ``RenderTarget``. We
   covered rendering to a ``RenderTarget`` in `the article on render targets <rendertargets>`.


   .. code:: javascript

      function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
         const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
         const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
         const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);

         camera.position.copy(boxCenter);
         camera.position.z += distance;

         // pick some near and far values for the frustum that
         // will contain the box.
         camera.near = boxSize / 100;
         camera.far = boxSize * 100;

         camera.updateProjectionMatrix();
      }

      function makeSpriteTexture(textureSize, obj) {
         const rt = new THREE.WebGLRenderTarget(textureSize, textureSize);

         const aspect = 1;  // because the render target is square
         const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

         scene.add(obj);

         // compute the box that contains obj
         const box = new THREE.Box3().setFromObject(obj);

         const boxSize = box.getSize(new THREE.Vector3());
         const boxCenter = box.getCenter(new THREE.Vector3());

         // set the camera to frame the box
         const fudge = 1.1;
         const size = Math.max(...boxSize.toArray()) * fudge;
         frameArea(size, size, boxCenter, camera);

         renderer.autoClear = false;
         renderer.setRenderTarget(rt);
         renderer.render(scene, camera);
         renderer.setRenderTarget(null);
         renderer.autoClear = true;

         scene.remove(obj);

         return {
            position: boxCenter.multiplyScalar(fudge),
            scale: size,
            texture: rt.texture,
         };
      }


   Some things to note about the code above:

   We're using the field of view (``fov``) defined above this code.

   We're computing a box that contains the tree the same way we did in `the article on
   loading a .obj file <load-obj>` with a few minor changes.

   We call ``frameArea`` again adapted `the article on loading a .obj file <load-obj>`. 
   In this case we compute how far the camera needs to be away from the object given 
   its field of view to contain the object. We then position the camera -z that distance 
   from the center of the box that contains the object.

   We multiply the size we want to fit by 1.1 (``fudge``) to make sure the tree fits
   completely in the render target. The issue here is the size we're using to calculate
   if the object fits in the camera's view is not taking into account that the very
   edges of the object will end up dipping outside area we calculated. We could compute
   how to make 100% of the box fit but that would waste space as well so instead we
   just *fudge* it.

   Then we render to the render target and remove the object from the scene.

   It's important to note we need the lights in the scene but we need to make sure
   nothing else is in the scene.

   We also need to not set a background color on the scene


   .. code:: javascript

      const scene = new THREE.Scene();
      - scene.background = new THREE.Color('lightblue');


   Finally we've made the texture we return it and the position and scale we need to
   make the facade so that it will appear to be in the same place.

   We then make a tree and call this code and pass it in


   .. code:: javascript

      // make billboard texture
      const tree = makeTree(0, 0);
      const facadeSize = 64;
      const treeSpriteInfo = makeSpriteTexture(facadeSize, tree);


   We can then make a grid of facades instead of a grid of tree models


   .. code:: javascript

      + function makeSprite(spriteInfo, x, z) {
      +   const {texture, offset, scale} = spriteInfo;
      +   const mat = new THREE.SpriteMaterial({
      +     map: texture,
      +     transparent: true,
      +   });
      +   const sprite = new THREE.Sprite(mat);
      +   scene.add(sprite);
      +   sprite.position.set(
      +       offset.x + x,
      +       offset.y,
      +       offset.z + z);
      +   sprite.scale.set(scale, scale, scale);
      + }

      for (let z = -50; z <= 50; z += 10) {
         for (let x = -50; x <= 50; x += 10) {
      -     makeTree(x, z);
      +     makeSprite(treeSpriteInfo, x, z);
         }
      }


   In the code above we apply the offset and scale needed to position the facade so it
   appears the same place the original tree would have appeared.

   Now that we're done making the tree facade texture we can set the background again


   .. code:: javascript

      scene.background = new THREE.Color('lightblue');


   and now we get a scene of tree facades


      `click here to open in a separate
      window <https://threejs.org/manual/examples/billboard-trees-static-billboards.html>`__

   Compare to the trees models above and you can see it looks fairly similar. We used a
   low-res texture, just 64x64 pixels so the facades are blocky. You could increase the
   resolution. Often facades are used only in the far distance when they are fairly
   small so a low-res texture is enough and it saves on drawing detailed trees that are
   only a few pixels big when far away.

   Another issue is we are only viewing the tree from one side. This is often solved by
   rendering more facades, say from 8 directions around the object and then setting
   which facade to show based on which direction the camera is looking at the facade.

   Whether or not you use facades is up to you but hopefully this article gave you some
   ideas and suggested some solutions if you decide to use them.



.. _F38:

Freeing Resources
=================

   -  `Freeing Resources <https://threejs.org/manual/en/cleanup.html>`__


   Three.js apps often use lots of memory. A 3D model might be 1 to 20 meg memory for
   all of its vertices. A model might use many textures that even if they are
   compressed into jpg files they have to be expanded to their uncompressed form to
   use. Each 1024x1024 texture takes 4 to 6meg of memory.

   Most three.js apps load resources at init time and then use those resources forever
   until the page is closed. But, what if you want to load and change resources over
   time?

   Unlike most JavaScript, three.js can not automatically clean these resources up. The
   browser will clean them up if you switch pages but otherwise it's up to you to
   manage them. This is an issue of how WebGL is designed and so three.js has no
   recourse but to pass on the responsibility to free resources back to you.

   You free three.js resource this by calling the ``dispose`` function on
   `textures <textures>`, `geometries <primitives>`, and `materials <materials>`.

   You could do this manually. At the start you might create some of these resources


   .. code:: javascript

      const boxGeometry = new THREE.BoxGeometry(...);
      const boxTexture = textureLoader.load(...);
      const boxMaterial = new THREE.MeshPhongMaterial({map: texture});


   and then when you're done with them you'd free them


   .. code:: javascript

      boxGeometry.dispose();
      boxTexture.dispose();
      boxMaterial.dispose();


   As you use more and more resources that would get more and more tedious.

   To help remove some of the tedium let's make a class to track the resources. We'll
   then ask that class to do the cleanup for us.

   Here's a first pass at such a class


   .. code:: javascript

      class ResourceTracker {
         constructor() {
            this.resources = new Set();
         }
         track(resource) {
            if (resource.dispose) {
            this.resources.add(resource);
            }
            return resource;
         }
         untrack(resource) {
            this.resources.delete(resource);
         }
         dispose() {
            for (const resource of this.resources) {
            resource.dispose();
            }
            this.resources.clear();
         }
      }


   Let's use this class with the first example from `the article on
   textures <textures>`. We can create an instance of this class


   .. code:: javascript

      const resTracker = new ResourceTracker();


   and then just to make it easier to use let's create a bound function for the
   ``track`` method


   .. code:: javascript

      const resTracker = new ResourceTracker();
      + const track = resTracker.track.bind(resTracker);


   Now to use it we just need to call ``track`` with for each geometry, texture, and
   material we create


   .. code:: javascript

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      - const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      + const geometry = track(new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth));

      const cubes = [];  // an array we can use to rotate the cubes
      const loader = new THREE.TextureLoader();

      - const material = new THREE.MeshBasicMaterial({
      -  map: loader.load('resources/images/wall.jpg'),
      - });
      + const material = track(new THREE.MeshBasicMaterial({
      +   map: track(loader.load('resources/images/wall.jpg')),
      + }));
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      cubes.push(cube);  // add to our list of cubes to rotate


   And then to free them we'd want to remove the cubes from the scene and then call
   ``resTracker.dispose``


   .. code:: javascript

      for (const cube of cubes) {
         scene.remove(cube);
      }
      cubes.length = 0;  // clears the cubes array
      resTracker.dispose();


   That would work but I find having to remove the cubes from the scene kind of
   tedious. Let's add that functionality to the ``ResourceTracker``.


   .. code:: javascript

      class ResourceTracker {
         constructor() {
            this.resources = new Set();
         }
         track(resource) {
      -     if (resource.dispose) {
      +     if (resource.dispose || resource instanceof THREE.Object3D) {
            this.resources.add(resource);
            }
            return resource;
         }
         untrack(resource) {
            this.resources.delete(resource);
         }
         dispose() {
            for (const resource of this.resources) {
      -       resource.dispose();
      +       if (resource instanceof THREE.Object3D) {
      +         if (resource.parent) {
      +           resource.parent.remove(resource);
      +         }
      +       }
      +       if (resource.dispose) {
      +         resource.dispose();
      +       }
      +     }
            this.resources.clear();
         }
      }


   And now we can track the cubes


   .. code:: javascript

      const material = track(new THREE.MeshBasicMaterial({
         map: track(loader.load('resources/images/wall.jpg')),
      }));
      const cube = track(new THREE.Mesh(geometry, material));
      scene.add(cube);
      cubes.push(cube);  // add to our list of cubes to rotate


   We no longer need the code to remove the cubes from the scene.


   .. code:: javascript

      - for (const cube of cubes) {
      -  scene.remove(cube);
      - }
      cubes.length = 0;  // clears the cube array
      resTracker.dispose();


   Let's arrange this code so that we can re-add the cube, texture, and material.


   .. code:: javascript

      const scene = new THREE.Scene();
      * const cubes = [];  // just an array we can use to rotate the cubes

      + function addStuffToScene() {
         const resTracker = new ResourceTracker();
         const track = resTracker.track.bind(resTracker);

         const boxWidth = 1;
         const boxHeight = 1;
         const boxDepth = 1;
         const geometry = track(new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth));

         const loader = new THREE.TextureLoader();

         const material = track(new THREE.MeshBasicMaterial({
            map: track(loader.load('resources/images/wall.jpg')),
         }));
         const cube = track(new THREE.Mesh(geometry, material));
         scene.add(cube);
         cubes.push(cube);  // add to our list of cubes to rotate
      +   return resTracker;
      + }


   And then let's write some code to add and remove things over time.


   .. code:: javascript

      function waitSeconds(seconds = 0) {
         return new Promise(resolve => setTimeout(resolve, seconds * 1000));
      }

      async function process() {
         for (;;) {
            const resTracker = addStuffToScene();
            await wait(2);
            cubes.length = 0;  // remove the cubes
            resTracker.dispose();
            await wait(1);
         }
      }
      process();


   This code will create the cube, texture and material, wait for 2 seconds, then
   dispose of them and wait for 1 second and repeat.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cleanup-simple.html>`__

   So that seems to work.

   For a loaded file though it's a little more work. Most loaders only return an
   ``Object3D`` as a root of the hierarchy of objects they load so we need to 
   discover what all the resources are.

   Let's update our ``ResourceTracker`` to try to do that.

   First we'll check if the object is an ``Object3D`` then track its geometry, 
   material, and children


   .. code:: javascript

      class ResourceTracker {
         constructor() {
            this.resources = new Set();
         }
         track(resource) {
            if (resource.dispose || resource instanceof THREE.Object3D) {
            this.resources.add(resource);
            }
      +     if (resource instanceof THREE.Object3D) {
      +       this.track(resource.geometry);
      +       this.track(resource.material);
      +       this.track(resource.children);
      +     }
            return resource;
         }
         ...
      }


   Now, because any of ``resource.geometry``, ``resource.material``, and
   ``resource.children`` might be null or undefined we'll check at the top of
   ``track``.


   .. code:: javascript

      class ResourceTracker {
         constructor() {
            this.resources = new Set();
         }
         track(resource) {
      +     if (!resource) {
      +       return resource;
      +     }

            if (resource.dispose || resource instanceof THREE.Object3D) {
            this.resources.add(resource);
            }
            if (resource instanceof THREE.Object3D) {
            this.track(resource.geometry);
            this.track(resource.material);
            this.track(resource.children);
            }
            return resource;
         }
         ...
      }


   Also because ``resource.children`` is an array and because ``resource.material`` can
   be an array let's check for arrays


   .. code:: javascript

      class ResourceTracker {
         constructor() {
            this.resources = new Set();
         }
         track(resource) {
            if (!resource) {
            return resource;
            }

      +     // handle children and when material is an array of materials.
      +     if (Array.isArray(resource)) {
      +       resource.forEach(resource => this.track(resource));
      +       return resource;
      +     }

            if (resource.dispose || resource instanceof THREE.Object3D) {
            this.resources.add(resource);
            }
            if (resource instanceof THREE.Object3D) {
            this.track(resource.geometry);
            this.track(resource.material);
            this.track(resource.children);
            }
            return resource;
         }
         ...
      }


   And finally we need to walk the properties and uniforms of a material looking for
   textures.


   .. code:: javascript

      class ResourceTracker {
         constructor() {
            this.resources = new Set();
         }
         track(resource) {
            if (!resource) {
            return resource;
            }

      *     // handle children and when material is an array of materials or
      *     // uniform is array of textures
            if (Array.isArray(resource)) {
            resource.forEach(resource => this.track(resource));
            return resource;
            }

            if (resource.dispose || resource instanceof THREE.Object3D) {
            this.resources.add(resource);
            }
            if (resource instanceof THREE.Object3D) {
            this.track(resource.geometry);
            this.track(resource.material);
            this.track(resource.children);
      -     }
      +     } else if (resource instanceof THREE.Material) {
      +       // We have to check if there are any textures on the material
      +       for (const value of Object.values(resource)) {
      +         if (value instanceof THREE.Texture) {
      +           this.track(value);
      +         }
      +       }
      +       // We also have to check if any uniforms reference textures or arrays of textures
      +       if (resource.uniforms) {
      +         for (const value of Object.values(resource.uniforms)) {
      +           if (value) {
      +             const uniformValue = value.value;
      +             if (uniformValue instanceof THREE.Texture ||
      +                 Array.isArray(uniformValue)) {
      +               this.track(uniformValue);
      +             }
      +           }
      +         }
      +       }
      +     }
            return resource;
         }
         ...
      }


   And with that let's take an example from `the article on loading gltf
   files <load-gltf>` and make it load and free files.


   .. code:: javascript

      const gltfLoader = new GLTFLoader();
      function loadGLTF(url) {
         return new Promise((resolve, reject) => {
            gltfLoader.load(url, resolve, undefined, reject);
         });
      }

      function waitSeconds(seconds = 0) {
         return new Promise(resolve => setTimeout(resolve, seconds * 1000));
      }

      const fileURLs = [
         'resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf',
         'resources/models/3dbustchallange_submission/scene.gltf',
         'resources/models/mountain_landscape/scene.gltf',
         'resources/models/simple_house_scene/scene.gltf',
      ];

      async function loadFiles() {
         for (;;) {
            for (const url of fileURLs) {
            const resMgr = new ResourceTracker();
            const track = resMgr.track.bind(resMgr);
            const gltf = await loadGLTF(url);
            const root = track(gltf.scene);
            scene.add(root);

            // compute the box that contains all the stuff
            // from root and below
            const box = new THREE.Box3().setFromObject(root);

            const boxSize = box.getSize(new THREE.Vector3()).length();
            const boxCenter = box.getCenter(new THREE.Vector3());

            // set the camera to frame the box
            frameArea(boxSize * 1.1, boxSize, boxCenter, camera);

            await waitSeconds(2);
            renderer.render(scene, camera);

            resMgr.dispose();

            await waitSeconds(1);

            }
         }
      }
      loadFiles();


   and we get


      `click here to open in a separate
      window <https://threejs.org/manual/examples/cleanup-loaded-files.html>`__

   Some notes about the code.

   If we wanted to load 2 or more files at once and free them at anytime we would use
   one ``ResourceTracker`` per file.

   Above we are only tracking ``gltf.scene`` right after loading. Based on our current
   implementation of ``ResourceTracker`` that will track all the resources just loaded.
   If we added more things to the scene we need to decide whether or not to track them.

   For example let's say after we loaded a character we put a tool in their hand by
   making the tool a child of their hand. As it is that tool will not be freed. I'm
   guessing more often than not this is what we want.

   That brings up a point. Originally when I first wrote the ``ResourceTracker`` above
   I walked through everything inside the ``dispose`` method instead of ``track``. It
   was only later as I thought about the tool as a child of hand case above that it
   became clear that tracking exactly what to free in ``track`` was more flexible and
   arguably more correct since we could then track what was loaded from the file rather
   than just freeing the state of the scene graph later.

   I honestly am not 100% happy with ``ResourceTracker``. Doing things this way is not
   common in 3D engines. We shouldn't have to guess what resources were loaded, we
   should know. It would be nice if three.js changed so that all file loaders returned
   some standard object with references to all the resources loaded. At least at the
   moment, three.js doesn't give us any more info when loading a scene so this solution
   seems to work.

   I hope you find this example useful or at least a good reference for what is
   required to free resources in three.js


.. _F39:

Making Voxel Geometry (Minecraft)
=================================

   -  `Making Voxel Geometry (Minecraft) <https://threejs.org/manual/en/voxel-geometry.html>`__


   I've seen this topic come up more than once in various places. That is basically,
   "How do I make a voxel display like Minecraft".

   Most people first attempt this by making a cube geometry and then making a mesh at
   each voxel position. Just for fun I tried this. I made a 16777216 element
   ``Uint8Array`` to represent a 256x256x256 cube of voxels.


   .. code:: javascript

      const cellSize = 256;
      const cell = new Uint8Array(cellSize * cellSize * cellSize);


   I then made a single layer with a kind of hills of sine waves like this


   .. code:: javascript

      for (let y = 0; y < cellSize; ++y) {
         for (let z = 0; z < cellSize; ++z) {
            for (let x = 0; x < cellSize; ++x) {
            const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
            if (height > y && height < y + 1) {
               const offset = y * cellSize * cellSize +
                              z * cellSize +
                              x;
               cell[offset] = 1;
            }
            }
         }
      }


   I then walked through all the cells and if they were not 0 I created a mesh with a
   cube.


   .. code:: javascript

      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshPhongMaterial({color: 'green'});

      for (let y = 0; y < cellSize; ++y) {
         for (let z = 0; z < cellSize; ++z) {
            for (let x = 0; x < cellSize; ++x) {
            const offset = y * cellSize * cellSize +
                           z * cellSize +
                           x;
            const block = cell[offset];
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            }
         }
      }


   The rest of the code is based on the example from `the article on rendering on
   demand <rendering-on-demand>`.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/voxel-geometry-separate-cubes.html>`__

   It takes a while to start and if you try to move the camera it's likely too slow.
   Like `the article on how to optimize lots of objects <optimize-lots-of-objects>` 
   the problem is there are just way too many objects. 256x256 is 65536 boxes!

   Using `the technique of merging the geometry <rendering-on-demand>` will fix
   the issue for this example but what if instead of just making a single layer we
   filled in everything below the ground with voxel. In other words change the loop
   filling in the voxels to this


   .. code:: javascript

      for (let y = 0; y < cellSize; ++y) {
         for (let z = 0; z < cellSize; ++z) {
            for (let x = 0; x < cellSize; ++x) {
            const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
      -       if (height > y && height < y + 1) {
      +       if (height < y + 1) {
               const offset = y * cellSize * cellSize +
                              z * cellSize +
                              x;
               cell[offset] = 1;
            }
            }
         }
      }


   I tried it once just to see the results. It churned for about a minute and then
   crashed with *out of memory* 😅

   There are several issues but the biggest issue is we're making all these faces
   inside the cubes that we can actually never see.

   In other words lets say we have a box of voxels 3x2x2. By merging cubes we're
   getting this

   .. container:: spread

      <div data-diagram="mergedCubes" style="height: 300px; touch-action: none;"></div>


   but we really want this

   .. container:: spread

      <div data-diagram="culledCubes" style="height: 300px; touch-action: none;"></div>


   In the top box there are faces between the voxels. Faces that are a waste since they
   can't be seen. It's not just one face between each voxel, there are 2 faces, one for
   each voxel facing its neighbor that are a waste. All these extra faces, especially
   for a large volume of voxels will kill performance.

   It should be clear that we can't just merge geometry. We need to build it ourselves,
   taking into account that if a voxel has an adjacent neighbor it doesn't need the
   face facing that neighbor.

   The next issue is that 256x256x256 is just too big. 16meg is a lot of memory and if
   nothing else in much of the space nothing is there so that's a lot of wasted memory.
   It's also a huge number of voxels, 16 million! That's too much to consider at once.

   A solution is to divide the area into smaller areas. Any area that has nothing in it
   needs no storage. Let's use 32x32x32 areas (that's 32k) and only create an area if
   something is in it. We'll call one of these larger 32x32x32 areas a "cell".

   Let's break this into pieces. First let's make a class to manage the voxel data.


   .. code:: javascript

      class VoxelWorld {
         constructor(cellSize) {
            this.cellSize = cellSize;
         }
      }


   Let's make the function that makes geometry for a cell. Let's assume you pass in a
   cell position. In other words if you want the geometry for the cell that covers
   voxels (0-31x, 0-31y, 0-31z) then you'd pass in 0,0,0. For the cell that covers
   voxels (32-63x, 0-31y, 0-31z) you'd pass in 1,0,0.

   We need to be able to check the neighboring voxels so let's assume our class has a
   function ``getVoxel`` that given a voxel position returns the value of the voxel
   there. In other words if you pass it 35,0,0 and the cellSize is 32 it's going to
   look at cell 1,0,0 and in that cell it will look at voxel 3,0,0. Using this function
   we can look at a voxel's neighboring voxels even if they happen to be in neighboring
   cells.


   .. code:: javascript

      class VoxelWorld {
         constructor(cellSize) {
            this.cellSize = cellSize;
         }
      +   generateGeometryDataForCell(cellX, cellY, cellZ) {
      +     const {cellSize} = this;
      +     const startX = cellX * cellSize;
      +     const startY = cellY * cellSize;
      +     const startZ = cellZ * cellSize;
      + 
      +     for (let y = 0; y < cellSize; ++y) {
      +       const voxelY = startY + y;
      +       for (let z = 0; z < cellSize; ++z) {
      +         const voxelZ = startZ + z;
      +         for (let x = 0; x < cellSize; ++x) {
      +           const voxelX = startX + x;
      +           const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
      +           if (voxel) {
      +             for (const {dir} of VoxelWorld.faces) {
      +               const neighbor = this.getVoxel(
      +                   voxelX + dir[0],
      +                   voxelY + dir[1],
      +                   voxelZ + dir[2]);
      +               if (!neighbor) {
      +                 // this voxel has no neighbor in this direction so we need a face
      +                 // here.
      +               }
      +             }
      +           }
      +         }
      +       }
      +     }
      +   }
      }

      + VoxelWorld.faces = [
      +   { // left
      +     dir: [ -1,  0,  0, ],
      +   },
      +   { // right
      +     dir: [  1,  0,  0, ],
      +   },
      +   { // bottom
      +     dir: [  0, -1,  0, ],
      +   },
      +   { // top
      +     dir: [  0,  1,  0, ],
      +   },
      +   { // back
      +     dir: [  0,  0, -1, ],
      +   },
      +   { // front
      +     dir: [  0,  0,  1, ],
      +   },
      + ];


   So using the code above we know when we need a face. Let's generate the faces.


   .. code:: javascript

      class VoxelWorld {
         constructor(cellSize) {
            this.cellSize = cellSize;
         }
         generateGeometryDataForCell(cellX, cellY, cellZ) {
            const {cellSize} = this;
      +     const positions = [];
      +     const normals = [];
      +     const indices = [];
            const startX = cellX * cellSize;
            const startY = cellY * cellSize;
            const startZ = cellZ * cellSize;

            for (let y = 0; y < cellSize; ++y) {
            const voxelY = startY + y;
            for (let z = 0; z < cellSize; ++z) {
               const voxelZ = startZ + z;
               for (let x = 0; x < cellSize; ++x) {
                  const voxelX = startX + x;
                  const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
                  if (voxel) {
      -             for (const {dir} of VoxelWorld.faces) {
      +             for (const {dir, corners} of VoxelWorld.faces) {
                     const neighbor = this.getVoxel(
                        voxelX + dir[0],
                        voxelY + dir[1],
                        voxelZ + dir[2]);
                     if (!neighbor) {
                        // this voxel has no neighbor in this direction so we need a face.
      +                 const ndx = positions.length / 3;
      +                 for (const pos of corners) {
      +                   positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
      +                   normals.push(...dir);
      +                 }
      +                 indices.push(
      +                   ndx, ndx + 1, ndx + 2,
      +                   ndx + 2, ndx + 1, ndx + 3,
      +                 );
                     }
                  }
                  }
               }
            }
            }
      +     return {
      +       positions,
      +       normals,
      +       indices,
            };
         }
      }

      VoxelWorld.faces = [
         { // left
            dir: [ -1,  0,  0, ],
      +     corners: [
      +       [ 0, 1, 0 ],
      +       [ 0, 0, 0 ],
      +       [ 0, 1, 1 ],
      +       [ 0, 0, 1 ],
      +     ],
         },
         { // right
            dir: [  1,  0,  0, ],
      +     corners: [
      +       [ 1, 1, 1 ],
      +       [ 1, 0, 1 ],
      +       [ 1, 1, 0 ],
      +       [ 1, 0, 0 ],
      +     ],
         },
         { // bottom
            dir: [  0, -1,  0, ],
      +     corners: [
      +       [ 1, 0, 1 ],
      +       [ 0, 0, 1 ],
      +       [ 1, 0, 0 ],
      +       [ 0, 0, 0 ],
      +     ],
         },
         { // top
            dir: [  0,  1,  0, ],
      +     corners: [
      +       [ 0, 1, 1 ],
      +       [ 1, 1, 1 ],
      +       [ 0, 1, 0 ],
      +       [ 1, 1, 0 ],
      +     ],
         },
         { // back
            dir: [  0,  0, -1, ],
      +     corners: [
      +       [ 1, 0, 0 ],
      +       [ 0, 0, 0 ],
      +       [ 1, 1, 0 ],
      +       [ 0, 1, 0 ],
      +     ],
         },
         { // front
            dir: [  0,  0,  1, ],
      +     corners: [
      +       [ 0, 0, 1 ],
      +       [ 1, 0, 1 ],
      +       [ 0, 1, 1 ],
      +       [ 1, 1, 1 ],
      +     ],
         },
      ];


   The code above would make basic geometry data for us. We just need to supply the
   ``getVoxel`` function. Let's start with just one hard coded cell.


   .. code:: javascript

      class VoxelWorld {
         constructor(cellSize) {
            this.cellSize = cellSize;
      +     this.cell = new Uint8Array(cellSize * cellSize * cellSize);
         }
      +   getCellForVoxel(x, y, z) {
      +     const {cellSize} = this;
      +     const cellX = Math.floor(x / cellSize);
      +     const cellY = Math.floor(y / cellSize);
      +     const cellZ = Math.floor(z / cellSize);
      +     if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      +       return null
      +     }
      +     return this.cell;
      +   }
      +   getVoxel(x, y, z) {
      +     const cell = this.getCellForVoxel(x, y, z);
      +     if (!cell) {
      +       return 0;
      +     }
      +     const {cellSize} = this;
      +     const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
      +     const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
      +     const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
      +     const voxelOffset = voxelY * cellSize * cellSize +
      +                         voxelZ * cellSize +
      +                         voxelX;
      +     return cell[voxelOffset];
      +   }
         generateGeometryDataForCell(cellX, cellY, cellZ) {

         ...
      }


   This seems like it would work. Let's make a ``setVoxel`` function so we can set some
   data.


   .. code:: javascript

      class VoxelWorld {
         constructor(cellSize) {
            this.cellSize = cellSize;
            this.cell = new Uint8Array(cellSize * cellSize * cellSize);
         }
         getCellForVoxel(x, y, z) {
            const {cellSize} = this;
            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
            return null
            }
            return this.cell;
         }
      +   setVoxel(x, y, z, v) {
      +     let cell = this.getCellForVoxel(x, y, z);
      +     if (!cell) {
      +       return;  // TODO: add a new cell?
      +     }
      +     const {cellSize} = this;
      +     const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
      +     const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
      +     const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
      +     const voxelOffset = voxelY * cellSize * cellSize +
      +                         voxelZ * cellSize +
      +                         voxelX;
      +     cell[voxelOffset] = v;
      +   }
         getVoxel(x, y, z) {
            const cell = this.getCellForVoxel(x, y, z);
            if (!cell) {
            return 0;
            }
            const {cellSize} = this;
            const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
            const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
            const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
            const voxelOffset = voxelY * cellSize * cellSize +
                              voxelZ * cellSize +
                              voxelX;
            return cell[voxelOffset];
         }
         generateGeometryDataForCell(cellX, cellY, cellZ) {

         ...
      }


   Hmmm, I see a lot of repeated code. Let's fix that up


   .. code:: javascript

      class VoxelWorld {
         constructor(cellSize) {
            this.cellSize = cellSize;
      +     this.cellSliceSize = cellSize * cellSize;
            this.cell = new Uint8Array(cellSize * cellSize * cellSize);
         }
         getCellForVoxel(x, y, z) {
            const {cellSize} = this;
            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
            return null;
            }
            return this.cell;
         }
      +   computeVoxelOffset(x, y, z) {
      +     const {cellSize, cellSliceSize} = this;
      +     const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
      +     const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
      +     const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
      +     return voxelY * cellSliceSize +
      +            voxelZ * cellSize +
      +            voxelX;
      +   }
         setVoxel(x, y, z, v) {
            const cell = this.getCellForVoxel(x, y, z);
            if (!cell) {
            return;  // TODO: add a new cell?
            }
      -     const {cellSize} = this;
      -     const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
      -     const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
      -     const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
      -     const voxelOffset = voxelY * cellSize * cellSize +
      -                         voxelZ * cellSize +
      -                         voxelX;
      +     const voxelOffset = this.computeVoxelOffset(x, y, z);
            cell[voxelOffset] = v;
         }
         getVoxel(x, y, z) {
            const cell = this.getCellForVoxel(x, y, z);
            if (!cell) {
            return 0;
            }
      -     const {cellSize} = this;
      -     const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
      -     const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
      -     const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
      -     const voxelOffset = voxelY * cellSize * cellSize +
      -                         voxelZ * cellSize +
      -                         voxelX;
      +     const voxelOffset = this.computeVoxelOffset(x, y, z);
            return cell[voxelOffset];
         }
         generateGeometryDataForCell(cellX, cellY, cellZ) {

         ...
      }


   Now let's make some code to fill out the first cell with voxels.


   .. code:: javascript

      const cellSize = 32;

      const world = new VoxelWorld(cellSize);

      for (let y = 0; y < cellSize; ++y) {
         for (let z = 0; z < cellSize; ++z) {
            for (let x = 0; x < cellSize; ++x) {
            const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
            if (y < height) {
               world.setVoxel(x, y, z, 1);
            }
            }
         }
      }


   and some code to actually generate geometry like we covered in `the article on
   custom BufferGeometry <custom-buffergeometry>`.


   .. code:: javascript

      const {positions, normals, indices} = world.generateGeometryDataForCell(0, 0, 0);
      const geometry = new THREE.BufferGeometry();
      const material = new THREE.MeshLambertMaterial({color: 'green'});

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      geometry.setAttribute(
            'position',
            new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      geometry.setAttribute(
            'normal',
            new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      geometry.setIndex(indices);
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);


   let's try it


      `click here to open in a separate
      window <https://threejs.org/manual/examples/voxel-geometry-culled-faces.html>`__

   That seems to be working! Okay, let's add in textures.

   Searching on the net I found `this set <https://www.minecraftforum.net/forums/mapping-and-modding-java-edition/resource-packs/1245961-16x-1-7-4-wip-flourish>`__
   of `CC-BY-NC-SA <https://creativecommons.org/licenses/by-nc-sa/4.0/>`__ licensed
   minecraft textures by `Joshtimus <https://www.minecraftforum.net/members/Joshtimus>`__. 
   I picked a few at random and built this `texture atlas <https://www.bing.com/search?q=texture+atlas>`__.

   .. image:: https://threejs.org/manual/examples/resources/images/minecraft/flourish-cc-by-nc-sa.png


   To make things simple they are arranged a voxel type per column where the top row is
   the side of a voxel. The 2nd row is the top of voxel, and the 3rd row is the bottom
   of the voxel.

   Knowing that we can add info to our ``VoxelWorld.faces`` data to specify for each
   face which row to use and the UVs to use for that face.


   .. code:: javascript

      VoxelWorld.faces = [
         { // left
      +     uvRow: 0,
            dir: [ -1,  0,  0, ],
            corners: [
      -       [ 0, 1, 0 ],
      -       [ 0, 0, 0 ],
      -       [ 0, 1, 1 ],
      -       [ 0, 0, 1 ],
      +       { pos: [ 0, 1, 0 ], uv: [ 0, 1 ], },
      +       { pos: [ 0, 0, 0 ], uv: [ 0, 0 ], },
      +       { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
      +       { pos: [ 0, 0, 1 ], uv: [ 1, 0 ], },
            ],
         },
         { // right
      +     uvRow: 0,
            dir: [  1,  0,  0, ],
            corners: [
      -       [ 1, 1, 1 ],
      -       [ 1, 0, 1 ],
      -       [ 1, 1, 0 ],
      -       [ 1, 0, 0 ],
      +       { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
      +       { pos: [ 1, 0, 1 ], uv: [ 0, 0 ], },
      +       { pos: [ 1, 1, 0 ], uv: [ 1, 1 ], },
      +       { pos: [ 1, 0, 0 ], uv: [ 1, 0 ], },
            ],
         },
         { // bottom
      +     uvRow: 1,
            dir: [  0, -1,  0, ],
            corners: [
      -       [ 1, 0, 1 ],
      -       [ 0, 0, 1 ],
      -       [ 1, 0, 0 ],
      -       [ 0, 0, 0 ],
      +       { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
      +       { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
      +       { pos: [ 1, 0, 0 ], uv: [ 1, 1 ], },
      +       { pos: [ 0, 0, 0 ], uv: [ 0, 1 ], },
            ],
         },
         { // top
      +     uvRow: 2,
            dir: [  0,  1,  0, ],
            corners: [
      -       [ 0, 1, 1 ],
      -       [ 1, 1, 1 ],
      -       [ 0, 1, 0 ],
      -       [ 1, 1, 0 ],
      +       { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
      +       { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
      +       { pos: [ 0, 1, 0 ], uv: [ 1, 0 ], },
      +       { pos: [ 1, 1, 0 ], uv: [ 0, 0 ], },
            ],
         },
         { // back
      +     uvRow: 0,
            dir: [  0,  0, -1, ],
            corners: [
      -       [ 1, 0, 0 ],
      -       [ 0, 0, 0 ],
      -       [ 1, 1, 0 ],
      -       [ 0, 1, 0 ],
      +       { pos: [ 1, 0, 0 ], uv: [ 0, 0 ], },
      +       { pos: [ 0, 0, 0 ], uv: [ 1, 0 ], },
      +       { pos: [ 1, 1, 0 ], uv: [ 0, 1 ], },
      +       { pos: [ 0, 1, 0 ], uv: [ 1, 1 ], },
            ],
         },
         { // front
      +     uvRow: 0,
            dir: [  0,  0,  1, ],
            corners: [
      -       [ 0, 0, 1 ],
      -       [ 1, 0, 1 ],
      -       [ 0, 1, 1 ],
      -       [ 1, 1, 1 ],
      +       { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
      +       { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
      +       { pos: [ 0, 1, 1 ], uv: [ 0, 1 ], },
      +       { pos: [ 1, 1, 1 ], uv: [ 1, 1 ], },
            ],
         },
      ];


   And we can update the code to use that data. We need to know the size of a tile in
   the texture atlas and the dimensions of the texture.


   .. code:: javascript

      class VoxelWorld {
      -  constructor(cellSize) {
      -     this.cellSize = cellSize;
      +   constructor(options) {
      +     this.cellSize = options.cellSize;
      +     this.tileSize = options.tileSize;
      +     this.tileTextureWidth = options.tileTextureWidth;
      +     this.tileTextureHeight = options.tileTextureHeight;
      +     const {cellSize} = this;
      +     this.cellSliceSize = cellSize * cellSize;
      +     this.cell = new Uint8Array(cellSize * cellSize * cellSize);
         }

         ...

         generateGeometryDataForCell(cellX, cellY, cellZ) {
      -     const {cellSize} = this;
      +     const {cellSize, tileSize, tileTextureWidth, tileTextureHeight} = this;
            const positions = [];
            const normals = [];
      +     const uvs = [];
            const indices = [];
            const startX = cellX * cellSize;
            const startY = cellY * cellSize;
            const startZ = cellZ * cellSize;

            for (let y = 0; y < cellSize; ++y) {
            const voxelY = startY + y;
            for (let z = 0; z < cellSize; ++z) {
               const voxelZ = startZ + z;
               for (let x = 0; x < cellSize; ++x) {
                  const voxelX = startX + x;
                  const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
                  if (voxel) {
                  const uvVoxel = voxel - 1;  // voxel 0 is sky so for UVs we start at 0
                  // There is a voxel here but do we need faces for it?
      -             for (const {dir, corners} of VoxelWorld.faces) {
      +             for (const {dir, corners, uvRow} of VoxelWorld.faces) {
                     const neighbor = this.getVoxel(
                        voxelX + dir[0],
                        voxelY + dir[1],
                        voxelZ + dir[2]);
                     if (!neighbor) {
                        // this voxel has no neighbor in this direction so we need a face.
                        const ndx = positions.length / 3;
      -                 for (const pos of corners) {
      +                 for (const {pos, uv} of corners) {
                        positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                        normals.push(...dir);
      +                   uvs.push(
      +                         (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
      +                     1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                        }
                        indices.push(
                        ndx, ndx + 1, ndx + 2,
                        ndx + 2, ndx + 1, ndx + 3,
                        );
                     }
                  }
                  }
               }
            }
            }

            return {
            positions,
            normals,
            uvs,
            indices,
            };
         }
      }


   We then need to `load the texture <textures>`


   .. code:: javascript

      const loader = new THREE.TextureLoader();
      const texture = loader.load('resources/images/minecraft/flourish-cc-by-nc-sa.png', render);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      texture.colorSpace = THREE.SRGBColorSpace;


   and pass the settings to the ``VoxelWorld`` class


   .. code:: javascript

      + const tileSize = 16;
      + const tileTextureWidth = 256;
      + const tileTextureHeight = 64;
      - const world = new VoxelWorld(cellSize);
      + const world = new VoxelWorld({
      +   cellSize,
      +   tileSize,
      +   tileTextureWidth,
      +   tileTextureHeight,
      + });


   Let's actually use the UVs when we create the geometry and the texture when we make
   the material


   .. code:: javascript

      - const {positions, normals, indices} = world.generateGeometryDataForCell(0, 0, 0);
      + const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(0, 0, 0);
      const geometry = new THREE.BufferGeometry();
      - const material = new THREE.MeshLambertMaterial({color: 'green'});
      + const material = new THREE.MeshLambertMaterial({
      +   map: texture,
      +   side: THREE.DoubleSide,
      +   alphaTest: 0.1,
      +   transparent: true,
      + });

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      + const uvNumComponents = 2;
      geometry.setAttribute(
            'position',
            new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      geometry.setAttribute(
            'normal',
            new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      + geometry.setAttribute(
      +     'uv',
      +     new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      geometry.setIndex(indices);
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);


   One last thing, we actually need to set some voxels to use different textures.


   .. code:: javascript

      for (let y = 0; y < cellSize; ++y) {
         for (let z = 0; z < cellSize; ++z) {
            for (let x = 0; x < cellSize; ++x) {
            const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
            if (y < height) {
      -         world.setVoxel(x, y, z, 1);
      +         world.setVoxel(x, y, z, randInt(1, 17));
            }
            }
         }
      }

      + function randInt(min, max) {
      +   return Math.floor(Math.random() * (max - min) + min);
      + }


   and with that we get textures!


      `click here to open in a separate
      window <https://threejs.org/manual/examples/voxel-geometry-culled-faces-with-textures.html>`__

   Let's make it support more than one cell.

   To do this lets store cells in an object using cell ids. A cell id will just be a
   cell's coordinates separated by a comma. In other words if we ask for voxel 35,0,0
   that is in cell 1,0,0 so its id is ``"1,0,0"``.


   .. code:: javascript

      class VoxelWorld {
         constructor(options) {
            this.cellSize = options.cellSize;
            this.tileSize = options.tileSize;
            this.tileTextureWidth = options.tileTextureWidth;
            this.tileTextureHeight = options.tileTextureHeight;
            const {cellSize} = this;
            this.cellSliceSize = cellSize * cellSize;
      -     this.cell = new Uint8Array(cellSize * cellSize * cellSize);
      +     this.cells = {};
         }
      +   computeCellId(x, y, z) {
      +     const {cellSize} = this;
      +     const cellX = Math.floor(x / cellSize);
      +     const cellY = Math.floor(y / cellSize);
      +     const cellZ = Math.floor(z / cellSize);
      +     return `${cellX},${cellY},${cellZ}`;
      +   }
      +   getCellForVoxel(x, y, z) {
      -     const cellX = Math.floor(x / cellSize);
      -     const cellY = Math.floor(y / cellSize);
      -     const cellZ = Math.floor(z / cellSize);
      -     if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      -       return null;
      -     }
      -     return this.cell;
      +     return this.cells[this.computeCellId(x, y, z)];
         }

         ...
      }


   and now we can make ``setVoxel`` add new cells if we try to set a voxel in a cell
   that does not yet exist


   .. code:: javascript

         setVoxel(x, y, z, v) {
      -     const cell = this.getCellForVoxel(x, y, z);
      +     let cell = this.getCellForVoxel(x, y, z);
            if (!cell) {
      -       return 0;
      +       cell = this.addCellForVoxel(x, y, z);
            }
            const voxelOffset = this.computeVoxelOffset(x, y, z);
            cell[voxelOffset] = v;
         }
      +   addCellForVoxel(x, y, z) {
      +     const cellId = this.computeCellId(x, y, z);
      +     let cell = this.cells[cellId];
      +     if (!cell) {
      +       const {cellSize} = this;
      +       cell = new Uint8Array(cellSize * cellSize * cellSize);
      +       this.cells[cellId] = cell;
      +     }
      +     return cell;
      +   }


   Let's make this editable.

   First we`ll add a UI. Using radio buttons we can make an 8x2 array of tiles


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="ui">
      +     <div class="tiles">
      +       <input type="radio" name="voxel" id="voxel1" value="1"><label for="voxel1" style="background-position:   -0% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel2" value="2"><label for="voxel2" style="background-position: -100% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel3" value="3"><label for="voxel3" style="background-position: -200% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel4" value="4"><label for="voxel4" style="background-position: -300% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel5" value="5"><label for="voxel5" style="background-position: -400% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel6" value="6"><label for="voxel6" style="background-position: -500% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel7" value="7"><label for="voxel7" style="background-position: -600% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel8" value="8"><label for="voxel8" style="background-position: -700% -0%"></label>
      +     </div>
      +     <div class="tiles">
      +       <input type="radio" name="voxel" id="voxel9"  value="9" ><label for="voxel9"  style="background-position:  -800% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel10" value="10"><label for="voxel10" style="background-position:  -900% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel11" value="11"><label for="voxel11" style="background-position: -1000% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel12" value="12"><label for="voxel12" style="background-position: -1100% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel13" value="13"><label for="voxel13" style="background-position: -1200% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel14" value="14"><label for="voxel14" style="background-position: -1300% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel15" value="15"><label for="voxel15" style="background-position: -1400% -0%"></label>
      +       <input type="radio" name="voxel" id="voxel16" value="16"><label for="voxel16" style="background-position: -1500% -0%"></label>
      +     </div>
      +   </div>
      </body>


   And add some CSS to style it, display the tiles and highlight the current selection


   .. code:: javascript

      body {
            margin: 0;
      }
      #c {
            width: 100%;
            height: 100%;
            display: block;
      }
      + #ui {
      +     position: absolute;
      +     left: 10px;
      +     top: 10px;
      +     background: rgba(0, 0, 0, 0.8);
      +     padding: 5px;
      + }
      + #ui input[type=radio] {
      +   width: 0;
      +   height: 0;
      +   display: none;
      + }
      + #ui input[type=radio] + label {
      +   background-image: url('resources/images/minecraft/flourish-cc-by-nc-sa.png');
      +   background-size: 1600% 400%;
      +   image-rendering: pixelated;
      +   width: 64px;
      +   height: 64px;
      +   display: inline-block;
      + }
      + #ui input[type=radio]:checked + label {
      +   outline: 3px solid red;
      + }
      + @media (max-width: 600px), (max-height: 600px) {
      +   #ui input[type=radio] + label {
      +     width: 32px;
      +     height: 32px;
      +   }
      + }


   The UX will be as follows. If no tile is selected and you click a voxel that voxel
   will be erased or if you click a voxel and are holding the shift key it will be
   erased. Otherwise if a tiles is selected it will be added. You can deselect the
   selected tile type by clicking it again.

   This code will let the user unselect the highlighted radio button.


   .. code:: javascript

      let currentVoxel = 0;
      let currentId;

      document.querySelectorAll('#ui .tiles input[type=radio][name=voxel]').forEach((elem) => {
         elem.addEventListener('click', allowUncheck);
      });

      function allowUncheck() {
         if (this.id === currentId) {
            this.checked = false;
            currentId = undefined;
            currentVoxel = 0;
         } else {
            currentId = this.id;
            currentVoxel = parseInt(this.value);
         }
      }


   And this below code will let us set a voxel based on where the user clicks. It uses
   code similar to the code we made in `the article on picking <picking>` but
   it's not using the built in ``RayCaster``. Instead it's using
   ``VoxelWorld.intersectRay`` which returns the position of intersection and the
   normal of the face hit.


   .. code:: javascript

      function getCanvasRelativePosition(event) {
         const rect = canvas.getBoundingClientRect();
         return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
         };
      }

      function placeVoxel(event) {
         const pos = getCanvasRelativePosition(event);
         const x = (pos.x / canvas.width ) *  2 - 1;
         const y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y

         const start = new THREE.Vector3();
         const end = new THREE.Vector3();
         start.setFromMatrixPosition(camera.matrixWorld);
         end.set(x, y, 1).unproject(camera);

         const intersection = world.intersectRay(start, end);
         if (intersection) {
            const voxelId = event.shiftKey ? 0 : currentVoxel;
            // the intersection point is on the face. That means
            // the math imprecision could put us on either side of the face.
            // so go half a normal into the voxel if removing (currentVoxel = 0)
            // our out of the voxel if adding (currentVoxel  > 0)
            const pos = intersection.position.map((v, ndx) => {
            return v + intersection.normal[ndx] * (voxelId > 0 ? 0.5 : -0.5);
            });
            world.setVoxel(...pos, voxelId);
            updateVoxelGeometry(...pos);
            requestRenderIfNotRequested();
         }
      }

      const mouse = {
         x: 0,
         y: 0,
      };

      function recordStartPosition(event) {
         mouse.x = event.clientX;
         mouse.y = event.clientY;
         mouse.moveX = 0;
         mouse.moveY = 0;
      }
      function recordMovement(event) {
         mouse.moveX += Math.abs(mouse.x - event.clientX);
         mouse.moveY += Math.abs(mouse.y - event.clientY);
      }
      function placeVoxelIfNoMovement(event) {
         if (mouse.moveX < 5 && mouse.moveY < 5) {
            placeVoxel(event);
         }
         window.removeEventListener('pointermove', recordMovement);
         window.removeEventListener('pointerup', placeVoxelIfNoMovement);
      }
      canvas.addEventListener('pointerdown', (event) => {
         event.preventDefault();
         recordStartPosition(event);
         window.addEventListener('pointermove', recordMovement);
         window.addEventListener('pointerup', placeVoxelIfNoMovement);
      }, {passive: false});
      canvas.addEventListener('touchstart', (event) => {
         // stop scrolling
         event.preventDefault();
      }, {passive: false});


   There's a lot going on in the code above. Basically the mouse has a dual purpose.
   One is to move the camera. The other is to edit the world. Placing/Erasing a voxel
   happen when you let off the mouse but only if you have not moved the mouse since you
   first pressed down. This is just a guess that if you did move the mouse you were
   trying to move the camera, not place a block. ``moveX`` and ``moveY`` are in
   absolute movement so if you move to the left 10 and then back to the right 10 you'll
   have moved 20 units. In that case the user likely was just rotating the model back
   and forth and does not want to place a block. I didn't do any testing to see if
   ``5`` is a good range or not.

   In the code we call ``world.setVoxel`` to set a voxel and then
   ``updateVoxelGeometry`` to update the three.js geometry based on what's changed.

   Let's make that now. If the user clicks a voxel on the edge of a cell then the
   geometry for the voxel in the adjacent cell might need new geometry. This means we
   need to check the cell for the voxel we just edited as well as in all 6 directions
   from that cell.


   .. code:: javascript

      const neighborOffsets = [
         [ 0,  0,  0], // self
         [-1,  0,  0], // left
         [ 1,  0,  0], // right
         [ 0, -1,  0], // down
         [ 0,  1,  0], // up
         [ 0,  0, -1], // back
         [ 0,  0,  1], // front
      ];
      function updateVoxelGeometry(x, y, z) {
         const updatedCellIds = {};
         for (const offset of neighborOffsets) {
            const ox = x + offset[0];
            const oy = y + offset[1];
            const oz = z + offset[2];
            const cellId = world.computeCellId(ox, oy, oz);
            if (!updatedCellIds[cellId]) {
            updatedCellIds[cellId] = true;
            updateCellGeometry(ox, oy, oz);
            }
         }
      }


   I thought about checking for adjacent cells like


   .. code:: javascript

      const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
      if (voxelX === 0) {
         // update cell to the left
      } else if (voxelX === cellSize - 1) {
         // update cell to the right
      }


   and there would be 4 more checks for the other 4 directions but it occurred to me
   the code would be much simpler with just an array of offsets and saving off the cell
   ids of the cells we already updated. If the updated voxel is not on the edge of a
   cell then the test will quickly reject updating the same cell.

   For ``updateCellGeometry`` we're just going to take the code we had before that was
   generating the geometry for one cell and make it handle multiple cells.


   .. code:: javascript

      const cellIdToMesh = {};
      function updateCellGeometry(x, y, z) {
         const cellX = Math.floor(x / cellSize);
         const cellY = Math.floor(y / cellSize);
         const cellZ = Math.floor(z / cellSize);
         const cellId = world.computeCellId(x, y, z);
         let mesh = cellIdToMesh[cellId];
         const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();

         const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(cellX, cellY, cellZ);
         const positionNumComponents = 3;
         geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
         const normalNumComponents = 3;
         geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
         const uvNumComponents = 2;
         geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
         geometry.setIndex(indices);
         geometry.computeBoundingSphere();

         if (!mesh) {
            mesh = new THREE.Mesh(geometry, material);
            mesh.name = cellId;
            cellIdToMesh[cellId] = mesh;
            scene.add(mesh);
            mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);
         }
      }


   The code above checks a map of cell ids to meshes. If we ask for a cell that doesn't
   exist a new ``Mesh`` is made and added to the
   correct place in world space. At the end we update the attributes and indices with
   the new data.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/voxel-geometry-culled-faces-ui.html>`__

   Some notes:

   ``RayCaster`` might have worked just fine. I didn't try it. Instead I found `a voxel
   specific raycaster <https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf>`__.
   that is optimized for voxels.

   I made ``intersectRay`` part of VoxelWorld because it seemed like if it gets too
   slow we could raycast against cells before raycasting on voxels as a simple speed up
   if it becomes too slow.

   You might want to change the length of the raycast as currently it's all the way to
   Z-far. I expect if the user clicks something too far way they don't really want to
   be placing blocks on the other side of the world that are 1 or 2 pixel large.

   Calling ``geometry.computeBoundingSphere`` might be slow. We could just manually set
   the bounding sphere to the fit the entire cell.

   Do we want remove cells if all voxels in that cell are 0? That would probably be
   reasonable change if we wanted to ship this.

   Thinking about how this works it's clear the absolute worst case is a checkerboard
   of on and off voxels. I don't know off the top of my head what other strategies to
   use if things get too slow. Maybe getting too slow would just encourage the user not
   to make giant checkerboard areas.

   To keep it simple the texture atlas is just 1 column per voxel type. It would be
   better to make something more flexible where we have a table of voxel types and each
   type can specify where its face textures are in the atlas. As it is lots of space is
   wasted.

   Looking at real minecraft there are tiles that are not voxels, not cubes. Like a
   fence tile or flowers. To do that we'd again need some table of voxel types and for
   each voxel whether it's a cube or some other geometry. If it's not a cube the
   neighbor check when generating the geometry would also need to change. A flower
   voxel next to another voxel should not remove the faces between them.

   If you want to make some minecraft like thing using three.js I hope this has given
   you some ideas where to start and how to generate some what efficient geometry.



.. _F40:

Start making a Game
===================

   -  `Start making a Game <https://threejs.org/manual/en/game.html>`__


   Many people want to write games using three.js. This article will hopefully give you
   some ideas on how to start.

   At least at the time I'm writing this article it's probably going to be the longest
   article on this site. It's possible the code here is massively over engineered but
   as I wrote each new feature I'd run into a problem that needed a solution I'm used
   to from other games I've written. In other words each new solution seemed important
   so I'll try to show why. Of course the smaller your game the less you might need
   some of the solutions shown here but this is a pretty small game and yet with the
   complexities of 3D characters many things take more organization than they might
   with 2D characters.

   As an example if you're making PacMan in 2D, when PacMan turns a corner that happens
   instantly at 90 degrees. There is no in-between step. But in a 3D game often we need
   the character to rotate over several frames. That simple change can add a bunch of
   complexity and require different solutions.

   The majority of the code here will not really be three.js and that's important to
   note, **three.js is not a game engine**. Three.js is a 3D library. It provides a
   `scene graph <scenegraph>` and features for displaying 3D objects added to
   that scene graph but it does not provide all the other things needed to make a game.
   No collisions, no physics, no input systems, no path finding, etc, etc... So, we'll
   have to provide those things ourselves.

   I ended up writing quite a bit of code to make this simple *unfinished* game like
   thing and again, it's certainly possible I over engineered and there are simpler
   solutions but I feel like I actually didn't write enough code and hopefully I can
   explain what I think is missing.

   Many of the ideas here are heavily influenced by `Unity <https://unity.com>`__. If
   you're not familiar with Unity that probably does not matter. I only bring it up as
   10s of 1000s of games have shipped using these ideas.

   Let's start with the three.js parts. We need to load models for our game.

   At `opengameart.org <https://opengameart.org>`__ I found this `animated knight
   model <https://opengameart.org/content/lowpoly-animated-knight>`__ by
   `quaternius <https://opengameart.org/users/quaternius>`__

   .. image:: https://threejs.org/manual/resources/images/knight.jpg


   `quaternius <https://opengameart.org/users/quaternius>`__ also made `these animated
   animals <https://opengameart.org/content/lowpoly-animated-farm-animal-pack>`__.

   .. image:: https://threejs.org/manual/resources/images/animals.jpg


   These seem like good models to start with so the first thing we need to do is load
   them.

   We covered `loading glTF files before <load-gltf>`. The difference this time
   is we need to load multiple models and we can't start the game until all the models
   are loaded.

   Fortunately three.js provides the ``LoadingManager`` just for this purpose. We create 
   a ``LoadingManager`` and pass it to the other loaders. The ``LoadingManager`` provides 
   both ``onProgress`` and ``onLoad`` properties we can attach callbacks to. The ``onLoad``
   callback will be called when all files have been loaded. The ``onProgress``
   callback as called after each individual file arrives to give as a chance to show
   loading progress.

   Starting with the code from `loading a glTF file <load-gltf>` I removed all
   the code related to framing the scene and added this code to load all models.


   .. code:: javascript

      const manager = new THREE.LoadingManager();
      manager.onLoad = init;
      const models = {
         pig:    { url: 'resources/models/animals/Pig.gltf' },
         cow:    { url: 'resources/models/animals/Cow.gltf' },
         llama:  { url: 'resources/models/animals/Llama.gltf' },
         pug:    { url: 'resources/models/animals/Pug.gltf' },
         sheep:  { url: 'resources/models/animals/Sheep.gltf' },
         zebra:  { url: 'resources/models/animals/Zebra.gltf' },
         horse:  { url: 'resources/models/animals/Horse.gltf' },
         knight: { url: 'resources/models/knight/KnightCharacter.gltf' },
      };
      {
         const gltfLoader = new GLTFLoader(manager);
         for (const model of Object.values(models)) {
            gltfLoader.load(model.url, (gltf) => {
            model.gltf = gltf;
            });
         }
      }

      function init() {
         // TBD
      }


   This code will load all the models above and the ``LoadingManager`` will call
   ``init`` when done. We'll use the ``models`` object later to let us access the
   loaded models so the `GLTFLoader </docs/#examples/loaders/GLTFLoader>`__
   callback for each individual model attaches the loaded data to that model's info.

   All the models with all their animation are currently about 6.6meg. That's a pretty
   big download. Assuming your server supports compression (the server this site runs
   on does) it's able to compress them to around 1.4meg. That's definitely better than
   6.6meg bit it's still not a tiny amount of data. It would probably be good if we
   added a progress bar so the user has some idea how much longer they have to wait.

   So, let's add an ``onProgress`` callback. It will be called with 3 arguments, 
   the ``url`` of the last loaded object and then the number of items loaded so far 
   as well as the total number of items.

   Let's setup some HTML for a loading bar


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="loading">
      +     <div>
      +       <div>...loading...</div>
      +       <div class="progress"><div id="progressbar"></div></div>
      +     </div>
      +   </div>
      </body>


   We'll look up the ``#progressbar`` div and we can set the width from 0% to 100% to
   show our progress. All we need to do is set that in our callback.


   .. code:: javascript

      const manager = new THREE.LoadingManager();
      manager.onLoad = init;

      + const progressbarElem = document.querySelector('#progressbar');
      + manager.onProgress = (url, itemsLoaded, itemsTotal) => {
      +   progressbarElem.style.width = `${itemsLoaded / itemsTotal * 100 | 0}%`;
      + };


   We already setup ``init`` to be called when all the models are loaded so we can turn
   off the progress bar by hiding the ``#loading`` element.


   .. code:: javascript

      function init() {
      +   // hide the loading bar
      +   const loadingElem = document.querySelector('#loading');
      +   loadingElem.style.display = 'none';
      }


   Here's a bunch of CSS for styling the bar. The CSS makes the ``#loading`` ``<div>``
   the full size of the page and centers its children. The CSS makes a ``.progress``
   area to contain the progress bar. The CSS also gives the progress bar a CSS
   animation of diagonal stripes.


   .. code:: javascript

      #loading {
         position: absolute;
         left: 0;
         top: 0;
         width: 100%;
         height: 100%;
         display: flex;
         align-items: center;
         justify-content: center;
         text-align: center;
         font-size: xx-large;
         font-family: sans-serif;
      }
      #loading>div>div {
         padding: 2px;
      }
      .progress {
         width: 50vw;
         border: 1px solid black;
      }
      #progressbar {
         width: 0;
         transition: width ease-out .5s;
         height: 1em;
         background-color: #888;
         background-image: linear-gradient(
            -45deg,
            rgba(255, 255, 255, .5) 25%,
            transparent 25%,
            transparent 50%,
            rgba(255, 255, 255, .5) 50%,
            rgba(255, 255, 255, .5) 75%,
            transparent 75%,
            transparent
         );
         background-size: 50px 50px;
         animation: progressanim 2s linear infinite;
      }

      @keyframes progressanim {
         0% {
            background-position: 50px 50px;
         }
         100% {
            background-position: 0 0;
         }
      }


   Now that we have a progress bar let's deal with the models. These models have
   animations and we want to be able to access those animations. Animations are stored
   in an array by default be we'd like to be able to easily access them by name so
   let's setup an ``animations`` property for each model to do that. Note of course
   this means animations must have unique names.


   .. code:: javascript

      + function prepModelsAndAnimations() {
      +   Object.values(models).forEach(model => {
      +     const animsByName = {};
      +     model.gltf.animations.forEach((clip) => {
      +       animsByName[clip.name] = clip;
      +     });
      +     model.animations = animsByName;
      +   });
      + }

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

      +   prepModelsAndAnimations();
      }


   Let's display the animated models.

   Unlike the `previous example of loading a glTF file <load-gltf>` This time we
   probably want to be able to display more than one instance of each model. To do
   this, instead of adding the loaded gltf scene directly like we did in `the article
   on loading a glTF <load-gltf>`, we instead want to clone the scene and in
   particular we want to clone it for skinned animated characters. Fortunately there's
   a utility function, ``SkeletonUtils.clone`` we can use to do this. So, first we need
   to include the utils.


   .. code:: javascript

      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
      + import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';


   Then we can clone the models we just loaded


   .. code:: javascript

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

         prepModelsAndAnimations();

      +   Object.values(models).forEach((model, ndx) => {
      +     const clonedScene = SkeletonUtils.clone(model.gltf.scene);
      +     const root = new THREE.Object3D();
      +     root.add(clonedScene);
      +     scene.add(root);
      +     root.position.x = (ndx - 3) * 3;
      +   });
      }


   Above, for each model, we clone the ``gltf.scene`` we loaded and we parent that to a
   new ``Object3D``. We need to parent it to another object because when we play 
   animations the animation will apply animated positions to the nodes in the 
   loaded scene which means we won't have control over those positions.

   To play the animations each model we clone needs an ``AnimationMixer``. An
   ``AnimationMixer`` contains 1 or more ``AnimationAction``\ s. An
   ``AnimationAction`` references an ``AnimationClip``. ``AnimationAction``\ s 
   have all kinds of settings for playing then chaining to another action or cross 
   fading between actions. Let's just get the first ``AnimationClip`` and create 
   an action for it. The default is for an action to play its clip in a loop forever.


   .. code:: javascript

      + const mixers = [];

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

         prepModelsAndAnimations();

         Object.values(models).forEach((model, ndx) => {
            const clonedScene = SkeletonUtils.clone(model.gltf.scene);
            const root = new THREE.Object3D();
            root.add(clonedScene);
            scene.add(root);
            root.position.x = (ndx - 3) * 3;

      +     const mixer = new THREE.AnimationMixer(clonedScene);
      +     const firstClip = Object.values(model.animations)[0];
      +     const action = mixer.clipAction(firstClip);
      +     action.play();
      +     mixers.push(mixer);
         });
      }


   We called ``play`` to start the action and stored off all the ``AnimationMixers`` 
   in an array called ``mixers``. Finally we need to update each ``AnimationMixer`` 
   in our render loop by computing the time since the last frame and passing that to
   ``AnimationMixer.update``.


   .. code:: javascript

      + let then = 0;
      function render(now) {
      +   now *= 0.001;  // convert to seconds
      +   const deltaTime = now - then;
      +   then = now;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

      +   for (const mixer of mixers) {
      +     mixer.update(deltaTime);
      +   }

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   And with that we should get each model loaded and playing its first animation.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/game-load-models.html>`__

   Let's make it so we can check all of the animations. We'll add all of the clips as
   actions and then enable just one at a time.


   .. code:: javascript

      - const mixers = [];
      + const mixerInfos = [];

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

         prepModelsAndAnimations();

         Object.values(models).forEach((model, ndx) => {
            const clonedScene = SkeletonUtils.clone(model.gltf.scene);
            const root = new THREE.Object3D();
            root.add(clonedScene);
            scene.add(root);
            root.position.x = (ndx - 3) * 3;

            const mixer = new THREE.AnimationMixer(clonedScene);
      -     const firstClip = Object.values(model.animations)[0];
      -     const action = mixer.clipAction(firstClip);
      -     action.play();
      -     mixers.push(mixer);
      +     const actions = Object.values(model.animations).map((clip) => {
      +       return mixer.clipAction(clip);
      +     });
      +     const mixerInfo = {
      +       mixer,
      +       actions,
      +       actionNdx: -1,
      +     };
      +     mixerInfos.push(mixerInfo);
      +     playNextAction(mixerInfo);
         });
      }

      + function playNextAction(mixerInfo) {
      +   const {actions, actionNdx} = mixerInfo;
      +   const nextActionNdx = (actionNdx + 1) % actions.length;
      +   mixerInfo.actionNdx = nextActionNdx;
      +   actions.forEach((action, ndx) => {
      +     const enabled = ndx === nextActionNdx;
      +     action.enabled = enabled;
      +     if (enabled) {
      +       action.play();
      +     }
      +   });
      + }


   The code above makes an array of ``AnimationAction``\ s, one for each
   ``AnimationClip``. It makes an array of objects, ``mixerInfos``, with references 
   to the ``AnimationMixer`` and all the ``AnimationAction``\ s for each model.
   It then calls ``playNextAction`` which sets ``enabled`` on all but one action for
   that mixer.

   We need to update the render loop for the new array


   .. code:: javascript

      - for (const mixer of mixers) {
      + for (const {mixer} of mixerInfos) {
         mixer.update(deltaTime);
      }


   Let's make it so pressing a key 1 to 8 will play the next animation for each model


   .. code:: javascript

      window.addEventListener('keydown', (e) => {
         const mixerInfo = mixerInfos[e.keyCode - 49];
         if (!mixerInfo) {
            return;
         }
         playNextAction(mixerInfo);
      });


   Now you should be able to click on the example and then press keys 1 through 8 to
   cycle each of the models through their available animations.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/game-check-animations.html>`__

   So that is arguably the sum-total of the three.js portion of this article. We
   covered loading multiple files, cloning skinned models, and playing animations on
   them. In a real game you'd have to do a ton more manipulation of
   ``AnimationAction`` objects.

   Let's start making a game infrastructure

   A common pattern for making a modern game is to use an `Entity Component
   System <https://www.bing.com/search?q=entity+component+system>`__. In an Entity
   Component System an object in a game is called an *entity* that consists of a bunch
   of *components*. You build up entities by deciding which components to attach to
   them. So, let's make an Entity Component System.

   We'll call our entities ``GameObject``. It's effectively just a collection of
   components and a three.js ``Object3D``.


   .. code:: javascript

      function removeArrayElement(array, element) {
         const ndx = array.indexOf(element);
         if (ndx >= 0) {
            array.splice(ndx, 1);
         }
      }

      class GameObject {
         constructor(parent, name) {
            this.name = name;
            this.components = [];
            this.transform = new THREE.Object3D();
            parent.add(this.transform);
         }
         addComponent(ComponentType, ...args) {
            const component = new ComponentType(this, ...args);
            this.components.push(component);
            return component;
         }
         removeComponent(component) {
            removeArrayElement(this.components, component);
         }
         getComponent(ComponentType) {
            return this.components.find(c => c instanceof ComponentType);
         }
         update() {
            for (const component of this.components) {
            component.update();
            }
         }
      }


   Calling ``GameObject.update`` calls ``update`` on all the components.

   I included a name only to help in debugging so if I look at a ``GameObject`` in the
   debugger I can see a name to help identify it.

   Some things that might seem a little strange:

   ``GameObject.addComponent`` is used to create components. Whether or not this a good
   idea or a bad idea I'm not sure. My thinking was it makes no sense for a component
   to exist outside of a gameobject so I thought it might be good if creating a
   component automatically added that component to the gameobject and passed the
   gameobject to the component's constructor. In other words to add a component you do
   this


   .. code:: javascript

      const gameObject = new GameObject(scene, 'foo');
      gameObject.addComponent(TypeOfComponent);


   If I didn't do it this way you'd instead do something like this


   .. code:: javascript

      const gameObject = new GameObject(scene, 'foo');
      const component = new TypeOfComponent(gameObject);
      gameObject.addComponent(component);


   Is it better that the first way is shorter and more automated or is it worse because
   it looks out of the ordinary? I don't know.

   ``GameObject.getComponent`` looks up components by type. That has the implication
   that you can not have 2 components of the same type on a single game object or at
   least if you do you can only look up the first one without adding some other API.

   It's common for one component to look up another and when looking them up they have
   to match by type otherwise you might get the wrong one. We could instead give each
   component a name and you could look them up by name. That would be more flexible in
   that you could have more than one component of the same type but it would also be
   more tedious. Again, I'm not sure which is better.

   On to the components themselves. Here is their base class.


   .. code:: javascript

      // Base for all components
      class Component {
         constructor(gameObject) {
            this.gameObject = gameObject;
         }
         update() {
         }
      }


   Do components need a base class? JavaScript is not like most strictly typed
   languages so effectively we could have no base class and just leave it up to each
   component to do whatever it wants in its constructor knowing that the first argument
   is always the component's gameobject. If it doesn't care about gameobject it
   wouldn't store it. I kind of feel like this common base is good though. It means if
   you have a reference to a component you know you can find its parent gameobject
   always and from its parent you can easily look up other components as well as look
   at its transform.

   To manage the gameobjects we probably need some kind of gameobject manager. You
   might think we could just keep an array of gameobjects but in a real game the
   components of a gameobject might add and remove other gameobjects at runtime. For
   example a gun gameobject might add a bullet gameobject every time the gun fires. A
   monster gameobject might remove itself if it has been killed. We then would have an
   issue that we might have code like this


   .. code:: javascript

      for (const gameObject of globalArrayOfGameObjects) {
         gameObject.update();
      }


   The loop above would fail or do un-expected things if gameobjects are added or
   removed from ``globalArrayOfGameObjects`` in the middle of the loop in some
   component's ``update`` function.

   To try to prevent that problem we need something a little safer. Here's one attempt.


   .. code:: javascript

      class SafeArray {
         constructor() {
            this.array = [];
            this.addQueue = [];
            this.removeQueue = new Set();
         }
         get isEmpty() {
            return this.addQueue.length + this.array.length > 0;
         }
         add(element) {
            this.addQueue.push(element);
         }
         remove(element) {
            this.removeQueue.add(element);
         }
         forEach(fn) {
            this._addQueued();
            this._removeQueued();
            for (const element of this.array) {
            if (this.removeQueue.has(element)) {
               continue;
            }
            fn(element);
            }
            this._removeQueued();
         }
         _addQueued() {
            if (this.addQueue.length) {
            this.array.splice(this.array.length, 0, ...this.addQueue);
            this.addQueue = [];
            }
         }
         _removeQueued() {
            if (this.removeQueue.size) {
            this.array = this.array.filter(element => !this.removeQueue.has(element));
            this.removeQueue.clear();
            }
         }
      }


   The class above lets you add or remove elements from the ``SafeArray`` but won't
   mess with the array itself while it's being iterated over. Instead new elements get
   added to ``addQueue`` and removed elements to the ``removeQueue`` and then added or
   removed outside of the loop.

   Using that here is our class to manage gameobjects.


   .. code:: javascript

      class GameObjectManager {
         constructor() {
            this.gameObjects = new SafeArray();
         }
         createGameObject(parent, name) {
            const gameObject = new GameObject(parent, name);
            this.gameObjects.add(gameObject);
            return gameObject;
         }
         removeGameObject(gameObject) {
            this.gameObjects.remove(gameObject);
         }
         update() {
            this.gameObjects.forEach(gameObject => gameObject.update());
         }
      }


   With all that now let's make our first component. This component will just manage a
   skinned three.js object like the ones we just created. To keep it simple it will
   just have one method, ``setAnimation`` that takes the name of the animation to play
   and plays it.


   .. code:: javascript

      class SkinInstance extends Component {
         constructor(gameObject, model) {
            super(gameObject);
            this.model = model;
            this.animRoot = SkeletonUtils.clone(this.model.gltf.scene);
            this.mixer = new THREE.AnimationMixer(this.animRoot);
            gameObject.transform.add(this.animRoot);
            this.actions = {};
         }
         setAnimation(animName) {
            const clip = this.model.animations[animName];
            // turn off all current actions
            for (const action of Object.values(this.actions)) {
            action.enabled = false;
            }
            // get or create existing action for clip
            const action = this.mixer.clipAction(clip);
            action.enabled = true;
            action.reset();
            action.play();
            this.actions[animName] = action;
         }
         update() {
            this.mixer.update(globals.deltaTime);
         }
      }


   You can see it's basically the code we had before that clones the scene we loaded,
   then sets up an ``AnimationMixer``. ``setAnimation`` adds a ``AnimationAction`` for 
   a particular ``AnimationClip`` if one does not already exist and disables all 
   existing actions.

   The code references ``globals.deltaTime``. Let's make a globals object


   .. code:: javascript

      const globals = {
         time: 0,
         deltaTime: 0,
      };


   And update it in the render loop


   .. code:: javascript

      let then = 0;
      function render(now) {
         // convert to seconds
         globals.time = now * 0.001;
         // make sure delta time isn't too big.
         globals.deltaTime = Math.min(globals.time - then, 1 / 20);
         then = globals.time;


   The check above for making sure ``deltaTime`` is not more than 1/20th of a second is
   because otherwise we'd get a huge value for ``deltaTime`` if we hide the tab. We
   might hide it for seconds or minutes and then when our tab was brought to the front
   ``deltaTime`` would be huge and might teleport characters across our game world if
   we had code like


   .. code:: javascript

      position += velocity * deltaTime;


   By limiting the maximum ``deltaTime`` that issue is prevented.

   Now let's make a component for the player.


   .. code:: javascript

      class Player extends Component {
         constructor(gameObject) {
            super(gameObject);
            const model = models.knight;
            this.skinInstance = gameObject.addComponent(SkinInstance, model);
            this.skinInstance.setAnimation('Run');
         }
      }


   The player calls ``setAnimation`` with ``'Run'``. To know which animations are
   available I modified our previous example to print out the names of the animations


   .. code:: javascript

      function prepModelsAndAnimations() {
         Object.values(models).forEach(model => {
      +     console.log('------->:', model.url);
            const animsByName = {};
            model.gltf.animations.forEach((clip) => {
            animsByName[clip.name] = clip;
      +       console.log('  ', clip.name);
            });
            model.animations = animsByName;
         });
      }


   And running it got this list in `the JavaScript
   console <https://developers.google.cn/web/tools/chrome-devtools/console/javascript>`__.


   .. code:: javascript

         ------->:  resources/models/animals/Pig.gltf
            Idle
            Death
            WalkSlow
            Jump
            Walk
         ------->:  resources/models/animals/Cow.gltf
            Walk
            Jump
            WalkSlow
            Death
            Idle
         ------->:  resources/models/animals/Llama.gltf
            Jump
            Idle
            Walk
            Death
            WalkSlow
         ------->:  resources/models/animals/Pug.gltf
            Jump
            Walk
            Idle
            WalkSlow
            Death
         ------->:  resources/models/animals/Sheep.gltf
            WalkSlow
            Death
            Jump
            Walk
            Idle
         ------->:  resources/models/animals/Zebra.gltf
            Jump
            Walk
            Death
            WalkSlow
            Idle
         ------->:  resources/models/animals/Horse.gltf
            Jump
            WalkSlow
            Death
            Walk
            Idle
         ------->:  resources/models/knight/KnightCharacter.gltf
            Run_swordRight
            Run
            Idle_swordLeft
            Roll_sword
            Idle
            Run_swordAttack


   Fortunately the names of the animations for all the animals match which will come in
   handy later. For now we only care the that the player has an animation called
   ``Run``.

   Let's use these components. Here's the updated init function. All it does is create
   a ``GameObject`` and add a ``Player`` component to it.


   .. code:: javascript

      const globals = {
         time: 0,
         deltaTime: 0,
      };
      + const gameObjectManager = new GameObjectManager();

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

         prepModelsAndAnimations();

      +   {
      +     const gameObject = gameObjectManager.createGameObject(scene, 'player');
      +     gameObject.addComponent(Player);
      +   }
      }


   And we need to call ``gameObjectManager.update`` in our render loop


   .. code:: javascript

      let then = 0;
      function render(now) {
         // convert to seconds
         globals.time = now * 0.001;
         // make sure delta time isn't too big.
         globals.deltaTime = Math.min(globals.time - then, 1 / 20);
         then = globals.time;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

      -  for (const {mixer} of mixerInfos) {
      -     mixer.update(deltaTime);
      -   }
      +   gameObjectManager.update();

         renderer.render(scene, camera);

         requestAnimationFrame(render);
      }


   and if we run that we get a single player.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/game-just-player.html>`__

   That was a lot of code just for an entity component system but it's infrastructure
   that most games need.

   Let's add an input system. Rather than read keys directly we'll make a class that
   other parts of the code can check ``left`` or ``right``. That way we can assign
   multiple ways to input ``left`` or ``right`` etc.. We'll start with just keys


   .. code:: javascript

      // Keeps the state of keys/buttons
      //
      // You can check
      //
      //   inputManager.keys.left.down
      //
      // to see if the left key is currently held down
      // and you can check
      //
      //   inputManager.keys.left.justPressed
      //
      // To see if the left key was pressed this frame
      //
      // Keys are 'left', 'right', 'a', 'b', 'up', 'down'
      class InputManager {
         constructor() {
            this.keys = {};
            const keyMap = new Map();

            const setKey = (keyName, pressed) => {
            const keyState = this.keys[keyName];
            keyState.justPressed = pressed && !keyState.down;
            keyState.down = pressed;
            };

            const addKey = (keyCode, name) => {
            this.keys[name] = { down: false, justPressed: false };
            keyMap.set(keyCode, name);
            };

            const setKeyFromKeyCode = (keyCode, pressed) => {
            const keyName = keyMap.get(keyCode);
            if (!keyName) {
               return;
            }
            setKey(keyName, pressed);
            };

            addKey(37, 'left');
            addKey(39, 'right');
            addKey(38, 'up');
            addKey(40, 'down');
            addKey(90, 'a');
            addKey(88, 'b');

            window.addEventListener('keydown', (e) => {
            setKeyFromKeyCode(e.keyCode, true);
            });
            window.addEventListener('keyup', (e) => {
            setKeyFromKeyCode(e.keyCode, false);
            });
         }
         update() {
            for (const keyState of Object.values(this.keys)) {
            if (keyState.justPressed) {
               keyState.justPressed = false;
            }
            }
         }
      }


   The code above tracks whether keys are up or down and you can check if a key is
   currently pressed by checking for example ``inputManager.keys.left.down``. It also
   has a ``justPressed`` property for each key so that you can check the user just
   pressed the key. For example a jump key you don't want to know if the button is
   being held down, you want to know did the user press it now.

   Let's create an instance of ``InputManager``


   .. code:: javascript

      const globals = {
         time: 0,
         deltaTime: 0,
      };
      const gameObjectManager = new GameObjectManager();
      + const inputManager = new InputManager();


   and update it in our render loop


   .. code:: javascript

      function render(now) {

         ...

         gameObjectManager.update();
      +   inputManager.update();

         ...
      }


   It needs to be called after ``gameObjectManager.update`` otherwise ``justPressed``
   would never be true inside a component's ``update`` function.

   Let's use it in the ``Player`` component


   .. code:: javascript

      + const kForward = new THREE.Vector3(0, 0, 1);
      const globals = {
         time: 0,
         deltaTime: 0,
      +   moveSpeed: 16,
      };

      class Player extends Component {
         constructor(gameObject) {
            super(gameObject);
            const model = models.knight;
            this.skinInstance = gameObject.addComponent(SkinInstance, model);
            this.skinInstance.setAnimation('Run');
      +     this.turnSpeed = globals.moveSpeed / 4;
         }
      +   update() {
      +     const {deltaTime, moveSpeed} = globals;
      +     const {transform} = this.gameObject;
      +     const delta = (inputManager.keys.left.down  ?  1 : 0) +
      +                   (inputManager.keys.right.down ? -1 : 0);
      +     transform.rotation.y += this.turnSpeed * delta * deltaTime;
      +     transform.translateOnAxis(kForward, moveSpeed * deltaTime);
      +   }
      }


   The code above uses ``Object3D.transformOnAxis`` to move the player forward.
   ``Object3D.transformOnAxis`` works in local space so it only works if the object 
   in question is at the root of the scene, not if it's parented to something else.
   `[§R1]`

   We also added a global ``moveSpeed`` and based a ``turnSpeed`` on the move speed.
   The turn speed is based on the move speed to try to make sure a character can turn
   sharply enough to meet its target. If ``turnSpeed`` so too small a character will
   turn around and around circling its target but never hitting it. I didn't bother to
   do the math to calculate the required turn speed for a given move speed. I just
   guessed.

   The code so far would work but if the player runs off the screen there's no way to
   find out where they are. Let's make it so if they are offscreen for more than a
   certain time they get teleported back to the origin. We can do that by using the
   three.js ``Frustum`` class to check if a point is inside the camera's view frustum.

   We need to build a frustum from the camera. We could do this in the Player component
   but other objects might want to use this too so let's add another gameobject with a
   component to manage a frustum.


   .. code:: javascript

      class CameraInfo extends Component {
         constructor(gameObject) {
            super(gameObject);
            this.projScreenMatrix = new THREE.Matrix4();
            this.frustum = new THREE.Frustum();
         }
         update() {
            const {camera} = globals;
            this.projScreenMatrix.multiplyMatrices(
               camera.projectionMatrix,
               camera.matrixWorldInverse);
            this.frustum.setFromProjectionMatrix(this.projScreenMatrix);
         }
      }


   Then let's setup another gameobject at init time.


   .. code:: javascript

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

         prepModelsAndAnimations();

      +   {
      +     const gameObject = gameObjectManager.createGameObject(camera, 'camera');
      +     globals.cameraInfo = gameObject.addComponent(CameraInfo);
      +   }

         {
            const gameObject = gameObjectManager.createGameObject(scene, 'player');
            gameObject.addComponent(Player);
         }
      }


   and now we can use it in the ``Player`` component.


   .. code:: javascript

      class Player extends Component {
         constructor(gameObject) {
            super(gameObject);
            const model = models.knight;
            this.skinInstance = gameObject.addComponent(SkinInstance, model);
            this.skinInstance.setAnimation('Run');
            this.turnSpeed = globals.moveSpeed / 4;
      +     this.offscreenTimer = 0;
      +     this.maxTimeOffScreen = 3;
         }
         update() {
      -     const {deltaTime, moveSpeed} = globals;
      +     const {deltaTime, moveSpeed, cameraInfo} = globals;
            const {transform} = this.gameObject;
            const delta = (inputManager.keys.left.down  ?  1 : 0) +
                        (inputManager.keys.right.down ? -1 : 0);
            transform.rotation.y += this.turnSpeed * delta * deltaTime;
            transform.translateOnAxis(kForward, moveSpeed * deltaTime);

      +     const {frustum} = cameraInfo;
      +     if (frustum.containsPoint(transform.position)) {
      +       this.offscreenTimer = 0;
      +     } else {
      +       this.offscreenTimer += deltaTime;
      +       if (this.offscreenTimer >= this.maxTimeOffScreen) {
      +         transform.position.set(0, 0, 0);
      +       }
      +     }
         }
      }


   One more thing before we try it out, let's add touchscreen support for mobile. First
   let's add some HTML to touch


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div id="ui">
      +     <div id="left"><img src="../resources/images/left.svg"></div>
      +     <div style="flex: 0 0 40px;"></div>
      +     <div id="right"><img src="../resources/images/right.svg"></div>
      +   </div>
         <div id="loading">
            <div>
            <div>...loading...</div>
            <div class="progress"><div id="progressbar"></div></div>
            </div>
         </div>
      </body>


   and some CSS to style it


   .. code:: javascript

      #ui {
         position: absolute;
         left: 0;
         top: 0;
         width: 100%;
         height: 100%;
         display: flex;
         justify-items: center;
         align-content: stretch;
      }
      #ui>div {
         display: flex;
         align-items: flex-end;
         flex: 1 1 auto;
      }
      .bright {
         filter: brightness(2);
      }
      #left {
         justify-content: flex-end;
      }
      #right {
         justify-content: flex-start;
      }
      #ui img {
         padding: 10px;
         width: 80px;
         height: 80px;
         display: block;
      }


   The idea here is there is one div, ``#ui``, that covers the entire page. Inside will
   be 2 divs, ``#left`` and ``#right`` both of which are almost half the page wide and
   the entire screen tall. In between there is a 40px separator. If the user slides
   their finger over the left or right side then we need up update ``keys.left`` and
   ``keys.right`` in the ``InputManager``. This makes the entire screen sensitive to
   being touched which seemed better than just small arrows.


   .. code:: javascript

      class InputManager {
         constructor() {
            this.keys = {};
            const keyMap = new Map();

            const setKey = (keyName, pressed) => {
            const keyState = this.keys[keyName];
            keyState.justPressed = pressed && !keyState.down;
            keyState.down = pressed;
            };

            const addKey = (keyCode, name) => {
            this.keys[name] = { down: false, justPressed: false };
            keyMap.set(keyCode, name);
            };

            const setKeyFromKeyCode = (keyCode, pressed) => {
            const keyName = keyMap.get(keyCode);
            if (!keyName) {
               return;
            }
            setKey(keyName, pressed);
            };

            addKey(37, 'left');
            addKey(39, 'right');
            addKey(38, 'up');
            addKey(40, 'down');
            addKey(90, 'a');
            addKey(88, 'b');

            window.addEventListener('keydown', (e) => {
            setKeyFromKeyCode(e.keyCode, true);
            });
            window.addEventListener('keyup', (e) => {
            setKeyFromKeyCode(e.keyCode, false);
            });

      +     const sides = [
      +       { elem: document.querySelector('#left'),  key: 'left'  },
      +       { elem: document.querySelector('#right'), key: 'right' },
      +     ];
      + 
      +     const clearKeys = () => {
      +       for (const {key} of sides) {
      +           setKey(key, false);
      +       }
      +     };
      + 
      +     const handleMouseMove = (e) => {
      +       e.preventDefault();
      +       // this is needed because we call preventDefault();
      +       // we also gave the canvas a tabindex so it can
      +       // become the focus
      +       canvas.focus();
      +       window.addEventListener('pointermove', handleMouseMove);
      +       window.addEventListener('pointerup', handleMouseUp);
      + 
      +       for (const {elem, key} of sides) {
      +         let pressed = false;
      +         const rect = elem.getBoundingClientRect();
      +         const x = e.clientX;
      +         const y = e.clientY;
      +         const inRect = x >= rect.left && x < rect.right &&
      +                        y >= rect.top && y < rect.bottom;
      +         if (inRect) {
      +           pressed = true;
      +         }
      +         setKey(key, pressed);
      +       }
      +     };
      + 
      +     function handleMouseUp() {
      +       clearKeys();
      +       window.removeEventListener('pointermove', handleMouseMove, {passive: false});
      +       window.removeEventListener('pointerup', handleMouseUp);
      +     }
      + 
      +     const uiElem = document.querySelector('#ui');
      +     uiElem.addEventListener('pointerdown', handleMouseMove, {passive: false});
      + 
      +     uiElem.addEventListener('touchstart', (e) => {
      +       // prevent scrolling
      +       e.preventDefault();
      +     }, {passive: false});
         }
         update() {
            for (const keyState of Object.values(this.keys)) {
            if (keyState.justPressed) {
               keyState.justPressed = false;
            }
            }
         }
      }


   And now we should be able to control the character with the left and right cursor
   keys or with our fingers on a touchscreen


      `click here to open in a separate
      window <https://threejs.org/manual/examples/game-player-input.html>`__

   Ideally we'd do something else if the player went off the screen like move the
   camera or maybe offscreen = death but this article is already going to be too long
   so for now teleporting to the middle was the simplest thing.

   Lets add some animals. We can start it off similar to the ``Player`` by making an
   ``Animal`` component.


   .. code:: javascript

      class Animal extends Component {
         constructor(gameObject, model) {
            super(gameObject);
            const skinInstance = gameObject.addComponent(SkinInstance, model);
            skinInstance.mixer.timeScale = globals.moveSpeed / 4;
            skinInstance.setAnimation('Idle');
         }
      }


   The code above sets the
   ``AnimationMixer.timeScale``
   to set the playback speed of the animations relative to the move speed. This way if
   we adjust the move speed the animation will speed up or slow down as well.

   To start we could setup one of each type of animal


   .. code:: javascript

      function init() {
         // hide the loading bar
         const loadingElem = document.querySelector('#loading');
         loadingElem.style.display = 'none';

         prepModelsAndAnimations();
         {
            const gameObject = gameObjectManager.createGameObject(camera, 'camera');
            globals.cameraInfo = gameObject.addComponent(CameraInfo);
         }

         {
            const gameObject = gameObjectManager.createGameObject(scene, 'player');
            globals.player = gameObject.addComponent(Player);
            globals.congaLine = [gameObject];
         }

      +   const animalModelNames = [
      +     'pig',
      +     'cow',
      +     'llama',
      +     'pug',
      +     'sheep',
      +     'zebra',
      +     'horse',
      +   ];
      +   animalModelNames.forEach((name, ndx) => {
      +     const gameObject = gameObjectManager.createGameObject(scene, name);
      +     gameObject.addComponent(Animal, models[name]);
      +     gameObject.transform.position.x = (ndx + 1) * 5;
      +   });
      }


   And that would get us animals standing on the screen but we want them to do
   something.

   Let's make them follow the player in a conga line but only if the player gets near
   enough. To do this we need several states.

   -  Idle:

      Animal is waiting for player to get close

   -  Wait for End of Line:

      Animal was tagged by player but now needs to wait for the animal at the end of
      the line to come by so they can join the end of the line.

   -  Go to Last:

      Animal needs to walk to where the animal they are following was, at the same time
      recording a history of where the animal they are following is currently.

   -  Follow

      Animal needs to keep recording a history of where the animal they are following
      is while moving to where the animal they are following was before.

   There are many ways to handle different states like this. A common one is to use a
   `Finite State Machine <https://www.bing.com/search?q=finite+state+machine>`__ and
   to build some class to help us manage the state.

   So, let's do that.


   .. code:: javascript

      class FiniteStateMachine {
         constructor(states, initialState) {
            this.states = states;
            this.transition(initialState);
         }
         get state() {
            return this.currentState;
         }
         transition(state) {
            const oldState = this.states[this.currentState];
            if (oldState && oldState.exit) {
            oldState.exit.call(this);
            }
            this.currentState = state;
            const newState = this.states[state];
            if (newState.enter) {
            newState.enter.call(this);
            }
         }
         update() {
            const state = this.states[this.currentState];
            if (state.update) {
            state.update.call(this);
            }
         }
      }


   Here's a simple class. We pass it an object with a bunch of states. Each state as 3
   optional functions, ``enter``, ``update``, and ``exit``. To switch states we call
   ``FiniteStateMachine.transition`` and pass it the name of the new state. If the
   current state has an ``exit`` function it's called. Then if the new state has an
   ``enter`` function it's called. Finally each frame ``FiniteStateMachine.update``
   calls the ``update`` function of the current state.

   Let's use it to manage the states of the animals.


   .. code:: javascript

      // Returns true of obj1 and obj2 are close
      function isClose(obj1, obj1Radius, obj2, obj2Radius) {
         const minDist = obj1Radius + obj2Radius;
         const dist = obj1.position.distanceTo(obj2.position);
         return dist < minDist;
      }

      // keeps v between -min and +min
      function minMagnitude(v, min) {
         return Math.abs(v) > min
            ? min * Math.sign(v)
            : v;
      }

      const aimTowardAndGetDistance = function() {
         const delta = new THREE.Vector3();

         return function aimTowardAndGetDistance(source, targetPos, maxTurn) {
            delta.subVectors(targetPos, source.position);
            // compute the direction we want to be facing
            const targetRot = Math.atan2(delta.x, delta.z) + Math.PI * 1.5;
            // rotate in the shortest direction
            const deltaRot = (targetRot - source.rotation.y + Math.PI * 1.5) % (Math.PI * 2) - Math.PI;
            // make sure we don't turn faster than maxTurn
            const deltaRotation = minMagnitude(deltaRot, maxTurn);
            // keep rotation between 0 and Math.PI * 2
            source.rotation.y = THREE.MathUtils.euclideanModulo(
               source.rotation.y + deltaRotation, Math.PI * 2);
            // return the distance to the target
            return delta.length();
         };
      }();

      class Animal extends Component {
         constructor(gameObject, model) {
            super(gameObject);
      +     const hitRadius = model.size / 2;
            const skinInstance = gameObject.addComponent(SkinInstance, model);
            skinInstance.mixer.timeScale = globals.moveSpeed / 4;
      +     const transform = gameObject.transform;
      +     const playerTransform = globals.player.gameObject.transform;
      +     const maxTurnSpeed = Math.PI * (globals.moveSpeed / 4);
      +     const targetHistory = [];
      +     let targetNdx = 0;
      + 
      +     function addHistory() {
      +       const targetGO = globals.congaLine[targetNdx];
      +       const newTargetPos = new THREE.Vector3();
      +       newTargetPos.copy(targetGO.transform.position);
      +       targetHistory.push(newTargetPos);
      +     }
      + 
      +     this.fsm = new FiniteStateMachine({
      +       idle: {
      +         enter: () => {
      +           skinInstance.setAnimation('Idle');
      +         },
      +         update: () => {
      +           // check if player is near
      +           if (isClose(transform, hitRadius, playerTransform, globals.playerRadius)) {
      +             this.fsm.transition('waitForEnd');
      +           }
      +         },
      +       },
      +       waitForEnd: {
      +         enter: () => {
      +           skinInstance.setAnimation('Jump');
      +         },
      +         update: () => {
      +           // get the gameObject at the end of the conga line
      +           const lastGO = globals.congaLine[globals.congaLine.length - 1];
      +           const deltaTurnSpeed = maxTurnSpeed * globals.deltaTime;
      +           const targetPos = lastGO.transform.position;
      +           aimTowardAndGetDistance(transform, targetPos, deltaTurnSpeed);
      +           // check if last thing in conga line is near
      +           if (isClose(transform, hitRadius, lastGO.transform, globals.playerRadius)) {
      +             this.fsm.transition('goToLast');
      +           }
      +         },
      +       },
      +       goToLast: {
      +         enter: () => {
      +           // remember who we're following
      +           targetNdx = globals.congaLine.length - 1;
      +           // add ourselves to the conga line
      +           globals.congaLine.push(gameObject);
      +           skinInstance.setAnimation('Walk');
      +         },
      +         update: () => {
      +           addHistory();
      +           // walk to the oldest point in the history
      +           const targetPos = targetHistory[0];
      +           const maxVelocity = globals.moveSpeed * globals.deltaTime;
      +           const deltaTurnSpeed = maxTurnSpeed * globals.deltaTime;
      +           const distance = aimTowardAndGetDistance(transform, targetPos, deltaTurnSpeed);
      +           const velocity = distance;
      +           transform.translateOnAxis(kForward, Math.min(velocity, maxVelocity));
      +           if (distance <= maxVelocity) {
      +             this.fsm.transition('follow');
      +           }
      +         },
      +       },
      +       follow: {
      +         update: () => {
      +           addHistory();
      +           // remove the oldest history and just put ourselves there.
      +           const targetPos = targetHistory.shift();
      +           transform.position.copy(targetPos);
      +           const deltaTurnSpeed = maxTurnSpeed * globals.deltaTime;
      +           aimTowardAndGetDistance(transform, targetHistory[0], deltaTurnSpeed);
      +         },
      +       },
      +     }, 'idle');
      +   }
      +   update() {
      +     this.fsm.update();
      +   }
      }


   That was big chunk of code but it does what was described above. Hopefully of you
   walk through each state it will be clear.

   A few things we need to add. We need the player to add itself to the globals so the
   animals can find it and we need to start the conga line with the player's
   ``GameObject``.


   .. code:: javascript

      function init() {

         ...

         {
            const gameObject = gameObjectManager.createGameObject(scene, 'player');
      +     globals.player = gameObject.addComponent(Player);
      +     globals.congaLine = [gameObject];
         }

      }


   We also need to compute a size for each model


   .. code:: javascript

      function prepModelsAndAnimations() {
      +   const box = new THREE.Box3();
      +   const size = new THREE.Vector3();
         Object.values(models).forEach(model => {
      +     box.setFromObject(model.gltf.scene);
      +     box.getSize(size);
      +     model.size = size.length();
            const animsByName = {};
            model.gltf.animations.forEach((clip) => {
            animsByName[clip.name] = clip;
            // Should really fix this in .blend file
            if (clip.name === 'Walk') {
               clip.duration /= 2;
            }
            });
            model.animations = animsByName;
         });
      }


   And we need the player to record their size


   .. code:: javascript

      class Player extends Component {
         constructor(gameObject) {
            super(gameObject);
            const model = models.knight;
      +     globals.playerRadius = model.size / 2;


   Thinking about it now it would probably have been smarter for the animals to just
   target the head of the conga line instead of the player specifically. Maybe I'll
   come back and change that later.

   When I first started this I used just one radius for all animals but of course that
   was no good as the pug is much smaller than the horse. So I added the difference
   sizes but I wanted to be able to visualize things. To do that I made a
   ``StatusDisplayHelper`` component.

   I uses a ``PolarGridHelper`` to draw a
   circle around each character and it uses html elements to let each character show
   some status using the techniques covered in `the article on aligning html elements
   to 3D <align-html-elements-to-3d>`.

   First we need to add some HTML to host these elements


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
         <div id="ui">
            <div id="left"><img src="../resources/images/left.svg"></div>
            <div style="flex: 0 0 40px;"></div>
            <div id="right"><img src="../resources/images/right.svg"></div>
         </div>
         <div id="loading">
            <div>
            <div>...loading...</div>
            <div class="progress"><div id="progressbar"></div></div>
            </div>
         </div>
      +   <div id="labels"></div>
      </body>


   And add some CSS for them


   .. code:: javascript

      #labels {
         position: absolute;  /* let us position ourself inside the container */
         left: 0;             /* make our position the top left of the container */
         top: 0;
         color: white;
         width: 100%;
         height: 100%;
         overflow: hidden;
         pointer-events: none;
      }
      #labels>div {
         position: absolute;  /* let us position them inside the container */
         left: 0;             /* make their default position the top left of the container */
         top: 0;
         font-size: large;
         font-family: monospace;
         user-select: none;   /* don't let the text get selected */
         text-shadow:         /* create a black outline */
            -1px -1px 0 #000,
            0   -1px 0 #000,
            1px -1px 0 #000,
            1px  0   0 #000,
            1px  1px 0 #000,
            0    1px 0 #000,
            -1px  1px 0 #000,
            -1px  0   0 #000;
      }


   Then here's the component


   .. code:: javascript

      const labelContainerElem = document.querySelector('#labels');

      class StateDisplayHelper extends Component {
         constructor(gameObject, size) {
            super(gameObject);
            this.elem = document.createElement('div');
            labelContainerElem.appendChild(this.elem);
            this.pos = new THREE.Vector3();

            this.helper = new THREE.PolarGridHelper(size / 2, 1, 1, 16);
            gameObject.transform.add(this.helper);
         }
         setState(s) {
            this.elem.textContent = s;
         }
         setColor(cssColor) {
            this.elem.style.color = cssColor;
            this.helper.material.color.set(cssColor);
         }
         update() {
            const {pos} = this;
            const {transform} = this.gameObject;
            const {canvas} = globals;
            pos.copy(transform.position);

            // get the normalized screen coordinate of that position
            // x and y will be in the -1 to +1 range with x = -1 being
            // on the left and y = -1 being on the bottom
            pos.project(globals.camera);

            // convert the normalized position to CSS coordinates
            const x = (pos.x *  .5 + .5) * canvas.clientWidth;
            const y = (pos.y * -.5 + .5) * canvas.clientHeight;

            // move the elem to that position
            this.elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
         }
      }


   And we can then add them to the animals like this


   .. code:: javascript

      class Animal extends Component {
         constructor(gameObject, model) {
            super(gameObject);
      +     this.helper = gameObject.addComponent(StateDisplayHelper, model.size);

            ...

         }
         update() {
            this.fsm.update();
      +     const dir = THREE.MathUtils.radToDeg(this.gameObject.transform.rotation.y);
      +     this.helper.setState(`${this.fsm.state}:${dir.toFixed(0)}`);
         }
      }


   While we're at it lets make it so we can turn them on/off using lil-gui like we've
   used else where


   .. code:: javascript

      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
      import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
      + import {GUI} from 'three/addons/libs/lil-gui.module.min.js';



   .. code:: javascript

      + const gui = new GUI();
      + gui.add(globals, 'debug').onChange(showHideDebugInfo);
      + showHideDebugInfo();

      const labelContainerElem = document.querySelector('#labels');
      + function showHideDebugInfo() {
      +   labelContainerElem.style.display = globals.debug ? '' : 'none';
      + }
      + showHideDebugInfo();

      class StateDisplayHelper extends Component {

         ...

         update() {
      +     this.helper.visible = globals.debug;
      +     if (!globals.debug) {
      +       return;
      +     }

            ...
         }
      }


   And with that we get the kind of start of a game


      `click here to open in a separate
      window <https://threejs.org/manual/examples/game-conga-line.html>`__

   Originally I set out to make a `snake game <https://www.bing.com/search?q=snake+game>`__ 
   where as you add animals to your line it gets harder because you need to avoid 
   crashing into them. I'd also have put some obstacles in the scene and maybe a 
   fence or some barrier around the perimeter.

   Unfortunately the animals are long and thin. From above here's the zebra.

   .. image:: https://threejs.org/manual/resources/images/zebra.png


   The code so far is using circle collisions which means if we had obstacles like a
   fence then this would be considered a collision

   .. image:: https://threejs.org/manual/resources/images/zebra-collisions.svg


   That's no good. Even animal to animal we'd have the same issue

   I thought about writing a 2D rectangle to rectangle collision system but I quickly
   realized it could really be a lot of code. Checking that 2 arbitrarily oriented
   boxes overlap is not too much code and for our game with just a few objects it might
   work but looking into it after a few objects you quickly start needing to optimize
   the collision checking. First you might go through all objects that can possibly
   collide with each other and check their bounding spheres or bounding circles or
   their axially aligned bounding boxes. Once you know which objects *might* be
   colliding then you need to do more work to check if they are *actually* colliding.
   Often even checking the bounding spheres is too much work and you need some kind of
   better spacial structure for the objects so you can more quickly only check objects
   possibly near each other.

   Then, once you write the code to check if 2 objects collide you generally want to
   make a collision system rather than manually asking "do I collide with these
   objects". A collision system emits events or calls callbacks in relation to things
   colliding. The advantage is it can check all the collisions at once so no objects
   get checked more than once where as if you manually call some "am I colliding"
   function often objects will be checked more than once wasting time.

   Making that collision system would probably not be more than 100-300 lines of code
   for just checking arbitrarily oriented rectangles but it's still a ton more code so
   it seemed best to leave it out.

   Another solution would have been to try to find other characters that are mostly
   circular from the top. Other humanoid characters for example instead of animals in
   which case the circle checking might work animal to animal. It would not work animal
   to fence, well we'd have to add circle to rectangle checking. I thought about making
   the fence a fence of bushes or poles, something circular but then I'd need probably
   120 to 200 of them to surround the play area which would run into the optimization
   issues mentioned above.

   These are reasons many games use an existing solution. Often these solutions are
   part of a physics library. The physical library needs to know if objects collide
   with each other so on top of providing physics they can also be used to detect
   collision.

   If you're looking for a solution some of the three.js examples use
   `ammo.js <https://github.com/kripken/ammo.js/>`__ so that might be one.

   One other solution might have been to place the obstacles on a grid and try to make
   it so each animal and the player just need to look at the grid. While that would be
   performant I felt that's best left as an exercise for the reader 😜

   One more thing, many game systems have something called
   `coroutines <https://www.bing.com/search?q=coroutines>`__. Coroutines are routines
   that can pause while running and continue later.

   Let's make the main character emit musical notes like they are leading the line by
   singing. There are many ways we could implement this but for now let's do it using
   coroutines.

   First, here's a class to manage coroutines


   .. code:: javascript

      function* waitSeconds(duration) {
         while (duration > 0) {
            duration -= globals.deltaTime;
            yield;
         }
      }

      class CoroutineRunner {
         constructor() {
            this.generatorStacks = [];
            this.addQueue = [];
            this.removeQueue = new Set();
         }
         isBusy() {
            return this.addQueue.length + this.generatorStacks.length > 0;
         }
         add(generator, delay = 0) {
            const genStack = [generator];
            if (delay) {
            genStack.push(waitSeconds(delay));
            }
            this.addQueue.push(genStack);
         }
         remove(generator) {
            this.removeQueue.add(generator);
         }
         update() {
            this._addQueued();
            this._removeQueued();
            for (const genStack of this.generatorStacks) {
            const main = genStack[0];
            // Handle if one coroutine removes another
            if (this.removeQueue.has(main)) {
               continue;
            }
            while (genStack.length) {
               const topGen = genStack[genStack.length - 1];
               const {value, done} = topGen.next();
               if (done) {
                  if (genStack.length === 1) {
                  this.removeQueue.add(topGen);
                  break;
                  }
                  genStack.pop();
               } else if (value) {
                  genStack.push(value);
               } else {
                  break;
               }
            }
            }
            this._removeQueued();
         }
         _addQueued() {
            if (this.addQueue.length) {
            this.generatorStacks.splice(this.generatorStacks.length, 0, ...this.addQueue);
            this.addQueue = [];
            }
         }
         _removeQueued() {
            if (this.removeQueue.size) {
            this.generatorStacks = this.generatorStacks.filter(genStack => !this.removeQueue.has(genStack[0]));
            this.removeQueue.clear();
            }
         }
      }


   It does things similar to ``SafeArray`` to make sure that it's safe to add or remove
   coroutines while other coroutines are running. It also handles nested coroutines.

   To make a coroutine you make a `JavaScript generator
   function <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*>`__.
   A generator function is preceded by the keyword ``function*`` (the asterisk is
   important!)

   Generator functions can ``yield``. For example


   .. code:: javascript

      function* countOTo9() {
         for (let i = 0; i < 10; ++i) {
            console.log(i);
            yield;
         }
      }


   If we added this function to the ``CoroutineRunner`` above it would print out each
   number, 0 to 9, once per frame or rather once per time we called ``runner.update``.


   .. code:: javascript

      const runner = new CoroutineRunner();
      runner.add(count0To9);
      while(runner.isBusy()) {
         runner.update();
      }


   Coroutines are removed automatically when they are finished. To remove a coroutine
   early, before it reaches the end you need to keep a reference to its generator like
   this


   .. code:: javascript

      const gen = count0To9();
      runner.add(gen);

      // sometime later

      runner.remove(gen);


   In any case, in the player let's use a coroutine to emit a note every half second to
   1 second


   .. code:: javascript

      class Player extends Component {
         constructor(gameObject) {

            ...

      +     this.runner = new CoroutineRunner();
      + 
      +     function* emitNotes() {
      +       for (;;) {
      +         yield waitSeconds(rand(0.5, 1));
      +         const noteGO = gameObjectManager.createGameObject(scene, 'note');
      +         noteGO.transform.position.copy(gameObject.transform.position);
      +         noteGO.transform.position.y += 5;
      +         noteGO.addComponent(Note);
      +       }
      +     }
      + 
      +     this.runner.add(emitNotes());
         }
         update() {
      +     this.runner.update();

         ...

         }
      }

      function rand(min, max) {
         if (max === undefined) {
            max = min;
            min = 0;
         }
         return Math.random() * (max - min) + min;
      }


   You can see we make a ``CoroutineRunner`` and we add an ``emitNotes`` coroutine.
   That function will run forever, waiting 0.5 to 1 seconds and then creating a game
   object with a ``Note`` component.

   For the ``Note`` component first lets make a texture with a note on it and instead
   of loading a note image let's make one using a canvas like we covered in `the
   article on canvas textures <canvas-textures>`.


   .. code:: javascript

      function makeTextTexture(str) {
         const ctx = document.createElement('canvas').getContext('2d');
         ctx.canvas.width = 64;
         ctx.canvas.height = 64;
         ctx.font = '60px sans-serif';
         ctx.textAlign = 'center';
         ctx.textBaseline = 'middle';
         ctx.fillStyle = '#FFF';
         ctx.fillText(str, ctx.canvas.width / 2, ctx.canvas.height / 2);
         return new THREE.CanvasTexture(ctx.canvas);
      }
      const noteTexture = makeTextTexture('♪');


   The texture we create above is white each means when we use it we can set the
   material's color and get a note of any color.

   Now that we have a noteTexture here's the ``Note`` component. It uses
   ``SpriteMaterial`` and a
   ``Sprite`` like we covered in `the article on
   billboards <billboards>`


   .. code:: javascript

      class Note extends Component {
         constructor(gameObject) {
            super(gameObject);
            const {transform} = gameObject;
            const noteMaterial = new THREE.SpriteMaterial({
            color: new THREE.Color().setHSL(rand(1), 1, 0.5),
            map: noteTexture,
            side: THREE.DoubleSide,
            transparent: true,
            });
            const note = new THREE.Sprite(noteMaterial);
            note.scale.setScalar(3);
            transform.add(note);
            this.runner = new CoroutineRunner();
            const direction = new THREE.Vector3(rand(-0.2, 0.2), 1, rand(-0.2, 0.2));

            function* moveAndRemove() {
            for (let i = 0; i < 60; ++i) {
               transform.translateOnAxis(direction, globals.deltaTime * 10);
               noteMaterial.opacity = 1 - (i / 60);
               yield;
            }
            transform.parent.remove(transform);
            gameObjectManager.removeGameObject(gameObject);
            }

            this.runner.add(moveAndRemove());
         }
         update() {
            this.runner.update();
         }
      }


   All it does is setup a ``Sprite``, then pick a
   random velocity and move the transform at that velocity for 60 frames while fading
   out the note by setting the material's
   ``opacity``. After the loop it the
   removes the transform from the scene and the note itself from active gameobjects.

   One last thing, let's add a few more animals


   .. code:: javascript

      function init() {

         ...

         const animalModelNames = [
            'pig',
            'cow',
            'llama',
            'pug',
            'sheep',
            'zebra',
            'horse',
         ];
      +   const base = new THREE.Object3D();
      +   const offset = new THREE.Object3D();
      +   base.add(offset);
      + 
      +   // position animals in a spiral.
      +   const numAnimals = 28;
      +   const arc = 10;
      +   const b = 10 / (2 * Math.PI);
      +   let r = 10;
      +   let phi = r / b;
      +   for (let i = 0; i < numAnimals; ++i) {
      +     const name = animalModelNames[rand(animalModelNames.length) | 0];
            const gameObject = gameObjectManager.createGameObject(scene, name);
            gameObject.addComponent(Animal, models[name]);
      +     base.rotation.y = phi;
      +     offset.position.x = r;
      +     offset.updateWorldMatrix(true, false);
      +     offset.getWorldPosition(gameObject.transform.position);
      +     phi += arc / r;
      +     r = b * phi;
         }


      `click here to open in a separate
      window <https://threejs.org/manual/examples/game-conga-line-w-notes.html>`__


   You might be asking, why not use ``setTimeout``? The problem with ``setTimeout`` is
   it's not related to the game clock. For example above we made the maximum amount of
   time allowed to elapse between frames to be 1/20th of a second. Our coroutine system
   will respect that limit but ``setTimeout`` would not.

   Of course we could have made a simple timer ourselves


   .. code:: javascript

      class Player ... {
         update() {
            this.noteTimer -= globals.deltaTime;
            if (this.noteTimer <= 0) {
            // reset timer
            this.noteTimer = rand(0.5, 1);
            // create a gameobject with a note component
            }
         }


   And for this particular case that might have been better but as you add more and
   things you'll get more and more variables added to your classes where as with
   coroutines you can often just *fire and forget*.

   Given our animal's simple states we could also have implemented them with a
   coroutine in the form of


   .. code:: javascript

      // pseudo code!
      function* animalCoroutine() {
         setAnimation('Idle');
         while(playerIsTooFar()) {
            yield;
         }
         const target = endOfLine;
         setAnimation('Jump');
         while(targetIsTooFar()) {
            aimAt(target);
            yield;
         }
         setAnimation('Walk')
         while(notAtOldestPositionOfTarget()) {
            addHistory();
            aimAt(target);
            yield;
         }
         for(;;) {
            addHistory();
            const pos = history.unshift();
            transform.position.copy(pos);
            aimAt(history[0]);
            yield;
         }
      }


   This would have worked but of course as soon as our states were not so linear we'd
   have had to switch to a ``FiniteStateMachine``.

   It also wasn't clear to me if coroutines should run independently of their
   components. We could have made a global ``CoroutineRunner`` and put all coroutines
   on it. That would make cleaning them up harder. As it is now if the gameobject is
   removed all of its components are removed and therefore the coroutine runners
   created are no longer called and it will all get garbage collected. If we had global
   runner then it would be the responsibility of each component to remove any
   coroutines it added or else some other mechanism of registering coroutines with a
   particular component or gameobject would be needed so that removing one removes the
   others.

   There are lots more issues a normal game engine would deal with. As it is there is
   no order to how gameobjects or their components are run. They are just run in the
   order added. Many game systems add a priority so the order can be set or changed.

   Another issue we ran into is the ``Note`` removing its gameobject's transform from
   the scene. That seems like something that should happen in ``GameObject`` since it
   was ``GameObject`` that added the transform in the first place. Maybe ``GameObject``
   should have a ``dispose`` method that is called by
   ``GameObjectManager.removeGameObject``?

   Yet another is how we're manually calling ``gameObjectManager.update`` and
   ``inputManager.update``. Maybe there should be a ``SystemManager`` which these
   global services can add themselves and each service will have its ``update``
   function called. In this way if we added a new service like ``CollisionManager`` we
   could just add it to the system manager and not have to edit the render loop.

   I'll leave those kinds of issues up to you. I hope this article has given you some
   ideas for your own game engine.

   Maybe I should promote a game jam. If you click the *jsfiddle* or *codepen* buttons
   above the last example they'll open in those sites ready to edit. Add some features,
   Change the game to a pug leading a bunch of knights. Use the knight's rolling
   animation as a bowling ball and make an animal bowling game. Make an animal relay
   race. If you make a cool game post a link in the comments below.

   .. container:: footnotes

      [§R1]: technically it would still work if none of the parents have any translation,
      rotation, or scale.



.. _F41:

VR - Basics
===========

   -  `VR - Basics <https://threejs.org/manual/en/webxr-basics.html>`__
   -  https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported

   Making a VR app in three.js is pretty simple. You basically just have to tell
   three.js you want to use WebXR. If you think about it a few things about WebXR
   should be clear. Which way the camera is pointing is supplied by the VR system
   itself since the user turns their head to choose a direction to look. Similarly the
   field of view and aspect will be supplied by the VR system since each system has a
   different field of view and display aspect.

   Let's take an example from the article on `making a responsive webpage <responsive>` 
   and make it support VR.

   Before we get started you're going to need a VR capable device like an Android
   smartphone, Google Daydream, Oculus Go, Oculus Rift, Vive, Samsung Gear VR., an
   iPhone with a `WebXR browser <https://apps.apple.com/us/app/webxr-viewer/id1295998056>`__.

   Next, if you are running locally you need to run a simple web server like is covered
   in `the article on setting up <setup>`.

   If the device you are using to view VR is not the same computer you're running on
   you need to serve your webpage via https or else the browser will not allow using
   the WebXR API. The server mentioned in `the article on setting up <setup>`
   called `Servez <https://greggman.github.io/servez>`__ has an option to use https.
   Check it and start the server.

   .. image:: https://threejs.org/manual/resources/images/servez-https.png


   The note the URLs. You need the one that is your computer's local ipaddress. It will
   usually start with ``192``, ``172`` or ``10``. Type that full address, including the
   ``https://`` part into your VR device's browser. Note: Your computer and your VR
   device need to be on the same local network or WiFi and you probably need to be on a
   home network. note: Many cafes are setup to disallow this kind of machine to machine
   connection.

   You'll be greeted with an error something like the one below. Click "advanced" and
   then click *proceed*.

   .. image:: https://threejs.org/manual/resources/images/https-warning.gif


   Now you can run your examples.

   If you're really going to do WebXR development another thing you should learn about
   is `remote debugging <https://developers.google.cn/web/tools/chrome-devtools/remote-debugging/>`__
   so that you can see console warnings, errors, and of course actually `debug your
   code <debugging-javascript>`.

   If you just want to see the code work below you can just run the code from this
   site.

   The first thing we need to do is include the VR support after including three.js


   .. code:: javascript

      import * as THREE from 'three';
      + import {VRButton} from 'three/addons/webxr/VRButton.js';


   Then we need to enable three.js's WebXR support and add its VR button to our page


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      +   renderer.xr.enabled = true;
      +   document.body.appendChild(VRButton.createButton(renderer));


   We need to let three.js run our render loop. Until now we have used a
   ``requestAnimationFrame`` loop but to support VR we need to let three.js handle our
   render loop for us. We can do that by calling ``WebGLRenderer.setAnimationLoop``
   and passing a function to call for the loop.


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
         }

         cubes.forEach((cube, ndx) => {
            const speed = 1 + ndx * .1;
            const rot = time * speed;
            cube.rotation.x = rot;
            cube.rotation.y = rot;
         });

         renderer.render(scene, camera);

      -  requestAnimationFrame(render);
      }

      - requestAnimationFrame(render);
      + renderer.setAnimationLoop(render);


   There is one more detail. We should probably set a camera height that's kind of
   average for a standing user.


   .. code:: javascript

      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      + camera.position.set(0, 1.6, 0);


   and move the cubes up to be in front of the camera


   .. code:: javascript

      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.x = x;
      + cube.position.y = 1.6;
      + cube.position.z = -2;


   We set them to ``z = -2`` since the camera will now be at ``z = 0`` and camera
   defaults to looking down the -z axis.

   This brings up an extremely important point. **Units in VR are in meters**. In other
   words **One Unit = One Meter**. This means the camera is 1.6 meters above 0. The
   cube's centers are 2 meters in front of the camera. Each cube is 1x1x1 meter large.
   This is important because VR needs to adjust things to the user *in the real world*.
   That means we need the units used in three.js to match the user's own movements.

   And with that we should get 3 spinning cubes in front of the camera with a button to
   enter VR.


      `click here to open in a separate window <https://threejs.org/manual/examples/webxr-basic.html>`__

   I find that VR works better if we have something surrounding the camera like room
   for reference so let's add a simple grid cubemap like we covered in `the article on
   backgrounds <backgrounds>`. We'll just use the same grid texture for each
   side of the cube which will give as a grid room.


   .. code:: javascript

      const scene = new THREE.Scene();
      + {
      +   const loader = new THREE.CubeTextureLoader();
      +   const texture = loader.load([
      +     'resources/images/grid-1024.png',
      +     'resources/images/grid-1024.png',
      +     'resources/images/grid-1024.png',
      +     'resources/images/grid-1024.png',
      +     'resources/images/grid-1024.png',
      +     'resources/images/grid-1024.png',
      +   ]);
      +   scene.background = texture;
      + }


   That's better.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/webxr-basic-w-background.html>`__

   Note: To actually see VR you will need a WebXR compatible device. I believe most
   Android Phones can support WebXR using Chrome or Firefox. For iOS you might be able
   to use this `WebXR App <https://apps.apple.com/us/app/webxr-viewer/id1295998056>`__
   though in general WebXR support on iOS is unsupported as of May 2019.

   To use WebXR on Android or iPhone you'll need a *VR Headset* for phones. You can get
   them for anywhere from $5 for one made of cardboard to $100. Unfortunately I don't
   know which ones to recommend. I've purchased 6 of them over the years and they are
   all of varying quality. I've never paid more than about $25.

   Just to mention some of the issues

   #. Do they fit your phone

      Phones come in a variety of sizes and so the VR headsets need to match. Many
      headsets claim to match a large variety of sizes. My experience is the more sizes
      they match the worse they actually are since instead of being designed for a
      specific size they have to make compromises to match more sizes. Unfortunately
      multi-size headsets are the most common type.

   #. Can they focus for your face

      Some devices have more adjustments than others. Generally there are at most 2
      adjustments. How far the lenses are from your eyes and how far apart the lenses
      are.

   #. Are they too reflective

      Many headsets of a cone of plastic from your eye to the phone. If that plastic is
      shinny or reflective then it will act like a mirror reflecting the screen and be
      very distracting.

      Few if any of the reviews seem to cover this issue.

   #. Are the comfortable on your face.

      Most of the devices rest on your nose like a pair of glasses. That can hurt after
      a few minutes. Some have straps that go around your head. Others have a 3rd strap
      that goes over your head. These may or may not help keep the device at the right
      place.

      It turns out for most (all?) devices, you eyes need to be centered with the
      lenses. If the lenses are slightly above or below your eyes the image gets out of
      focus. This can be very frustrating as things might start in focus but 45-60
      seconds later the device has shifted up or down 1 millimeter and you suddenly
      realize you've been struggling to focus on a blurry image.

   #. Can they support your glasses.

      If you wear eye glasses then you'll need to read the reviews to see if a
      particular headset works well with eye glasses.

   I really can't make any recommendations unfortunately. `Google has some cheap
   recommendations made from cardboard <https://vr.google.com/cardboard/get-cardboard/>`__ 
   some of them as low as $5 so maybe start there and if you enjoy it then consider 
   upgrading. $5 is like the price of 1 coffee so seriously, give it try!

   There are also 3 basic types of devices.

   #. 3 degrees of freedom (3dof), no input device

      This is generally the phone style although sometimes you can buy a 3rd party
      input device. The 3 degrees of freedom mean you can look up/down (1),
      left/right(2) and you can tilt your head left and right (3).

   #. 3 degrees of freedom (3dof) with 1 input device (3dof)

      This is basically Google Daydream and Oculus GO

      These also allow 3 degrees of freedom and include a small controller that acts
      like a laser pointer inside VR. The laser pointer also only has 3 degrees of
      freedom. The system can tell which way the input device is pointing but it can
      not tell where the device is.

   #. 6 degrees of freedom (6dof) with input devices (6dof)

      These are *the real deal* haha. 6 degrees of freedom means not only do these
      device know which way you are looking but they also know where your head actually
      is. That means if you move from left to right or forward and back or stand up /
      sit down the devices can register this and everything in VR moves accordingly.
      It's spookily and amazingly real feeling. With a good demo you'll be blown away
      or at least I was and still am.

      Further these devices usually include 2 controllers, one for each hand and the
      system can tell exactly where your hands are and which way they are oriented and
      so you can manipulate things in VR by just reaching out, touching, pushing,
      twisting, etc...

      6 degree of freedom devices include the Vive and Vive Pro, the Oculus Rift and
      Quest, and I believe all of the Windows MR devices.

   With all that covered I don't for sure know which devices will work with WebXR. I'm
   99% sure that most Android phones will work when running Chrome. You may need to
   turn on WebXR support in `about:flags <about:flags>`__. I also know Google
   Daydream will also work and similarly you need to enable WebXR support in
   `about:flags <about:flags>`__. Oculus Rift, Vive, and Vive Pro will work via
   Chrome or Firefox. I'm less sure about Oculus Go and Oculus Quest as both of them
   use custom OSes but according to the internet they both appear to work.

   Okay, after that long detour about VR Devices and WebXR there's some things to cover

   -  Supporting both VR and Non-VR

      AFAICT, at least as of r112, there is no easy way to support both VR and non-VR
      modes with three.js. Ideally if not in VR mode you'd be able to control the
      camera using whatever means you want, for example the `OrbitControls`, and you'd get
      some kind of event when switching into and out of VR mode so that you could turn
      the controls on/off.

   If three.js adds some support to do both I'll try to update this article. Until then
   you might need 2 versions of your site OR pass in a flag in the URL, something like


   .. code:: javascript

      https://mysite.com/mycooldemo?allowvr=true


   Then we could add some links in to switch modes


   .. code:: javascript

      <body>
         <canvas id="c"></canvas>
      +   <div class="mode">
      +     <a href="?allowvr=true" id="vr">Allow VR</a>
      +     <a href="?" id="nonvr">Use Non-VR Mode</a>
      +   </div>
      </body>


   and some CSS to position them


   .. code:: javascript

      body {
            margin: 0;
      }
      #c {
            width: 100%;
            height: 100%;
            display: block;
      }
      + .mode {
      +   position: absolute;
      +   right: 1em;
      +   top: 1em;
      + }


   in your code you could use that parameter like this


   .. code:: javascript

      function main() {
         const canvas = document.querySelector('#c');
         const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
      -  renderer.xr.enabled = true;
      -  document.body.appendChild(VRButton.createButton(renderer));

         const fov = 75;
         const aspect = 2;  // the canvas default
         const near = 0.1;
         const far = 5;
         const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
         camera.position.set(0, 1.6, 0);

      +   const params = (new URL(document.location)).searchParams;
      +   const allowvr = params.get('allowvr') === 'true';
      +   if (allowvr) {
      +     renderer.xr.enabled = true;
      +     document.body.appendChild(VRButton.createButton(renderer));
      +     document.querySelector('#vr').style.display = 'none';
      +   } else {
      +     // no VR, add some controls
      +     const controls = new OrbitControls(camera, canvas);
      +     controls.target.set(0, 1.6, -2);
      +     controls.update();
      +     document.querySelector('#nonvr').style.display = 'none';
      +   }


   Whether that's good or bad I don't know. I have a feeling the differences between
   what's needed for VR and what's needed for non-VR are often very different so for
   all but the most simple things maybe 2 separate pages are better? You'll have to
   decide.

   Note for various reasons this will not work in the live editor on this site so if
   you want to check it out `click here <https://threejs.org/manual/examples/webxr-basic-vr-optional.html>`__.
   It should start in non-VR mode and you can use the mouse or fingers to move the
   camera. Clicking "Allow VR" should switch to allow VR mode and you should be able to
   click "Enter VR" if you're on a VR device.

   -  Deciding on the level of VR support

      Above we covered 3 types of VR devices.

      -  3DOF no input
      -  3DOF + 3DOF input
      -  6DOF + 6DOF input

      You need to decide how much effort you're willing to put in to support each type
      of device.

      For example the simplest device has no input. The best you can generally do is
      make it so there are some buttons or objects in the user's view and if the user
      aligns some marker in the center of the display on those objects for 1/2 a second
      or so then that button is clicked. A common UX is to display a small timer that
      will appear over the object indicating if you keep the marker there for a moment
      the object/button will be selected.

      Since there is no other input that's about the best you can do

      The next level up you have one 3DOF input device. Generally it can point at
      things and the user has at least 2 buttons. The Daydream also has a touchpad
      which provides normal touch inputs.

      In any case if a user has this type of device it's far more comfortable for the
      user to by able to point at things with their controller than it is to make them
      do it with their head by looking at things.

      A similar level to that might be 3DOF or 6DOF device with a game console
      controller. You'll have to decide what to do here. I suspect the most common
      thing is the user still has to look to point and the controller is just used for
      buttons.

      The last level is a user with a 6DOF headset and 2 6DOF controllers. Those users
      will find an experience that is only 3DOF to often be frustrating. Similarly they
      usually expect to be able to virtually manipulate things with their hands in VR
      so you'll have to decide if you want to support that or not.

   As you can see getting started in VR is pretty easy but actually making something
   shippable in VR will require lots of decision making and design.

   This was a pretty brief intro into VR with three.js. We'll cover some of the input
   methods in `future articles <webxr-look-to-select>`.



.. _F42:

VR - Look To Select
===================

   -  `VR - Look To Select <https://threejs.org/manual/en/webxr-look-to-select.html>`__


   **NOTE: The examples on this page require a VR capable device. Without one they
   won't work. See `previous article <webxr>` as to why**

   In the `previous article <webxr>` we went over a very simple VR example using
   three.js and we discussed the various kinds of VR systems.

   The simplest and possibly most common is the Google Cardboard style of VR which is
   basically a phone put into a $5 - $50 face mask. This kind of VR has no controller
   so people have to come up with creative solutions for allowing user input.

   The most common solution is "look to select" where if the user points their head at
   something for a moment it gets selected.

   Let's implement "look to select"! We'll start with `an example from the previous
   article <webxr>` and to do it we'll add the ``PickHelper`` we made in `the
   article on picking <picking>`. Here it is.


   .. code:: javascript

      class PickHelper {
         constructor() {
            this.raycaster = new THREE.Raycaster();
            this.pickedObject = null;
            this.pickedObjectSavedColor = 0;
         }
         pick(normalizedPosition, scene, camera, time) {
            // restore the color if there is a picked object
            if (this.pickedObject) {
            this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
            this.pickedObject = undefined;
            }

            // cast a ray through the frustum
            this.raycaster.setFromCamera(normalizedPosition, camera);
            // get the list of objects the ray intersected
            const intersectedObjects = this.raycaster.intersectObjects(scene.children);
            if (intersectedObjects.length) {
            // pick the first object. It's the closest one
            this.pickedObject = intersectedObjects[0].object;
            // save its color
            this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
            // set its emissive color to flashing red/yellow
            this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
            }
         }
      }


   For an explanation of that code `see the article on picking <picking>`.

   To use it we just need to create an instance and call it in our render loop


   .. code:: javascript

      + const pickHelper = new PickHelper();

      ...
      function render(time) {
         time *= 0.001;

         ...

      +   // 0, 0 is the center of the view in normalized coordinates.
      +   pickHelper.pick({x: 0, y: 0}, scene, camera, time);


   In the original picking example we converted the mouse coordinates from CSS pixels
   into normalized coordinates that go from -1 to +1 across the canvas.

   In this case though we will always pick where the camera is facing which is the
   center of the screen so we pass in ``0`` for both ``x`` and ``y`` which is the
   center in normalized coordinates.

   And with that objects will flash when we look at them


      `click here to open in a separate
      window <https://threejs.org/manual/examples/webxr-look-to-select.html>`__

   Typically we don't want selection to be immediate. Instead we require the user to
   keep the camera on the thing they want to select for a few moments to give them a
   chance not to select something by accident.

   To do that we need some kind of meter or gauge or some way to convey that the user
   must keep looking and for how long.

   One easy way we could do that is to make a 2 color texture and use a texture offset
   to slide the texture across a model.

   Let's do this by itself to see it work before we add it to the VR example.

   First we make an ``OrthographicCamera``


   .. code:: javascript

      const left = -2;    // Use values for left
      const right = 2;    // right, top and bottom
      const top = 1;      // that match the default
      const bottom = -1;  // canvas size.
      const near = -1;
      const far = 1;
      const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);


   And of course update it if the canvas changes size


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            const aspect = canvas.clientWidth / canvas.clientHeight;
      +     camera.left = -aspect;
      +     camera.right = aspect;
            camera.updateProjectionMatrix();
         }
         ...


   We now have a camera that shows 2 units above and below the center and aspect units
   left and right.

   Next let's make a 2 color texture. We'll use a ``DataTexture`` which we've used a few
   `other <indexed-textures>` `places <post-processing-3dlut>`.


   .. code:: javascript

      function makeDataTexture(data, width, height) {
         const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
         texture.minFilter = THREE.NearestFilter;
         texture.magFilter = THREE.NearestFilter;
         texture.needsUpdate = true;
         return texture;
      }

      const cursorColors = new Uint8Array([
         64, 64, 64, 64,       // dark gray
         255, 255, 255, 255,   // white
      ]);
      const cursorTexture = makeDataTexture(cursorColors, 2, 1);


   We'll then use that texture on a ``TorusGeometry``


   .. code:: javascript

      const ringRadius = 0.4;
      const tubeRadius = 0.1;
      const tubeSegments = 4;
      const ringSegments = 64;
      const cursorGeometry = new THREE.TorusGeometry(
            ringRadius, tubeRadius, tubeSegments, ringSegments);

      const cursorMaterial = new THREE.MeshBasicMaterial({
         color: 'white',
         map: cursorTexture,
         transparent: true,
         blending: THREE.CustomBlending,
         blendSrc: THREE.OneMinusDstColorFactor,
         blendDst: THREE.OneMinusSrcColorFactor,
      });
      const cursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
      scene.add(cursor);


   and then in ``render`` lets adjust the texture's offset


   .. code:: javascript

      function render(time) {
         time *= 0.001;

         if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            const aspect = canvas.clientWidth / canvas.clientHeight;
            camera.left = -aspect;
            camera.right = aspect;
            camera.updateProjectionMatrix();
         }

      +   const fromStart = 0;
      +   const fromEnd = 2;
      +   const toStart = -0.5;
      +   const toEnd = 0.5;
      +   cursorTexture.offset.x = THREE.MathUtils.mapLinear(
      +       time % 2,
      +       fromStart, fromEnd,
      +       toStart, toEnd);

         renderer.render(scene, camera);
      }


   ``THREE.MathUtils.mapLinear`` takes a value that goes between ``fromStart`` and
   ``fromEnd`` and maps it to a value between ``toStart`` and ``toEnd``. In the case
   above we're taking ``time % 2`` which means a value that goes from 0 to 2 and maps
   that to a value that goes from -0.5 to 0.5

   `Textures <textures>` are mapped to geometry using normalized texture
   coordinates that go from 0 to 1. That means our 2x1 pixel image, set to the default
   wrapping mode of ``THREE.ClampToEdge``, if we adjust the texture coordinates by -0.5
   then the entire mesh will be the first color and if we adjust the texture
   coordinates by +0.5 the entire mesh will be the second color. In between with the
   filtering set to ``THREE.NearestFilter`` we'll be able to move the transition
   between the 2 colors through the geometry.

   Let's add a background texture while we're at it just like we covered in `the
   article on backgrounds <backgrounds>`. We'll just use a 2x2 set of colors but
   set the texture's repeat settings to give us an 8x8 grid. This will give our cursor
   something to be rendered over so we can check it against different colors.


   .. code:: javascript

      + const backgroundColors = new Uint8Array([
      +     0,   0,   0, 255,  // black
      +    90,  38,  38, 255,  // dark red
      +   100, 175, 103, 255,  // medium green
      +   255, 239, 151, 255,  // light yellow
      + ]);
      + const backgroundTexture = makeDataTexture(backgroundColors, 2, 2);
      + backgroundTexture.wrapS = THREE.RepeatWrapping;
      + backgroundTexture.wrapT = THREE.RepeatWrapping;
      + backgroundTexture.repeat.set(4, 4);

      const scene = new THREE.Scene();
      + scene.background = backgroundTexture;


   Now if we run that you'll see we get a circle like gauge and that we can set where
   the gauge is.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/webxr-look-to-select-selector.html>`__

   A few things to notice **and try**.

   -  We set the ``cursorMaterial``'s ``blending``, ``blendSrc`` and ``blendDst``
      properties as follows


      .. code:: javascript

            blending: THREE.CustomBlending,
            blendSrc: THREE.OneMinusDstColorFactor,
            blendDst: THREE.OneMinusSrcColorFactor,

      This gives as an *inverse* type of effect. Comment out those 3 lines and you'll
      see the difference. I'm just guessing the inverse effect is best here as that way
      we can hopefully see the cursor regardless of the colors it is over.


   -  We use a ``TorusGeometry`` and not a ``RingGeometry``

      For whatever reason the ``RingGeometry`` uses a flat UV mapping scheme. 
      Because of this if we use a ``RingGeometry`` the texture slides
      horizontally across the ring instead of around it like it does above.

      Try it out, change the ``TorusGeometry`` to a ``RingGeometry`` (it's just 
      commented out in the example above) and you'll see what I mean.

      The *proper* thing to do (for some definition of *proper*) would be to either use
      the ``RingGeometry`` but fix the texture coordinates so they go around the ring. 
      Or else, generate our own ring geometry. But, the torus works just fine. Placed 
      directly in front of the camera with a ``MeshBasicMaterial`` it will look exactly 
      like a ring and the texture coordinates go around the ring so it works for our needs.

   Let's integrate it with our VR code above.


   .. code:: javascript

      class PickHelper {
      -  constructor() {
      +   constructor(camera) {
            this.raycaster = new THREE.Raycaster();
            this.pickedObject = null;
      -     this.pickedObjectSavedColor = 0;

      +     const cursorColors = new Uint8Array([
      +       64, 64, 64, 64,       // dark gray
      +       255, 255, 255, 255,   // white
      +     ]);
      +     this.cursorTexture = makeDataTexture(cursorColors, 2, 1);
      + 
      +     const ringRadius = 0.4;
      +     const tubeRadius = 0.1;
      +     const tubeSegments = 4;
      +     const ringSegments = 64;
      +     const cursorGeometry = new THREE.TorusGeometry(
      +         ringRadius, tubeRadius, tubeSegments, ringSegments);
      + 
      +     const cursorMaterial = new THREE.MeshBasicMaterial({
      +       color: 'white',
      +       map: this.cursorTexture,
      +       transparent: true,
      +       blending: THREE.CustomBlending,
      +       blendSrc: THREE.OneMinusDstColorFactor,
      +       blendDst: THREE.OneMinusSrcColorFactor,
      +     });
      +     const cursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
      +     // add the cursor as a child of the camera
      +     camera.add(cursor);
      +     // and move it in front of the camera
      +     cursor.position.z = -1;
      +     const scale = 0.05;
      +     cursor.scale.set(scale, scale, scale);
      +     this.cursor = cursor;
      + 
      +     this.selectTimer = 0;
      +     this.selectDuration = 2;
      +     this.lastTime = 0;
         }
         pick(normalizedPosition, scene, camera, time) {
      +     const elapsedTime = time - this.lastTime;
      +     this.lastTime = time;

      -     // restore the color if there is a picked object
      -     if (this.pickedObject) {
      -       this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
      -       this.pickedObject = undefined;
      -     }

      +     const lastPickedObject = this.pickedObject;
      +     this.pickedObject = undefined;

            // cast a ray through the frustum
            this.raycaster.setFromCamera(normalizedPosition, camera);
            // get the list of objects the ray intersected
            const intersectedObjects = this.raycaster.intersectObjects(scene.children);
            if (intersectedObjects.length) {
            // pick the first object. It's the closest one
            this.pickedObject = intersectedObjects[0].object;
      -       // save its color
      -       this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
      -       // set its emissive color to flashing red/yellow
      -       this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
            }

      +     // show the cursor only if it's hitting something
      +     this.cursor.visible = this.pickedObject ? true : false;
      + 
      +     let selected = false;
      + 
      +     // if we're looking at the same object as before
      +     // increment time select timer
      +     if (this.pickedObject && lastPickedObject === this.pickedObject) {
      +       this.selectTimer += elapsedTime;
      +       if (this.selectTimer >= this.selectDuration) {
      +         this.selectTimer = 0;
      +         selected = true;
      +       }
      +     } else {
      +       this.selectTimer = 0;
      +     }
      + 
      +     // set cursor material to show the timer state
      +     const fromStart = 0;
      +     const fromEnd = this.selectDuration;
      +     const toStart = -0.5;
      +     const toEnd = 0.5;
      +     this.cursorTexture.offset.x = THREE.MathUtils.mapLinear(
      +         this.selectTimer,
      +         fromStart, fromEnd,
      +         toStart, toEnd);
      + 
      +     return selected ? this.pickedObject : undefined;
         }
      }


   You can see the code above we added all the code to create the cursor geometry,
   texture, and material and we added it as a child of the camera so it will always be
   in front of the camera. Note we need to add the camera to the scene otherwise the
   cursor won't be rendered.


   .. code:: javascript

      + scene.add(camera);


   We then check if the thing we're picking this time is the same as it was last time.
   If so we add the elapsed time to a timer and if the timer reaches its limit we
   return the selected item.

   Now let's use that to pick the cubes. As a simple example we'll add 3 spheres as
   well. When a cube is picked with hide the cube and un-hide the corresponding sphere.

   So first we'll make a sphere geometry


   .. code:: javascript

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      - const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      + const boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      + 
      + const sphereRadius = 0.5;
      + const sphereGeometry = new THREE.SphereGeometry(sphereRadius);


   Then let's create 3 pairs of box and sphere meshes. We'll use a
   `Map <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map>`__
   so that we can associate each ``Mesh`` with its partner.


   .. code:: javascript

      - const cubes = [
      -  makeInstance(geometry, 0x44aa88,  0),
      -  makeInstance(geometry, 0x8844aa, -2),
      -  makeInstance(geometry, 0xaa8844,  2),
      - ];
      + const meshToMeshMap = new Map();
      + [
      +   { x:  0, boxColor: 0x44aa88, sphereColor: 0xFF4444, },
      +   { x:  2, boxColor: 0x8844aa, sphereColor: 0x44FF44, },
      +   { x: -2, boxColor: 0xaa8844, sphereColor: 0x4444FF, },
      + ].forEach((info) => {
      +   const {x, boxColor, sphereColor} = info;
      +   const sphere = makeInstance(sphereGeometry, sphereColor, x);
      +   const box = makeInstance(boxGeometry, boxColor, x);
      +   // hide the sphere
      +   sphere.visible = false;
      +   // map the sphere to the box
      +   meshToMeshMap.set(box, sphere);
      +   // map the box to the sphere
      +   meshToMeshMap.set(sphere, box);
      + });


   In ``render`` where we rotate the cubes we need to iterate over ``meshToMeshMap``
   instead of ``cubes``.


   .. code:: javascript

      - cubes.forEach((cube, ndx) => {
      + let ndx = 0;
      + for (const mesh of meshToMeshMap.keys()) {
         const speed = 1 + ndx * .1;
         const rot = time * speed;
      -  cube.rotation.x = rot;
      -  cube.rotation.y = rot;
      - });
      +   mesh.rotation.x = rot;
      +   mesh.rotation.y = rot;
      +   ++ndx;
      + }


   And now we can use our new ``PickHelper`` implementation to select one of the
   objects. When selected we hide that object and un-hide its partner.


   .. code:: javascript

      // 0, 0 is the center of the view in normalized coordinates.
      - pickHelper.pick({x: 0, y: 0}, scene, camera, time);
      + const selectedObject = pickHelper.pick({x: 0, y: 0}, scene, camera, time);
      + if (selectedObject) {
      +   selectedObject.visible = false;
      +   const partnerObject = meshToMeshMap.get(selectedObject);
      +   partnerObject.visible = true;
      + }


   And with that we should have a pretty decent *look to select* implementation.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/webxr-look-to-select-w-cursor.html>`__

   I hope this example gave some ideas of how to implement a "look to select" type of
   Google Cardboard level UX. Sliding textures using texture coordinates offsets is
   also a commonly useful technique.

   Next up `let's allow the user that has a VR controller to point at and move
   things <webxr-point-to-select>`.


.. _F43:

VR - Point To Select
====================

   -  `VR - Point To Select <https://threejs.org/manual/en/webxr-point-to-select.html>`__


   **NOTE: The examples on this page require a VR capable device with a pointing
   device. Without one they won't work. See** `this article <webxr>`\ **as to
   why**

   In the `previous article <webxr-look-to-select>` we went over a very simple
   VR example where we let the user choose things by pointing via looking. In this
   article we will take it one step further and let the user choose with a pointing
   device.

   Three.js makes is relatively easy by providing 2 controller objects in VR and tries
   to handle both cases of a single 3DOF controller and two 6DOF controllers. Each of
   the controllers are ``Object3D`` objects which give the orientation and position of 
   that controller. They also provide ``selectstart``, ``select`` and ``selectend`` 
   events when the user starts pressing, is pressing, and stops pressing (ends) the 
   "main" button on the controller.

   Starting with the last example from `the previous article <webxr-look-to-select>` 
   let's change the ``PickHelper`` into a ``ControllerPickHelper``.

   Our new implementation will emit a ``select`` event that gives us the object that
   was picked so to use it we'll just need to do this.


   .. code:: javascript

      const pickHelper = new ControllerPickHelper(scene);
      pickHelper.addEventListener('select', (event) => {
         event.selectedObject.visible = false;
         const partnerObject = meshToMeshMap.get(event.selectedObject);
         partnerObject.visible = true;
      });


   Remember from our previous code ``meshToMeshMap`` maps our boxes and spheres to each
   other so if we have one we can look up its partner through ``meshToMeshMap`` so here
   we're just hiding the selected object and un-hiding its partner.

   As for the actual implementation of ``ControllerPickHelper``, first we need to add
   the VR controller objects to the scene and to those add some 3D lines we can use to
   display where the user is pointing. We save off both the controllers and the their
   lines.


   .. code:: javascript

      class ControllerPickHelper {
         constructor(scene) {
            const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -1),
            ]);

            this.controllers = [];
            for (let i = 0; i < 2; ++i) {
            const controller = renderer.xr.getController(i);
            scene.add(controller);

            const line = new THREE.Line(pointerGeometry);
            line.scale.z = 5;
            controller.add(line);
            this.controllers.push({controller, line});
            }
         }
      }


   Without doing anything else this alone would give us 1 or 2 lines in the scene
   showing where the user's pointing devices are and which way they are pointing.

   One problem we have though, we don't want have our ``RayCaster`` pick the line
   itself so an easy solution is separate the objects we wanted to be able to pick from
   the objects we don't by parenting them under another
   ``Object3D``.


   .. code:: javascript

      const scene = new THREE.Scene();
      + // object to put pickable objects on so we can easily
      + // separate them from non-pickable objects
      + const pickRoot = new THREE.Object3D();
      + scene.add(pickRoot);

      ...

      function makeInstance(geometry, color, x) {
         const material = new THREE.MeshPhongMaterial({color});

         const cube = new THREE.Mesh(geometry, material);
      -  scene.add(cube);
      +   pickRoot.add(cube);

      ...


   Next let's add some code to pick from the controllers. This is the first time we've
   picked with something not the camera. In our `article on picking <picking>`
   the user uses the mouse or finger to pick which means picking comes from the camera
   into the screen. In `the previous article <webxr-look-to-select>` we were
   picking based on which way the user is looking so again that comes from the camera.
   This time though we're picking from the position of the controllers so we're not
   using the camera.


   .. code:: javascript

      class ControllerPickHelper {
         constructor(scene) {
      +     this.raycaster = new THREE.Raycaster();
      +     this.objectToColorMap = new Map();
      +     this.controllerToObjectMap = new Map();
      +     this.tempMatrix = new THREE.Matrix4();

            const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
               new THREE.Vector3(0, 0, 0),
               new THREE.Vector3(0, 0, -1),
            ]);

            this.controllers = [];
            for (let i = 0; i < 2; ++i) {
               const controller = renderer.xr.getController(i);
               scene.add(controller);

               const line = new THREE.Line(pointerGeometry);
               line.scale.z = 5;
               controller.add(line);
               this.controllers.push({controller, line});
            }
         }
      +   update(pickablesParent, time) {
      +     this.reset();
      +     for (const {controller, line} of this.controllers) {
      +       // cast a ray through the from the controller
      +       this.tempMatrix.identity().extractRotation(controller.matrixWorld);
      +       this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      +       this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
      +       // get the list of objects the ray intersected
      +       const intersections = this.raycaster.intersectObjects(pickablesParent.children);
      +       if (intersections.length) {
      +         const intersection = intersections[0];
      +         // make the line touch the object
      +         line.scale.z = intersection.distance;
      +         // pick the first object. It's the closest one
      +         const pickedObject = intersection.object;
      +         // save which object this controller picked
      +         this.controllerToObjectMap.set(controller, pickedObject);
      +         // highlight the object if we haven't already
      +         if (this.objectToColorMap.get(pickedObject) === undefined) {
      +           // save its color
      +           this.objectToColorMap.set(pickedObject, pickedObject.material.emissive.getHex());
      +           // set its emissive color to flashing red/yellow
      +           pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFF2000 : 0xFF0000);
      +         }
      +       } else {
      +         line.scale.z = 5;
      +       }
      +     }
      +   }
      }


   Like before we use a ``Raycaster`` but this time
   we take the ray from the controller. Our previous ``PickHelper`` there was only one
   thing picking but here we have up to 2 controllers, one for each hand. We save off
   which object each controller is looking at in ``controllerToObjectMap``. We also
   save off the original emissive color in ``objectToColorMap`` and we make the line
   long enough to touch whatever it's pointing at.

   We need to add some code to reset these settings every frame.


   .. code:: javascript

      class ControllerPickHelper {

         ...

      +   _reset() {
      +     // restore the colors
      +     this.objectToColorMap.forEach((color, object) => {
      +       object.material.emissive.setHex(color);
      +     });
      +     this.objectToColorMap.clear();
      +     this.controllerToObjectMap.clear();
      +   }
         update(pickablesParent, time) {
      +     this._reset();

            ...

      }


   Next we want to emit a ``select`` event when the user clicks the controller. To do
   that we can extend three.js's ``EventDispatcher`` and then we'll check
   when we get a ``select`` event from the controller, then if that controller is
   pointing at something we emit what that controller is pointing at as our own
   ``select`` event.


   .. code:: javascript

      - class ControllerPickHelper {
      + class ControllerPickHelper extends THREE.EventDispatcher {
         constructor(scene) {
      +     super();
            this.raycaster = new THREE.Raycaster();
            this.objectToColorMap = new Map();  // object to save color and picked object
            this.controllerToObjectMap = new Map();
            this.tempMatrix = new THREE.Matrix4();

            const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -1),
            ]);

            this.controllers = [];
            for (let i = 0; i < 2; ++i) {
            const controller = renderer.xr.getController(i);
      +       controller.addEventListener('select', (event) => {
      +         const controller = event.target;
      +         const selectedObject = this.controllerToObjectMap.get(controller);
      +         if (selectedObject) {
      +           this.dispatchEvent({type: 'select', controller, selectedObject});
      +         }
      +       });
            scene.add(controller);

            const line = new THREE.Line(pointerGeometry);
            line.scale.z = 5;
            controller.add(line);
            this.controllers.push({controller, line});
            }
         }
      }


   All that is left is to call ``update`` in our render loop


   .. code:: javascript

      function render(time) {

         ...

      +   pickHelper.update(pickablesParent, time);

         renderer.render(scene, camera);
      }


   and assuming you have a VR device with a controller you should be able to use the
   controllers to pick things.


      `click here to open in a separate
      window <https://threejs.org/manual/examples/webxr-point-to-select.html>`__

   And what if we wanted to be able to move the objects?

   That's relatively easy. Let's move our controller 'select' listener code out into a
   function so we can use it for more than one thing.


   .. code:: javascript

      class ControllerPickHelper extends THREE.EventDispatcher {
         constructor(scene) {
            super();

            ...

            this.controllers = [];

      +     const selectListener = (event) => {
      +       const controller = event.target;
      +       const selectedObject = this.controllerToObjectMap.get(event.target);
      +       if (selectedObject) {
      +         this.dispatchEvent({type: 'select', controller, selectedObject});
      +       }
      +     };

            for (let i = 0; i < 2; ++i) {
            const controller = renderer.xr.getController(i);
      -       controller.addEventListener('select', (event) => {
      -         const controller = event.target;
      -         const selectedObject = this.controllerToObjectMap.get(event.target);
      -         if (selectedObject) {
      -           this.dispatchEvent({type: 'select', controller, selectedObject});
      -         }
      -       });
      +       controller.addEventListener('select', selectListener);

               ...


   Then let's use it for both ``selectstart`` and ``select``


   .. code:: javascript

      class ControllerPickHelper extends THREE.EventDispatcher {
         constructor(scene) {
            super();

            ...

            this.controllers = [];

            const selectListener = (event) => {
            const controller = event.target;
            const selectedObject = this.controllerToObjectMap.get(event.target);
            if (selectedObject) {
      -         this.dispatchEvent({type: 'select', controller, selectedObject});
      +         this.dispatchEvent({type: event.type, controller, selectedObject});
            }
            };

            for (let i = 0; i < 2; ++i) {
            const controller = renderer.xr.getController(i);
            controller.addEventListener('select', selectListener);
            controller.addEventListener('selectstart', selectListener);

               ...


   and let's also pass on the ``selectend`` event which three.js sends out when you
   user lets of the button on the controller.


   .. code:: javascript

      class ControllerPickHelper extends THREE.EventDispatcher {
         constructor(scene) {
            super();

            ...

            this.controllers = [];

            const selectListener = (event) => {
            const controller = event.target;
            const selectedObject = this.controllerToObjectMap.get(event.target);
            if (selectedObject) {
               this.dispatchEvent({type: event.type, controller, selectedObject});
            }
            };

      +     const endListener = (event) => {
      +       const controller = event.target;
      +       this.dispatchEvent({type: event.type, controller});
      +     };

            for (let i = 0; i < 2; ++i) {
            const controller = renderer.xr.getController(i);
            controller.addEventListener('select', selectListener);
            controller.addEventListener('selectstart', selectListener);
      +       controller.addEventListener('selectend', endListener);

               ...


   Now let's change the code so when we get a ``selectstart`` event we'll remove the
   selected object from the scene and make it a child of the controller. This means it
   will move with the controller. When we get a ``selectend`` event we'll put it back
   in the scene.


   .. code:: javascript

      const pickHelper = new ControllerPickHelper(scene);
      - pickHelper.addEventListener('select', (event) => {
      -  event.selectedObject.visible = false;
      -  const partnerObject = meshToMeshMap.get(event.selectedObject);
      -  partnerObject.visible = true;
      - });

      + const controllerToSelection = new Map();
      + pickHelper.addEventListener('selectstart', (event) => {
      +   const {controller, selectedObject} = event;
      +   const existingSelection = controllerToSelection.get(controller);
      +   if (!existingSelection) {
      +     controllerToSelection.set(controller, {
      +       object: selectedObject,
      +       parent: selectedObject.parent,
      +     });
      +     controller.attach(selectedObject);
      +   }
      + });
      + 
      + pickHelper.addEventListener('selectend', (event) => {
      +   const {controller} = event;
      +   const selection = controllerToSelection.get(controller);
      +   if (selection) {
      +     controllerToSelection.delete(controller);
      +     selection.parent.attach(selection.object);
      +   }
      + });


   When an object is selected we save off that object and its original parent. When the
   user is done we can put the object back.

   We use the ``Object3D.attach`` to re-parent the selected objects. These functions 
   let us change the parent of an object without changing its orientation and position 
   in the scene.

   And with that we should be able to move the objects around with a 6DOF controller or
   at least change their orientation with a 3DOF controller


      `click here to open in a separate
      window <https://threejs.org/manual/examples/webxr-point-to-select-w-move.html>`__

   To be honest I'm not 100% sure this ``ControllerPickHelper`` is the best way to
   organize the code but it's useful to demonstrating the various parts of getting
   something simple working in VR in three.js


.. _F44:

Material Table
==============

   -  `Material Table <https://threejs.org/manual/en/material-table.html>`__

   The most common materials in three.js are the Mesh materials. Here is a table
   showing which material support which features.

.. * `https://threejs.org/docs/#api/materials/${material.name}.${property}`__

.. _➊: https://threejs.org/docs/#api/materials/Basic
.. _➋: https://threejs.org/docs/#api/materials/Lambert
.. _➌: https://threejs.org/docs/#api/materials/Phong
.. _➍: https://threejs.org/docs/#api/materials/Standard
.. _➎: https://threejs.org/docs/#api/materials/Physical

   ➊_ = Basic
   ➋_ = Lambert
   ➌_ = Phong
   ➍_ = Standard
   ➎_ = Physical

   ========================= ==========================
   **Matteral Features**     ``| ➊ | ➋ | ➌ | ➍ | ➎ |``
   ========================= ==========================
   alphaMap                  ``| ● | ● | ● | ● | ● |``
   anisotropy                ``|   |   |   |   | ● |``
   anisotropyMap             ``|   |   |   |   | ● |``
   anisotropyRotation        ``|   |   |   |   | ● |``
   aoMap                     ``| ● | ● | ● | ● | ● |``
   aoMapIntensity            ``| ● | ● | ● | ● | ● |``
   attenuationColor          ``|   |   |   |   | ● |``
   attenuationDistance       ``|   |   |   |   | ● |``
   bumpMap                   ``|   | ● | ● | ● | ● |``
   bumpScale                 ``|   | ● | ● | ● | ● |``
   clearcoat                 ``|   |   |   |   | ● |``
   clearcoatMap              ``|   |   |   |   | ● |``
   clearcoatNormalMap        ``|   |   |   |   | ● |``
   clearcoatNormalScale      ``|   |   |   |   | ● |``
   clearcoatRoughness        ``|   |   |   |   | ● |``
   clearcoatRoughnessMap     ``|   |   |   |   | ● |``
   color                     ``| ● | ● | ● | ● | ● |``
   combine                   ``| ● | ● | ● |   |   |``
   displacementBias          ``|   | ● | ● | ● | ● |``
   displacementMap           ``|   | ● | ● | ● | ● |``
   displacementScale         ``|   | ● | ● | ● | ● |``
   emissive                  ``|   | ● | ● | ● | ● |``
   emissiveIntensity         ``|   | ● | ● | ● | ● |``
   emissiveMap               ``|   | ● | ● | ● | ● |``
   envMap                    ``| ● | ● | ● | ● | ● |``
   envMapIntensity           ``|   |   |   | ● | ● |``
   ior                       ``|   |   |   |   | ● |``
   iridescence               ``|   |   |   |   | ● |``
   iridescenceIOR            ``|   |   |   |   | ● |``
   iridescenceMap            ``|   |   |   |   | ● |``
   iridescenceThicknessMap   ``|   |   |   |   | ● |``
   iridescenceThicknessRange ``|   |   |   |   | ● |``
   lightMap                  ``| ● | ● | ● | ● | ● |``
   lightMapIntensity         ``| ● | ● | ● | ● | ● |``
   map                       ``| ● | ● | ● | ● | ● |``
   metalness                 ``|   |   |   | ● | ● |``
   metalnessMap              ``|   |   |   | ● | ● |``
   normalMap                 ``|   | ● | ● | ● | ● |``
   normalMapType             ``|   | ● | ● | ● | ● |``
   normalScale               ``|   | ● | ● | ● | ● |``
   reflectivity              ``| ● | ● | ● |   | ● |``
   refractionRatio           ``| ● | ● | ● | ● | ● |``
   roughness                 ``|   |   |   | ● | ● |``
   roughnessMap              ``|   |   |   | ● | ● |``
   sheen                     ``|   |   |   |   | ● |``
   sheenColor                ``|   |   |   |   | ● |``
   sheenColorMap             ``|   |   |   |   | ● |``
   sheenRoughness            ``|   |   |   |   | ● |``
   sheenRoughnessMap         ``|   |   |   |   | ● |``
   shininess                 ``|   |   | ● |   |   |``
   specular                  ``|   |   | ● |   |   |``
   specularColor             ``|   |   |   |   | ● |``
   specularColorMap          ``|   |   |   |   | ● |``
   specularIntensity         ``|   |   |   |   | ● |``
   specularIntensityMap      ``|   |   |   |   | ● |``
   specularMap               ``| ● | ● | ● |   |   |``
   thickness                 ``|   |   |   |   | ● |``
   thicknessMap              ``|   |   |   |   | ● |``
   transmission              ``|   |   |   |   | ● |``
   transmissionMap           ``|   |   |   |   | ● |``
   wireframe                 ``| ● | ● | ● | ● | ● |``
   ========================= ==========================




🟡 Documentation
=================

   .. code:: bash

      while read -r html
      do 
         echo ".. _page:" >> $0
         pandoc -trst -fhtml $html --column=90 >> $0
      done << EOF
      https://threejs.org/docs/manual/en/introduction/Installation.html
      https://threejs.org/docs/manual/en/introduction/Creating-a-scene.html
      https://threejs.org/docs/manual/en/introduction/WebGL-compatibility-check.html
      https://threejs.org/docs/manual/en/introduction/Drawing-lines.html
      https://threejs.org/docs/manual/en/introduction/Creating-text.html
      https://threejs.org/docs/manual/en/introduction/Loading-3D-models.html
      https://threejs.org/docs/manual/en/introduction/Libraries-and-Plugins.html
      https://threejs.org/docs/manual/en/introduction/FAQ.html
      https://threejs.org/docs/manual/en/introduction/Useful-links.html
      https://threejs.org/docs/manual/en/introduction/How-to-update-things.html
      https://threejs.org/docs/manual/en/introduction/How-to-dispose-of-objects.html
      https://threejs.org/docs/manual/en/introduction/How-to-create-VR-content.html
      https://threejs.org/docs/manual/en/introduction/How-to-use-post-processing.html
      https://threejs.org/docs/manual/en/introduction/Matrix-transformations.html
      https://threejs.org/docs/manual/en/introduction/Animation-system.html
      https://threejs.org/docs/manual/en/introduction/Color-management.html
      https://threejs.org/docs/api/en/animation/AnimationAction.html
      ...
      EOF
      exit


Getting Started
---------------

   -  [D001]_ `Installation  <https://threejs.org/docs/manual/en/introduction/Installation.html>`__
   -  [D002]_ `Creating a scene  <https://threejs.org/docs/manual/en/introduction/Creating-a-scene.html>`__
   -  [D003]_ `WebGL compatibility check  <https://threejs.org/docs/manual/en/introduction/WebGL-compatibility-check.html>`__
   -  [D004]_ `Drawing lines  <https://threejs.org/docs/manual/en/introduction/Drawing-lines.html>`__
   -  [D005]_ `Creating text  <https://threejs.org/docs/manual/en/introduction/Creating-text.html>`__
   -  [D006]_ `Loading 3D models  <https://threejs.org/docs/manual/en/introduction/Loading-3D-models.html>`__
   -  [D007]_ `Libraries and Plugins  <https://threejs.org/docs/manual/en/introduction/Libraries-and-Plugins.html>`__
   -  [D008]_ `FAQ  <https://threejs.org/docs/manual/en/introduction/FAQ.html>`__
   -  [D009]_ `Useful links  <https://threejs.org/docs/manual/en/introduction/Useful-links.html>`__

Next Steps
----------

   -  [D010]_ `Updating resources  <https://threejs.org/docs/manual/en/introduction/How-to-update-things.html>`__
   -  [D011]_ `Disposing resources  <https://threejs.org/docs/manual/en/introduction/How-to-dispose-of-objects.html>`__
   -  [D012]_ `Creating VR content  <https://threejs.org/docs/manual/en/introduction/How-to-create-VR-content.html>`__
   -  [D013]_ `Post-processing  <https://threejs.org/docs/manual/en/introduction/How-to-use-post-processing.html>`__
   -  [D014]_ `Matrix transformations  <https://threejs.org/docs/manual/en/introduction/Matrix-transformations.html>`__
   -  [D015]_ `Animation system  <https://threejs.org/docs/manual/en/introduction/Animation-system.html>`__
   -  [D016]_ `Color management  <https://threejs.org/docs/manual/en/introduction/Color-management.html>`__


.. _D001:

Installation
============

   https://threejs.org/docs/manual/en/introduction/Installation.html

Project structure
-----------------

   Every three.js project needs at least one HTML file to define the webpage, and a
   JavaScript file to run your three.js code. The structure and naming choices below aren't
   required, but will be used throughout this guide for consistency.

   -  *index.html*

      .. code:: javascript

         <!DOCTYPE html> 
         <html lang="en"> 
            <head> 
               <meta charset="utf-8"> 
               <title>My first three.js app</title> 
               <style> body { margin: 0;
               } </style> 
            </head> 
         <body> 
         <script type="module" src="/main.js"></script> 
         </body> 
         </html>

   -  *main.js*

      .. code:: javascript

         import * as THREE from 'three';
         ...

   -  *public/*

      -  The *public/* folder is sometimes also called a "static" folder, because the files
         it contains are pushed to the website unchanged. Usually textures, audio, and 3D
         models will go here.

   Now that we've set up the basic project structure, we need a way to run the project
   locally and access it through a web browser. Installation and local development can be
   accomplished with npm and a build tool, or by importing three.js from a CDN. Both options
   are explained in the sections below.

Option 1: Install with NPM and a build tool
-------------------------------------------

   Development
   ~~~~~~~~~~~

   Installing from the `npm package registry <https://www.npmjs.com/>`__ and using a
   `build tool <https://eloquentjavascript.net/10_modules.html#h_zWTXAU93DC>`__ is the
   recommended approach for most users — the more dependencies your project needs, the more
   likely you are to run into problems that the static hosting cannot easily resolve. With a
   build tool, importing local JavaScript files and npm packages should work out of the box,
   without import maps.

   #. Install `Node.js <https://nodejs.org/>`__. We'll need it to load manage dependencies
      and to run our build tool.

   #. Install three.js and a build tool, `Vite <https://vitejs.dev/>`__, using a
      `terminal <https://www.joshwcomeau.com/javascript/terminal-for-js-devs/>`__ in your
      project folder. Vite will be used during development, but it isn't part of the final
      webpage. If you prefer to use another build tool, that's fine — we support modern build
      tools that can import `ES Modules <https://eloquentjavascript.net/10_modules.html#h_zWTXAU93DC>`__.


      .. code:: bash

         # three.js 
         npm install --save three 

         # vite 
         npm install --save-dev vite


      Installation added *node_modules/* and *package.json* to my project. What are they?

      npm uses *package.json* to describe which versions of each dependency you've installed.
      If you have other people working on the project with you, they can install the original
      versions of each dependency simply by running *npm install*. If you're using version
      history, commit *package.json*.

      npm installs the code for each dependency in a new *node_modules/* folder. When Vite
      builds your application, it sees imports for 'three' and pulls three.js files
      automatically from this folder. The *node_modules/* folder is used only during
      development, and shouldn't be uploaded to your web hosting provider or committed to
      version history.

   #. From your terminal, run: 
   
      .. code:: bash

         npx vite

      What is *npx*?

      npx is installed with Node.js, and runs command line programs like Vite so that you
      don't have to search for the right file in *node_modules/* yourself. If you prefer, you
      can put `Vite's common commands <https://vitejs.dev/guide/#command-line-interface>`__
      into the `package.json:scripts <https://docs.npmjs.com/cli/v9/using-npm/scripts>`__
      list, and use *npm run dev* instead.

   #. If everything went well, you'll see a URL like *http://localhost:5173* appear in your
      terminal, and can open that URL to see your web application.

   The page will be blank — you're ready to `create a scene <#manual/introduction/Creating-a-scene>`__.

   If you want to learn more about these tools before you continue, see:

   -  `three.js journey: Local Server <https://threejs-journey.com/lessons/local-server>`__
   -  `Vite: Command Line Interface <https://vitejs.dev/guide/cli.html>`__
   -  `MDN: Package management basics <https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Package_management>`__

   Production
   ~~~~~~~~~~

   Later, when you're ready to deploy your web application, you'll just need to tell Vite to
   run a production build — *npx vite build*. Everything used by the application will be
   compiled, optimized, and copied into the *dist/* folder. The contents of that folder are
   ready to be hosted on your website.

Option 2: Import from a CDN
---------------------------


   Development
   ~~~~~~~~~~~

   Installing without build tools will require some changes to the project structure given
   above.

   #. We imported code from 'three' (an npm package) in *main.js*, and web browsers don't
      know what that means. In *index.html* we'll need to add an
      `import map <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap>`__ 
      defining where to get the package. Put the code below inside the
      *<head></head>* tag, after the styles.


      .. code:: javascript

         <script type="importmap"> 
         { 
            "imports": { 
               "three": "https://cdn.jsdelivr.net/npm/three@<version>/build/three.module.js", 
               "three/addons/": "https://cdn.jsdelivr.net/npm/three@<version>/examples/jsm/" 
            } 
         } 
         </script>


      Don't forget to replace *<version>* with an actual version of three.js, like
      *"v0.149.0"*. The most recent version can be found on the
      `npm version list <https://www.npmjs.com/package/three?activeTab=versions>`__.

   #. We'll also need to run a *local server* to host these files at URL where the web
      browser can access them. While it's technically possible to double-click an HTML file
      and open it in your browser, important features that we'll later implement, do not work
      when the page is opened this way, for security reasons.

      Install `Node.js <https://nodejs.org/>`__, then run `serve <https://www.npmjs.com/package/serve>`__ 
      to start a local server in the project's directory:


      .. code:: javascript

         npx serve .


   #. If everything went well, you'll see a URL like http://localhost:3000 appear in your
      terminal, and can open that URL to see your web application.

   The page will be blank — you're ready to `create a scene <#manual/introduction/Creating-a-scene>`__.

   Many other local static servers are available — some use different languages instead of
   Node.js, and others are desktop applications. They all work basically the same way, and
   we've provided a few alternatives below.

   More local servers

   Command Line
   ~~~~~~~~~~~~

   Command line local servers run from a terminal window. The associated programming language
   may need to be installed first.

   ============================== ==================
   ``npx http-server``            (Node.js)
   ``npx five-server``            (Node.js)
   ``python -m SimpleHTTPServer`` (Python 2.x)
   ``python -m http.server``      (Python 3.x)
   ``php -S localhost:8000``      (PHP 5.4+)
   ============================== ==================

   GUI
   ~~~

   GUI local servers run as an application window on your computer, and may have a user
   interface.

   -  `Servez <https://greggman.github.io/servez>`__

   Code Editor Plugins
   ~~~~~~~~~~~~~~~~~~~

   Some code editors have plugins that spawn a simple server on demand.

   -  `Five Server <https://marketplace.visualstudio.com/items?itemName=yandeu.five-server>`__ 
      for Visual Studio Code
   -  `Live Server <https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer>`__ 
      for Visual Studio Code
   -  `Live Server <https://atom.io/packages/atom-live-server>`__ for Atom


   Production
   ~~~~~~~~~~

   When you're ready to deploy your web application, push the source files to your web
   hosting provider — no need to build or compile anything. The downside of that tradeoff is
   that you'll need to be careful to keep the import map updated with any dependencies (and
   dependencies of dependencies!) that your application requires. If the CDN hosting your
   dependencies goes down temporarily, your website will stop working too.

   **IMPORTANT:** *Import all dependencies from the same version of three.js, and from the
   same CDN. Mixing files from different sources may cause duplicate code to be included, or
   even break the application in unexpected ways.*

Addons
------

   Out of the box, three.js includes the fundamentals of a 3D engine. Other three.js
   components — such as controls, loaders, and post-processing effects — are part of the
   `addons/ <https://github.com/mrdoob/three.js/tree/dev/examples/jsm>`__ directory. Addons
   do not need to be *installed* separately, but do need to be *imported* separately.

   The example below shows how to import three.js with the ``OrbitControls`` and
   ``GLTFLoader`` addons. Where necessary, this will also be mentioned in each addon's
   documentation or examples.


   .. code:: javascript

      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      
      const controls = new OrbitControls( camera, renderer.domElement );
      const loader = new GLTFLoader();


   Some excellent third-party projects are available for three.js, too. These need to be
   installed separately — see `Libraries and Plugins <#manual/introduction/Libraries-and-Plugins>`__.

   Next Steps
   ----------

   You're now ready to `create a scene <#manual/introduction/Creating-a-scene>`__.


.. _D002:

Creating a scene
================

   https://threejs.org/docs/manual/en/introduction/Creating-a-scene.html

   The goal of this section is to give a brief introduction to three.js. We will start by
   setting up a scene, with a spinning cube. A working example is provided at the bottom of
   the page in case you get stuck and need help.

   Before we start
   ---------------

   If you haven't yet, go through the `Installation <#manual/introduction/Installation>`__
   guide. We'll assume you've already set up the same project structure (including
   *index.html* and *main.js*), have installed three.js, and are either running a build tool,
   or using a local server with a CDN and import maps.

   Creating the scene
   ------------------

   To actually be able to display anything with three.js, we need three things: scene, camera
   and renderer, so that we can render the scene with camera.

   *main.js —*


   .. code:: javascript

      import * as THREE from 'three';
      
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera( 75, 
            window.innerWidth / window.innerHeight, 0.1, 1000 );
      const renderer = new THREE.WebGLRenderer();

      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );


   Let's take a moment to explain what's going on here. We have now set up the scene, our
   camera and the renderer.

   There are a few different cameras in three.js. For now, let's use a ``PerspectiveCamera``.

   The first attribute is the ``field of view``. FOV is the extent of the scene that is seen
   on the display at any given moment. The value is in degrees.

   The second one is the ``aspect ratio``. You almost always want to use the width of the
   element divided by the height, or you'll get the same result as when you play old movies
   on a widescreen TV - the image looks squished.

   The next two attributes are the ``near`` and ``far`` clipping plane. What that means, is
   that objects further away from the camera than the value of ``far`` or closer than
   ``near`` won't be rendered. You don't have to worry about this now, but you may want to
   use other values in your apps to get better performance.

   Next up is the renderer. In addition to creating the renderer instance, we also need to
   set the size at which we want it to render our app. It's a good idea to use the width and
   height of the area we want to fill with our app - in this case, the width and height of
   the browser window. For performance intensive apps, you can also give ``setSize`` smaller
   values, like ``window.innerWidth/2`` and ``window.innerHeight/2``, which will make the app
   render at quarter size.

   If you wish to keep the size of your app but render it at a lower resolution, you can do
   so by calling ``setSize`` with false as ``updateStyle`` (the third argument). For example,
   ``setSize(window.innerWidth/2, window.innerHeight/2, false)`` will render your app at half
   resolution, given that your <canvas> has 100% width and height.

   Last but not least, we add the ``renderer`` element to our HTML document. This is a
   <canvas> element the renderer uses to display the scene to us.

   *"That's all good, but where's that cube you promised?"* Let's add it now.


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 1, 1, 1 );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const cube = new THREE.Mesh( geometry, material );

      scene.add( cube );
      camera.position.z = 5;


   To create a cube, we need a ``BoxGeometry``. This is an object that contains all the
   points (``vertices``) and fill (``faces``) of the cube. We'll explore this more in the
   future.

   In addition to the geometry, we need a material to color it. Three.js comes with several
   materials, but we'll stick to the ``MeshBasicMaterial`` for now. All materials take an
   object of properties which will be applied to them. To keep things very simple, we only
   supply a color attribute of ``0x00ff00``, which is green. This works the same way that
   colors work in CSS or Photoshop (``hex colors``).

   The third thing we need is a ``Mesh``. A mesh is an object that takes a geometry, and
   applies a material to it, which we then can insert to our scene, and move freely around.

   By default, when we call ``scene.add()``, the thing we add will be added to the
   coordinates ``(0,0,0)``. This would cause both the camera and the cube to be inside each
   other. To avoid this, we simply move the camera out a bit.

   Rendering the scene
   -------------------

   If you copied the code from above into the HTML file we created earlier, you wouldn't be
   able to see anything. This is because we're not actually rendering anything yet. For that,
   we need what's called a render or animation loop.


   .. code:: javascript

      function animate() { 
         renderer.render( scene, camera );
      }
      renderer.setAnimationLoop( animate );


   This will create a loop that causes the renderer to draw the scene every time the screen
   is refreshed (on a typical screen this means 60 times per second). If you're new to
   writing games in the browser, you might say *"why don't we just create a setInterval ?"*
   The thing is - we could, but ``requestAnimationFrame`` which is internally used in
   ``WebGLRenderer`` has a number of advantages. Perhaps the most important one is that it
   pauses when the user navigates to another browser tab, hence not wasting their precious
   processing power and battery life.

   Animating the cube
   ------------------

   If you insert all the code above into the file you created before we began, you should see
   a green box. Let's make it all a little more interesting by rotating it.

   Add the following code right above the ``renderer.render`` call in your ``animate``
   function:


   .. code:: javascript

      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;


   This will be run every frame (normally 60 times per second), and give the cube a nice
   rotation animation. Basically, anything you want to move or change while the app is
   running has to go through the animation loop. You can of course call other functions from
   there, so that you don't end up with an ``animate`` function that's hundreds of lines.

   The result
   ----------

   Congratulations! You have now completed your first three.js application. It's simple, but
   you have to start somewhere.

   The full code is available below and as an editable `live example <https://jsfiddle.net/tswh48fL/>`__. 
   Play around with it to get a better understanding of how it works.

   *index.html —*


   .. code:: javascript

      <!DOCTYPE html> 
         <html lang="en"> 
            <head> 
               <meta charset="utf-8"> 
               <title>My first three.js app</title> 
               <style> body { margin: 0; } </style> 
            </head> 
            <body> 
               <script type="module" src="/main.js"></script> 
            </body> 
         </html>


   *main.js —*


   .. code:: javascript

      import * as THREE from 'three';
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera( 75, 
            window.innerWidth / window.innerHeight, 0.1, 1000 );
      const renderer = new THREE.WebGLRenderer();

      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.setAnimationLoop( animate );
      document.body.appendChild( renderer.domElement );

      const geometry = new THREE.BoxGeometry( 1, 1, 1 );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const cube = new THREE.Mesh( geometry, material );

      scene.add( cube );
      camera.position.z = 5;

      function animate() { cube.rotation.x += 0.01;
         cube.rotation.y += 0.01;
         renderer.render( scene, camera );
      }



.. _D003:

WebGL compatibility check
=========================

   https://threejs.org/docs/manual/en/introduction/WebGL-compatibility-check.html

   Even though this is becoming less and less of a problem, some devices or browsers may
   still not support WebGL 2. The following method allows you to check if it is supported and
   display a message to the user if it is not. Import the WebGL support detection module, and
   run the following before attempting to render anything.


   .. code:: javascript

      import WebGL from 'three/addons/capabilities/WebGL.js';
      if ( WebGL.isWebGL2Available() ) { 
         // Initiate function or other initializations here animate();
      } else { const warning = WebGL.getWebGL2ErrorMessage();
         document.getElementById( 'container' ).appendChild( warning );
      }



.. _D004:

Drawing lines
=============

   https://threejs.org/docs/manual/en/introduction/Drawing-lines.html


      Let's say you want to draw a line or a circle, not a wireframe ``Mesh``. First we
      need to set up the `renderer <#WebGLRenderer>`__, `scene <#Scene>`__ and camera (see
      the Creating a scene page).

      Here is the code that we will use:


      .. code:: javascript

         const renderer = new THREE.WebGLRenderer();
         renderer.setSize( window.innerWidth, window.innerHeight );
         document.body.appendChild( renderer.domElement );

         const camera = new THREE.PerspectiveCamera( 45, 
               window.innerWidth / window.innerHeight, 1, 500 );
         camera.position.set( 0, 0, 100 );
         camera.lookAt( 0, 0, 0 );
         const scene = new THREE.Scene();

      Next thing we will do is define a material. For lines we have to use
      ``LineBasicMaterial`` or ``LineDashedMaterial``.


      .. code:: javascript

         //create a blue LineBasicMaterial 
         const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
         
      After material we will need a geometry with some vertices:


      .. code:: javascript

         const points = [];
         points.push( new THREE.Vector3( - 10, 0, 0 ) );
         points.push( new THREE.Vector3( 0, 10, 0 ) );
         points.push( new THREE.Vector3( 10, 0, 0 ) );
         const geometry = new THREE.BufferGeometry().setFromPoints( points );
         
      Note that lines are drawn between each consecutive pair of vertices, but not between
      the first and last (the line is not closed.)

      Now that we have points for two lines and a material, we can put them together to form
      a line.


      .. code:: javascript

         const line = new THREE.Line( geometry, material );
         
      All that's left is to add it to the scene and call `render <#WebGLRenderer.render>`__.


      .. code:: javascript

         scene.add( line );
         renderer.render( scene, camera );
         
      You should now be seeing an arrow pointing upwards, made from two blue lines.


.. _D005:

Creating text
=============

   https://threejs.org/docs/manual/en/introduction/Creating-text.html


      There are often times when you might need to use text in your three.js application -
      here are a couple of ways that you can do so.

   1. DOM + CSS
   ------------


      Using HTML is generally the easiest and fastest manner to add text. This is the method
      used for descriptive overlays in most three.js examples.

      You can add content to a


      .. code:: javascript

         <div id="info">Description</div>

      and use CSS markup to position absolutely at a position above all others with a z-index
      especially if you are running three.js full screen.


      .. code:: javascript

         #info { 
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
         }


   2. Use ``CSS2DRenderer`` or ``CSS3DRenderer``
   ---------------------------------------------------


      Use these renderers to draw high-quality text contained in DOM elements to your
      three.js scene. This is similar to 1. except that with these renderers elements can be
      integrated more tightly and dynamically into the scene.

   3. Draw text to canvas and use as a ``Texture``
   --------------------------------------------------


      Use this method if you wish to draw text easily on a plane in your three.js scene.

   4. Create a model in your favourite 3D application and export to three.js
   -------------------------------------------------------------------------


      Use this method if you prefer working with your 3d applications and importing the
      models to three.js.

   5. Procedural Text Geometry
   ---------------------------


      If you prefer to work purely in THREE.js or to create procedural and dynamic 3D text
      geometries, you can create a mesh whose geometry is an instance of THREE.TextGeometry:


      .. code:: javascript

         new THREE.TextGeometry( text, parameters );
         

      In order for this to work, however, your TextGeometry will need an instance of
      THREE.Font to be set on its "font" parameter. See the ``TextGeometry`` page for more
      info on how this can be done, descriptions of each accepted parameter, and a list of
      the JSON fonts that come with the THREE.js distribution itself.

      **Examples**

      [example:webgl_geometry_text WebGL / geometry / text]
      [example:webgl_shadowmap WebGL / shadowmap]

      If Typeface is down, or you want to use a font that is not there, there's a tutorial
      with a python script for blender that allows you to export text to Three.js's JSON
      format: http://www.jaanga.com/2012/03/blender-to-threejs-create-3d-text-with.html

   6. Bitmap Fonts
   ---------------


      BMFonts (bitmap fonts) allow batching glyphs into a single BufferGeometry. BMFont
      rendering supports word-wrapping, letter spacing, kerning, signed distance fields with
      standard derivatives, multi-channel signed distance fields, multi-texture fonts, and
      more. See `three-mesh-ui <https://github.com/felixmariotto/three-mesh-ui>`__ or
      `three-bmfont-text <https://github.com/Jam3/three-bmfont-text>`__.

      Stock fonts are available in projects like `A-Frame Fonts <https://github.com/etiennepinchon/aframe-fonts>`__, 
      or you can create your own from any .TTF font, optimizing to include only characters 
      required for a project.

      Some helpful tools:

      -  `msdf-bmfont-web <http://msdf-bmfont.donmccurdy.com/>`__ *(web-based)*
      -  `msdf-bmfont-xml <https://github.com/soimy/msdf-bmfont-xml>`__ *(commandline)*
      -  `hiero <https://github.com/libgdx/libgdx/wiki/Hiero>`__ *(desktop app)*

   7. Troika Text

      The `troika-three-text <https://www.npmjs.com/package/troika-three-text>`__ package
      renders quality antialiased text using a similar technique as BMFonts, but works
      directly with any .TTF or .WOFF font file so you don't have to pregenerate a glyph
      texture offline. It also adds capabilities including:

      -  Effects like strokes, drop shadows, and curvature
      -  The ability to apply any three.js Material, even a custom ShaderMaterial
      -  Support for font ligatures, scripts with joined letters, and
         right-to-left/bidirectional layout
      -  Optimization for large amounts of dynamic text, performing most work off the main
         thread in a web worker


.. _D006:

Loading 3D models
=================

   https://threejs.org/docs/manual/en/introduction/Loading-3D-models.html

   3D models are available in hundreds of file formats, each with different purposes,
   assorted features, and varying complexity. Although `three.js provides many loaders 
   <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders>`__, choosing
   the right format and workflow will save time and frustration later on. Some formats are
   difficult to work with, inefficient for realtime experiences, or simply not fully
   supported at this time.

   This guide provides a workflow recommended for most users, and suggestions for what to try
   if things don't go as expected.

   Before we start
   ---------------

   If you're new to running a local server, begin with `installation <#manual/introduction/Installation>`__ 
   first. Many common errors viewing 3D models can be avoided by hosting files correctly.

   Recommended workflow
   --------------------

   Where possible, we recommend using glTF (GL Transmission Format). Both .GLB and .GLTF
   versions of the format are well supported. Because glTF is focused on runtime asset
   delivery, it is compact to transmit and fast to load. Features include meshes, materials,
   textures, skins, skeletons, morph targets, animations, lights, and cameras.

   Public-domain glTF files are available on sites like
   `Sketchfab <https://sketchfab.com/models?features=downloadable&sort_by=-likeCount&type=models>`__,
   or various tools include glTF export:

   -  `Blender <https://www.blender.org/>`__ by the Blender Foundation
   -  `Substance Painter <https://www.allegorithmic.com/products/substance-painter>`__ 
      by Allegorithmic
   -  `Modo <https://www.foundry.com/products/modo>`__ by Foundry
   -  `Toolbag <https://www.marmoset.co/toolbag/>`__ by Marmoset
   -  `Houdini <https://www.sidefx.com/products/houdini/>`__ by SideFX
   -  `Cinema 4D <https://labs.maxon.net/?p=3360>`__ by MAXON
   -  `COLLADA2GLTF <https://github.com/KhronosGroup/COLLADA2GLTF>`__ by the Khronos Group
   -  `FBX2GLTF <https://github.com/facebookincubator/FBX2glTF>`__ by Facebook
   -  `OBJ2GLTF <https://github.com/AnalyticalGraphicsInc/obj2gltf>`__ by Analytical Graphics
      Inc
   -  …and `many more <http://github.khronos.org/glTF-Project-Explorer/>`__

   If your preferred tools do not support glTF, consider requesting glTF export from the
   authors, or posting on `the glTF roadmap thread <https://github.com/KhronosGroup/glTF/issues/1051>`__.

   When glTF is not an option, popular formats such as FBX, OBJ, or COLLADA are also
   available and regularly maintained.

   Loading
   -------

   Only a few loaders (e.g. ``ObjectLoader``) are included by default with three.js —
   others should be added to your app individually.


   .. code:: javascript

      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


   Once you've imported a loader, you're ready to add a model to your scene. Syntax varies
   among different loaders — when using another format, check the examples and documentation
   for that loader. For glTF, usage with global scripts would be:


   .. code:: javascript

      const loader = new GLTFLoader();
      loader.load( 'path/to/model.glb', function ( gltf ) { 
         scene.add( gltf.scene );
      }, undefined, function ( error ) { 
         console.error( error );
      } );


   See `GLTFLoader documentation <#GLTFLoader>`__ for further details.

   Troubleshooting
   ---------------

   You've spent hours modeling an artisanal masterpiece, you load it into the webpage, and —
   oh no! 😭 It's distorted, miscolored, or missing entirely. Start with these
   troubleshooting steps:

   #. Check the JavaScript console for errors, and make sure you've used an ``onError``
      callback when calling ``.load()`` to log the result.

   #. View the model in another application. For glTF, drag-and-drop viewers are available
      for `three.js <https://gltf-viewer.donmccurdy.com/>`__ and
      `babylon.js <https://sandbox.babylonjs.com/>`__. If the model appears correctly in one
      or more applications, `file a bug against three.js <https://github.com/mrdoob/three.js/issues/new>`__. 
      If the model cannot be shown in any application, we strongly encourage filing 
      a bug with the application used to create the model.

   #. Try scaling the model up or down by a factor of 1000. Many models are scaled
      differently, and large models may not appear if the camera is inside the model.

   #. Try to add and position a light source. The model may be hidden in the dark.

   #. Look for failed texture requests in the network tab, like
      ``"C:PPathTToMModelttexture.jpg"``. Use paths relative to your model instead,
      such as ``images/texture.jpg`` — this may require editing the model file in a text
      editor.

   Asking for help
   ---------------

   If you've gone through the troubleshooting process above and your model still isn't
   working, the right approach to asking for help will get you to a solution faster. Post a
   question on the `three.js forum <https://discourse.threejs.org/>`__ and, whenever
   possible, include your model (or a simpler model with the same problem) in any formats you
   have available. Include enough information for someone else to reproduce the issue quickly
   — ideally, a live demo.


.. _D007:

Libraries and Plugins
=====================

   https://threejs.org/docs/manual/en/introduction/Libraries-and-Plugins.html

   Listed here are externally developed compatible libraries and plugins for three.js. This
   list and the associated packages are maintained by the community and not guaranteed to be
   up to date. If you'd like to update this list make a PR!

   Physics
   ~~~~~~~

   -  `Oimo.js <https://github.com/lo-th/Oimo.js/>`__
   -  `enable3d <https://enable3d.io/>`__
   -  `ammo.js <https://github.com/kripken/ammo.js/>`__
   -  `cannon-es <https://github.com/pmndrs/cannon-es>`__
   -  `rapier <https://rapier.rs/>`__
   -  `Jolt <https://github.com/jrouwe/JoltPhysics.js>`__

   Postprocessing
   ~~~~~~~~~~~~~~

   In addition to the `official three.js postprocessing effects 
   <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing>`__, 
   support for some additional effects and frameworks are available through external libraries.

   -  `postprocessing <https://github.com/vanruesc/postprocessing>`__

   Intersection and Raycast Performance
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `three-mesh-bvh <https://github.com/gkjohnson/three-mesh-bvh>`__

   Path Tracing
   ~~~~~~~~~~~~

   -  `three-gpu-pathtracer <https://github.com/gkjohnson/three-gpu-pathtracer>`__

   File Formats
   ~~~~~~~~~~~~

   In addition to the `official three.js loaders <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders>`__, 
   support for some additional formats is available through external libraries.

   -  `urdf-loader <https://github.com/gkjohnson/urdf-loaders/tree/master/javascript>`__
   -  `3d-tiles-renderer-js <https://github.com/NASA-AMMOS/3DTilesRendererJS>`__
   -  `WebWorker OBJLoader <https://github.com/kaisalmen/WWOBJLoader>`__
   -  `IFC.js <https://github.com/IFCjs/web-ifc-three>`__

   Geometry
   ~~~~~~~~

   -  `THREE.MeshLine <https://github.com/spite/THREE.MeshLine>`__

   3D Text and Layout
   ~~~~~~~~~~~~~~~~~~

   -  `troika-three-text <https://github.com/protectwise/troika/tree/master/packages/troika-three-text>`__
   -  `three-mesh-ui <https://github.com/felixmariotto/three-mesh-ui>`__

   Particle Systems
   ~~~~~~~~~~~~~~~~

   -  `three.quarks <https://github.com/Alchemist0823/three.quarks>`__
   -  `three-nebula <https://github.com/creativelifeform/three-nebula>`__

   Inverse Kinematics
   ~~~~~~~~~~~~~~~~~~

   -  `THREE.IK <https://github.com/jsantell/THREE.IK>`__
   -  `fullik <https://github.com/lo-th/fullik>`__
   -  `closed-chain-ik <https://github.com/gkjohnson/closed-chain-ik-js>`__

   Game AI
   ~~~~~~~

   -  `yuka <https://mugen87.github.io/yuka/>`__
   -  `three-pathfinding <https://github.com/donmccurdy/three-pathfinding>`__
   -  `recast-navigation-js <https://github.com/isaac-mason/recast-navigation-js>`__

   Wrappers and Frameworks
   ~~~~~~~~~~~~~~~~~~~~~~~

   -  `A-Frame <https://aframe.io/>`__
   -  `Lume <https://lume.io/>`__ - HTML elements for 3D graphics built on Three.
   -  `react-three-fiber <https://github.com/pmndrs/react-three-fiber>`__ - React components
      for 3D graphics built on Three.
   -  `threepipe <https://threepipe.org/>`__ - A versatile 3D viewer framework using
      three.js for rendering.
   -  `ECSY <https://github.com/ecsyjs/ecsy-three>`__
   -  `Threlte <https://threlte.xyz/>`__ - Svelte components for 3D graphics built on Three.
   -  `Needle Engine <https://needle.tools/>`__
   -  `tresjs <https://tresjs.org/>`__ - Vue components for 3D graphics built on Three.


.. _D008:

FAQ
===

   https://threejs.org/docs/manual/en/introduction/FAQ.html

   Which 3D model format is best supported?
   ----------------------------------------


      The recommended format for importing and exporting assets is glTF (GL Transmission
      Format). Because glTF is focused on runtime asset delivery, it is compact to transmit
      and fast to load.

      three.js provides loaders for many other popular formats like FBX, Collada or OBJ as
      well. Nevertheless, you should always try to establish a glTF based workflow in your
      projects first. For more information, see `loading 3D models <#manual/introduction/Loading-3D-models>`__.


   Why are there meta viewport tags in examples?
   ---------------------------------------------


      .. code:: javascript

         <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

      These tags control viewport size and scale for mobile browsers (where page content may
      be rendered at different size than visible viewport).

      `Safari: Using the Viewport <https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html>`__

      `MDN: Using the viewport meta tag <https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag>`__

   How can scene scale be preserved on resize?
   -------------------------------------------

   We want all objects, regardless of their distance from the camera, to appear the same
   size, even as the window is resized. The key equation to solving this is this formula for
   the visible height at a given distance:

   .. code:: javascript

      visible_height = 2 * Math.tan( ( Math.PI / 180 ) * camera.fov / 2 ) * distance_from_camera;
      
   If we increase the window height by a certain percentage, then what we want is the visible
   height at all distances to increase by the same percentage. This can not be done by
   changing the camera position. Instead you have to change the camera field-of-view.
   `Example <http://jsfiddle.net/Q4Jpu/>`__.

   Why is part of my object invisible?
   -----------------------------------

   This could be because of face culling. Faces have an orientation that decides which side
   is which. And the culling removes the backside in normal circumstances. To see if this is
   your problem, change the material side to THREE.DoubleSide.

   .. code:: javascript

      material.side = THREE.DoubleSide


   Why does three.js sometimes return strange results for invalid inputs?
   ----------------------------------------------------------------------

   For performance reasons, three.js doesn't validate inputs in most cases. It's your app's
   responsibility to make sure that all inputs are valid.

   Can I use three.js in Node.js?
   ------------------------------

   Because three.js is built for the web, it depends on browser and DOM APIs that don't
   always exist in Node.js. Some of these issues can be avoided by using shims like
   `headless-gl <https://github.com/stackgl/headless-gl>`__ and
   `jsdom-global <https://github.com/rstacruz/jsdom-global>`__, or by replacing components
   like ``TextureLoader`` with custom alternatives. Other DOM APIs may be deeply
   intertwined with the code that uses them, and will be harder to work around. We welcome
   simple and maintainable pull requests to improve Node.js support, but recommend opening an
   issue to discuss your improvements first.


.. _D009:

Useful links
============

   https://threejs.org/docs/manual/en/introduction/Useful-links.html

   The following is a collection of links that you might find useful when learning three.js.
   If you find something that you'd like to add here, or think that one of the links below
   is no longer relevant or working, feel free to click the 'edit' button in the bottom
   right and make some changes!

   Note also that as three.js is under rapid development, a lot of these links will contain
   information that is out of date - if something isn't working as you'd expect or as one
   of these links says it should, check the browser console for warnings or errors. Also
   check the relevant docs pages.

   Help forums
   -----------

   Three.js officially uses the `forum <https://discourse.threejs.org/>`__ and
   `Stack Overflow <http://stackoverflow.com/tags/three.js/info>`__ for help requests. If
   you need assistance with something, that's the place to go. Do NOT open an issue on Github
   for help requests.

   Tutorials and courses
   ---------------------

   Getting started with three.js
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `Three.js Fundamentals starting lesson <https://threejs.org/manual/#en/fundamentals>`__
   -  `Beginning with 3D WebGL <https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene>`__ 
      by `Rachel Smith <https://codepen.io/rachsmith/>`__.
   -  `Animating scenes with WebGL and three.js <https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/>`__

   More extensive / advanced articles and courses
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `Three Journey <https://threejs-journey.com/>`__ Course by
      `Bruno Simon <https://bruno-simon.com/>`__ - Teaches beginners how to use Three.js
      step by step
   -  `Discover three.js <https://discoverthreejs.com/>`__
   -  `Collection of tutorials <http://blog.cjgammon.com/>`__ by
      `CJ Gammon <http://www.cjgammon.com/>`__.
   -  `Glossy spheres in three.js <https://medium.com/soffritti.pierfrancesco/glossy-spheres-in-three-js-bfd2785d4857>`__.
   -  `Interactive 3D Graphics <https://www.udacity.com/course/interactive-3d-graphics--cs291>`__ - 
      a free course on Udacity that teaches the fundamentals of 3D Graphics, and
      uses three.js as its coding tool.
   -  `Aerotwist <https://aerotwist.com/tutorials/>`__ tutorials by
      `Paul Lewis <https://github.com/paullewis/>`__.
   -  `Three.js Bookshelf <https://discourse.threejs.org/t/three-js-bookshelf/2468>`__ -
      Looking for more resources about three.js or computer graphics in general? Check out
      the selection of literature recommended by the community.

   News and Updates
   ----------------

   -  `Three.js on Twitter <https://twitter.com/hashtag/threejs>`__
   -  `Three.js on reddit <http://www.reddit.com/r/threejs/>`__
   -  `WebGL on reddit <http://www.reddit.com/r/webgl/>`__

   **Examples**

   -  `three-seed <https://github.com/edwinwebb/three-seed/>`__ - three.js starter project
      with ES6 and Webpack
   -  `Professor Stemkoskis Examples <http://stemkoski.github.io/Three.js/index.html>`__ - a
      collection of beginner friendly examples built using three.js r60.
   -  `Official three.js examples <https://threejs.org/examples/>`__ - these examples are
      maintained as part of the three.js repository, and always use the latest version of
      three.js.
   -  `Official three.js dev branch examples <https://raw.githack.com/mrdoob/three.js/dev/examples/>`__ - 
      Same as the above, except these use the dev branch of three.js, and
      are used to check that everything is working as three.js being is developed.

   Tools
   -----

   -  `physgl.org <https://github.com/tbensky/physgl>`__ - JavaScript front-end with
      wrappers to three.js, to bring WebGL graphics to students learning physics and math.
   -  `Whitestorm.js <https://whsjs.readme.io/>`__ – Modular three.js framework with
      AmmoNext physics plugin.
   -  `Three.js Inspector <http://zz85.github.io/zz85-bookmarklets/threelabs.html>`__
   -  `ThreeNodes.js <http://idflood.github.io/ThreeNodes.js/>`__.
   -  `vscode shader <https://marketplace.visualstudio.com/items?itemName=slevesque.shader>`__ - 
      Syntax highlighter for shader language.
      `vscode comment-tagged-templates <https://marketplace.visualstudio.com/items?itemName=bierner.comment-tagged-templates>`__ - 
      Syntax highlighting for tagged template strings
      using comments to shader language, like: glsl.js.
   -  `WebXR-emulator-extension <https://github.com/MozillaReality/WebXR-emulator-extension>`__

   WebGL References
   ----------------

   -  `webgl-reference-card.pdf <https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf>`__ - 
      Reference of all WebGL and GLSL keywords, terminology, syntax and definitions.

   Old Links
   ---------

   These links are kept for historical purposes - you may still find them useful, but be
   warned that they may have information relating to very old versions of three.js.

   -  `AlterQualia at WebGL Camp 3 <https://www.youtube.com/watch?v=Dir4KO9RdhM>`__
   -  `Yomotsus Examples <http://yomotsu.github.io/threejs-examples/>`__ - 
      a collection of examples using three.js r45.
   -  `Introduction to Three.js <http://fhtr.org/BasicsOfThreeJS/#1>`__ 
      by `Ilmari Heikkinen <http://github.com/kig/>`__ (slideshow).
   -  `WebGL and Three.js <http://www.slideshare.net/yomotsu/webgl-and-threejs>`__ 
      by `Akihiro Oyamada <http://github.com/yomotsu>`__ (slideshow).
   -  `Trigger Rally <https://www.youtube.com/watch?v=VdQnOaolrPA>`__ 
      by `jareiko <https://github.com/jareiko>`__ (video).
   -  `ThreeFab <http://blackjk3.github.io/threefab/>`__ - 
      scene editor, maintained up until around three.js r50.
   -  `Max to Three.js workflow tips and tricks <http://bkcore.com/blog/3d/webgl-three-js-workflow-tips.html>`__ 
      by `BKcore <https://github.com/BKcore>`__
   -  `A whirlwind look at Three.js <http://12devsofxmas.co.uk/2012/01/webgl-and-three-js/>`__ 
      by `Paul King <http://github.com/nrocy>`__
   -  `Animated selective glow in Three.js <http://bkcore.com/blog/3d/webgl-three-js-animated-selective-glow.html>`__ 
      by `BKcore <https://github.com/BKcore>`__
   -  `Building A Physics Simulation Environment <http://www.natural-science.or.jp/article/20120220155529.php>`__ - three.js tutorial in Japanese


.. _D010:

Updating resources
==================

   https://threejs.org/docs/manual/en/introduction/How-to-update-things.html


      All objects by default automatically update their matrices if they have been added to
      the scene with


      .. code:: javascript

         const object = new THREE.Object3D();
         scene.add( object );
                  
      
      or if they are the child of another object that has been added to the scene:

      .. code:: javascript

         const object1 = new THREE.Object3D();
         const object2 = new THREE.Object3D();
         object1.add( object2 );
         scene.add( object1 );
         //object1 and object2 will automatically update their matrices


   However, if you know the object will be static, you can disable this and update the
   transform matrix manually just when needed.


   .. code:: javascript

      object.matrixAutoUpdate = false;
      object.updateMatrix();


   BufferGeometry

      BufferGeometries store information (such as vertex positions, face indices, normals,
      colors, UVs, and any custom attributes) in `buffers <#BufferAttribute>`__ - that is,
      `typed arrays <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays>`__. 
      This makes them generally faster than standard Geometries, at the cost of
      being somewhat harder to work with.

      With regards to updating BufferGeometries, the most important thing to understand is
      that you cannot resize buffers (this is very costly, basically the equivalent to
      creating a new geometry). You can however update the content of buffers.

      This means that if you know an attribute of your BufferGeometry will grow, say the
      number of vertices, you must pre-allocate a buffer large enough to hold any new
      vertices that may be created. Of course, this also means that there will be a maximum
      size for your BufferGeometry - there is no way to create a BufferGeometry that can
      efficiently be extended indefinitely.

      We'll use the example of a line that gets extended at render time. We'll allocate space
      in the buffer for 500 vertices but draw only two at first, using
      ``BufferGeometry.drawRange``.


      .. code:: javascript

         const MAX_POINTS = 500;
         // geometry const geometry = new THREE.BufferGeometry();
         // attributes const positions = new Float32Array( MAX_POINTS * 3 );
         // 3 vertices per point geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
         // draw range const drawCount = 2;
         // draw the first 2 points, only geometry.setDrawRange( 0, drawCount );
         // material const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
         // line const line = new THREE.Line( geometry, material );
         scene.add( line );
         
      Next we'll randomly add points to the line using a pattern like:


      .. code:: javascript

         const positionAttribute = line.geometry.getAttribute( 'position' );
         let x = 0, y = 0, z = 0;
         for ( let i = 0;
            i < positionAttribute.count;
            i ++ ) { positionAttribute.setXYZ( i, x, y, z );
            x += ( Math.random() - 0.5 ) * 30;
            y += ( Math.random() - 0.5 ) * 30;
            z += ( Math.random() - 0.5 ) * 30;
         }

      If you want to change the *number of points* rendered after the first render, do this:


      .. code:: javascript

         line.geometry.setDrawRange( 0, newValue );
         
      If you want to change the position data values after the first render, you need to set
      the needsUpdate flag like so:


      .. code:: javascript

         positionAttribute.needsUpdate = true;
         // required after the first render

      If you change the position data values after the initial render, you may need to
      recompute bounding volumes so other features of the engine like view frustum culling or
      helpers properly work.


      .. code:: javascript

         line.geometry.computeBoundingBox();
         line.geometry.computeBoundingSphere();
         
      `Here is a fiddle <https://jsfiddle.net/t4m85pLr/1/>`__ showing an animated line which
      you can adapt to your use case.

      **Examples**

      [example:webgl_custom_attributes WebGL / custom / attributes]
      [example:webgl_buffergeometry_custom_attributes_particles WebGL / buffergeometry / custom / attributes / particles]

   Materials
   ---------


      All uniforms values can be changed freely (e.g. colors, textures, opacity, etc), values
      are sent to the shader every frame.

      Also GLstate related parameters can change any time (depthTest, blending,
      polygonOffset, etc).

      The following properties can't be easily changed at runtime (once the material is
      rendered at least once):

      -  numbers and types of uniforms
      -  presence or not of

         -  texture
         -  fog
         -  vertex colors
         -  morphing
         -  shadow map
         -  alpha test
         -  transparent

      Changes in these require building of new shader program. You'll need to set


      .. code:: javascript

         material.needsUpdate = true

      Bear in mind this might be quite slow and induce jerkiness in framerate (especially on
      Windows, as shader compilation is slower in DirectX than OpenGL).

      For smoother experience you can emulate changes in these features to some degree by
      having "dummy" values like zero intensity lights, white textures, or zero density fog.

      You can freely change the material used for geometry chunks, however you cannot change
      how an object is divided into chunks (according to face materials).

      If you need to have different configurations of materials during runtime:

      *  If the number of materials / chunks is small, you could pre-divide the object
         beforehand (e.g. hair / face / body / upper clothes / trousers for a human, front /
         sides / top / glass / tire / interior for a car).

      *  If the number is large (e.g. each face could be potentially different), consider a
         different solution, such as using attributes / textures to drive different per-face
         look.

      **Examples**

      [example:webgl_materials_car WebGL / materials / car]
      [example:webgl_postprocessing_dof WebGL / webgl_postprocessing / dof]

   Textures
   --------


      Image, canvas, video and data textures need to have the following flag set if they are
      changed:


      .. code:: javascript

         texture.needsUpdate = true;
         
      Render targets update automatically.

      **Examples**

      [example:webgl_materials_video WebGL / materials / video]
      [example:webgl_rtt WebGL / rtt]

   Cameras
   -------


      A camera's position and target is updated automatically. If you need to change

      -  fov
      -  aspect
      -  near
      -  far

      then you'll need to recompute the projection matrix:


      .. code:: javascript

         camera.aspect = window.innerWidth / window.innerHeight;
         camera.updateProjectionMatrix();
         

   InstancedMesh
   -------------


      ``InstancedMesh`` is a class for conveniently access instanced rendering in
      ``three.js``. Certain library features like view frustum culling or ray casting rely on
      up-to-date bounding volumes (bounding sphere and bounding box). Because of the way how
      ``InstancedMesh`` works, the class has its own `boundingBox <#InstancedMesh.boundingBox>`__ and `boundingSphere <#InstancedMesh.boundingSphere>`__ properties that
      supersede the bounding volumes on geometry level.

      Similar to geometries you have to recompute the bounding box and sphere whenever you
      change the underlying data. In context of ``InstancedMesh``, that happens when you
      transform instances via `setMatrixAt <#InstancedMesh.setMatrixAt>`__(). You can use the
      same pattern like with geometries.


      .. code:: javascript

         instancedMesh.computeBoundingBox();
         instancedMesh.computeBoundingSphere();
         

   SkinnedMesh
   -----------


      ``SkinnedMesh`` follows the same principles like ``InstancedMesh`` in context of
      bounding volumes. Meaning the class has its own version of
      `boundingBox <#SkinnedMesh.boundingBox>`__ and `boundingSphere <#SkinnedMesh.boundingSphere>`__ to correctly enclose animated meshes. When calling
      ``computeBoundingBox()`` and ``computeBoundingSphere()``, the class computes the
      respective bounding volumes based on the current bone tranformation (or in other words
      the current animation state).


.. _D011:

Disposing resources
===================

   https://threejs.org/docs/manual/en/introduction/How-to-dispose-of-objects.html

   One important aspect in order to improve performance and avoid memory leaks in your
   application is the disposal of unused library entities. Whenever you create an instance of
   a three.js type, you allocate a certain amount of memory. However, three.js
   creates for specific objects like geometries or materials WebGL related entities like
   buffers or shader programs which are necessary for rendering. It's important to highlight
   that these objects are not released automatically. Instead, the application has to use a
   special API in order to free such resources. This guide provides a brief overview about
   how this API is used and what objects are relevant in this context.

   Geometries
   ----------

   A geometry usually represents vertex information defined as a collection of attributes.
   three.js internally creates an object of type
   `WebGLBuffer <https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer>`__ for each
   attribute. These entities are only deleted if you call ``BufferGeometry.dispose``(). If
   a geometry becomes obsolete in your application, execute the method to free all related
   resources.

   Materials
   ---------

   A material defines how objects are rendered. three.js uses the information of a
   material definition in order to construct a shader program for rendering. Shader programs
   can only be deleted if the respective material is disposed. For performance reasons,
   three.js tries to reuse existing shader programs if possible. So a shader program is
   only deleted if all related materials are disposed. You can indicate the disposal of a
   material by executing ``Material.dispose``().

   Textures
   --------

   The disposal of a material has no effect on textures. They are handled separately since a
   single texture can be used by multiple materials at the same time. Whenever you create an
   instance of ``Texture``, three.js internally creates an instance of
   `WebGLTexture <https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture>`__. Similar
   to buffers, this object can only be deleted by calling ``Texture.dispose``().

   If you use an ``ImageBitmap`` as the texture's data source, you have to call
   `ImageBitmap.close <https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap/close>`__() 
   at the application level to dispose of all CPU-side resources. An
   automated call of ``ImageBitmap.close()`` in ``Texture.dispose``() is not possible,
   since the image bitmap becomes unusable, and the engine has no way of knowing if the image
   bitmap is used elsewhere.

   Render Targets
   Objects of type ``WebGLRenderTarget`` not only allocate an instance of
   `WebGLTexture <https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture>`__ but also
   `WebGLFramebuffer <https://developer.mozilla.org/en-US/docs/Web/API/WebGLFramebuffer>`__s
   and `WebGLRenderbuffer <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderbuffer>`__s 
   for realizing custom rendering destinations. These objects are only
   deallocated by executing ``WebGLRenderTarget.dispose``().

   Miscellaneous
   -------------

   There are other classes from the examples directory like controls or post processing
   passes which provide ``dispose()`` methods in order to remove internal event listeners or
   render targets. In general, it's recommended to check the API or documentation of a class
   and watch for ``dispose()``. If present, you should use it when cleaning things up.

   FAQ
   ---

   Why can't three.js dispose objects automatically?
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This question was asked many times by the community so it's important to clarify this
   matter. Fact is that three.js does not know the lifetime or scope of user-created
   entities like geometries or materials. This is the responsibility of the application. For
   example even if a material is currently not used for rendering, it might be necessary for
   the next frame. So if the application decides that a certain object can be deleted, it has
   to notify the engine via calling the respective ``dispose()`` method.

   Does removing a mesh from the scene also dispose its geometry and material?
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   No, you have to explicitly dispose the geometry and material via ``dispose()``. Keep in
   mind that geometries and materials can be shared among 3D objects like meshes.

   Does three.js provide information about the amount of cached objects?
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Yes. It's possible to evaluate ``WebGLRenderer.info``, a special property of the
   renderer with a series of statistical information about the graphics board memory and the
   rendering process. Among other things, it tells you how many textures, geometries and
   shader programs are internally stored. If you notice performance problems in your
   application, it's a good idea to debug this property in order to easily identify a memory
   leak.

   What happens when you call ``dispose()`` on a texture but the image is not loaded yet?
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Internal resources for a texture are only allocated if the image has fully loaded. If you
   dispose a texture before the image was loaded, nothing happens. No resources were
   allocated so there is also no need for clean up.

   What happens when I call ``dispose()`` and then use the respective object at a later point?
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   That depends. For geometries, materials, textures, render targets and post processing
   passes the deleted internal resources can be created again by the engine. So no runtime
   error will occur but you might notice a negative performance impact for the current frame,
   especially when shader programs have to be compiled. Controls and renderers are an
   exception. Instances of these classes can not be used after ``dispose()`` has been called.
   You have to create new instances in this case.

   How should I manage three.js objects in my app? When do I know how to dispose things?
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In general, there is no definite recommendation for this. It highly depends on the
   specific use case when calling ``dispose()`` is appropriate. It's important to highlight
   that it's not always necessary to dispose objects all the time. A good example for this is
   a game which consists of multiple levels. A good place for object disposal is when
   switching the level. The app could traverse through the old scene and dispose all obsolete
   materials, geometries and textures. As mentioned in the previous section, it does not
   produce a runtime error if you dispose an object that is actually still in use. The worst
   thing that can happen is performance drop for a single frame.

   Examples that demonstrate the usage of dispose()
   ------------------------------------------------

   [example:webgl_test_memory WebGL / test / memory]
   [example:webgl_test_memory2 WebGL / test / memory2]


.. _D012:

Creating VR content
===================

   https://threejs.org/docs/manual/en/introduction/How-to-create-VR-content.html

   This guide provides a brief overview of the basic components of a web-based VR application
   made with three.js.

   Workflow
   --------

   First, you have to include `VRButton.js <https://github.com/mrdoob/three.js/blob/master/examples/jsm/webxr/VRButton.js>`__ 
   into your project.


   .. code:: javascript

      import { VRButton } from 'three/addons/webxr/VRButton.js';


   ``VRButton.createButton()`` does two important things: It creates a button which indicates
   VR compatibility. Besides, it initiates a VR session if the user activates the button. The
   only thing you have to do is to add the following line of code to your app.


   .. code:: javascript

      document.body.appendChild( VRButton.createButton( renderer ) );


   Next, you have to tell your instance of ``WebGLRenderer`` to enable XR rendering.


   .. code:: javascript

      renderer.xr.enabled = true;


   Finally, you have to adjust your animation loop since we can't use our well known
   ``window.requestAnimationFrame()`` function. For VR projects we use
   `setAnimationLoop <#WebGLRenderer.setAnimationLoop>`__. The minimal code looks like this:


   .. code:: javascript

      renderer.setAnimationLoop( function () { renderer.render( scene, camera );
      } );


   Next Steps
   ----------

   Have a look at one of the official WebVR examples to see this workflow in action.

   [example:webxr_vr_ballshooter WebXR / VR / ballshooter]
   [example:webxr_vr_cubes WebXR / VR / cubes]
   [example:webxr_vr_dragging WebXR / VR / dragging]
   [example:webxr_vr_paint WebXR / VR / paint]
   [example:webxr_vr_panorama_depth WebXR / VR / panorama_depth]
   [example:webxr_vr_panorama WebXR / VR / panorama]
   [example:webxr_vr_rollercoaster WebXR / VR / rollercoaster]
   [example:webxr_vr_sandbox WebXR / VR / sandbox]
   [example:webxr_vr_sculpt WebXR / VR / sculpt]
   [example:webxr_vr_video WebXR / VR / video]


.. _D013:

How to use post-processing
==========================

   https://threejs.org/docs/manual/en/introduction/How-to-use-post-processing.html

   Many three.js applications render their 3D objects directly to the screen. Sometimes,
   however, you want to apply one or more graphical effects like Depth-Of-Field, Bloom, Film
   Grain or various types of Anti-aliasing. Post-processing is a widely used approach to
   implement such effects. First, the scene is rendered to a render target which represents a
   buffer in the video card's memory. In the next step one or more post-processing passes
   apply filters and effects to the image buffer before it is eventually rendered to the
   screen.

   three.js provides a complete post-processing solution via ``EffectComposer`` to
   implement such a workflow.

   Workflow
   --------

   The first step in the process is to import all necessary files from the examples
   directory. The guide assumes you are using the official
   `npm package <https://www.npmjs.com/package/three>`__ of three.js. For our basic demo in
   this guide we need the following files.


   .. code:: javascript

      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
      import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
      import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';


   After all files are successfully imported, we can create our composer by passing in an
   instance of ``WebGLRenderer``.


   .. code:: javascript

      const composer = new EffectComposer( renderer );


   When using a composer, it's necessary to change the application's animation loop. Instead
   of calling the render method of ``WebGLRenderer``, we now use the respective
   counterpart of ``EffectComposer``.


   .. code:: javascript

      function animate() { 
         requestAnimationFrame( animate );
         composer.render();
      }


   Our composer is now ready so it's possible to configure the chain of post-processing
   passes. These passes are responsible for creating the final visual output of the
   application. They are processed in order of their addition/insertion. In our example, the
   instance of ``RenderPass`` is executed first, then the instance of ``GlitchPass`` and
   finally ``OutputPass``. The last enabled pass in the chain is automatically rendered to
   the screen. The setup of the passes looks like so:


   .. code:: javascript

      const renderPass = new RenderPass( scene, camera );
      composer.addPass( renderPass );
      const glitchPass = new GlitchPass();
      composer.addPass( glitchPass );
      const outputPass = new OutputPass();
      composer.addPass( outputPass );


   ``RenderPass`` is normally placed at the beginning of the chain in order to provide the
   rendered scene as an input for the next post-processing step. In our case, ``GlitchPass``
   is going to use these image data to apply a wild glitch effect. ``OutputPass`` is usually
   the last pass in the chain which performs sRGB color space conversion and tone mapping.
   Check out this `live example <https://threejs.org/examples/webgl_postprocessing_glitch>`__ 
   to see it in action.

   Built-in Passes
   ---------------

   You can use a wide range of pre-defined post-processing passes provided by the engine.
   They are located in the `postprocessing <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing>`__ 
   directory.

   Custom Passes
   -------------

   Sometimes you want to write a custom post-processing shader and include it into the chain
   of post-processing passes. For this scenario, you can utilize ``ShaderPass``. After
   importing the file and your custom shader, you can use the following code to setup the
   pass.


   .. code:: javascript

      import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
      import { LuminosityShader } from 'three/addons/shaders/LuminosityShader.js';
      // later in your init routine 
      const luminosityPass = new ShaderPass( LuminosityShader );
      composer.addPass( luminosityPass );


   The repository provides a file called `CopyShader <https://github.com/mrdoob/three.js/blob/master/examples/jsm/shaders/CopyShader.js>`__ 
   which is a good starting code for your own custom shader. ``CopyShader`` just
   copies the image contents of the ``EffectComposer``'s read buffer to its write buffer
   without applying any effects.


.. _D014:

Matrix transformations
======================

   https://threejs.org/docs/manual/en/introduction/Matrix-transformations.html

   Three.js uses ``matrices`` to encode 3D transformations---translations (position),
   rotations, and scaling. Every instance of ``Object3D`` has a `matrix <#Object3D.matrix>`__ which stores that object's position, rotation, and scale. This page describes how
   to update an object's transformation.

   Convenience properties and ``matrixAutoUpdate``
   -----------------------------------------------

   There are two ways to update an object's transformation:

   #. Modify the object's ``position``, ``quaternion``, and ``scale`` properties, and let
      three.js recompute the object's matrix from these properties:

      .. code:: javascript

         object.position.copy( start_position );
         object.quaternion.copy( quaternion );
                  
      By default, the ``matrixAutoUpdate`` property is set true, and the matrix will be
      automatically recalculated. If the object is static, or you wish to manually control
      when recalculation occurs, better performance can be obtained by setting the property
      false: ``object.matrixAutoUpdate = false;
      ` And after changing any properties, manually
      update the matrix: ``object.updateMatrix();
      `
   #. Modify the object's matrix directly. The ``Matrix4`` class has various methods for
      modifying the matrix:

      .. code:: javascript

         object.matrix.setRotationFromQuaternion( quaternion );
         object.matrix.setPosition( start_position );
         object.matrixAutoUpdate = false;
         
      Note that ``matrixAutoUpdate`` *must* be set to ``false`` in this case, and you should
      make sure *not* to call ``updateMatrix``. Calling ``updateMatrix`` will clobber the
      manual changes made to the matrix, recalculating the matrix from ``position``,
      ``scale``, and so on.

   Object and world matrices
   -------------------------

   An object's `matrix <#Object3D.matrix>`__ stores the object's transformation *relative* to
   the object's `parent <#Object3D.parent>`__; to get the object's transformation in *world*
   coordinates, you must access the object's ``Object3D.matrixWorld``.

   When either the parent or the child object's transformation changes, you can request that
   the child object's `matrixWorld <#Object3D.matrixWorld>`__ be updated by calling
   `updateMatrixWorld <#Object3D.updateMatrixWorld>`__().

   An object can be transformed via ``Object3D.applyMatrix4``. Note: Under-the-hood, this
   method relies on ``Matrix4.decompose``, and not all matrices are decomposable in this
   way. For example, if an object has a non-uniformly scaled parent, then the object's world
   matrix may not be decomposable, and this method may not be appropriate.

   Rotation and Quaternion
   -----------------------

   Three.js provides two ways of representing 3D rotations: `Euler angles <#Euler>`__ and
   `Quaternions <#Quaternion>`__, as well as methods for converting between the two. Euler
   angles are subject to a problem called "gimbal lock," where certain configurations can
   lose a degree of freedom (preventing the object from being rotated about one axis). For
   this reason, object rotations are *always* stored in the object's
   `quaternion <#Object3D.quaternion>`__.

   Previous versions of the library included a ``useQuaternion`` property which, when set to
   false, would cause the object's `matrix <#Object3D.matrix>`__ to be calculated from an
   Euler angle. This practice is deprecated---instead, you should use the
   `setRotationFromEuler <#Object3D.setRotationFromEuler>`__ method, which will update the
   quaternion.


.. _D015:

Animation system
================

   https://threejs.org/docs/manual/en/introduction/Animation-system.html

   Overview
   --------

   Within the three.js animation system you can animate various properties of your models:
   the bones of a `skinned and rigged model <#SkinnedMesh>`__, morph targets, different
   material properties (colors, opacity, booleans), visibility and transforms. The animated
   properties can be faded in, faded out, crossfaded and warped. The weight and time scales
   of different simultaneous animations on the same object as well as on different objects
   can be changed independently. Various animations on the same and on different objects
   can be synchronized.

   To achieve all this in one homogeneous system, the three.js animation system
   `has completely changed in 2015 <https://github.com/mrdoob/three.js/issues/6881>`__
   (beware of outdated information!), and it has now an architecture similar to
   Unity/Unreal Engine 4. This page gives a short overview of the main components of the
   system and how they work together.

   Animation Clips
   ~~~~~~~~~~~~~~~

   If you have successfully imported an animated 3D object (it doesn't matter if it has
   bones or morph targets or both) — for example exporting it from Blender with the
   `glTF Blender exporter <https://github.com/KhronosGroup/glTF-Blender-IO>`__ and loading
   it into a three.js scene using ``GLTFLoader`` — one of the response fields should be
   an array named "animations", containing the `AnimationClips <#AnimationClip>`__ for this
   model (see a list of possible loaders below).

   Each ``AnimationClip`` usually holds the data for a certain activity of the object. If
   the mesh is a character, for example, there may be one AnimationClip for a walkcycle, a
   second for a jump, a third for sidestepping and so on.

   Keyframe Tracks
   ~~~~~~~~~~~~~~~

   Inside of such an ``AnimationClip`` the data for each animated property are stored in a
   separate ``KeyframeTrack``. Assuming a character object has a `skeleton <#Skeleton>`__, one keyframe track could store the data for the position changes of the lower
   arm bone over time, a different track the data for the rotation changes of the same
   bone, a third the track position, rotation or scaling of another bone, and so on. It
   should be clear, that an AnimationClip can be composed of lots of such tracks.

   Assuming the model has morph targets (for example one morph target showing a friendly
   face and another showing an angry face), each track holds the information as to how the
   `influence <#Mesh.morphTargetInfluences>`__ of a certain morph target changes during the
   performance of the clip.

   Animation Mixer
   ~~~~~~~~~~~~~~~

   The stored data forms only the basis for the animations - actual playback is controlled by
   the ``AnimationMixer``. You can imagine this not only as a player for animations, but
   as a simulation of a hardware like a real mixer console, which can control several
   animations simultaneously, blending and merging them.

   Animation Actions
   ~~~~~~~~~~~~~~~~~

   The ``AnimationMixer`` itself has only very few (general) properties and methods, because
   it can be controlled by the `AnimationActions <#AnimationAction>`__. By configuring an
   ``AnimationAction`` you can determine when a certain ``AnimationClip`` shall be played,
   paused or stopped on one of the mixers, if and how often the clip has to be repeated,
   whether it shall be performed with a fade or a time scaling, and some additional things,
   such crossfading or synchronizing.

   Animation Object Groups
   ~~~~~~~~~~~~~~~~~~~~~~~

   If you want a group of objects to receive a shared animation state, you can use an
   ``AnimationObjectGroup``.

   Supported Formats and Loaders
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Note that not all model formats include animation (OBJ notably does not), and that only
   some three.js loaders support `AnimationClip <#AnimationClip>`__ sequences. Several that
   *do* support this animation type:

   -  `THREE.ObjectLoader <#ObjectLoader>`__
   -  THREE.BVHLoader
   -  THREE.ColladaLoader
   -  THREE.FBXLoader
   -  `THREE.GLTFLoader <#GLTFLoader>`__
   -  THREE.MMDLoader

   Note that 3ds max and Maya currently can't export multiple animations (meaning animations
   which are not on the same timeline) directly to a single file.

   Example
   -------


   .. code:: javascript

      let mesh;
      // Create an AnimationMixer, and get the list of AnimationClip instances 
      const mixer = new THREE.AnimationMixer( mesh );
      const clips = mesh.animations;

      // Update the mixer on each frame 
      function update () { 
         mixer.update( deltaSeconds );
      } 

      // Play a specific animation 
      const clip = THREE.AnimationClip.findByName( clips, 'dance' );
      const action = mixer.clipAction( clip );
      action.play();

      // Play all animations 
      clips.forEach( function ( clip ) { mixer.clipAction( clip ).play(); } );



.. _D016:

Color management
================

   https://threejs.org/docs/manual/en/introduction/Color-management.html

   What is a color space?
   ----------------------

   Every color space is a collection of several design decisions, chosen together to support
   a large range of colors while satisfying technical constraints related to precision and
   display technologies. When creating a 3D asset, or assembling 3D assets together into a
   scene, it is important to know what these properties are, and how the properties of one
   color space relate to other color spaces in the scene.

   .. figure:: https://threejs.org/resources/srgb_gamut.png

      sRGB colors and white point (D65) displayed in the reference CIE 1931 chromaticity
      diagram. Colored region represents a 2D projection of the sRGB gamut, which is a 3D
      volume. Source: `Wikipedia <https://en.wikipedia.org/wiki/SRGB>`__

   -  **Color primaries:** Primary colors (e.g. red, green, blue) are not absolutes; they are
      selected from the visible spectrum based on constraints of limited precision and
      capabilities of available display devices. Colors are expressed as a ratio of the
      primary colors.
   -  **White point:** Most color spaces are engineered such that an equally weighted sum of
      primaries *R = G = B* will appear to be without color, or "achromatic". The appearance
      of achromatic values (like white or grey) depend on human perception, which in turn
      depends heavily on the context of the observer. A color space specifies its "white
      point" to balance these needs. The white point defined by the sRGB color space is
      `D65 <https://en.wikipedia.org/wiki/Illuminant_D65>`__.
   -  **Transfer functions:** After choosing the color gamut and a color model, we still need
      to define mappings ("transfer functions") of numerical values to/from the color space.
      Does *r = 0.5* represent 50% less physical illumination than *r = 1.0*? Or 50% less
      bright, as perceived by an average human eye? These are different things, and that
      difference can be represented as a mathematical function. Transfer functions may be
      *linear* or *nonlinear*, depending on the objectives of the color space. sRGB defines
      nonlinear transfer functions. Those functions are sometimes approximated as *gamma
      functions*, but the term "gamma" is ambiguous and should be avoided in this context.

   These three parameters — color primaries, white point, and transfer functions — define a
   color space, with each chosen for particular goals. Having defined the parameters, a few
   additional terms are helpful:

   -  **Color model:** Syntax for numerically identifying colors within chosen the color
      gamut — a coordinate system for colors. In three.js we're mainly concerned with the RGB
      color model, having three coordinates *r, g, b ∈ [0,1]* ("closed domain") or *r, g, b ∈
      [0,∞]* ("open domain") each representing a fraction of a primary color. Other color
      models (HSL, Lab, LCH) are commonly used for artistic control.
   -  **Color gamut:** Once color primaries and a white point have been chosen, these
      represent a volume within the visible spectrum (a "gamut"). Colors not within this
      volume ("out of gamut") cannot be expressed by closed domain [0,1] RGB values. In the
      open domain [0,∞], the gamut is technically infinite.

   Consider two very common color spaces: ``SRGBColorSpace`` ("sRGB") and
   ``LinearSRGBColorSpace`` ("Linear-sRGB"). Both use the same primaries and white point,
   and therefore have the same color gamut. Both use the RGB color model. They differ only in
   the transfer functions — Linear-sRGB is linear with respect to physical light intensity.
   sRGB uses the nonlinear sRGB transfer functions, and more closely resembles the way that
   the human eye perceives light and the responsiveness of common display devices.

   That difference is important. Lighting calculations and other rendering operations must
   generally occur in a linear color space. However, a linear colors are less efficient to
   store in an image or framebuffer, and do not look correct when viewed by a human observer.
   As a result, input textures and the final rendered image will generally use the nonlinear
   sRGB color space.

   .. Notice::

      ℹ️ **NOTICE:** *While some modern displays support wider gamuts like Display-P3, the
      web platform's graphics APIs largely rely on sRGB. Applications using three.js today
      will typically use only the sRGB and Linear-sRGB color spaces.*

   Roles of color spaces
   ---------------------

   Linear workflows — required for modern rendering methods — generally involve more than one
   color space, each assigned to a particular role. Linear and nonlinear color spaces are
   appropriate for different roles, explained below.

   Input color space
   ~~~~~~~~~~~~~~~~~

   Colors supplied to three.js — from color pickers, textures, 3D models, and other sources —
   each have an associated color space. Those not already in the Linear-sRGB working color
   space must be converted, and textures be given the correct *texture.colorSpace*
   assignment. Certain conversions (for hexadecimal and CSS colors in sRGB) can be made
   automatically if the THREE.ColorManagement API is enabled before initializing colors:


   .. code:: javascript

      THREE.ColorManagement.enabled = true;


   -  **Materials, lights, and shaders:** Colors in materials, lights, and shaders store RGB
      components in the Linear-sRGB working color space.
   -  **Vertex colors:** `BufferAttributes <#BufferAttribute>`__ store RGB components in the
      Linear-sRGB working color space.
   -  **Color textures:** PNG or JPEG `Textures <#Texture>`__ containing color information
      (like .map or .emissiveMap) use the closed domain sRGB color space, and must be
      annotated with *texture.colorSpace = SRGBColorSpace*. Formats like OpenEXR (sometimes
      used for .envMap or .lightMap) use the Linear-sRGB color space indicated with
      *texture.colorSpace = LinearSRGBColorSpace*, and may contain values in the open domain
      [0,∞].
   -  **Non-color textures:** Textures that do not store color information (like .normalMap
      or .roughnessMap) do not have an associated color space, and generally use the
      (default) texture annotation of *texture.colorSpace = NoColorSpace*. In rare cases,
      non-color data may be represented with other nonlinear encodings for technical reasons.

   .. Warning::

      ⚠️ **WARNING:** *Many formats for 3D models do not correctly or consistently define
      color space information. While three.js attempts to handle most cases, problems are
      common with older file formats. For best results, use glTF 2.0 (``GLTFLoader``) and
      test 3D models in online viewers early to confirm the asset itself is correct.*

   Working color space
   ~~~~~~~~~~~~~~~~~~~

   Rendering, interpolation, and many other operations must be performed in an open domain
   linear working color space, in which RGB components are proportional to physical
   illumination. In three.js, the working color space is Linear-sRGB.

   Output color space
   ~~~~~~~~~~~~~~~~~~

   Output to a display device, image, or video may involve conversion from the open domain
   Linear-sRGB working color space to another color space. This conversion may be performed
   in the main render pass (``WebGLRenderer.outputColorSpace``), or during
   post-processing.


   .. code:: javascript

      renderer.outputColorSpace = THREE.SRGBColorSpace;
      // optional with post-processing


   -  **Display:** Colors written to a WebGL canvas for display should be in the sRGB color
      space.
   -  **Image:** Colors written to an image should use the color space appropriate for the
      format and usage. Fully-rendered images written to PNG or JPEG textures generally use
      the sRGB color space. Images containing emission, light maps, or other data not
      confined to the [0,1] range will generally use the open domain Linear-sRGB color space,
      and a compatible image format like OpenEXR.

   .. Warning::

      ⚠️ **WARNING:** *Render targets may use either sRGB or Linear-sRGB. sRGB makes better
      use of limited precision. In the closed domain, 8 bits often suffice for sRGB whereas
      ≥12 bits (half float) may be required for Linear-sRGB. If later pipeline stages require
      Linear-sRGB input, the additional conversions may have a small performance cost.*

   Custom materials based on ``ShaderMaterial`` and ``RawShaderMaterial`` have to
   implement their own output color space conversion. For instances of ``ShaderMaterial``,
   adding the ``colorspace_fragment`` shader chunk to the fragment shader's ``main()``
   function should be sufficient.

   Working with THREE.Color instances
   ----------------------------------

   Methods reading or modifying ``Color`` instances assume data is already in the three.js
   working color space, Linear-sRGB. RGB and HSL components are direct representations of
   data stored by the Color instance, and are never converted implicitly. Color data may be
   explicitly converted with *.convertLinearToSRGB()* or *.convertSRGBToLinear()*.


   .. code:: javascript

      // RGB components (no change). 
      color.r = color.g = color.b = 0.5;
      console.log( color.r );
      // → 0.5 // Manual conversion. 
      color.r = 0.5;
      color.convertSRGBToLinear();
      console.log( color.r );
      // → 0.214041140


   With *ColorManagement.enabled = true* set (recommended), certain conversions are made
   automatically. Because hexadecimal and CSS colors are generally sRGB, ``Color`` methods
   will automatically convert these inputs from sRGB to Linear-sRGB in setters, or convert
   from Linear-sRGB to sRGB when returning hexadecimal or CSS output from getters.


   .. code:: javascript

      // Hexadecimal conversion. 
      color.setHex( 0x808080 );
      console.log( color.r );
      // → 0.214041140 
      console.log( color.getHex() );
      // → 0x808080 

      // CSS conversion. 
      color.setStyle( 'rgb( 0.5, 0.5, 0.5 )' );
      console.log( color.r );
      // → 0.214041140 

      // Override conversion with 'colorSpace' argument. 
      color.setHex( 0x808080, LinearSRGBColorSpace );
      console.log( color.r );
      // → 0.5 
      console.log( color.getHex( LinearSRGBColorSpace ) );
      // → 0x808080 
      console.log( color.getHex( SRGBColorSpace ) );
      // → 0xBCBCBC


   Common mistakes
   ---------------

   When an individual color or texture is misconfigured, it will appear darker or lighter
   than expected. When the renderer's output color space is misconfigured, the entire scene
   may appear darker (e.g. missing conversion to sRGB) or lighter (e.g. a double conversion
   to sRGB with post-processing). In each case the problem may not be uniform, and simply
   increasing/decreasing lighting does not solve it.

   A more subtle issue appears when *both* the input color spaces and the output color spaces
   are incorrect — the overall brightness levels may be fine, but colors may change
   unexpectedly under different lighting, or shading may appear more blown-out and less soft
   than intended. These two wrongs do not make a right, and it's important that the working
   color space be linear ("scene referred") and the output color space be nonlinear ("display
   referred").

   Further reading
   ---------------

   -  `GPU Gems 3: The Importance of Being
      Linear <https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear>`__,
      by Larry Gritz and Eugene d'Eon
   -  `What every coder should know about
      gamma <https://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma/>`__,
      by John Novak
   -  `The Hitchhiker's Guide to Digital Color <https://hg2dc.com/>`__, by Troy Sobotka
   -  `Color Management <https://docs.blender.org/manual/en/latest/render/color_management.html>`__,
      Blender


🟡 Reference
============

API Reference
-------------

Animation
~~~~~~~~~

   -  [D017]_ `AnimationAction  <https://threejs.org/docs/api/en/animation/AnimationAction.html>`__
   -  [D018]_ `AnimationClip  <https://threejs.org/docs/api/en/animation/AnimationClip.html>`__
   -  [D019]_ `AnimationMixer  <https://threejs.org/docs/api/en/animation/AnimationMixer.html>`__
   -  [D020]_ `AnimationObjectGroup  <https://threejs.org/docs/api/en/animation/AnimationObjectGroup.html>`__
   -  [D021]_ `AnimationUtils  <https://threejs.org/docs/api/en/animation/AnimationUtils.html>`__
   -  [D022]_ `KeyframeTrack  <https://threejs.org/docs/api/en/animation/KeyframeTrack.html>`__
   -  [D023]_ `PropertyBinding  <https://threejs.org/docs/api/en/animation/PropertyBinding.html>`__
   -  [D024]_ `PropertyMixer  <https://threejs.org/docs/api/en/animation/PropertyMixer.html>`__

Animation / Tracks
~~~~~~~~~~~~~~~~~~

   -  [D025]_ `BooleanKeyframeTrack  <https://threejs.org/docs/api/en/animation/tracks/BooleanKeyframeTrack.html>`__
   -  [D026]_ `ColorKeyframeTrack  <https://threejs.org/docs/api/en/animation/tracks/ColorKeyframeTrack.html>`__
   -  [D027]_ `NumberKeyframeTrack  <https://threejs.org/docs/api/en/animation/tracks/NumberKeyframeTrack.html>`__
   -  [D028]_ `QuaternionKeyframeTrack  <https://threejs.org/docs/api/en/animation/tracks/QuaternionKeyframeTrack.html>`__
   -  [D029]_ `StringKeyframeTrack  <https://threejs.org/docs/api/en/animation/tracks/StringKeyframeTrack.html>`__
   -  [D030]_ `VectorKeyframeTrack  <https://threejs.org/docs/api/en/animation/tracks/VectorKeyframeTrack.html>`__

Audio
~~~~~

   -  [D031]_ `Audio  <https://threejs.org/docs/api/en/audio/Audio.html>`__
   -  [D032]_ `AudioAnalyser  <https://threejs.org/docs/api/en/audio/AudioAnalyser.html>`__
   -  [D033]_ `AudioContext  <https://threejs.org/docs/api/en/audio/AudioContext.html>`__
   -  [D034]_ `AudioListener  <https://threejs.org/docs/api/en/audio/AudioListener.html>`__
   -  [D035]_ `PositionalAudio  <https://threejs.org/docs/api/en/audio/PositionalAudio.html>`__

Cameras
~~~~~~~

   -  [D036]_ `ArrayCamera  <https://threejs.org/docs/api/en/cameras/ArrayCamera.html>`__
   -  [D037]_ `Camera  <https://threejs.org/docs/api/en/cameras/Camera.html>`__
   -  [D038]_ `CubeCamera  <https://threejs.org/docs/api/en/cameras/CubeCamera.html>`__
   -  [D039]_ `OrthographicCamera  <https://threejs.org/docs/api/en/cameras/OrthographicCamera.html>`__
   -  [D040]_ `PerspectiveCamera  <https://threejs.org/docs/api/en/cameras/PerspectiveCamera.html>`__
   -  [D041]_ `StereoCamera  <https://threejs.org/docs/api/en/cameras/StereoCamera.html>`__

Constants
~~~~~~~~~

   -  [D042]_ `Animation  <https://threejs.org/docs/api/en/constants/Animation.html>`__
   -  [D043]_ `Core  <https://threejs.org/docs/api/en/constants/Core.html>`__
   -  [D044]_ `CustomBlendingEquation  <https://threejs.org/docs/api/en/constants/CustomBlendingEquations.html>`__
   -  [D045]_ `BufferAttributeUsage  <https://threejs.org/docs/api/en/constants/BufferAttributeUsage.html>`__
   -  [D046]_ `Materials  <https://threejs.org/docs/api/en/constants/Materials.html>`__
   -  [D047]_ `Renderer  <https://threejs.org/docs/api/en/constants/Renderer.html>`__
   -  [D048]_ `Textures  <https://threejs.org/docs/api/en/constants/Textures.html>`__

Core
~~~~

   -  [D049]_ `BufferAttribute  <https://threejs.org/docs/api/en/core/BufferAttribute.html>`__
   -  [D050]_ `BufferGeometry  <https://threejs.org/docs/api/en/core/BufferGeometry.html>`__
   -  [D051]_ `Clock  <https://threejs.org/docs/api/en/core/Clock.html>`__
   -  [D052]_ `EventDispatcher  <https://threejs.org/docs/api/en/core/EventDispatcher.html>`__
   -  [D053]_ `GLBufferAttribute  <https://threejs.org/docs/api/en/core/GLBufferAttribute.html>`__
   -  [D054]_ `InstancedBufferAttribute  <https://threejs.org/docs/api/en/core/InstancedBufferAttribute.html>`__
   -  [D055]_ `InstancedBufferGeometry  <https://threejs.org/docs/api/en/core/InstancedBufferGeometry.html>`__
   -  [D056]_ `InstancedInterleavedBuffer  <https://threejs.org/docs/api/en/core/InstancedInterleavedBuffer.html>`__
   -  [D057]_ `InterleavedBuffer  <https://threejs.org/docs/api/en/core/InterleavedBuffer.html>`__
   -  [D058]_ `InterleavedBufferAttribute  <https://threejs.org/docs/api/en/core/InterleavedBufferAttribute.html>`__
   -  [D059]_ `Layers  <https://threejs.org/docs/api/en/core/Layers.html>`__
   -  [D060]_ `Object3D  <https://threejs.org/docs/api/en/core/Object3D.html>`__
   -  [D061]_ `Raycaster  <https://threejs.org/docs/api/en/core/Raycaster.html>`__
   -  [D062]_ `Uniform  <https://threejs.org/docs/api/en/core/Uniform.html>`__

Core / BufferAttributes
~~~~~~~~~~~~~~~~~~~~~~~

   -  [D063]_ `BufferAttribute Types  <https://threejs.org/docs/api/en/core/bufferAttributeTypes/BufferAttributeTypes.html>`__

Extras
~~~~~~

   -  [D064]_ `DataUtils  <https://threejs.org/docs/api/en/extras/DataUtils.html>`__
   -  [D065]_ `Earcut  <https://threejs.org/docs/api/en/extras/Earcut.html>`__
   -  [D066]_ `ImageUtils  <https://threejs.org/docs/api/en/extras/ImageUtils.html>`__
   -  [D067]_ `PMREMGenerator  <https://threejs.org/docs/api/en/extras/PMREMGenerator.html>`__
   -  [D068]_ `ShapeUtils  <https://threejs.org/docs/api/en/extras/ShapeUtils.html>`__
   -  [D069]_ `TextureUtils  <https://threejs.org/docs/api/en/extras/TextureUtils.html>`__

Extras / Core
~~~~~~~~~~~~~

   -  [D070]_ `Curve  <https://threejs.org/docs/api/en/extras/core/Curve.html>`__
   -  [D071]_ `CurvePath  <https://threejs.org/docs/api/en/extras/core/CurvePath.html>`__
   -  [D072]_ `Interpolations  <https://threejs.org/docs/api/en/extras/core/Interpolations.html>`__
   -  [D073]_ `Path  <https://threejs.org/docs/api/en/extras/core/Path.html>`__
   -  [D074]_ `Shape  <https://threejs.org/docs/api/en/extras/core/Shape.html>`__
   -  [D075]_ `ShapePath  <https://threejs.org/docs/api/en/extras/core/ShapePath.html>`__

Extras / Curves
~~~~~~~~~~~~~~~

   -  [D076]_ `ArcCurve  <https://threejs.org/docs/api/en/extras/curves/ArcCurve.html>`__
   -  [D077]_ `CatmullRomCurve3  <https://threejs.org/docs/api/en/extras/curves/CatmullRomCurve3.html>`__
   -  [D078]_ `CubicBezierCurve  <https://threejs.org/docs/api/en/extras/curves/CubicBezierCurve.html>`__
   -  [D079]_ `CubicBezierCurve3  <https://threejs.org/docs/api/en/extras/curves/CubicBezierCurve3.html>`__
   -  [D080]_ `EllipseCurve  <https://threejs.org/docs/api/en/extras/curves/EllipseCurve.html>`__
   -  [D081]_ `LineCurve  <https://threejs.org/docs/api/en/extras/curves/LineCurve.html>`__
   -  [D082]_ `LineCurve3  <https://threejs.org/docs/api/en/extras/curves/LineCurve3.html>`__
   -  [D083]_ `QuadraticBezierCurve  <https://threejs.org/docs/api/en/extras/curves/QuadraticBezierCurve.html>`__
   -  [D084]_ `QuadraticBezierCurve3  <https://threejs.org/docs/api/en/extras/curves/QuadraticBezierCurve3.html>`__
   -  [D085]_ `SplineCurve  <https://threejs.org/docs/api/en/extras/curves/SplineCurve.html>`__

Geometries
~~~~~~~~~~

   -  [D086]_ `BoxGeometry  <https://threejs.org/docs/api/en/geometries/BoxGeometry.html>`__
   -  [D087]_ `CapsuleGeometry  <https://threejs.org/docs/api/en/geometries/CapsuleGeometry.html>`__
   -  [D088]_ `CircleGeometry  <https://threejs.org/docs/api/en/geometries/CircleGeometry.html>`__
   -  [D089]_ `ConeGeometry  <https://threejs.org/docs/api/en/geometries/ConeGeometry.html>`__
   -  [D090]_ `CylinderGeometry  <https://threejs.org/docs/api/en/geometries/CylinderGeometry.html>`__
   -  [D091]_ `DodecahedronGeometry  <https://threejs.org/docs/api/en/geometries/DodecahedronGeometry.html>`__
   -  [D092]_ `EdgesGeometry  <https://threejs.org/docs/api/en/geometries/EdgesGeometry.html>`__
   -  [D093]_ `ExtrudeGeometry  <https://threejs.org/docs/api/en/geometries/ExtrudeGeometry.html>`__
   -  [D094]_ `IcosahedronGeometry  <https://threejs.org/docs/api/en/geometries/IcosahedronGeometry.html>`__
   -  [D095]_ `LatheGeometry  <https://threejs.org/docs/api/en/geometries/LatheGeometry.html>`__
   -  [D096]_ `OctahedronGeometry  <https://threejs.org/docs/api/en/geometries/OctahedronGeometry.html>`__
   -  [D097]_ `PlaneGeometry  <https://threejs.org/docs/api/en/geometries/PlaneGeometry.html>`__
   -  [D098]_ `PolyhedronGeometry  <https://threejs.org/docs/api/en/geometries/PolyhedronGeometry.html>`__
   -  [D099]_ `RingGeometry  <https://threejs.org/docs/api/en/geometries/RingGeometry.html>`__
   -  [D100]_ `ShapeGeometry  <https://threejs.org/docs/api/en/geometries/ShapeGeometry.html>`__
   -  [D101]_ `SphereGeometry  <https://threejs.org/docs/api/en/geometries/SphereGeometry.html>`__
   -  [D102]_ `TetrahedronGeometry  <https://threejs.org/docs/api/en/geometries/TetrahedronGeometry.html>`__
   -  [D103]_ `TorusGeometry  <https://threejs.org/docs/api/en/geometries/TorusGeometry.html>`__
   -  [D104]_ `TorusKnotGeometry  <https://threejs.org/docs/api/en/geometries/TorusKnotGeometry.html>`__
   -  [D105]_ `TubeGeometry  <https://threejs.org/docs/api/en/geometries/TubeGeometry.html>`__
   -  [D106]_ `WireframeGeometry  <https://threejs.org/docs/api/en/geometries/WireframeGeometry.html>`__

Helpers
~~~~~~~

   -  [D107]_ `ArrowHelper  <https://threejs.org/docs/api/en/helpers/ArrowHelper.html>`__
   -  [D108]_ `AxesHelper  <https://threejs.org/docs/api/en/helpers/AxesHelper.html>`__
   -  [D109]_ `BoxHelper  <https://threejs.org/docs/api/en/helpers/BoxHelper.html>`__
   -  [D110]_ `Box3Helper  <https://threejs.org/docs/api/en/helpers/Box3Helper.html>`__
   -  [D111]_ `CameraHelper  <https://threejs.org/docs/api/en/helpers/CameraHelper.html>`__
   -  [D112]_ `DirectionalLightHelper  <https://threejs.org/docs/api/en/helpers/DirectionalLightHelper.html>`__
   -  [D113]_ `GridHelper  <https://threejs.org/docs/api/en/helpers/GridHelper.html>`__
   -  [D114]_ `PolarGridHelper  <https://threejs.org/docs/api/en/helpers/PolarGridHelper.html>`__
   -  [D115]_ `HemisphereLightHelper  <https://threejs.org/docs/api/en/helpers/HemisphereLightHelper.html>`__
   -  [D116]_ `PlaneHelper  <https://threejs.org/docs/api/en/helpers/PlaneHelper.html>`__
   -  [D117]_ `PointLightHelper  <https://threejs.org/docs/api/en/helpers/PointLightHelper.html>`__
   -  [D118]_ `SkeletonHelper  <https://threejs.org/docs/api/en/helpers/SkeletonHelper.html>`__
   -  [D119]_ `SpotLightHelper  <https://threejs.org/docs/api/en/helpers/SpotLightHelper.html>`__

Lights
~~~~~~

   -  [D120]_ `AmbientLight  <https://threejs.org/docs/api/en/lights/AmbientLight.html>`__
   -  [D121]_ `DirectionalLight  <https://threejs.org/docs/api/en/lights/DirectionalLight.html>`__
   -  [D122]_ `HemisphereLight  <https://threejs.org/docs/api/en/lights/HemisphereLight.html>`__
   -  [D123]_ `Light  <https://threejs.org/docs/api/en/lights/Light.html>`__
   -  [D124]_ `LightProbe  <https://threejs.org/docs/api/en/lights/LightProbe.html>`__
   -  [D125]_ `PointLight  <https://threejs.org/docs/api/en/lights/PointLight.html>`__
   -  [D126]_ `RectAreaLight  <https://threejs.org/docs/api/en/lights/RectAreaLight.html>`__
   -  [D127]_ `SpotLight  <https://threejs.org/docs/api/en/lights/SpotLight.html>`__

Lights / Shadows
~~~~~~~~~~~~~~~~

   -  [D128]_ `LightShadow  <https://threejs.org/docs/api/en/lights/shadows/LightShadow.html>`__
   -  [D129]_ `PointLightShadow  <https://threejs.org/docs/api/en/lights/shadows/PointLightShadow.html>`__
   -  [D130]_ `DirectionalLightShadow  <https://threejs.org/docs/api/en/lights/shadows/DirectionalLightShadow.html>`__
   -  [D131]_ `SpotLightShadow  <https://threejs.org/docs/api/en/lights/shadows/SpotLightShadow.html>`__

Loaders
~~~~~~~

   -  [D132]_ `AnimationLoader  <https://threejs.org/docs/api/en/loaders/AnimationLoader.html>`__
   -  [D133]_ `AudioLoader  <https://threejs.org/docs/api/en/loaders/AudioLoader.html>`__
   -  [D134]_ `BufferGeometryLoader  <https://threejs.org/docs/api/en/loaders/BufferGeometryLoader.html>`__
   -  [D135]_ `Cache  <https://threejs.org/docs/api/en/loaders/Cache.html>`__
   -  [D136]_ `CompressedTextureLoader  <https://threejs.org/docs/api/en/loaders/CompressedTextureLoader.html>`__
   -  [D137]_ `CubeTextureLoader  <https://threejs.org/docs/api/en/loaders/CubeTextureLoader.html>`__
   -  [D138]_ `DataTextureLoader  <https://threejs.org/docs/api/en/loaders/DataTextureLoader.html>`__
   -  [D139]_ `FileLoader  <https://threejs.org/docs/api/en/loaders/FileLoader.html>`__
   -  [D140]_ `ImageBitmapLoader  <https://threejs.org/docs/api/en/loaders/ImageBitmapLoader.html>`__
   -  [D141]_ `ImageLoader  <https://threejs.org/docs/api/en/loaders/ImageLoader.html>`__
   -  [D142]_ `Loader  <https://threejs.org/docs/api/en/loaders/Loader.html>`__
   -  [D143]_ `LoaderUtils  <https://threejs.org/docs/api/en/loaders/LoaderUtils.html>`__
   -  [D144]_ `MaterialLoader  <https://threejs.org/docs/api/en/loaders/MaterialLoader.html>`__
   -  [D145]_ `ObjectLoader  <https://threejs.org/docs/api/en/loaders/ObjectLoader.html>`__
   -  [D146]_ `TextureLoader  <https://threejs.org/docs/api/en/loaders/TextureLoader.html>`__

Loaders / Managers
~~~~~~~~~~~~~~~~~~

   -  [D147]_ `DefaultLoadingManager  <https://threejs.org/docs/api/en/loaders/managers/DefaultLoadingManager.html>`__
   -  [D148]_ `LoadingManager  <https://threejs.org/docs/api/en/loaders/managers/LoadingManager.html>`__

Materials
~~~~~~~~~

   -  [D149]_ `LineBasicMaterial  <https://threejs.org/docs/api/en/materials/LineBasicMaterial.html>`__
   -  [D150]_ `LineDashedMaterial  <https://threejs.org/docs/api/en/materials/LineDashedMaterial.html>`__
   -  [D151]_ `Material  <https://threejs.org/docs/api/en/materials/Material.html>`__
   -  [D152]_ `MeshBasicMaterial  <https://threejs.org/docs/api/en/materials/MeshBasicMaterial.html>`__
   -  [D153]_ `MeshDepthMaterial  <https://threejs.org/docs/api/en/materials/MeshDepthMaterial.html>`__
   -  [D154]_ `MeshDistanceMaterial  <https://threejs.org/docs/api/en/materials/MeshDistanceMaterial.html>`__
   -  [D155]_ `MeshLambertMaterial  <https://threejs.org/docs/api/en/materials/MeshLambertMaterial.html>`__
   -  [D156]_ `MeshMatcapMaterial  <https://threejs.org/docs/api/en/materials/MeshMatcapMaterial.html>`__
   -  [D157]_ `MeshNormalMaterial  <https://threejs.org/docs/api/en/materials/MeshNormalMaterial.html>`__
   -  [D158]_ `MeshPhongMaterial  <https://threejs.org/docs/api/en/materials/MeshPhongMaterial.html>`__
   -  [D159]_ `MeshPhysicalMaterial  <https://threejs.org/docs/api/en/materials/MeshPhysicalMaterial.html>`__
   -  [D160]_ `MeshStandardMaterial  <https://threejs.org/docs/api/en/materials/MeshStandardMaterial.html>`__
   -  [D161]_ `MeshToonMaterial  <https://threejs.org/docs/api/en/materials/MeshToonMaterial.html>`__
   -  [D162]_ `PointsMaterial  <https://threejs.org/docs/api/en/materials/PointsMaterial.html>`__
   -  [D163]_ `RawShaderMaterial  <https://threejs.org/docs/api/en/materials/RawShaderMaterial.html>`__
   -  [D164]_ `ShaderMaterial  <https://threejs.org/docs/api/en/materials/ShaderMaterial.html>`__
   -  [D165]_ `ShadowMaterial  <https://threejs.org/docs/api/en/materials/ShadowMaterial.html>`__
   -  [D166]_ `SpriteMaterial  <https://threejs.org/docs/api/en/materials/SpriteMaterial.html>`__

Math
~~~~

   -  [D167]_ `Box2  <https://threejs.org/docs/api/en/math/Box2.html>`__
   -  [D168]_ `Box3  <https://threejs.org/docs/api/en/math/Box3.html>`__
   -  [D169]_ `Color  <https://threejs.org/docs/api/en/math/Color.html>`__
   -  [D170]_ `Cylindrical  <https://threejs.org/docs/api/en/math/Cylindrical.html>`__
   -  [D171]_ `Euler  <https://threejs.org/docs/api/en/math/Euler.html>`__
   -  [D172]_ `Frustum  <https://threejs.org/docs/api/en/math/Frustum.html>`__
   -  [D173]_ `Interpolant  <https://threejs.org/docs/api/en/math/Interpolant.html>`__
   -  [D174]_ `Line3  <https://threejs.org/docs/api/en/math/Line3.html>`__
   -  [D175]_ `MathUtils  <https://threejs.org/docs/api/en/math/MathUtils.html>`__
   -  [D176]_ `Matrix3  <https://threejs.org/docs/api/en/math/Matrix3.html>`__
   -  [D177]_ `Matrix4  <https://threejs.org/docs/api/en/math/Matrix4.html>`__
   -  [D178]_ `Plane  <https://threejs.org/docs/api/en/math/Plane.html>`__
   -  [D179]_ `Quaternion  <https://threejs.org/docs/api/en/math/Quaternion.html>`__
   -  [D180]_ `Ray  <https://threejs.org/docs/api/en/math/Ray.html>`__
   -  [D181]_ `Sphere  <https://threejs.org/docs/api/en/math/Sphere.html>`__
   -  [D182]_ `Spherical  <https://threejs.org/docs/api/en/math/Spherical.html>`__
   -  [D183]_ `SphericalHarmonics3  <https://threejs.org/docs/api/en/math/SphericalHarmonics3.html>`__
   -  [D184]_ `Triangle  <https://threejs.org/docs/api/en/math/Triangle.html>`__
   -  [D185]_ `Vector2  <https://threejs.org/docs/api/en/math/Vector2.html>`__
   -  [D186]_ `Vector3  <https://threejs.org/docs/api/en/math/Vector3.html>`__
   -  [D187]_ `Vector4  <https://threejs.org/docs/api/en/math/Vector4.html>`__

Math / Interpolants
~~~~~~~~~~~~~~~~~~~

   -  [D188]_ `CubicInterpolant  <https://threejs.org/docs/api/en/math/interpolants/CubicInterpolant.html>`__
   -  [D189]_ `DiscreteInterpolant  <https://threejs.org/docs/api/en/math/interpolants/DiscreteInterpolant.html>`__
   -  [D190]_ `LinearInterpolant  <https://threejs.org/docs/api/en/math/interpolants/LinearInterpolant.html>`__
   -  [D191]_ `QuaternionLinearInterpolant  <https://threejs.org/docs/api/en/math/interpolants/QuaternionLinearInterpolant.html>`__

Objects
~~~~~~~

   -  [D192]_ `BatchedMesh  <https://threejs.org/docs/api/en/objects/BatchedMesh.html>`__
   -  [D193]_ `Bone  <https://threejs.org/docs/api/en/objects/Bone.html>`__
   -  [D194]_ `Group  <https://threejs.org/docs/api/en/objects/Group.html>`__
   -  [D195]_ `InstancedMesh  <https://threejs.org/docs/api/en/objects/InstancedMesh.html>`__
   -  [D196]_ `Line  <https://threejs.org/docs/api/en/objects/Line.html>`__
   -  [D197]_ `LineLoop  <https://threejs.org/docs/api/en/objects/LineLoop.html>`__
   -  [D198]_ `LineSegments  <https://threejs.org/docs/api/en/objects/LineSegments.html>`__
   -  [D199]_ `LOD  <https://threejs.org/docs/api/en/objects/LOD.html>`__
   -  [D200]_ `Mesh  <https://threejs.org/docs/api/en/objects/Mesh.html>`__
   -  [D201]_ `Points  <https://threejs.org/docs/api/en/objects/Points.html>`__
   -  [D202]_ `Skeleton  <https://threejs.org/docs/api/en/objects/Skeleton.html>`__
   -  [D203]_ `SkinnedMesh  <https://threejs.org/docs/api/en/objects/SkinnedMesh.html>`__
   -  [D204]_ `Sprite  <https://threejs.org/docs/api/en/objects/Sprite.html>`__

Renderers
~~~~~~~~~

   -  [D205]_ `WebGLRenderer  <https://threejs.org/docs/api/en/renderers/WebGLRenderer.html>`__
   -  [D206]_ `WebGLRenderTarget  <https://threejs.org/docs/api/en/renderers/WebGLRenderTarget.html>`__
   -  [D207]_ `WebGL3DRenderTarget  <https://threejs.org/docs/api/en/renderers/WebGL3DRenderTarget.html>`__
   -  [D208]_ `WebGLArrayRenderTarget  <https://threejs.org/docs/api/en/renderers/WebGLArrayRenderTarget.html>`__
   -  [D209]_ `WebGLCubeRenderTarget  <https://threejs.org/docs/api/en/renderers/WebGLCubeRenderTarget.html>`__

Renderers / Shaders
~~~~~~~~~~~~~~~~~~~

   -  [D210]_ `ShaderChunk  <https://threejs.org/docs/api/en/renderers/shaders/ShaderChunk.html>`__
   -  [D211]_ `ShaderLib  <https://threejs.org/docs/api/en/renderers/shaders/ShaderLib.html>`__
   -  [D212]_ `UniformsLib  <https://threejs.org/docs/api/en/renderers/shaders/UniformsLib.html>`__
   -  [D213]_ `UniformsUtils  <https://threejs.org/docs/api/en/renderers/shaders/UniformsUtils.html>`__

Renderers / WebXR
~~~~~~~~~~~~~~~~~

   -  [D214]_ `WebXRManager  <https://threejs.org/docs/api/en/renderers/webxr/WebXRManager.html>`__

Scenes
~~~~~~

   -  [D215]_ `Fog  <https://threejs.org/docs/api/en/scenes/Fog.html>`__
   -  [D216]_ `FogExp2  <https://threejs.org/docs/api/en/scenes/FogExp2.html>`__
   -  [D217]_ `Scene  <https://threejs.org/docs/api/en/scenes/Scene.html>`__

Textures
~~~~~~~~

   -  [D218]_ `CanvasTexture  <https://threejs.org/docs/api/en/textures/CanvasTexture.html>`__
   -  [D219]_ `CompressedTexture  <https://threejs.org/docs/api/en/textures/CompressedTexture.html>`__
   -  [D220]_ `CompressedArrayTexture  <https://threejs.org/docs/api/en/textures/CompressedArrayTexture.html>`__
   -  [D221]_ `CubeTexture  <https://threejs.org/docs/api/en/textures/CubeTexture.html>`__
   -  [D222]_ `Data3DTexture  <https://threejs.org/docs/api/en/textures/Data3DTexture.html>`__
   -  [D223]_ `DataArrayTexture  <https://threejs.org/docs/api/en/textures/DataArrayTexture.html>`__
   -  [D224]_ `DataTexture  <https://threejs.org/docs/api/en/textures/DataTexture.html>`__
   -  [D225]_ `DepthTexture  <https://threejs.org/docs/api/en/textures/DepthTexture.html>`__
   -  [D226]_ `FramebufferTexture  <https://threejs.org/docs/api/en/textures/FramebufferTexture.html>`__
   -  [D227]_ `Source  <https://threejs.org/docs/api/en/textures/Source.html>`__
   -  [D228]_ `Texture  <https://threejs.org/docs/api/en/textures/Texture.html>`__
   -  [D229]_ `VideoTexture  <https://threejs.org/docs/api/en/textures/VideoTexture.html>`__


Addons
------

Animations
~~~~~~~~~~

   -  [D230]_ `CCDIKSolver  <https://threejs.org/docs/examples/en/animations/CCDIKSolver.html>`__
   -  [D231]_ `MMDAnimationHelper  <https://threejs.org/docs/examples/en/animations/MMDAnimationHelper.html>`__
   -  [D232]_ `MMDPhysics  <https://threejs.org/docs/examples/en/animations/MMDPhysics.html>`__

Controls
~~~~~~~~

   -  [D233]_ `ArcballControls  <https://threejs.org/docs/examples/en/controls/ArcballControls.html>`__
   -  [D234]_ `DragControls  <https://threejs.org/docs/examples/en/controls/DragControls.html>`__
   -  [D235]_ `FirstPersonControls  <https://threejs.org/docs/examples/en/controls/FirstPersonControls.html>`__
   -  [D236]_ `FlyControls  <https://threejs.org/docs/examples/en/controls/FlyControls.html>`__
   -  [D237]_ `MapControls  <https://threejs.org/docs/examples/en/controls/MapControls.html>`__
   -  [D238]_ `OrbitControls  <https://threejs.org/docs/examples/en/controls/OrbitControls.html>`__
   -  [D239]_ `PointerLockControls  <https://threejs.org/docs/examples/en/controls/PointerLockControls.html>`__
   -  [D240]_ `TrackballControls  <https://threejs.org/docs/examples/en/controls/TrackballControls.html>`__
   -  [D241]_ `TransformControls  <https://threejs.org/docs/examples/en/controls/TransformControls.html>`__

Geometries
~~~~~~~~~~

   -  [D242]_ `ConvexGeometry  <https://threejs.org/docs/examples/en/geometries/ConvexGeometry.html>`__
   -  [D243]_ `DecalGeometry  <https://threejs.org/docs/examples/en/geometries/DecalGeometry.html>`__
   -  [D244]_ `ParametricGeometry  <https://threejs.org/docs/examples/en/geometries/ParametricGeometry.html>`__
   -  [D245]_ `SDFGeometryGenerator  <https://threejs.org/docs/examples/en/geometries/SDFGeometryGenerator.html>`__
   -  [D246]_ `TeapotGeometry  <https://threejs.org/docs/examples/en/geometries/TeapotGeometry.html>`__
   -  [D247]_ `TextGeometry  <https://threejs.org/docs/examples/en/geometries/TextGeometry.html>`__

Helpers
~~~~~~~

   -  [D248]_ `LightProbeHelper  <https://threejs.org/docs/examples/en/helpers/LightProbeHelper.html>`__
   -  [D249]_ `PositionalAudioHelper  <https://threejs.org/docs/examples/en/helpers/PositionalAudioHelper.html>`__
   -  [D250]_ `RectAreaLightHelper  <https://threejs.org/docs/examples/en/helpers/RectAreaLightHelper.html>`__
   -  [D251]_ `VertexNormalsHelper  <https://threejs.org/docs/examples/en/helpers/VertexNormalsHelper.html>`__
   -  [D252]_ `VertexTangentsHelper  <https://threejs.org/docs/examples/en/helpers/VertexTangentsHelper.html>`__

Lights
~~~~~~

   -  [D253]_ `LightProbeGenerator  <https://threejs.org/docs/examples/en/lights/LightProbeGenerator.html>`__

Loaders
~~~~~~~

   -  [D254]_ `3DMLoader  <https://threejs.org/docs/examples/en/loaders/3DMLoader.html>`__
   -  [D255]_ `DRACOLoader  <https://threejs.org/docs/examples/en/loaders/DRACOLoader.html>`__
   -  [D256]_ `FontLoader  <https://threejs.org/docs/examples/en/loaders/FontLoader.html>`__
   -  [D257]_ `GLTFLoader  <https://threejs.org/docs/examples/en/loaders/GLTFLoader.html>`__
   -  [D258]_ `KTX2Loader  <https://threejs.org/docs/examples/en/loaders/KTX2Loader.html>`__
   -  [D259]_ `LDrawLoader  <https://threejs.org/docs/examples/en/loaders/LDrawLoader.html>`__
   -  [D260]_ `LUT3dlLoader  <https://threejs.org/docs/examples/en/loaders/LUT3dlLoader.html>`__
   -  [D261]_ `LUTCubeLoader  <https://threejs.org/docs/examples/en/loaders/LUTCubeLoader.html>`__
   -  [D262]_ `MMDLoader  <https://threejs.org/docs/examples/en/loaders/MMDLoader.html>`__
   -  [D263]_ `MTLLoader  <https://threejs.org/docs/examples/en/loaders/MTLLoader.html>`__
   -  [D264]_ `OBJLoader  <https://threejs.org/docs/examples/en/loaders/OBJLoader.html>`__
   -  [D265]_ `PCDLoader  <https://threejs.org/docs/examples/en/loaders/PCDLoader.html>`__
   -  [D266]_ `PDBLoader  <https://threejs.org/docs/examples/en/loaders/PDBLoader.html>`__
   -  [D267]_ `SVGLoader  <https://threejs.org/docs/examples/en/loaders/SVGLoader.html>`__
   -  [D268]_ `TGALoader  <https://threejs.org/docs/examples/en/loaders/TGALoader.html>`__

Objects
~~~~~~~

   -  [D269]_ `Lensflare  <https://threejs.org/docs/examples/en/objects/Lensflare.html>`__
   -  [D270]_ `Sky  <https://threejs.org/docs/examples/en/objects/Sky.html>`__

Post-Processing
~~~~~~~~~~~~~~~

   -  [D271]_ `EffectComposer  <https://threejs.org/docs/examples/en/postprocessing/EffectComposer.html>`__

Exporters
~~~~~~~~~

   -  [D272]_ `DRACOExporter  <https://threejs.org/docs/examples/en/exporters/DRACOExporter.html>`__
   -  [D273]_ `EXRExporter  <https://threejs.org/docs/examples/en/exporters/EXRExporter.html>`__
   -  [D274]_ `GLTFExporter  <https://threejs.org/docs/examples/en/exporters/GLTFExporter.html>`__
   -  [D275]_ `OBJExporter  <https://threejs.org/docs/examples/en/exporters/OBJExporter.html>`__
   -  [D276]_ `PLYExporter  <https://threejs.org/docs/examples/en/exporters/PLYExporter.html>`__
   -  [D277]_ `STLExporter  <https://threejs.org/docs/examples/en/exporters/STLExporter.html>`__

Math
~~~~

   -  [D278]_ `LookupTable  <https://threejs.org/docs/examples/en/math/Lut.html>`__
   -  [D279]_ `MeshSurfaceSampler  <https://threejs.org/docs/examples/en/math/MeshSurfaceSampler.html>`__
   -  [D280]_ `OBB  <https://threejs.org/docs/examples/en/math/OBB.html>`__

Misc
~~~~

   -  [D281]_ `Timer  <https://threejs.org/docs/examples/en/misc/Timer.html>`__

Modifiers
~~~~~~~~~

   -  [D282]_ `EdgeSplit  <https://threejs.org/docs/examples/en/modifiers/EdgeSplitModifier.html>`__

ConvexHull
~~~~~~~~~~

   -  [D283]_ `Face  <https://threejs.org/docs/examples/en/math/convexhull/Face.html>`__
   -  [D284]_ `HalfEdge  <https://threejs.org/docs/examples/en/math/convexhull/HalfEdge.html>`__
   -  [D285]_ `ConvexHull  <https://threejs.org/docs/examples/en/math/convexhull/ConvexHull.html>`__
   -  [D286]_ `VertexNode  <https://threejs.org/docs/examples/en/math/convexhull/VertexNode.html>`__
   -  [D287]_ `VertexList  <https://threejs.org/docs/examples/en/math/convexhull/VertexList.html>`__

Renderers
~~~~~~~~~

   -  [D288]_ `CSS2DRenderer  <https://threejs.org/docs/examples/en/renderers/CSS2DRenderer.html>`__
   -  [D289]_ `CSS3DRenderer  <https://threejs.org/docs/examples/en/renderers/CSS3DRenderer.html>`__
   -  [D290]_ `SVGRenderer  <https://threejs.org/docs/examples/en/renderers/SVGRenderer.html>`__

Utils
~~~~~

   -  [D291]_ `BufferGeometryUtils  <https://threejs.org/docs/examples/en/utils/BufferGeometryUtils.html>`__
   -  [D292]_ `CameraUtils  <https://threejs.org/docs/examples/en/utils/CameraUtils.html>`__
   -  [D293]_ `SceneUtils  <https://threejs.org/docs/examples/en/utils/SceneUtils.html>`__
   -  [D294]_ `SkeletonUtils  <https://threejs.org/docs/examples/en/utils/SkeletonUtils.html>`__

WebXR
~~~~~

   -  [D295]_ `XREstimatedLight  <https://threejs.org/docs/examples/en/webxr/XREstimatedLight.html>`__


Developer Reference
-------------------

WebGLRenderer
~~~~~~~~~~~~~

   -  [D296]_ `WebGLProgram  <https://threejs.org/docs/api/en/renderers/webgl/WebGLProgram.html>`__


.. _D017:

AnimationAction
===============

   https://threejs.org/docs/api/en/animation/AnimationAction.html

   AnimationActions schedule the performance of the animations which are stored in
   `AnimationClips <#AnimationClip>`__.


   Note: Most of AnimationAction's methods can be chained.
   For an overview of the different elements of the three.js animation system see the
   "Animation System" article in the "Next Steps" section of the manual.

   .. Constructor

🐣:AnimationAction( AnimationMixer mixer, AnimationClip clip, Object3D localRoot )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `mixer <#AnimationMixer>`__ - the ``AnimationMixer`` that is controlled by this action.
   -  `clip <#AnimationClip>`__ - the ``AnimationClip`` that holds the animation data for this action.
   -  `localRoot <#Object3D>`__ - the root object on which this action is performed.
   -  `blendMode <#Number>`__ - defines how the animation is blended/combined when two or more
      animations are simultaneously played.

   Note: Instead of calling this constructor directly you should instantiate an
   AnimationAction with ``AnimationMixer.clipAction`` since this method provides caching
   for better performance.

Properties
----------

⭕:Number blendMode
~~~~~~~~~~~~~~~~~~~~

   Defines how the animation is blended/combined when two or more animations are
   simultaneously played. Valid values are ``NormalAnimationBlendMode`` (default) and
   ``AdditiveAnimationBlendMode``.

⭕:Boolean clampWhenFinished
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If ``clampWhenFinished`` is set to true the animation will automatically be
   ``paused`` on its last frame.

   If ``clampWhenFinished`` is set to false, ``enabled`` will automatically be
   switched to false when the last loop of the action has finished, so that this action has
   no further impact.
   Default is ``false``.

   Note: ``clampWhenFinished`` has no impact if the action is interrupted (it has only an
   effect if its last loop has really finished).

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   Setting ``enabled`` to ``false`` disables this action, so that it has no impact.
   Default is ``true``.

   When the action is re-enabled, the animation continues from its current 
   ``time`` (setting ``enabled`` to ``false`` doesn't reset the action).

   Note: Setting ``enabled`` to ``true`` doesn’t automatically restart the animation.
   Setting ``enabled`` to ``true`` will only restart the animation immediately if the
   following condition is fulfilled: ``paused`` is ``false``, this action has
   not been deactivated in the meantime (by executing a ``stop`` or 
   ``reset`` command), and neither ``weight`` nor ``timeScale`` is
   ``0``.

⭕:Number loop
~~~~~~~~~~~~~~~

   The looping mode (can be changed with ``setLoop``). Default is
   `THREE.LoopRepeat <#Animation>`__ (with an infinite number of 
   ``repetitions`` )

   Must be one of these constants:

   -  `THREE.LoopOnce <#Animation>`__ - playing the clip once,
   -  `THREE.LoopRepeat <#Animation>`__ - playing the clip with the chosen number of
      ``repetitions``, each time jumping from the end of the clip directly to its beginning,
   -  `THREE.LoopPingPong <#Animation>`__ - playing the clip with the chosen number of
      ``repetitions``, alternately playing forward and backward.

⭕:Boolean paused
~~~~~~~~~~~~~~~~~~

   Setting ``paused`` to ``true`` pauses the execution of the action by setting the
   effective time scale to ``0``. Default is ``false``.

⭕:Number repetitions
~~~~~~~~~~~~~~~~~~~~~~

   The number of repetitions of the performed ``AnimationClip`` over the course of this
   action. Can be set via ``setLoop``. Default is ``Infinity``.
   Setting this number has no effect, if the `loop mode <#.loop>`__ is set to
   `THREE.LoopOnce <#Animation>`__.

⭕:Number time
~~~~~~~~~~~~~~~

   The local time of this action (in seconds, starting with ``0``).
   The value gets clamped or wrapped to ``0...clip.duration`` (according to the loop
   state). It can be scaled relatively to the global mixer time by changing
   ``timeScale`` (using ``setEffectiveTimeScale`` or ``setDuration``).

⭕:Number timeScale
~~~~~~~~~~~~~~~~~~~~

   Scaling factor for the ``time``. A value of ``0`` causes the animation to
   pause. Negative values cause the animation to play backwards. Default is ``1``.
   Properties/methods concerning ``timeScale`` (respectively ``time``) are:
   ``getEffectiveTimeScale``, ``halt``, ``paused`` , ``setDuration``, 
   ``setEffectiveTimeScale`` , ``stopWarping``, ``syncWith``, ``warp``.

⭕:Number weight
~~~~~~~~~~~~~~~~~

   The degree of influence of this action (in the interval ``[0, 1]``). Values between
   ``0`` (no impact) and ``1`` (full impact) can be used to blend between several actions.
   Default is ``1``.

   Properties/methods concerning ``weight`` are: ``crossFadeFrom``,
   ``crossFadeTo``, ``enabled``, ``fadeIn``, ``fadeOut``, ``getEffectiveWeight``,
   ``setEffectiveWeight``, ``stopFading``.

⭕:Boolean zeroSlopeAtEnd
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Enables smooth interpolation without separate clips for start, loop and end.
   Default is ``true``.

⭕:Boolean zeroSlopeAtStart
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Enables smooth interpolation without separate clips for start, loop and end.
   Default is ``true``.

Methods
-------

📦:crossFadeFrom( AnimationAction fadeOutAction, Number durationInSeconds, Boolean warpBoolean ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Causes this action to `fade in <#.fadeIn>`__, fading out another action simultaneously,
   within the passed time interval. This method can be chained.
   If warpBoolean is true, additional `warping <#.warp>`__ (gradually changes of the time
   scales) will be applied.

   Note: Like with ``fadeIn``/ ``fadeOut``, the fading starts/ends with a weight of ``1``.

📦:crossFadeTo( AnimationAction fadeInAction, Number durationInSeconds, Boolean warpBoolean ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Causes this action to `fade out <#.fadeOut>`__, fading in another action simultaneously,
   within the passed time interval. This method can be chained.
   If warpBoolean is true, additional `warping <#.warp>`__ (gradually changes of the time
   scales) will be applied.

   Note: Like with ``fadeIn``/ ``fadeOut``, the fading starts/ends with a weight of ``1``.

📦:fadeIn( Number durationInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Increases the ``weight`` of this action gradually from ``0`` to ``1``, within
   the passed time interval. This method can be chained.

📦:fadeOut( Number durationInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Decreases the ``weight`` of this action gradually from ``1`` to ``0``, within
   the passed time interval. This method can be chained.

📦:getEffectiveTimeScale() Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the effective time scale (considering the current states of warping and
   ``paused``).

📦:getEffectiveWeight() Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the effective weight (considering the current states of fading and ``enabled``).

📦:getClip() AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the clip which holds the animation data for this action.

📦:getMixer() AnimationMixer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the mixer which is responsible for playing this action.

📦:getRoot() Object3D
~~~~~~~~~~~~~~~~~~~~~~

   Returns the root object on which this action is performed.

📦:halt( Number durationInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Decelerates this animation's speed to ``0`` by decreasing ``timeScale``
   gradually (starting from its current value), within the passed time interval. This method
   can be chained.

📦:isRunning() Boolean
~~~~~~~~~~~~~~~~~~~~~~~

   Returns true if the action’s ``time`` is currently running.
   In addition to being activated in the mixer (see ``isScheduled``) the
   following conditions must be fulfilled: ``paused`` is equal to false,
   ``enabled`` is equal to true, ``timeScale`` is different from
   ``0``, and there is no scheduling for a delayed start (``startAt``).

   Note: ``isRunning`` being true doesn’t necessarily mean that the animation can actually
   be seen. This is only the case, if ``weight`` is additionally set to a
   non-zero value.

📦:isScheduled() Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns true, if this action is activated in the mixer.

   Note: This doesn’t necessarily mean that the animation is actually running (compare the
   additional conditions for ``isRunning``).

📦:play() this
~~~~~~~~~~~~~~~

   Tells the mixer to activate the action. This method can be chained.

   Note: Activating this action doesn’t necessarily mean that the animation starts
   immediately: If the action had already finished before (by reaching the end of its last
   loop), or if a time for a delayed start has been set (via ``startAt``), a
   ``reset`` must be executed first. Some other settings (
   ``paused`` =true, ``enabled``=false, ``weight``=0, 
   ``timeScale`` =0) can prevent the animation from playing, too.

📦:reset() this
~~~~~~~~~~~~~~~~

   Resets the action. This method can be chained.
   This method sets ``paused`` to false, ``enabled`` to true,
   ``time`` to ``0``, interrupts any scheduled fading and warping, and removes the
   internal loop count and scheduling for delayed starting.

   Note: ``reset`` is always called by ``stop``, but ``reset`` doesn’t call
   ``stop`` itself. This means: If you want both, resetting and stopping, don’t call
   ``reset``; call ``stop`` instead.

📦:setDuration( Number durationInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the duration for a single loop of this action (by adjusting 
   ``timeScale`` and stopping any scheduled warping). This method can be chained.

📦:setEffectiveTimeScale( Number timeScale ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``timeScale`` and stops any scheduled warping. This method can be
   chained.
   If ``paused`` is false, the effective time scale (an internal property) will
   also be set to this value; otherwise the effective time scale (directly affecting the
   animation at this moment) will be set to ``0``.

   Note: ``paused`` will not be switched to ``true`` automatically, if ``timeScale`` is set
   to ``0`` by this method.

📦:setEffectiveWeight( Number weight ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``weight`` and stops any scheduled fading. This method can be chained.
   If ``enabled`` is true, the effective weight (an internal property) will
   also be set to this value; otherwise the effective weight (directly affecting the
   animation at this moment) will be set to ``0``.

   Note: ``enabled`` will not be switched to ``false`` automatically, if ``weight`` is set
   to ``0`` by this method.

📦:setLoop( Number loopMode, Number repetitions) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the `loop mode <#.loop>`__ and the number of ``repetitions``. This
   method can be chained.

📦:startAt( Number startTimeInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines the time for a delayed start (usually passed as ``AnimationMixer.time`` +
   deltaTimeInSeconds). This method can be chained.

   Note: The animation will only start at the given time, if ``startAt`` is chained with
   ``play``, or if the action has already been activated in the mixer (by a
   previous call of ``play``, without stopping or resetting it in the meantime).

📦:stop() this
~~~~~~~~~~~~~~~

   Tells the mixer to deactivate this action. This method can be chained.
   The action will be immediately stopped and completely ``reset``.

   Note: You can stop all active actions on the same mixer in one go via
   `mixer.stopAllAction <#AnimationMixer.stopAllAction>`__.

📦:stopFading() this
~~~~~~~~~~~~~~~~~~~~~

   Stops any scheduled `fading <#.fadeIn>`__ which is applied to this action. 
   This method can be chained.

📦:stopWarping() this
~~~~~~~~~~~~~~~~~~~~~~

   Stops any scheduled `warping <#.warp>`__ which is applied to this action. 
   This method can be chained.

📦:syncWith( AnimationAction otherAction ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Synchronizes this action with the passed other action. This method can be chained.
   Synchronizing is done by setting this action’s ``time`` and 
   ``timeScale`` values to the corresponding values of the other action (stopping any
   scheduled warping).

   Note: Future changes of the other action's ``time`` and ``timeScale`` will not be
   detected.

📦:warp( Number startTimeScale, Number endTimeScale, Number durationInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Changes the playback speed, within the passed time interval, by modifying 
   ``timeScale`` gradually from ``startTimeScale`` to ``endTimeScale``. This method can be
   chained.


🚀Events
~~~~~~~~~

   There are two events indicating when a single loop of the action respectively the entire
   action has finished. You can react to them with:


   .. code:: javascript

      mixer.addEventListener( 'loop', function( e ) { …} );
      // properties of e: type, action and loopDelta 

      mixer.addEventListener( 'finished', function( e ) { …} );
      // properties of e: type, action and direction




.. _D018:

AnimationClip
=============

   https://threejs.org/docs/api/en/animation/AnimationClip.html

   An ``AnimationAction`` is a reusable set of keyframe tracks which represent an animation.
   For an overview of the different elements of the three.js animation system see the
   "Animation System" article in the "Next Steps" section of the manual.

   .. Constructor

🐣:AnimationClip( String name, Number duration, Array tracks )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `name <#String>`__ - a name for this clip.
   -  `duration <#Number>`__ - the duration of this clip (in seconds). If a negative value is
      passed, the duration will be calculated from the passed ``tracks`` array.
   -  `tracks <#Array>`__ - an array of `KeyframeTracks <#KeyframeTrack>`__.
   -  `blendMode <#Number>`__ - defines how the animation is blended/combined when two or more
      animations are simultaneously played.

   Note: Instead of instantiating an AnimationClip directly with the constructor, you can
   use one of its static methods to create AnimationClips: from JSON (``parse``),
   from morph target sequences ( ``CreateFromMorphTargetSequence`` , 
   ``CreateClipsFromMorphTargetSequences`` ) or from animation hierarchies
   (``parseAnimation``) - if your model doesn't already hold
   AnimationClips in its geometry's animations array.

Properties
----------

⭕:Number blendMode
~~~~~~~~~~~~~~~~~~~~

   Defines how the animation is blended/combined when two or more animations are
   simultaneously played. Valid values are ``NormalAnimationBlendMode`` (default) and
   ``AdditiveAnimationBlendMode``.

⭕:Number duration
~~~~~~~~~~~~~~~~~~~

   The duration of this clip (in seconds). This can be calculated from the 
   ``tracks`` array via ``resetDuration``.

⭕:String name
~~~~~~~~~~~~~~~

   A name for this clip. A certain clip can be searched via ``findByName``.

⭕:Array tracks
~~~~~~~~~~~~~~~~

   An array containing a ``KeyframeTrack`` for each property that are animated by this
   clip.

⭕:String uuid
~~~~~~~~~~~~~~~

   The `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this clip
   instance. It gets automatically assigned and shouldn't be edited.

Methods
-------

📦:clone() AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a copy of this clip.

📦:optimize() this
~~~~~~~~~~~~~~~~~~~

   Optimizes each track by removing equivalent sequential keys (which are common in morph
   target sequences).

📦:resetDuration() this
~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``duration`` of the clip to the duration of its longest
   ``KeyframeTrack``.

📦:toJSON() Object
~~~~~~~~~~~~~~~~~~~

   Returns a JSON object representing the serialized animation clip.

📦:trim() this
~~~~~~~~~~~~~~~

   Trims all tracks to the clip's duration.

📦:validate() Boolean
~~~~~~~~~~~~~~~~~~~~~~

   Performs minimal validation on each track in the clip. Returns true if all tracks are
   valid.

Static Methods
--------------

📦:CreateClipsFromMorphTargetSequences( String name, Array morphTargetSequence, Number fps, Boolean noLoop ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns an array of new AnimationClips created from the morph target sequences of a
   geometry, trying to sort morph target names into animation-group-based patterns like
   "Walk_001, Walk_002, Run_001, Run_002...".

📦:CreateFromMorphTargetSequence( String name, Array morphTargetSequence, Number fps, Boolean noLoop ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a new AnimationClip from the passed morph targets array of a geometry, taking a
   name and the number of frames per second.

   Note: The fps parameter is required, but the animation speed can be overridden in an
   ``AnimationAction`` via `animationAction.setDuration <#AnimationAction.setDuration>`__.

📦:findByName( Object objectOrClipArray, String name ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Searches for an AnimationClip by name, taking as its first parameter either an array of
   AnimationClips, or a mesh or geometry that contains an array named "animations".

📦:parse( Object json ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Parses a JSON representation of a clip and returns an AnimationClip.

📦:parseAnimation( Object animation, Array bones ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Parses the animation.hierarchy format and returns an AnimationClip.

📦:toJSON( AnimationClip clip ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Takes an AnimationClip and returns a JSON object.



.. _D019:

AnimationMixer
==============

   https://threejs.org/docs/api/en/animation/AnimationMixer.html

   The AnimationMixer is a player for animations on a particular object in the scene. When
   multiple objects in the scene are animated independently, one AnimationMixer may be used
   for each object.
   For an overview of the different elements of the three.js animation system see the
   "Animation System" article in the "Next Steps" section of the manual.

   .. Constructor

🐣:AnimationMixer( Object3D rootObject )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `rootObject <#Object3D>`__ - the object whose animations shall be played by this mixer.

Properties
----------

⭕:Number time
~~~~~~~~~~~~~~~

   The global mixer time (in seconds; starting with ``0`` on the mixer's creation).

⭕:Number timeScale
~~~~~~~~~~~~~~~~~~~~

   A scaling factor for the global `mixer time <#.time>`__.

   Note: Setting the mixer's timeScale to ``0`` and later back to ``1`` is a possibility to
   pause/unpause all actions that are controlled by this mixer.

Methods
-------

📦:clipAction(AnimationClip clip, Object3D optionalRoot) AnimationAction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns an ``AnimationAction`` for the passed clip, optionally using a root object
   different from the mixer's default root. The first parameter can be either an
   ``AnimationClip`` object or the name of an AnimationClip.
   If an action fitting the clip and root parameters doesn't yet exist, it will be created
   by this method. Calling this method several times with the same clip and root parameters
   always returns the same clip instance.

📦:existingAction(AnimationClip clip, Object3D optionalRoot) AnimationAction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns an existing ``AnimationAction`` for the passed clip, optionally using a root
   object different from the mixer's default root.
   The first parameter can be either an ``AnimationClip`` object or the name of an
   AnimationClip.

📦:getRoot() Object3D
~~~~~~~~~~~~~~~~~~~~~~

   Returns this mixer's root object.

📦:stopAllAction() this
~~~~~~~~~~~~~~~~~~~~~~~~

   Deactivates all previously scheduled actions on this mixer.

📦:update(Number deltaTimeInSeconds) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Advances the global mixer time and updates the animation.
   This is usually done in the render loop, passing `clock.getDelta <#Clock.getDelta>`__
   scaled by the mixer's ``timeScale``.

📦:setTime(Number timeInSeconds) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the global mixer to a specific time and updates the animation accordingly.
   This is useful when you need to jump to an exact time in an animation. The input
   parameter will be scaled by the mixer's ``timeScale``.

📦:uncacheClip(AnimationClip clip) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Deallocates all memory resources for a clip. Before using this method make sure to call
   ``AnimationAction.stop``() for all related actions.

📦:uncacheRoot(Object3D root) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Deallocates all memory resources for a root object. Before using this method make sure to
   call ``AnimationAction.stop``() for all related actions or alternatively
   ``.stopAllAction``() when the mixer operates on a single root.

📦:uncacheAction(AnimationClip clip, Object3D optionalRoot) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Deallocates all memory resources for an action. Before using this method make sure to call
   ``AnimationAction.stop``() to deactivate the action.



.. _D020:

AnimationObjectGroup
====================

   https://threejs.org/docs/api/en/animation/AnimationObjectGroup.html

   A group of objects that receives a shared animation state.
   For an overview of the different elements of the three.js animation system see the
   "Animation System" article in the "Next Steps" section of the manual.

   **Usage:**

   Add objects you would otherwise pass as 'root' to the constructor or the
   `clipAction <#AnimationMixer.clipAction>`__ method of `AnimationMixer <#AnimationMixer>`__ 
   and instead pass this object as 'root'.

   Note that objects of this class appear as one object to the mixer, so cache control of
   the individual objects must be done on the group.

   **Limitations**

   The animated properties must be compatible among all objects in the group.
   A single property can either be controlled through a target group or directly, but not
   both.

   .. Constructor

🐣:AnimationObjectGroup( Object obj1, Object obj2, Object obj3, ...)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `obj <#Object>`__ - an arbitrary number of meshes that share the same animation state.

Properties
----------

⭕:Boolean isAnimationObjectGroup
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``AnimationObjectGroup``.

⭕:Object stats
~~~~~~~~~~~~~~~~

   An object that contains some informations of this ``AnimationObjectGroup`` (total number,
   number in use, number of bindings per object)

⭕:String uuid
~~~~~~~~~~~~~~~

   The `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this
   ``AnimationObjectGroup``. It gets automatically assigned and shouldn't be edited.

Methods
-------

📦:add( Object obj1, Object obj2, Object obj3, ... ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds an arbitrary number of objects to this ``AnimationObjectGroup``.

📦:remove( Object obj1, Object obj2, Object obj3, ... ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes an arbitrary number of objects from this ``AnimationObjectGroup``.

📦:uncache( Object obj1, Object obj2, Object obj3, ... ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Deallocates all memory resources for the passed objects of this ``AnimationObjectGroup``.



.. _D021:

AnimationUtils
==============

   https://threejs.org/docs/api/en/animation/AnimationUtils.html

   An object with various functions to assist with animations, used internally.

Methods
-------

📦:convertArray( array, type, forceClone ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts an array to a specific type.

📦:flattenJSON( jsonKeys, times, values, valuePropertyName ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Used for parsing AOS keyframe formats.

📦:getKeyframeOrder( times ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns an array by which times and values can be sorted.

📦:isTypedArray( object ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns ``true`` if the object is a typed array.

📦:makeClipAdditive( AnimationClip targetClip, Number referenceFrame, AnimationClip referenceClip, Number fps ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts the keyframes of the given animation clip to an additive format.

📦:sortedArray( values, stride, order ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sorts the array previously returned by `getKeyframeOrder <#AnimationUtils.getKeyframeOrder>`__.

📦:subclip( AnimationClip clip, String name, Number startFrame, Number endFrame, Number fps ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a new clip, containing only the segment of the original clip between the given
   frames.



.. _D022:

KeyframeTrack
=============

   https://threejs.org/docs/api/en/animation/KeyframeTrack.html

   A KeyframeTrack is a timed sequence of `keyframes <https://en.wikipedia.org/wiki/Key_frame>`__, 
   which are composed of lists of times and related values, and which are used to
   animate a specific property of an object.

   For an overview of the different elements of the three.js animation system see the
   "Animation System" article in the "Next Steps" section of the manual.

   In contrast to the animation hierarchy of the
   `JSON model format <https://github.com/mrdoob/three.js/wiki/JSON-Model-format-3>`__ a
   ``KeyframeTrack`` doesn't store its single keyframes as objects in a "keys" array (holding
   the times and the values for each frame together in one place).

   Instead of this there are always two arrays in a ``KeyframeTrack``: the 
   ``times`` array stores the time values for all keyframes of this track in sequential order,
   and the ``values`` array contains the corresponding changing values of the
   animated property.

   A single value, belonging to a certain point of time, can not only be a simple number, but
   (for example) a vector (if a position is animated) or a quaternion (if a rotation is
   animated). For this reason the values array (which is a flat array, too) might be three or
   four times as long as the times array.

   Corresponding to the different possible types of animated values there are several
   subclasses of ``KeyframeTrack``, inheriting the most properties and methods:

   -  ``BooleanKeyframeTrack``
   -  ``ColorKeyframeTrack``
   -  ``NumberKeyframeTrack``
   -  ``QuaternionKeyframeTrack``
   -  ``StringKeyframeTrack``
   -  ``VectorKeyframeTrack``

   Some examples of how to manually create `AnimationClips <#AnimationClip>`__ with different
   sorts of KeyframeTracks can be found in the
   `AnimationClipCreator <https://threejs.org/examples/jsm/animation/AnimationClipCreator.js>`__ file.

   Since explicit values are only specified for the discrete points of time stored in the
   times array, all values in between have to be interpolated.

   The track's name is important for the connection of this track with a specific property of
   the animated node (done by ``PropertyBinding``).

   .. Constructor

🐣:KeyframeTrack( String name, Array times, Array values, Constant interpolation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `name <#String>`__ - the identifier for the ``KeyframeTrack``.
   -  `times <#Array>`__ - an array of keyframe times, converted internally to a
   -  `Float32Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array>`__.
   -  `values <#Array>`__ - an array with the values related to the times array, converted
      internally to a `Float32Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array>`__.
   -  `interpolation <#Constant>`__ - the type of interpolation to use. See `Animation Constants <#Animation>`__ 
      for possible values. Default is `InterpolateLinear <#Animation>`__.

Properties
----------

⭕:String name
~~~~~~~~~~~~~~~

   The track's name can refer to morph targets or `bones <#SkinnedMesh>`__ or possibly other
   values within an animated object. See ``PropertyBinding.parseTrackName`` for the forms
   of strings that can be parsed for property binding:

   The name can specify the node either using its name or its uuid (although it needs to be
   in the subtree of the scene graph node passed into the mixer). Or, if the track name
   starts with a dot, the track applies to the root node that was passed into the mixer.

   Usually after the node a property will be specified directly. But you can also specify a
   subproperty, such as .rotation[x], if you just want to drive the X component of the
   rotation via a float track.

   You can also specify bones or multimaterials by using an object name, for example:
   .bones[R_hand].scale; the red channel of the diffuse color of the fourth material in a
   materials array - as a further example - can be accessed with .materials[3].diffuse[r].

   PropertyBinding will also resolve morph target names, for example:
   .morphTargetInfluences[run].


   Note: The track's name does not necessarily have to be unique. Multiple tracks can drive
   the same property. The result should be based on a weighted blend between the multiple
   tracks according to the weights of their respective actions.

⭕:Float32Array times
~~~~~~~~~~~~~~~~~~~~~~

   A `Float32Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array>`__, 
   converted from the times array which is passed in the constructor.

⭕:Float32Array values
~~~~~~~~~~~~~~~~~~~~~~~

   A `Float32Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array>`__, 
   converted from the values array which is passed in the constructor.

⭕:Constant DefaultInterpolation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The default interpolation type: `InterpolateLinear <#Animation>`__.

⭕:Constant TimeBufferType 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Float32Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array>`__, 
   the type of the buffer internally used for the times.

⭕:Constant ValueBufferType 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Float32Array <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array>`__, 
   the type of the buffer internally used for the values.

Methods
-------

📦:clone() KeyframeTrack
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a copy of this track.

📦:createInterpolant() Interpolant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a `LinearInterpolant <#LinearInterpolant>`__, `CubicInterpolant <#CubicInterpolant>`__ 
   or `DiscreteInterpolant <#DiscreteInterpolant>`__, depending on the
   value of the interpolation parameter passed in the constructor.

📦:getInterpolation() Interpolant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the interpolation type.

📦:getValueSize() Number
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the size of each value (that is the length of the ``values`` array
   divided by the length of the ``times`` array).

📦:InterpolantFactoryMethodDiscrete( Float32Array result ) DiscreteInterpolant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a new `DiscreteInterpolant <#DiscreteInterpolant>`__ from the
   `times <#KeyframeTrack.times>`__ and `values <#KeyframeTrack.times>`__. A Float32Array can
   be passed which will receive the results. Otherwise a new array with the appropriate size
   will be created automatically.

📦:InterpolantFactoryMethodLinear( Float32Array result ) LinearInterpolant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a new `LinearInterpolant <#LinearInterpolant>`__ from the
   `times <#KeyframeTrack.times>`__ and `values <#KeyframeTrack.times>`__. A Float32Array can
   be passed which will receive the results. Otherwise a new array with the appropriate size
   will be created automatically.

📦:InterpolantFactoryMethodSmooth( Float32Array result ) CubicInterpolant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Create a new `CubicInterpolant <#CubicInterpolant>`__ from the `times <#KeyframeTrack.times>`__ 
   and `values <#KeyframeTrack.times>`__. A Float32Array can be passed which will
   receive the results. Otherwise a new array with the appropriate size will be created
   automatically.

📦:optimize() this
~~~~~~~~~~~~~~~~~~~

   Removes equivalent sequential keys, which are common in morph target sequences.

📦:scale() this
~~~~~~~~~~~~~~~~

   Scales all keyframe times by a factor.

   Note: This is useful, for example, for conversions to a certain rate of frames per
   seconds (as it is done internally by `animationClip.CreateFromMorphTargetSequence <#AnimationClip.CreateFromMorphTargetSequence>`__).

📦:setInterpolation( Constant interpolationType ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the interpolation type. See `Animation Constants <#Animation>`__ for choices.

📦:shift( Number timeOffsetInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Moves all keyframes either forward or backward in time.

📦:trim( Number startTimeInSeconds, Number endTimeInSeconds ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes keyframes before ``startTime`` and after ``endTime``, without changing any values
   within the range [``startTime``, ``endTime``].

📦:validate() Boolean
~~~~~~~~~~~~~~~~~~~~~~

   Performs minimal validation on the tracks. Returns true if valid.

   This method logs errors to the console, if a track is empty, if the `value size <#.valueSize>`__ 
   is not valid, if an item in the ``times`` or ``values`` array
   is not a valid number or if the items in the ``times`` array are out of order.

Static Methods
--------------

📦:toJSON( KeyframeTrack track ) JSON
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts the track to JSON.



.. _D023:

PropertyBinding
===============

   https://threejs.org/docs/api/en/animation/PropertyBinding.html

   This holds a reference to a real property in the scene graph; used internally.

   .. Constructor

🐣:PropertyBinding( Object3D rootNode, path, parsedPath )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   - `rootNode <#Object3D>`__: -- path -- parsedPath (optional)

Properties
----------

⭕:Number path
~~~~~~~~~~~~~~~

⭕:Number parsedPath
~~~~~~~~~~~~~~~~~~~~~

⭕:Number node
~~~~~~~~~~~~~~~

⭕:Number rootNode
~~~~~~~~~~~~~~~~~~~

⭕:Object BindingType
~~~~~~~~~~~~~~~~~~~~~~

⭕:Object Versioning
~~~~~~~~~~~~~~~~~~~~~

⭕:Array GetterByBindingType
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:Array SetterByBindingTypeAndVersioning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Methods
-------

📦:getValue( Array targetArray, Number offset ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📦:setValue( Array sourceArray, Number offset ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📦:bind( ) undefined
~~~~~~~~~~~~~~~~~~~~~

   Create getter / setter pair for a property in the scene graph. Used internally by
   `getValue <#PropertyBinding.getValue>`__ and `setValue <#PropertyBinding.setValue>`__.

📦:unbind( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Unbind getter / setter pair for a property in the scene graph.

📦:Composite( targetGroup, path, optionalParsedPath ) Constructor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Create a new Composite PropertyBinding.

📦:create( root, path, parsedPath ) Constructor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Create a new Composite PropertyBinding (if root is an ``AnimationObjectGroup``) or
   PropertyBinding.

📦:parseTrackName( trackName ) Constructor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Matches strings in the following forms:

   ::

      -- nodeName.property
      -- nodeName.property[accessor]
      -- nodeName.material.property[accessor]
      -- uuid.property[accessor]
      -- uuid.objectName[objectIndex].propertyName[propertyIndex]
      -- parentName/nodeName.property
      -- parentName/parentName/nodeName.property[index]
      -- .bone[Armature.DEF_cog].position
      -- scene:helium_balloon_model:helium_balloon_model.position

📦:findNode( root, nodeName ) Constructor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Find a node in a node tree or `Skeleton <#Skeleton>`__.



.. _D024:

PropertyMixer
=============

   https://threejs.org/docs/api/en/animation/PropertyMixer.html

   Buffered scene graph property that allows weighted accumulation; used internally.

   .. Constructor

🐣:PropertyMixer( PropertyBinding binding, String typeName, Number valueSize )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -- binding
   -- typeName
   -- valueSize

Properties
----------

⭕:PropertyBinding binding
~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:TypedArray buffer
~~~~~~~~~~~~~~~~~~~~~

   Buffer with size `valueSize <#PropertyMixer>`__ `` 4.
   This has the layout: [ incoming \| accu0 \| accu1 \| orig ]
   Interpolators can use .buffer as their .result and the data then goes to 'incoming'.
   'accu0' and 'accu1' are used frame-interleaved for the cumulative result and are
   compared to detect changes. 'orig' stores the original state of the property.

⭕:Number cumulativeWeight
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``0``.

⭕:Number cumulativeWeightAdditive
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``0``.

⭕:Number valueSize
~~~~~~~~~~~~~~~~~~~~

⭕:Number referenceCount
~~~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``0``.

⭕:Number useCount
~~~~~~~~~~~~~~~~~~~

   Default is ``0``.

Methods
-------

📦:accumulate( Number accuIndex, Number weight ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Accumulate data in `buffer <#PropertyMixer.buffer>`__[accuIndex] 'incoming' region into
   'accu[i]'.
   If weight is ``0`` this does nothing.

📦:accumulateAdditive( Number weight ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Accumulate data in the 'incoming' region into 'add'.
   If weight is ``0`` this does nothing.

📦:apply( Number accuIndex ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Apply the state of `buffer <#PropertyMixer.buffer>`__ 'accu[i]' to the binding when accus
   differ.

📦:saveOriginalState( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Remember the state of the bound property and copy it to both accus.

📦:restoreOriginalState( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Apply the state previously taken via 'saveOriginalState' to the binding.



.. _D025:

KeyframeTrack → BooleanKeyframeTrack
====================================

   https://threejs.org/docs/api/en/animation/tracks/BooleanKeyframeTrack.html

   A Track of boolean keyframe values.

   .. Constructor

🐣:BooleanKeyframeTrack( String name, Array times, Array values )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `name <#String>`__ - (required) identifier for the KeyframeTrack.
   `times <#Array>`__ - (required) array of keyframe times.
   `values <#Array>`__ - values for the keyframes at the times specified.

   This keyframe track type has no interpolation parameter because the interpolation is
   always `InterpolateDiscrete <#Animation>`__.

Properties
----------

   See ``KeyframeTrack`` for inherited properties.

⭕:Constant DefaultInterpolation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The default interpolation type to use. Only `InterpolateDiscrete <#Animation>`__ is valid
   for this track type.

⭕:Array ValueBufferType
~~~~~~~~~~~~~~~~~~~~~~~~~

   A normal Array (no Float32Array in this case, unlike ``ValueBufferType`` of
   ``KeyframeTrack``).

⭕:String ValueTypeName
~~~~~~~~~~~~~~~~~~~~~~~~

   String 'bool'.

Methods
-------

   See ``KeyframeTrack`` for inherited methods.

📦:InterpolantFactoryMethodLinear () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The value of this method here is 'undefined', as it does not make sense for discrete
   properties.

📦:InterpolantFactoryMethodSmooth () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The value of this method here is 'undefined', as it does not make sense for discrete
   properties.



.. _D026:

KeyframeTrack → ColorKeyframeTrack
==================================

   https://threejs.org/docs/api/en/animation/tracks/ColorKeyframeTrack.html

   A Track of keyframe values that represent color changes.
   The very basic implementation of this subclass has nothing special yet. However, this is
   the place for color space parameterization.

   .. Constructor

🐣:ColorKeyframeTrack( String name, Array times, Array values, Constant interpolation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `name <#String>`__ - (required) identifier for the KeyframeTrack.
   `times <#Array>`__ - (required) array of keyframe times.
   `values <#Array>`__ - values for the keyframes at the times specified, a flat array of
   color components between ``0`` and ``1``.
   `interpolation <#Constant>`__ - the type of interpolation to use. See `Animation Constants <#Animation>`__ 
   for possible values. Default is `InterpolateLinear <#Animation>`__.

Properties
----------

   See ``KeyframeTrack`` for inherited properties.

⭕:String ValueTypeName
~~~~~~~~~~~~~~~~~~~~~~~~

   String 'color'.

Methods
-------

   See ``KeyframeTrack`` for inherited methods.



.. _D027:

KeyframeTrack → NumberKeyframeTrack
===================================

   https://threejs.org/docs/api/en/animation/tracks/NumberKeyframeTrack.html

   A Track of numeric keyframe values.

   .. Constructor

🐣:NumberKeyframeTrack( String name, Array times, Array values, Constant interpolation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `name <#String>`__ - (required) identifier for the KeyframeTrack.
   `times <#Array>`__ - (required) array of keyframe times.
   `values <#Array>`__ - values for the keyframes at the times specified.
   `interpolation <#Constant>`__ - the type of interpolation to use. See `Animation Constants <#Animation>`__ 
   for possible values. Default is `InterpolateLinear <#Animation>`__.

Properties
----------

   See ``KeyframeTrack`` for inherited properties.

⭕:String ValueTypeName
~~~~~~~~~~~~~~~~~~~~~~~~

   String 'number'.

Methods
-------

   See ``KeyframeTrack`` for inherited methods.



.. _D028:

KeyframeTrack → QuaternionKeyframeTrack
=======================================

   https://threejs.org/docs/api/en/animation/tracks/QuaternionKeyframeTrack.html

   A Track of quaternion keyframe values.

   .. Constructor

🐣:QuaternionKeyframeTrack( String name, Array times, Array values, Constant interpolation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `name <#String>`__ - (required) identifier for the KeyframeTrack.
   `times <#Array>`__ - (required) array of keyframe times.
   `values <#Array>`__ - values for the keyframes at the times specified, a flat array of
   quaternion components.
   `interpolation <#Constant>`__ - the type of interpolation to use. See `Animation Constants <#Animation>`__ 
   for possible values. Default is `InterpolateLinear <#Animation>`__.

Properties
----------

   See ``KeyframeTrack`` for inherited properties.

⭕:Constant DefaultInterpolation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The default interpolation type to use, `InterpolateLinear <#Animation>`__.

⭕:String ValueTypeName
~~~~~~~~~~~~~~~~~~~~~~~~

   String 'quaternion'.

Methods
-------

   See ``KeyframeTrack`` for inherited methods.

📦:InterpolantFactoryMethodLinear() QuaternionLinearInterpolant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a new `QuaternionLinearInterpolant <#QuaternionLinearInterpolant>`__ based on the
   `values <#KeyframeTrack.values>`__, `times <#KeyframeTrack.times>`__ and
   `valueSize <#KeyframeTrack.valueSize>`__ of the keyframes.



.. _D029:

KeyframeTrack → StringKeyframeTrack
===================================

   https://threejs.org/docs/api/en/animation/tracks/StringKeyframeTrack.html

   A Track of string keyframe values.

   .. Constructor

🐣:StringKeyframeTrack( String name, Array times, Array values )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `name <#String>`__ - (required) identifier for the KeyframeTrack.
   `times <#Array>`__ - (required) array of keyframe times.
   `values <#Array>`__ - values for the keyframes at the times specified.

   This keyframe track type has no interpolation parameter because the interpolation is
   always `InterpolateDiscrete <#Animation>`__.

Properties
----------

   See ``KeyframeTrack`` for inherited properties.

⭕:Constant DefaultInterpolation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The default interpolation type to use. Only `InterpolateDiscrete <#Animation>`__ is valid
   for this track type.

⭕:Array ValueBufferType
~~~~~~~~~~~~~~~~~~~~~~~~~

   A normal Array (no Float32Array in this case, unlike ``ValueBufferType`` of
   ``KeyframeTrack``).

⭕:String ValueTypeName
~~~~~~~~~~~~~~~~~~~~~~~~

   String 'string'.

Methods
-------

   See ``KeyframeTrack`` for inherited methods.

📦:InterpolantFactoryMethodLinear() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The value of this method here is 'undefined', as it does not make sense for discrete
   properties.

📦:InterpolantFactoryMethodSmooth() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The value of this method here is 'undefined', as it does not make sense for discrete
   properties.



.. _D030:

KeyframeTrack → VectorKeyframeTrack
===================================

   https://threejs.org/docs/api/en/animation/tracks/VectorKeyframeTrack.html

   A Track of vector keyframe values.

   .. Constructor

🐣:VectorKeyframeTrack( String name, Array times, Array values, Constant interpolation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `name <#String>`__ - (required) identifier for the KeyframeTrack.
   `times <#Array>`__ - (required) array of keyframe times.
   `values <#Array>`__ - values for the keyframes at the times specified, a flat array of
   vector components.
   `interpolation <#Constant>`__ - the type of interpolation to use. See `Animation Constants <#Animation>`__ 
   for possible values. Default is `InterpolateLinear <#Animation>`__.

Properties
----------

   See ``KeyframeTrack`` for inherited properties.

⭕:String ValueTypeName
~~~~~~~~~~~~~~~~~~~~~~~~

   String 'vector'.

Methods
-------

   See ``KeyframeTrack`` for inherited methods.



.. _D031:

Object3D → Audio
================

   https://threejs.org/docs/api/en/audio/Audio.html

   Create a non-positional ( global ) audio object.
   This uses the `Web Audio API <https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API>`__.

   **Code Example**


   .. code:: javascript

      // create an AudioListener and add it to the camera 
      const listener = new THREE.AudioListener();
      camera.add( listener );
      // create a global audio source 
      const sound = new THREE.Audio( listener );
      // load a sound and set it as the Audio object's buffer 
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load( 'sounds/ambient.ogg', function( buffer ) { 
         sound.setBuffer( buffer );
         sound.setLoop( true );
         sound.setVolume( 0.5 );
         sound.play();
      });


   **Examples**

   [example:webaudio_sandbox webaudio / sandbox ]
   [example:webaudio_visualizer webaudio / visualizer ]

   .. Constructor

🐣:Audio( AudioListener listener )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   listener — (required) `AudioListener <#AudioListener>`__ instance.

Properties
----------

⭕:Boolean autoplay
~~~~~~~~~~~~~~~~~~~~

   Whether to start playback automatically. Default is ``false``.

⭕:AudioContext context
~~~~~~~~~~~~~~~~~~~~~~~~

   The `AudioContext <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext>`__ of
   the `listener <#AudioListener>`__ given in the constructor.

⭕:Number detune
~~~~~~~~~~~~~~~~~

   Modify pitch, measured in cents. +/- 100 is a semitone. +/- 1200 is an octave.
   Default is ``0``.

⭕:Array filters
~~~~~~~~~~~~~~~~~

   Represents an array of `AudioNodes <https://developer.mozilla.org/en-US/docs/Web/API/AudioNode>`__. 
   Can be used to apply a variety of low-order filters to create more complex
   sound effects. In most cases, the array contains instances of ``BiquadFilterNodes``. 
   Filters are set via ``Audio.setFilter`` or `Audio.setFilters <https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode>`__.

⭕:GainNode gain
~~~~~~~~~~~~~~~~~

   A `GainNode <https://developer.mozilla.org/en-US/docs/Web/API/GainNode>`__ created using
   `AudioContext.createGain <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createGain>`__().

⭕:Boolean hasPlaybackControl
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether playback can be controlled using the `play <#Audio.play>`__(), 
   `pause <#Audio.pause>`__() etc. methods. Default is ``true``.

⭕:Boolean isPlaying
~~~~~~~~~~~~~~~~~~~~~

   Whether the audio is currently playing.

⭕:AudioListener listener
~~~~~~~~~~~~~~~~~~~~~~~~~~

   A reference to the listener object of this audio.

⭕:Number playbackRate
~~~~~~~~~~~~~~~~~~~~~~~

   Speed of playback. Default is ``1``.

⭕:Number offset
~~~~~~~~~~~~~~~~~

   An offset to the time within the audio buffer that playback should begin. Same as the
   ``offset`` parameter of
   `AudioBufferSourceNode.start <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/start>`__(). 
   Default is ``0``.

⭕:Number duration
~~~~~~~~~~~~~~~~~~~

   Overrides the duration of the audio. Same as the ``duration`` parameter of
   `AudioBufferSourceNode.start <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/start>`__(). 
   Default is ``undefined`` to play the whole buffer.

⭕:AudioNode source
~~~~~~~~~~~~~~~~~~~~

   An `AudioBufferSourceNode <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode>`__ 
   created using `AudioContext.createBufferSource <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createBufferSource>`__().

⭕:String sourceType
~~~~~~~~~~~~~~~~~~~~~

   Type of the audio source. Default is string 'empty'.

⭕:String type
~~~~~~~~~~~~~~~

   String denoting the type, set to 'Audio'.

Methods
-------

📦:connect() this
~~~~~~~~~~~~~~~~~~

   Connect to the ``Audio.source``. This is used internally on initialisation and when
   setting / removing filters.

📦:disconnect() this
~~~~~~~~~~~~~~~~~~~~~

   Disconnect from the ``Audio.source``. This is used internally when setting / removing
   filters.

📦:getDetune() Float
~~~~~~~~~~~~~~~~~~~~~

   Returns the detuning of oscillation in cents.

📦:getFilter() BiquadFilterNode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the first element of the `filters <#Audio.filters>`__ array.

📦:getFilters() Array
~~~~~~~~~~~~~~~~~~~~~~

   Returns the `filters <#Audio.filters>`__ array.

📦:getLoop() Boolean
~~~~~~~~~~~~~~~~~~~~~

   Return the value of `source.loop <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loop>`__ 
   (whether playback should loop).

📦:getOutput() GainNode
~~~~~~~~~~~~~~~~~~~~~~~~

   Return the `gainNode <#Audio.gain>`__.

📦:getPlaybackRate() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return the value of `playbackRate <#Audio.playbackRate>`__.

📦:getVolume( value ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return the current volume.

📦:play( delay ) this
~~~~~~~~~~~~~~~~~~~~~~

   If `hasPlaybackControl <#Audio.hasPlaybackControl>`__ is true, starts playback.

📦:pause() this
~~~~~~~~~~~~~~~~

   If `hasPlaybackControl <#Audio.hasPlaybackControl>`__ is true, pauses playback.

📦:onEnded() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Called automatically when playback finished.

📦:setBuffer( audioBuffer ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Setup the `source <#Audio.source>`__ to the audioBuffer, and 
   sets `sourceType <#Audio.sourceType>`__ to 'buffer'.
   If `autoplay <#Audio.autoplay>`__, also starts playback.

📦:setDetune( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines the detuning of oscillation in cents.

📦:setFilter( filter ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies a single filter node to the audio.

📦:setFilters( Array value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   value - arrays of filters.
   Applies an array of filter nodes to the audio.

📦:setLoop( Boolean value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set `source.loop <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loop>`__ 
   to ``value`` (whether playback should loop).

📦:setLoopStart( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set `source.loopStart <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loopStart>`__ 
   to ``value``.

📦:setLoopEnd( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set `source.loopEnd <https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loopEnd>`__ 
   to ``value``.

📦:setMediaElementSource( mediaElement ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the given object of type `HTMLMediaElement <https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement>`__ 
   as the source of this audio.
   Also sets `hasPlaybackControl <#Audio.hasPlaybackControl>`__ to false.

📦:setMediaStreamSource( mediaStream ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the given object of type
   `MediaStream <https://developer.mozilla.org/en-US/docs/Web/API/MediaStream>`__ as the
   source of this audio.
   Also sets `hasPlaybackControl <#Audio.hasPlaybackControl>`__ to false.

📦:setNodeSource( audioNode ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Setup the `source <#Audio.source>`__ to the audioBuffer, and sets `sourceType <#Audio.sourceType>`__ 
   to 'audioNode'.
   Also sets `hasPlaybackControl <#Audio.hasPlaybackControl>`__ to false.

📦:setPlaybackRate( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If `hasPlaybackControl <#Audio.hasPlaybackControl>`__ is enabled, set the
   `playbackRate <#Audio.playbackRate>`__ to ``value``.

📦:setVolume( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the volume.

📦:stop() this
~~~~~~~~~~~~~~~

   If `hasPlaybackControl <#Audio.hasPlaybackControl>`__ is enabled, stops playback.



.. _D032:

AudioAnalyser
=============

   https://threejs.org/docs/api/en/audio/AudioAnalyser.html

   Create a AudioAnalyser object, which uses an
   `AnalyserNode <https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode>`__ 
   to analyse audio data.
   This uses the `Web Audio API <https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API>`__.

   **Code Example**


   .. code:: javascript

      // create an AudioListener and add it to the camera
      const listener = new THREE.AudioListener();
      camera.add( listener );

      // create an Audio source
      const sound = new THREE.Audio( listener );

      // load a sound and set it as the Audio object's buffer
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load( 'sounds/ambient.ogg', function( buffer ) {
         sound.setBuffer( buffer );
         sound.setLoop(true);
         sound.setVolume(0.5);
         sound.play();
      });

      // create an AudioAnalyser, passing in the sound and desired fftSize
      const analyser = new THREE.AudioAnalyser( sound, 32 );

      // get the average frequency of the sound
      const data = analyser.getAverageFrequency();


   **Examples**

   [example:webaudio_sandbox webaudio / sandbox ]
   [example:webaudio_visualizer webaudio / visualizer ]

   .. Constructor

🐣:AudioAnalyser( audio, fftSize )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Create a new `AudioAnalyser <#AudioAnalyser>`__.

Properties
----------

⭕:AnalyserNode analyser
~~~~~~~~~~~~~~~~~~~~~~~~~

   An `AnalyserNode <https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode>`__ used
   to analyze audio.

⭕:Integer fftSize
~~~~~~~~~~~~~~~~~~~

   A non-zero power of two up to 2048, representing the size of the FFT (Fast Fourier
   Transform) to be used to determine the frequency domain. See
   `this page <https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize>`__ for
   details.

⭕:Uint8Array data
~~~~~~~~~~~~~~~~~~~

   A Uint8Array with size determined by
   `analyser.frequencyBinCount <https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount>`__ 
   used to hold analysis data.

Methods
-------

📦:getFrequencyData() Uint8Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Uses the Web Audio's
   `getByteFrequencyData <https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData>`__ 
   method. See that page.

📦:getAverageFrequency() Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get the average of the frequencies returned by the `getFrequencyData <#AudioAnalyser.getFrequencyData>`__ method.



.. _D033:

AudioContext
============

   https://threejs.org/docs/api/en/audio/AudioContext.html

   This contains methods for setting up an
   `AudioContext <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext>`__.
   Used internally by the `AudioListener <#AudioListener>`__ and `AudioLoader <#AudioLoader>`__ classes.
   This uses the `Web Audio API <https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API>`__.

Methods
-------

📦:getContext() AudioContext
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return the value of the variable ``context`` in the outer scope, if defined, otherwise set
   it to a new `AudioContext <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext>`__.

📦:setContext( AudioContext value ) AudioContext
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the variable ``context`` in the outer scope to ``value``.



.. _D034:

Object3D → AudioListener
========================

   https://threejs.org/docs/api/en/audio/AudioListener.html

   The ``AudioAnalyser`` represents a virtual
   `listener <https://developer.mozilla.org/en-US/docs/Web/API/AudioListener>`__ of the
   all positional and non-positional audio effects in the scene.
   A three.js application usually creates a single instance of ``AudioAnalyser``. It is a mandatory
   constructor parameter for audios entities like `Audio <#Audio>`__ and
   `PositionalAudio <#PositionalAudio>`__.
   In most cases, the listener object is a child of the camera. So the 3D transformation of
   the camera represents the 3D transformation of the listener.

   **Code Example**


   .. code:: javascript

      // create an AudioListener and add it to the camera
      const listener = new THREE.AudioListener();
      camera.add( listener );

      // create a global audio source
      const sound = new THREE.Audio( listener );

      // load a sound and set it as the Audio object's buffer
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load( 'sounds/ambient.ogg', function( buffer ) {
         sound.setBuffer( buffer );
         sound.setLoop(true);
         sound.setVolume(0.5);
         sound.play();
      });


   **Examples**

   [example:webaudio_sandbox webaudio / sandbox ]
   [example:webaudio_timing webaudio / timing ]
   [example:webaudio_visualizer webaudio / visualizer ]

   .. Constructor


🐣:AudioListener( )
~~~~~~~~~~~~~~~~~~

   Create a new AudioListener.

Properties
----------

⭕:AudioContext context
~~~~~~~~~~~~~~~~~~~~~~~~

   The `AudioContext <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext>`__ of
   the `listener <#AudioListener>`__ given in the constructor.

⭕:GainNode gain
~~~~~~~~~~~~~~~~~

   A `GainNode <https://developer.mozilla.org/en-US/docs/Web/API/GainNode>`__ created using
   `AudioContext.createGain <https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createGain>`__().

⭕:AudioNode filter
~~~~~~~~~~~~~~~~~~~~

   Default is ``null``.

⭕:Number timeDelta
~~~~~~~~~~~~~~~~~~~~

   Time delta value for audio entities. Use in context of
   `AudioParam.linearRampToValueAtTimeDefault <https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/linearRampToValueAtTime>`__(). 

Methods
-------

📦:getInput() GainNode
~~~~~~~~~~~~~~~~~~~~~~~

   Return the `gainNode <#AudioListener.gain>`__.

📦:removeFilter() this
~~~~~~~~~~~~~~~~~~~~~~~

   Set the `filter <#AudioListener.filter>`__ property to ``null``.

📦:getFilter() AudioNode
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the value of the `filter <#AudioListener.filter>`__ property.

📦:setFilter( AudioNode value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the `filter <#AudioListener.filter>`__ property to ``value``.

📦:getMasterVolume() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return the volume.

📦:setMasterVolume( Number value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the volume.



.. _D035:

Object3D → Audio → PositionalAudio
==================================

   https://threejs.org/docs/api/en/audio/PositionalAudio.html

   Create a positional audio object.
   This uses the `Web Audio API <https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API>`__.

   **Code Example**


   .. code:: javascript

      // create an AudioListener and add it to the camera
      const listener = new THREE.AudioListener();
      camera.add( listener );

      // create the PositionalAudio object (passing in the listener)
      const sound = new THREE.PositionalAudio( listener );

      // load a sound and set it as the PositionalAudio object's buffer
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load( 'sounds/song.ogg', function( buffer ) {
         sound.setBuffer( buffer );
         sound.setRefDistance( 20 );
         sound.play();
      });

      // create an object for the sound to play from
      const sphere = new THREE.SphereGeometry( 20, 32, 16 );
      const material = new THREE.MeshPhongMaterial( { color: 0xff2200 } );
      const mesh = new THREE.Mesh( sphere, material );
      scene.add( mesh );

      // finally add the sound to the mesh
      mesh.add( sound );


   **Examples**

   [example:webaudio_orientation webaudio / orientation ]
   [example:webaudio_sandbox webaudio / sandbox ]
   [example:webaudio_timing webaudio / timing ]

   .. Constructor

🐣:PositionalAudio( AudioListener listener )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   listener — (required) `AudioListener <#AudioListener>`__ instance.

Properties
----------

   See the `Audio <#Audio>`__ class for inherited properties.

⭕:PannerNode panner
~~~~~~~~~~~~~~~~~~~~~

   The PositionalAudio's `PannerNode <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode>`__.

Methods
-------

   See the `Audio <#Audio>`__ class for inherited methods.

📦:getOutput() PannerNode
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the `panner <#PositionalAudio.panner>`__.

📦:getRefDistance() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the value of
   `panner.refDistance <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance>`__.

📦:setRefDistance( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the value of
   `panner.refDistance <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance>`__.

📦:getRolloffFactor() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the value of
   `panner.rolloffFactor <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor>`__.

📦:setRolloffFactor( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the value of
   `panner.rolloffFactor <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor>`__.

📦:getDistanceModel() String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the value of
   `panner.distanceModel <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel>`__.

📦:setDistanceModel( String value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the value of
   `panner.distanceModel <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel>`__.

📦:getMaxDistance() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the value of
   `panner.maxDistance <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance>`__.

📦:setMaxDistance( Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the value of
   `panner.maxDistance <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance>`__.

📦:setDirectionalCone( Float coneInnerAngle, Float coneOuterAngle, Float coneOuterGain ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This method can be used in order to transform an omnidirectional sound into a
   `directional sound <https://developer.mozilla.org/en-US/docs/Web/API/PannerNode>`__.



.. _D036:

Object3D → Camera → PerspectiveCamera → ArrayCamera
===================================================

   https://threejs.org/docs/api/en/cameras/ArrayCamera.html

   ``PositionalAudio`` can be used in order to efficiently render a scene with a predefined set of
   cameras. This is an important performance aspect for rendering VR scenes.
   An instance of ``PositionalAudio`` always has an array of sub cameras. It's mandatory to define for
   each sub camera the ``viewport`` property which determines the part of the viewport that
   is rendered with this camera.

   **Examples**

   [example:webgl_camera_array camera / array ]

   .. Constructor

🐣:ArrayCamera( Array array )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An array of cameras.

Properties
----------

   See the base ``PerspectiveCamera`` class for common properties.

⭕:Array cameras
~~~~~~~~~~~~~~~~~

   An array of cameras.

⭕:Boolean isArrayCamera
~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``ArrayCamera``.

Methods
-------

   See the base ``PerspectiveCamera`` class for common methods.



.. _D037:

Object3D → Camera
=================

   https://threejs.org/docs/api/en/cameras/Camera.html

   Abstract base class for cameras. This class should always be inherited when you build a
   new camera.

   .. Constructor


🐣:Camera()
~~~~~~~~~~

   Creates a new ``Camera``. Note that this class is not intended to be called directly; you
   probably want a ``PerspectiveCamera`` or ``OrthographicCamera`` instead.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Boolean isCamera
~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Camera``.

⭕:Layers layers
~~~~~~~~~~~~~~~~~

   The `layers <#Layers>`__ that the camera is a member of. This is an inherited property
   from ``Object3D``.
   Objects must share at least one layer with the camera to be seen when the camera's
   viewpoint is rendered.

⭕:Matrix4 matrixWorldInverse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world
   transform of the Camera.

⭕:Matrix4 projectionMatrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is the matrix which contains the projection.

⭕:Matrix4 projectionMatrixInverse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The inverse of projectionMatrix.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:clone( ) Camera
~~~~~~~~~~~~~~~~~~~

   Return a new camera with the same properties as this one.

📦:copy( Camera source, Boolean recursive ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copy the properties from the source camera into this one.

📦:getWorldDirection( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a ``Vector3`` representing the world space direction in which the camera is
   looking. (Note: A camera looks down its local, negative z-axis).



.. _D038:

Object3D → CubeCamera
=====================

   https://threejs.org/docs/api/en/cameras/CubeCamera.html

   Creates 6 cameras that render to a ``WebGLCubeRenderTarget``.

   **Code Example**


   .. code:: javascript

      // Create cube render target
      const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 128, 
            { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );

      // Create cube camera
      const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
      scene.add( cubeCamera );

      // Create car
      const chromeMaterial = new THREE.MeshLambertMaterial( { 
         color: 0xffffff, 
         envMap: cubeRenderTarget.texture 
      } );

      const car = new THREE.Mesh( carGeometry, chromeMaterial );
      scene.add( car );

      // Update the render target cube
      car.visible = false;
      cubeCamera.position.copy( car.position );
      cubeCamera.update( renderer, scene );

      // Render the scene
      car.visible = true;
      renderer.render( scene, camera );


   **Examples**

   [example:webgl_materials_cubemap_dynamic materials / cubemap / dynamic ]

   .. Constructor

🐣:CubeCamera( Number near, Number far, WebGLCubeRenderTarget renderTarget )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   near -- The near clipping distance.
   far -- The far clipping distance.
   renderTarget -- The destination cube render target.

   Constructs a CubeCamera that contains 6 `PerspectiveCameras <#PerspectiveCamera>`__ that
   render to a ``WebGLCubeRenderTarget``.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:WebGLCubeRenderTarget renderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The destination cube render target.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:update( WebGLRenderer renderer, Scene scene ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   renderer -- The current WebGL renderer
   scene -- The current scene

   Call this to update the `renderTarget <#CubeCamera.renderTarget>`__.



.. _D039:

Object3D → Camera → OrthographicCamera
======================================

   https://threejs.org/docs/api/en/cameras/OrthographicCamera.html

   Camera that uses `orthographic projection <https://en.wikipedia.org/wiki/Orthographic_projection>`__.
   In this projection mode, an object's size in the rendered image stays constant
   regardless of its distance from the camera.
   This can be useful for rendering 2D scenes and UI elements, amongst other things.

   **Code Example**


   .. code:: javascript

      const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
      scene.add( camera );


   **Examples**

   [example:webgl_camera camera ]
   [example:webgl_interactive_cubes_ortho interactive / cubes / ortho ]
   [example:webgl_materials_cubemap_dynamic materials / cubemap / dynamic]
   [example:webgl_postprocessing_advanced postprocessing / advanced ]
   [example:webgl_postprocessing_dof2 postprocessing / dof2 ]
   [example:webgl_postprocessing_godrays postprocessing / godrays ]
   [example:webgl_rtt rtt ]
   [example:webgl_shadowmap shadowmap ]

   .. Constructor

🐣:OrthographicCamera( Number left, Number right, Number top, Number bottom, Number near, Number far )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   left — Camera frustum left plane.
   right — Camera frustum right plane.
   top — Camera frustum top plane.
   bottom — Camera frustum bottom plane.
   near — Camera frustum near plane.
   far — Camera frustum far plane.
   Together these define the camera's `viewing frustum <https://en.wikipedia.org/wiki/Viewing_frustum>`__.

Properties
----------

   See the base ``Camera`` class for common properties.
   Note that after making changes to most of these properties you will have to call
   `.updateProjectionMatrix <#OrthographicCamera.updateProjectionMatrix>`__ for the changes
   to take effect.

⭕:Float bottom
~~~~~~~~~~~~~~~~

   Camera frustum bottom plane.

⭕:Float far
~~~~~~~~~~~~~

   Camera frustum far plane. Default is ``2000``.
   Must be greater than the current value of ``near`` plane.

⭕:Boolean isOrthographicCamera
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``OrthographicCamera``.

⭕:Float left
~~~~~~~~~~~~~~

   Camera frustum left plane.

⭕:Float near
~~~~~~~~~~~~~~

   Camera frustum near plane. Default is ``0.1``.
   The valid range is between ``0`` and the current value of the ``far`` plane.
   Note that, unlike for the ``PerspectiveCamera``, ``0`` is a valid value for an
   OrthographicCamera's near plane.

⭕:Float right
~~~~~~~~~~~~~~~

   Camera frustum right plane.

⭕:Float top
~~~~~~~~~~~~~

   Camera frustum top plane.

⭕:Object view
~~~~~~~~~~~~~~~

   Set by `setViewOffset <#OrthographicCamera.setViewOffset>`__. Default is ``null``.

⭕:number zoom
~~~~~~~~~~~~~~~

   Gets or sets the zoom factor of the camera. Default is ``1``.

Methods
-------

   See the base ``Camera`` class for common methods.

📦:setViewOffset( Float fullWidth, Float fullHeight, Float x, Float y, Float width, Float height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   fullWidth — full width of multiview setup
   fullHeight — full height of multiview setup
   x — horizontal offset of subcamera
   y — vertical offset of subcamera
   width — width of subcamera
   height — height of subcamera
   Sets an offset in a larger `viewing frustum <https://en.wikipedia.org/wiki/Viewing_frustum>`__. 
   This is useful for multi-window or multi-monitor/multi-machine setups. For an
   example on how to use it see `PerspectiveCamera <#PerspectiveCamera.setViewOffset>`__.

📦:clearViewOffset() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes any offset set by the .setViewOffset method.

📦:updateProjectionMatrix() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the camera projection matrix. Must be called after any change of parameters.

📦:toJSON(Object meta) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- object containing metadata such as textures or images in objects' descendants.
   Convert the camera to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.



.. _D040:

Object3D → Camera → PerspectiveCamera
=====================================

   https://threejs.org/docs/api/en/cameras/PerspectiveCamera.html

   Camera that uses `perspective projection <https://en.wikipedia.org/wiki/Perspective_(graphical)>`__.
   This projection mode is designed to mimic the way the human eye sees. It is the most
   common projection mode used for rendering a 3D scene.

   **Code Example**


   .. code:: javascript

      const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
      scene.add( camera );


   **Examples**

   [example:webgl_animation_skinning_blending animation / skinning / blending]
   [example:webgl_animation_skinning_morph animation / skinning / morph ]
   [example:webgl_effects_stereo effects / stereo ]
   [example:webgl_interactive_cubes interactive / cubes ]
   [example:webgl_loader_collada_skinning loader / collada / skinning ]

   .. Constructor

🐣:PerspectiveCamera( Number fov, Number aspect, Number near, Number far )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   fov — Camera frustum vertical field of view.
   aspect — Camera frustum aspect ratio.
   near — Camera frustum near plane.
   far — Camera frustum far plane.
   Together these define the camera's `viewing frustum <https://en.wikipedia.org/wiki/Viewing_frustum>`__.

Properties
----------

   See the base ``Camera`` class for common properties.
   Note that after making changes to most of these properties you will have to call
   `.updateProjectionMatrix <#PerspectiveCamera.updateProjectionMatrix>`__ for the changes
   to take effect.

⭕:Float aspect
~~~~~~~~~~~~~~~~

   Camera frustum aspect ratio, usually the canvas width / canvas height. Default is ``1``
   (square canvas).

⭕:Float far
~~~~~~~~~~~~~

   Camera frustum far plane. Default is ``2000``.
   Must be greater than the current value of ``near`` plane.

⭕:Float filmGauge
~~~~~~~~~~~~~~~~~~~

   Film size used for the larger axis. Default is ``35`` (millimeters). This parameter does
   not influence the projection matrix unless .filmOffset is set to a nonzero value.

⭕:Float filmOffset
~~~~~~~~~~~~~~~~~~~~

   Horizontal off-center offset in the same unit as ``.filmGauge``. Default is ``0``.

⭕:Float focus
~~~~~~~~~~~~~~~

   Object distance used for stereoscopy and depth-of-field effects. This parameter does not
   influence the projection matrix unless a ``StereoCamera`` is being used.
   Default is ``10``.

⭕:Float fov
~~~~~~~~~~~~~

   Camera frustum vertical field of view, from bottom to top of view, in degrees.
   Default is ``50``.

⭕:Boolean isPerspectiveCamera
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``PerspectiveCamera``.

⭕:Float near
~~~~~~~~~~~~~~

   Camera frustum near plane. Default is ``0.1``.
   The valid range is greater than ``0`` and less than the current value of the 
   ``far`` plane. Note that, unlike for the ``OrthographicCamera``, ``0`` is *not* a valid
   value for a PerspectiveCamera's near plane.

⭕:Object view
~~~~~~~~~~~~~~~

   Frustum window specification or null. This is set using the
   `.setViewOffset <#PerspectiveCamera.setViewOffset>`__ method and cleared using
   `.clearViewOffset <#PerspectiveCamera.clearViewOffset>`__.

⭕:number zoom
~~~~~~~~~~~~~~~

   Gets or sets the zoom factor of the camera. Default is ``1``.

Methods
-------

   See the base ``Camera`` class for common methods.

📦:clearViewOffset() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes any offset set by the `.setViewOffset <#PerspectiveCamera.setViewOffset>`__
   method.

📦:getEffectiveFOV() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the current vertical field of view angle in degrees considering .zoom.

📦:getFilmHeight() Float
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the height of the image on the film. If .aspect is less than or equal to one
   (portrait format), the result equals .filmGauge.

📦:getFilmWidth() Float
~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the width of the image on the film. If .aspect is greater than or equal to one
   (landscape format), the result equals .filmGauge.

📦:getFocalLength() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the focal length of the current .fov in respect to .filmGauge.

📦:setFocalLength( Float focalLength ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the FOV by focal length in respect to the current `.filmGauge <#PerspectiveCamera.filmGauge>`__.
   By default, the focal length is specified for a 35mm (full frame) camera.

📦:getViewBounds( Float distance, Vector2 minTarget, Vector2 maxTarget ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the 2D bounds of the camera's viewable rectangle at a given distance along the
   viewing direction. Sets minTarget and maxTarget to the coordinates of the lower-left and
   upper-right corners of the view rectangle.

📦:getViewSize( Float distance, Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the width and height of the camera's viewable rectangle at a given distance along
   the viewing direction. Copies the result into the target Vector2, where x is width and y
   is height.

📦:setViewOffset( Float fullWidth, Float fullHeight, Float x, Float y, Float width, Float height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   fullWidth — full width of multiview setup
   fullHeight — full height of multiview setup
   x — horizontal offset of subcamera
   y — vertical offset of subcamera
   width — width of subcamera
   height — height of subcamera

   Sets an offset in a larger frustum. This is useful for multi-window or
   multi-monitor/multi-machine setups.

   For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are
   in grid like this:

   ::

      +---+---+---+
      A | B | C |
      +---+---+---+
      D | E | F |
      +---+---+---+
            

   then for each monitor you would call it like this:

   .. code:: javascript

      const w = 1920;
      const h = 1080;
      const fullWidth = w * 3;
      const fullHeight = h * 2;

      // A
      camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
      // B
      camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
      // C
      camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
      // D
      camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
      // E
      camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
      // F
      camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );


   Note there is no reason monitors have to be the same size or in a grid.

📦:updateProjectionMatrix() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the camera projection matrix. Must be called after any change of parameters.

📦:toJSON(Object meta) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- object containing metadata such as textures or images in objects' descendants.
   Convert the camera to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.



.. _D041:

StereoCamera
============

   https://threejs.org/docs/api/en/cameras/StereoCamera.html

   Dual `PerspectiveCamera <#PerspectiveCamera>`__s used for effects such as
   `3D Anaglyph <https://en.wikipedia.org/wiki/Anaglyph_3D>`__ or
   `Parallax Barrier <https://en.wikipedia.org/wiki/parallax_barrier>`__.

   **Examples**

   [example:webgl_effects_anaglyph effects / anaglyph ]
   [example:webgl_effects_parallaxbarrier effects / parallaxbarrier ]
   [example:webgl_effects_stereo effects / stereo ]

   .. Constructor


🐣:StereoCamera( )
~~~~~~~~~~~~~~~~~

Properties
----------

⭕:Float aspect
~~~~~~~~~~~~~~~~

   Default is ``1``.

⭕:Float eyeSep
~~~~~~~~~~~~~~~~

   Default is ``0.064``.

⭕:PerspectiveCamera cameraL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Left camera. This is added to `layer 1 <#Layers>`__ - objects to be rendered by the left
   camera must also be added to this layer.

⭕:PerspectiveCamera cameraR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Right camera.This is added to `layer 2 <#Layers>`__ - objects to be rendered by the right
   camera must also be added to this layer.

Methods
-------

📦:update( PerspectiveCamera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the stereo cameras based on the camera passed in.



.. _D042:

Animation Constants
===================

   https://threejs.org/docs/api/en/constants/Animation.html

   Loop Modes
   ----------


   .. code:: javascript

      THREE.LoopOnce 
      THREE.LoopRepeat 
      THREE.LoopPingPong


   Interpolation Modes
   -------------------


   .. code:: javascript

      THREE.InterpolateDiscrete 
      THREE.InterpolateLinear 
      THREE.InterpolateSmooth


   Ending Modes
   ------------


   .. code:: javascript

      THREE.ZeroCurvatureEnding 
      THREE.ZeroSlopeEnding 
      THREE.WrapAroundEnding


   Animation Blend Modes
   ---------------------


   .. code:: javascript

      THREE.NormalAnimationBlendMode 
      THREE.AdditiveAnimationBlendMode




.. _D043:

Core Constants
==============

   https://threejs.org/docs/api/en/constants/Core.html

   Revision Number
   ---------------


   .. code:: javascript

      THREE.REVISION


      :name: rev

      The current three.js `revision number <https://github.com/mrdoob/three.js/releases>`__.

   Color Spaces
   ------------


   .. code:: javascript

      THREE.NoColorSpace = "" 
      THREE.SRGBColorSpace = "srgb" 
      THREE.LinearSRGBColorSpace = "srgb-linear"


   ``NoColorSpace`` defines no specific color space. It is commonly used for textures
   including normal maps, roughness maps, metalness maps, ambient occlusion maps, and other
   non-color data.

   ``SRGBColorSpace`` (“srgb”) refers to the color space defined by the Rec. 709
   primaries, D65 white point, and nonlinear sRGB transfer functions. sRGB is the default
   color space in CSS, and is often found in color palettes and color pickers. Colors
   expressed in hexadecimal or CSS notation are typically in the sRGB color space.

   ``LinearSRGBColorSpace`` (“srgb-linear”) refers to the sRGB color space (above) with
   linear transfer functions. Linear-sRGB is the working color space in three.js, used
   throughout most of the rendering process. RGB components found in three.js materials and
   shaders are in the Linear-sRGB color space.

   For further background and usage, see *Color management*.

   Mouse Buttons
   -------------


   .. code:: javascript

      THREE.MOUSE.LEFT 
      THREE.MOUSE.MIDDLE 
      THREE.MOUSE.RIGHT 
      THREE.MOUSE.ROTATE 
      THREE.MOUSE.DOLLY 
      THREE.MOUSE.PAN


   The constants LEFT and ROTATE have the same underlying value. The constants MIDDLE and
   DOLLY have the same underlying value. The constants RIGHT and PAN have the same underlying
   value.

   Touch Actions
   -------------


   .. code:: javascript

      THREE.TOUCH.ROTATE 
      THREE.TOUCH.PAN 
      THREE.TOUCH.DOLLY_PAN 
      THREE.TOUCH.DOLLY_ROTATE




.. _D044:

Custom Blending Equation Constants
==================================

   https://threejs.org/docs/api/en/constants/CustomBlendingEquations.html

   These work with all material types. First set the material's blending mode to
   THREE.CustomBlending, then set the desired Blending Equation, Source Factor and
   Destination Factor.

   **Code Example**


   .. code:: javascript

      const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
      material.blending = THREE.CustomBlending;
      material.blendEquation = THREE.AddEquation; //default 
      material.blendSrc = THREE.SrcAlphaFactor; //default 
      material.blendDst = THREE.OneMinusSrcAlphaFactor; //default


   **Examples**

   [example:webgl_materials_blending_custom materials / blending / custom ]

   Blending Equations
   ------------------


   .. code:: javascript

      THREE.AddEquation 
      THREE.SubtractEquation 
      THREE.ReverseSubtractEquation 
      THREE.MinEquation 
      THREE.MaxEquation


   Source Factors

   .. code:: javascript

      THREE.ZeroFactor 
      THREE.OneFactor 
      THREE.SrcColorFactor 
      THREE.OneMinusSrcColorFactor 
      THREE.SrcAlphaFactor 
      THREE.OneMinusSrcAlphaFactor 
      THREE.DstAlphaFactor 
      THREE.OneMinusDstAlphaFactor 
      THREE.DstColorFactor 
      THREE.OneMinusDstColorFactor 
      THREE.SrcAlphaSaturateFactor 
      THREE.ConstantColorFactor 
      THREE.OneMinusConstantColorFactor 
      THREE.ConstantAlphaFactor 
      THREE.OneMinusConstantAlphaFactor


   Destination Factors
   -------------------

   All of the Source Factors are valid as Destination Factors, except for

   .. code:: javascript

      THREE.SrcAlphaSaturateFactor




.. _D045:

Buffer Attribute Usage Constants
================================

   https://threejs.org/docs/api/en/constants/BufferAttributeUsage.html

   The usage constants can be used to provide a hint to the API regarding how the geometry
   buffer attribute will be used in order to optimize performance.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BufferGeometry();
      const positionAttribute = new THREE.BufferAttribute( array, 3 , false );
      positionAttribute.setUsage( THREE.DynamicDrawUsage );
      geometry.setAttribute( 'position', positionAttribute );


   **Examples**

   [example:webgl_buffergeometry_drawrange materials / buffergeometry / drawrange ]

   Geometry Usage

   .. code:: javascript

      THREE.StaticDrawUsage 
      THREE.DynamicDrawUsage 
      THREE.StreamDrawUsage 
      THREE.StaticReadUsage 
      THREE.DynamicReadUsage 
      THREE.StreamReadUsage 
      THREE.StaticCopyUsage 
      THREE.DynamicCopyUsage 
      THREE.StreamCopyUsage

   For more detailed information on each of these constants see
   `this OpenGL documentation <https://www.khronos.org/opengl/wiki/Buffer_Object#Buffer_Object_Usage>`__.



.. _D046:

Material Constants
==================

   https://threejs.org/docs/api/en/constants/Materials.html

   These constants define properties common to all material types, with the exception of
   Texture Combine Operations which only apply to `MeshBasicMaterial <#MeshBasicMaterial.combine>`__, 
   `MeshLambertMaterial <#MeshLambertMaterial.combine>`__ and
   `MeshPhongMaterial <#MeshPhongMaterial.combine>`__.

   Side
   ----


   .. code:: javascript

      THREE.FrontSide 
      THREE.BackSide 
      THREE.DoubleSide


   Defines which side of faces will be rendered - front, back or both. Default is
   `FrontSide <#Constant>`__.

   Blending Mode
   -------------


   .. code:: javascript

      THREE.NoBlending 
      THREE.NormalBlending 
      THREE.AdditiveBlending 
      THREE.SubtractiveBlending 
      THREE.MultiplyBlending 
      THREE.CustomBlending


   These control the source and destination blending equations for the material's RGB and
   Alpha sent to the WebGLRenderer for use by WebGL.
   `NormalBlending <#Constant>`__ is the default.
   Note that `CustomBlending <#Constant>`__ must be set to use `Custom Blending Equations <#CustomBlendingEquation>`__.
   See the [example:webgl_materials_blending materials / blending] example.

   Depth Mode
   ----------


   .. code:: javascript

      THREE.NeverDepth 
      THREE.AlwaysDepth 
      THREE.EqualDepth 
      THREE.LessDepth 
      THREE.LessEqualDepth 
      THREE.GreaterEqualDepth 
      THREE.GreaterDepth 
      THREE.NotEqualDepth


   Which depth function the material uses to compare incoming pixels Z-depth against the
   current Z-depth buffer value. If the result of the comparison is true, the pixel will be
   drawn.
   `NeverDepth <#Materials>`__ will never return true.
   `AlwaysDepth <#Materials>`__ will always return true.
   `EqualDepth <#Materials>`__ will return true if the incoming pixel Z-depth is equal to
   the current buffer Z-depth.
   `LessDepth <#Materials>`__ will return true if the incoming pixel Z-depth is less than
   the current buffer Z-depth.
   `LessEqualDepth <#Materials>`__ is the default and will return true if the incoming
   pixel Z-depth is less than or equal to the current buffer Z-depth.
   `GreaterEqualDepth <#Materials>`__ will return true if the incoming pixel Z-depth is
   greater than or equal to the current buffer Z-depth.
   `GreaterDepth <#Materials>`__ will return true if the incoming pixel Z-depth is greater
   than the current buffer Z-depth.
   `NotEqualDepth <#Materials>`__ will return true if the incoming pixel Z-depth is not
   equal to the current buffer Z-depth.

   Texture Combine Operations
   --------------------------


   .. code:: javascript

      THREE.MultiplyOperation 
      THREE.MixOperation 
      THREE.AddOperation


   These define how the result of the surface's color is combined with the environment map
   (if present), for `MeshBasicMaterial <#MeshBasicMaterial.combine>`__,
   `MeshLambertMaterial <#MeshLambertMaterial.combine>`__ and
   `MeshPhongMaterial <#MeshPhongMaterial.combine>`__.
   `MultiplyOperation <#Constant>`__ is the default and multiplies the environment map
   color with the surface color.
   `MixOperation <#Constant>`__ uses reflectivity to blend between the two colors.
   `AddOperation <#Constant>`__ adds the two colors.

   Stencil Functions
   -----------------


   .. code:: javascript

      THREE.NeverStencilFunc 
      THREE.LessStencilFunc 
      THREE.EqualStencilFunc 
      THREE.LessEqualStencilFunc 
      THREE.GreaterStencilFunc 
      THREE.NotEqualStencilFunc 
      THREE.GreaterEqualStencilFunc 
      THREE.AlwaysStencilFunc


   Which stencil function the material uses to determine whether or not to perform a
   stencil operation.
   `NeverStencilFunc <#Materials>`__ will never return true.
   `LessStencilFunc <#Materials>`__ will return true if the stencil reference value is less
   than the current stencil value.
   `EqualStencilFunc <#Materials>`__ will return true if the stencil reference value is
   equal to the current stencil value.
   `LessEqualStencilFunc <#Materials>`__ will return true if the stencil reference value is
   less than or equal to the current stencil value.
   `GreaterStencilFunc <#Materials>`__ will return true if the stencil reference value is
   greater than the current stencil value.
   `NotEqualStencilFunc <#Materials>`__ will return true if the stencil reference value is
   not equal to the current stencil value.
   `GreaterEqualStencilFunc <#Materials>`__ will return true if the stencil reference value
   is greater than or equal to the current stencil value.
   `AlwaysStencilFunc <#Materials>`__ will always return true.

   Stencil Operations
   ------------------


   .. code:: javascript

      THREE.ZeroStencilOp 
      THREE.KeepStencilOp 
      THREE.ReplaceStencilOp 
      THREE.IncrementStencilOp 
      THREE.DecrementStencilOp 
      THREE.IncrementWrapStencilOp 
      THREE.DecrementWrapStencilOp 
      THREE.InvertStencilOp


   Which stencil operation the material will perform on the stencil buffer pixel if the
   provided stencil function passes.
   `ZeroStencilOp <#Materials>`__ will set the stencil value to ``0``.
   `KeepStencilOp <#Materials>`__ will not change the current stencil value.
   `ReplaceStencilOp <#Materials>`__ will replace the stencil value with the specified
   stencil reference value.
   `IncrementStencilOp <#Materials>`__ will increment the current stencil value by ``1``.
   `DecrementStencilOp <#Materials>`__ will decrement the current stencil value by ``1``.
   `IncrementWrapStencilOp <#Materials>`__ will increment the current stencil value by
   ``1``. If the value increments past ``255`` it will be set to ``0``.
   `DecrementWrapStencilOp <#Materials>`__ will increment the current stencil value by
   ``1``. If the value decrements below ``0`` it will be set to ``255``.
   `InvertStencilOp <#Materials>`__ will perform a bitwise inversion of the current stencil
   value.

   Normal map type
   ---------------


   .. code:: javascript

      THREE.TangentSpaceNormalMap 
      THREE.ObjectSpaceNormalMap


   Defines the type of the normal map. For TangentSpaceNormalMap, the information is relative
   to the underlying surface. For ObjectSpaceNormalMap, the information is relative to the
   object orientation. Default is `TangentSpaceNormalMap <#Constant>`__.

   GLSL Version
   ------------


   .. code:: javascript

      THREE.GLSL1 
      THREE.GLSL3




.. _D047:

WebGLRenderer Constants
=======================

   https://threejs.org/docs/api/en/constants/Renderer.html

   Cull Face Modes
   ---------------


   .. code:: javascript

      THREE.CullFaceNone 
      THREE.CullFaceBack 
      THREE.CullFaceFront 
      THREE.CullFaceFrontBack


   `CullFaceNone <#constant>`__ disables face culling.
   `CullFaceBack <#constant>`__ culls back faces (default).
   `CullFaceFront <#constant>`__ culls front faces.
   `CullFaceFrontBack <#constant>`__ culls both front and back faces.

   Shadow Types
   ------------


   .. code:: javascript

      THREE.BasicShadowMap 
      THREE.PCFShadowMap 
      THREE.PCFSoftShadowMap 
      THREE.VSMShadowMap


   These define the WebGLRenderer's `shadowMap.type <#WebGLRenderer.shadowMap.type>`__ property.
   `BasicShadowMap <#constant>`__ gives unfiltered shadow maps - fastest, but lowest quality.
   `PCFShadowMap <#constant>`__ filters shadow maps using the Percentage-Closer Filtering
   (PCF) algorithm (default).
   `PCFSoftShadowMap <#constant>`__ filters shadow maps using the Percentage-Closer
   Filtering (PCF) algorithm with better soft shadows especially when using low-resolution
   shadow maps.
   `VSMShadowMap <#constant>`__ filters shadow maps using the Variance Shadow Map (VSM)
   algorithm. When using VSMShadowMap all shadow receivers will also cast shadows.

   Tone Mapping
   ------------


   .. code:: javascript

      THREE.NoToneMapping 
      THREE.LinearToneMapping 
      THREE.ReinhardToneMapping 
      THREE.CineonToneMapping 
      THREE.ACESFilmicToneMapping 
      THREE.AgXToneMapping 
      THREE.NeutralToneMapping 
      THREE.CustomToneMapping


   These define the WebGLRenderer's `toneMapping <#WebGLRenderer.toneMapping>`__ property.
   This is used to approximate the appearance of high dynamic range (HDR) on the low dynamic
   range medium of a standard computer monitor or mobile device's screen.

   THREE.LinearToneMapping, THREE.ReinhardToneMapping, THREE.CineonToneMapping,
   THREE.ACESFilmicToneMapping, THREE.AgXToneMapping and THREE.NeutralToneMapping are
   built-inimplementations of tone mapping. THREE.CustomToneMapping expects a custom
   implementation by modyfing GLSL code of the material's fragment shader. See the
   [example:webgl_tonemapping WebGL / tonemapping] example.

   THREE.NeutralToneMapping is an implementation based on the Khronos 3D Commerce Group
   standard tone mapping.



.. _D048:

Texture Constants
=================

   https://threejs.org/docs/api/en/constants/Textures.html

   Mapping Modes
   -------------


   .. code:: javascript

      THREE.UVMapping 
      THREE.CubeReflectionMapping 
      THREE.CubeRefractionMapping 
      THREE.EquirectangularReflectionMapping 
      THREE.EquirectangularRefractionMapping 
      THREE.CubeUVReflectionMapping


   These define the texture's mapping mode.

   `UVMapping <#Constant>`__ is the default, and maps the texture using the mesh's UV
   coordinates.
   The rest define environment mapping types.
   `CubeReflectionMapping <#Constant>`__ and `CubeRefractionMapping <#Constant>`__ are for
   use with a `CubeTexture <#CubeTexture>`__, which is made up of six textures, one for
   each face of the cube. `CubeReflectionMapping <#Constant>`__ is the default for a
   `CubeTexture <#CubeTexture>`__.
   `EquirectangularReflectionMapping <#Constant>`__ and `EquirectangularRefractionMapping <#Constant>`__ 
   are for use with an equirectangular environment map.
   Also called a lat-long map, an equirectangular texture represents a 360-degree view
   along the horizontal centerline, and a 180-degree view along the vertical axis, with the
   top and bottom edges of the image corresponding to the north and south poles of a mapped
   sphere.

   See the [example:webgl_materials_envmaps materials / envmaps] example.

   Wrapping Modes

   .. code:: javascript

      THREE.RepeatWrapping 
      THREE.ClampToEdgeWrapping 
      THREE.MirroredRepeatWrapping


   These define the texture's `wrapS <#Texture.wrapS>`__ and `wrapT <#Texture.wrapT>`__
   properties, which define horizontal and vertical texture wrapping.
   With `RepeatWrapping <#constant>`__ the texture will simply repeat to infinity.
   `ClampToEdgeWrapping <#constant>`__ is the default. The last pixel of the texture
   stretches to the edge of the mesh.
   With `MirroredRepeatWrapping <#constant>`__ the texture will repeats to infinity,
   mirroring on each repeat.

   Magnification Filters
   ---------------------


   .. code:: javascript

      THREE.NearestFilter 
      THREE.LinearFilter


   For use with a texture's `magFilter <#Texture.magFilter>`__ property, these define the
   texture magnification function to be used when the pixel being textured maps to an area
   less than or equal to one texture element (texel).
   `NearestFilter <#constant>`__ returns the value of the texture element that is nearest
   (in Manhattan distance) to the specified texture coordinates.
   `LinearFilter <#constant>`__ is the default and returns the weighted average of the four
   texture elements that are closest to the specified texture coordinates, and can include
   items wrapped or repeated from other parts of a texture, depending on the values of
   `wrapS <#Texture.wrapS>`__ and `wrapT <#Texture.wrapT>`__, and on the exact mapping.

   Minification Filters
   --------------------


   .. code:: javascript

      THREE.NearestFilter 
      THREE.NearestMipmapNearestFilter 
      THREE.NearestMipmapLinearFilter 
      THREE.LinearFilter 
      THREE.LinearMipmapNearestFilter 
      THREE.LinearMipmapLinearFilter


   For use with a texture's `minFilter <#Texture.minFilter>`__ property, these define the
   texture minifying function that is used whenever the pixel being textured maps to an
   area greater than one texture element (texel).

   In addition to `NearestFilter <#constant>`__ and `LinearFilter <#constant>`__, the
   following four functions can be used for minification:

   -  `NearestMipmapNearestFilter <#constant>`__ chooses the mipmap that most closely matches
      the size of the pixel being textured and uses the `NearestFilter <#constant>`__
      criterion (the texel nearest to the center of the pixel) to produce a texture value.

   -  `NearestMipmapLinearFilter <#constant>`__ chooses the two mipmaps that most closely
      match the size of the pixel being textured and uses the `NearestFilter <#constant>`__
      criterion to produce a texture value from each mipmap. The final texture value is a
      weighted average of those two values.

   -  `LinearMipmapNearestFilter <#constant>`__ chooses the mipmap that most closely matches
      the size of the pixel being textured and uses the `LinearFilter <#constant>`__ criterion
      (a weighted average of the four texels that are closest to the center of the pixel) to
      produce a texture value.

   -  `LinearMipmapLinearFilter <#constant>`__ is the default and chooses the two mipmaps that
      most closely match the size of the pixel being textured and uses the `LinearFilter <#constant>`__ 
      criterion to produce a texture value from each mipmap. The final texture
      value is a weighted average of those two values.

   See the [example:webgl_materials_texture_filters materials / texture / filters] example.

   Types
   -----


   .. code:: javascript

      THREE.UnsignedByteType 
      THREE.ByteType 
      THREE.ShortType 
      THREE.UnsignedShortType 
      THREE.IntType 
      THREE.UnsignedIntType 
      THREE.FloatType 
      THREE.HalfFloatType 
      THREE.UnsignedShort4444Type 
      THREE.UnsignedShort5551Type 
      THREE.UnsignedInt248Type 
      THREE.UnsignedInt5999Type


   For use with a texture's `type <#Texture.type>`__ property, which must correspond to the
   correct format. See below for details.
   `UnsignedByteType <#constant>`__ is the default.

   Formats
   -------


   .. code:: javascript

      THREE.AlphaFormat 
      THREE.RedFormat 
      THREE.RedIntegerFormat 
      THREE.RGFormat 
      THREE.RGIntegerFormat 
      THREE.RGBFormat 
      THREE.RGBAFormat 
      THREE.RGBAIntegerFormat 
      THREE.LuminanceFormat 
      THREE.LuminanceAlphaFormat 
      THREE.DepthFormat 
      THREE.DepthStencilFormat


   For use with a texture's `format <#Texture.format>`__ property, these define how
   elements of a 2d texture, or ``texels``, are read by shaders.

   `AlphaFormat <#constant>`__ discards the red, green and blue components and reads just
   the alpha component.
   `RedFormat <#constant>`__ discards the green and blue components and reads just the red
   component.
   `RedIntegerFormat <#constant>`__ discards the green and blue components and reads just
   the red component. The texels are read as integers instead of floating point.
   `RGFormat <#constant>`__ discards the alpha, and blue components and reads the red, and
   green components.
   `RGIntegerFormat <#constant>`__ discards the alpha, and blue components and reads the
   red, and green components. The texels are read as integers instead of floating point.
   `RGBAFormat <#constant>`__ is the default and reads the red, green, blue and alpha
   components.
   `RGBAIntegerFormat <#constant>`__ is the default and reads the red, green, blue and
   alpha components. The texels are read as integers instead of floating point.
   `LuminanceFormat <#constant>`__ reads each element as a single luminance component. This
   is then converted to a floating point, clamped to the range [0,1], and then assembled
   into an RGBA element by placing the luminance value in the red, green and blue channels,
   and attaching 1.0 to the alpha channel.
   `LuminanceAlphaFormat <#constant>`__ reads each element as a luminance/alpha double. The
   same process occurs as for the `LuminanceFormat <#constant>`__, except that the alpha
   channel may have values other than ``1.0``.
   `DepthFormat <#constant>`__ reads each element as a single depth value, converts it to
   floating point, and clamps to the range [0,1]. This is the default for
   `DepthTexture <#DepthTexture>`__.
   `DepthStencilFormat <#constant>`__ reads each element is a pair of depth and stencil
   values. The depth component of the pair is interpreted as in `DepthFormat <#constant>`__. 
   The stencil component is interpreted based on the depth + stencil internal format.

   Note that the texture must have the correct `type <#Texture.type>`__ set, as described
   above. See `WebGLRenderingContext.texImage2D <https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext/texImage2D>`__ 
   for details.

   DDS / ST3C Compressed Texture Formats
   -------------------------------------


   .. code:: javascript

      THREE.RGB_S3TC_DXT1_Format 
      THREE.RGBA_S3TC_DXT1_Format 
      THREE.RGBA_S3TC_DXT3_Format 
      THREE.RGBA_S3TC_DXT5_Format


   For use with a `CompressedTexture <#CompressedTexture>`__'s `format <#Texture.format>`__
   property, these require support for the `WEBGL_compressed_texture_s3tc <https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/>`__ 
   extension.

   There are four `S3TC <https://en.wikipedia.org/wiki/S3_Texture_Compression>`__ formats
   available via this extension. These are:

   -  `RGB_S3TC_DXT1_Format <#constant>`__: A DXT1-compressed image in an RGB image format.

   -  `RGBA_S3TC_DXT1_Format <#constant>`__: A DXT1-compressed image in an RGB image format
      with a simple on/off alpha value.

   -  `RGBA_S3TC_DXT3_Format <#constant>`__: A DXT3-compressed image in an RGBA image format.
      Compared to a 32-bit RGBA texture, it offers 4:1 compression.

   -  `RGBA_S3TC_DXT5_Format <#constant>`__: A DXT5-compressed image in an RGBA image format.

   It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha
   compression is done.

   PVRTC Compressed Texture Formats
   --------------------------------


   .. code:: javascript

      THREE.RGB_PVRTC_4BPPV1_Format 
      THREE.RGB_PVRTC_2BPPV1_Format 
      THREE.RGBA_PVRTC_4BPPV1_Format 
      THREE.RGBA_PVRTC_2BPPV1_Format


   For use with a `CompressedTexture <#CompressedTexture>`__'s `format <#Texture.format>`__
   property, these require support for the
   `WEBGL_compressed_texture_pvrtc <https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/>`__ extension.
   PVRTC is typically only available on mobile devices with PowerVR chipsets, which are
   mainly Apple devices.
   There are four `PVRTC <https://en.wikipedia.org/wiki/PVRTC>`__ formats available via
   this extension. These are:
   `RGB_PVRTC_4BPPV1_Format <#constant>`__: RGB compression in 4-bit mode. One block for
   each 4×4 pixels.
   `RGB_PVRTC_2BPPV1_Format <#constant>`__: RGB compression in 2-bit mode. One block for
   each 8×4 pixels.
   `RGBA_PVRTC_4BPPV1_Format <#constant>`__: RGBA compression in 4-bit mode. One block for
   each 4×4 pixels.
   `RGBA_PVRTC_2BPPV1_Format <#constant>`__: RGBA compression in 2-bit mode. One block for
   each 8×4 pixels.

   ETC Compressed Texture Format
   -----------------------------


   .. code:: javascript

      THREE.RGB_ETC1_Format 
      THREE.RGB_ETC2_Format 
      THREE.RGBA_ETC2_EAC_Format


   For use with a `CompressedTexture <#CompressedTexture>`__'s `format <#Texture.format>`__
   property, these require support for the
   `WEBGL_compressed_texture_etc1 <https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/>`__ (ETC1) or
   `WEBGL_compressed_texture_etc <https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/>`__ (ETC2) extensions.

   ASTC Compressed Texture Format
   ------------------------------


   .. code:: javascript

      THREE.RGBA_ASTC_4x4_Format 
      THREE.RGBA_ASTC_5x4_Format 
      THREE.RGBA_ASTC_5x5_Format 
      THREE.RGBA_ASTC_6x5_Format 
      THREE.RGBA_ASTC_6x6_Format 
      THREE.RGBA_ASTC_8x5_Format 
      THREE.RGBA_ASTC_8x6_Format 
      THREE.RGBA_ASTC_8x8_Format 
      THREE.RGBA_ASTC_10x5_Format 
      THREE.RGBA_ASTC_10x6_Format 
      THREE.RGBA_ASTC_10x8_Format 
      THREE.RGBA_ASTC_10x10_Format 
      THREE.RGBA_ASTC_12x10_Format 
      THREE.RGBA_ASTC_12x12_Format


   For use with a `CompressedTexture <#CompressedTexture>`__'s `format <#Texture.format>`__
   property, these require support for the
   `WEBGL_compressed_texture_astc <https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/>`__ extension.

   BPTC Compressed Texture Format
   ------------------------------


   .. code:: javascript

      THREE.RGBA_BPTC_Format


   For use with a `CompressedTexture <#CompressedTexture>`__'s `format <#Texture.format>`__
   property, these require support for the
   `EXT_texture_compression_bptc <https://www.khronos.org/registry/webgl/extensions/EXT_texture_compression_bptc/>`__ extension.

   Texture Comparison functions
   ----------------------------


   .. code:: javascript

      THREE.NeverCompare 
      THREE.LessCompare 
      THREE.EqualCompare 
      THREE.LessEqualCompare 
      THREE.GreaterCompare 
      THREE.NotEqualCompare 
      THREE.GreaterEqualCompare 
      THREE.AlwaysCompare


   Internal Formats
   ----------------

   ==================== ==================== =====================
   'ALPHA'              'RG16I'              'RGBA4'                    
   'RGB'                'RG16UI'             'RGBA8'                    
   'RGBA'               'RG16F'              'RGBA8_SNORM'              
   'LUMINANCE'          'RG32I'              'RGBA8I'                   
   'LUMINANCE_ALPHA'    'RG32UI'             'RGBA8UI'                  
   'RED_INTEGER'        'RG32F'              'RGBA16I'                  
   'R8'                 'RGB565'             'RGBA16UI'                 
   'R8_SNORM'           'RGB8'               'RGBA16F'                  
   'R8I'                'RGB8_SNORM'         'RGBA32I'                  
   'R8UI'               'RGB8I'              'RGBA32UI'                 
   'R16I'               'RGB8UI'             'RGBA32F'                  
   'R16UI'              'RGB16I'             'RGB5_A1'                  
   'R16F'               'RGB16UI'            'RGB10_A2'                 
   'R32I'               'RGB16F'             'RGB10_A2UI'               
   'R32UI'              'RGB32I'             'SRGB8_ALPHA8'             
   'R32F'               'RGB32UI'            'DEPTH_COMPONENT16'        
   'RG8'                'RGB32F'             'DEPTH_COMPONENT24'        
   'RG8_SNORM'          'RGB9_E5'            'DEPTH_COMPONENT32F'       
   'RG8I'               'SRGB8'              'DEPTH24_STENCIL8'         
   'RG8UI'              'R11F_G11F_B10F'     'DEPTH32F_STENCIL8'        
   ==================== ==================== =====================


   For use with a texture's `internalFormat <#Texture.internalFormat>`__ property, these
   define how elements of a texture, or ``texels``, are stored on the GPU.

-   ====================== ======================================================
   ``R8``                 stores the red component on 8 bits.
   ``R8_SNORM``           stores the red component on 8 bits. The component is stored as
                          normalized.
   ``R8I``                stores the red component on 8 bits. The component is stored as an
                          integer.
   ``R8UI``               stores the red component on 8 bits. The component is stored as an
                          unsigned integer.
   ``R16I``               stores the red component on 16 bits. The component is stored as an
                          integer.
   ``R16UI``              stores the red component on 16 bits. The component is stored as an
                          unsigned integer.
   ``R16F``               stores the red component on 16 bits. The component is stored as
                          floating point.
   ``R32I``               stores the red component on 32 bits. The component is stored as an
                          integer.
   ``R32UI``              stores the red component on 32 bits. The component is stored as an
                          unsigned integer.
   ``R32F``               stores the red component on 32 bits. The component is stored as
                          floating point.
   ``RG8``                stores the red and green components on 8 bits each.
   ``RG8_SNORM``          stores the red and green components on 8 bits each. Every
                          component is stored as normalized.
   ``RG8I``               stores the red and green components on 8 bits each. Every component
                          is stored as an integer.
   ``RG8UI``              stores the red and green components on 8 bits each. Every
                          component is stored as an unsigned integer.
   ``RG16I``              stores the red and green components on 16 bits each. Every
                          component is stored as an integer.
   ``RG16UI``             stores the red and green components on 16 bits each. Every
                          component is stored as an unsigned integer.
   ``RG16F``              stores the red and green components on 16 bits each. Every
                          component is stored as floating point.
   ``RG32I``              stores the red and green components on 32 bits each. Every
                          component is stored as an integer.
   ``RG32UI``             stores the red and green components on 32 bits. Every component
                          is stored as an unsigned integer.
   ``RG32F``              stores the red and green components on 32 bits. Every component is
                          stored as floating point.
   ``RGB8``               stores the red, green, and blue components on 8 bits each.
   ``RGB8_SNORM``         stores the red, green, and blue components on 8 bits each.
                          Every component is stored as normalized.
   ``RGB8I``              stores the red, green, and blue components on 8 bits each. Every
                          component is stored as an integer.
   ``RGB8UI``             stores the red, green, and blue components on 8 bits each. Every
                          component is stored as an unsigned integer.
   ``RGB16I``             stores the red, green, and blue components on 16 bits each. Every
                          component is stored as an integer.
   ``RGB16UI``            stores the red, green, and blue components on 16 bits each.
                          Every component is stored as an unsigned integer.
   ``RGB16F``             stores the red, green, and blue components on 16 bits each. Every
                          component is stored as floating point
   ``RGB32I``             stores the red, green, and blue components on 32 bits each. Every
                          component is stored as an integer.
   ``RGB32UI``            stores the red, green, and blue components on 32 bits each.
                          Every component is stored as an unsigned integer.
   ``RGB32F``             stores the red, green, and blue components on 32 bits each. Every
                          component is stored as floating point
   ``R11F_G11F_B10F``     stores the red, green, and blue components respectively
                          on 11 bits, 11 bits, and 10bits. Every component is stored as floating point.
   ``RGB565``             stores the red, green, and blue components respectively on 5
                          bits, 6 bits, and 5 bits.
   ``RGB9_E5``            stores the red, green, and blue components on 9 bits each.
   ``RGBA8``              stores the red, green, blue, and alpha components on 8 bits each.
   ``RGBA8_SNORM``        stores the red, green, blue, and alpha components on 8 bits.
                          Every component is stored as normalized.
   ``RGBA8I``             stores the red, green, blue, and alpha components on 8 bits each.
                          Every component is stored as an integer.
   ``RGBA8UI``            stores the red, green, blue, and alpha components on 8 bits.
                          Every component is stored as an unsigned integer.
   ``RGBA16I``            stores the red, green, blue, and alpha components on 16 bits.
                          Every component is stored as an integer.
   ``RGBA16UI``           stores the red, green, blue, and alpha components on 16 bits.
                          Every component is stored as an unsigned integer.
   ``RGBA16F``            stores the red, green, blue, and alpha components on 16 bits.
                          Every component is stored as floating point.
   ``RGBA32I``            stores the red, green, blue, and alpha components on 32 bits.
                          Every component is stored as an integer.
   ``RGBA32UI``           stores the red, green, blue, and alpha components on 32 bits.
                          Every component is stored as an unsigned integer.
   ``RGBA32F``            stores the red, green, blue, and alpha components on 32 bits.
                          Every component is stored as floating point.
   ``RGB5_A1``            stores the red, green, blue, and alpha components respectively
                          on 5 bits, 5 bits, 5 bits, and 1 bit.
   ``RGB10_A2``           stores the red, green, blue, and alpha components respectively
                          on 10 bits, 10 bits, 10 bits and 2 bits.
   ``RGB10_A2UI``         stores the red, green, blue, and alpha components
                          respectively on 10 bits, 10 bits, 10 bits and 2 bits. 
                          Every component is stored as an unsigned integer.
   ``SRGB8``              stores the red, green, and blue components on 8 bits each.
   ``SRGB8_ALPHA8``       stores the red, green, blue, and alpha components on 8 bits each.
   ``DEPTH_COMPONENT16``  stores the depth component on 16bits.
   ``DEPTH_COMPONENT24``  stores the depth component on 24bits.
   ``DEPTH_COMPONENT32F`` stores the depth component on 32bits. 
                          The component is stored as floating point.
   ``DEPTH24_STENCIL8``   stores the depth, and stencil components respectively
                          on 24 bits and 8 bits. The stencil component is stored as an unsigned integer.
   ``DEPTH32F_STENCIL8``  stores the depth, and stencil components respectively
                          on 32 bits and 8 bits. The depth component is stored as floating point, 
                          and the stencil component as an unsigned integer.
   ====================== ======================================================

   Note that the texture must have the correct `type <#Texture.type>`__ set, as well as the
   correct `format <#Texture.format>`__. See
   `WebGLRenderingContext.texImage2D <https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext/texImage2D>`__, 
   and `WebGL2RenderingContext.texImage3D <https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texImage3D>`__, 
   for more details regarding the possible combination
   of `format <#Texture.format>`__, `internalFormat <#Texture.internalFormat>`__, and
   `type <#Texture.type>`__.

   For more in-depth information regarding internal formats, you can also refer directly to
   the `WebGL2 Specification <https://www.khronos.org/registry/webgl/specs/latest/2.0/>`__
   and to the `OpenGL ES 3.0 Specification <https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf>`__.

   Depth Packing
   -------------


   .. code:: javascript

      THREE.BasicDepthPacking 
      THREE.RGBADepthPacking


   For use with the `depthPacking <#MeshDepthMaterial.depthPacking>`__ property of
   ``MeshDepthMaterial``.

   Color Space
   -----------


   .. code:: javascript

      THREE.NoColorSpace = "" 
      THREE.SRGBColorSpace = "srgb" 
      THREE.LinearSRGBColorSpace = "srgb-linear"


   Used to define the color space of textures (and the output color space of the renderer).
   If the color space type is changed after the texture has already been used by a
   material, you will need to set `Material.needsUpdate <#Material.needsUpdate>`__ to
   ``true`` to make the material recompile.



.. _D049:

BufferAttribute
===============

   https://threejs.org/docs/api/en/core/BufferAttribute.html

   This class stores data for an attribute (such as vertex positions, face indices, normals,
   colors, UVs, and any custom attributes ) associated with a ``BufferGeometry``, which
   allows for more efficient passing of data to the GPU. See that page for details and a
   usage example. When working with vector-like data, the *.fromBufferAttribute( attribute,
   index )* helper methods on `Vector2 <#Vector2.fromBufferAttribute>`__,
   `Vector3 <#Vector3.fromBufferAttribute>`__, `Vector4 <#Vector4.fromBufferAttribute>`__,
   and `Color <#Color.fromBufferAttribute>`__ classes may be helpful.

   .. Constructor

🐣:BufferAttribute( TypedArray array, Integer itemSize, Boolean normalized )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#TypedArray>`__ -- Must be a
   `TypedArray <https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/TypedArray>`__. 
   Used to instantiate the buffer.

   This array should have ``itemSize * numVertices`` elements, where numVertices is the
   number of vertices in the associated `BufferGeometry <#BufferGemetry>`__.
   `itemSize <#Integer>`__ -- the number of values of the array that should be associated
   with a particular vertex. For instance, if this attribute is storing a 3-component
   vector (such as a position, normal, or color), then itemSize should be 3.
   `normalized <#Boolean>`__ -- (optional) Applies to integer data only. Indicates how the
   underlying data in the buffer maps to the values in the GLSL code. For instance, if
   `array <#TypedArray>`__ is an instance of UInt16Array, and `normalized <#Boolean>`__ is
   true, the values ``0 - +65535`` in the array data will be mapped to 0.0f - +1.0f in the
   GLSL attribute. An Int16Array (signed) would map from -32768 - +32767 to -1.0f - +1.0f.
   If `normalized <#Boolean>`__ is false, the values will be converted to floats
   unmodified, i.e. 32767 becomes 32767.0f.

Properties
----------

⭕:TypedArray array
~~~~~~~~~~~~~~~~~~~~

   The `array <#TypedArray>`__ holding data stored in the buffer.

⭕:Integer count
~~~~~~~~~~~~~~~~~

   Represents the number of items this buffer attribute stores. It is internally computed by
   dividing the `array <#BufferAttribute.array>`__'s length by the
   `itemSize <#BufferAttribute.itemSize>`__. Read-only property.

⭕:Number gpuType
~~~~~~~~~~~~~~~~~~

   Configures the bound GPU type for use in shaders. Either `THREE.FloatType <#BufferAttribute>`__ 
   or `THREE.IntType <#BufferAttribute>`__, default is `THREE.FloatType <#BufferAttribute>`__. 
   
   Note: this only has an effect for integer arrays and is not configurable
   for float arrays. For lower precision float types, see `THREE.Float16BufferAttribute <#BufferAttributeTypes>`__.

⭕:Boolean isBufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``BufferAttribute``.

⭕:Integer itemSize
~~~~~~~~~~~~~~~~~~~~

   The length of vectors that are being stored in the `array <#BufferAttribute.array>`__.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name for this attribute instance. Default is an empty string.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set
   this to true when you modify the value of the array.
   Setting this to true also increments the `version <#BufferAttribute.version>`__.

⭕:Boolean normalized
~~~~~~~~~~~~~~~~~~~~~~

   Indicates how the underlying data in the buffer maps to the values in the GLSL shader
   code. See the constructor above for details.

⭕:Function onUploadCallback
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A callback function that is executed after the Renderer has transferred the attribute
   array data to the GPU.

⭕:Object updateRanges
~~~~~~~~~~~~~~~~~~~~~~~

   Array of objects containing:
   `start <#Integer>`__: Position at which to start update.
   `count <#Integer>`__: The number of components to update.
   This can be used to only update some components of stored vectors (for example, just the
   component related to color). Use the `addUpdateRange <#BufferAttribute.addUpdateRange>`__ 
   function to add ranges to this array.

⭕:Usage usage
~~~~~~~~~~~~~~~

   Defines the intended usage pattern of the data store for optimization purposes.
   Corresponds to the ``usage`` parameter of
   `WebGLRenderingContext.bufferData <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData>`__(). 
   Default is `StaticDrawUsage <#BufferAttributeUsage>`__. 
   See usage `constants <#BufferAttributeUsage>`__ for all possible values.

   Note: After the initial use of a buffer, its usage cannot be changed. Instead,
   instantiate a new one and set the desired usage before the next render.

⭕:Integer version
~~~~~~~~~~~~~~~~~~~

   A version number, incremented every time the `needsUpdate <#BufferAttribute.needsUpdate>`__ 
   property is set to true.

Methods
-------

📦:applyMatrix3( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies matrix `m <#Matrix3>`__ to every Vector3 element of this BufferAttribute.

📦:applyMatrix4( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies matrix `m <#Matrix4>`__ to every Vector3 element of this BufferAttribute.

📦:applyNormalMatrix( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies normal matrix `m <#Matrix3>`__ to every Vector3 element of this BufferAttribute.

📦:transformDirection( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies matrix `m <#Matrix4>`__ to every Vector3 element of this BufferAttribute,
   interpreting the elements as a direction vectors.

📦:addUpdateRange( Integer start, Integer count ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds a range of data in the data array to be updated on the GPU. Adds an object describing
   the range to the `updateRanges <#BufferAttribute.updateRanges>`__ array.

📦:clearUpdateRanges() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clears the `updateRanges <#BufferAttribute.updateRanges>`__ array.

📦:clone() BufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return a copy of this bufferAttribute.

📦:copy( BufferAttribute bufferAttribute ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies another BufferAttribute to this BufferAttribute.

📦:copyArray( array ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copy the array given here (which can be a normal array or TypedArray) into
   `array <#BufferAttribute.array>`__.

   See `TypedArray.set <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set>`__ 
   for notes on requirements if copying a TypedArray.

📦:copyAt ( Integer index1, BufferAttribute bufferAttribute, Integer index2 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copy a vector from bufferAttribute[index2] to `array <#BufferAttribute.array>`__[index1].

📦:getComponent( Integer index, Integer component ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the given component of the vector at the given index.

📦:getX( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the x component of the vector at the given index.

📦:getY( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the y component of the vector at the given index.

📦:getZ( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the z component of the vector at the given index.

📦:getW( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the w component of the vector at the given index.

📦:onUpload( Function callback ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the value of the onUploadCallback property.
   In the [example:webgl_buffergeometry WebGL / Buffergeometry] this is used to free memory
   after the buffer has been transferred to the GPU.

📦:set ( Array value, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``value`` -- an ``Array`` or ``TypedArray`` from which to copy values.
   -  ``offset`` -- (optional) index of the `array <#BufferAttribute.array>`__ at which to start
   copying.

   Calls `TypedArray.set`( `value <#Array>`__, `Integer offset <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set>`__ ) 
   on the `array <#BufferAttribute.array>`__.

   In particular, see that page for requirements on `value <#Array>`__ being a
   ``TypedArray``.

📦:setUsage ( Usage value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set `usage <#BufferAttribute.usage>`__ to value. See usage `constants <#BufferAttributeUsage>`__ 
   for all possible input values.

   Note: After the initial use of a buffer, its usage cannot be changed. Instead,
   instantiate a new one and set the desired usage before the next render.

📦:setComponent( Integer index, Integer component, Float value ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the given component of the vector at the given index.

📦:setX( Integer index, Float x ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x component of the vector at the given index.

📦:setY( Integer index, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the y component of the vector at the given index.

📦:setZ( Integer index, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the z component of the vector at the given index.

📦:setW( Integer index, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the w component of the vector at the given index.

📦:setXY( Integer index, Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x and y components of the vector at the given index.

📦:setXYZ( Integer index, Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x, y and z components of the vector at the given index.

📦:setXYZW( Integer index, Float x, Float y, Float z, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x, y, z and w components of the vector at the given index.



.. _D050:

BufferGeometry
==============

   https://threejs.org/docs/api/en/core/BufferGeometry.html

   A representation of mesh, line, or point geometry. Includes vertex positions, face
   indices, normals, colors, UVs, and custom attributes within buffers, reducing the cost of
   passing all this data to the GPU.

   To read and edit data in BufferGeometry attributes, see ``BufferAttribute``
   documentation.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BufferGeometry();

      // create a simple square shape. We duplicate the top left and bottom right
      // vertices because each vertex needs to appear once per triangle.
      const vertices = new Float32Array( [
         -1.0, -1.0,  1.0, // v0
         1.0, -1.0,  1.0, // v1
         1.0,  1.0,  1.0, // v2

         1.0,  1.0,  1.0, // v3
         -1.0,  1.0,  1.0, // v4
         -1.0, -1.0,  1.0  // v5
      ] );

      // itemSize = 3 because there are 3 values (components) per vertex
      geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
      const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
      const mesh = new THREE.Mesh( geometry, material );


   Code Example (Index)
   --------------------


   .. code:: javascript

      const geometry = new THREE.BufferGeometry();

      const vertices = new Float32Array( [
         -1.0, -1.0,  1.0, // v0
         1.0, -1.0,  1.0, // v1
         1.0,  1.0,  1.0, // v2
         -1.0,  1.0,  1.0, // v3
      ] );

      const indices = [
         0, 1, 2,
         2, 3, 0,
      ];

      geometry.setIndex( indices );
      geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

      const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
      const mesh = new THREE.Mesh( geometry, material );


   **Examples**

   [example:webgl_buffergeometry Mesh with non-indexed faces]
   [example:webgl_buffergeometry_indexed Mesh with indexed faces]
   [example:webgl_buffergeometry_lines Lines]
   [example:webgl_buffergeometry_lines_indexed Indexed Lines]
   [example:webgl_buffergeometry_custom_attributes_particles Particles]
   [example:webgl_buffergeometry_rawshader Raw Shaders]

   .. Constructor


🐣:BufferGeometry()
~~~~~~~~~~~~~~~~~~


      This creates a new ``BufferGeometry``. It also sets several properties to a default value.

Properties
----------

⭕:Object attributes
~~~~~~~~~~~~~~~~~~~~~

   This hashmap has as id the name of the attribute to be set and as value the
   `buffer <#BufferAttribute>`__ to set it to. Rather than accessing this property directly,
   use ``.setAttribute`` and ``.getAttribute`` to access attributes of this geometry.

⭕:Box3 boundingBox
~~~~~~~~~~~~~~~~~~~~

   Bounding box for the bufferGeometry, which can be calculated with
   ``.computeBoundingBox``(). Default is ``null``.

⭕:Sphere boundingSphere
~~~~~~~~~~~~~~~~~~~~~~~~~

   Bounding sphere for the bufferGeometry, which can be calculated with
   ``.computeBoundingSphere``(). Default is ``null``.

⭕:Object drawRange
~~~~~~~~~~~~~~~~~~~~

   Determines the part of the geometry to render. This should not be set directly, instead
   use ``.setDrawRange``. Default is ``{ start: 0, count: Infinity }`` For non-indexed
   BufferGeometry, count is the number of vertices to render. For indexed BufferGeometry,
   count is the number of indices to render.

⭕:Array groups
~~~~~~~~~~~~~~~~

   Split the geometry into groups, each of which will be rendered in a separate WebGL draw
   call. This allows an array of materials to be used with the geometry.
   Each group is an object of the form:

   .. code:: javascript

      { start: Integer, count: Integer, materialIndex: Integer }

   where start specifies the first element in this draw call – the first vertex for 
   non-indexed geometry, otherwise the first triangle index. Count specifies how many 
   vertices (or indices) are included, and materialIndex specifies the material array index to use.
   Use ``.addGroup`` to add groups, rather than modifying this array directly.
   Every vertex and index must belong to exactly one group — groups must not share vertices
   or indices, and must not leave vertices or indices unused.

⭕:Integer id
~~~~~~~~~~~~~~

   Unique number for this bufferGeometry instance.

⭕:BufferAttribute index
~~~~~~~~~~~~~~~~~~~~~~~~~

   Allows for vertices to be re-used across multiple triangles; this is called using "indexed
   triangles". Each triangle is associated with the indices of three vertices. This attribute
   therefore stores the index of each vertex for each triangular face. If this attribute is
   not set, the `renderer <#WebGLRenderer>`__ assumes that each three contiguous positions
   represent a single triangle. Default is ``null``.

⭕:Boolean isBufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``BufferGeometry``.

⭕:Object morphAttributes
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Hashmap of ``BufferAttribute``s holding details of the geometry's morph targets.

   Note: Once the geometry has been rendered, the morph attribute data cannot be changed.
   You will have to call ``.dispose``(), and create a new instance of ``BufferGeometry``.

⭕:Boolean morphTargetsRelative
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Used to control the morph target behavior; when set to true, the morph target data is
   treated as relative offsets, rather than as absolute positions/normals.
   Default is ``false``.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name for this bufferGeometry instance. Default is an empty string.

⭕:Object userData
~~~~~~~~~~~~~~~~~~~

   An object that can be used to store custom data about the BufferGeometry. It should not
   hold references to functions as these will not be cloned. Default is an empty object
   ``{}``.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this object
   instance. This gets automatically assigned and shouldn't be edited.

Methods
-------

   `EventDispatcher <#EventDispatcher>`__ methods are available on this class.

📦:addGroup( Integer start, Integer count, Integer materialIndex ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds a group to this geometry; see the `groups <#BufferGeometry.groups>`__ property for
   details.

📦:applyMatrix4( Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the matrix transform to the geometry.

📦:applyQuaternion( Quaternion quaternion ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the rotation represented by the quaternion to the geometry.

📦:center () this
~~~~~~~~~~~~~~~~~~

   Center the geometry based on the bounding box.

📦:clearGroups( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clears all groups.

📦:clone() BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a clone of this BufferGeometry.

📦:computeBoundingBox() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding box of the geometry, and updates the ``.boundingBox`` attribute.
   The bounding box is not computed by the engine; it must be computed by your app. You may
   need to recompute the bounding box if the geometry vertices are modified.

📦:computeBoundingSphere() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding sphere of the geometry, and updates the ``.boundingSphere``
   attribute. The engine automatically computes the bounding sphere when it is needed, e.g.,
   for ray casting or view frustum culling. You may need to recompute the bounding sphere if
   the geometry vertices are modified.

📦:computeTangents() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Calculates and adds a tangent attribute to this geometry.
   The computation is only supported for indexed geometries and if position, normal, and uv
   attributes are defined. When using a tangent space normal map, prefer the MikkTSpace
   algorithm provided by ``BufferGeometryUtils.computeMikkTSpaceTangents`` instead.

📦:computeVertexNormals() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   each vertex normal to be the average of the face normals of the faces that share that
   vertex. For non-indexed geometries, vertices are not shared, and the method sets each
   vertex normal to be the same as the face normal.

📦:copy( BufferGeometry bufferGeometry ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies another BufferGeometry to this BufferGeometry.

📦:deleteAttribute( String name ) BufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Deletes the `attribute <#BufferAttribute>`__ with the specified name.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:getAttribute( String name ) BufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the `attribute <#BufferAttribute>`__ with the specified name.

📦:getIndex () BufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return the ``.index`` buffer.

📦:hasAttribute( String name ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns ``true`` if the attribute with the specified name exists.

📦:lookAt ( Vector3 vector ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   vector - A world vector to look at.
   Rotates the geometry to face a point in space. This is typically done as a one time
   operation, and not during a loop. Use ``Object3D.lookAt`` for typical real-time mesh
   usage.

📦:normalizeNormals() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Every normal vector in a geometry will have a magnitude of ``1``. This will correct
   lighting on the geometry surfaces.

📦:rotateX ( Float radians ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Rotate the geometry about the X axis. This is typically done as a one time operation, and
   not during a loop. Use ``Object3D.rotation`` for typical real-time mesh rotation.

📦:rotateY ( Float radians ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Rotate the geometry about the Y axis. This is typically done as a one time operation, and
   not during a loop. Use ``Object3D.rotation`` for typical real-time mesh rotation.

📦:rotateZ ( Float radians ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Rotate the geometry about the Z axis. This is typically done as a one time operation, and
   not during a loop. Use ``Object3D.rotation`` for typical real-time mesh rotation.

📦:scale ( Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Scale the geometry data. This is typically done as a one time operation, and not during a
   loop. Use ``Object3D.scale`` for typical real-time mesh scaling.

📦:setAttribute( String name, BufferAttribute attribute ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets an attribute to this geometry. Use this rather than the attributes property, because
   an internal hashmap of ``.attributes`` is maintained to speed up iterating over
   attributes.

📦:setDrawRange ( Integer start, Integer count ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the ``.drawRange`` property. For non-indexed BufferGeometry, count is the number of
   vertices to render. For indexed BufferGeometry, count is the number of indices to render.

📦:setFromPoints ( Array points ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the attributes for this BufferGeometry from an array of points.

📦:setIndex ( BufferAttribute index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the ``.index`` buffer.

📦:toJSON() Object
~~~~~~~~~~~~~~~~~~~

   Convert the buffer geometry to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.

📦:toNonIndexed() BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return a non-index version of an indexed BufferGeometry.

📦:translate ( Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Translate the geometry. This is typically done as a one time operation, and not during a
   loop. Use ``Object3D.position`` for typical real-time mesh translation.



.. _D051:

Clock
=====

   https://threejs.org/docs/api/en/core/Clock.html

   Object for keeping track of time. This uses
   `performance.now <https://developer.mozilla.org/en-US/docs/Web/API/Performance/now>`__ if
   it is available, otherwise it reverts to the less accurate
   `Date.now <https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now>`__.

   .. Constructor

🐣:Clock( Boolean autoStart )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   autoStart — (optional) whether to automatically start the clock when ``.getDelta``() is
   called for the first time. Default is ``true``.

Properties
----------

⭕:Boolean autoStart
~~~~~~~~~~~~~~~~~~~~~

   If set, starts the clock automatically when ``.getDelta``() is called for the first
   time. Default is ``true``.

⭕:Float startTime
~~~~~~~~~~~~~~~~~~~

   Holds the time at which the clock's `start <#Clock.start>`__ method was last called.
   Default is ``0``.

⭕:Float oldTime
~~~~~~~~~~~~~~~~~

   Holds the time at which the clock's `start <#Clock.start>`__, ``.getElapsedTime``() or
   ``.getDelta``() methods were last called. Default is ``0``.

⭕:Float elapsedTime
~~~~~~~~~~~~~~~~~~~~~

   Keeps track of the total time that the clock has been running. Default is ``0``.

⭕:Boolean running
~~~~~~~~~~~~~~~~~~~

   Whether the clock is running or not. Default is ``false``.

Methods
-------

📦:start() undefined
~~~~~~~~~~~~~~~~~~~~~

   Starts clock. Also sets the ``.startTime`` and ``.oldTime`` to the current time,
   sets ``.elapsedTime`` to ``0`` and ``.running`` to ``true``.

📦:stop() undefined
~~~~~~~~~~~~~~~~~~~~

   Stops clock and sets `oldTime <#Clock.oldTime>`__ to the current time.

📦:getElapsedTime() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get the seconds passed since the clock started and sets ``.oldTime`` to the current
   time.
   If ``.autoStart`` is ``true`` and the clock is not running, also starts the clock.

📦:getDelta() Float
~~~~~~~~~~~~~~~~~~~~

   Get the seconds passed since the time ``.oldTime`` was set and sets ``.oldTime``
   to the current time.
   If ``.autoStart`` is ``true`` and the clock is not running, also starts the clock.



.. _D052:

EventDispatcher
===============

   https://threejs.org/docs/api/en/core/EventDispatcher.html

   JavaScript events for custom objects.
   `EventDispatcher on GitHub <https://github.com/mrdoob/eventdispatcher.js>`__

   **Code Example**


   .. code:: javascript

      // Adding events to a custom object
      class Car extends EventDispatcher {
         start() {
            this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
         }
      };

      // Using events with the custom object
      const car = new Car();
      car.addEventListener( 'start', function ( event ) {
         alert( event.message );
      } );

      car.start();


   .. Constructor


🐣:EventDispatcher()
~~~~~~~~~~~~~~~~~~~

   Creates EventDispatcher object.

Methods
-------

📦:addEventListener( String type, Function listener ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   type - The type of event to listen to.
   listener - The function that gets called when the event is fired.

   Adds a listener to an event type.

📦:hasEventListener( String type, Function listener ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   type - The type of event to listen to.
   listener - The function that gets called when the event is fired.

   Checks if listener is added to an event type.

📦:removeEventListener( String type, Function listener ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   type - The type of the listener that gets removed.
   listener - The listener function that gets removed.

   Removes a listener from an event type.

📦:dispatchEvent( Object event ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   event - The event that gets fired.

   Fire an event type.



.. _D053:

GLBufferAttribute
=================

   https://threejs.org/docs/api/en/core/GLBufferAttribute.html

   This buffer attribute class does not construct a VBO. Instead, it uses whatever VBO is
   passed in constructor and can later be altered via the ``buffer`` property.
   It is required to pass additional params alongside the VBO. Those are: the GL context,
   the GL data type, the number of components per vertex, the number of bytes per
   component, and the number of vertices.
   The most common use case for this class is when some kind of GPGPU calculation
   interferes or even produces the VBOs in question.

   .. Constructor

🐣:GLBufferAttribute( WebGLBuffer buffer, GLenum type, Integer itemSize, Integer elementSize, Integer count )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``buffer`` — Must be a
   `WebGLBuffer <https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer>`__.
   ``type`` — One of
   `WebGL Data Types <https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types>`__.
   ``itemSize`` — The number of values of the array that should be associated with a
   particular vertex. For instance, if this attribute is storing a 3-component vector (such
   as a position, normal, or color), then itemSize should be 3.
   ``elementSize`` — 1, 2 or 4. The corresponding size (in bytes) for the given "type"
   param.

   -  gl.FLOAT: 4
   -  gl.UNSIGNED_SHORT: 2
   -  gl.SHORT: 2
   -  gl.UNSIGNED_INT: 4
   -  gl.INT: 4
   -  gl.BYTE: 1
   -  gl.UNSIGNED_BYTE: 1

   ``count`` — The expected number of vertices in VBO.

Properties
----------

⭕:WebGLBuffer buffer
~~~~~~~~~~~~~~~~~~~~~~

   The current `WebGLBuffer <https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer>`__ instance.

⭕:Integer count
~~~~~~~~~~~~~~~~~

   The expected number of vertices in VBO.

⭕:Boolean isGLBufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only. Always ``true``.

⭕:Integer itemSize
~~~~~~~~~~~~~~~~~~~~

   How many values make up each item (vertex).

⭕:Integer elementSize
~~~~~~~~~~~~~~~~~~~~~~~

   Stores the corresponding size in bytes for the current ``type`` property value.

   See above (constructor) for a list of known type sizes.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name for this attribute instance. Default is an empty string.

⭕:GLenum type
~~~~~~~~~~~~~~~

   A `WebGL Data Type <https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types>`__ 
   describing the underlying VBO contents.

   Set this property together with ``elementSize``. The recommended way is using the
   ``setType`` method.

Methods
-------

📦:setBuffer( buffer ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``buffer`` property.

📦:setType( type, elementSize ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the both ``type`` and ``elementSize`` properties.

📦:setItemSize( itemSize ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``itemSize`` property.

📦:setCount( count ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``count`` property.

⭕:Integer version
~~~~~~~~~~~~~~~~~~~

   A version number, incremented every time the needsUpdate property is set to true.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``false``. Setting this to true increments `version <#GLBufferAttribute.version>`__.



.. _D054:

BufferAttribute → InstancedBufferAttribute
==========================================

   https://threejs.org/docs/api/en/core/InstancedBufferAttribute.html

   An instanced version of ``BufferAttribute``.

   .. Constructor

🐣:InstancedBufferAttribute( TypedArray array, Integer itemSize, Boolean normalized, Number meshPerAttribute )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Properties
----------

   See ``BufferAttribute`` for inherited properties.

⭕:Number meshPerAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines how often a value of this buffer attribute should be repeated. A value of one
   means that each value of the instanced attribute is used for a single instance. A value of
   two means that each value is used for two consecutive instances (and so on).
   Default is ``1``.

Methods
-------

   See ``BufferAttribute`` for inherited methods.



.. _D055:

BufferGeometry → InstancedBufferGeometry
========================================

   https://threejs.org/docs/api/en/core/InstancedBufferGeometry.html

   An instanced version of ``BufferGeometry``.

   .. Constructor


🐣:InstancedBufferGeometry( )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Properties
----------

   See ``BufferGeometry`` for inherited properties.

⭕:Number instanceCount
~~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``Infinity``.

⭕:Boolean isInstancedBufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``InstancedBufferGeometry``.

Methods
-------

   See ``BufferGeometry`` for inherited methods.

📦:copy( InstancedBufferGeometry source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the given ``InstancedBufferGeometry`` to this instance.



.. _D056:

InterleavedBuffer → InstancedInterleavedBuffer
==============================================

   https://threejs.org/docs/api/en/core/InstancedInterleavedBuffer.html

   An instanced version of ``InterleavedBuffer``.

   .. Constructor

🐣:InstancedInterleavedBuffer( TypedArray array, Integer itemSize, Number meshPerAttribute )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Properties
----------

   See ``InterleavedBuffer`` for inherited properties.

⭕:Number meshPerAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``1``.

Methods
-------

   See ``InterleavedBuffer`` for inherited methods.



.. _D057:

InterleavedBuffer
=================

   https://threejs.org/docs/api/en/core/InterleavedBuffer.html

   "Interleaved" means that multiple attributes, possibly of different types, (e.g.,
   position, normal, uv, color) are packed into a single array buffer.
   An introduction into interleaved arrays can be found here:
   `Interleaved array basics <https://blog.tojicode.com/2011/05/interleaved-array-basics.html>`__

   **Examples**

   [example:webgl_buffergeometry_points_interleaved webgl / buffergeometry / points /
   interleaved]

   .. Constructor

🐣:InterleavedBuffer( TypedArray array, Integer stride )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#TypedArray>`__ -- A typed array with a shared buffer. Stores the geometry data.
   `stride <#Integer>`__ -- The number of typed-array elements per vertex.

Properties
----------

⭕:Array array
~~~~~~~~~~~~~~~

   A typed array with a shared buffer. Stores the geometry data.

⭕:Integer stride
~~~~~~~~~~~~~~~~~~

   The number of typed-array elements per vertex.

⭕:Integer count
~~~~~~~~~~~~~~~~~

   Gives the total number of elements in the array.

⭕:Object updateRanges
~~~~~~~~~~~~~~~~~~~~~~~

   Array of objects containing:
   `start <#Integer>`__: Position at which to start update.
   `count <#Integer>`__: The number of components to update.
   This can be used to only update some components of stored data. Use the
   `addUpdateRange <#InterleavedBuffer.addUpdateRange>`__ function to add ranges to this
   array.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this instance.
   This gets automatically assigned, so this shouldn't be edited.

⭕:Integer version
~~~~~~~~~~~~~~~~~~~

   A version number, incremented every time the needsUpdate property is set to true.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``false``. Setting this to true increments `version <#InterleavedBuffer.version>`__.

⭕:Usage usage
~~~~~~~~~~~~~~~

   Defines the intended usage pattern of the data store for optimization purposes.
   Corresponds to the ``usage`` parameter of
   `WebGLRenderingContext.bufferData <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData>`__().

Methods
-------

📦:addUpdateRange( Integer start, Integer count ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds a range of data in the data array to be updated on the GPU. Adds an object describing
   the range to the `updateRanges <#InterleavedBuffer.updateRanges>`__ array.

📦:clearUpdateRanges() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clears the `updateRanges <#InterleavedBuffer.updateRanges>`__ array.

📦:copy( InterleavedBuffer source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies another ``InterleavedBuffer`` to this ``InterleavedBuffer``.

📦:copyAt( Integer index1, InterleavedBuffer attribute, Integer index2 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies data from ``attribute[index2]`` to `array <#InterleavedBuffer.array>`__[index1].

📦:set( TypedArray value, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   value - The source (typed) array.
   offset - The offset into the target array at which to begin writing values from the
   source array. Default is ``0``.
   Stores multiple values in the buffer, reading input values from a specified array.

📦:clone( Object data ) InterleavedBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   data - This object holds shared array buffers required for properly cloning geometries
   with interleaved attributes.
   Creates a clone of this ``InterleavedBuffer``.

📦:setUsage ( Usage value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set `usage <#InterleavedBuffer.usage>`__ to value.

📦:toJSON( Object data ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   data - This object holds shared array buffers required for properly serializing
   geometries with interleaved attributes.
   Serializes this ``InterleavedBuffer``.



.. _D058:

InterleavedBufferAttribute
==========================

   https://threejs.org/docs/api/en/core/InterleavedBufferAttribute.html

   .. Constructor

🐣:InterleavedBufferAttribute( InterleavedBuffer interleavedBuffer, Integer itemSize, Integer offset, Boolean normalized )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Properties
----------

⭕:InterleavedBuffer data
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The `InterleavedBuffer <#InterleavedBuffer>`__ instance passed in the constructor.

⭕:TypedArray array
~~~~~~~~~~~~~~~~~~~~

   The value of `data <#InterleavedBufferAttribute.data>`__.array.

⭕:Integer count
~~~~~~~~~~~~~~~~~

   The value of `data <#InterleavedBufferAttribute.data>`__.count. If the buffer is storing a
   3-component item (such as a position, normal, or color), then this will count the number
   of such items stored.

⭕:Boolean isInterleavedBufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``InterleavedBufferAttribute``.

⭕:Integer itemSize
~~~~~~~~~~~~~~~~~~~~

   How many values make up each item.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name for this attribute instance. Default is an empty string.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   Default is ``false``. Setting this to ``true`` will send the entire interleaved buffer
   (not just the specific attribute data) to the GPU again.

⭕:Boolean normalized
~~~~~~~~~~~~~~~~~~~~~~

   Default is ``false``.

⭕:Integer offset
~~~~~~~~~~~~~~~~~~

   The offset in the underlying array buffer where an item starts.

Methods
-------

📦:applyMatrix4( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies matrix `m <#Matrix4>`__ to every Vector3 element of this
   InterleavedBufferAttribute.

📦:applyNormalMatrix( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies normal matrix `m <#Matrix3>`__ to every Vector3 element of this
   InterleavedBufferAttribute.

📦:transformDirection( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies matrix `m <#Matrix4>`__ to every Vector3 element of this
   InterleavedBufferAttribute, interpreting the elements as a direction vectors.

📦:getComponent( Integer index, Integer component ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the given component of the vector at the given index.

📦:getX( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the x component of the item at the given index.

📦:getY( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the y component of the item at the given index.

📦:getZ( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the z component of the item at the given index.

📦:getW( Integer index ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the w component of the item at the given index.

📦:setComponent( Integer index, Integer component, Float value ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the given component of the vector at the given index.

📦:setX( Integer index, Float x ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x component of the item at the given index.

📦:setY( Integer index, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the y component of the item at the given index.

📦:setZ( Integer index, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the z component of the item at the given index.

📦:setW( Integer index, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the w component of the item at the given index.

📦:setXY( Integer index, Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x and y components of the item at the given index.

📦:setXYZ( Integer index, Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x, y and z components of the item at the given index.

📦:setXYZW( Integer index, Float x, Float y, Float z, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the x, y, z and w components of the item at the given index.



.. _D059:

Layers
======

   https://threejs.org/docs/api/en/core/Layers.html

   A ``Layers`` object assigns an ``Object3D`` to 1 or more of 32 layers numbered
   ``0`` to ``31`` - internally the layers are stored as a
   `bit mask <https://en.wikipedia.org/wiki/Mask_(computing)>`__, and by default all
   Object3Ds are a member of layer 0.
   This can be used to control visibility - an object must share a layer with a
   `camera <#Camera>`__ to be visible when that camera's view is rendered.
   All classes that inherit from ``Object3D`` have an ``Object3D.layers`` property
   which is an instance of this class.

   **Examples**

   [example:webgl_layers WebGL / layers]

   .. Constructor


🐣:Layers()
~~~~~~~~~~

   Create a new Layers object, with membership initially set to layer 0.

Properties
----------

⭕:Integer mask
~~~~~~~~~~~~~~~~

   A bit mask storing which of the 32 layers this layers object is currently a member of.

Methods
-------

📦:disable( Integer layer ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   layer - an integer from 0 to 31.
   Remove membership of this ``layer``.

📦:enable( Integer layer ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   layer - an integer from 0 to 31.
   Add membership of this ``layer``.

📦:set( Integer layer ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   layer - an integer from 0 to 31.
   Set membership to ``layer``, and remove membership all other layers.

📦:test( Layers layers ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   layers - a Layers object
   Returns true if this and the passed ``layers`` object have at least one layer in common.

📦:isEnabled( Integer layer ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   layer - an integer from 0 to 31.
   Returns true if the given layer is enabled.

📦:toggle( Integer layer ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   layer - an integer from 0 to 31.
   Toggle membership of ``layer``.

📦:enableAll() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~

   Add membership to all layers.

📦:disableAll() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Remove membership from all layers.



.. _D060:

Object3D
========

   https://threejs.org/docs/api/en/core/Object3D.html

   This is the base class for most objects in three.js and provides a set of properties and
   methods for manipulating objects in 3D space.
   Note that this can be used for grouping objects via the ``.add``( object ) method
   which adds the object as a child, however it is better to use ``Group`` for this.

   .. Constructor


🐣:Object3D()
~~~~~~~~~~~~

   The constructor takes no arguments.

Properties
----------

⭕:AnimationClip animations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Array with object's animation clips.

⭕:Boolean castShadow
~~~~~~~~~~~~~~~~~~~~~~

   Whether the object gets rendered into shadow map. Default is ``false``.

⭕:Array children
~~~~~~~~~~~~~~~~~~

   Array with object's children. See ``Group`` for info on manually grouping objects.

⭕:Material customDepthMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Custom depth material to be used when rendering to the depth map. Can only be used in
   context of meshes. When shadow-casting with a ``DirectionalLight`` or ``SpotLight``,
   if you are modifying vertex positions in the vertex shader you must specify a
   customDepthMaterial for proper shadows. Default is ``undefined``.

⭕:Material customDistanceMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Same as ``customDepthMaterial``, but used with ``PointLight``.
   Default is ``undefined``.

⭕:Boolean frustumCulled
~~~~~~~~~~~~~~~~~~~~~~~~~

   When this is set, it checks every frame if the object is in the frustum of the camera
   before rendering the object. If set to ``false`` the object gets rendered every frame even
   if it is not in the frustum of the camera. Default is ``true``.

⭕:Integer id
~~~~~~~~~~~~~~

   readonly – Unique number for this object instance.

⭕:Boolean isObject3D
~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Object3D``.

⭕:Layers layers
~~~~~~~~~~~~~~~~~

   The layer membership of the object. The object is only visible if it has at least one
   layer in common with the ``Camera`` in use. This property can also be used to filter
   out unwanted objects in ray-intersection tests when using ``Raycaster``.

⭕:Matrix4 matrix
~~~~~~~~~~~~~~~~~~

   The local transform matrix.

⭕:Boolean matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When this is set, it calculates the matrix of position, (rotation or quaternion) and scale
   every frame and also recalculates the matrixWorld property.
   Default is ``Object3D.DEFAULT_MATRIX_AUTO_UPDATE`` (true).

⭕:Matrix4 matrixWorld
~~~~~~~~~~~~~~~~~~~~~~~

   The global transform of the object. If the Object3D has no parent, then it's identical to
   the local transform ``.matrix``.

⭕:Boolean matrixWorldAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If set, then the renderer checks every frame if the object and its children need matrix
   updates. When it isn't, then you have to maintain all matrices in the object and its
   children yourself. Default is ``Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`` (true).

⭕:Boolean matrixWorldNeedsUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When this is set, it calculates the matrixWorld in that frame and resets this property to
   false. Default is ``false``.

⭕:Matrix4 modelViewMatrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is passed to the shader and used to calculate the position of the object.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name of the object (doesn't need to be unique). Default is an empty string.

⭕:Matrix3 normalMatrix
~~~~~~~~~~~~~~~~~~~~~~~~

   This is passed to the shader and used to calculate lighting for the object. It is the
   transpose of the inverse of the upper left 3x3 sub-matrix of this object's
   modelViewMatrix.
   The reason for this special matrix is that simply using the modelViewMatrix could result
   in a non-unit length of normals (on scaling) or in a non-perpendicular direction (on
   non-uniform scaling).
   On the other hand the translation part of the modelViewMatrix is not relevant for the
   calculation of normals. Thus a Matrix3 is sufficient.

⭕:Function onAfterRender
~~~~~~~~~~~~~~~~~~~~~~~~~~

   An optional callback that is executed immediately after a 3D object is rendered. This
   function is called with the following parameters: renderer, scene, camera, geometry,
   material, group.

   Please notice that this callback is only executed for ``renderable`` 3D objects. Meaning
   3D objects which define their visual appearance with geometries and materials like
   instances of ``Mesh``, ``Line``, ``Points`` or ``Sprite``. Instances of
   ``Object3D``, ``Group`` or ``Bone`` are not renderable and thus this callback is
   not executed for such objects.

⭕:Function onAfterShadow
~~~~~~~~~~~~~~~~~~~~~~~~~~

   An optional callback that is executed immediately after a 3D object is rendered to a
   shadow map. This function is called with the following parameters: renderer, scene,
   camera, shadowCamera, geometry, depthMaterial, group.

   Please notice that this callback is only executed for ``renderable`` 3D objects. Meaning
   3D objects which define their visual appearance with geometries and materials like
   instances of ``Mesh``, ``Line``, ``Points`` or ``Sprite``. Instances of
   ``Object3D``, ``Group`` or ``Bone`` are not renderable and thus this callback is
   not executed for such objects.

⭕:Function onBeforeRender
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An optional callback that is executed immediately before a 3D object is rendered. This
   function is called with the following parameters: renderer, scene, camera, geometry,
   material, group.

   Please notice that this callback is only executed for ``renderable`` 3D objects. Meaning
   3D objects which define their visual appearance with geometries and materials like
   instances of ``Mesh``, ``Line``, ``Points`` or ``Sprite``. Instances of
   ``Object3D``, ``Group`` or ``Bone`` are not renderable and thus this callback is
   not executed for such objects.

⭕:Function onBeforeShadow
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An optional callback that is executed immediately before a 3D object is rendered to a
   shadow map. This function is called with the following parameters: renderer, scene,
   camera, shadowCamera, geometry, depthMaterial, group.

   Please notice that this callback is only executed for ``renderable`` 3D objects. Meaning
   3D objects which define their visual appearance with geometries and materials like
   instances of ``Mesh``, ``Line``, ``Points`` or ``Sprite``. Instances of
   ``Object3D``, ``Group`` or ``Bone`` are not renderable and thus this callback is
   not executed for such objects.

⭕:Object3D parent
~~~~~~~~~~~~~~~~~~~

   Object's parent in the `scene graph <https://en.wikipedia.org/wiki/Scene_graph>`__. An
   object can have at most one parent.

⭕:Vector3 position
~~~~~~~~~~~~~~~~~~~~

   A ``Vector3`` representing the object's local position. Default is ``(0, 0, 0)``.

⭕:Quaternion quaternion
~~~~~~~~~~~~~~~~~~~~~~~~~

   Object's local rotation as a `Quaternion <#Quaternion>`__.

⭕:Boolean receiveShadow
~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether the material receives shadows. Default is ``false``.

⭕:Number renderOrder
~~~~~~~~~~~~~~~~~~~~~~

   This value allows the default rendering order of
   `scene graph <https://en.wikipedia.org/wiki/Scene_graph>`__ objects to be overridden
   although opaque and transparent objects remain sorted independently. When this property is
   set for an instance of `Group <#Group>`__, all descendants objects will be sorted and
   rendered together. Sorting is from lowest to highest renderOrder. Default value is ``0``.

⭕:Euler rotation
~~~~~~~~~~~~~~~~~~

   Object's local rotation (see `Euler angles <https://en.wikipedia.org/wiki/Euler_angles>`__), in radians.

⭕:Vector3 scale
~~~~~~~~~~~~~~~~~

   The object's local scale. Default is ``Vector3``( 1, 1, 1 ).

⭕:Vector3 up
~~~~~~~~~~~~~~

   This is used by the ``lookAt`` method, for example, to determine the
   orientation of the result.
   Default is ``Object3D.DEFAULT_UP`` - that is, ``( 0, 1, 0 )``.

⭕:Object userData
~~~~~~~~~~~~~~~~~~~

   An object that can be used to store custom data about the Object3D. It should not hold
   references to functions as these will not be cloned. Default is an empty object ``{}``.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this object
   instance. This gets automatically assigned, so this shouldn't be edited.

⭕:Boolean visible
~~~~~~~~~~~~~~~~~~~

   Object gets rendered if ``true``. Default is ``true``.

   Static Properties
   -----------------

   Static properties and methods are defined per class rather than per instance of that
   class. This means that changing ``Object3D.DEFAULT_UP`` or
   ``Object3D.DEFAULT_MATRIX_AUTO_UPDATE`` will change the values of ``up`` and
   ``matrixAutoUpdate`` for ``every`` instance of Object3D (or derived
   classes) created after the change has been made (already created Object3Ds will not be
   affected).

⭕:Vector3 DEFAULT_UP
~~~~~~~~~~~~~~~~~~~~~~

   The default ``up`` direction for objects, also used as the default position for
   ``DirectionalLight``, ``HemisphereLight`` and ``Spotlight`` (which creates
   lights shining from the top down).
   Set to ( 0, 1, 0 ) by default.

⭕:Boolean DEFAULT_MATRIX_AUTO_UPDATE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The default setting for ``matrixAutoUpdate`` for newly created
   Object3Ds.

⭕:Boolean DEFAULT_MATRIX_WORLD_AUTO_UPDATE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The default setting for ``matrixWorldAutoUpdate`` for newly
   created Object3Ds.

Methods
-------

   `EventDispatcher <#EventDispatcher>`__ methods are available on this class.

📦:add( Object3D object, ... ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds ``object`` as child of this object. An arbitrary number of objects may be added.
   Any current parent on an object passed in here will be removed, since an object can have
   at most one parent.
   See ``Group`` for info on manually grouping objects.

📦:applyMatrix4( Matrix4 matrix ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the matrix transform to the object and updates the object's position, rotation and
   scale.

📦:applyQuaternion( Quaternion quaternion ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the rotation represented by the quaternion to the object.

📦:attach( Object3D object ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds ``object`` as a child of this, while maintaining the object's world transform.

   Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).

📦:clear() this
~~~~~~~~~~~~~~~~

   Removes all child objects.

📦:clone( Boolean recursive ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   recursive -- if true, descendants of the object are also cloned. Default is true.
   Returns a clone of this object and optionally all descendants.

📦:copy( Object3D object, Boolean recursive ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   recursive -- If set to ``true``, descendants of the object are copied next to the
   existing ones. If set to ``false``, descendants are left unchanged. Default is ``true``.
   Copies the given object into this object. Note: Event listeners and user-defined
   callbacks (``.onAfterRender`` and ``.onBeforeRender``) are not copied.

📦:getObjectById( Integer id ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   id -- Unique number of the object instance
   Searches through an object and its children, starting with the object itself, and
   returns the first with a matching id.
   Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for
   each new object.

📦:getObjectByName( String name ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   name -- String to match to the children's Object3D.name property.
   Searches through an object and its children, starting with the object itself, and
   returns the first with a matching name.
   Note that for most objects the name is an empty string by default. You will have to set
   it manually to make use of this method.

📦:getObjectByProperty( String name, Any value ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   name -- the property name to search for.
   value -- value of the given property.
   Searches through an object and its children, starting with the object itself, and
   returns the first with a property that matches the value given.

📦:getObjectsByProperty( String name, Any value, Array optionalTarget ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   name -- the property name to search for.
   value -- value of the given property.
   optionalTarget -- (optional) target to set the result. Otherwise a new Array is
   instantiated. If set, you must clear this array prior to each call (i.e., array.length =
   0;).
   Searches through an object and its children, starting with the object itself, and
   returns all the objects with a property that matches the value given.

📦:getWorldPosition( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a vector representing the position of the object in world space.

📦:getWorldQuaternion( Quaternion target ) Quaternion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Quaternion>`__ — the result will be copied into this Quaternion.
   Returns a quaternion representing the rotation of the object in world space.

📦:getWorldScale( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a vector of the scaling factors applied to the object for each axis in world
   space.

📦:getWorldDirection( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a vector representing the direction of object's positive z-axis in world space.

📦:localToWorld( Vector3 vector ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   vector - A vector representing a position in this object's local space.
   Converts the vector from this object's local space to world space.

📦:lookAt( Vector3 vector ) undefined
📦:lookAt( Float x, Float y, Float z ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   vector - A vector representing a position in world space.
   Optionally, the ``x``, ``y`` and ``z`` components of the world space
   position.
   Rotates the object to face a point in world space.
   This method does not support objects having non-uniformly-scaled parent(s).

📦:raycast( Raycaster raycaster, Array intersects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Abstract (empty) method to get intersections between a casted ray and this object.
   Subclasses such as ``Mesh``, ``Line``, and ``Points`` implement this method in
   order to use raycasting.

📦:remove( Object3D object, ... ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes ``object`` as child of this object. An arbitrary number of objects may be removed.

📦:removeFromParent() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes this object from its current parent.

📦:rotateOnAxis( Vector3 axis, Float angle ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   axis -- A normalized vector in object space.
   angle -- The angle in radians.
   Rotate an object along an axis in object space. The axis is assumed to be normalized.

📦:rotateOnWorldAxis( Vector3 axis, Float angle) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   axis -- A normalized vector in world space.
   angle -- The angle in radians.
   Rotate an object along an axis in world space. The axis is assumed to be normalized.
   Method Assumes no rotated parent.

📦:rotateX( Float rad ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   rad - the angle to rotate in radians.
   Rotates the object around x axis in local space.

📦:rotateY( Float rad ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   rad - the angle to rotate in radians.
   Rotates the object around y axis in local space.

📦:rotateZ( Float rad ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   rad - the angle to rotate in radians.
   Rotates the object around z axis in local space.

📦:setRotationFromAxisAngle( Vector3 axis, Float angle ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   axis -- A normalized vector in object space.
   angle -- angle in radians
   Calls `setFromAxisAngle <#Quaternion.setFromAxisAngle>`__( `axis <#Float>`__,
   `angle <#Float>`__ ) on the ``.quaternion``.

📦:setRotationFromEuler( Euler euler ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   euler -- Euler angle specifying rotation amount.
   Calls `setRotationFromEuler <#Quaternion.setRotationFromEuler>`__( `euler <#Euler>`__)
   on the ``.quaternion``.

📦:setRotationFromMatrix( Matrix4 m ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   m -- rotate the quaternion by the rotation component of the matrix.
   Calls `setFromRotationMatrix <#Quaternion.setFromRotationMatrix>`__( `m <#Matrix4>`__)
   on the ``.quaternion``.
   Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e,
   unscaled).

📦:setRotationFromQuaternion( Quaternion q ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   q -- normalized Quaternion.
   Copy the given quaternion into ``.quaternion``.

📦:toJSON( Object meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- object containing metadata such as materials, textures or images for the object.
   Convert the object to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.

📦:translateOnAxis( Vector3 axis, Float distance ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   axis -- A normalized vector in object space.
   distance -- The distance to translate.
   Translate an object by distance along an axis in object space. The axis is assumed to be
   normalized.

📦:translateX( Float distance ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Translates object along x axis in object space by ``distance`` units.

📦:translateY( Float distance ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Translates object along y axis in object space by ``distance`` units.

📦:translateZ( Float distance ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Translates object along z axis in object space by ``distance`` units.

📦:traverse( Function callback ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   callback - A function with as first argument an object3D object.
   Executes the callback on this object and all descendants.

   Note: Modifying the scene graph inside the callback is discouraged.

📦:traverseVisible( Function callback ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   callback - A function with as first argument an object3D object.
   Like traverse, but the callback will only be executed for visible objects. Descendants
   of invisible objects are not traversed.

   Note: Modifying the scene graph inside the callback is discouraged.

📦:traverseAncestors( Function callback ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   callback - A function with as first argument an object3D object.
   Executes the callback on all ancestors.

   Note: Modifying the scene graph inside the callback is discouraged.

📦:updateMatrix() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the local transform.

📦:updateMatrixWorld( Boolean force ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   force - A boolean that can be used to bypass ``.matrixWorldAutoUpdate``, to
   recalculate the world matrix of the object and descendants on the current frame. Useful
   if you cannot wait for the renderer to update it on the next frame (assuming
   ``.matrixWorldAutoUpdate`` set to ``true``).
   Updates the global transform of the object and its descendants if the world matrix needs
   update (``.matrixWorldNeedsUpdate`` set to true) or if the ``force`` parameter is set
   to ``true``.

📦:updateWorldMatrix( Boolean updateParents, Boolean updateChildren ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   updateParents - recursively updates global transform of ancestors.
   updateChildren - recursively updates global transform of descendants.
   Updates the global transform of the object.

📦:worldToLocal( Vector3 vector ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   vector - A vector representing a position in world space.
   Converts the vector from world space to this object's local space.


🚀Events
~~~~~~~~~


   ============= ==============================================================
   added         Fires when the object has been added to its parent object.
   removed       Fires when the object has been removed from its parent object.
   childadded    Fires when a new child object has been added.
   childremoved  Fires when a new child object has been removed.
   ============= ==============================================================



.. _D061:

Raycaster
=========

   https://threejs.org/docs/api/en/core/Raycaster.html

   This class is designed to assist with `raycasting <https://en.wikipedia.org/wiki/Ray_casting>`__. 
   Raycasting is used for mouse picking (working out what objects in the 3d
   space the mouse is over) amongst other things.

   **Code Example**


   .. code:: javascript

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function onPointerMove( event ) {

         // calculate pointer position in normalized device coordinates
         // (-1 to +1) for both components

         pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
         pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      }

      function render() {

         // update the picking ray with the camera and pointer position
         raycaster.setFromCamera( pointer, camera );

         // calculate objects intersecting the picking ray
         const intersects = raycaster.intersectObjects( scene.children );

         for ( let i = 0; i < intersects.length; i ++ ) {

            intersects[ i ].object.material.color.set( 0xff0000 );

         }

         renderer.render( scene, camera );

      }

      window.addEventListener( 'pointermove', onPointerMove );

      window.requestAnimationFrame(render);

   **Examples**

   [example:webgl_interactive_cubes Raycasting to a Mesh]
   [example:webgl_interactive_cubes_ortho Raycasting to a Mesh in using an
   OrthographicCamera]
   [example:webgl_interactive_buffergeometry Raycasting to a Mesh with BufferGeometry]
   [example:webgl_instancing_raycast Raycasting to a InstancedMesh]
   [example:webgl_interactive_lines Raycasting to a Line]
   [example:webgl_interactive_raycasting_points Raycasting to Points]
   [example:webgl_geometry_terrain_raycast Terrain raycasting]
   [example:webgl_interactive_voxelpainter Raycasting to paint voxels]
   [example:webgl_raycaster_texture Raycast to a Texture]

   .. Constructor

🐣:Raycaster( Vector3 origin, Vector3 direction, Float near, Float far )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `origin <#Vector3>`__ — The origin vector where the ray casts from.
   `direction <#Vector3>`__ — The direction vector that gives direction to the ray. Should
   be normalized.
   `near <#Float>`__ — All results returned are further away than near. Near can't be
   negative. Default value is ``0``.
   `far <#Float>`__ — All results returned are closer than far. Far can't be lower than
   near. Default value is Infinity.

   This creates a new raycaster object.

Properties
----------

⭕:Float far
~~~~~~~~~~~~~

   The far factor of the raycaster. This value indicates which objects can be discarded based
   on the distance. This value shouldn't be negative and should be larger than the near
   property.

⭕:Float near
~~~~~~~~~~~~~~

   The near factor of the raycaster. This value indicates which objects can be discarded
   based on the distance. This value shouldn't be negative and should be smaller than the far
   property.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The camera to use when raycasting against view-dependent objects such as billboarded
   objects like ``Sprites``. This field can be set manually or is set when calling
   "setFromCamera". Defaults to null.

⭕:Layers layers
~~~~~~~~~~~~~~~~~

   Used by ``Raycaster`` to selectively ignore 3D objects when performing intersection tests. The
   following code example ensures that only 3D objects on layer ``1`` will be honored by the
   instance of ``Raycaster``. ``raycaster.layers.set( 1 ); object.layers.enable( 1 );``

⭕:Object params
~~~~~~~~~~~~~~~~~

   An object with the following properties:

   .. code:: javascript

      { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }

   Where threshold is the precision of the raycaster when intersecting objects, in world
   units.

⭕:Ray ray
~~~~~~~~~~~

   The [Page:Ray] used for the raycasting.

Methods
-------

📦:set( Vector3 origin, Vector3 direction) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `origin <#Vector3>`__ — The origin vector where the ray casts from.
   `direction <#Vector3>`__ — The normalized direction vector that gives direction to the
   ray.

   Updates the ray with a new origin and direction. Please note that this method only copies
   the values from the arguments.

📦:setFromCamera( Vector2 coords, Camera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `coords <#Vector2>`__ — 2D coordinates of the mouse, in normalized device coordinates
   (NDC)---X and Y components should be between ``-1`` and ``1``.
   `camera <#Camera>`__ — camera from which the ray should originate

   Updates the ray with a new origin and direction.

📦:setFromXRController( WebXRController controller ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `controller <#WebXRController>`__ — The controller to copy the position and direction
   from.

   Updates the ray with a new origin and direction.

📦:intersectObject( Object3D object, Boolean recursive, Array optionalTarget ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ — The object to check for intersection with the ray.
   `recursive <#Boolean>`__ — If true, it also checks all descendants. Otherwise it only
   checks intersection with the object. Default is true.
   `optionalTarget <#Array>`__ — (optional) target to set the result. Otherwise a new
   ``Array`` is instantiated. If set, you must clear this array prior to each call
   (i.e., array.length = 0;).

   Checks all intersection between the ray and the object with or without the descendants.
   Intersections are returned sorted by distance, closest first. An array of intersections is
   returned...


   .. code:: javascript

      [ { distance, point, face, faceIndex, object }, ... ]


   `distance <#Float>`__ – distance between the origin of the ray and the intersection
   `point <#Vector3>`__ – point of intersection, in world coordinates
   `face <#Object>`__ – intersected face
   `faceIndex <#Integer>`__ – index of the intersected face
   `object <#Object3D>`__ – the intersected object
   `uv <#Vector2>`__ - U,V coordinates at point of intersection
   `uv1 <#Vector2>`__ - Second set of U,V coordinates at point of intersection
   `normal <#Vector3>`__ - interpolated normal vector at point of intersection
   `instanceId <#Integer>`__ – The index number of the instance where the ray intersects
   the InstancedMesh

   ``Raycaster`` delegates to the `raycast <#Object3D.raycast>`__ method of the passed
   object, when evaluating whether the ray intersects the object or not. This allows
   `meshes <#Mesh>`__ to respond differently to ray casting than `lines <#Line>`__ and
   `pointclouds <#Points>`__.

   ``Note`` that for meshes, faces must be pointed towards the origin of the ``ray``
   in order to be detected; intersections of the ray passing through the back of a face will
   not be detected. To raycast against both faces of an object, you'll want to set the
   `material <#Mesh.material>`__'s `side <#Material.side>`__ property to
   ``THREE.DoubleSide``.

📦:intersectObjects( Array objects, Boolean recursive, Array optionalTarget ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `objects <#Array>`__ — The objects to check for intersection with the ray.
   `recursive <#Boolean>`__ — If true, it also checks all descendants of the objects.
   Otherwise it only checks intersection with the objects. Default is true.
   `optionalTarget <#Array>`__ — (optional) target to set the result. Otherwise a new
   ``Array`` is instantiated. If set, you must clear this array prior to each call
   (i.e., array.length = 0;).

   Checks all intersection between the ray and the objects with or without the descendants.
   Intersections are returned sorted by distance, closest first. Intersections are of the
   same form as those returned by ``.intersectObject``.



.. _D062:

Uniform
=======

   https://threejs.org/docs/api/en/core/Uniform.html

   Uniforms are global GLSL variables. They are passed to shader programs.

   **Code Example**

   When declaring a uniform of a ``ShaderMaterial``, it is declared by value or by object.


   .. code:: javascript

      uniforms: { time: { value: 1.0 }, resolution: new Uniform( new Vector2() ) };


   Uniform types
   -------------

   Each uniform must have a ``value`` property. The type of the value must correspond to the
   type of the uniform variable in the GLSL code as specified for the primitive GLSL types in
   the table below. Uniform structures and arrays are also supported. GLSL arrays of
   primitive type must either be specified as an array of the corresponding THREE objects or
   as a flat array containing the data of all the objects. In other words; GLSL primitives in
   arrays must not be represented by arrays. This rule does not apply transitively. An array
   of ``vec2`` arrays, each with a length of five vectors, must be an array of arrays, of
   either five ``Vector2`` objects or ten \`number`s.

   .. table:: Uniform types

      ============ =====================================
      GLSL type    JavaScript type
      ============ =====================================
      int          ``Number``
      uint         ``Number``
      float        ``Number``
      bool         ``Boolean``
      bool         ``Number``
      vec2         `THREE.Vector2 <#Vector2>`__
      vec2         `Float32Array <#Float32Array>`__ 
      vec2         `Array <#Array>`__ 
      vec3         `THREE.Vector3 <#Vector3>`__
      vec3         `THREE.Color <#Color>`__
      vec3         `Float32Array <#Float32Array>`__ 
      vec3         `Array <#Array>`__ 
      vec4         `THREE.Vector4 <#Vector4>`__
      vec4         `THREE.Quaternion <#Quaternion>`__
      vec4         `Float32Array <#Float32Array>`__ 
      vec4         `Array <#Array>`__ 
      mat2         `Float32Array <#Float32Array>`__ 
      mat2         `Array <#Array>`__ 
      mat3         `THREE.Matrix3 <#Matrix3>`__
      mat3         `Float32Array <#Float32Array>`__ 
      mat3         `Array <#Array>`__ 
      mat4         `THREE.Matrix4 <#Matrix4>`__
      mat4         `Float32Array <#Float32Array>`__ 
      mat4         `Array <#Array>`__ 
      ivec2, bvec2 `Float32Array <#Float32Array>`__ 
      ivec2, bvec2 `Array <#Array>`__ 
      ivec3, bvec3 `Int32Array <#Int32Array>`__ 
      ivec3, bvec3 `Array <#Array>`__ 
      ivec4, bvec4 `Int32Array <#Int32Array>`__ 
      ivec4, bvec4 `Array <#Array>`__ 
      sampler2D    `THREE.Texture <#Texture>`__
      samplerCube  `THREE.CubeTexture <#CubeTexture>`__
      ============ =====================================

   (``) Same for an (innermost) array (dimension) of the same GLSL type, containing the
   components of all vectors or matrices in the array.

   Structured Uniforms
   -------------------

   Sometimes you want to organize uniforms as ``structs`` in your shader code. The following
   style must be used so ``three.js`` is able to process structured uniform data.


   .. code:: javascript

      uniforms = { data: { value: { position: new Vector3(), direction: new Vector3( 0, 0, 1 ) } } };
      
   This definition can be mapped on the following GLSL code:

   .. code:: javascript

      struct Data { vec3 position;
      vec3 direction;
      };
      uniform Data data;


   Structured Uniforms with Arrays
   -------------------------------

   It's also possible to manage ``structs`` in arrays. The syntax for this use case looks
   like so:


   .. code:: javascript

      const entry1 = { position: new Vector3(), direction: new Vector3( 0, 0, 1 ) };
      const entry2 = { position: new Vector3( 1, 1, 1 ), direction: new Vector3( 0, 1, 0 ) };
      uniforms = { data: { value: [ entry1, entry2 ] } };
      
   This definition can be mapped on the following GLSL code:

   .. code:: javascript

      struct Data { vec3 position;
      vec3 direction;
      };
      uniform Data data[ 2 ];


   .. Constructor

🐣:Uniform( Object value )
~~~~~~~~~~~~~~~~~~~~~~~~~

   value -- An object containing the value to set up the uniform. It's type must be one of
   the Uniform Types described above.

Properties
----------

⭕:Object value
~~~~~~~~~~~~~~~~

   Current value of the uniform.

Methods
-------

📦:clone() Uniform
~~~~~~~~~~~~~~~~~~~

   Returns a clone of this uniform.
   If the uniform's value property is an ``Object`` with a clone() method, this is used,
   otherwise the value is copied by assignment. Array values are shared between cloned
   ``Uniform``s.



.. _D063:

BufferAttribute → BufferAttribute Types
=======================================

   https://threejs.org/docs/api/en/core/bufferAttributeTypes/BufferAttributeTypes.html

   There are nine types of ``BufferAttribute`` available in three.js. These correspond to
   the JavaScript
   `Typed Arrays <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#Syntax>`__.


   .. code:: javascript

      THREE.Float32BufferAttribute 
      THREE.Float16BufferAttribute 
      THREE.Uint32BufferAttribute 
      THREE.Int32BufferAttribute 
      THREE.Uint16BufferAttribute 
      THREE.Int16BufferAttribute 
      THREE.Uint8ClampedBufferAttribute 
      THREE.Uint8BufferAttribute 
      THREE.Int8BufferAttribute


   All of the above are called in the same way.

   .. Constructor

🐣:TypedBufferAttribute( Array_or_Integer array, Integer itemSize, Boolean normalized )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   array -- this can be a typed or untyped (normal) array or an integer length. An array
   value will be converted to the Type specified. If a length is given a new TypedArray
   will created, initialized with all elements set to zero.
   itemSize -- the number of values of the array that should be associated with a
   particular vertex.
   normalized -- (optional) indicates how the underlying data in the buffer maps to the
   values in the GLSL code.

Properties
----------

   See the ``BufferAttribute`` page for inherited properties.

Methods
-------

   See the ``BufferAttribute`` page for inherited methods.



.. _D064:

DataUtils
=========

   https://threejs.org/docs/api/en/extras/DataUtils.html

   A class containing utility functions for data.

Methods
-------

📦:toHalfFloat( Number val ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   val -- A single precision floating point value.
   Returns a half precision floating point value from the given single precision floating
   point value.

📦:fromHalfFloat( Number val ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   val -- A half precision floating point value.
   Returns a single precision floating point value from the given half precision floating
   point value.



.. _D065:

Earcut
======

   https://threejs.org/docs/api/en/extras/Earcut.html

   An implementation of the earcut polygon triangulation algorithm. The code is a port of
   `mapbox/earcut <https://github.com/mapbox/earcut>`__.

Methods
-------

📦:triangulate( data, holeIndices, dim ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   data -- A flat array of vertex coordinates.
   holeIndices -- An array of hole indices if any.
   dim -- The number of coordinates per vertex in the input array.
   Triangulates the given shape definition by returning an array of triangles. A triangle
   is defined by three consecutive integers representing vertex indices.



.. _D066:

ImageUtils
==========

   https://threejs.org/docs/api/en/extras/ImageUtils.html

   A class containing utility functions for images.

Methods
-------

📦:getDataURL( HTMLCanvasElement image | HTMLImageElement image | ImageBitmap image ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   image -- The image object.
   Returns a data URI containing a representation of the given image.

📦:sRGBToLinear( HTMLCanvasElement image | HTMLImageElement image | ImageBitmap image ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   image -- The image object.
   Converts the given sRGB image data to linear color space.



.. _D067:

PMREMGenerator
==============

   https://threejs.org/docs/api/en/extras/PMREMGenerator.html

   This class generates a Prefiltered, Mipmapped Radiance Environment Map (PMREM) from a
   cubeMap environment texture. This allows different levels of blur to be quickly accessed
   based on material roughness. Unlike a traditional mipmap chain, it only goes down to the
   LOD_MIN level (above), and then creates extra even more filtered 'mips' at the same
   LOD_MIN resolution, associated with higher roughness levels. In this way we maintain
   resolution to smoothly interpolate diffuse lighting while limiting sampling computation.

   Note: The minimum ``MeshStandardMaterial``'s roughness depends on the size of the
   provided texture. If your render has small dimensions or the shiny parts have a lot of
   curvature, you may still be able to get away with a smaller texture size.

   ============ =================
   texture size minimum roughness
   16           0.21
   32           0.15
   64           0.11
   128          0.076
   256          0.054
   512          0.038
   1024         0.027
   ============ =================

   .. Constructor

🐣:PMREMGenerator( WebGLRenderer renderer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This constructor creates a new ``PMREMGenerator``.

Methods
-------

📦:fromScene( Scene scene, Number sigma, Number near, Number far ) WebGLRenderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scene <#Scene>`__ - The given scene.
   `sigma <#Number>`__ - (optional) Specifies a blur radius in radians to be applied to the
   scene before PMREM generation. Default is ``0``.
   `near <#Number>`__ - (optional) The near plane value. Default is ``0.1``.
   `far <#Number>`__ - (optional) The far plane value. Default is ``100``.
   Generates a PMREM from a supplied Scene, which can be faster than using an image if
   networking bandwidth is low. Optional near and far planes ensure the scene is rendered
   in its entirety (the cubeCamera is placed at the origin).

📦:fromEquirectangular( Texture equirectangular ) WebGLRenderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `equirectangular <#Texture>`__ - The equirectangular texture.
   Generates a PMREM from an equirectangular texture.

📦:fromCubemap( CubeTexture cubemap ) WebGLRenderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `cubemap <#CubeTexture>`__ - The cubemap texture.
   Generates a PMREM from an cubemap texture.

📦:compileCubemapShader() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Pre-compiles the cubemap shader. You can get faster start-up by invoking this method
   during your texture's network fetch for increased concurrency.

📦:compileEquirectangularShader() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Pre-compiles the equirectangular shader. You can get faster start-up by invoking this
   method during your texture's network fetch for increased concurrency.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D068:

ShapeUtils
==========

   https://threejs.org/docs/api/en/extras/ShapeUtils.html

   A class containing utility functions for shapes.
   Note that these are all linear functions so it is necessary to calculate separately for
   x, y (and z, w if present) components of a vector.

Methods
-------

📦:area( contour ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~

   contour -- 2D polygon. An array of THREE.Vector2()
   Calculate area of a ( 2D ) contour polygon.

📦:isClockWise( pts ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   pts -- points defining a 2D polygon
   Note that this is a linear function so it is necessary to calculate separately for x, y
   components of a polygon.
   Used internally by `Path <#Path>`__, `ExtrudeGeometry <#ExtrudeGeometry>`__ and
   `ShapeGeometry <#ShapeGeometry>`__.

📦:triangulateShape( contour, holes ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   contour -- 2D polygon. An array of ``Vector2``.
   holes -- An array that holds arrays of ``Vector2``s. Each array represents a single
   hole definition.
   Used internally by `ExtrudeGeometry <#ExtrudeGeometry>`__ and `ShapeGeometry <#ShapeGeometry>`__ 
   to calculate faces in shapes with holes.



.. _D069:

TextureUtils
============

   https://threejs.org/docs/api/en/extras/TextureUtils.html

   A class containing utility functions for textures.

Methods
-------

📦:contain( Texture texture, Number aspect ) Texture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Scales the texture as large as possible within its surface without cropping or stretching
   the texture. The method preserves the original aspect ratio of the texture. Akin to CSS
   ``object-fit: contain``.

📦:cover( Texture texture, Number aspect ) Texture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Scales the texture to the smallest possible size to fill the surface, leaving no empty
   space. The method preserves the original aspect ratio of the texture. Akin to CSS
   ``object-fit: cover``.

📦:fill( Texture texture ) Texture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Configures the texture to the default transformation. Akin to CSS ``object-fit: fill``.

📦:getByteLength( Number width, Number height, Number format, Number type ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Given the width, height, format, and type of a texture. Determines how many bytes must be
   used to represent the texture.



.. _D070:

Curve
=====

   https://threejs.org/docs/api/en/extras/core/Curve.html

   An abstract base class for creating a ``PMREMGenerator`` object that contains methods for
   interpolation. For an array of ``PMREMGenerator``s see ``CurvePath``.

   .. Constructor


🐣:Curve()
~~~~~~~~~

   This constructor creates a new ``Curve``.

Properties
----------

⭕:Integer arcLengthDivisions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This value determines the amount of divisions when calculating the cumulative segment
   lengths of a curve via ``.getLengths``. To ensure precision when using methods like
   ``.getSpacedPoints``, it is recommended to increase ``.arcLengthDivisions`` if the
   curve is very large. Default is ``200``.

Methods
-------

📦:getPoint( Float t, Vector optionalTarget ) Vector
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `t <#Float>`__ - A position on the curve. Must be in the range [ 0, 1 ].
   `optionalTarget <#Vector>`__ — (optional) If specified, the result will be copied into
   this Vector, otherwise a new Vector will be created.
   Returns a vector for a given position on the curve.

📦:getPointAt( Float u, Vector optionalTarget ) Vector
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `u <#Float>`__ - A position on the curve according to the arc length. Must be in the
   range [ 0, 1 ].
   `optionalTarget <#Vector>`__ — (optional) If specified, the result will be copied into
   this Vector, otherwise a new Vector will be created.
   Returns a vector for a given position on the curve according to the arc length.

📦:getPoints( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   divisions -- number of pieces to divide the curve into. Default is ``5``.
   Returns a set of divisions + 1 points using getPoint( t ).

📦:getSpacedPoints( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   divisions -- number of pieces to divide the curve into. Default is ``5``.
   Returns a set of divisions + 1 equi-spaced points using getPointAt( u ).

📦:getLength() Float
~~~~~~~~~~~~~~~~~~~~~

   Get total curve arc length.

📦:getLengths( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get list of cumulative segment lengths.

📦:updateArcLengths() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the cumulative segment distance cache. The method must be called every time curve
   parameters are changed. If an updated curve is part of a composed curve like
   ``CurvePath``, ``.updateArcLengths``() must be called on the composed curve, too.

📦:getUtoTmapping( Float u, Float distance ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Given u in the range ( 0 .. 1 ), returns `t <#Float>`__ also in the range ( 0 .. 1 ). u
   and t can then be used to give you points which are equidistant from the ends of the
   curve, using ``.getPoint``.

📦:getTangent( Float t, Vector optionalTarget ) Vector
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `t <#Float>`__ - A position on the curve. Must be in the range [ 0, 1 ].
   `optionalTarget <#Vector>`__ — (optional) If specified, the result will be copied into
   this Vector, otherwise a new Vector will be created.
   Returns a unit vector tangent at t. If the derived curve does not implement its tangent
   derivation, two points a small delta apart will be used to find its gradient which seems
   to give a reasonable approximation.

📦:getTangentAt( Float u, Vector optionalTarget ) Vector
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `u <#Float>`__ - A position on the curve according to the arc length. Must be in the
   range [ 0, 1 ].
   `optionalTarget <#Vector>`__ — (optional) If specified, the result will be copied into
   this Vector, otherwise a new Vector will be created.
   Returns tangent at a point which is equidistant to the ends of the curve from the point
   given in ``.getTangent``.

📦:computeFrenetFrames( Integer segments, Boolean closed ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries
   like ``TubeGeometry`` or ``ExtrudeGeometry``.

📦:clone() Curve
~~~~~~~~~~~~~~~~~

   Creates a clone of this instance.

📦:copy( Curve source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies another ``Curve`` object to this instance.

📦:toJSON() Object
~~~~~~~~~~~~~~~~~~~

   Returns a JSON object representation of this instance.

📦:fromJSON( Object json ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the data from the given JSON object to this instance.



.. _D071:

Curve → CurvePath
=================

   https://threejs.org/docs/api/en/extras/core/CurvePath.html

   An abstract base class extending ``Curve``. A CurvePath is simply an array of connected
   curves, but retains the api of a curve.

   .. Constructor


🐣:CurvePath()
~~~~~~~~~~~~~

   The constructor take no parameters.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Array curves
~~~~~~~~~~~~~~~~

   The array of `Curves <#Curve>`__.

⭕:Boolean autoClose
~~~~~~~~~~~~~~~~~~~~~

   Whether or not to automatically close the path.

Methods
-------

   See the base ``Curve`` class for common methods.

📦:add( Curve curve ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Add a curve to the ``.curves`` array.

📦:closePath() this
~~~~~~~~~~~~~~~~~~~~

   Adds a `lineCurve <#LineCurve>`__ to close the path.

📦:getCurveLengths() Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get list of cumulative curve lengths of the curves in the ``.curves`` array.

📦:getPoints( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   divisions -- number of pieces to divide the curve into. Default is ``12``.
   Returns an array of points representing a sequence of curves. The ``division`` parameter
   defines the number of pieces each curve is divided into. However, for optimization and
   quality purposes, the actual sampling resolution for each curve depends on its type. For
   example, for a ``LineCurve``, the returned number of points is always just 2.

📦:getSpacedPoints( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   divisions -- number of pieces to divide the curve into. Default is ``40``.
   Returns a set of divisions + 1 equi-spaced points using getPointAt( u ).



.. _D072:

Interpolations
==============

   https://threejs.org/docs/api/en/extras/core/Interpolations.html

   ``CurvePath`` contains spline and Bézier functions internally used by concrete curve classes.

Methods
-------

📦:CatmullRom( Float t, Float p0, Float p1, Float p2, Float p3 ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   t -- interpolation weight.
   p0, p1, p2, p3 -- the points defining the spline curve.
   Used internally by `SplineCurve <#SplineCurve>`__.

📦:QuadraticBezier( Float t, Float p0, Float p1, Float p2 ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   t -- interpolation weight.
   p0, p1, p2 -- the starting, control and end points defining the curve.
   Used internally by `QuadraticBezierCurve3 <#QuadraticBezierCurve3>`__ and
   `QuadraticBezierCurve <#QuadraticBezierCurve>`__.

📦:CubicBezier( Float t, Float p0, Float p1, Float p2, Float p3 ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   t -- interpolation weight.
   p0, p1, p2, p3 -- the starting, control(twice) and end points defining the curve.
   Used internally by `CubicBezierCurve3 <#CubicBezierCurve3>`__ and `CubicBezierCurve <#CubicBezierCurve>`__.



.. _D073:

Curve → CurvePath → Path
========================

   https://threejs.org/docs/api/en/extras/core/Path.html

   A 2D path representation. The class provides methods for creating paths and contours of 2D
   shapes similar to the 2D Canvas API.

   **Code Example**


   .. code:: javascript

      const path = new THREE.Path();
      path.lineTo( 0, 0.8 );
      path.quadraticCurveTo( 0, 1, 0.2, 1 );
      path.lineTo( 1, 1 );
      const points = path.getPoints();
      const geometry = new THREE.BufferGeometry().setFromPoints( points );
      const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
      const line = new THREE.Line( geometry, material );
      scene.add( line );


   .. Constructor

🐣:Path( Array points )
~~~~~~~~~~~~~~~~~~~~~~

   points -- (optional) array of `Vector2s <#Vector2>`__.
   Creates a Path from the points. The first point defines the offset, then successive
   points are added to the `curves <#CurvePath.curves>`__ array as `LineCurves <#LineCurve>`__.
   If no points are specified, an empty path is created and the ``.currentPoint`` is set
   to the origin.

Properties
----------

   See the base ``CurvePath`` class for common properties.

⭕:Vector2 currentPoint
~~~~~~~~~~~~~~~~~~~~~~~~

   The current offset of the path. Any new ``Curve`` added will start here.

Methods
-------

   See the base ``CurvePath`` class for common methods.

📦:absarc( Float x, Float y, Float radius, Float startAngle, Float endAngle, Boolean clockwise ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   x, y -- The absolute center of the arc.
   radius -- The radius of the arc.
   startAngle -- The start angle in radians.
   endAngle -- The end angle in radians.
   clockwise -- Sweep the arc clockwise. Defaults to ``false``.
   Adds an absolutely positioned `EllipseCurve <#EllipseCurve>`__ to the path.

📦:absellipse( Float x, Float y, Float xRadius, Float yRadius, Float startAngle, Float endAngle, Boolean clockwise, Float rotation ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   x, y -- The absolute center of the ellipse.
   xRadius -- The radius of the ellipse in the x axis.
   yRadius -- The radius of the ellipse in the y axis.
   startAngle -- The start angle in radians.
   endAngle -- The end angle in radians.
   clockwise -- Sweep the ellipse clockwise. Defaults to false.
   rotation -- The rotation angle of the ellipse in radians, counterclockwise from the
   positive X axis. Optional, defaults to ``0``.
   Adds an absolutely positioned `EllipseCurve <#EllipseCurve>`__ to the path.

📦:arc( Float x, Float y, Float radius, Float startAngle, Float endAngle, Boolean clockwise ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   x, y -- The center of the arc offset from the last call.
   radius -- The radius of the arc.
   startAngle -- The start angle in radians.
   endAngle -- The end angle in radians.
   clockwise -- Sweep the arc clockwise. Defaults to ``false``.
   Adds an `EllipseCurve <#EllipseCurve>`__ to the path, positioned relative to
   ``.currentPoint``.

📦:bezierCurveTo( Float cp1X, Float cp1Y, Float cp2X, Float cp2Y, Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This creates a bezier curve from ``.currentPoint`` with (cp1X, cp1Y) and (cp2X, cp2Y)
   as control points and updates ``.currentPoint`` to x and y.

📦:ellipse( Float x, Float y, Float xRadius, Float yRadius, Float startAngle, Float endAngle, Boolean clockwise, Float rotation ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   x, y -- The center of the ellipse offset from the last call.
   xRadius -- The radius of the ellipse in the x axis.
   yRadius -- The radius of the ellipse in the y axis.
   startAngle -- The start angle in radians.
   endAngle -- The end angle in radians.
   clockwise -- Sweep the ellipse clockwise. Defaults to ``false``.
   rotation -- The rotation angle of the ellipse in radians, counterclockwise from the
   positive X axis. Optional, defaults to ``0``.
   Adds an `EllipseCurve <#EllipseCurve>`__ to the path, positioned relative to
   ``.currentPoint``.

📦:lineTo( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Connects a ``LineCurve`` from ``.currentPoint`` to x, y onto the path.

📦:moveTo( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Move the ``.currentPoint`` to x, y.

📦:quadraticCurveTo( Float cpX, Float cpY, Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a quadratic curve from ``.currentPoint`` with cpX and cpY as control point and
   updates ``.currentPoint`` to x and y.

📦:setFromPoints( Array vector2s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points -- array of `Vector2s <#Vector2>`__.
   Points are added to the `curves <#CurvePath.curves>`__ array as `LineCurves <#LineCurve>`__.

📦:splineThru ( Array points ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points - An array of `Vector2s <#Vector2>`__
   Connects a new ``SplineCurve`` onto the path.



.. _D074:

Curve → CurvePath → Path → Shape
================================

   https://threejs.org/docs/api/en/extras/core/Shape.html

   Defines an arbitrary 2d shape plane using paths with optional holes. It can be used with
   ``ExtrudeGeometry``, ``ShapeGeometry``, to get points, or to get triangulated faces.

   **Code Example**


   .. code:: javascript

      const heartShape = new THREE.Shape();
      heartShape.moveTo( 25, 25 );
      heartShape.bezierCurveTo( 25, 25, 20, 0, 0, 0 );
      heartShape.bezierCurveTo( - 30, 0, - 30, 35, - 30, 35 );
      heartShape.bezierCurveTo( - 30, 55, - 10, 77, 25, 95 );
      heartShape.bezierCurveTo( 60, 77, 80, 55, 80, 35 );
      heartShape.bezierCurveTo( 80, 35, 80, 0, 50, 0 );
      heartShape.bezierCurveTo( 35, 0, 25, 25, 25, 25 );
      const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, 
            steps: 2, bevelSize: 1, bevelThickness: 1 };
      const geometry = new THREE.ExtrudeGeometry( heartShape, extrudeSettings );
      const mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial() );


   **Examples**

   [example:webgl_geometry_shapes geometry / shapes ]
   [example:webgl_geometry_extrude_shapes geometry / extrude / shapes ]

   .. Constructor

🐣:Shape( Array points )
~~~~~~~~~~~~~~~~~~~~~~~

   points -- (optional) array of `Vector2s <#Vector2>`__.
   Creates a Shape from the points. The first point defines the offset, then successive
   points are added to the `curves <#CurvePath.curves>`__ array as `LineCurves <#LineCurve>`__.
   If no points are specified, an empty shape is created and the ``.currentPoint`` is
   set to the origin.

Properties
----------

   See the base ``Path`` class for common properties.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this instance.
   This gets automatically assigned, so this shouldn't be edited.

⭕:Array holes
~~~~~~~~~~~~~~~

   An array of `paths <#Path>`__ that define the holes in the shape.

Methods
-------

   See the base ``Path`` class for common methods.

📦:extractPoints( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   divisions -- The fineness of the result.
   Call `getPoints <#Curve.getPoints>`__ on the shape and the ``.holes`` array, and
   return an object of the form: ``{ shape holes }`` where shape and holes are arrays of
   `Vector2s <#Vector2>`__.

📦:getPointsHoles( Integer divisions ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   divisions -- The fineness of the result.
   Get an array of `Vector2s <#Vector2>`__ that represent the holes in the shape.



.. _D075:

ShapePath
=========

   https://threejs.org/docs/api/en/extras/core/ShapePath.html

   This class is used to convert a series of shapes to an array of ``Path``s, for example
   an SVG shape to a path.

   .. Constructor


🐣:ShapePath( )
~~~~~~~~~~~~~~

   Creates a new ShapePath. Unlike a ``Path``, no points are passed in as the ShapePath is
   designed to be generated after creation.

Properties
----------

⭕:Array subPaths
~~~~~~~~~~~~~~~~~~

   Array of ``Path``s.

⭕:Array currentPath
~~~~~~~~~~~~~~~~~~~~~

   The current ``Path`` that is being generated.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the shape, by default set to white (0xffffff).

Methods
-------

📦:moveTo( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Starts a new ``Path`` and calls ``Path.moveTo``( x, y ) on that ``Path``. Also
   points `currentPath <#ShapePath.currentPath>`__ to that ``Path``.

📦:lineTo( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This creates a line from the `currentPath <#ShapePath.currentPath>`__'s offset to X and Y
   and updates the offset to X and Y.

📦:quadraticCurveTo( Float cpX, Float cpY, Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This creates a quadratic curve from the `currentPath <#ShapePath.currentPath>`__'s offset
   to x and y with cpX and cpY as control point and updates the `currentPath <#ShapePath.currentPath>`__'s 
   offset to x and y.

📦:bezierCurveTo( Float cp1X, Float cp1Y, Float cp2X, Float cp2Y, Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This creates a bezier curve from the `currentPath <#ShapePath.currentPath>`__'s offset to
   x and y with cp1X, cp1Y and cp2X, cp2Y as control points and updates the
   `currentPath <#ShapePath.currentPath>`__'s offset to x and y.

📦:splineThru ( Array points ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points - An array of ``Vector2``s

   Connects a new ``SplineCurve`` onto the `currentPath <#ShapePath.currentPath>`__.

📦:toShapes( Boolean isCCW ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   isCCW -- Changes how solids and holes are generated

   Converts the `subPaths <#ShapePath.subPaths>`__ array into an array of Shapes. By
   default solid shapes are defined clockwise (CW) and holes are defined counterclockwise
   (CCW). If isCCW is set to true, then those are flipped.



.. _D076:

Curve → EllipseCurve → ArcCurve
===============================

   https://threejs.org/docs/api/en/extras/curves/ArcCurve.html

   Alias for ``EllipseCurve``.

Properties
----------

   See the ``EllipseCurve`` class for common properties.



.. _D077:

Curve → CatmullRomCurve3
========================

   https://threejs.org/docs/api/en/extras/curves/CatmullRomCurve3.html

   Create a smooth 3d spline curve from a series of points using the
   `Catmull-Rom <https://en.wikipedia.org/wiki/Centripetal_Catmull-Rom_spline>`__ algorithm.

   **Code Example**


   .. code:: javascript

      //Create a closed wavey loop
      const curve = new THREE.CatmullRomCurve3( [
         new THREE.Vector3( -10, 0, 10 ),
         new THREE.Vector3( -5, 5, 5 ),
         new THREE.Vector3( 0, 0, 0 ),
         new THREE.Vector3( 5, -5, 5 ),
         new THREE.Vector3( 10, 0, 10 )
      ] );

      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );

      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

      // Create the final object to add to the scene
      const curveObject = new THREE.Line( geometry, material );


   **Examples**

   [example:webgl_geometry_extrude_splines WebGL / geometry / extrude / splines]

   .. Constructor

🐣:CatmullRomCurve3( Array points, Boolean closed, String curveType, Float tension )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points – An array of ``Vector3`` points
   closed – Whether the curve is closed. Default is ``false``.
   curveType – Type of the curve. Default is ``centripetal``.
   tension – Tension of the curve. Default is ``0.5``.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Array points
~~~~~~~~~~~~~~~~

   The array of ``Vector3`` points that define the curve. It needs at least two entries.

⭕:Boolean closed
~~~~~~~~~~~~~~~~~~

   The curve will loop back onto itself when this is true.

⭕:String curveType
~~~~~~~~~~~~~~~~~~~~

   Possible values are ``centripetal``, ``chordal`` and ``catmullrom``.

⭕:Float tension
~~~~~~~~~~~~~~~~~

   When ``.curveType`` is ``catmullrom``, defines catmullrom's tension.

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D078:

Curve → CubicBezierCurve
========================

   https://threejs.org/docs/api/en/extras/curves/CubicBezierCurve.html

   Create a smooth 2d `cubic bezier
   curve <http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg>`__,
   defined by a start point, endpoint and two control points.

   **Code Example**


   .. code:: javascript

      const curve = new THREE.CubicBezierCurve( 
         new THREE.Vector2( -10, 0 ), 
         new THREE.Vector2( -5, 15 ), 
         new THREE.Vector2( 20, 15 ), 
         new THREE.Vector2( 10, 0 ) );
      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );
      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
      // Create the final object to add to the scene 
      const curveObject = new THREE.Line( geometry, material );


   .. Constructor

   ``CatmullRomCurve3`` ( [param:Vector2 v0], [param:Vector2 v1], [param:Vector2 v2], [param:Vector2 v3] )
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v0 <#Vector2>`__ – The starting point.
   `v1 <#Vector2>`__ – The first control point.
   `v2 <#Vector2>`__ – The second control point.
   `v3 <#Vector2>`__ – The ending point.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Vector2 v0
~~~~~~~~~~~~~~

   The starting point.

⭕:Vector2 v1
~~~~~~~~~~~~~~

   The first control point.

⭕:Vector2 v2
~~~~~~~~~~~~~~

   The second control point.

⭕:Vector2 v3
~~~~~~~~~~~~~~

   The ending point.

Methods
-------

   See the base ``Curve`` class for common Methods.



.. _D079:

Curve → CubicBezierCurve3
=========================

   https://threejs.org/docs/api/en/extras/curves/CubicBezierCurve3.html

   Create a smooth 3d `cubic bezier
   curve <http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg>`__,
   defined by a start point, endpoint and two control points.

   **Code Example**


   .. code:: javascript

      const curve = new THREE.CubicBezierCurve3( 
         new THREE.Vector3( -10, 0, 0 ), 
         new THREE.Vector3( -5, 15, 0 ), 
         new THREE.Vector3( 20, 15, 0 ), 
         new THREE.Vector3( 10, 0, 0 ) 
      );
      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );
      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
      // Create the final object to add to the scene 
      const curveObject = new THREE.Line( geometry, material );


   .. Constructor

🐣:CubicBezierCurve3( Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v0 <#Vector3>`__ – The starting point.
   `v1 <#Vector3>`__ – The first control point.
   `v2 <#Vector3>`__ – The second control point.
   `v3 <#Vector3>`__ – The ending point.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Vector3 v0
~~~~~~~~~~~~~~

   The starting point.

⭕:Vector3 v1
~~~~~~~~~~~~~~

   The first control point.

⭕:Vector3 v2
~~~~~~~~~~~~~~

   The second control point.

⭕:Vector3 v3
~~~~~~~~~~~~~~

   The ending point.

Methods
-------

   See the base ``Curve`` class for common Methods.



.. _D080:

Curve → EllipseCurve
====================

   https://threejs.org/docs/api/en/extras/curves/EllipseCurve.html

   Creates a 2d curve in the shape of an ellipse. Setting the `xRadius <#Number>`__ equal to
   the `yRadius <#Number>`__ will result in a circle.

   **Code Example**


   .. code:: javascript

      const curve = new THREE.EllipseCurve(
         0,  0,            // ax, aY
         10, 10,           // xRadius, yRadius
         0,  2 * Math.PI,  // aStartAngle, aEndAngle
         false,            // aClockwise
         0                 // aRotation
      );

      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );

      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

      // Create the final object to add to the scene
      const ellipse = new THREE.Line( geometry, material );


   .. Constructor

🐣:EllipseCurve( Float aX, Float aY, Float xRadius, Float yRadius, Radians aStartAngle, Radians aEndAngle, Boolean aClockwise, Radians aRotation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `aX <#Float>`__ – The X center of the ellipse. Default is ``0``.
   `aY <#Float>`__ – The Y center of the ellipse. Default is ``0``.
   `xRadius <#Float>`__ – The radius of the ellipse in the x direction. Default is ``1``.
   `yRadius <#Float>`__ – The radius of the ellipse in the y direction. Default is ``1``.
   `aStartAngle <#Radians>`__ – The start angle of the curve in radians starting from the
   positive X axis. Default is ``0``.
   `aEndAngle <#Radians>`__ – The end angle of the curve in radians starting from the
   positive X axis. Default is ``2 x Math.PI``.
   `aClockwise <#Boolean>`__ – Whether the ellipse is drawn clockwise.
   Default is ``false``.
   `aRotation <#Radians>`__ – The rotation angle of the ellipse in radians,
   counterclockwise from the positive X axis (optional). Default is ``0``.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Float aX
~~~~~~~~~~~~

   The X center of the ellipse.

⭕:Float aY
~~~~~~~~~~~~

   The Y center of the ellipse.

⭕:Radians xRadius
~~~~~~~~~~~~~~~~~~~

   The radius of the ellipse in the x direction.

⭕:Radians yRadius
~~~~~~~~~~~~~~~~~~~

   The radius of the ellipse in the y direction.

⭕:Float aStartAngle
~~~~~~~~~~~~~~~~~~~~~

   The start angle of the curve in radians starting from the middle right side.

⭕:Float aEndAngle
~~~~~~~~~~~~~~~~~~~

   The end angle of the curve in radians starting from the middle right side.

⭕:Boolean aClockwise
~~~~~~~~~~~~~~~~~~~~~~

   Whether the ellipse is drawn clockwise.

⭕:Float aRotation
~~~~~~~~~~~~~~~~~~~

   The rotation angle of the ellipse in radians, counterclockwise from the positive X axis
   (optional). Default is ``0``.

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D081:

Curve → LineCurve
=================

   https://threejs.org/docs/api/en/extras/curves/LineCurve.html

   A curve representing a 2d line segment.

   .. Constructor

🐣:LineCurve( Vector2 v1, Vector2 v2 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v1 <#Vector2>`__ – The start point.
   `v2 <#Vector2>`__ - The end point.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Vector2 v1
~~~~~~~~~~~~~~

   The start point.

⭕:Vector2 v2
~~~~~~~~~~~~~~

   The end point

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D082:

Curve → LineCurve3
==================

   https://threejs.org/docs/api/en/extras/curves/LineCurve3.html

   A curve representing a 3d line segment.

   .. Constructor

🐣:LineCurve3( Vector3 v1, Vector3 v2 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v1 <#Vector3>`__ – The start point.
   `v2 <#Vector3>`__ - The end point.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Vector3 v1
~~~~~~~~~~~~~~

   The start point.

⭕:Vector3 v2
~~~~~~~~~~~~~~

   The end point.

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D083:

Curve → QuadraticBezierCurve
============================

   https://threejs.org/docs/api/en/extras/curves/QuadraticBezierCurve.html

   Create a smooth 2d `quadratic bezier
   curve <http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif>`__,
   defined by a startpoint, endpoint and a single control point.

   **Code Example**


   .. code:: javascript

      const curve = new THREE.QuadraticBezierCurve(
         new THREE.Vector2( -10, 0 ),
         new THREE.Vector2( 20, 15 ),
         new THREE.Vector2( 10, 0 )
      );

      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );

      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

      // Create the final object to add to the scene
      const curveObject = new THREE.Line( geometry, material );



   .. Constructor

🐣:QuadraticBezierCurve( Vector2 v0, Vector2 v1, Vector2 v2 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v0 <#Vector2>`__ – The startpoint.
   `v1 <#Vector2>`__ – The control point.
   `v2 <#Vector2>`__ – The endpoint.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Vector2 v0
~~~~~~~~~~~~~~

   The startpoint.

⭕:Vector2 v1
~~~~~~~~~~~~~~

   The control point.

⭕:Vector2 v2
~~~~~~~~~~~~~~

   The endpoint.

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D084:

Curve → QuadraticBezierCurve3
=============================

   https://threejs.org/docs/api/en/extras/curves/QuadraticBezierCurve3.html

   Create a smooth 3d `quadratic bezier
   curve <http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif>`__,
   defined by a startpoint, endpoint and a single control point.

   **Code Example**


   .. code:: javascript

      const curve = new THREE.QuadraticBezierCurve3(
         new THREE.Vector3( -10, 0, 0 ),
         new THREE.Vector3( 20, 15, 0 ),
         new THREE.Vector3( 10, 0, 0 )
      );

      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );

      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

      // Create the final object to add to the scene
      const curveObject = new THREE.Line( geometry, material );


   .. Constructor

🐣:QuadraticBezierCurve3( Vector3 v0, Vector3 v1, Vector3 v2 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v0 <#Vector3>`__ – The starting point
   `v1 <#Vector3>`__ – The middle control point
   `v2 <#Vector3>`__ – The ending point

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Vector3 v0
~~~~~~~~~~~~~~

   The startpoint.

⭕:Vector3 v1
~~~~~~~~~~~~~~

   The control point.

⭕:Vector3 v2
~~~~~~~~~~~~~~

   The endpoint.

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D085:

Curve → SplineCurve
===================

   https://threejs.org/docs/api/en/extras/curves/SplineCurve.html

   Create a smooth 2d spline curve from a series of points. Internally this uses
   ``Interpolations.CatmullRom`` to create the curve.

   **Code Example**


   .. code:: javascript

      // Create a sine-like wave
      const curve = new THREE.SplineCurve( [
         new THREE.Vector2( -10, 0 ),
         new THREE.Vector2( -5, 5 ),
         new THREE.Vector2( 0, 0 ),
         new THREE.Vector2( 5, -5 ),
         new THREE.Vector2( 10, 0 )
      ] );

      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );

      const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

      // Create the final object to add to the scene
      const splineObject = new THREE.Line( geometry, material );


   .. Constructor

🐣:SplineCurve( Array points )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points – An array of ``Vector2`` points that define the curve.

Properties
----------

   See the base ``Curve`` class for common properties.

⭕:Array points
~~~~~~~~~~~~~~~~

   The array of ``Vector2`` points that define the curve.

Methods
-------

   See the base ``Curve`` class for common methods.



.. _D086:

BufferGeometry → BoxGeometry
============================

   https://threejs.org/docs/api/en/geometries/BoxGeometry.html

   ``SplineCurve`` is a geometry class for a rectangular cuboid with a given 'width', 'height', and
   'depth'. On creation, the cuboid is centred on the origin, with each edge parallel to one
   of the axes.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 1, 1, 1 );
      const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
      const cube = new THREE.Mesh( geometry, material );
      scene.add( cube );


   .. Constructor

🐣:BoxGeometry(Float width, Float height, Float depth, Integer widthSegments, Integer heightSegments, Integer depthSegments)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   width — Width; that is, the length of the edges parallel to the X axis. Optional;
   defaults to ``1``.
   height — Height; that is, the length of the edges parallel to the Y axis. Optional;
   defaults to ``1``.
   depth — Depth; that is, the length of the edges parallel to the Z axis. Optional;
   defaults to ``1``.
   widthSegments — Number of segmented rectangular faces along the width of the sides.
   Optional; defaults to ``1``.
   heightSegments — Number of segmented rectangular faces along the height of the sides.
   Optional; defaults to ``1``.
   depthSegments — Number of segmented rectangular faces along the depth of the sides.
   Optional; defaults to ``1``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D087:

BufferGeometry → LatheGeometry → CapsuleGeometry
================================================

   https://threejs.org/docs/api/en/geometries/CapsuleGeometry.html

   ``BoxGeometry`` is a geometry class for a capsule with given radii and height. It is constructed
   using a lathe.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.CapsuleGeometry( 1, 1, 4, 8 );
      const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
      const capsule = new THREE.Mesh( geometry, material );
      scene.add( capsule );


   .. Constructor

🐣:CapsuleGeometry(Float radius, Float length, Integer capSegments, Integer radialSegments)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Radius of the capsule. Optional; defaults to ``1``.
   length — Length of the middle section. Optional; defaults to ``1``.
   capSegments — Number of curve segments used to build the caps. Optional; defaults to
   ``4``.
   radialSegments — Number of segmented faces around the circumference of the capsule.
   Optional; defaults to ``8``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D088:

BufferGeometry → CircleGeometry
===============================

   https://threejs.org/docs/api/en/geometries/CircleGeometry.html

   ``CapsuleGeometry`` is a simple shape of Euclidean geometry. It is constructed from a number of
   triangular segments that are oriented around a central point and extend as far out as a
   given radius. It is built counter-clockwise from a start angle and a given central angle.
   It can also be used to create regular polygons, where the number of segments determines
   the number of sides.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.CircleGeometry( 5, 32 );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const circle = new THREE.Mesh( geometry, material );
      scene.add( circle );


   .. Constructor

🐣:CircleGeometry(Float radius, Integer segments, Float thetaStart, Float thetaLength)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Radius of the circle, default = 1.
   segments — Number of segments (triangles), minimum = ``3``, default = ``32``.
   thetaStart — Start angle for first segment, default = ``0`` (three o'clock position).
   thetaLength — The central angle, often called theta, of the circular sector. The default
   is \`2`*Pi, which makes for a complete circle.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D089:

BufferGeometry → CylinderGeometry → ConeGeometry
================================================

   https://threejs.org/docs/api/en/geometries/ConeGeometry.html

   A class for generating cone geometries.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.ConeGeometry( 5, 20, 32 );
      const material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
      const cone = new THREE.Mesh(geometry, material );
      scene.add( cone );


   .. Constructor

🐣:ConeGeometry(Float radius, Float height, Integer radialSegments, Integer heightSegments, Boolean openEnded, Float thetaStart, Float thetaLength)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Radius of the cone base. Default is ``1``.
   height — Height of the cone. Default is ``1``.
   radialSegments — Number of segmented faces around the circumference of the cone.
   Default is ``32``
   heightSegments — Number of rows of faces along the height of the cone. Default is ``1``.
   openEnded — A Boolean indicating whether the base of the cone is open or capped.
   Default is false, meaning capped.
   thetaStart — Start angle for first segment, default = 0 (three o'clock position).
   thetaLength — The central angle, often called theta, of the circular sector. The default
   is \`2`*Pi, which makes for a complete cone.

Properties
----------

   See the base ``CylinderGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``CylinderGeometry`` class for common methods.



.. _D090:

BufferGeometry → CylinderGeometry
=================================

   https://threejs.org/docs/api/en/geometries/CylinderGeometry.html

   A class for generating cylinder geometries.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
      const material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
      const cylinder = new THREE.Mesh( geometry, material );
      scene.add( cylinder );


   .. Constructor

🐣:CylinderGeometry(Float radiusTop, Float radiusBottom, Float height, Integer radialSegments, Integer heightSegments, Boolean openEnded, Float thetaStart, Float thetaLength)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radiusTop — Radius of the cylinder at the top. Default is ``1``.
   radiusBottom — Radius of the cylinder at the bottom. Default is ``1``.
   height — Height of the cylinder. Default is ``1``.
   radialSegments — Number of segmented faces around the circumference of the cylinder.
   Default is ``32``
   heightSegments — Number of rows of faces along the height of the cylinder.
   Default is ``1``.
   openEnded — A Boolean indicating whether the ends of the cylinder are open or capped.
   Default is false, meaning capped.
   thetaStart — Start angle for first segment, default = 0 (three o'clock position).
   thetaLength — The central angle, often called theta, of the circular sector. The default
   is \`2`*Pi, which makes for a complete cylinder.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D091:

BufferGeometry → PolyhedronGeometry] DodecahedronGeometry
=========================================================

   https://threejs.org/docs/api/en/geometries/DodecahedronGeometry.html

   A class for generating a dodecahedron geometries.

   .. Constructor

🐣:DodecahedronGeometry(Float radius, Integer detail)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Radius of the dodecahedron. Default is ``1``.
   detail — Default is ``0``. Setting this to a value greater than ``0`` adds vertices
   making it no longer a dodecahedron.

Properties
----------

   See the base ``PolyhedronGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``PolyhedronGeometry`` class for common methods.



.. _D092:

BufferGeometry → EdgesGeometry
==============================

   https://threejs.org/docs/api/en/geometries/EdgesGeometry.html

   This can be used as a helper object to view the edges of a `geometry <#BufferGeometry>`__.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 100, 100, 100 );
      const edges = new THREE.EdgesGeometry( geometry );
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
      scene.add( line );


   **Examples**

   [example:webgl_helpers helpers]

   .. Constructor

🐣:EdgesGeometry( BufferGeometry geometry, Integer thresholdAngle )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry — Any geometry object.
   thresholdAngle — An edge is only rendered if the angle (in degrees) between the face
   normals of the adjoining faces exceeds this value. default = 1 degree.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D093:

BufferGeometry → ExtrudeGeometry
================================

   https://threejs.org/docs/api/en/geometries/ExtrudeGeometry.html

   Creates extruded geometry from a path shape.

   **Code Example**


   .. code:: javascript

      const length = 12, width = 8;
      const shape = new THREE.Shape();
      shape.moveTo( 0,0 );
      shape.lineTo( 0, width );
      shape.lineTo( length, width );
      shape.lineTo( length, 0 );
      shape.lineTo( 0, 0 );
      const extrudeSettings = { 
         steps: 2, 
         depth: 16, 
         bevelEnabled: true, 
         bevelThickness: 1, 
         bevelSize: 1, 
         bevelOffset: 0, 
         bevelSegments: 1 
      };
      const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const mesh = new THREE.Mesh( geometry, material ) ;
      scene.add( mesh );


   .. Constructor

🐣:ExtrudeGeometry(Array shapes, Object options)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   shapes — Shape or an array of shapes.
   options — Object that can contain the following parameters.

   -  curveSegments — int. Number of points on the curves. Default is ``12``.
   -  steps — int. Number of points used for subdividing segments along the depth of the
      extruded spline. Default is ``1``.
   -  depth — float. Depth to extrude the shape. Default is ``1``.
   -  bevelEnabled — bool. Apply beveling to the shape. Default is true.
   -  bevelThickness — float. How deep into the original shape the bevel goes. Default is
      ``0.2``.
   -  bevelSize — float. Distance from the shape outline that the bevel extends. Default is
      bevelThickness - 0.1.
   -  bevelOffset — float. Distance from the shape outline that the bevel starts. Default is
      ``0``.
   -  bevelSegments — int. Number of bevel layers. Default is ``3``.
   -  extrudePath — THREE.Curve. A 3D spline path along which the shape should be extruded.
      Bevels not supported for path extrusion.
   -  UVGenerator — Object. object that provides UV generator functions

   This object extrudes a 2D shape to a 3D geometry.

   When creating a Mesh with this geometry, if you'd like to have a separate material used
   for its face and its extruded sides, you can use an array of materials. The first material
   will be applied to the face; the second material will be applied to the sides.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D094:

BufferGeometry → PolyhedronGeometry → IcosahedronGeometry
=========================================================

   https://threejs.org/docs/api/en/geometries/IcosahedronGeometry.html

   A class for generating an icosahedron geometry.

   .. Constructor

🐣:IcosahedronGeometry(Float radius, Integer detail)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Default is ``1``.
   detail — Default is ``0``. Setting this to a value greater than ``0`` adds more vertices
   making it no longer an icosahedron. When detail is greater than 1, it's effectively a
   sphere.

Properties
----------

   See the base ``PolyhedronGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``PolyhedronGeometry`` class for common methods.



.. _D095:

BufferGeometry → LatheGeometry
==============================

   https://threejs.org/docs/api/en/geometries/LatheGeometry.html

   Creates meshes with axial symmetry like vases. The lathe rotates around the Y axis.

   **Code Example**


   .. code:: javascript

      const points = [];
      for ( let i = 0;
      i < 10;
      i ++ ) { points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
      } const geometry = new THREE.LatheGeometry( points );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const lathe = new THREE.Mesh( geometry, material );
      scene.add( lathe );


   .. Constructor

🐣:LatheGeometry(Array points, Integer segments, Float phiStart, Float phiLength)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points — Array of Vector2s. The x-coordinate of each point must be greater than zero.
   Default is an array with (0,-0.5), (0.5,0) and (0,0.5) which creates a simple diamond
   shape.
   segments — the number of circumference segments to generate. Default is 12.
   phiStart — the starting angle in radians. Default is ``0``.
   phiLength — the radian (0 to 2PI) range of the lathed section 2PI is a closed lathe,
   less than 2PI is a portion. Default is 2PI.

   This creates a ``LatheGeometry`` based on the parameters.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D096:

BufferGeometry → PolyhedronGeometry → OctahedronGeometry
========================================================

   https://threejs.org/docs/api/en/geometries/OctahedronGeometry.html

   A class for generating an octahedron geometry.

   .. Constructor

🐣:OctahedronGeometry(Float radius, Integer detail)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Radius of the octahedron. Default is ``1``.
   detail — Default is ``0``. Setting this to a value greater than zero add vertices making
   it no longer an octahedron.

Properties
----------

   See the base ``PolyhedronGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``PolyhedronGeometry`` class for common methods.



.. _D097:

BufferGeometry → PlaneGeometry
==============================

   https://threejs.org/docs/api/en/geometries/PlaneGeometry.html

   A class for generating plane geometries.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.PlaneGeometry( 1, 1 );
      const material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
      const plane = new THREE.Mesh( geometry, material );
      scene.add( plane );


   .. Constructor

🐣:PlaneGeometry(Float width, Float height, Integer widthSegments, Integer heightSegments)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   width — Width along the X axis. Default is ``1``.
   height — Height along the Y axis. Default is ``1``.
   widthSegments — Optional. Default is ``1``.
   heightSegments — Optional. Default is ``1``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D098:

BufferGeometry → PolyhedronGeometry
===================================

   https://threejs.org/docs/api/en/geometries/PolyhedronGeometry.html

   A polyhedron is a solid in three dimensions with flat faces. This class will take an array
   of vertices, project them onto a sphere, and then divide them up to the desired level of
   detail. This class is used by ``DodecahedronGeometry``, ``IcosahedronGeometry``,
   ``OctahedronGeometry``, and ``TetrahedronGeometry`` to generate their respective
   geometries.

   **Code Example**


   .. code:: javascript

      const verticesOfCube = [ -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1, -1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1, ];
      const indicesOfFaces = [ 2,1,0, 0,3,2, 0,4,7, 7,3,0, 0,1,5, 5,4,0, 1,2,6, 6,5,1, 2,3,7, 7,6,2, 4,5,6, 6,7,4 ];
      const geometry = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 6, 2 );


   .. Constructor

🐣:PolyhedronGeometry(Array vertices, Array indices, Float radius, Integer detail)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   vertices — ``Array`` of points of the form [1,1,1, -1,-1,-1, ... ]
   indices — ``Array`` of indices that make up the faces of the form [0,1,2, 2,3,0, ...
   ]
   radius — ``Float`` - The radius of the final shape
   detail — ``Integer`` - How many levels to subdivide the geometry. The more detail,
   the smoother the shape.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D099:

BufferGeometry → RingGeometry
=============================

   https://threejs.org/docs/api/en/geometries/RingGeometry.html

   A class for generating a two-dimensional ring geometry.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.RingGeometry( 1, 5, 32 );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
      const mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );


   .. Constructor

🐣:RingGeometry(Float innerRadius, Float outerRadius, Integer thetaSegments, Integer phiSegments, Float thetaStart, Float thetaLength)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   innerRadius — Default is ``0.5``.
   outerRadius — Default is ``1``.
   thetaSegments — Number of segments. A higher number means the ring will be more round.
   Minimum is ``3``. Default is ``32``.
   phiSegments — Number of segments per ring segment. Minimum is ``1``. Default is ``1``.
   thetaStart — Starting angle. Default is ``0``.
   thetaLength — Central angle. Default is Math.PI `` 2.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D100:

BufferGeometry → ShapeGeometry
==============================

   https://threejs.org/docs/api/en/geometries/ShapeGeometry.html

   Creates an one-sided polygonal geometry from one or more path shapes.

   **Code Example**


   .. code:: javascript

      const x = 0, y = 0;
      const heartShape = new THREE.Shape();
      heartShape.moveTo( x + 5, y + 5 );
      heartShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );
      heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 );
      heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
      heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );
      heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );
      heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );
      const geometry = new THREE.ShapeGeometry( heartShape );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const mesh = new THREE.Mesh( geometry, material ) ;
      scene.add( mesh );


   .. Constructor

🐣:ShapeGeometry(Array shapes, Integer curveSegments)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   shapes — ``Array`` of shapes or a single `shape <#Shape>`__. Default is a single
   triangle shape.
   curveSegments - ``Integer`` - Number of segments per shape. Default is 12.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D101:

BufferGeometry → SphereGeometry
===============================

   https://threejs.org/docs/api/en/geometries/SphereGeometry.html

   A class for generating sphere geometries.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.SphereGeometry( 15, 32, 16 );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const sphere = new THREE.Mesh( geometry, material );
      scene.add( sphere );


   .. Constructor

🐣:SphereGeometry(Float radius, Integer widthSegments, Integer heightSegments, Float phiStart, Float phiLength, Float thetaStart, Float thetaLength)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — sphere radius. Default is ``1``.
   widthSegments — number of horizontal segments. Minimum value is ``3``, and the default
   is ``32``.
   heightSegments — number of vertical segments. Minimum value is ``2``, and the default is
   ``16``.
   phiStart — specify horizontal starting angle. Default is ``0``.
   phiLength — specify horizontal sweep angle size. Default is Math.PI `` 2.
   thetaStart — specify vertical starting angle. Default is ``0``.
   thetaLength — specify vertical sweep angle size. Default is Math.PI.

   The geometry is created by sweeping and calculating vertexes around the Y axis (horizontal
   sweep) and the Z axis (vertical sweep). Thus, incomplete spheres (akin to \`'sphere
   slices'\`) can be created through the use of different values of phiStart, phiLength,
   thetaStart and thetaLength, in order to define the points in which we start (or end)
   calculating those vertices.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D102:

BufferGeometry → PolyhedronGeometry → TetrahedronGeometry
=========================================================

   https://threejs.org/docs/api/en/geometries/TetrahedronGeometry.html

   A class for generating a tetrahedron geometries.

   .. Constructor

🐣:TetrahedronGeometry(Float radius, Integer detail)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius — Radius of the tetrahedron. Default is ``1``.
   detail — Default is ``0``. Setting this to a value greater than ``0`` adds vertices
   making it no longer a tetrahedron.

Properties
----------

   See the base ``PolyhedronGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``PolyhedronGeometry`` class for common methods.



.. _D103:

BufferGeometry → TorusGeometry
==============================

   https://threejs.org/docs/api/en/geometries/TorusGeometry.html

   A class for generating torus geometries.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const torus = new THREE.Mesh( geometry, material );
      scene.add( torus );


   .. Constructor

🐣:TorusGeometry(Float radius, Float tube, Integer radialSegments, Integer tubularSegments, Float arc)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius - Radius of the torus, from the center of the torus to the center of the tube.
   Default is ``1``.
   tube — Radius of the tube. Default is ``0.4``.
   radialSegments — Default is ``12``
   tubularSegments — Default is ``48``.
   arc — Central angle. Default is Math.PI `` 2.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D104:

BufferGeometry → TorusKnotGeometry
==================================

   https://threejs.org/docs/api/en/geometries/TorusKnotGeometry.html

   Creates a torus knot, the particular shape of which is defined by a pair of coprime
   integers, p and q. If p and q are not coprime, the result will be a torus link.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const torusKnot = new THREE.Mesh( geometry, material );
      scene.add( torusKnot );


   .. Constructor

🐣:TorusKnotGeometry(Float radius, Float tube, Integer tubularSegments, Integer radialSegments, Integer p, Integer q)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  radius - Radius of the torus. Default is ``1``.
   -  tube — Radius of the tube. Default is ``0.4``.
   -  tubularSegments — Default is ``64``.
   -  radialSegments — Default is ``8``.
   -  p — This value determines, how many times the geometry winds around its axis of
      rotational symmetry. Default is ``2``.
   -  q — This value determines, how many times the geometry winds around a circle in the
      interior of the torus. Default is ``3``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D105:

BufferGeometry → TubeGeometry
=============================

   https://threejs.org/docs/api/en/geometries/TubeGeometry.html

   Creates a tube that extrudes along a 3d curve.

   **Code Example**


   .. code:: javascript

      class CustomSinCurve extends THREE.Curve { constructor( scale = 1 ) { super();
      this.scale = scale;
      } getPoint( t, optionalTarget = new THREE.Vector3() ) { const tx = t * 3 - 1.5;
      const ty = Math.sin( 2 * Math.PI * t );
      const tz = 0;
      return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );
      } } const path = new CustomSinCurve( 10 );
      const geometry = new THREE.TubeGeometry( path, 20, 2, 8, false );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );


   .. Constructor

🐣:TubeGeometry(Curve path, Integer tubularSegments, Float radius, Integer radialSegments, Boolean closed)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   path — ``Curve`` - A 3D path that inherits from the ``Curve`` base class.
   Default is a quadratic bezier curve.
   tubularSegments — ``Integer`` - The number of segments that make up the tube.
   Default is ``64``.
   radius — ``Float`` - The radius of the tube. Default is ``1``.
   radialSegments — ``Integer`` - The number of segments that make up the cross-section.
   Default is ``8``.
   closed — ``Boolean`` Is the tube open or closed. Default is ``false``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

⭕:Array tangents
~~~~~~~~~~~~~~~~~~

   An array of ``Vector3`` tangents

⭕:Array normals
~~~~~~~~~~~~~~~~~

   An array of ``Vector3`` normals

⭕:Array binormals
~~~~~~~~~~~~~~~~~~~

   An array of ``Vector3`` binormals

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D106:

BufferGeometry → WireframeGeometry
==================================

   https://threejs.org/docs/api/en/geometries/WireframeGeometry.html

   This can be used as a helper object to view a `geometry <#BufferGeometry>`__ as a
   wireframe.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.SphereGeometry( 100, 100, 100 );
      const wireframe = new THREE.WireframeGeometry( geometry );
      const line = new THREE.LineSegments( wireframe );
      line.material.depthTest = false;
      line.material.opacity = 0.25;
      line.material.transparent = true;
      scene.add( line );


   **Examples**

   [example:webgl_helpers helpers]

   .. Constructor

🐣:WireframeGeometry( BufferGeometry geometry )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry — any geometry object.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D107:

Object3D → ArrowHelper
======================

   https://threejs.org/docs/api/en/helpers/ArrowHelper.html

   An 3D arrow object for visualizing directions.

   **Code Example**


   .. code:: javascript

      const dir = new THREE.Vector3( 1, 2, 0 );
      //normalize the direction vector (convert to vector of length 1) dir.normalize();
      const origin = new THREE.Vector3( 0, 0, 0 );
      const length = 1;
      const hex = 0xffff00;
      const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
      scene.add( arrowHelper );


   **Examples**

   [example:webgl_shadowmesh WebGL / shadowmesh]

   .. Constructor

🐣:ArrowHelper(Vector3 dir, Vector3 origin, Number length, Number hex, Number headLength, Number headWidth )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `dir <#Vector3>`__ -- direction from origin. Must be a unit vector.
   `origin <#Vector3>`__ -- Point at which the arrow starts.
   `length <#Number>`__ -- length of the arrow. Default is ``1``.
   `hex <#Number>`__ -- hexadecimal value to define color. Default is 0xffff00.
   `headLength <#Number>`__ -- The length of the head of the arrow. Default is ``0.2`` ``
   length.
   `headWidth <#Number>`__ -- The width of the head of the arrow. Default is ``0.2`` ``
   headLength.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Line line
~~~~~~~~~~~~~

   Contains the line part of the arrowHelper.

⭕:Mesh cone
~~~~~~~~~~~~~

   Contains the cone part of the arrowHelper.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:setColor(Color color) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   color -- The desired color.
   Sets the color of the arrowHelper.

📦:setLength(Number length, Number headLength, Number headWidth) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   length -- The desired length.
   headLength -- The length of the head of the arrow.
   headWidth -- The width of the head of the arrow.
   Sets the length of the arrowhelper.

📦:setDirection(Vector3 dir) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   dir -- The desired direction. Must be a unit vector.
   Sets the direction of the arrowhelper.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D108:

Object3D → Line → LineSegments → AxesHelper
===========================================

   https://threejs.org/docs/api/en/helpers/AxesHelper.html

   An axis object to visualize the 3 axes in a simple way.
   The X axis is red. The Y axis is green. The Z axis is blue.

   **Code Example**


   .. code:: javascript

      const axesHelper = new THREE.AxesHelper( 5 );
      scene.add( axesHelper );


   **Examples**

   [example:webgl_buffergeometry_compression WebGL / buffergeometry / compression]
   [example:webgl_geometry_convex WebGL / geometry / convex]
   [example:webgl_loader_nrrd WebGL / loader / nrrd]

   .. Constructor

🐣:AxesHelper( Number size )
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `size <#Number>`__ -- (optional) size of the lines representing the axes.
   Default is ``1``.

Properties
----------

   See the base ``LineSegments`` class for common properties.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:setColors( Color xAxisColor, Color yAxisColor, Color zAxisColor ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the axes colors to `xAxisColor <#Color>`__, `yAxisColor <#Color>`__, `zAxisColor <#Color>`__.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D109:

Object3D → Line → LineSegments → BoxHelper
==========================================

   https://threejs.org/docs/api/en/helpers/BoxHelper.html

   Helper object to graphically show the world-axis-aligned bounding box around an object.
   The actual bounding box is handled with ``Box3``, this is just a visual helper for
   debugging. It can be automatically resized with the ``BoxHelper.update`` method when
   the object it's created from is transformed. Note that the object must have a
   ``BufferGeometry`` for this to work, so it won't work with `Sprites <#Sprite>`__.

   **Code Example**


   .. code:: javascript

      const sphere = new THREE.SphereGeometry();
      const object = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( 0xff0000 ) );
      const box = new THREE.BoxHelper( object, 0xffff00 );
      scene.add( box );


   **Examples**

   [example:webgl_helpers WebGL / helpers]
   [example:webgl_loader_nrrd WebGL / loader / nrrd]
   [example:webgl_buffergeometry_drawrange WebGL / buffergeometry / drawrange]

   .. Constructor

🐣:BoxHelper( Object3D object, Color color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ -- (optional) the object3D to show the world-axis-aligned
   boundingbox.
   `color <#Color>`__ -- (optional) hexadecimal value that defines the box's color.
   Default is 0xffff00.
   Creates a new wireframe box that bounds the passed object. Internally this uses
   ``Box3.setFromObject`` to calculate the dimensions. Note that this includes any
   children.

Properties
----------

   See the base ``LineSegments`` class for common properties.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the helper's geometry to match the dimensions of the object, including any
   children. See ``Box3.setFromObject``.

📦:setFromObject( Object3D object ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ - ``Object3D`` to create the helper of.
   Updates the wireframe box for the passed object.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D110:

Object3D → Line → LineSegments → Box3Helper
===========================================

   https://threejs.org/docs/api/en/helpers/Box3Helper.html

   Helper object to visualize a ``Box3``.

   **Code Example**


   .. code:: javascript

      const box = new THREE.Box3();
      box.setFromCenterAndSize( new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 2, 1, 3 ) );
      const helper = new THREE.Box3Helper( box, 0xffff00 );
      scene.add( helper );


   .. Constructor

🐣:Box3Helper( Box3 box, Color color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ -- the Box3 to show.
   `color <#Color>`__ -- (optional) the box's color. Default is 0xffff00.
   Creates a new wireframe box that represents the passed Box3.

Properties
----------

   See the base ``LineSegments`` class for common properties.

⭕:Box3 box
~~~~~~~~~~~~

   The Box3 being visualized.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:updateMatrixWorld( Boolean force ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This overrides the method in the base ``Object3D`` class so that it also updates the
   wireframe box to the extent of the `.box <#Box3Helper.box>`__ property.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D111:

Object3D → Line → LineSegments → CameraHelper
=============================================

   https://threejs.org/docs/api/en/helpers/CameraHelper.html

   This helps with visualizing what a camera contains in its frustum. It visualizes the
   frustum of a camera using a ``LineSegments``.
   ``Box3Helper`` must be a child of the scene.

   **Code Example**


   .. code:: javascript

      const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      const helper = new THREE.CameraHelper( camera );
      scene.add( helper );


   **Examples**

   [example:webgl_camera WebGL / camera]
   [example:webgl_geometry_extrude_splines WebGL / extrude / splines]

   .. Constructor

🐣:CameraHelper( Camera camera )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__ -- The camera to visualize.
   This create a new [Name] for the specified camera.

Properties
----------

   See the base ``LineSegments`` class for common properties.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The camera being visualized.

⭕:Object pointMap
~~~~~~~~~~~~~~~~~~~

   This contains the points used to visualize the camera.

⭕:Object matrix
~~~~~~~~~~~~~~~~~

   Reference to the `camera.matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   camera's `matrixWorld <#Object3D.matrixWorld>`__.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:setColors( Color frustum, Color cone, Color up, Color target, Color cross ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines the colors of the helper.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the helper based on the projectionMatrix of the camera.



.. _D112:

Object3D → DirectionalLightHelper
=================================

   https://threejs.org/docs/api/en/helpers/DirectionalLightHelper.html

   Helper object to assist with visualizing a ``DirectionalLight``'s effect on the scene.
   This consists of plane and a line representing the light's position and direction.

   **Code Example**


   .. code:: javascript

      const light = new THREE.DirectionalLight( 0xFFFFFF );
      scene.add( light );
      const helper = new THREE.DirectionalLightHelper( light, 5 );
      scene.add( helper );


   .. Constructor

🐣:DirectionalLightHelper( DirectionalLight light, Number size, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `light <#DirectionalLight>`__-- The light to be visualized.
   `size <#Number>`__ -- (optional) dimensions of the plane. Default is ``1``.
   `color <#Hex>`__ -- (optional) if this is not the set the helper will take the color of
   the light.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Line lightPlane
~~~~~~~~~~~~~~~~~~~

   Contains the line mesh showing the location of the directional light.

⭕:DirectionalLight light
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Reference to the `directionalLight <#DirectionalLight>`__ being visualized.

⭕:Object matrix
~~~~~~~~~~~~~~~~~

   Reference to the light's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   light's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:hex color
~~~~~~~~~~~~~

   The color parameter passed in the constructor. Default is ``undefined``. If this is
   changed, the helper's color will update the next time ``update`` is called.

Methods
-------

   See the base ``Object3D`` class for common properties.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the helper to match the position and direction of the `directionalLight <#.light>`__ being visualized.



.. _D113:

Object3D → Line → LineSegments → GridHelper
===========================================

   https://threejs.org/docs/api/en/helpers/GridHelper.html

   The GridHelper is an object to define grids. Grids are two-dimensional arrays of lines.

   **Code Example**


   .. code:: javascript

      const size = 10;
      const divisions = 10;
      const gridHelper = new THREE.GridHelper( size, divisions );
      scene.add( gridHelper );


   **Examples**

   [example:webgl_helpers WebGL / helpers]

   .. Constructor

🐣:GridHelper( number size, Number divisions, Color colorCenterLine, Color colorGrid )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   size -- The size of the grid. Default is ``10``.
   divisions -- The number of divisions across the grid. Default is ``10``.
   colorCenterLine -- The color of the centerline. This can be a ``Color``, a
   hexadecimal value and an CSS-Color name. Default is 0x444444
   colorGrid -- The color of the lines of the grid. This can be a ``Color``, a
   hexadecimal value and an CSS-Color name. Default is 0x888888

   Creates a new ``GridHelper`` of size 'size' and divided into 'divisions' segments per side. Colors
   are optional.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D114:

Object3D → Line → LineSegments → PolarGridHelper
================================================

   https://threejs.org/docs/api/en/helpers/PolarGridHelper.html

   The PolarGridHelper is an object to define polar grids. Grids are two-dimensional arrays
   of lines.

   **Code Example**


   .. code:: javascript

      const radius = 10;
      const sectors = 16;
      const rings = 8;
      const divisions = 64;
      const helper = new THREE.PolarGridHelper( radius, sectors, rings, divisions );
      scene.add( helper );


   **Examples**

   [example:webgl_helpers WebGL / helpers]

   .. Constructor

🐣:PolarGridHelper( Number radius, Number sectors, Number rings, Number divisions, Color color1, Color color2 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   radius -- The radius of the polar grid. This can be any positive number.
   Default is ``10``.
   sectors -- The number of sectors the grid will be divided into. This can be any positive
   integer. Default is ``16``.
   rings -- The number of rings. This can be any positive integer. Default is 8.
   divisions -- The number of line segments used for each circle. This can be any positive
   integer that is 3 or greater. Default is ``64``.
   color1 -- The first color used for grid elements. This can be a ``Color``, a
   hexadecimal value and an CSS-Color name. Default is 0x444444
   color2 -- The second color used for grid elements. This can be a ``Color``, a
   hexadecimal value and an CSS-Color name. Default is 0x888888

   Creates a new ``PolarGridHelper`` of radius 'radius' with 'sectors' number of sectors and 'rings'
   number of rings, where each circle is smoothed into 'divisions' number of line segments.
   Colors are optional.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D115:

Object3D → HemisphereLightHelper
================================

   https://threejs.org/docs/api/en/helpers/HemisphereLightHelper.html

   Creates a visual aid consisting of a spherical ``Mesh`` for a `HemisphereLight <#HemisphereLight>`__.

   **Code Example**


   .. code:: javascript

      const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
      const helper = new THREE.HemisphereLightHelper( light, 5 );
      scene.add( helper );


   .. Constructor

🐣:HemisphereLightHelper( HemisphereLight light, Number sphereSize, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `light <#HemisphereLight>`__ -- The light being visualized.
   `size <#Number>`__ -- The size of the mesh used to visualize the light.
   `color <#Hex>`__ -- (optional) if this is not the set the helper will take the color of
   the light.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:HemisphereLight light
~~~~~~~~~~~~~~~~~~~~~~~~~

   Reference to the HemisphereLight being visualized.

⭕:Object matrix
~~~~~~~~~~~~~~~~~

   Reference to the hemisphereLight's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   hemisphereLight's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:hex color
~~~~~~~~~~~~~

   The color parameter passed in the constructor. Default is ``undefined``. If this is
   changed, the helper's color will update the next time ``update`` is called.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the helper to match the position and direction of the ``.light``.



.. _D116:

Object3D → Line → LineSegments → PlaneHelper
============================================

   https://threejs.org/docs/api/en/helpers/PlaneHelper.html

   Helper object to visualize a ``Plane``.

   **Code Example**


   .. code:: javascript

      const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
      const helper = new THREE.PlaneHelper( plane, 1, 0xffff00 );
      scene.add( helper );


   .. Constructor

🐣:PlaneHelper( Plane plane, Float size, Color hex )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ -- the plane to visualize.
   `size <#Float>`__ -- (optional) side length of plane helper. Default is 1.
   `color <#Color>`__ -- (optional) the color of the helper. Default is 0xffff00.
   Creates a new wireframe representation of the passed plane.

Properties
----------

   See the base ``Line`` class for common properties.

⭕:Plane plane
~~~~~~~~~~~~~~~

   The `plane <#Plane>`__ being visualized.

⭕:Float size
~~~~~~~~~~~~~~

   The side lengths of plane helper.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:updateMatrixWorld( Boolean force ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This overrides the method in the base ``Object3D`` class so that it also updates the
   helper object according to the `.plane <#PlaneHelper.plane>`__ and `.size <#PlaneHelper.size>`__ properties.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D117:

Object3D → Mesh → PointLightHelper
==================================

   https://threejs.org/docs/api/en/helpers/PointLightHelper.html

   This displays a helper object consisting of a spherical ``Mesh`` for visualizing a
   ``PointLight``.

   **Code Example**


   .. code:: javascript

      const pointLight = new THREE.PointLight( 0xff0000, 1, 100 );
      pointLight.position.set( 10, 10, 10 );
      scene.add( pointLight );
      const sphereSize = 1;
      const pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
      scene.add( pointLightHelper );


   **Examples**

   [example:webgl_helpers WebGL / helpers]

   .. Constructor

🐣:PointLightHelper( PointLight light, Float sphereSize, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `light <#PointLight>`__ -- The light to be visualized.
   `sphereSize <#Float>`__ -- (optional) The size of the sphere helper. Default is ``1``.
   `color <#Hex>`__ -- (optional) if this is not the set the helper will take the color of
   the light.

Properties
----------

   See the base ``Mesh`` class for common properties.

⭕:PointLight light
~~~~~~~~~~~~~~~~~~~~

   The ``PointLight`` that is being visualized.

⭕:Object matrix
~~~~~~~~~~~~~~~~~

   Reference to the pointLight's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   pointLight's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:hex color
~~~~~~~~~~~~~

   The color parameter passed in the constructor. Default is ``undefined``. If this is
   changed, the helper's color will update the next time ``update`` is called.

Methods
-------

   See the base ``Mesh`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the helper to match the position of the ``.light``.



.. _D118:

Object3D → Line → LineSegments → SkeletonHelper
===============================================

   https://threejs.org/docs/api/en/helpers/SkeletonHelper.html

   A helper object to assist with visualizing a `Skeleton <#Skeleton>`__. The helper is
   rendered using a `LineBasicMaterial <#LineBasicMaterial>`__.

   **Code Example**


   .. code:: javascript

      const helper = new THREE.SkeletonHelper( skinnedMesh );
      scene.add( helper );


   **Examples**

   [example:webgl_animation_skinning_blending WebGL / animation / skinning / blending]
   [example:webgl_animation_skinning_morph WebGL / animation / skinning / morph]
   [example:webgl_loader_bvh WebGL / loader / bvh ]

   .. Constructor

🐣:SkeletonHelper( Object3D object )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   object -- Usually an instance of ``SkinnedMesh``. However, any instance of
   ``Object3D`` can be used if it represents a hierarchy of `Bone <#Bone>`__s (via
   ``Object3D.children``).

Properties
----------

⭕:Array bones
~~~~~~~~~~~~~~~

   The list of bones that the helper renders as `Lines <#Line>`__.

⭕:Boolean isSkeletonHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``SkeletonHelper``.

⭕:Object3D root
~~~~~~~~~~~~~~~~~

   The object passed in the constructor.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D119:

Object3D → SpotLightHelper
==========================

   https://threejs.org/docs/api/en/helpers/SpotLightHelper.html

   This displays a cone shaped helper object for a ``SpotLight``.

   **Code Example**


   .. code:: javascript

      const spotLight = new THREE.SpotLight( 0xffffff );
      spotLight.position.set( 10, 10, 10 );
      scene.add( spotLight );
      const spotLightHelper = new THREE.SpotLightHelper( spotLight );
      scene.add( spotLightHelper );


   **Examples**

   [example:webgl_lights_spotlights WebGL/ lights / spotlights ]

   .. Constructor

🐣:SpotLightHelper( SpotLight light, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `light <#SpotLight>`__ -- The ``SpotLight`` to be visualized.
   `color <#Hex>`__ -- (optional) if this is not the set the helper will take the color of
   the light.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:LineSegments cone
~~~~~~~~~~~~~~~~~~~~~

   ``LineSegments`` used to visualize the light.

⭕:SpotLight light
~~~~~~~~~~~~~~~~~~~

   Reference to the ``SpotLight`` being visualized.

⭕:Object matrix
~~~~~~~~~~~~~~~~~

   Reference to the spotLight's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   spotLight's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:hex color
~~~~~~~~~~~~~

   The color parameter passed in the constructor. Default is ``undefined``. If this is
   changed, the helper's color will update the next time ``update`` is called.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the light helper.



.. _D120:

Object3D → Light → AmbientLight
===============================

   https://threejs.org/docs/api/en/lights/AmbientLight.html

   This light globally illuminates all objects in the scene equally.
   This light cannot be used to cast shadows as it does not have a direction.

   **Code Example**


   .. code:: javascript

      const light = new THREE.AmbientLight( 0x404040 );
      // soft white light scene.add( light );


   .. Constructor

🐣:AmbientLight( Integer color, Float intensity )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Integer>`__ - (optional) Numeric value of the RGB component of the color.
   Default is 0xffffff.
   `intensity <#Float>`__ - (optional) Numeric value of the light's strength/intensity.
   Default is ``1``.
   Creates a new ``AmbientLight``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties.

⭕:Boolean isAmbientLight
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``AmbientLight``.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.



.. _D121:

Object3D → Light → DirectionalLight
===================================

   https://threejs.org/docs/api/en/lights/DirectionalLight.html

   A light that gets emitted in a specific direction. This light will behave as though it
   is infinitely far away and the rays produced from it are all parallel. The common use
   case for this is to simulate daylight; the sun is far enough away that its position can
   be considered to be infinite, and all light rays coming from it are parallel.
   This light can cast shadows - see the ``DirectionalLightShadow`` page for details.

   A Note about Position, Target and rotation
   ------------------------------------------

   A common point of confusion for directional lights is that setting the rotation has no
   effect. This is because three.js's DirectionalLight is the equivalent to what is often
   called a 'Target Direct Light' in other applications.
   This means that its direction is calculated as pointing from the light's
   `position <#Object3D.position>`__ to the ``target``'s position (as opposed to
   a 'Free Direct Light' that just has a rotation component).
   The reason for this is to allow the light to cast shadows - the ``shadow``
   camera needs a position to calculate shadows from.
   See the ``target`` property below for details on updating the target.

   **Code Example**


   .. code:: javascript

      // White directional light at half intensity shining from the top.
      const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
      scene.add( directionalLight );


   **Examples**

   [example:misc_controls_fly controls / fly ]
   [example:webgl_effects_parallaxbarrier effects / parallaxbarrier ]
   [example:webgl_effects_stereo effects / stereo ]
   [example:webgl_geometry_extrude_splines geometry / extrude / splines ]
   [example:webgl_materials_bumpmap materials / bumpmap ]

   .. Constructor

🐣:DirectionalLight( Integer color, Float intensity )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Integer>`__ - (optional) hexadecimal color of the light. Default is 0xffffff
   (white).
   `intensity <#Float>`__ - (optional) numeric value of the light's strength/intensity.
   Default is ``1``.
   Creates a new ``DirectionalLight``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties.

⭕:Boolean castShadow
~~~~~~~~~~~~~~~~~~~~~~

   If set to ``true`` light will cast dynamic shadows. ``Warning``: This is expensive and
   requires tweaking to get shadows looking right. See the ``DirectionalLightShadow`` for
   details. The default is ``false``.

⭕:Boolean isDirectionalLight
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``DirectionalLight``.

⭕:Vector3 position
~~~~~~~~~~~~~~~~~~~~

   This is set equal to ``Object3D.DEFAULT_UP`` (0, 1, 0), so that the light shines from
   the top down.

⭕:DirectionalLightShadow shadow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A ``DirectionalLightShadow`` used to calculate shadows for this light.

⭕:Object3D target
~~~~~~~~~~~~~~~~~~~

   The DirectionalLight points from its ``position`` to target.position. The
   default position of the target is ``(0, 0, 0)``.
   ``Note``: For the target's position to be changed to anything other than the default, it
   must be added to the `scene <#Scene>`__ using


   .. code:: javascript

      scene.add( light.target );


   This is so that the target's `matrixWorld <#Object3D.matrixWorld>`__ gets automatically
   updated each frame.
   It is also possible to set the target to be another object in the scene (anything with a
   `position <#Object3D.position>`__ property), like so:


   .. code:: javascript

      const targetObject = new THREE.Object3D();
      scene.add(targetObject);
      light.target = targetObject;


   The directionalLight will now track the target object.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:copy( DirectionalLight source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies value of all the properties from the `source <#DirectionalLight>`__ to this
   DirectionalLight.



.. _D122:

Object3D → Light → HemisphereLight
==================================

   https://threejs.org/docs/api/en/lights/HemisphereLight.html

   A light source positioned directly above the scene, with color fading from the sky color
   to the ground color.
   This light cannot be used to cast shadows.

   **Code Example**


   .. code:: javascript

      const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
      scene.add( light );


   **Examples**

   [example:webgl_animation_skinning_blending animation / skinning / blending ]
   [example:webgl_lights_hemisphere lights / hemisphere ]
   [example:misc_controls_pointerlock controls / pointerlock ]
   [example:webgl_loader_collada_kinematics loader / collada / kinematics ]
   [example:webgl_loader_stl loader / stl ]

   .. Constructor

🐣:HemisphereLight( Integer skyColor, Integer groundColor, Float intensity )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `skyColor <#Integer>`__ - (optional) hexadecimal color of the sky. Default is 0xffffff.
   `groundColor <#Integer>`__ - (optional) hexadecimal color of the ground. Default is
   0xffffff.
   `intensity <#Float>`__ - (optional) numeric value of the light's strength/intensity.
   Default is ``1``.
   Creates a new ``HemisphereLight``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties.

⭕:Float color
~~~~~~~~~~~~~~~

   The light's sky color, as passed in the constructor. Default is a new ``Color`` set to
   white (0xffffff).

⭕:Float groundColor
~~~~~~~~~~~~~~~~~~~~~

   The light's ground color, as passed in the constructor. Default is a new ``Color`` set
   to white (0xffffff).

⭕:Boolean isHemisphereLight
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``HemisphereLight``.

⭕:Vector3 position
~~~~~~~~~~~~~~~~~~~~

   This is set equal to ``Object3D.DEFAULT_UP`` (0, 1, 0), so that the light shines from
   the top down.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.

📦:copy( HemisphereLight source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the value of ``color``, ``intensity`` and
   ``groundColor`` from the `source <#Light>`__ light into this one.



.. _D123:

Object3D → Light
================

   https://threejs.org/docs/api/en/lights/Light.html

   Abstract base class for lights - all other light types inherit the properties and methods
   described here.

   .. Constructor

🐣:Light( Integer color, Float intensity )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Integer>`__ - (optional) hexadecimal color of the light. Default is 0xffffff
   (white).
   `intensity <#Float>`__ - (optional) numeric value of the light's strength/intensity.
   Default is ``1``.
   Creates a new ``Light``. Note that this is not intended to be called directly (use one of
   derived classes instead).

Properties
----------

   See the base `Object3D <#Object3D>`__ class for common properties.

⭕:Color color
~~~~~~~~~~~~~~~

   Color of the light. Defaults to a new ``Color`` set to white, if not passed in the
   constructor.

⭕:Float intensity
~~~~~~~~~~~~~~~~~~~

   The light's intensity, or strength.
   The units of intensity depend on the type of light.
   Default - ``1.0``.

⭕:Boolean isLight
~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Light``.

Methods
-------

   See the base `Object3D <#Object3D>`__ class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Abstract dispose method for classes that extend this class; implemented by subclasses that
   have disposable GPU-related resources.

📦:copy( Light source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the value of ``color`` and ``intensity`` from the
   `source <#Light>`__ light into this one.

📦:toJSON( Object meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- object containing metadata such as materials, textures for objects.
   Convert the light to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.



.. _D124:

Object3D → Light → LightProbe
=============================

   https://threejs.org/docs/api/en/lights/LightProbe.html

   Light probes are an alternative way of adding light to a 3D scene. Unlike classical light
   sources (e.g. directional, point or spot lights), light probes do not emit light. Instead
   they store information about light passing through 3D space. During rendering, the light
   that hits a 3D object is approximated by using the data from the light probe.

   Light probes are usually created from (radiance) environment maps. The class
   ``LightProbeGenerator`` can be used to create light probes from instances of
   ``CubeTexture`` or ``WebGLCubeRenderTarget``. However, light estimation data could
   also be provided in other forms e.g. by WebXR. This enables the rendering of augmented
   reality content that reacts to real world lighting.

   The current probe implementation in three.js supports so-called diffuse light probes. This
   type of light probe is functionally equivalent to an irradiance environment map.

   **Examples**

   [example:webgl_lightprobe WebGL / light probe ]
   [example:webgl_lightprobe_cubecamera WebGL / light probe / cube camera ]

   .. Constructor

🐣:LightProbe( SphericalHarmonics3 sh, Float intensity )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sh <#SphericalHarmonics3>`__ - (optional) An instance of ``SphericalHarmonics3``.
   `intensity <#Float>`__ - (optional) Numeric value of the light probe's intensity.
   Default is ``1``.
   Creates a new ``LightProbe``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties. The `color <#Light.color>`__
   property is currently not evaluated and thus has no effect.

⭕:Boolean isLightProbe
~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``LightProbe``.

⭕:SphericalHarmonics3 sh
~~~~~~~~~~~~~~~~~~~~~~~~~~

   A light probe uses spherical harmonics to encode lighting information.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.



.. _D125:

Object3D → Light → PointLight
=============================

   https://threejs.org/docs/api/en/lights/PointLight.html

   A light that gets emitted from a single point in all directions. A common use case for
   this is to replicate the light emitted from a bare lightbulb.
   This light can cast shadows - see ``PointLightShadow`` page for details.

   **Code Example**


   .. code:: javascript

      const light = new THREE.PointLight( 0xff0000, 1, 100 );
      light.position.set( 50, 50, 50 );
      scene.add( light );


   **Examples**

   [example:webgl_lights_pointlights lights / pointlights ]
   [example:webgl_effects_anaglyph effects / anaglyph ]
   [example:webgl_geometry_text geometry / text ]
   [example:webgl_lensflares lensflares ]

   .. Constructor

🐣:PointLight( Integer color, Float intensity, Number distance, Float decay )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Integer>`__ - (optional) hexadecimal color of the light. Default is 0xffffff
   (white).
   `intensity <#Float>`__ - (optional) numeric value of the light's strength/intensity.
   Default is ``1``.
   `distance <#Number>`__ - Maximum range of the light. Default is ``0`` (no limit).
   `decay <#Float>`__ - The amount the light dims along the distance of the light.
   Default is ``2``.
   Creates a new ``PointLight``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties.

⭕:Boolean castShadow
~~~~~~~~~~~~~~~~~~~~~~

   If set to ``true`` light will cast dynamic shadows. ``Warning``: This is expensive and
   requires tweaking to get shadows looking right. See the ``PointLightShadow`` for
   details. The default is ``false``.

⭕:Float decay
~~~~~~~~~~~~~~~

   The amount the light dims along the distance of the light. Default is ``2``.
   In context of physically-correct rendering the default value should not be changed.

⭕:Float distance
~~~~~~~~~~~~~~~~~~

   When distance is zero, light will attenuate according to inverse-square law to infinite
   distance. When distance is non-zero, light will attenuate according to inverse-square law
   until near the distance cutoff, where it will then attenuate quickly and smoothly to 0.
   Inherently, cutoffs are not physically correct.

   Default is ``0.0``.

⭕:Float intensity
~~~~~~~~~~~~~~~~~~~

   The light's luminous intensity measured in candela (cd). Default is ``1``.
   Changing the intensity will also change the light's power.

⭕:Float power
~~~~~~~~~~~~~~~

   The light's power.
   Power is the luminous power of the light measured in lumens (lm).
   Changing the power will also change the light's intensity.

⭕:PointLightShadow shadow
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A ``PointLightShadow`` used to calculate shadows for this light.
   The lightShadow's `camera <#LightShadow.camera>`__ is set to a ``PerspectiveCamera``
   with `fov <#PerspectiveCamera.fov>`__ of ``90``, `aspect <#PerspectiveCamera.aspect>`__
   of ``1``, `near <#PerspectiveCamera.near>`__ clipping plane at ``0.5`` and
   `far <#PerspectiveCamera.far>`__ clipping plane at ``500``.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:copy( PointLight source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies value of all the properties from the `source <#PointLight>`__ to this PointLight.



.. _D126:

Object3D → Light → RectAreaLight
================================

   https://threejs.org/docs/api/en/lights/RectAreaLight.html

   RectAreaLight emits light uniformly across the face a rectangular plane. This light type
   can be used to simulate light sources such as bright windows or strip lighting.
   Important Notes:

   -  There is no shadow support.
   -  Only `MeshStandardMaterial` and `MeshPhysicalMaterial` are supported.
   -  You have to include
      `RectAreaLightUniformsLib <https://threejs.org/examples/jsm/lights/RectAreaLightUniformsLib.js>`__ 
      into your scene and call ``init()``.

   **Code Example**


   .. code:: javascript

      const width = 10;
      const height = 10;
      const intensity = 1;
      const rectLight = new THREE.RectAreaLight( 0xffffff, intensity, width, height );
      rectLight.position.set( 5, 5, 0 );
      rectLight.lookAt( 0, 0, 0 );
      scene.add( rectLight ) const rectLightHelper = new RectAreaLightHelper( rectLight );
      rectLight.add( rectLightHelper );


   **Examples**

   [example:webgl_lights_rectarealight WebGL / rectarealight ]

   .. Constructor

🐣:RectAreaLight( Integer color, Float intensity, Float width, Float height )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Integer>`__ - (optional) hexadecimal color of the light. Default is 0xffffff
   (white).
   `intensity <#Float>`__ - (optional) the light's intensity, or brightness.
   Default is ``1``.
   `width <#Float>`__ - (optional) width of the light. Default is ``10``.
   `height <#Float>`__ - (optional) height of the light. Default is ``10``.
   Creates a new ``RectAreaLight``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties.

⭕:Float height
~~~~~~~~~~~~~~~~

   The height of the light.

⭕:Float intensity
~~~~~~~~~~~~~~~~~~~

   The light's intensity. It is the luminance (brightness) of the light measured in nits
   (cd/m^2). Default is ``1``.
   Changing the intensity will also change the light's power.

⭕:Boolean isRectAreaLight
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``RectAreaLight``.

⭕:Float power
~~~~~~~~~~~~~~~

   The light's power.
   Power is the luminous power of the light measured in lumens (lm).
   Changing the power will also change the light's intensity.

⭕:Float width
~~~~~~~~~~~~~~~

   The width of the light.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.

📦:copy( RectAreaLight source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies value of all the properties from the `source <#RectAreaLight>`__ to this
   RectAreaLight.


.. _D127:

Object3D → Light → SpotLight
============================

   https://threejs.org/docs/api/en/lights/SpotLight.html

   This light gets emitted from a single point in one direction, along a cone that
   increases in size the further from the light it gets.
   This light can cast shadows - see the ``SpotLightShadow`` page for details.

   **Code Example**


   .. code:: javascript

      // white spotlight shining from the side, modulated by a texture, casting a shadow 
      const spotLight = new THREE.SpotLight( 0xffffff );
      spotLight.position.set( 100, 1000, 100 );
      spotLight.map = new THREE.TextureLoader().load( url );
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;
      spotLight.shadow.camera.near = 500;
      spotLight.shadow.camera.far = 4000;
      spotLight.shadow.camera.fov = 30;
      scene.add( spotLight );


   **Examples**

   [example:webgl_lights_spotlight lights / spotlight ]
   [example:webgl_lights_spotlights lights / spotlights ]

   .. Constructor

🐣:SpotLight( Integer color, Float intensity, Float distance, Radians angle, Float penumbra, Float decay )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Integer>`__ - (optional) hexadecimal color of the light. Default is 0xffffff
   (white).
   `intensity <#Float>`__ - (optional) numeric value of the light's strength/intensity.
   Default is ``1``.
   `distance <#Float>`__ - Maximum range of the light. Default is ``0`` (no limit).
   `angle <#Radians>`__ - Maximum angle of light dispersion from its direction whose upper
   bound is Math.PI/2.
   `penumbra <#Float>`__ - Percent of the spotlight cone that is attenuated due to
   penumbra. Takes values between zero and ``1``. Default is zero.
   `decay <#Float>`__ - The amount the light dims along the distance of the light.
   Creates a new ``SpotLight``.

Properties
----------

   See the base `Light <#Light>`__ class for common properties.

⭕:Float angle
~~~~~~~~~~~~~~~

   Maximum extent of the spotlight, in radians, from its direction. Should be no more than
   ``Math.PI/2``. The default is ``Math.PI/3``.

⭕:Boolean castShadow
~~~~~~~~~~~~~~~~~~~~~~

   If set to ``true`` light will cast dynamic shadows. ``Warning``: This is expensive and
   requires tweaking to get shadows looking right. See the ``SpotLightShadow`` for
   details. The default is ``false``.

⭕:Float decay
~~~~~~~~~~~~~~~

   The amount the light dims along the distance of the light. Default is ``2``.
   In context of physically-correct rendering the default value should not be changed.

⭕:Float distance
~~~~~~~~~~~~~~~~~~

   When distance is zero, light will attenuate according to inverse-square law to infinite
   distance. When distance is non-zero, light will attenuate according to inverse-square law
   until near the distance cutoff, where it will then attenuate quickly and smoothly to
   ``0``. Inherently, cutoffs are not physically correct.

   Default is ``0.0``.

⭕:Float intensity
~~~~~~~~~~~~~~~~~~~

   The light's luminous intensity measured in candela (cd). Default is ``1``.
   Changing the intensity will also change the light's power.

⭕:Boolean isSpotLight
~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``SpotLight``.

⭕:Float penumbra
~~~~~~~~~~~~~~~~~~

   Percent of the spotlight cone that is attenuated due to penumbra. Takes values between
   zero and ``1``. The default is ``0.0``.

⭕:Vector3 position
~~~~~~~~~~~~~~~~~~~~

   This is set equal to ``Object3D.DEFAULT_UP`` (0, 1, 0), so that the light shines from
   the top down.

⭕:Float power
~~~~~~~~~~~~~~~

   The light's power.
   Power is the luminous power of the light measured in lumens (lm).
   Changing the power will also change the light's intensity.

⭕:SpotLightShadow shadow
~~~~~~~~~~~~~~~~~~~~~~~~~~

   A ``SpotLightShadow`` used to calculate shadows for this light.

⭕:Object3D target
~~~~~~~~~~~~~~~~~~~

   The Spotlight points from its ``position`` to target.position. The default
   position of the target is ``(0, 0, 0)``.
   ``Note``: For the target's position to be changed to anything other than the default, it
   must be added to the `scene <#Scene>`__ using ``scene.add( light.target );`` This is so
   that the target's `matrixWorld <#Object3D.matrixWorld>`__ gets automatically updated
   each frame.
   It is also possible to set the target to be another object in the scene (anything with a
   `position <#Object3D.position>`__ property), like so:

   .. code:: javascript

      const targetObject = new THREE.Object3D();
      scene.add(targetObject);
      light.target = targetObject;
      
   The spotlight will now track the target object.

⭕:Texture map
~~~~~~~~~~~~~~~

   A ``Texture`` used to modulate the color of the light. The spot light color is mixed
   with the RGB value of this texture, with a ratio corresponding to its alpha value. The
   cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value).
   ``Warning``: ``.map`` is disabled if ``.castShadow`` is ``false``.

Methods
-------

   See the base `Light <#Light>`__ class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:copy( SpotLight source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies value of all the properties from the `source <#SpotLight>`__ to this SpotLight.



.. _D128:

LightShadow
===========

   https://threejs.org/docs/api/en/lights/shadows/LightShadow.html

   Serves as a base class for the other shadow classes.

   .. Constructor

🐣:LightShadow( Camera camera )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__ - the light's view of the world.
   Create a new ``LightShadow``. This is not intended to be called directly - it is used as a base
   class by other light shadows.

Properties
----------

⭕:Boolean autoUpdate
~~~~~~~~~~~~~~~~~~~~~~

   Enables automatic updates of the light's shadow. Default is ``true``. If you do not
   require dynamic lighting / shadows, you may set this to ``false``.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The light's view of the world. This is used to generate a depth map of the scene; objects
   behind other objects from the light's perspective will be in shadow.

⭕:Float bias
~~~~~~~~~~~~~~

   Shadow map bias, how much to add or subtract from the normalized depth when deciding
   whether a surface is in shadow.
   The default is ``0``. Very tiny adjustments here (in the order of ``0.0001``) may help
   reduce artifacts in shadows

⭕:Integer blurSamples
~~~~~~~~~~~~~~~~~~~~~~~

   The amount of samples to use when blurring a VSM shadow map.

⭕:Float intensity
~~~~~~~~~~~~~~~~~~~

   The intensity of the shadow. The default is ``1``. Valid values are in the range \`[0,
   1]``.

⭕:WebGLRenderTarget map
~~~~~~~~~~~~~~~~~~~~~~~~~

   The depth map generated using the internal camera; a location beyond a pixel's depth is in
   shadow. Computed internally during rendering.

⭕:WebGLRenderTarget mapPass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The distribution map generated using the internal camera; an occlusion is calculated based
   on the distribution of depths. Computed internally during rendering.

⭕:Vector2 mapSize
~~~~~~~~~~~~~~~~~~~

   A [Page:Vector2] defining the width and height of the shadow map.
   Higher values give better quality shadows at the cost of computation time. Values must
   be powers of 2, up to the ``WebGLRenderer.capabilities``.maxTextureSize for a given
   device, although the width and height don't have to be the same (so, for example, (512,
   1024) is valid). The default is ``( 512, 512 )``.

⭕:Matrix4 matrix
~~~~~~~~~~~~~~~~~~

   Model to shadow camera space, to compute location and depth in shadow map. Stored in a
   `Matrix4 <#Matrix4>`__. This is computed internally during rendering.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   When set to ``true``, shadow maps will be updated in the next ``render`` call.
   Default is ``false``. If you have set ``.autoUpdate`` to ``false``, you will need to set this
   property to ``true`` and then make a render call to update the light's shadow.

⭕:Float normalBias
~~~~~~~~~~~~~~~~~~~~

   Defines how much the position used to query the shadow map is offset along the object
   normal. The default is ``0``. Increasing this value can be used to reduce shadow acne
   especially in large scenes where light shines onto geometry at a shallow angle. The cost
   is that shadows may appear distorted.

⭕:Float radius
~~~~~~~~~~~~~~~~

   Setting this to values greater than 1 will blur the edges of the shadow.
   High values will cause unwanted banding effects in the shadows - a greater
   ``mapSize`` will allow for a higher value to be used here before these
   effects become visible.
   If ``WebGLRenderer.shadowMap.type`` is set to `PCFSoftShadowMap <#Renderer>`__,
   radius has no effect and it is recommended to increase softness by decreasing
   ``mapSize`` instead.
   Note that this has no effect if the ``WebGLRenderer.shadowMap.type`` is set to
   `BasicShadowMap <#Renderer>`__.

Methods
-------

📦:getFrameExtents() Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Used internally by the renderer to extend the shadow map to contain all viewports

📦:updateMatrices( Light light ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the matrices for the camera and shadow, used internally by the renderer.
   light -- the light for which the shadow is being rendered.

📦:getFrustum() Frustum
~~~~~~~~~~~~~~~~~~~~~~~~

   Gets the shadow cameras frustum. Used internally by the renderer to cull objects.

📦:getViewportCount() number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Used internally by the renderer to get the number of viewports that need to be rendered
   for this shadow.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:copy( LightShadow source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies value of all the properties from the `source <#LightShadow>`__ to this Light.

📦:clone() LightShadow
~~~~~~~~~~~~~~~~~~~~~~~

   Creates a new LightShadow with the same properties as this one.

📦:toJSON() Object
~~~~~~~~~~~~~~~~~~~

   Serialize this LightShadow.



.. _D129:

LightShadow → PointLightShadow
==============================

   https://threejs.org/docs/api/en/lights/shadows/PointLightShadow.html

   This is used internally by `PointLights <#PointLight>`__ for calculating shadows.

   **Code Example**


   .. code:: javascript

      //Create a WebGLRenderer and turn on shadows in the renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

      //Create a PointLight and turn on shadows for the light
      const light = new THREE.PointLight( 0xffffff, 1, 100 );
      light.position.set( 0, 10, 4 );
      light.castShadow = true; // default false
      scene.add( light );

      //Set up shadow properties for the light
      light.shadow.mapSize.width = 512; // default
      light.shadow.mapSize.height = 512; // default
      light.shadow.camera.near = 0.5; // default
      light.shadow.camera.far = 500; // default

      //Create a sphere that cast shadows (but does not receive them)
      const sphereGeometry = new THREE.SphereGeometry( 5, 32, 32 );
      const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xff0000 } );
      const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
      sphere.castShadow = true; //default is false
      sphere.receiveShadow = false; //default
      scene.add( sphere );

      //Create a plane that receives shadows (but does not cast them)
      const planeGeometry = new THREE.PlaneGeometry( 20, 20, 32, 32 );
      const planeMaterial = new THREE.MeshStandardMaterial( { color: 0x00ff00 } )
      const plane = new THREE.Mesh( planeGeometry, planeMaterial );
      plane.receiveShadow = true;
      scene.add( plane );

      //Create a helper for the shadow camera (optional)
      const helper = new THREE.CameraHelper( light.shadow.camera );
      scene.add( helper );



   .. Constructor


🐣:PointLightShadow( )
~~~~~~~~~~~~~~~~~~~~~

   Creates a new ``PointLightShadow``. This is not intended to be called directly - it is called internally
   by ``PointLight``.

Properties
----------

   See the base `LightShadow <#LightShadow>`__ class for common properties.

⭕:Boolean isPointLightShadow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``PointLightShadow``.

Methods
-------

   See the base `LightShadow <#LightShadow>`__ class for common methods.

📦:updateMatrices( Light light, number viewportIndex) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the matrices for the camera and shadow, used internally by the renderer.
   light -- the light for which the shadow is being rendered.
   viewportIndex -- calculates the matrix for this viewport



.. _D130:

LightShadow → DirectionalLightShadow
====================================

   https://threejs.org/docs/api/en/lights/shadows/DirectionalLightShadow.html

   This is used internally by `DirectionalLights <#DirectionalLight>`__ for calculating
   shadows.
   Unlike the other shadow classes, this uses an ``OrthographicCamera`` to calculate the
   shadows, rather than a ``PerspectiveCamera``. This is because light rays from a
   ``DirectionalLight`` are parallel.

   **Code Example**


   .. code:: javascript

      //Create a WebGLRenderer and turn on shadows in the renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

      //Create a DirectionalLight and turn on shadows for the light
      const light = new THREE.DirectionalLight( 0xffffff, 1 );
      light.position.set( 0, 1, 0 ); //default; light shining from top
      light.castShadow = true; // default false
      scene.add( light );

      //Set up shadow properties for the light
      light.shadow.mapSize.width = 512; // default
      light.shadow.mapSize.height = 512; // default
      light.shadow.camera.near = 0.5; // default
      light.shadow.camera.far = 500; // default

      //Create a sphere that cast shadows (but does not receive them)
      const sphereGeometry = new THREE.SphereGeometry( 5, 32, 32 );
      const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xff0000 } );
      const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
      sphere.castShadow = true; //default is false
      sphere.receiveShadow = false; //default
      scene.add( sphere );

      //Create a plane that receives shadows (but does not cast them)
      const planeGeometry = new THREE.PlaneGeometry( 20, 20, 32, 32 );
      const planeMaterial = new THREE.MeshStandardMaterial( { color: 0x00ff00 } )
      const plane = new THREE.Mesh( planeGeometry, planeMaterial );
      plane.receiveShadow = true;
      scene.add( plane );

      //Create a helper for the shadow camera (optional)
      const helper = new THREE.CameraHelper( light.shadow.camera );
      scene.add( helper );


   .. Constructor


🐣:DirectionalLightShadow( )
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a new ``DirectionalLightShadow``. This is not intended to be called directly - 
   it is called internally by ``DirectionalLight``.

Properties
----------

   See the base `LightShadow <#LightShadow>`__ class for common properties.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The light's view of the world. This is used to generate a depth map of the scene;
   objects behind other objects from the light's perspective will be in shadow.
   The default is an ``OrthographicCamera`` with `left <#OrthographicCamera.left>`__ and
   `bottom <#OrthographicCamera.bottom>`__ set to ``-5``, `right <#OrthographicCamera.right>`__ 
   and `top <#OrthographicCamera.top>`__ set to ``5``, the
   `near <#OrthographicCamera.near>`__ clipping plane at ``0.5`` and the
   `far <#OrthographicCamera.far>`__ clipping plane at ``500``.

⭕:Boolean isDirectionalLightShadow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``DirectionalLightShadow``.

Methods
-------

   See the base `LightShadow <#LightShadow>`__ class for common methods.



.. _D131:

LightShadow → SpotLightShadow
=============================

   https://threejs.org/docs/api/en/lights/shadows/SpotLightShadow.html

   This is used internally by `SpotLights <#SpotLight>`__ for calculating shadows.

   **Code Example**


   .. code:: javascript

      //Create a WebGLRenderer and turn on shadows in the renderer 
      const renderer = new THREE.WebGLRenderer();
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap 

      //Create a SpotLight and turn on shadows for the light 
      const light = new THREE.SpotLight( 0xffffff );
      light.castShadow = true;           // default false 
      scene.add( light );
      //Set up shadow properties for the light 
      light.shadow.mapSize.width = 512;  // default 
      light.shadow.mapSize.height = 512; // default 
      light.shadow.camera.near = 0.5;    // default 
      light.shadow.camera.far = 500;     // default 
      light.shadow.focus = 1;            // default 

      //Create a sphere that cast shadows (but does not receive them) 
      const sphereGeometry = new THREE.SphereGeometry( 5, 32, 32 );
      const sphereMaterial = new THREE.MeshStandardMaterial( { color: 0xff0000 } );
      const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
      sphere.castShadow = true;     //default is false 
      sphere.receiveShadow = false; //default 
      scene.add( sphere );

      //Create a plane that receives shadows (but does not cast them) 
      const planeGeometry = new THREE.PlaneGeometry( 20, 20, 32, 32 );
      const planeMaterial = new THREE.MeshStandardMaterial( { color: 0x00ff00 } ) 
      const plane = new THREE.Mesh( planeGeometry, planeMaterial );
      plane.receiveShadow = true;
      scene.add( plane );
      //Create a helper for the shadow camera (optional) 
      const helper = new THREE.CameraHelper( light.shadow.camera );
      scene.add( helper );


   .. Constructor

🐣:SpotLightShadow()
~~~~~~~~~~~~~~~~~~~

   The constructor creates a ``PerspectiveCamera`` to manage the shadow's view of the world.

Properties
----------

   See the base `LightShadow <#LightShadow>`__ class for common properties.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The light's view of the world. This is used to generate a depth map of the scene;
   objects behind other objects from the light's perspective will be in shadow.
   The default is a ``PerspectiveCamera`` with `near <#PerspectiveCamera.near>`__
   clipping plane at ``0.5``. The `fov <#PerspectiveCamera.fov>`__ will track the
   `angle <#SpotLight.angle>`__ property of the owning `SpotLight <#SpotLight>`__ via the
   `update <#SpotLightShadow.update>`__ method. Similarly, the
   `aspect <#PerspectiveCamera.aspect>`__ property will track the aspect of the
   `mapSize <#LightShadow.mapSize>`__. If the `distance <#SpotLight.distance>`__ property
   of the light is set, the `far <#PerspectiveCamera.far>`__ clipping plane will track
   that, otherwise it defaults to ``500``.

⭕:Number focus
~~~~~~~~~~~~~~~~

   Used to focus the shadow camera. The camera's field of view is set as a percentage of
   the spotlight's field-of-view. Range is ``[0, 1]``. Default is ``1.0``.

⭕:Boolean isSpotLightShadow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``SpotLightShadow``.

Methods
-------

   See the base `LightShadow <#LightShadow>`__ class for common methods.



.. _D132:

Loader → AnimationLoader
========================

   https://threejs.org/docs/api/en/loaders/AnimationLoader.html

   Class for loading `AnimationClips <#AnimationClip>`__ in JSON format. This uses the
   ``FileLoader`` internally for loading files.

   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new THREE.AnimationLoader();

      // load a resource
      loader.load(
         // resource URL
         'animations/animation.js',

         // onLoad callback
         function ( animations ) {
            // animations is an array of AnimationClips
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.log( 'An error happened' );
         }
      );



   .. Constructor

🐣:AnimationLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``AnimationLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded `animation clips <#AnimationClip>`__.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called if load errors.
   Begin loading from url and pass the loaded animation to onLoad.

📦:parse( JSON json ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#JSON>`__ — required
   Parse the JSON object and return an array of animation clips. Individual clips in the
   object will be parsed with ``AnimationClip.parse``.



.. _D133:

Loader → AudioLoader
====================

   https://threejs.org/docs/api/en/loaders/AudioLoader.html

   Class for loading an `AudioBuffer`. This uses the `FileLoader <https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer>`__ 
   internally for loading files.

   **Code Example**


   .. code:: javascript

      // instantiate a listener
      const audioListener = new THREE.AudioListener();

      // add the listener to the camera
      camera.add( audioListener );

      // instantiate audio object
      const oceanAmbientSound = new THREE.Audio( audioListener );

      // add the audio object to the scene
      scene.add( oceanAmbientSound );

      // instantiate a loader
      const loader = new THREE.AudioLoader();

      // load a resource
      loader.load(
         // resource URL
         'audio/ambient_ocean.ogg',

         // onLoad callback
         function ( audioBuffer ) {
            // set the audio object buffer to the loaded object
            oceanAmbientSound.setBuffer( audioBuffer );

            // play the audio
            oceanAmbientSound.play();
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.log( 'An error happened' );
         }
      );



   .. Constructor

🐣:AudioLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``AudioLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `url <#String>`__ — the path or URL to the file. This can also be a
   -  `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   -  `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
      loaded text response.
   -  `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
      argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   -  `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
      not set the Content-Length header; `total <#Integer>`__ will be 0.
   -  `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and pass the loaded `AudioBuffer <#String>`__ to onLoad.



.. _D134:

Loader → BufferGeometryLoader
=============================

   https://threejs.org/docs/api/en/loaders/BufferGeometryLoader.html

   A loader for loading a ``BufferGeometry``. This uses the ``FileLoader`` internally
   for loading files.

   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new THREE.BufferGeometryLoader();

      // load a resource
      loader.load(
         // resource URL
         'models/json/pressure.json',

         // onLoad callback
         function ( geometry ) {
            const material = new THREE.MeshLambertMaterial( { color: 0xF5F5F5 } );
            const object = new THREE.Mesh( geometry, material );
            scene.add( object );
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.log( 'An error happened' );
         }
      );

   .. Constructor

🐣:BufferGeometryLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``BufferGeometryLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.d
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded ``BufferGeometry``.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and call onLoad with the parsed response content.

📦:parse( Object json ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — The ``JSON`` structure to parse.
   Parse a ``JSON`` structure and return a ``BufferGeometry``.



.. _D135:

Cache
=====

   https://threejs.org/docs/api/en/loaders/Cache.html

   A simple caching system, used internally by ``FileLoader``.

   **Code Example**

   To enable caching across all loaders that use ``FileLoader``, set


   .. code:: javascript

      THREE.Cache.enabled = true.


   **Examples**

   [example:webgl_geometry_text WebGL / geometry / text ]
   [example:webgl_interactive_instances_gpu WebGL / interactive / instances / gpu]
   [example:webgl_loader_ttf WebGL / loader / ttf]

Properties
----------

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   Whether caching is enabled. Default is ``false``.

⭕:Object files
~~~~~~~~~~~~~~~~

   An `object <#Object>`__ that holds cached files.

Methods
-------

📦:add( String key, Object file ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `key <#String>`__ — the `key <#String>`__ to reference the cached file by.
   `file <#Object>`__ — The file to be cached.
   Adds a cache entry with a key to reference the file. If this key already holds a file,
   it is overwritten.

📦:get( String key ) Any
~~~~~~~~~~~~~~~~~~~~~~~~~

   `key <#String>`__ — A string key
   Get the value of `key <#String>`__. If the key does not exist ``undefined`` is returned.

📦:remove( String key ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `key <#String>`__ — A string key that references a cached file.
   Remove the cached file associated with the key.

📦:clear() undefined
~~~~~~~~~~~~~~~~~~~~~

   Remove all values from the cache.



.. _D136:

Loader → CompressedTextureLoader
================================

   https://threejs.org/docs/api/en/loaders/CompressedTextureLoader.html

   Abstract base class for block based textures loader (dds, pvr, ...). This uses the
   ``FileLoader`` internally for loading files.

   **Examples**

   See the `DDSLoader <https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/DDSLoader.js>`__ 
   and `PVRLoader <https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/PVRLoader.js>`__ 
   for examples of derived classes.

   .. Constructor

🐣:CompressedTextureLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``CompressedTextureLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) CompressedTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ (optional) — Will be called when load completes. The argument
   will be the loaded texture.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and pass the loaded texture to onLoad. The method also returns a
   new texture object which can directly be used for material creation.



.. _D137:

Loader → CubeTextureLoader
==========================

   https://threejs.org/docs/api/en/loaders/CubeTextureLoader.html

   ``CompressedTextureLoader`` can be used to load cube maps. The loader returns an instance of ``CubeTexture``
   and expects the cube map to be defined as six separate images representing the sides of a
   cube. Other cube map definitions like vertical and horizontal cross, column and row
   layouts are not supported.

   The loaded ``CubeTexture`` is in sRGB color space. Meaning the `colorSpace <#Texture.colorSpace>`__ 
   property is set to ``THREE.SRGBColorSpace`` by default.

   **Code Example**


   .. code:: javascript

      const scene = new THREE.Scene();
      scene.background = new THREE.CubeTextureLoader() 
         .setPath( 'textures/cubeMaps/' ) 
         .load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] );


   **Examples**

   [example:webgl_materials_cubemap materials / cubemap]
   [example:webgl_materials_cubemap_dynamic materials / cubemap / dynamic]
   [example:webgl_materials_cubemap_refraction materials / cubemap / refraction]

   .. Constructor

🐣:CubeTextureLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``CubeTextureLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String urls, Function onLoad, Function onProgress, Function onError ) CubeTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `urls <#String>`__ — array of 6 urls to images, one for each side of the CubeTexture.
   The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z,
   neg-z. They can also be
   `Data URIs <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   Note that, by convention, cube maps are specified in a coordinate system in which
   positive-x is to the right when looking up the positive-z axis -- in other words, using
   a left-handed coordinate system. Since three.js uses a right-handed coordinate system,
   environment maps used in three.js will have pos-x and neg-x swapped.
   `onLoad <#Function>`__ (optional) — Will be called when load completes. The argument
   will be the loaded `texture <#CubeTexture>`__.
   `onProgress <#Function>`__ (optional) — This callback function is currently not
   supported.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and pass the loaded `texture <#CubeTexture>`__ to onLoad. The
   method also returns a new texture object which can directly be used for material creation.



.. _D138:

Loader → DataTextureLoader
==========================

   https://threejs.org/docs/api/en/loaders/DataTextureLoader.html

   Abstract base class to load generic binary textures formats (rgbe, hdr, ...). This uses
   the ``FileLoader`` internally for loading files, and creates a new ``DataTexture``.

   **Examples**

   See the
   `RGBELoader <https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/RGBELoader.js>`__ 
   for an example of a derived class.

   .. Constructor

🐣:DataTextureLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``DataTextureLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) DataTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ (optional) — Will be called when load completes. The argument
   will be the loaded texture.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses.The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and pass the loaded texture to onLoad. The method also returns a
   new texture object which can directly be used for material creation.



.. _D139:

Loader → FileLoader
===================

   https://threejs.org/docs/api/en/loaders/FileLoader.html

   A low level class for loading resources with Fetch, used internally by most loaders. It
   can also be used directly to load any file type that does not have a loader.

   **Code Example**


   .. code:: javascript

      const loader = new THREE.FileLoader();

      //load a text file and output the result to the console
      loader.load(
         // resource URL
         'example.txt',

         // onLoad callback
         function ( data ) {
            // output the text to the console
            console.log( data )
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.error( 'An error happened' );
         }
      );


   ``Note:`` The cache must be enabled using ``THREE.Cache.enabled = true;`` This is a global
   property and only needs to be set once to be used by all loaders that use FileLoader
   internally. `Cache <#Cache>`__ is a cache module that holds the response from each request
   made through this loader, so each file is requested once.

   .. Constructor

   ``DataTextureLoader`` ( [param:LoadingManager manager] )
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is ``DefaultLoadingManager``.

Properties
----------

   See the base ``Loader`` class for common properties.

⭕:String mimeType
~~~~~~~~~~~~~~~~~~~

   The expected ``mimeType``. See `setMimeType <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types>`__. 
   Default is ``undefined``.

⭕:String responseType
~~~~~~~~~~~~~~~~~~~~~~~

   The expected response type. See ``.setResponseType``. Default is ``undefined``.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ (optional) — Will be called when loading completes. The argument
   will be the loaded response.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called if an error occurs.
   Load the URL and pass the response to the onLoad function.

📦:setMimeType( String mimeType ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the expected
   `mimeType <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types>`__ 
   of the file being loaded. Note that in many cases this will be determined
   automatically, so by default it is ``undefined``.

📦:setResponseType( String responseType ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Change the response type. Valid values are:

   -  `text <#String>`__ or empty string (default) - returns the data as `String <#String>`__.
   -  `arraybuffer <#String>`__ - loads the data into a
      `ArrayBuffer <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer>`__ 
      and returns that.
   -  `blob <#String>`__ - returns the data as a
      `Blob <https://developer.mozilla.org/en/docs/Web/API/Blob>`__.
   -  `document <#String>`__ - parses the file using the
      `DOMParser <https://developer.mozilla.org/en-US/docs/Web/API/DOMParser>`__.
   -  `json <#String>`__ - parses the file using
      `JSON.parse <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse>`__.



.. _D140:

Loader → ImageBitmapLoader
==========================

   https://threejs.org/docs/api/en/loaders/ImageBitmapLoader.html

   A loader for loading an ``Image`` as an
   `ImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap>`__. An
   ImageBitmap provides an asynchronous and resource efficient pathway to prepare textures
   for rendering in WebGL.
   Unlike ``FileLoader``, ``DataTextureLoader`` does not avoid multiple concurrent requests to the same
   URL.

   Note that ``Texture.flipY`` and ``Texture.premultiplyAlpha`` with
   `ImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap>`__ are
   ignored. `ImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap>`__
   needs these configuration on bitmap creation unlike regular images need them on uploading
   to GPU. You need to set the equivalent options via ``ImageBitmapLoader.setOptions``
   instead. Refer to `WebGL specification <https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.10>`__ for the detail.

   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new THREE.ImageBitmapLoader();

      // set options if needed
      loader.setOptions( { imageOrientation: 'flipY' } );

      // load a image resource
      loader.load(
         // resource URL
         'textures/skyboxsun25degtest.png',

         // onLoad callback
         function ( imageBitmap ) {
            const texture = new THREE.CanvasTexture( imageBitmap );
            const material = new THREE.MeshBasicMaterial( { map: texture } );
         },

         // onProgress callback currently not supported
         undefined,

         // onError callback
         function ( err ) {
            console.log( 'An error happened' ); 
         }
      );


   **Examples**

   [example:webgl_loader_imagebitmap WebGL / loader / ImageBitmap]

   .. Constructor

🐣:ImageBitmapLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``ImageBitmapLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

⭕:Boolean isImageBitmapLoader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``ImageBitmapLoader``.

⭕:String options
~~~~~~~~~~~~~~~~~~

   An optional object that sets options for the internally used
   `createImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap>`__ 
   factory method. Default is ``undefined``.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded `image <#Image>`__.
   `onProgress <#Function>`__ (optional) — This callback function is currently not
   supported.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and return the `image <#ImageBitmap>`__ object that will contain
   the data.

📦:setOptions( Object options ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the options object for
   `createImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap>`__.



.. _D141:

Loader → ImageLoader
====================

   https://threejs.org/docs/api/en/loaders/ImageLoader.html

   A loader for loading an ``Image``. This is used internally by the
   ``CubeTextureLoader``, ``ObjectLoader`` and ``TextureLoader``.

   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new THREE.ImageLoader();

      // load a image resource
      loader.load(
         // resource URL
         'textures/skyboxsun25degtest.png',

         // onLoad callback
         function ( image ) {
            // use the image, e.g. draw part of it on a canvas
            const canvas = document.createElement( 'canvas' );
            const context = canvas.getContext( '2d' );
            context.drawImage( image, 100, 100 );
         },

         // onProgress callback currently not supported
         undefined,

         // onError callback
         function () {
            console.error( 'An error happened.' );
         }
      );




   Please note three.js r84 dropped support for ImageLoader progress events. For an
   ImageLoader that supports progress events, see
   `this thread <https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639>`__.

   **Examples**

   [example:webgl_loader_obj WebGL / loader / obj]
   [example:webgl_shaders_ocean WebGL / shaders / ocean]

   .. Constructor

🐣:ImageLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``ImageLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) HTMLImageElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded `image <#Image>`__.
   `onProgress <#Function>`__ (optional) — This callback function is currently not
   supported.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and return the `image <#Image>`__ object that will contain the
   data.



.. _D142:

Loader
======

   https://threejs.org/docs/api/en/loaders/Loader.html

   Base class for implementing loaders.

   .. Constructor

🐣:Loader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``Loader``.

Properties
----------

⭕:String crossOrigin
~~~~~~~~~~~~~~~~~~~~~~

   The crossOrigin string to implement CORS for loading the url from a different domain that
   allows CORS. Default is ``anonymous``.

⭕:Boolean withCredentials
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether the XMLHttpRequest uses credentials. See ``.setWithCredentials``.
   Default is ``false``.

⭕:LoadingManager manager
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The `loadingManager <#LoadingManager>`__ the loader is using.
   Default is ``DefaultLoadingManager``.

⭕:String path
~~~~~~~~~~~~~~~

   The base path from which the asset will be loaded. Default is the empty string.

⭕:String resourcePath
~~~~~~~~~~~~~~~~~~~~~~~

   The base path from which additional resources like textures will be loaded. Default is the
   empty string.

⭕:Object requestHeader
~~~~~~~~~~~~~~~~~~~~~~~~

   The `request header <https://developer.mozilla.org/en-US/docs/Glossary/Request_header>`__
   used in HTTP request. See ``.setRequestHeader``. Default is empty object.

Methods
-------

📦:load() undefined
~~~~~~~~~~~~~~~~~~~~

   This method needs to be implement by all concrete loaders. It holds the logic for loading
   the asset from the backend.

📦:loadAsync( String url, Function onProgress ) Promise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the file to be loaded.
   `onProgress <#Function>`__ (optional) — A function to be called while the loading is in
   progress. The argument will be the ProgressEvent instance, which contains 
   `lengthComputable <#Boolean>`__, `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.

   This method is equivalent to ``.load``, but returns a
   `Promise <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise>`__.

   `onLoad <#Function>`__ is handled by
   ``Promise.resolve`` and `Function onError <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve>`__ 
   is handled by `Promise.reject <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject>`__.

📦:parse() undefined
~~~~~~~~~~~~~~~~~~~~~

   This method needs to be implement by all concrete loaders. It holds the logic for parsing
   the asset into three.js entities.

📦:setCrossOrigin( String crossOrigin ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `crossOrigin <#String>`__ — The crossOrigin string to implement CORS for loading the url
   from a different domain that allows CORS.

📦:setWithCredentials( Boolean value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or
   TLS client certificates. See
   `XMLHttpRequest.withCredentials <https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials>`__.
   Note that this has no effect if you are loading files locally or from the same domain.

📦:setPath( String path ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `path <#String>`__ — Set the base path for the asset.

📦:setResourcePath( String resourcePath ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `resourcePath <#String>`__ — Set the base path for dependent resources like textures.

📦:setRequestHeader( Object requestHeader ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `requestHeader <#Object>`__ - key: The name of the header whose value is to be set.
   value: The value to set as the body of the header.
   Set the `request header <https://developer.mozilla.org/en-US/docs/Glossary/Request_header>`__ used in HTTP request.



.. _D143:

LoaderUtils
===========

   https://threejs.org/docs/api/en/loaders/LoaderUtils.html

   An object with several loader utility functions.

   Functions
   ---------

📦:decodeText( TypedArray array ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#TypedArray>`__ — A stream of bytes as a typed array.

   The function takes a stream of bytes as input and returns a string representation.

📦:extractUrlBase( String url ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — The url to extract the base url from.

   Extract the base from the URL.

📦:resolveURL( String url, String path ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — The absolute or relative url resolve. `path <#String>`__ — The base
   path for relative urls to be resolved against.

   Resolves relative urls against the given path. Absolute paths, data urls, and blob urls
   will be returned as is. Invalid urls will return an empty string.



.. _D144:

Loader → MaterialLoader
=======================

   https://threejs.org/docs/api/en/loaders/MaterialLoader.html

   A loader for loading a ``Material`` in JSON format. This uses the ``FileLoader``
   internally for loading files.

   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new THREE.MaterialLoader();

      // load a resource
      loader.load(
         // resource URL
         'path/to/material.json',

         // onLoad callback
         function ( material ) {
            object.material = material;
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.log( 'An error happened' );
         }
      );



   .. Constructor

🐣:MaterialLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``MaterialLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

⭕:Object textures
~~~~~~~~~~~~~~~~~~~

   Object holding any textures used by the material. See ``.setTextures``.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded ``Material``.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called when load errors.
   Begin loading from url.

📦:parse( Object json ) Material
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — The json object containing the parameters of the Material.
   Parse a ``JSON`` structure and create a new ``Material`` of the type `json.type <#String>`__ with parameters defined in the json object.

📦:setTextures( Object textures ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `textures <#Object>`__ — object containing any textures used by the material.



.. _D145:

Loader → ObjectLoader
=====================

   https://threejs.org/docs/api/en/loaders/ObjectLoader.html

   A loader for loading a JSON resource in the
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.
   This uses the ``FileLoader`` internally for loading files.

   **Code Example**


   .. code:: javascript

      const loader = new THREE.ObjectLoader();

      loader.load(
         // resource URL
         "models/json/example.json",

         // onLoad callback
         // Here the loaded data is assumed to be an object
         function ( obj ) {
            // Add the loaded object to the scene
            scene.add( obj );
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.error( 'An error happened' );
         }
      );


      // Alternatively, to parse a previously loaded JSON structure
      const object = loader.parse( a_json_object );

      scene.add( object );



   **Examples**

   [example:webgpu_materials_lightmap WebGL / materials / lightmap]

   .. Constructor

🐣:ObjectLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``ObjectLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded `object <#Object3D>`__.
   `onProgress <#Function>`__ (optional) — Will be called while load progresses. The
   argument will be the ProgressEvent instance, which contains `lengthComputable <#Boolean>`__, 
   `total <#Integer>`__ and `loaded <#Integer>`__. If the server does
   not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ (optional) — Will be called when load errors.

   Begin loading from url and call onLoad with the parsed response content.

📦:parse( Object json, Function onLoad ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   `onLoad <#Function>`__ — Will be called when parsed completes. The argument will be the
   parsed `object <#Object3D>`__.
   Parse a ``JSON`` structure and return a three.js object. This is used internally by
   ``.load``() but can also be used directly to parse a previously loaded JSON
   structure.

📦:parseGeometries( Object json ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   This is used by ``.parse``() to parse any `geometries <#BufferGeometry>`__ in the
   JSON structure.

📦:parseMaterials( Object json ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   This is used by ``.parse``() to parse any materials in the JSON structure using
   ``MaterialLoader``.

📦:parseAnimations( Object json ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   This is used by ``.parse``() to parse any animations in the JSON structure, using
   ``AnimationClip.parse``().

📦:parseImages( Object json ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   This is used by ``.parse``() to parse any images in the JSON structure, using
   ``ImageLoader``.

📦:parseTextures( Object json ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   This is used by ``.parse``() to parse any textures in the JSON structure.

📦:parseObject( Object json, BufferGeometry geometries, Material materials, AnimationClip animations ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — required. The JSON source to parse.
   `geometries <#BufferGeometry>`__ — required. The geometries of the JSON.
   `materials <#Material>`__ — required. The materials of the JSON.
   `animations <#AnimationClip>`__ — required. The animations of the JSON.
   This is used by ``.parse``() to parse any 3D objects in the JSON structure.



.. _D146:

Loader → TextureLoader
======================

   https://threejs.org/docs/api/en/loaders/TextureLoader.html

   Class for loading a `texture <#Texture>`__. This uses the ``ImageLoader`` internally
   for loading files.

   **Code Example**


   .. code:: javascript

      const texture = new THREE.TextureLoader().load('textures/land_ocean_ice_cloud_2048.jpg' ); 
      // immediately use the texture for material creation 

      const material = new THREE.MeshBasicMaterial( { map:texture } );


   **Code Example with Callbacks**

   .. code:: javascript

      // instantiate a loader
      const loader = new THREE.TextureLoader();

      // load a resource
      loader.load(
         // resource URL
         'textures/land_ocean_ice_cloud_2048.jpg',

         // onLoad callback
         function ( texture ) {
            // in this example we create the material when the texture is loaded
            const material = new THREE.MeshBasicMaterial( {
               map: texture
            } );
         },

         // onProgress callback currently not supported
         undefined,

         // onError callback
         function ( err ) {
            console.error( 'An error happened.' );
         }
      );


   Please note three.js r84 dropped support for TextureLoader progress events. For a
   TextureLoader that supports progress events, see
   `this thread <https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145>`__.

   **Examples**

   [example:webgl_geometry_cube geometry / cube]

   .. Constructor

🐣:TextureLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``TextureLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) Texture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ (optional) — Will be called when load completes. The argument
   will be the loaded `texture <#Texture>`__.
   `onProgress <#Function>`__ (optional) — This callback function is currently not
   supported.
   `onError <#Function>`__ (optional) — Will be called when load errors.
   Begin loading from the given URL and pass the fully loaded `texture <#Texture>`__ to
   onLoad. The method also returns a new texture object which can directly be used for
   material creation. If you do it this way, the texture may pop up in your scene once the
   respective loading process is finished.



.. _D147:

DefaultLoadingManager
=====================

   https://threejs.org/docs/api/en/loaders/managers/DefaultLoadingManager.html

   A global instance of the `LoadingManager <#LoadingManager>`__, used by most loaders when
   no custom manager has been specified.
   This will be sufficient for most purposes, however there may be times when you desire
   separate loading managers for say, textures and models.

   **Code Example**

   You can optionally set the `onStart <#LoadingManager.onStart>`__,
   `onLoad <#LoadingManager.onLoad>`__, `onProgress <#LoadingManager.onProgress>`__,
   `onError <#LoadingManager.onStart>`__ functions for the manager. These will then apply
   to any loaders using the DefaultLoadingManager.
   Note that these shouldn't be confused with the similarly named functions of individual
   loaders, as they are intended for displaying information about the overall status of
   loading, rather than dealing with the data that has been loaded.


   .. code:: javascript

      THREE.DefaultLoadingManager.onStart = function ( url, itemsLoaded, itemsTotal ) {
         console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
      };

      THREE.DefaultLoadingManager.onLoad = function ( ) {
         console.log( 'Loading Complete!');
      };

      THREE.DefaultLoadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
         console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
      };

      THREE.DefaultLoadingManager.onError = function ( url ) {
         console.log( 'There was an error loading ' + url );
      };



Properties
----------

   See the `LoadingManager <#LoadingManager>`__ page for details of properties.

Methods
-------

   See the `LoadingManager <#LoadingManager>`__ page for details of methods.



.. _D148:

LoadingManager
==============

   https://threejs.org/docs/api/en/loaders/managers/LoadingManager.html

   Handles and keeps track of loaded and pending data. A default global instance of this
   class is created and used by loaders if not supplied manually - see
   ``DefaultLoadingManager``.
   In general that should be sufficient, however there are times when it can be useful to
   have separate loaders - for example if you want to show separate loading bars for
   objects and textures.

   **Code Example**

   This example shows how to use LoadingManager to track the progress of ``OBJLoader``.


   .. code:: javascript

      const manager = new THREE.LoadingManager();
      manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
         console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
      };

      manager.onLoad = function ( ) {
         console.log( 'Loading complete!');
      };

      manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
         console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
      };

      manager.onError = function ( url ) {
         console.log( 'There was an error loading ' + url );
      };

      const loader = new OBJLoader( manager );
      loader.load( 'file.obj', function ( object ) {
         //
      } );


   In addition to observing progress, a LoadingManager can be used to override resource URLs
   during loading. This may be helpful for assets coming from drag-and-drop events,
   WebSockets, WebRTC, or other APIs. An example showing how to load an in-memory model using
   Blob URLs is below.


   .. code:: javascript

      // Blob or File objects created when dragging files into the webpage.
      const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};

      const manager = new THREE.LoadingManager();

      // Initialize loading manager with URL callback.
      const objectURLs = [];
      manager.setURLModifier( ( url ) => {

         url = URL.createObjectURL( blobs[ url ] );
         objectURLs.push( url );
         return url;

      } );

      // Load as usual, then revoke the blob URLs.
      const loader = new GLTFLoader( manager );
      loader.load( 'fish.gltf', (gltf) => {

         scene.add( gltf.scene );
         objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );

      });


   **Examples**

   [example:webgl_loader_obj WebGL / loader / obj]
   [example:webgl_postprocessing_outline WebGL / postprocessing / outline]

   .. Constructor

🐣:LoadingManager( Function onLoad, Function onProgress, Function onError )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `onLoad <#Function>`__ — (optional) this function will be called when all loaders are done.
   -  `onProgress <#Function>`__ — (optional) this function will be called when an item is complete.
   -  `onError <#Function>`__ — (optional) this function will be called a loader encounters errors.

   Creates a new ``LoadingManager``.

Properties
----------

⭕:Function onStart
~~~~~~~~~~~~~~~~~~~~

   This function will be called when loading starts. The arguments are:
   `url <#String>`__ — The url of the item just loaded.
   `itemsLoaded <#Integer>`__ — the number of items already loaded so far.
   `itemsTotal <#Integer>`__ — the total amount of items to be loaded.
   By default this is undefined.

⭕:Function onLoad
~~~~~~~~~~~~~~~~~~~

   This function will be called when all loading is completed. By default this is undefined,
   unless passed in the constructor.

⭕:Function onProgress
~~~~~~~~~~~~~~~~~~~~~~~

   This function will be called when an item is complete. The arguments are:
   `url <#String>`__ — The url of the item just loaded.
   `itemsLoaded <#Integer>`__ — the number of items already loaded so far.
   `itemsTotal <#Integer>`__ — the total amount of items to be loaded.
   By default this is undefined, unless passed in the constructor.

⭕:Function onError
~~~~~~~~~~~~~~~~~~~~

   This function will be called when any item errors, with the argument:
   `url <#String>`__ — The url of the item that errored.
   By default this is undefined, unless passed in the constructor.

Methods
-------

📦:addHandler( Object regex, Loader loader ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `regex <#Object>`__ — A regular expression.
   `loader <#Loader>`__ — The loader.

   Registers a loader with the given regular expression. Can be used to define what loader
   should be used in order to load specific files. A typical use case is to overwrite the
   default loader for textures.


   .. code:: javascript

      // add handler for TGA textures manager.addHandler( /\.tga$/i, new TGALoader() );


📦:getHandler( String file ) Loader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `file <#String>`__ — The file path.

   Can be used to retrieve the registered loader for the given file path.

📦:removeHandler( Object regex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `regex <#Object>`__ — A regular expression.

   Removes the loader for the given regular expression.

📦:resolveURL( String url ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the url to load
   Given a URL, uses the URL modifier callback (if any) and returns a resolved URL. If no
   URL modifier is set, returns the original URL.

📦:setURLModifier( Function callback ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `callback <#Function>`__ — URL modifier callback. Called with `url <#String>`__
   argument, and must return `resolvedURL <#String>`__.
   If provided, the callback will be passed each resource URL before a request is sent. The
   callback may return the original URL, or a new URL to override loading behavior. This
   behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.

   

   *Note: The following methods are designed to be called internally by loaders. You
   shouldn't call them directly.*

📦:itemStart( String url ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the url to load
   This should be called by any loader using the manager when the loader starts loading an
   url.

📦:itemEnd( String url ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the loaded url
   This should be called by any loader using the manager when the loader ended loading an
   url.

📦:itemError( String url ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the loaded url
   This should be called by any loader using the manager when the loader errors loading an
   url.



.. _D149:

Material → LineBasicMaterial
============================

   https://threejs.org/docs/api/en/materials/LineBasicMaterial.html

   A material for drawing wireframe-style geometries.

   **Code Example**


   .. code:: javascript

      const material = new THREE.LineBasicMaterial( {
         color: 0xffffff,
         linewidth: 1,
         linecap: 'round', //ignored by WebGLRenderer
         linejoin:  'round' //ignored by WebGLRenderer
      } );


   **Examples**

   [example:webgl_buffergeometry_drawrange WebGL / buffergeometry / drawrange]
   [example:webgl_buffergeometry_lines WebGL / buffergeometry / lines]
   [example:webgl_buffergeometry_lines_indexed WebGL / buffergeometry / lines / indexed]
   [example:webgl_decals WebGL / decals]
   [example:webgl_geometry_nurbs WebGL / geometry / nurbs]
   [example:webgl_geometry_shapes WebGL / geometry / shapes]
   [example:webgl_geometry_spline_editor WebGL / geometry / spline / editor]
   [example:webgl_interactive_buffergeometry WebGL / interactive / buffergeometry]
   [example:webgl_interactive_voxelpainter WebGL / interactive / voxelpainter]
   [example:webgl_lines_colors WebGL / lines / colors]
   [example:webgl_lines_dashed WebGL / lines / dashed]
   [example:physics_ammo_rope physics / ammo / rope]

   .. Constructor

🐣:LineBasicMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Float linewidth
~~~~~~~~~~~~~~~~~~~

   Controls line thickness. Default is ``1``.
   Due to limitations of the
   `OpenGL Core Profile` with the `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will always be ``1`` regardless of the set value.

⭕:String linecap
~~~~~~~~~~~~~~~~~~

   Define appearance of line ends. Possible values are 'butt', 'round' and 'square'.
   Default is 'round'. This corresponds to the `2D Canvas lineCap` property and it is 
   ignored by the `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap>`__ 
   renderer.

⭕:String linejoin
~~~~~~~~~~~~~~~~~~~

   Define appearance of line joints. Possible values are 'round', 'bevel' and 'miter'.
   Default is 'round'.
   This corresponds to the `2D Canvas lineJoin` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin>`__ renderer.

⭕:Texture map
~~~~~~~~~~~~~~~

   Sets the color of the lines using data from a ``Texture``.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D150:

Material → LineBasicMaterial → LineDashedMaterial
=================================================

   https://threejs.org/docs/api/en/materials/LineDashedMaterial.html

   A material for drawing wireframe-style geometries with dashed lines.

   Note: You must call ``Line.computeLineDistances``() when using ``LineBasicMaterial``.

   **Code Example**


   .. code:: javascript

      const material = new THREE.LineDashedMaterial( { 
         color: 0xffffff, 
         linewidth: 1, 
         scale: 1, 
         dashSize: 3, 
         gapSize: 1, 
      } );


   **Examples**

   [example:webgl_lines_dashed WebGL / lines / dashed]

   .. Constructor

🐣:LineDashedMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited from
   ``LineBasicMaterial``) can be passed in here.

Properties
----------

   See the base ``LineBasicMaterial`` class for common properties.

⭕:number dashSize
~~~~~~~~~~~~~~~~~~~

   The size of the dash. This is both the gap with the stroke. Default is ``3``.

⭕:number gapSize
~~~~~~~~~~~~~~~~~~

   The size of the gap. Default is ``1``.

⭕:Boolean isLineDashedMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``LineDashedMaterial``.

⭕:number scale
~~~~~~~~~~~~~~~~

   The scale of the dashed part of a line. Default is ``1``.

Methods
-------

   See the base ``LineBasicMaterial`` class for common methods.



.. _D151:

Material
========

   https://threejs.org/docs/api/en/materials/Material.html

   Abstract base class for materials.
   Materials describe the appearance of `objects <#Object>`__. They are defined in a
   (mostly) renderer-independent way, so you don't have to rewrite materials if you decide
   to use a different renderer.
   The following properties and methods are inherited by all other material types (although
   they may have different defaults).

   .. Constructor


🐣:Material()
~~~~~~~~~~~~

   This creates a generic material.

Properties
----------

⭕:Boolean alphaHash
~~~~~~~~~~~~~~~~~~~~~

   Enables alpha hashed transparency, an alternative to ``.transparent`` or
   ``.alphaTest``. The material will not be rendered if opacity is lower than a random
   threshold. Randomization introduces some grain or noise, but approximates alpha blending
   without the associated problems of sorting. Using TAARenderPass can reduce the resulting
   noise.

⭕:Float alphaTest
~~~~~~~~~~~~~~~~~~~

   Sets the alpha value to be used when running an alpha test. The material will not be
   rendered if the opacity is lower than this value. Default is ``0``.

⭕:Boolean alphaToCoverage
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Enables alpha to coverage. Can only be used with MSAA-enabled contexts (meaning when the
   renderer was created with ``antialias`` parameter set to ``true``). Enabling this will
   smooth aliasing on clip plane edges and alphaTest-clipped edges. Default is ``false``.

⭕:Float blendAlpha
~~~~~~~~~~~~~~~~~~~~

   Represents the alpha value of the constant blend color. Default is ``0``. This property
   has only an effect when using custom blending with `ConstantAlpha <#CustomBlendingEquation>`__
    or `OneMinusConstantAlpha <#CustomBlendingEquation>`__.

⭕:Color blendColor
~~~~~~~~~~~~~~~~~~~~

   Represent the RGB values of the constant blend color. Default is ``0x000000``.
   This property has only an effect when using custom blending with
   `ConstantColor <#CustomBlendingEquation>`__ or `OneMinusConstantColor <#CustomBlendingEquation>`__.

⭕:Integer blendDst
~~~~~~~~~~~~~~~~~~~~

   Blending destination. Default is `OneMinusSrcAlphaFactor <#CustomBlendingEquation>`__.
   See the destination factors `constants <#CustomBlendingEquation>`__ for all possible
   values.
   The material's `blending <#Constant>`__ must be set to `CustomBlending <#Materials>`__
   for this to have any effect.

⭕:Integer blendDstAlpha
~~~~~~~~~~~~~~~~~~~~~~~~~

   The transparency of the ``.blendDst``. Uses ``.blendDst`` value if null.
   Default is ``null``.

⭕:Integer blendEquation
~~~~~~~~~~~~~~~~~~~~~~~~~

   Blending equation to use when applying blending. Default is `AddEquation <#CustomBlendingEquation>`__. 
   See the blending equation `constants <#CustomBlendingEquation>`__ for all
   possible values.
   The material's `blending <#Constant>`__ must be set to `CustomBlending <#Materials>`__
   for this to have any effect.

⭕:Integer blendEquationAlpha
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The transparency of the ``.blendEquation``. Uses ``.blendEquation`` value if null.
   Default is ``null``.

⭕:Blending blending
~~~~~~~~~~~~~~~~~~~~~

   Which blending to use when displaying objects with this material.
   This must be set to `CustomBlending <#Materials>`__ to use custom `blendSrc <#Constant>`__, 
   `blendDst <#Constant>`__ or `blendEquation <#Constant>`__.
   See the blending mode `constants <#Materials>`__ for all possible values. Default is
   `NormalBlending <#Materials>`__.

⭕:Integer blendSrc
~~~~~~~~~~~~~~~~~~~~

   Blending source. Default is `SrcAlphaFactor <#CustomBlendingEquation>`__. See the source
   factors `constants <#CustomBlendingEquation>`__ for all possible values.
   The material's `blending <#Constant>`__ must be set to `CustomBlending <#Materials>`__
   for this to have any effect.

⭕:Integer blendSrcAlpha
~~~~~~~~~~~~~~~~~~~~~~~~~

   The transparency of the ``.blendSrc``. Uses ``.blendSrc`` value if null.
   Default is ``null``.

⭕:Boolean clipIntersection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Changes the behavior of clipping planes so that only their intersection is clipped, rather
   than their union. Default is ``false``.

⭕:Array clippingPlanes
~~~~~~~~~~~~~~~~~~~~~~~~

   User-defined clipping planes specified as THREE.Plane objects in world space. These planes
   apply to the objects this material is attached to. Points in space whose signed distance
   to the plane is negative are clipped (not rendered). This requires
   ``WebGLRenderer.localClippingEnabled`` to be ``true``. See the
   [example:webgl_clipping_intersection WebGL / clipping /intersection] example.
   Default is ``null``.

⭕:Boolean clipShadows
~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether to clip shadows according to the clipping planes specified on this
   material. Default is ``false``.

⭕:Boolean colorWrite
~~~~~~~~~~~~~~~~~~~~~~

   Whether to render the material's color. This can be used in conjunction with a mesh's
   `renderOrder <#Integer>`__ property to create invisible objects that occlude other
   objects. Default is ``true``.

⭕:Object defines
~~~~~~~~~~~~~~~~~~

   Custom defines to be injected into the shader. These are passed in form of an object
   literal, with key/value pairs. ``{ MY_CUSTOM_DEFINE: '' , PI2: Math.PI ** 2 }``. The pairs
   are defined in both vertex and fragment shaders. Default is ``undefined``.

⭕:Integer depthFunc
~~~~~~~~~~~~~~~~~~~~~

   Which depth function to use. Default is `LessEqualDepth <#Materials>`__. See the depth
   mode `constants <#Materials>`__ for all possible values.

⭕:Boolean depthTest
~~~~~~~~~~~~~~~~~~~~~

   Whether to have depth test enabled when rendering this material. Default is ``true``. When
   the depth test is disabled, the depth write will also be implicitly disabled.

⭕:Boolean depthWrite
~~~~~~~~~~~~~~~~~~~~~~

   Whether rendering this material has any effect on the depth buffer. Default is ``true``.
   When drawing 2D overlays it can be useful to disable the depth writing in order to layer
   several things together without creating z-index artifacts.

⭕:Boolean forceSinglePass
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether double-sided, transparent objects should be rendered with a single pass or not.
   Default is ``false``.
   The engine renders double-sided, transparent objects with two draw calls (back faces
   first, then front faces) to mitigate transparency artifacts. There are scenarios however
   where this approach produces no quality gains but still doubles draw calls e.g. when
   rendering flat vegetation like grass sprites. In these cases, set the
   ``forceSinglePass`` flag to ``true`` to disable the two pass rendering to avoid
   performance issues.

⭕:Boolean isMaterial
~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Material``.

⭕:Boolean stencilWrite
~~~~~~~~~~~~~~~~~~~~~~~~

   Whether stencil operations are performed against the stencil buffer. In order to perform
   writes or comparisons against the stencil buffer this value must be ``true``.
   Default is ``false``.

⭕:Integer stencilWriteMask
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The bit mask to use when writing to the stencil buffer. Default is ``0xFF``.

⭕:Integer stencilFunc
~~~~~~~~~~~~~~~~~~~~~~~

   The stencil comparison function to use. Default is `AlwaysStencilFunc <#Materials>`__. See
   stencil function `constants <#Materials>`__ for all possible values.

⭕:Integer stencilRef
~~~~~~~~~~~~~~~~~~~~~~

   The value to use when performing stencil comparisons or stencil operations.
   Default is ``0``.

⭕:Integer stencilFuncMask
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The bit mask to use when comparing against the stencil buffer. Default is ``0xFF``.

⭕:Integer stencilFail
~~~~~~~~~~~~~~~~~~~~~~~

   Which stencil operation to perform when the comparison function returns false. Default is
   `KeepStencilOp <#Materials>`__. See the stencil operations `constants <#Materials>`__ for
   all possible values.

⭕:Integer stencilZFail
~~~~~~~~~~~~~~~~~~~~~~~~

   Which stencil operation to perform when the comparison function returns true but the depth
   test fails. Default is `KeepStencilOp <#Materials>`__. See the stencil operations
   `constants <#Materials>`__ for all possible values.

⭕:Integer stencilZPass
~~~~~~~~~~~~~~~~~~~~~~~~

   Which stencil operation to perform when the comparison function returns true and the depth
   test passes. Default is `KeepStencilOp <#Materials>`__. See the stencil operations
   `constants <#Materials>`__ for all possible values.

⭕:Integer id
~~~~~~~~~~~~~~

   Unique number for this material instance.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name of the object (doesn't need to be unique). Default is an empty string.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   Specifies that the material needs to be recompiled.

⭕:Float opacity
~~~~~~~~~~~~~~~~~

   Float in the range of ``0.0`` - ``1.0`` indicating how transparent the material is. A
   value of ``0.0`` indicates fully transparent, ``1.0`` is fully opaque.
   If the material's `transparent <#Boolean>`__ property is not set to ``true``, the
   material will remain fully opaque and this value will only affect its color.
   Default is ``1.0``.

⭕:Boolean polygonOffset
~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to use polygon offset. Default is ``false``. This corresponds to the
   ``GL_POLYGON_OFFSET_FILL`` WebGL feature.

⭕:Integer polygonOffsetFactor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the polygon offset factor. Default is ``0``.

⭕:Integer polygonOffsetUnits
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the polygon offset units. Default is ``0``.

⭕:String precision
~~~~~~~~~~~~~~~~~~~~

   Override the renderer's default precision for this material. Can be ``"highp"``,
   ``"mediump"`` or ``"lowp"``. Default is ``null``.

⭕:Boolean premultipliedAlpha
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to premultiply the alpha (transparency) value. See
   [Example:webgl_materials_physical_transmission WebGL / Materials / Physical /
   Transmission] for an example of the difference. Default is ``false``.

⭕:Boolean dithering
~~~~~~~~~~~~~~~~~~~~~

   Whether to apply dithering to the color to remove the appearance of banding.
   Default is ``false``.

⭕:Integer shadowSide
~~~~~~~~~~~~~~~~~~~~~~

   Defines which side of faces cast shadows. When set, can be `THREE.FrontSide <#Materials>`__, 
   `THREE.BackSide <#Materials>`__, or `THREE.DoubleSide <#Materials>`__.
   Default is ``null``.
   If ``null``, the side casting shadows is determined as follows:

   ==================== ====================
   ``Material.side`` Side casting shadows
   ==================== ====================
   THREE.FrontSide      back side
   THREE.BackSide       front side
   THREE.DoubleSide     both sides
   ==================== ====================

⭕:Integer side
~~~~~~~~~~~~~~~~

   Defines which side of faces will be rendered - front, back or both. Default is
   `THREE.FrontSide <#Materials>`__. Other options are `THREE.BackSide <#Materials>`__ or
   `THREE.DoubleSide <#Materials>`__.

⭕:Boolean toneMapped
~~~~~~~~~~~~~~~~~~~~~~

   Defines whether this material is tone mapped according to the renderer's
   `toneMapping <#WebGLRenderer.toneMapping>`__ setting. It is ignored when rendering to a
   render target or using post processing. Default is ``true``.

⭕:Boolean transparent
~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether this material is transparent. This has an effect on rendering as
   transparent objects need special treatment and are rendered after non-transparent
   objects.
   When set to true, the extent to which the material is transparent is controlled by
   setting its `opacity <#Float>`__ property. Default is ``false``.

⭕:String type
~~~~~~~~~~~~~~~

   Value is the string 'Material'. This shouldn't be changed, and can be used to find all
   objects of this type in a scene.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this material
   instance. This gets automatically assigned, so this shouldn't be edited.

⭕:Integer version
~~~~~~~~~~~~~~~~~~~

   This starts at ``0`` and counts how many times `.needsUpdate <#Material.needsUpdate>`__ is
   set to ``true``.

⭕:Boolean vertexColors
~~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether vertex coloring is used. Default is ``false``. The engine supports RGB and
   RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color
   buffer attribute is used.

⭕:Boolean visible
~~~~~~~~~~~~~~~~~~~

   Defines whether this material is visible. Default is ``true``.

⭕:Object userData
~~~~~~~~~~~~~~~~~~~

   An object that can be used to store custom data about the Material. It should not hold
   references to functions as these will not be cloned. Default is an empty object ``{}``.

Methods
-------

   `EventDispatcher <#EventDispatcher>`__ methods are available on this class.

📦:clone( ) Material
~~~~~~~~~~~~~~~~~~~~~

   Return a new material with the same parameters as this material.

📦:copy( material material ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copy the parameters from the passed material into this material.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

   Material textures must be disposed of by the dispose() method of `Texture <#Texture>`__.

📦:onBeforeCompile( Shader shader, WebGLRenderer renderer ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An optional callback that is executed immediately before the shader program is compiled.
   This function is called with the shader source code as a parameter. Useful for the
   modification of built-in materials.

   Unlike properties, the callback is not supported by `.clone <#Material.clone>`__(),
   `.copy <#Material.copy>`__() and `.toJSON <#Material.toJSON>`__().

📦:customProgramCacheKey() String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In case onBeforeCompile is used, this callback can be used to identify values of settings
   used in onBeforeCompile, so three.js can reuse a cached shader or recompile the shader for
   this material as needed.

   For example, if onBeforeCompile contains a conditional statement like:

   .. code:: javascript

      if ( black ) { 
         shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4(1)', 'gl_FragColor = vec4(0)') 
      }

   then customProgramCacheKey should be set like this:

   .. code:: javascript

      material.customProgramCacheKey = function() { return black ? '1' : '0'; }


   Unlike properties, the callback is not supported by `.clone <#Material.clone>`__(),
   `.copy <#Material.copy>`__() and `.toJSON <#Material.toJSON>`__().

📦:setValues( Object values ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   values -- a container with parameters.
   Sets the properties based on the ``values``.

📦:toJSON( Object meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- object containing metadata such as textures or images for the material.
   Convert the material to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.



.. _D152:

Material → MeshBasicMaterial
============================

   https://threejs.org/docs/api/en/materials/MeshBasicMaterial.html

   A material for drawing geometries in a simple shaded (flat or wireframe) way.
   This material is not affected by lights.

   .. Constructor

🐣:MeshBasicMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture aoMap
~~~~~~~~~~~~~~~~~

   The red channel of this texture is used as the ambient occlusion map. Default is null. The
   aoMap requires a second set of UVs.

⭕:Float aoMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the ambient occlusion effect. Default is ``1``. Zero is no occlusion effect.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Integer combine
~~~~~~~~~~~~~~~~~~~

   How to combine the result of the surface's color with the environment map, if any.
   Options are `THREE.MultiplyOperation <#Materials>`__ (default), `THREE.MixOperation <#Materials>`__, 
   `THREE.AddOperation <#Materials>`__. If mix is chosen, the
   ``.reflectivity`` is used to blend between the two colors.

⭕:Texture envMap
~~~~~~~~~~~~~~~~~~

   The environment map. Default is null.

⭕:Euler envMapRotation
~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the environment map in radians. Default is ``(0,0,0)``.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Texture lightMap
~~~~~~~~~~~~~~~~~~~~

   The light map. Default is null. The lightMap requires a second set of UVs.

⭕:Float lightMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the baked light. Default is ``1``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null.

⭕:Float reflectivity
~~~~~~~~~~~~~~~~~~~~~~

   How much the environment map affects the surface; also see ``.combine``. The default
   value is ``1`` and the valid range is between ``0`` (no reflections) and ``1`` (full
   reflections).

⭕:Float refractionRatio
~~~~~~~~~~~~~~~~~~~~~~~~~

   The index of refraction (IOR) of air (approximately 1) divided by the index of refraction
   of the material. It is used with environment mapping modes `THREE.CubeRefractionMapping <#Textures>`__ 
   and `THREE.EquirectangularRefractionMapping <#Textures>`__.
   The refraction ratio should not exceed ``1``. Default is ``0.98``.

⭕:Texture specularMap
~~~~~~~~~~~~~~~~~~~~~~~

   Specular map used by the material. Default is null.

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is ``false`` (i.e. render as flat polygons).

⭕:String wireframeLinecap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line ends. Possible values are "butt", "round" and "square".
   Default is 'round'.

   This corresponds to the `2D Canvas lineCap` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap>`__ renderer.

⭕:String wireframeLinejoin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line joints. Possible values are "round", "bevel" and "miter".
   Default is 'round'.

   This corresponds to the `2D Canvas lineJoin` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin>`__ renderer.

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.

   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D153:

Material → MeshDepthMaterial
============================

   https://threejs.org/docs/api/en/materials/MeshDepthMaterial.html

   A material for drawing geometry by depth. Depth is based off of the camera near and far
   plane. White is nearest, black is farthest.

   .. Constructor

🐣:MeshDepthMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited from
   ``Material``) can be passed in here.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Constant depthPacking
~~~~~~~~~~~~~~~~~~~~~~~~~

   Type for depth packing. Default is `BasicDepthPacking <#Textures>`__.

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``false``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null.

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is false (i.e. render as smooth shaded).

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.

   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D154:

Material → MeshDistanceMaterial
===============================

   https://threejs.org/docs/api/en/materials/MeshDistanceMaterial.html

   ``MeshDepthMaterial`` is internally used for implementing shadow mapping with ``PointLight``s.
   Can also be used to customize the shadow casting of an object by assigning an instance
   of ``MeshDepthMaterial`` to ``Object3D.customDistanceMaterial``. The following examples demonstrates
   this approach in order to ensure transparent parts of objects do no cast shadows.

   **Examples**

   [example:webgl_shadowmap_pointlight WebGL / shadowmap / pointlight]

   .. Constructor

🐣:MeshDistanceMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited from
   ``Material``) can be passed in here.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``false``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D155:

Material → MeshLambertMaterial
==============================

   https://threejs.org/docs/api/en/materials/MeshLambertMaterial.html

   A material for non-shiny surfaces, without specular highlights.
   The material uses a non-physically based
   `Lambertian <https://en.wikipedia.org/wiki/Lambertian_reflectance>`__ model for
   calculating reflectance. This can simulate some surfaces (such as untreated wood or
   stone) well, but cannot simulate shiny surfaces with specular highlights (such as
   varnished wood). ``MeshDistanceMaterial`` uses per-fragment shading.
   Due to the simplicity of the reflectance and illumination models, performance will be
   greater when using this material over the ``MeshPhongMaterial``,
   ``MeshStandardMaterial`` or ``MeshPhysicalMaterial``, at the cost of some
   graphical accuracy.

   .. Constructor

🐣:MeshLambertMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture aoMap
~~~~~~~~~~~~~~~~~

   The red channel of this texture is used as the ambient occlusion map. Default is null. The
   aoMap requires a second set of UVs.

⭕:Float aoMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the ambient occlusion effect. Default is ``1``. Zero is no occlusion effect.

⭕:Texture bumpMap
~~~~~~~~~~~~~~~~~~~

   The texture to create a bump map. The black and white values map to the perceived depth in
   relation to the lights. Bump doesn't actually affect the geometry of the object, only the
   lighting. If a normal map is defined this will be ignored.

⭕:Float bumpScale
~~~~~~~~~~~~~~~~~~~

   How much the bump map affects the material. Typical ranges are 0-1. Default is 1.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Integer combine
~~~~~~~~~~~~~~~~~~~

   How to combine the result of the surface's color with the environment map, if any.
   Options are `THREE.MultiplyOperation <#Materials>`__ (default), `THREE.MixOperation <#Materials>`__, 
   `THREE.AddOperation <#Materials>`__. If mix is chosen, the
   ``.reflectivity`` is used to blend between the two colors.

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Color emissive
~~~~~~~~~~~~~~~~~~

   Emissive (light) color of the material, essentially a solid color unaffected by other
   lighting. Default is black.

⭕:Texture emissiveMap
~~~~~~~~~~~~~~~~~~~~~~~

   Set emissive (glow) map. Default is null. The emissive map color is modulated by the
   emissive color and the emissive intensity. If you have an emissive map, be sure to set the
   emissive color to something other than black.

⭕:Float emissiveIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the emissive light. Modulates the emissive color. Default is 1.

⭕:Texture envMap
~~~~~~~~~~~~~~~~~~

   The environment map. Default is null.

⭕:Euler envMapRotation
~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the environment map in radians. Default is ``(0,0,0)``.

⭕:Boolean flatShading
~~~~~~~~~~~~~~~~~~~~~~~

   Define whether the material is rendered with flat shading. Default is false.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Texture lightMap
~~~~~~~~~~~~~~~~~~~~

   The light map. Default is null. The lightMap requires a second set of UVs.

⭕:Float lightMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the baked light. Default is ``1``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null.

⭕:Texture normalMap
~~~~~~~~~~~~~~~~~~~~~

   The texture to create a normal map. The RGB values affect the surface normal for each
   pixel fragment and change the way the color is lit. Normal maps do not change the actual
   shape of the surface, only the lighting. In case the material has a normal map authored
   using the left handed convention, the y component of normalScale should be negated to
   compensate for the different handedness.

⭕:Integer normalMapType
~~~~~~~~~~~~~~~~~~~~~~~~~

   The type of normal map.
   Options are `THREE.TangentSpaceNormalMap <#constant>`__ (default), and `THREE.ObjectSpaceNormalMap <#constant>`__.

⭕:Vector2 normalScale
~~~~~~~~~~~~~~~~~~~~~~~

   How much the normal map affects the material. Typical ranges are 0-1. Default is a
   ``Vector2`` set to (1,1).

⭕:Float reflectivity
~~~~~~~~~~~~~~~~~~~~~~

   How much the environment map affects the surface; also see ``.combine``.

⭕:Float refractionRatio
~~~~~~~~~~~~~~~~~~~~~~~~~

   The index of refraction (IOR) of air (approximately 1) divided by the index of refraction
   of the material. It is used with environment mapping modes `THREE.CubeRefractionMapping <#Textures>`__ 
   and `THREE.EquirectangularRefractionMapping <#Textures>`__.
   The refraction ratio should not exceed ``1``. Default is ``0.98``.

⭕:Texture specularMap
~~~~~~~~~~~~~~~~~~~~~~~

   Specular map used by the material. Default is null.

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is ``false`` (i.e. render as flat polygons).

⭕:String wireframeLinecap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line ends. Possible values are "butt", "round" and "square".
   Default is 'round'.
   This corresponds to the `2D Canvas lineCap` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap>`__ renderer.

⭕:String wireframeLinejoin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line joints. Possible values are "round", "bevel" and "miter".
   Default is 'round'.
   This corresponds to the `2D Canvas lineJoin` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin>`__ renderer.

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D156:

Material → MeshMatcapMaterial
=============================

   https://threejs.org/docs/api/en/materials/MeshMatcapMaterial.html

   ``MeshLambertMaterial`` is defined by a MatCap (or Lit Sphere) texture, which encodes the material color
   and shading.
   ``MeshLambertMaterial`` does not respond to lights since the matcap image file encodes baked lighting. It
   will cast a shadow onto an object that receives shadows (and shadow clipping works), but
   it will not self-shadow or receive shadows.

   .. Constructor

🐣:MeshMatcapMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture bumpMap
~~~~~~~~~~~~~~~~~~~

   The texture to create a bump map. The black and white values map to the perceived depth in
   relation to the lights. Bump doesn't actually affect the geometry of the object, only the
   lighting. If a normal map is defined this will be ignored.

⭕:Float bumpScale
~~~~~~~~~~~~~~~~~~~

   How much the bump map affects the material. Typical ranges are 0-1. Default is ``1``.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Boolean flatShading
~~~~~~~~~~~~~~~~~~~~~~~

   Define whether the material is rendered with flat shading. Default is false.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null. The texture map color is modulated by the diffuse ``.color``.

⭕:Texture matcap
~~~~~~~~~~~~~~~~~~

   The matcap map. Default is null.

⭕:Texture normalMap
~~~~~~~~~~~~~~~~~~~~~

   The texture to create a normal map. The RGB values affect the surface normal for each
   pixel fragment and change the way the color is lit. Normal maps do not change the actual
   shape of the surface, only the lighting. In case the material has a normal map authored
   using the left handed convention, the y component of normalScale should be negated to
   compensate for the different handedness.

⭕:Integer normalMapType
~~~~~~~~~~~~~~~~~~~~~~~~~

   The type of normal map.
   Options are `THREE.TangentSpaceNormalMap <#constant>`__ (default), and `THREE.ObjectSpaceNormalMap <#constant>`__.

⭕:Vector2 normalScale
~~~~~~~~~~~~~~~~~~~~~~~

   How much the normal map affects the material. Typical ranges are 0-1. Default is a
   ``Vector2`` set to (1,1).

Methods
-------

   See the base ``Material`` class for common methods.



.. _D157:

Material → MeshNormalMaterial
=============================

   https://threejs.org/docs/api/en/materials/MeshNormalMaterial.html

   A material that maps the normal vectors to RGB colors.

   .. Constructor

🐣:MeshNormalMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited from
   ``Material``) can be passed in here.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture bumpMap
~~~~~~~~~~~~~~~~~~~

   The texture to create a bump map. The black and white values map to the perceived depth in
   relation to the lights. Bump doesn't actually affect the geometry of the object, only the
   lighting. If a normal map is defined this will be ignored.

⭕:Float bumpScale
~~~~~~~~~~~~~~~~~~~

   How much the bump map affects the material. Typical ranges are 0-1. Default is ``1``.

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Boolean flatShading
~~~~~~~~~~~~~~~~~~~~~~~

   Define whether the material is rendered with flat shading. Default is false.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``false``.

⭕:Texture normalMap
~~~~~~~~~~~~~~~~~~~~~

   The texture to create a normal map. The RGB values affect the surface normal for each
   pixel fragment and change the way the color is lit. Normal maps do not change the actual
   shape of the surface, only the lighting. In case the material has a normal map authored
   using the left handed convention, the y component of normalScale should be negated to
   compensate for the different handedness.

⭕:Integer normalMapType
~~~~~~~~~~~~~~~~~~~~~~~~~

   The type of normal map.
   Options are `THREE.TangentSpaceNormalMap <#constant>`__ (default), and `THREE.ObjectSpaceNormalMap <#constant>`__.

⭕:Vector2 normalScale
~~~~~~~~~~~~~~~~~~~~~~~

   How much the normal map affects the material. Typical ranges are 0-1. Default is a
   ``Vector2`` set to (1,1).

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is false (i.e. render as smooth shaded).

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D158:

Material → MeshPhongMaterial
============================

   https://threejs.org/docs/api/en/materials/MeshPhongMaterial.html

   A material for shiny surfaces with specular highlights.
   The material uses a non-physically based
   `Blinn-Phong <https://en.wikipedia.org/wiki/Blinn-Phong_shading_model>`__ model for
   calculating reflectance. Unlike the Lambertian model used in the
   ``MeshLambertMaterial`` this can simulate shiny surfaces with specular highlights
   (such as varnished wood). ``MeshNormalMaterial`` uses per-fragment shading.
   Performance will generally be greater when using this material over the
   ``MeshStandardMaterial`` or ``MeshPhysicalMaterial``, at the cost of some
   graphical accuracy.

   .. Constructor

🐣:MeshPhongMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture aoMap
~~~~~~~~~~~~~~~~~

   The red channel of this texture is used as the ambient occlusion map. Default is null. The
   aoMap requires a second set of UVs.

⭕:Float aoMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the ambient occlusion effect. Default is ``1``. Zero is no occlusion effect.

⭕:Texture bumpMap
~~~~~~~~~~~~~~~~~~~

   The texture to create a bump map. The black and white values map to the perceived depth in
   relation to the lights. Bump doesn't actually affect the geometry of the object, only the
   lighting. If a normal map is defined this will be ignored.

⭕:Float bumpScale
~~~~~~~~~~~~~~~~~~~

   How much the bump map affects the material. Typical ranges are 0-1. Default is ``1``.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Integer combine
~~~~~~~~~~~~~~~~~~~

   How to combine the result of the surface's color with the environment map, if any.
   Options are `THREE.MultiplyOperation <#Materials>`__ (default), `THREE.MixOperation <#Materials>`__, 
   `THREE.AddOperation <#Materials>`__. If mix is chosen, the
   ``.reflectivity`` is used to blend between the two colors.

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Color emissive
~~~~~~~~~~~~~~~~~~

   Emissive (light) color of the material, essentially a solid color unaffected by other
   lighting. Default is black.

⭕:Texture emissiveMap
~~~~~~~~~~~~~~~~~~~~~~~

   Set emissive (glow) map. Default is null. The emissive map color is modulated by the
   emissive color and the emissive intensity. If you have an emissive map, be sure to set the
   emissive color to something other than black.

⭕:Float emissiveIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the emissive light. Modulates the emissive color. Default is 1.

⭕:Texture envMap
~~~~~~~~~~~~~~~~~~

   The environment map. Default is null.

⭕:Euler envMapRotation
~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the environment map in radians. Default is ``(0,0,0)``.

⭕:Boolean flatShading
~~~~~~~~~~~~~~~~~~~~~~~

   Define whether the material is rendered with flat shading. Default is false.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Texture lightMap
~~~~~~~~~~~~~~~~~~~~

   The light map. Default is null. The lightMap requires a second set of UVs.

⭕:Float lightMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the baked light. Default is ``1``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null. The texture map color is modulated by the diffuse ``.color``.

⭕:Texture normalMap
~~~~~~~~~~~~~~~~~~~~~

   The texture to create a normal map. The RGB values affect the surface normal for each
   pixel fragment and change the way the color is lit. Normal maps do not change the actual
   shape of the surface, only the lighting. In case the material has a normal map authored
   using the left handed convention, the y component of normalScale should be negated to
   compensate for the different handedness.

⭕:Integer normalMapType
~~~~~~~~~~~~~~~~~~~~~~~~~

   The type of normal map.
   Options are `THREE.TangentSpaceNormalMap <#constant>`__ (default), and `THREE.ObjectSpaceNormalMap <#constant>`__.

⭕:Vector2 normalScale
~~~~~~~~~~~~~~~~~~~~~~~

   How much the normal map affects the material. Typical ranges are 0-1. Default is a
   ``Vector2`` set to (1,1).

⭕:Float reflectivity
~~~~~~~~~~~~~~~~~~~~~~

   How much the environment map affects the surface; also see ``.combine``. The default
   value is ``1`` and the valid range is between ``0`` (no reflections) and ``1`` (full
   reflections).

⭕:Float refractionRatio
~~~~~~~~~~~~~~~~~~~~~~~~~

   The index of refraction (IOR) of air (approximately 1) divided by the index of refraction
   of the material. It is used with environment mapping modes `THREE.CubeRefractionMapping <#Textures>`__ 
   and `THREE.EquirectangularRefractionMapping <#Textures>`__.
   The refraction ratio should not exceed ``1``. Default is ``0.98``.

⭕:Float shininess
~~~~~~~~~~~~~~~~~~~

   How shiny the ``.specular`` highlight is; a higher value gives a sharper highlight.
   Default is ``30``.

⭕:Color specular
~~~~~~~~~~~~~~~~~~

   Specular color of the material. Default is a ``Color`` set to ``0x111111`` (very dark
   grey).
   This defines how shiny the material is and the color of its shine.

⭕:Texture specularMap
~~~~~~~~~~~~~~~~~~~~~~~

   The specular map value affects both how much the specular surface highlight contributes
   and how much of the environment map affects the surface. Default is null.

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is ``false`` (i.e. render as flat polygons).

⭕:String wireframeLinecap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line ends. Possible values are "butt", "round" and "square".
   Default is 'round'.
   This corresponds to the `2D Canvas lineCap` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap>`__ renderer.

⭕:String wireframeLinejoin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line joints. Possible values are "round", "bevel" and "miter".
   Default is 'round'.
   This corresponds to the `2D Canvas lineJoin` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin>`__ renderer.

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will
   always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D159:

Material → MeshStandardMaterial → MeshPhysicalMaterial
======================================================

   https://threejs.org/docs/api/en/materials/MeshPhysicalMaterial.html

   An extension of the ``MeshStandardMaterial``, providing more advanced physically-based
   rendering properties:

   -  **Anisotropy:** Ability to represent the anisotropic property of materials as
      observable with brushed metals.
   -  **Clearcoat:** Some materials — like car paints, carbon fiber, and wet surfaces —
      require a clear, reflective layer on top of another layer that may be irregular or
      rough. Clearcoat approximates this effect, without the need for a separate transparent
      surface.
   -  **Iridescence:** Allows to render the effect where hue varies depending on the viewing
      angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
      wings of many insects.
   -  **Physically-based transparency:** One limitation of `.opacity <#Material.opacity>`__
      is that highly transparent materials are less reflective. Physically-based
      ``.transmission`` provides a more realistic option for thin, transparent surfaces
      like glass.
   -  **Advanced reflectivity:** More flexible reflectivity for non-metallic materials.
   -  **Sheen:** Can be used for representing cloth and fabric materials.

   As a result of these complex shading features, MeshPhysicalMaterial has a higher
   performance cost, per pixel, than other three.js materials. Most effects are disabled by
   default, and add cost as they are enabled. For best results, always specify an
   `environment map <#.envMap>`__ when using this material.

   **Examples**

   [example:webgl_loader_gltf_anisotropy loader / gltf / anisotropy]
   [example:webgl_materials_physical_clearcoat materials / physical / clearcoat]
   [example:webgl_loader_gltf_iridescence loader / gltf / iridescence]
   [example:webgl_loader_gltf_sheen loader / gltf / sheen]
   [example:webgl_materials_physical_transmission materials / physical / transmission]

   .. Constructor

🐣:MeshPhysicalMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material`` and ``MeshStandardMaterial``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` and ``MeshStandardMaterial`` classes for common
   properties.

⭕:Float anisotropy
~~~~~~~~~~~~~~~~~~~~

   The anisotropy strength. Default is ``0.0``.

⭕:Texture anisotropyMap
~~~~~~~~~~~~~~~~~~~~~~~~~

   Red and green channels represent the anisotropy direction in ``[-1, 1]`` tangent,
   bitangent space, to be rotated by ``.anisotropyRotation``. The blue channel contains
   strength as ``[0, 1]`` to be multiplied by ``.anisotropy``. Default is ``null``.

⭕:Float anisotropyRotation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the anisotropy in tangent, bitangent space, measured in radians
   counter-clockwise from the tangent. When ``.anisotropyMap`` is present, this property
   provides additional rotation to the vectors in the texture. Default is ``0.0``.

⭕:Color attenuationColor
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The color that white light turns into due to absorption when reaching the attenuation
   distance. Default is ``white`` (0xffffff).

⭕:Float attenuationDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Density of the medium given as the average distance that light travels in the medium
   before interacting with a particle. The value is given in world space units, and must be
   greater than zero. Default is ``Infinity``.

⭕:Float clearcoat
~~~~~~~~~~~~~~~~~~~

   Represents the intensity of the clear coat layer, from ``0.0`` to ``1.0``. Use clear coat
   related properties to enable multilayer materials that have a thin translucent layer over
   the base layer. Default is ``0.0``.

⭕:Texture clearcoatMap
~~~~~~~~~~~~~~~~~~~~~~~~

   The red channel of this texture is multiplied against ``.clearcoat``, for per-pixel
   control over a coating's intensity. Default is ``null``.

⭕:Texture clearcoatNormalMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Can be used to enable independent normals for the clear coat layer. Default is ``null``.

⭕:Vector2 clearcoatNormalScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much ``.clearcoatNormalMap`` affects the clear coat layer, from ``(0,0)`` to
   ``(1,1)``. Default is ``(1,1)``.

⭕:Float clearcoatRoughness
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Roughness of the clear coat layer, from ``0.0`` to ``1.0``. Default is ``0.0``.

⭕:Texture clearcoatRoughnessMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The green channel of this texture is multiplied against ``.clearcoatRoughness``, for
   per-pixel control over a coating's roughness. Default is ``null``.

⭕:Object defines
~~~~~~~~~~~~~~~~~~

   An object of the form: ``{ 'STANDARD': '', 'PHYSICAL': '', };`` This is used by the
   ``WebGLRenderer`` for selecting shaders.

⭕:Float dispersion
~~~~~~~~~~~~~~~~~~~~

   Defines the strength of the angular separation of colors (chromatic aberration)
   transmitting through a relatively clear volume. Any value zero or larger is valid, the
   typical range of realistic values is ``[0, 1]``. Default is ``0`` (no dispersion). This
   property can be only be used with transmissive objects, see ``.transmission``.

⭕:Float ior
~~~~~~~~~~~~~

   Index-of-refraction for non-metallic materials, from ``1.0`` to ``2.333``.
   Default is ``1.5``.

⭕:Float reflectivity
~~~~~~~~~~~~~~~~~~~~~~

   Degree of reflectivity, from ``0.0`` to ``1.0``. Default is ``0.5``, which corresponds
   to an index-of-refraction of 1.5.
   This models the reflectivity of non-metallic materials. It has no effect when
   `metalness <#MeshStandardMaterial.metalness>`__ is ``1.0``

⭕:Float iridescence
~~~~~~~~~~~~~~~~~~~~~

   The intensity of the `iridescence <https://en.wikipedia.org/wiki/Iridescence>`__ layer,
   simulating RGB color shift based on the angle between the surface and the viewer, from
   ``0.0`` to ``1.0``. Default is ``0.0``.

⭕:Texture iridescenceMap
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The red channel of this texture is multiplied against ``.iridescence``, for per-pixel
   control over iridescence. Default is ``null``.

⭕:Float iridescenceIOR
~~~~~~~~~~~~~~~~~~~~~~~~

   Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
   Between ``1.0`` to ``2.333``. Default is ``1.3``.

⭕:Array iridescenceThicknessRange
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence
   layer. Thickness of iridescence layer has an equivalent effect of the one
   ``.thickness`` has on ``.ior``. Default is ``[100, 400]``.
   If ``.iridescenceThicknessMap`` is not defined, iridescence thickness will use only
   the second element of the given array.

⭕:Texture iridescenceThicknessMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A texture that defines the thickness of the iridescence layer, stored in the green
   channel. Minimum and maximum values of thickness are defined by
   ``.iridescenceThicknessRange`` array:

   -  ``0.0`` in the green channel will result in thickness equal to first element of the
      array.
   -  ``1.0`` in the green channel will result in thickness equal to second element of the
      array.
   -  Values in-between will linearly interpolate between the elements of the array.

   Default is ``null``.

⭕:Float sheen
~~~~~~~~~~~~~~~

   The intensity of the sheen layer, from ``0.0`` to ``1.0``. Default is ``0.0``.

⭕:Float sheenRoughness
~~~~~~~~~~~~~~~~~~~~~~~~

   Roughness of the sheen layer, from ``0.0`` to ``1.0``. Default is ``1.0``.

⭕:Texture sheenRoughnessMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The alpha channel of this texture is multiplied against ``.sheenRoughness``, for
   per-pixel control over sheen roughness. Default is ``null``.

⭕:Color sheenColor
~~~~~~~~~~~~~~~~~~~~

   The sheen tint. Default is ``0x000000``, black.

⭕:Texture sheenColorMap
~~~~~~~~~~~~~~~~~~~~~~~~~

   The RGB channels of this texture are multiplied against ``.sheenColor``, for per-pixel
   control over sheen tint. Default is ``null``.

⭕:Float specularIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A float that scales the amount of specular reflection for non-metals only. When set to
   zero, the model is effectively Lambertian. From ``0.0`` to ``1.0``. Default is ``1.0``.

⭕:Texture specularIntensityMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The alpha channel of this texture is multiplied against ``.specularIntensity``, for
   per-pixel control over specular intensity. Default is ``null``.

⭕:Color specularColor
~~~~~~~~~~~~~~~~~~~~~~~

   A ``Color`` that tints the specular reflection at normal incidence for non-metals only.
   Default is ``0xffffff``, white.

⭕:Texture specularColorMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The RGB channels of this texture are multiplied against ``.specularColor``, for
   per-pixel control over specular color. Default is ``null``.

⭕:Float thickness
~~~~~~~~~~~~~~~~~~~

   The thickness of the volume beneath the surface. The value is given in the coordinate
   space of the mesh. If the value is ``0`` the material is thin-walled. Otherwise the
   material is a volume boundary. Default is ``0``.

⭕:Texture thicknessMap
~~~~~~~~~~~~~~~~~~~~~~~~

   A texture that defines the thickness, stored in the green channel. This will be multiplied
   by ``.thickness``. Default is ``null``.

⭕:Float transmission
~~~~~~~~~~~~~~~~~~~~~~

   Degree of transmission (or optical transparency), from ``0.0`` to ``1.0``.
   Default is ``0.0``.
   Thin, transparent or semitransparent, plastic or glass materials remain largely
   reflective even if they are fully transmissive. The transmission property can be used to
   model these materials.
   When transmission is non-zero, `opacity <#Material.opacity>`__ should be set to ``1``.

⭕:Texture transmissionMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The red channel of this texture is multiplied against ``.transmission``, for per-pixel
   control over optical transparency. Default is ``null``.

Methods
-------

   See the base ``Material`` and ``MeshStandardMaterial`` classes for common methods.



.. _D160:

Material → MeshStandardMaterial
===============================

   https://threejs.org/docs/api/en/materials/MeshStandardMaterial.html

   A standard physically based material, using Metallic-Roughness workflow.
   Physically based rendering (PBR) has recently become the standard in many 3D
   applications, such as
   `Unity <https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/>`__,
   `Unreal <https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/>`__ and
   `3D Studio Max <http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017>`__.
   This approach differs from older approaches in that instead of using approximations for
   the way in which light interacts with a surface, a physically correct model is used. The
   idea is that, instead of tweaking materials to look good under specific lighting, a
   material can be created that will react 'correctly' under all lighting scenarios.
   In practice this gives a more accurate and realistic looking result than the
   ``MeshLambertMaterial`` or ``MeshPhongMaterial``, at the cost of being somewhat
   more computationally expensive. ``MeshPhysicalMaterial`` uses per-fragment shading.
   Note that for best results you should always specify an `environment map <#.envMap>`__
   when using this material.
   For a non-technical introduction to the concept of PBR and how to set up a PBR material,
   check out these articles by the people at `marmoset <https://www.marmoset.co>`__:

   -  `Basic Theory of Physically Based Rendering <https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/>`__
   -  `Physically Based Rendering and You Can Too <https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/>`__

   Technical details of the approach used in three.js (and most other PBR systems) can be
   found is this `paper from Disney <https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf>`__ 
   (pdf), by Brent Burley.

   .. Constructor

🐣:MeshStandardMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture aoMap
~~~~~~~~~~~~~~~~~

   The red channel of this texture is used as the ambient occlusion map. Default is null. The
   aoMap requires a second set of UVs.

⭕:Float aoMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the ambient occlusion effect. Default is ``1``. Zero is no occlusion effect.

⭕:Texture bumpMap
~~~~~~~~~~~~~~~~~~~

   The texture to create a bump map. The black and white values map to the perceived depth in
   relation to the lights. Bump doesn't actually affect the geometry of the object, only the
   lighting. If a normal map is defined this will be ignored.

⭕:Float bumpScale
~~~~~~~~~~~~~~~~~~~

   How much the bump map affects the material. Typical ranges are 0-1. Default is ``1``.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Object defines
~~~~~~~~~~~~~~~~~~

   An object of the form: ``{ 'STANDARD': '' };`` This is used by the ``WebGLRenderer``
   for selecting shaders.

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Color emissive
~~~~~~~~~~~~~~~~~~

   Emissive (light) color of the material, essentially a solid color unaffected by other
   lighting. Default is black.

⭕:Texture emissiveMap
~~~~~~~~~~~~~~~~~~~~~~~

   Set emissive (glow) map. Default is null. The emissive map color is modulated by the
   emissive color and the emissive intensity. If you have an emissive map, be sure to set the
   emissive color to something other than black.

⭕:Float emissiveIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the emissive light. Modulates the emissive color. Default is 1.

⭕:Texture envMap
~~~~~~~~~~~~~~~~~~

   The environment map. To ensure a physically correct rendering, you should only add
   environment maps which were preprocessed by ``PMREMGenerator``. Default is null.

⭕:Euler envMapRotation
~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the environment map in radians. Default is ``(0,0,0)``.

⭕:Float envMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~

   Scales the effect of the environment map by multiplying its color.

⭕:Boolean flatShading
~~~~~~~~~~~~~~~~~~~~~~~

   Define whether the material is rendered with flat shading. Default is false.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Boolean isMeshStandardMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``MeshStandardMaterial``.

⭕:Texture lightMap
~~~~~~~~~~~~~~~~~~~~

   The light map. Default is null. The lightMap requires a second set of UVs.

⭕:Float lightMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the baked light. Default is ``1``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null. The texture map color is modulated by the diffuse ``.color``.

⭕:Float metalness
~~~~~~~~~~~~~~~~~~~

   How much the material is like a metal. Non-metallic materials such as wood or stone use
   ``0.0``, metallic use ``1.0``, with nothing (usually) in between. Default is ``0.0``. A
   value between ``0.0`` and ``1.0`` could be used for a rusty metal look. If metalnessMap is
   also provided, both values are multiplied.

⭕:Texture metalnessMap
~~~~~~~~~~~~~~~~~~~~~~~~

   The blue channel of this texture is used to alter the metalness of the material.

⭕:Texture normalMap
~~~~~~~~~~~~~~~~~~~~~

   The texture to create a normal map. The RGB values affect the surface normal for each
   pixel fragment and change the way the color is lit. Normal maps do not change the actual
   shape of the surface, only the lighting. In case the material has a normal map authored
   using the left handed convention, the y component of normalScale should be negated to
   compensate for the different handedness.

⭕:Integer normalMapType
~~~~~~~~~~~~~~~~~~~~~~~~~

   The type of normal map.
   Options are `THREE.TangentSpaceNormalMap <#constant>`__ (default), and `THREE.ObjectSpaceNormalMap <#constant>`__.

⭕:Vector2 normalScale
~~~~~~~~~~~~~~~~~~~~~~~

   How much the normal map affects the material. Typical ranges are 0-1. Default is a
   ``Vector2`` set to (1,1).

⭕:Float roughness
~~~~~~~~~~~~~~~~~~~

   How rough the material appears. ``0.0`` means a smooth mirror reflection, ``1.0`` means
   fully diffuse. Default is ``1.0``. If roughnessMap is also provided, both values are
   multiplied.

⭕:Texture roughnessMap
~~~~~~~~~~~~~~~~~~~~~~~~

   The green channel of this texture is used to alter the roughness of the material.

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is ``false`` (i.e. render as flat polygons).

⭕:String wireframeLinecap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line ends. Possible values are "butt", "round" and "square".
   Default is 'round'.
   This corresponds to the `2D Canvas lineCap` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap>`__ renderer.

⭕:String wireframeLinejoin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line joints. Possible values are "round", "bevel" and "miter".
   Default is 'round'.
   This corresponds to the `2D Canvas lineJoin` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin>`__ renderer.

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will
   always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D161:

Material → MeshToonMaterial
===========================

   https://threejs.org/docs/api/en/materials/MeshToonMaterial.html

   .. container:: desc

      A material implementing toon shading.

   **Examples**

   [example:webgl_materials_toon materials / toon]

   .. Constructor

🐣:MeshToonMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Texture aoMap
~~~~~~~~~~~~~~~~~

   The red channel of this texture is used as the ambient occlusion map. Default is null. The
   aoMap requires a second set of UVs.

⭕:Float aoMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the ambient occlusion effect. Default is ``1``. Zero is no occlusion effect.

⭕:Texture bumpMap
~~~~~~~~~~~~~~~~~~~

   The texture to create a bump map. The black and white values map to the perceived depth in
   relation to the lights. Bump doesn't actually affect the geometry of the object, only the
   lighting. If a normal map is defined this will be ignored.

⭕:Float bumpScale
~~~~~~~~~~~~~~~~~~~

   How much the bump map affects the material. Typical ranges are 0-1. Default is ``1``.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Texture displacementMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The displacement map affects the position of the mesh's vertices. Unlike other maps which
   only affect the light and shade of the material the displaced vertices can cast shadows,
   block other objects, and otherwise act as real geometry. The displacement texture is an
   image where the value of each pixel (white being the highest) is mapped against, and
   repositions, the vertices of the mesh.

⭕:Float displacementScale
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How much the displacement map affects the mesh (where black is no displacement, and white
   is maximum displacement). Without a displacement map set, this value is not applied.
   Default is ``1``.

⭕:Float displacementBias
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The offset of the displacement map's values on the mesh's vertices. Without a displacement
   map set, this value is not applied. Default is ``0``.

⭕:Color emissive
~~~~~~~~~~~~~~~~~~

   Emissive (light) color of the material, essentially a solid color unaffected by other
   lighting. Default is black.

⭕:Texture emissiveMap
~~~~~~~~~~~~~~~~~~~~~~~

   Set emissive (glow) map. Default is null. The emissive map color is modulated by the
   emissive color and the emissive intensity. If you have an emissive map, be sure to set the
   emissive color to something other than black.

⭕:Float emissiveIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the emissive light. Modulates the emissive color. Default is 1.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Texture gradientMap
~~~~~~~~~~~~~~~~~~~~~~~

   Gradient map for toon shading. It's required to set ``Texture.minFilter`` and
   ``Texture.magFilter`` to `THREE.NearestFilter <#Textures>`__ when using this type of
   texture. Default is ``null``.

⭕:Texture lightMap
~~~~~~~~~~~~~~~~~~~~

   The light map. Default is null. The lightMap requires a second set of UVs.

⭕:Float lightMapIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Intensity of the baked light. Default is ``1``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null. The texture map color is modulated by the diffuse ``.color``.

⭕:Texture normalMap
~~~~~~~~~~~~~~~~~~~~~

   The texture to create a normal map. The RGB values affect the surface normal for each
   pixel fragment and change the way the color is lit. Normal maps do not change the actual
   shape of the surface, only the lighting. In case the material has a normal map authored
   using the left handed convention, the y component of normalScale should be negated to
   compensate for the different handedness.

⭕:Integer normalMapType
~~~~~~~~~~~~~~~~~~~~~~~~~

   The type of normal map.
   Options are `THREE.TangentSpaceNormalMap <#constant>`__ (default), and `THREE.ObjectSpaceNormalMap <#constant>`__.

⭕:Vector2 normalScale
~~~~~~~~~~~~~~~~~~~~~~~

   How much the normal map affects the material. Typical ranges are 0-1. Default is a
   ``Vector2`` set to (1,1).

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe. Default is ``false`` (i.e. render as flat polygons).

⭕:String wireframeLinecap
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line ends. Possible values are "butt", "round" and "square".
   Default is 'round'.
   This corresponds to the `2D Canvas lineCap` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap>`__ renderer.

⭕:String wireframeLinejoin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Define appearance of line joints. Possible values are "round", "bevel" and "miter".
   Default is 'round'.
   This corresponds to the `2D Canvas lineJoin` property and it is ignored by the 
   `WebGLRenderer WebGL <https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin>`__ renderer.

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will
   always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D162:

Material → PointsMaterial
=========================

   https://threejs.org/docs/api/en/materials/PointsMaterial.html

   The default material used by ``Points``.

   **Code Example**


   .. code:: javascript

      const vertices = [];
      for ( let i = 0;
      i < 10000;
      i ++ ) { const x = THREE.MathUtils.randFloatSpread( 2000 );
      const y = THREE.MathUtils.randFloatSpread( 2000 );
      const z = THREE.MathUtils.randFloatSpread( 2000 );
      vertices.push( x, y, z );
      } const geometry = new THREE.BufferGeometry();
      geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
      const material = new THREE.PointsMaterial( { color: 0x888888 } );
      const points = new THREE.Points( geometry, material );
      scene.add( points );


   **Examples**

   [example:misc_controls_fly misc / controls / fly]
   [example:webgl_buffergeometry_drawrange WebGL / BufferGeometry / drawrange]
   [example:webgl_buffergeometry_points WebGL / BufferGeometry / points]
   [example:webgl_buffergeometry_points_interleaved WebGL / BufferGeometry / points /
   interleaved]
   [example:webgl_camera WebGL / camera ]
   [example:webgl_geometry_convex WebGL / geometry / convex]
   [example:webgl_geometry_shapes WebGL / geometry / shapes]
   [example:webgl_interactive_raycasting_points WebGL / interactive / raycasting / points]
   [example:webgl_multiple_elements_text WebGL / multiple / elements / text]
   [example:webgl_points_billboards WebGL / points / billboards]
   [example:webgl_points_dynamic WebGL / points / dynamic]
   [example:webgl_points_sprites WebGL / points / sprites]

   .. Constructor

🐣:PointsMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff).

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Texture map
~~~~~~~~~~~~~~~

   Sets the color of the points using data from a ``Texture``. May optionally include an
   alpha channel, typically combined with `.transparent <#Material.transparent>`__ or
   `.alphaTest <#Material.alphaTest>`__.

⭕:Number size
~~~~~~~~~~~~~~~

   Defines the size of the points in pixels. Default is ``1.0``.
   Will be capped if it exceeds the hardware dependent parameter
   `gl.ALIASED_POINT_SIZE_RANGE <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParameter>`__.

⭕:Boolean sizeAttenuation
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Specify whether points' size is attenuated by the camera depth. (Perspective camera only.)
   Default is true.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D163:

Material → ShaderMaterial → RawShaderMaterial
=============================================

   https://threejs.org/docs/api/en/materials/RawShaderMaterial.html

   This class works just like ``ShaderMaterial``, except that definitions of built-in
   uniforms and attributes are not automatically prepended to the GLSL shader code.

   **Code Example**


   .. code:: javascript

      const material = new THREE.RawShaderMaterial( { 
         uniforms: { time: { value: 1.0 } },
         vertexShader: document.getElementById( 'vertexShader' ).textContent,
         fragmentShader: document.getElementById( 'fragmentShader' ).textContent, 
      } );


   **Examples**

   [example:webgl_buffergeometry_rawshader WebGL / buffergeometry / rawshader]
   [example:webgl_buffergeometry_instancing_billboards WebGL / buffergeometry / instancing
   / billboards]
   [example:webgl_buffergeometry_instancing WebGL / buffergeometry / instancing]
   [example:webgl_raymarching_reflect WebGL / raymarching / reflect]
   [example:webgl_volume_cloud WebGL / volume / cloud]
   [example:webgl_volume_instancing WebGL / volume / instancing]
   [example:webgl_volume_perlin WebGL / volume / perlin]

   .. Constructor

🐣:RawShaderMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material`` and ``ShaderMaterial``) can be passed in here.

Properties
----------

   See the base ``Material`` and ``ShaderMaterial`` classes for common properties.

Methods
-------

   See the base ``Material`` and ``ShaderMaterial`` classes for common methods.



.. _D164:

Material → ShaderMaterial
=========================

   https://threejs.org/docs/api/en/materials/ShaderMaterial.html

   A material rendered with custom shaders. A shader is a small program written in
   `GLSL <https://www.khronos.org/files/opengles_shading_language.pdf>`__ that runs on the
   GPU. You may want to use a custom shader if you need to:

   -  implement an effect not included with any of the built-in `materials <#Material>`__
   -  combine many objects into a single ``BufferGeometry`` in order to improve
      performance

   There are the following notes to bear in mind when using a ``ShaderMaterial``:

   -  A ``ShaderMaterial`` will only be rendered properly by ``WebGLRenderer``, since the
      GLSL code in the `vertexShader <https://en.wikipedia.org/wiki/Shader#Vertex_shaders>`__ and 
      `fragmentShader <https://en.wikipedia.org/wiki/Shader#Pixel_shaders>`__ properties 
      must be compiled and run on the GPU using WebGL.
   -  As of THREE r72, directly assigning attributes in a ShaderMaterial is no longer
      supported. A ``BufferGeometry`` instance must be used instead, using
      ``BufferAttribute`` instances to define custom attributes.
   -  As of THREE r77, ``WebGLRenderTarget`` or ``WebGLCubeRenderTarget`` instances are
      no longer supposed to be used as uniforms. Their `texture <#Texture>`__ property must
      be used instead.
   -  Built in attributes and uniforms are passed to the shaders along with your code. If you
      don't want the ``WebGLProgram`` to add anything to your shader code, you can use
      ``RawShaderMaterial`` instead of this class.
   -  You can use the directive #pragma unroll_loop_start and #pragma unroll_loop_end in
      order to unroll a ``for`` loop in GLSL by the shader preprocessor. The directive has to
      be placed right above the loop. The loop formatting has to correspond to a defined
      standard.

      -  The loop has to be `normalized <https://en.wikipedia.org/wiki/Normalized_loop>`__.
      -  The loop variable has to be ``i``.
      -  The value ``UNROLLED_LOOP_INDEX`` will be replaced with the explicitly value of
         ``i`` for the given iteration and can be used in preprocessor statements.


      .. code:: javascript

         #pragma unroll_loop_start for ( int i = 0;
         i < 10;
         i ++ ) { // ... } #pragma unroll_loop_end


   **Code Example**


   .. code:: javascript

      const material = new THREE.ShaderMaterial( { 
         uniforms: { 
            time: { value: 1.0 }, 
            resolution: { value: new THREE.Vector2() } 
         }, 
         vertexShader: document.getElementById( 'vertexShader' ).textContent, 
         fragmentShader: document.getElementById( 'fragmentShader' ).textContent 
      } );


   **Examples**

   [example:webgl_buffergeometry_custom_attributes_particles webgl / buffergeometry /
   custom / attributes / particles]
   [example:webgl_buffergeometry_selective_draw webgl / buffergeometry / selective / draw]
   [example:webgl_custom_attributes webgl / custom / attributes]
   [example:webgl_custom_attributes_lines webgl / custom / attributes / lines]
   [example:webgl_custom_attributes_points webgl / custom / attributes / points]
   [example:webgl_custom_attributes_points2 webgl / custom / attributes / points2]
   [example:webgl_custom_attributes_points3 webgl / custom / attributes / points3]
   [example:webgl_depth_texture webgl / depth / texture]
   [example:webgl_gpgpu_birds webgl / gpgpu / birds]
   [example:webgl_gpgpu_protoplanet webgl / gpgpu / protoplanet]
   [example:webgl_gpgpu_water webgl / gpgpu / water]
   [example:webgl_interactive_points webgl / interactive / points]
   [example:webgl_video_kinect webgl / video / kinect]
   [example:webgl_lights_hemisphere webgl / lights / hemisphere]
   [example:webgl_marchingcubes webgl / marchingcubes]
   [example:webgl_materials_envmaps webgl / materials / envmaps]
   [example:webgl_materials_wireframe webgl / materials / wireframe]
   [example:webgl_modifier_tessellation webgl / modifier / tessellation]
   [example:webgl_postprocessing_dof2 webgl / postprocessing / dof2]
   [example:webgl_postprocessing_godrays webgl / postprocessing / godrays]

   Vertex shaders and fragment shaders
   -----------------------------------


      You can specify two different types of shaders for each material:

      -  The vertex shader runs first; it receives ``attributes``, calculates / manipulates
         the position of each individual vertex, and passes additional data (\`varying`s) to
         the fragment shader.
      -  The fragment ( or pixel ) shader runs second; it sets the color of each individual
         "fragment" (pixel) rendered to the screen.

      There are three types of variables in shaders: uniforms, attributes, and varyings:

      -  ``Uniforms`` are variables that have the same value for all vertices - lighting,
         fog, and shadow maps are examples of data that would be stored in uniforms. Uniforms
         can be accessed by both the vertex shader and the fragment shader.
      -  ``Attributes`` are variables associated with each vertex---for instance, the vertex
         position, face normal, and vertex color are all examples of data that would be
         stored in attributes. Attributes can ``only`` be accessed within the vertex shader.
      -  ``Varyings`` are variables that are passed from the vertex shader to the fragment
         shader. For each fragment, the value of each varying will be smoothly interpolated
         from the values of adjacent vertices.

      Note that ``within`` the shader itself, uniforms and attributes act like constants; you
      can only modify their values by passing different values to the buffers from your
      JavaScript code.

   Built-in attributes and uniforms
   --------------------------------


      The ``WebGLRenderer`` provides many attributes and uniforms to shaders by default;
      definitions of these variables are prepended to your ``fragmentShader`` and
      ``vertexShader`` code by the ``WebGLProgram`` when the shader is compiled; you don't
      need to declare them yourself. See ``WebGLProgram`` for details of these variables.

      Some of these uniforms or attributes (e.g. those pertaining lighting, fog, etc.)
      require properties to be set on the material in order for ``WebGLRenderer`` to copy
      the appropriate values to the GPU - make sure to set these flags if you want to use
      these features in your own shader.

      If you don't want ``WebGLProgram`` to add anything to your shader code, you can use
      ``RawShaderMaterial`` instead of this class.

   Custom attributes and uniforms
   ------------------------------


      Both custom attributes and uniforms must be declared in your GLSL shader code (within
      ``vertexShader`` and/or ``fragmentShader``). Custom uniforms must be defined in
      ``both`` the ``uniforms`` property of your ``ShaderMaterial``, whereas any custom
      attributes must be defined via ``BufferAttribute`` instances. Note that \`varying`s
      only need to be declared within the shader code (not within the material).

      To declare a custom attribute, please reference the ``BufferGeometry`` page for an
      overview, and the ``BufferAttribute`` page for a detailed look at the
      ``BufferAttribute`` API.

      When creating your attributes, each typed array that you create to hold your
      attribute's data must be a multiple of your data type's size. For example, if your
      attribute is a `THREE.Vector3 <#Vector3>`__ type, and you have 3000 vertices in your
      ``BufferGeometry``, your typed array value must be created with a length of 3000 ``
      3, or 9000 (one value per-component). A table of each data type's size is shown below
      for reference:

      .. table:: Attribute sizes

         ========= ============================ ====
         GLSL type JavaScript type              Size
         ========= ============================ ====
         float     ``Number``                1
         vec2      `THREE.Vector2 <#Vector2>`__ 2
         vec3      `THREE.Vector3 <#Vector3>`__ 3
         vec3      `THREE.Color <#Color>`__     3
         vec4      `THREE.Vector4 <#Vector4>`__ 4
         ========= ============================ ====

      Note that attribute buffers are ``not`` refreshed automatically when their values
      change. To update custom attributes, set the ``needsUpdate`` flag to true on the
      ``BufferAttribute`` of the geometry (see ``BufferGeometry`` for further details).

      To declare a custom ``Uniform``, use the ``uniforms`` property:

      .. code:: javascript

         uniforms: { time: { value: 1.0 }, resolution: { value: new THREE.Vector2() } }


      You're recommended to update custom ``Uniform`` values depending on `object <#Object3D>`__ 
      and `camera <#Camera>`__ in ``Object3D.onBeforeRender`` because
      ``Material`` can be shared among `meshes <#Mesh>`__, `matrixWorld <#Matrix4>`__ of
      ``Scene`` and ``Camera`` are updated in ``WebGLRenderer.render``, and some
      effects render a `scene <#Scene>`__ with their own private `cameras <#Camera>`__.

   .. Constructor

🐣:ShaderMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited from
   ``Material``) can be passed in here.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Boolean clipping
~~~~~~~~~~~~~~~~~~~~

   Defines whether this material supports clipping; true to let the renderer pass the
   clippingPlanes uniform. Default is false.

⭕:Object defaultAttributeValues
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When the rendered geometry doesn't include these attributes but the material does, these
   default values will be passed to the shaders. This avoids errors when buffer data is
   missing.

   .. code:: javascript

      this.defaultAttributeValues = { 'color': [ 1, 1, 1 ], 'uv': [ 0, 0 ], 'uv1': [ 0, 0 ] };


⭕:Object defines
~~~~~~~~~~~~~~~~~~

   Defines custom constants using ``#define`` directives within the GLSL code for both the
   vertex shader and the fragment shader; each key/value pair yields another directive:

   .. code:: javascript

      defines: { FOO: 15, BAR: true }


   yields the lines

   .. code:: javascript
   
      #define FOO 15 #define BAR true

   in the GLSL code.

⭕:Object extensions
~~~~~~~~~~~~~~~~~~~~~

   An object with the following properties:

   .. code:: javascript

      this.extensions = { 
         clipCullDistance: false, // set to use vertex shader 
         clipping multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID 
      };


⭕:Boolean fog
~~~~~~~~~~~~~~~

   Define whether the material color is affected by global fog settings; true to pass fog
   uniforms to the shader. Default is false.

⭕:String fragmentShader
~~~~~~~~~~~~~~~~~~~~~~~~~

   Fragment shader GLSL code. This is the actual code for the shader. In the example above,
   the ``vertexShader`` and ``fragmentShader`` code is extracted from the DOM; it could be
   passed as a string directly or loaded via AJAX instead.

⭕:String glslVersion
~~~~~~~~~~~~~~~~~~~~~~

   Defines the GLSL version of custom shader code. Valid values are ``THREE.GLSL1`` or
   ``THREE.GLSL3``. Default is ``null``.

⭕:String index0AttributeName
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If set, this calls
   `gl.bindAttribLocation <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation>`__ 
   to bind a generic vertex index to an attribute variable. Default is
   undefined.

⭕:Boolean isShaderMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``ShaderMaterial``.

⭕:Boolean lights
~~~~~~~~~~~~~~~~~~

   Defines whether this material uses lighting; true to pass uniform data related to lighting
   to this shader. Default is false.

⭕:Float linewidth
~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will
   always be ``1`` regardless of the set value.

⭕:Boolean flatShading
~~~~~~~~~~~~~~~~~~~~~~~

   Define whether the material is rendered with flat shading. Default is false.

⭕:Object uniforms
~~~~~~~~~~~~~~~~~~~

   An object of the form: ``{ "uniform1": { value: 1.0 }, "uniform2": { value: 2 } }``
   specifying the uniforms to be passed to the shader code; keys are uniform names, values
   are definitions of the form ``{ value: 1.0 }`` where ``value`` is the value of the
   uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that
   uniforms are refreshed on every frame, so updating the value of the uniform will
   immediately update the value available to the GLSL code.

⭕:Boolean uniformsNeedUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Can be used to force a uniform update while changing uniforms in
   ``Object3D.onBeforeRender``(). Default is ``false``.

⭕:Boolean vertexColors
~~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether vertex coloring is used. Default is ``false``.

⭕:String vertexShader
~~~~~~~~~~~~~~~~~~~~~~~

   Vertex shader GLSL code. This is the actual code for the shader. In the example above, the
   ``vertexShader`` and ``fragmentShader`` code is extracted from the DOM; it could be passed
   as a string directly or loaded via AJAX instead.

⭕:Boolean wireframe
~~~~~~~~~~~~~~~~~~~~~

   Render geometry as wireframe (using GL_LINES instead of GL_TRIANGLES). Default is false
   (i.e. render as flat polygons).

⭕:Float wireframeLinewidth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Controls wireframe thickness. Default is ``1``.
   Due to limitations of the `OpenGL Core Profile` with the 
   `WebGLRenderer WebGL <https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf>`__ 
   renderer on most platforms linewidth will
   always be ``1`` regardless of the set value.

Methods
-------

   See the base ``Material`` class for common methods.

📦:clone() ShaderMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Generates a shallow copy of this material. Note that the vertexShader and fragmentShader
   are copied ``by reference``, as are the definitions of the ``attributes``; this means that
   clones of the material will share the same compiled ``WebGLProgram``. However, the
   ``uniforms`` are copied ``by value``, which allows you to have different sets of uniforms
   for different copies of the material.



.. _D165:

Material → ShadowMaterial
=========================

   https://threejs.org/docs/api/en/materials/ShadowMaterial.html

   This material can receive shadows, but otherwise is completely transparent.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.PlaneGeometry( 2000, 2000 );
      geometry.rotateX( - Math.PI / 2 );
      const material = new THREE.ShadowMaterial();
      material.opacity = 0.2;
      const plane = new THREE.Mesh( geometry, material );
      plane.position.y = -200;
      plane.receiveShadow = true;
      scene.add( plane );


   **Examples**

   [example:webgl_geometry_spline_editor geometry / spline / editor]

   .. Constructor

🐣:ShadowMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.

Properties
----------

   See the base ``Material`` classes for common properties.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to black (0x000000).

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Boolean transparent
~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether this material is transparent. Default is ``true``.

Methods
-------

   See the base ``Material`` classes for common methods.



.. _D166:

Material → SpriteMaterial
=========================

   https://threejs.org/docs/api/en/materials/SpriteMaterial.html

   A material for a use with a ``Sprite``.

   **Code Example**


   .. code:: javascript

      const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
      const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );
      const sprite = new THREE.Sprite( material );
      sprite.scale.set(200, 200, 1) scene.add( sprite );


   **Examples**

   [example:webgl_raycaster_sprite WebGL / raycast / sprite]
   [example:webgl_sprites WebGL / sprites]
   [example:svg_sandbox SVG / sandbox]

   .. Constructor

🐣:SpriteMaterial( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `parameters <#Object>`__ - (optional) an object with one or more properties defining the
   material's appearance. Any property of the material (including any property inherited
   from ``Material``) can be passed in here.
   The exception is the property `color <#Hexadecimal>`__, which can be passed in as a
   hexadecimal string and is ``0xffffff`` (white) by default. ``Color.set``( color ) is
   called internally. SpriteMaterials are not clipped by using
   ``Material.clippingPlanes``.

Properties
----------

   See the base ``Material`` class for common properties.

⭕:Texture alphaMap
~~~~~~~~~~~~~~~~~~~~

   The alpha map is a grayscale texture that controls the opacity across the surface
   (black: fully transparent; white: fully opaque). Default is null.
   Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB
   and RGBA textures, the `WebGL <#WebGLRenderer>`__ renderer will use the green channel
   when sampling this texture due to the extra bit of precision provided for green in
   DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha
   textures will also still work as expected.

⭕:Color color
~~~~~~~~~~~~~~~

   ``Color`` of the material, by default set to white (0xffffff). The ``.map`` is
   multiplied by the color.

⭕:Boolean fog
~~~~~~~~~~~~~~~

   Whether the material is affected by fog. Default is ``true``.

⭕:Boolean isSpriteMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``SpriteMaterial``.

⭕:Texture map
~~~~~~~~~~~~~~~

   The color map. May optionally include an alpha channel, typically combined with
   `.transparent <#Material.transparent>`__ or `.alphaTest <#Material.alphaTest>`__.
   Default is null.

⭕:Radians rotation
~~~~~~~~~~~~~~~~~~~~

   The rotation of the sprite in radians. Default is ``0``.

⭕:Boolean sizeAttenuation
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether the size of the sprite is attenuated by the camera depth. (Perspective camera
   only.) Default is ``true``.

⭕:Boolean transparent
~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether this material is transparent. Default is ``true``.

Methods
-------

   See the base ``Material`` class for common methods.



.. _D167:

Box2
====

   https://threejs.org/docs/api/en/math/Box2.html

   Represents an axis-aligned bounding box (AABB) in 2D space.

   .. Constructor

🐣:Box2( Vector2 min, Vector2 max )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector2>`__ - (optional) ``Vector2`` representing the lower (x, y) boundary of
   the box. Default is ( + Infinity, + Infinity ).
   `max <#Vector2>`__ - (optional) ``Vector2`` representing the upper (x, y) boundary of
   the box. Default is ( - Infinity, - Infinity ).
   Creates a ``Box2`` bounded by min and max.

Properties
----------

⭕:Vector2 min
~~~~~~~~~~~~~~~

   ``Vector2`` representing the lower (x, y) boundary of the box.
   Default is ( + Infinity, + Infinity ).

⭕:Vector2 max
~~~~~~~~~~~~~~~

   ``Vector2`` representing the lower upper (x, y) boundary of the box.
   Default is ( - Infinity, - Infinity ).

Methods
-------

📦:clampPoint( Vector2 point, Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector2>`__ - ``Vector2`` to clamp.
   `target <#Vector2>`__ — the result will be copied into this Vector2.
   `Clamps <https://en.wikipedia.org/wiki/Clamping_(graphics)>`__ the `point <#Vector2>`__ 
   within the bounds of this box.

📦:clone() Box2
~~~~~~~~~~~~~~~~

   Returns a new ``Box2`` with the same ``min`` and ``max`` as this one.

📦:containsBox( Box2 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box2>`__ - `Box2 <#Box2>`__ to test for inclusion.
   Returns true if this box includes the entirety of `box <#Box2>`__. If this and
   `box <#Box2>`__ are identical,
   this function also returns true.

📦:containsPoint( Vector2 point ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector2>`__ - ``Vector2`` to check for inclusion.
   Returns true if the specified `point <#Vector2>`__ lies within or on the boundaries of
   this box.

📦:copy( Box2 box ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the ``min`` and ``max`` from `box <#Box2>`__ to this box.

📦:distanceToPoint( Vector2 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector2>`__ - ``Vector2`` to measure distance to.
   Returns the distance from any edge of this box to the specified point. If the
   `point <#Vector2>`__ lies inside of this box, the distance will be ``0``.

📦:equals( Box2 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box2>`__ - Box to compare with this one.
   Returns true if this box and `box <#Box2>`__ share the same lower and upper bounds.

📦:expandByPoint( Vector2 point ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector2>`__ - ``Vector2`` that should be included in the box.
   Expands the boundaries of this box to include `point <#Vector2>`__.

📦:expandByScalar( Float scalar ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scalar <#Float>`__ - Distance to expand the box by.
   Expands each dimension of the box by `scalar <#Float>`__. If negative, the dimensions of
   the box will be contracted.

📦:expandByVector( Vector2 vector ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vector <#Vector2>`__ - ``Vector2`` to expand the box by.
   Expands this box equilaterally by `vector <#Vector2>`__. The width of this box will be
   expanded by the x component of `vector <#Vector2>`__ in both directions. The height of
   this box will be expanded by the y component of `vector <#Vector2>`__ in both
   directions.

📦:getCenter( Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector2>`__ — the result will be copied into this Vector2.
   Returns the center point of the box as a ``Vector2``.

📦:getParameter( Vector2 point, Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector2>`__ - ``Vector2``.
   `target <#Vector2>`__ — the result will be copied into this Vector2.
   Returns a point as a proportion of this box's width and height.

📦:getSize( Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector2>`__ — the result will be copied into this Vector2.
   Returns the width and height of this box.

📦:intersect( Box2 box ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box2>`__ - Box to intersect with.
   Returns the intersection of this and `box <#Box2>`__, setting the upper bound of this
   box to the lesser of the two boxes' upper bounds and the lower bound of this box to the
   greater of the two boxes' lower bounds.

📦:intersectsBox( Box2 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box2>`__ - Box to check for intersection against.
   Determines whether or not this box intersects `box <#Box2>`__.

📦:isEmpty() Boolean
~~~~~~~~~~~~~~~~~~~~~

   Returns true if this box includes zero points within its bounds.
   Note that a box with equal lower and upper bounds still includes one point, the one both
   bounds share.

📦:makeEmpty() this
~~~~~~~~~~~~~~~~~~~~

   Makes this box empty.

📦:set( Vector2 min, Vector2 max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector2>`__ - (required ) ``Vector2`` representing the lower (x, y) boundary
   of the box.
   `max <#Vector2>`__ - (required) ``Vector2`` representing the upper (x, y) boundary of
   the box.
   Sets the lower and upper (x, y) boundaries of this box.
   Please note that this method only copies the values from the given objects.

📦:setFromCenterAndSize( Vector2 center, Vector2 size ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector2>`__ - Desired center position of the box (``Vector2``).
   `size <#Vector2>`__ - Desired x and y dimensions of the box (``Vector2``).
   Centers this box on `center <#Vector2>`__ and sets this box's width and height to the
   values specified in `size <#Vector2>`__.

📦:setFromPoints( Array points ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `points <#Array>`__ - Array of `Vector2s <#Vector2>`__ that the resulting box will
   contain.
   Sets the upper and lower bounds of this box to include all of the points in `points <#Array>`__.

📦:translate( Vector2 offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `offset <#Vector2>`__ - Direction and distance of offset.
   Adds `offset <#Vector2>`__ to both the upper and lower bounds of this box, effectively
   moving this box `offset <#Vector2>`__ units in 2D space.

📦:union( Box2 box ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box2>`__ - Box that will be unioned with this box.
   Unions this box with `box <#Box2>`__, setting the upper bound of this box to the greater
   of the two boxes' upper bounds and the lower bound of this box to the lesser of the two
   boxes' lower bounds.



.. _D168:

Box3
====

   https://threejs.org/docs/api/en/math/Box3.html

   Represents an axis-aligned bounding box (AABB) in 3D space.

   **Code Example**


   .. code:: javascript

      const box = new THREE.Box3();

      const mesh = new THREE.Mesh(
         new THREE.SphereGeometry(),
         new THREE.MeshBasicMaterial()
      );

      // ensure the bounding box is computed for its geometry
      // this should be done only once (assuming static geometries)
      mesh.geometry.computeBoundingBox();

      // ...

      // in the animation loop, compute the current bounding box with the world matrix
      box.copy( mesh.geometry.boundingBox ).applyMatrix4( mesh.matrixWorld );


   .. Constructor

🐣:Box3( Vector3 min, Vector3 max )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector3>`__ - (optional) ``Vector3`` representing the lower (x, y, z) boundary
   of the box. Default is ( + Infinity, + Infinity, + Infinity ).
   `max <#Vector3>`__ - (optional) ``Vector3`` representing the upper (x, y, z) boundary
   of the box. Default is ( - Infinity, - Infinity, - Infinity ).
   Creates a ``Box3`` bounded by min and max.

Properties
----------

⭕:Boolean isBox3
~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Box3``.

⭕:Vector3 min
~~~~~~~~~~~~~~~

   ``Vector3`` representing the lower (x, y, z) boundary of the box.
   Default is ( + Infinity, + Infinity, + Infinity ).

⭕:Vector3 max
~~~~~~~~~~~~~~~

   ``Vector3`` representing the upper (x, y, z) boundary of the box.
   Default is ( - Infinity, - Infinity, - Infinity ).

Methods
-------

📦:applyMatrix4( Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `matrix <#Matrix4>`__ - The ``Matrix4`` to apply
   Transforms this Box3 with the supplied matrix.

📦:clampPoint( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` to clamp.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   `Clamps <https://en.wikipedia.org/wiki/Clamping_(graphics)>`__ 
   the `point <#Vector3>`__ within the bounds of this box.

📦:clone() Box3
~~~~~~~~~~~~~~~~

   Returns a new ``Box3`` with the same ``min`` and ``max`` as this one.

📦:containsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - `Box3 <#Box3>`__ to test for inclusion.
   Returns true if this box includes the entirety of `box <#Box3>`__. If this and
   `box <#Box3>`__ are identical,
   this function also returns true.

📦:containsPoint( Vector3 point ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` to check for inclusion.
   Returns true if the specified `point <#Vector3>`__ lies within or on the boundaries of
   this box.

📦:copy( Box3 box ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - ``Box3`` to copy.
   Copies the ``min`` and ``max`` from `box <#Box3>`__ to this box.

📦:distanceToPoint( Vector3 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` to measure distance to.
   Returns the distance from any edge of this box to the specified point. If the
   `point <#Vector3>`__ lies inside of this box, the distance will be ``0``.

📦:equals( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - Box to compare with this one.
   Returns true if this box and `box <#Box3>`__ share the same lower and upper bounds.

📦:expandByObject( Object3D object, Boolean precise ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ - ``Object3D`` to expand the box by.
   precise - (optional) expand the bounding box as little as necessary at the expense of
   more computation. Default is false.
   Expands the boundaries of this box to include `object <#Object3D>`__ and its children,
   accounting for the object's, and children's, world transforms. The function may result
   in a larger box than strictly necessary (unless the precise parameter is set to true).

📦:expandByPoint( Vector3 point ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` that should be included in the box.
   Expands the boundaries of this box to include `point <#Vector3>`__.

📦:expandByScalar( Float scalar ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scalar <#Float>`__ - Distance to expand the box by.
   Expands each dimension of the box by `scalar <#Float>`__. If negative, the dimensions of
   the box will be contracted.

📦:expandByVector( Vector3 vector ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vector <#Vector3>`__ - ``Vector3`` to expand the box by.
   Expands this box equilaterally by `vector <#Vector3>`__. The width of this box will be
   expanded by the x component of `vector <#Vector3>`__ in both directions. The height of
   this box will be expanded by the y component of `vector <#Vector3>`__ in both
   directions. The depth of this box will be expanded by the z component of ``vector`` in
   both directions.

📦:getBoundingSphere( Sphere target ) Sphere
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Sphere>`__ — the result will be copied into this Sphere.
   Gets a ``Sphere`` that bounds the box.

📦:getCenter( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the center point of the box as a ``Vector3``.

📦:getParameter( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3``.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a point as a proportion of this box's width, height and depth.

📦:getSize( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the width, height and depth of this box.

📦:intersect( Box3 box ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - Box to intersect with.
   Computes the intersection of this and `box <#Box3>`__, setting the upper bound of this
   box to the lesser of the two boxes' upper bounds and the lower bound of this box to the
   greater of the two boxes' lower bounds. If there's no overlap, makes this box empty.

📦:intersectsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - Box to check for intersection against.
   Determines whether or not this box intersects `box <#Box3>`__.

📦:intersectsPlane( Plane plane ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ - ``Plane`` to check for intersection against.
   Determines whether or not this box intersects `plane <#Plane>`__.

📦:intersectsSphere( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - ``Sphere`` to check for intersection against.
   Determines whether or not this box intersects `sphere <#Sphere>`__.

📦:intersectsTriangle( Triangle triangle ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `triangle <#Triangle>`__ - ``Triangle`` to check for intersection against.
   Determines whether or not this box intersects `triangle <#Triangle>`__.

📦:isEmpty() Boolean
~~~~~~~~~~~~~~~~~~~~~

   Returns true if this box includes zero points within its bounds.
   Note that a box with equal lower and upper bounds still includes one point, the one both
   bounds share.

📦:makeEmpty() this
~~~~~~~~~~~~~~~~~~~~

   Makes this box empty.

📦:set( Vector3 min, Vector3 max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector3>`__ - ``Vector3`` representing the lower (x, y, z) boundary of the
   box.
   `max <#Vector3>`__ - ``Vector3`` representing the upper (x, y, z) boundary of the
   box.
   Sets the lower and upper (x, y, z) boundaries of this box.
   Please note that this method only copies the values from the given objects.

📦:setFromArray( Array array ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   array -- An array of position data that the resulting box will envelop.
   Sets the upper and lower bounds of this box to include all of the data in ``array``.

📦:setFromBufferAttribute( BufferAttribute attribute ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `attribute <#BufferAttribute>`__ - A buffer attribute of position data that the
   resulting box will envelop.
   Sets the upper and lower bounds of this box to include all of the data in
   `attribute <#BufferAttribute>`__.

📦:setFromCenterAndSize( Vector3 center, Vector3 size ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector3>`__, - Desired center position of the box.
   `size <#Vector3>`__ - Desired x, y and z dimensions of the box.
   Centers this box on `center <#Vector3>`__ and sets this box's width, height and depth to
   the values specified
   in `size <#Vector3>`__

📦:setFromObject( Object3D object, Boolean precise ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ - ``Object3D`` to compute the bounding box of.
   precise - (optional) compute the smallest world-axis-aligned bounding box at the expense
   of more computation. Default is false.
   Computes the world-axis-aligned bounding box of an ``Object3D`` (including its
   children), accounting for the object's, and children's, world transforms. The function
   may result in a larger box than strictly necessary.

📦:setFromPoints( Array points ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `points <#Array>`__ - Array of `Vector3s <#Vector3>`__ that the resulting box will
   contain.
   Sets the upper and lower bounds of this box to include all of the points in `points <#Array>`__.

📦:translate( Vector3 offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `offset <#Vector3>`__ - Direction and distance of offset.
   Adds `offset <#Vector3>`__ to both the upper and lower bounds of this box, effectively
   moving this box `offset <#Vector3>`__ units in 3D space.

📦:union( Box3 box ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - Box that will be unioned with this box.
   Computes the union of this box and `box <#Box3>`__, setting the upper bound of this box
   to the greater of the two boxes' upper bounds and the lower bound of this box to the
   lesser of the two boxes' lower bounds.



.. _D169:

Color
=====

   https://threejs.org/docs/api/en/math/Color.html

   Class representing a color.

   Iterating through a ``Box3`` instance will yield its components (r, g, b) in the
   corresponding order.

   Code Examples
   -------------

   A Color can be initialised in any of the following ways:


   .. code:: javascript

      //empty constructor - will default white
      const color1 = new THREE.Color();

      //Hexadecimal color (recommended)
      const color2 = new THREE.Color( 0xff0000 );

      //RGB string
      const color3 = new THREE.Color("rgb(255, 0, 0)");
      const color4 = new THREE.Color("rgb(100%, 0%, 0%)");

      //X11 color name - all 140 color names are supported.
      //Note the lack of CamelCase in the name
      const color5 = new THREE.Color( 'skyblue' );

      //HSL string
      const color6 = new THREE.Color("hsl(0, 100%, 50%)");

      //Separate RGB values between 0 and 1
      const color7 = new THREE.Color( 1, 0, 0 );



   .. Constructor

🐣:Color( Color_Hex_or_String r, Float g, Float b )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `r <#Color_Hex_or_String>`__ - (optional) If arguments `g <#Float>`__ and `b <#Float>`__
   are defined, the red component of the color. If they are not defined, it can be a
   `hexadecimal triplet <https://en.wikipedia.org/wiki/Web_colors#Hex_triplet>`__
   (recommended), a CSS-style string, or another ``Color`` instance.
   `g <#Float>`__ - (optional) If it is defined, the green component of the color.
   `b <#Float>`__ - (optional) If it is defined, the blue component of the color.
   Note that standard method of specifying color in three.js is with a
   `hexadecimal triplet <https://en.wikipedia.org/wiki/Web_colors#Hex_triplet>`__, and
   that method is used throughout the rest of the documentation.
   When all arguments are defined then `r <#Color_Hex_or_String>`__ is the red component,
   `g <#Float>`__ is the green component and `b <#Float>`__ is the blue component of the
   color.
   When only `r <#Color_Hex_or_String>`__ is defined:

   -  It can be a `hexadecimal triplet <https://en.wikipedia.org/wiki/Web_colors#Hex_triplet>`__ 
      representing the color (recommended).
   -  It can be an another Color instance.
   -  It can be a CSS-style string. For example:

      -  'rgb(250, 0,0)'
      -  'rgb(100%,0%,0%)'
      -  'hsl(0, 100%, 50%)'
      -  '#ff0000'
      -  '#f00'
      -  'red'

Properties
----------

⭕:Boolean isColor
~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Color``.

⭕:Float r
~~~~~~~~~~~

   Red channel value between ``0`` and ``1``. Default is ``1``.

⭕:Float g
~~~~~~~~~~~

   Green channel value between ``0`` and ``1``. Default is ``1``.

⭕:Float b
~~~~~~~~~~~

   Blue channel value between ``0`` and ``1``. Default is ``1``.

Methods
-------

📦:add( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the RGB values of `color <#Color>`__ to the RGB values of this color.

📦:addColors( Color color1, Color color2 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this color's RGB values to the sum of the RGB values of `color1 <#Color>`__ 
   and `color2 <#Color>`__.

📦:addScalar( Number s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds `s <#Number>`__ to the RGB values of this color.

📦:applyMatrix3( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the transform `m <#Matrix3>`__ to this color's RGB components.

📦:clone() Color
~~~~~~~~~~~~~~~~~

   Returns a new Color with the same ``r``, ``g`` and ``b`` values as this
   one.

📦:copy( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the ``r``, ``g`` and ``b`` parameters from `color <#Color>`__ in
   to this color.

📦:convertLinearToSRGB() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts this color from linear space to sRGB space.

📦:convertSRGBToLinear() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts this color from sRGB space to linear space.

📦:copyLinearToSRGB( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Color>`__ — Color to copy.
   Copies the given color into this color, and then converts this color from linear space
   to sRGB space.

📦:copySRGBToLinear( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Color>`__ — Color to copy.
   Copies the given color into this color, and then converts this color from sRGB space to
   linear space.

📦:equals( Color color ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Compares the RGB values of `color <#Color>`__ with those of this object. Returns true if
   they are the same, false otherwise.

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - ``Array`` of floats in the form [ `r <#Float>`__, `g <#Float>`__, `b <#Float>`__ ].
   `offset <#Integer>`__ - An optional offset into the array.
   Sets this color's components based on an array formatted like [ `r <#Float>`__,
   `g <#Float>`__, `b <#Float>`__ ].

📦:fromBufferAttribute( BufferAttribute attribute, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `attribute <#BufferAttribute>`__ - the source attribute.
   `index <#Integer>`__ - index in the attribute.
   Sets this color's components from the `attribute <#BufferAttribute>`__.

📦:getHex( string colorSpace = SRGBColorSpace ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the hexadecimal value of this color.

📦:getHexString( string colorSpace = SRGBColorSpace ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').

📦:getHSL( Object target, string colorSpace = LinearSRGBColorSpace ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Object>`__ — the result will be copied into this Object. Adds h, s and l keys
   to the object (if not already present).
   Convert this Color's ``r``, ``g`` and ``b`` values to
   `HSL <https://en.wikipedia.org/wiki/HSL_and_HSV>`__ format and returns an object of the
   form: ``{ h: 0, s: 0, l: 0 }``

📦:getRGB( Color target, string colorSpace = LinearSRGBColorSpace ) Color
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Color>`__ — the result will be copied into this object.
   Returns the RGB values of this color as an instance of ``Color``.

📦:getStyle( string colorSpace = SRGBColorSpace ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the value of this color as a CSS style string. Example: ``rgb(255,0,0)``.

📦:lerp( Color color, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Color>`__ - color to converge on.
   `alpha <#Float>`__ - interpolation factor in the closed interval ``[0, 1]``.
   Linearly interpolates this color's RGB values toward the RGB values of the passed
   argument. The alpha argument can be thought of as the ratio between the two colors,
   where ``0.0`` is this color and ``1.0`` is the first argument.

📦:lerpColors( Color color1, Color color2, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color1 <#Color>`__ - the starting ``Color``.
   `color2 <#Color>`__ - ``Color`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Sets this color to be the color linearly interpolated between `color1 <#Color>`__ and
   `color2 <#Color>`__ where alpha is the percent distance along the line connecting the
   two colors - alpha = 0 will be `color1 <#Color>`__, and alpha = 1 will be `color2 <#Color>`__.

📦:lerpHSL( Color color, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `color <#Color>`__ - color to converge on.
   `alpha <#Float>`__ - interpolation factor in the closed interval ``[0, 1]``.
   Linearly interpolates this color's HSL values toward the HSL values of the passed
   argument. It differs from the classic ``.lerp`` by not interpolating straight from
   one color to the other, but instead going through all the hues in between those two
   colors. The alpha argument can be thought of as the ratio between the two colors, where
   0.0 is this color and 1.0 is the first argument.

📦:multiply( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this color's RGB values by the given `color <#Color>`__'s RGB values.

📦:multiplyScalar( Number s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this color's RGB values by `s <#Number>`__.

📦:offsetHSL( Float h, Float s, Float l ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the given `h <#Float>`__, `s <#Float>`__, and `l <#Float>`__ to this color's values.
   Internally, this converts the color's ``r``, ``g`` and ``b`` values to
   HSL, adds `h <#Float>`__, `s <#Float>`__, and `l <#Float>`__, and then converts the color
   back to RGB.

📦:set( Color_Hex_or_String r, Float g, Float b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `r <#Color_Hex_or_String>`__ - (optional) If arguments `g <#Float>`__ and `b <#Float>`__
   are defined, the red component of the color. If they are not defined, it can be a
   `hexadecimal triplet <https://en.wikipedia.org/wiki/Web_colors#Hex_triplet>`__
   (recommended), a CSS-style string, or another ``Color`` instance.
   `g <#Float>`__ - (optional) If it is defined, the green component of the color.
   `b <#Float>`__ - (optional) If it is defined, the blue component of the color.
   See the Constructor above for full details about possible arguments. Delegates to
   ``.copy``, ``.setStyle``, ``.setRGB`` or ``.setHex`` depending on input
   type.

📦:setFromVector3( Vector3 vector ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this colors's ``r``, ``g`` and ``b`` components from the x, y, and
   z components of the specified `vector <#Vector3>`__.

📦:setHex( Integer hex, string colorSpace = SRGBColorSpace ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `hex <#Integer>`__ — `hexadecimal triplet <https://en.wikipedia.org/wiki/Web_colors#Hex_triplet>`__ format.
   Sets this color from a hexadecimal value.

📦:setHSL( Float h, Float s, Float l, string colorSpace = LinearSRGBColorSpace ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `h <#Float>`__ — hue value between ``0.0`` and ``1.0``
   `s <#Float>`__ — saturation value between ``0.0`` and ``1.0``
   `l <#Float>`__ — lightness value between ``0.0`` and ``1.0``
   Sets color from HSL values.

📦:setRGB( Float r, Float g, Float b, string colorSpace = LinearSRGBColorSpace ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `r <#Float>`__ — Red channel value between ``0.0`` and ``1.0``.
   `g <#Float>`__ — Green channel value between ``0.0`` and ``1.0``.
   `b <#Float>`__ — Blue channel value between ``0.0`` and ``1.0``.
   Sets this color from RGB values.

📦:setScalar( Float scalar ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scalar <#Float>`__ — a value between ``0.0`` and ``1.0``.
   Sets all three color components to the value `scalar <#Float>`__.

📦:setStyle( String style, string colorSpace = SRGBColorSpace ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `style <#String>`__ — color as a CSS-style string.
   Sets this color from a CSS-style string. For example, "rgb(250, 0,0)", "rgb(100%, 0%,
   0%)", "hsl(0, 100%, 50%)", "#ff0000", "#f00", or "red" ( or any
   `X11 color name <https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart>`__ -
   all 140 color names are supported ).
   Translucent colors such as "rgba(255, 0, 0, 0.5)" and "hsla(0, 100%, 50%, 0.5)" are also
   accepted, but the alpha-channel coordinate will be discarded.
   Note that for X11 color names, multiple words such as Dark Orange become the string
   'darkorange'.

📦:setColorName( String style, string colorSpace = SRGBColorSpace ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `style <#String>`__ — color name ( from
   `X11 color names <https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart>`__ ).
   Sets this color from a color name. Faster than ``.setStyle`` method if you don't need
   the other CSS-style formats.
   For convenience, the list of names is exposed in Color.NAMES as a hash:

   .. code:: javascript

      Color.NAMES.aliceblue // returns 0xF0F8FF


📦:sub( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts the RGB components of the given color from the RGB components of this color. If
   this results in a negative component, that component is set to zero.

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - An optional array to store the color to.
   `offset <#Integer>`__ - An optional offset into the array.
   Returns an array of the form [ r, g, b ].

📦:toJSON() Number
~~~~~~~~~~~~~~~~~~~

   This methods defines the serialization result of ``Color``. Returns the color as a
   hexadecimal value.



.. _D170:

Cylindrical
===========

   https://threejs.org/docs/api/en/math/Cylindrical.html

   A point's `cylindrical coordinates <https://en.wikipedia.org/wiki/Cylindrical_coordinate_system>`__.

   .. Constructor

🐣:Cylindrical( Float radius, Float theta, Float y )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `radius <#Float>`__ - distance from the origin to a point in the x-z plane.
   Default is ``1.0``.
   `theta <#Float>`__ - counterclockwise angle in the x-z plane measured in radians from
   the positive z-axis. Default is ``0``.
   `y <#Float>`__ - height above the x-z plane. Default is ``0``.

Properties
----------

⭕:Float radius
~~~~~~~~~~~~~~~~

⭕:Float theta
~~~~~~~~~~~~~~~

⭕:Float y
~~~~~~~~~~~

Methods
-------

📦:clone() Cylindrical
~~~~~~~~~~~~~~~~~~~~~~~

   Returns a new cylindrical with the same ``radius``, ``theta`` and
   ``y`` properties as this one.

📦:copy( Cylindrical other ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed Cylindrical's ``radius``, ``theta``
   and ``y`` properties to this cylindrical.

📦:set( Float radius, Float theta, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets values of this cylindrical's ``radius``, ``theta`` and 
   ``y`` properties.

📦:setFromVector3( Vector3 vec3 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets values of this cylindrical's ``radius``, ``theta`` and 
   ``y`` properties from the `Vector3 <#Vector3>`__.

📦:setFromCartesianCoords( Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets values of this cylindrical's ``radius``, ``theta`` and 
   ``y`` properties from Cartesian coordinates.



.. _D171:

Euler
=====

   https://threejs.org/docs/api/en/math/Euler.html

   A class representing `Euler Angles <http://en.wikipedia.org/wiki/Euler_angles>`__.
   Euler angles describe a rotational transformation by rotating an object on its various
   axes in specified amounts per axis, and a specified axis order.

   Iterating through a ``Cylindrical`` instance will yield its components (x, y, z, order) in the
   corresponding order.

   **Code Example**


   .. code:: javascript

      const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
      const b = new THREE.Vector3( 1, 0, 1 );
      b.applyEuler(a);


   .. Constructor

🐣:Euler( Float x, Float y, Float z, String order )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - (optional) the angle of the x axis in radians. Default is ``0``.
   `y <#Float>`__ - (optional) the angle of the y axis in radians. Default is ``0``.
   `z <#Float>`__ - (optional) the angle of the z axis in radians. Default is ``0``.
   `order <#String>`__ - (optional) a string representing the order that the rotations are
   applied, defaults to 'XYZ' (must be upper case).

Properties
----------

⭕:Boolean isEuler
~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Euler``.

⭕:String order
~~~~~~~~~~~~~~~~

   The order in which to apply rotations. Default is 'XYZ', which means that the object
   will first be rotated around its X axis, then its Y axis and finally its Z axis. Other
   possibilities are: 'YZX', 'ZXY', 'XZY', 'YXZ' and 'ZYX'. These must be in upper case.
   Three.js uses ``intrinsic`` Tait-Bryan angles. This means that rotations are performed
   with respect to the ``local`` coordinate system. That is, for order 'XYZ', the rotation
   is first around the local-X axis (which is the same as the world-X axis), then around
   local-Y (which may now be different from the world Y-axis), then local-Z (which may be
   different from the world Z-axis).

⭕:Float x
~~~~~~~~~~~

   The current value of the x component.

⭕:Float y
~~~~~~~~~~~

   The current value of the y component.

⭕:Float z
~~~~~~~~~~~

   The current value of the z component.

Methods
-------

📦:copy( Euler euler ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies value of `euler <#Euler>`__ to this euler.

📦:clone() Euler
~~~~~~~~~~~~~~~~~

   Returns a new Euler with the same parameters as this one.

📦:equals( Euler euler ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Checks for strict equality of this euler and `euler <#Euler>`__.

📦:fromArray( Array array ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ of length 3 or 4. The optional 4th argument corresponds to the
   ``order``.
   Assigns this euler's ``x`` angle to ``array[0]``.
   Assigns this euler's ``y`` angle to ``array[1]``.
   Assigns this euler's ``z`` angle to ``array[2]``.
   Optionally assigns this euler's ``order`` to ``array[3]``.

📦:reorder( String newOrder ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resets the euler angle with a new order by creating a quaternion from this euler angle
   and then setting this euler angle with the quaternion and the new order.
   *``Warning``: this discards revolution information.*

📦:set( Float x, Float y, Float z, String order ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``x`` - the angle of the x axis in radians.
   ``y`` - the angle of the y axis in radians.
   ``z`` - the angle of the z axis in radians.
   ``order`` - (optional) a string representing the order that the rotations are
   applied.
   Sets the angles of this euler transform and optionally the ``order``.

📦:setFromRotationMatrix( Matrix4 m, String order ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `m <#Matrix4>`__ - a ``Matrix4`` of which the upper 3x3 of matrix is a pure
   `rotation matrix <https://en.wikipedia.org/wiki/Rotation_matrix>`__ (i.e. unscaled).
   ``order`` - (optional) a string representing the order that the rotations are
   applied.
   Sets the angles of this euler transform from a pure rotation matrix based on the
   orientation specified by order.

📦:setFromQuaternion( Quaternion q, String order ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `q <#Quaternion>`__ - a normalized quaternion.
   ``order`` - (optional) a string representing the order that the rotations are
   applied.
   Sets the angles of this euler transform from a normalized quaternion based on the
   orientation specified by ``order``.

📦:setFromVector3( Vector3 vector, String order ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vector <#Vector3>`__ - ``Vector3``.
   ``order`` - (optional) a string representing the order that the rotations are
   applied.
   Set the ``x``, ``y`` and ``z``, and optionally update the 
   ``order`` .

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) array to store the euler in.
   `offset <#Integer>`__ (optional) offset in the array.
   Returns an array of the form [``x``, ``y``, ``z``, `order  <#.order>`__].



.. _D172:

Frustum
=======

   https://threejs.org/docs/api/en/math/Frustum.html

   `Frustums <http://en.wikipedia.org/wiki/Frustum>`__ are used to determine what is
   inside the camera's field of view. They help speed up the rendering process - objects
   which lie outside a camera's frustum can safely be excluded from rendering.
   This class is mainly intended for use internally by a renderer for calculating a
   `camera <#Camera>`__ or `shadowCamera <#LightShadow.camera>`__'s frustum.

   .. Constructor

🐣:Frustum(Plane p0, Plane p1, Plane p2, Plane p3, Plane p4, Plane p5)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `p0 <#Plane>`__ - (optional) defaults to a new ``Plane``.
   `p1 <#Plane>`__ - (optional) defaults to a new ``Plane``.
   `p2 <#Plane>`__ - (optional) defaults to a new ``Plane``.
   `p3 <#Plane>`__ - (optional) defaults to a new ``Plane``.
   `p4 <#Plane>`__ - (optional) defaults to a new ``Plane``.
   `p5 <#Plane>`__ - (optional) defaults to a new ``Plane``.
   Creates a new ``Frustum``.

Properties
----------

⭕:Array planes
~~~~~~~~~~~~~~~~

   Array of 6 `planes <#Plane>`__.

Methods
-------

📦:clone() Frustum
~~~~~~~~~~~~~~~~~~~

   Return a new Frustum with the same parameters as this one.

📦:containsPoint( Vector3 point ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` to test.
   Checks to see if the frustum contains the `point <#Vector3>`__.

📦:copy( Frustum frustum ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `frustum <#Frustum>`__ - The frustum to copy
   Copies the properties of the passed `frustum <#Frustum>`__ into this one.

📦:intersectsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - ``Box3`` to check for intersection.
   Return true if `box <#Box3>`__ intersects with this frustum.

📦:intersectsObject( Object3D object ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Checks whether the `object <#Object3D>`__'s `bounding sphere <#BufferGeometry.boundingSphere>`__ is intersecting the Frustum.
   Note that the object must have a `geometry <#BufferGeometry>`__ so that the bounding
   sphere can be calculated.

📦:intersectsSphere( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - ``Sphere`` to check for intersection.
   Return true if `sphere <#Sphere>`__ intersects with this frustum.

📦:intersectsSprite( Sprite sprite ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Checks whether the `sprite <#Sprite>`__ is intersecting the Frustum.

📦:set( Plane p0, Plane p1, Plane p2, Plane p3, Plane p4, Plane p5 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the frustum from the passed planes. No plane order is implied.
   Note that this method only copies the values from the given objects.

📦:setFromProjectionMatrix( Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `matrix <#Matrix4>`__ - Projection ``Matrix4`` used to set the ``planes``
   Sets the frustum planes from the projection matrix.



.. _D173:

Interpolant
===========

   https://threejs.org/docs/api/en/math/Interpolant.html

   Abstract base class of interpolants over parametric samples.
   The parameter domain is one dimensional, typically the time or a path along a curve
   defined by the data.
   The sample values can have any dimensionality and derived classes may apply special
   interpretations to the data.
   This class provides the interval seek in a Template Method, deferring the actual
   interpolation to derived classes.
   Time complexity is ``O(1)`` for linear access crossing at most two points and \`O(log
   N)\` for random access, where ``N`` is the number of positions.
   References: `http://www.oodesign.com/template-method-pattern.html <http://www.oodesign.com/template-method-pattern.html>`__

   .. Constructor

🐣:Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   parameterPositions -- array of positions
   sampleValues -- array of samples
   sampleSize -- number of samples
   resultBuffer -- buffer to store the interpolation results.

   Note: This is not designed to be called directly.

Properties
----------

⭕:null parameterPositions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:null resultBuffer
~~~~~~~~~~~~~~~~~~~~~

⭕:null sampleValues
~~~~~~~~~~~~~~~~~~~~~

⭕:Object settings
~~~~~~~~~~~~~~~~~~~

   Optional, subclass-specific settings structure.

⭕:null valueSize
~~~~~~~~~~~~~~~~~~

Methods
-------

📦:evaluate( Number t ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Evaluate the interpolant at position ``t``.



.. _D174:

Line3
=====

   https://threejs.org/docs/api/en/math/Line3.html

   A geometric line segment represented by a start and end point.

   .. Constructor

🐣:Line3( Vector3 start, Vector3 end )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `start <#Vector3>`__ - Start of the line segment. Default is ``(0, 0, 0)``.
   `end <#Vector3>`__ - End of the line segment. Default is ``(0, 0, 0)``.
   Creates a new ``Line3``.

Properties
----------

⭕:Vector3 start
~~~~~~~~~~~~~~~~~

   ``Vector3`` representing the start point of the line.

⭕:Vector3 end
~~~~~~~~~~~~~~~

   ``Vector3`` representing the end point of the line.

Methods
-------

📦:applyMatrix4( Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies a matrix transform to the line segment.

📦:at( Float t, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `t <#Float>`__ - Use values 0-1 to return a position along the line segment.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a vector at a certain position along the line. When `t <#Float>`__ = 0, it
   returns the start vector, and when `t <#Float>`__ = 1 it returns the end vector.

📦:clone() Line3
~~~~~~~~~~~~~~~~~

   Returns a new ``Line3`` with the same ``start`` and ``end`` vectors
   as this one.

📦:closestPointToPoint( Vector3 point, Boolean clampToLine, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - return the closest point on the line to this point.
   `clampToLine <#Boolean>`__ - whether to clamp the returned value to the line segment.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the closets point on the line. If `clampToLine <#Boolean>`__ is true, then the
   returned value will be clamped to the line segment.

📦:closestPointToPointParameter( Vector3 point, Boolean clampToLine ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - the point for which to return a point parameter.
   `clampToLine <#Boolean>`__ - Whether to clamp the result to the range ``[0, 1]``.
   Returns a point parameter based on the closest point as projected on the line segment.
   If `clampToLine <#Boolean>`__ is true, then the returned value will be between ``0`` and
   ``1``.

📦:copy( Line3 line ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the passed line's ``start`` and ``end`` vectors to this line.

📦:delta( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the delta vector of the line segment ( ``end`` vector minus the
   ``start`` vector).

📦:distance() Float
~~~~~~~~~~~~~~~~~~~~

   Returns the `Euclidean distance <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line distance) between the line's ``start`` and ``end``
   points.

📦:distanceSq() Float
~~~~~~~~~~~~~~~~~~~~~~

   Returns the square of the `Euclidean distance` (straight-line distance) between the line's 
   `start <https://en.wikipedia.org/wiki/Euclidean_distance>`__ and 
   ``end`` vectors.

📦:equals( Line3 line ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `line <#Line3>`__ - ``Line3`` to compare with this one.
   Returns true if both line's ``start`` and ``end`` points are equal.

📦:getCenter( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the center of the line segment.

📦:set( Vector3 start, Vector3 end ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `start <#Vector3>`__ - set the `start point <#.start>`__ of the line.
   `end <#Vector3>`__ - set the `end point <#.end>`__ of the line.
   Sets the start and end values by copying the provided vectors.



.. _D175:

MathUtils
=========

   https://threejs.org/docs/api/en/math/MathUtils.html

   An object with several math utility functions.

   Functions
   ---------

📦:clamp( Float value, Float min, Float max ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `value <#Float>`__ — Value to be clamped.
   `min <#Float>`__ — Minimum value.
   `max <#Float>`__ — Maximum value.
   Clamps the `value <#Float>`__ to be between `min <#Float>`__ and `max <#Float>`__.

📦:degToRad( Float degrees ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts degrees to radians.

📦:euclideanModulo( Integer n, Integer m ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `n <#Integer>`__, `m <#Integer>`__ - Integers
   Computes the Euclidean modulo of `m <#Integer>`__ % `n <#Integer>`__, that is:

   .. code:: javascript

      ( ( n % m ) + m ) % m


📦:generateUUID( ) UUID
~~~~~~~~~~~~~~~~~~~~~~~~

   Generate a `UUID <https://en.wikipedia.org/wiki/Universally_unique_identifier>`__
   (universally unique identifier).

📦:isPowerOfTwo( Number n ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return ``true`` if `n <#Number>`__ is a power of 2.

📦:inverseLerp( Float x, Float y, Float value ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - Start point.
   `y <#Float>`__ - End point.
   `value <#Float>`__ - A value between start and end.
   Returns the percentage in the closed interval ``[0, 1]`` of the given value between the
   start and end point.

📦:lerp( Float x, Float y, Float t ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - Start point.
   `y <#Float>`__ - End point.
   `t <#Float>`__ - interpolation factor in the closed interval ``[0, 1]``.
   Returns a value `linearly interpolated` from two known points based on the given interval - 
   `Float t <https://en.wikipedia.org/wiki/Linear_interpolation>`__ = 0
   will return `x <#Float>`__ and `t <#Float>`__ = 1 will return `y <#Float>`__.

📦:damp( Float x, Float y, Float lambda, Float dt ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `x <#Float>`__ - Current point.
   -  `y <#Float>`__ - Target point.
   -  `lambda <#Float>`__ - A higher lambda value will make the movement more sudden, and a
      lower value will make the movement more gradual.
   -  `dt <#Float>`__ - Delta time in seconds.

   Smoothly interpolate a number from `x <#Float>`__ toward `y <#Float>`__ in a spring-like
   manner using the `dt <#Float>`__ to maintain frame rate independent movement. For
   details, see `Frame rate independent damping using lerp <http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/>`__.

📦:mapLinear( Float x, Float a1, Float a2, Float b1, Float b2 ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `x <#Float>`__ — Value to be mapped.
   -  `a1 <#Float>`__ — Minimum value for range A.
   -  `a2 <#Float>`__ — Maximum value for range A.
   -  `b1 <#Float>`__ — Minimum value for range B.
   -  `b2 <#Float>`__ — Maximum value for range B.

   Linear mapping of `x <#Float>`__ from range [`a1 <#Float>`__, `a2 <#Float>`__] to range
   [`b1 <#Float>`__, `b2 <#Float>`__].

📦:pingpong( Float x, Float length ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `x <#Float>`__ — The value to pingpong.
   -  `length <#Float>`__ — The positive value the function will pingpong to.
      Default is ``1``.

   Returns a value that alternates between ``0`` and [param:Float length].

📦:ceilPowerOfTwo( Number n ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the smallest power of 2 that is greater than or equal to `n <#Number>`__.

📦:floorPowerOfTwo( Number n ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the largest power of ``2`` that is less than or equal to `n <#Number>`__.

📦:radToDeg( Float radians ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converts radians to degrees.

📦:randFloat( Float low, Float high ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Random float in the interval [`low <#Float>`__, `high <#Float>`__].

📦:randFloatSpread( Float range ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Random float in the interval [- `range <#Float>`__ / 2, `range <#Float>`__ / 2].

📦:randInt( Integer low, Integer high ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Random integer in the interval [`low <#Float>`__, `high <#Float>`__].

📦:seededRandom( Integer seed ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Deterministic pseudo-random float in the interval ``[0, 1]``. The integer `seed <#Integer>`__ is optional.

📦:smoothstep( Float x, Float min, Float max ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - The value to evaluate based on its position between min and max.
   `min <#Float>`__ - Any x value below min will be ``0``.
   `max <#Float>`__ - Any x value above max will be ``1``.
   Returns a value between 0-1 that represents the percentage that x has moved between min
   and max, but smoothed or slowed down the closer X is to the min and max.
   See `Smoothstep <http://en.wikipedia.org/wiki/Smoothstep>`__ for details.

📦:smootherstep( Float x, Float min, Float max ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - The value to evaluate based on its position between min and max.
   `min <#Float>`__ - Any x value below min will be ``0``.
   `max <#Float>`__ - Any x value above max will be ``1``.
   Returns a value between 0-1. A `variation on smoothstep <https://en.wikipedia.org/wiki/Smoothstep#Variations>`__ 
   that has zero 1st and 2nd order derivatives at x=0 and x=1.

📦:setQuaternionFromProperEuler( Quaternion q, Float a, Float b, Float c, String order ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `q <#Quaternion>`__ - the quaternion to be set
   `a <#Float>`__ - the rotation applied to the first axis, in radians
   `b <#Float>`__ - the rotation applied to the second axis, in radians
   `c <#Float>`__ - the rotation applied to the third axis, in radians
   `order <#String>`__ - a string specifying the axes order: 'XYX', 'XZX', 'YXY', 'YZY',
   'ZXZ', or 'ZYZ'
   Sets quaternion `q <#Quaternion>`__ from the
   `intrinsic Proper Euler Angles <http://en.wikipedia.org/wiki/Euler_angles>`__ defined
   by angles `a <#Float>`__, `b <#Float>`__, and `c <#Float>`__, and order `order <#String>`__.
   Rotations are applied to the axes in the order specified by `order <#String>`__:
   rotation by angle `a <#Float>`__ is applied first, then by angle `b <#Float>`__, then by
   angle `c <#Float>`__. Angles are in radians.



.. _D176:

Matrix3
=======

   https://threejs.org/docs/api/en/math/Matrix3.html

   A class representing a 3x3 `matrix <https://en.wikipedia.org/wiki/Matrix_(mathematics)>`__.

   **Code Example**


   .. code:: javascript

      const m = new Matrix3();


   A Note on Row-Major and Column-Major Ordering
   ---------------------------------------------

   The constructor and ``set``() method take arguments in
   `row-major` order, while internally they are stored in the 
   `.elements elements <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__
   array in column-major order.

   This means that calling ``m.set( 11, 12, 13, 21, 22, 23, 31, 32, 33 );`` will result in
   the ``elements`` array containing:

   .. code:: javascript

      m.elements = [ 11, 21, 31, 12, 22, 32, 13, 23, 33 ];
         

   and internally all calculations are performed using column-major ordering. However, 
   as the actual ordering makes no difference mathematically and most people are used to 
   thinking about matrices in row-major order, the three.js documentation shows matrices 
   in row-major order. Just bear in mind that if you are reading the source code, you'll 
   have to take the `transpose <https://en.wikipedia.org/wiki/Transpose>`__ of any 
   matrices outlined here to make sense of the calculations.

   .. Constructor

🐣:Matrix3( Number n11, Number n12, Number n13, Number n21, Number n22, Number n23, Number n31, Number n32, Number n33 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a 3x3 matrix with the given arguments in row-major order. If no arguments are
   provided, the constructor initializes the ``Matrix3`` to the 3x3
   `identity matrix <https://en.wikipedia.org/wiki/Identity_matrix>`__.

Properties
----------

⭕:Array elements
~~~~~~~~~~~~~~~~~~

   A `column-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order>`__ list of
   matrix values.

Methods
-------

📦:clone() Matrix3
~~~~~~~~~~~~~~~~~~~

   Creates a new Matrix3 and with identical elements to this one.

📦:copy( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the elements of matrix `m <#Matrix3>`__ into this matrix.

📦:determinant() Float
~~~~~~~~~~~~~~~~~~~~~~~

   Computes and returns the `determinant <https://en.wikipedia.org/wiki/Determinant>`__ of
   this matrix.

📦:equals( Matrix3 m ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return true if this matrix and `m <#Matrix3>`__ are equal.

📦:extractBasis( Vector3 xAxis, Vector3 yAxis, Vector3 zAxis ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Extracts the `basis <https://en.wikipedia.org/wiki/Basis_(linear_algebra)>`__ of this
   matrix into the three axis vectors provided. If this matrix is:

   .. math::

      \begin{bmatrix}
      a & b & c \\
      d & e & f \\
      g & h & i
      \end{bmatrix}

   then the `xAxis <#Vector3>`__, `yAxis <#Vector3>`__, `zAxis <#Vector3>`__ will be set to:

   :math:`{xAxis} = \begin{bmatrix}
   a \\
   d \\
   g
   \end{bmatrix}`, :math:`{yAxis} = \begin{bmatrix}
   b \\
   e \\
   h
   \end{bmatrix}`, and :math:`{zAxis} = \begin{bmatrix}
   c \\
   f \\
   i
   \end{bmatrix}`

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - the array to read the elements from.
   `offset <#Integer>`__ - (optional) index of first element in the array.
   Default is ``0``.
   Sets the elements of this matrix based on an array in
   `column-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__ format.

📦:invert() this
~~~~~~~~~~~~~~~~~

   Inverts this matrix, using the
   `analytic method <https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution>`__.
   You can not invert with a determinant of zero. If you attempt this, the method produces a
   zero matrix instead.

📦:getNormalMatrix( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `m <#Matrix4>`__ - ``Matrix4`` Sets this matrix as the upper left 3x3 of the
      `normal matrix <https://en.wikipedia.org/wiki/Normal_matrix>`__ of the passed
      `matrix4 <#Matrix4>`__. The normal matrix is the
      `inverse <https://en.wikipedia.org/wiki/Invertible_matrix>`__
      `transpose` of the matrix `Matrix4 m <https://en.wikipedia.org/wiki/Transpose>`__.

📦:identity() this
~~~~~~~~~~~~~~~~~~~

   Resets this matrix to the 3x3 identity matrix:

   .. math::

      \begin{bmatrix}
      1 & 0 & 0 \\
      0 & 1 & 0 \\
      0 & 0 & 1
      \end{bmatrix}

📦:makeRotation( Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `theta <#Float>`__ — Rotation angle in radians. Positive values rotate counterclockwise.
   Sets this matrix as a 2D rotational transformation by `theta <#Float>`__ radians. The
   resulting matrix will be:

   .. math::

      \begin{bmatrix}
      {\cos\theta} & {{-sin}\theta} & 0 \\
      {\sin\theta} & {\cos\theta} & 0 \\
      0 & 0 & 1
      \end{bmatrix}

📦:makeScale( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - the amount to scale in the X axis.
   `y <#Float>`__ - the amount to scale in the Y axis.
   Sets this matrix as a 2D scale transform:

   .. math::

      \begin{bmatrix}
      x & 0 & 0 \\
      0 & y & 0 \\
      0 & 0 & 1
      \end{bmatrix}

📦:makeTranslation( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📦:makeTranslation( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v <#Vector2>`__ a translation transform from vector.
   or
   `x <#Float>`__ - the amount to translate in the X axis.
   `y <#Float>`__ - the amount to translate in the Y axis.
   Sets this matrix as a 2D translation transform:

   .. math::

      \begin{bmatrix}
      1 & 0 & x \\
      0 & 1 & y \\
      0 & 0 & 1
      \end{bmatrix}

📦:multiply( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Post-multiplies this matrix by `m <#Matrix3>`__.

📦:multiplyMatrices( Matrix3 a, Matrix3 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this matrix to `a <#Matrix3>`__ x `b <#Matrix3>`__.

📦:multiplyScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies every component of the matrix by the scalar value ``s``.

📦:rotate( Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Rotates this matrix by the given angle (in radians).

📦:scale( Float sx, Float sy ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Scales this matrix with the given scalar values.

📦:set( Float n11, Float n12, Float n13, Float n21, Float n22, Float n23, Float n31, Float n32, Float n33 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the 3x3 matrix values to the given `row-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order>`__ 
   sequence of values:

   .. math::

      \begin{bmatrix}
      {n11} & {n12} & {n13} \\
      {n21} & {n22} & {n23} \\
      {n31} & {n32} & {n33}
      \end{bmatrix}

📦:premultiply( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Pre-multiplies this matrix by `m <#Matrix3>`__.

📦:setFromMatrix4( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set this matrix to the upper 3x3 matrix of the Matrix4 `m <#Matrix4>`__.

📦:setUvTransform( Float tx, Float ty, Float sx, Float sy, Float rotation, Float cx, Float cy ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `tx <#Float>`__ - offset x
   `ty <#Float>`__ - offset y
   `sx <#Float>`__ - repeat x
   `sy <#Float>`__ - repeat y
   `rotation <#Float>`__ - rotation, in radians. Positive values rotate counterclockwise
   `cx <#Float>`__ - center x of rotation
   `cy <#Float>`__ - center y of rotation
   Sets the UV transform matrix from offset, repeat, rotation, and center.

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) array to store the resulting vector in. If not given a
   new array will be created.
   `offset <#Integer>`__ - (optional) offset in the array at which to put the result.
   Writes the elements of this matrix to an array in
   `column-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__ format.

📦:translate( Float tx, Float ty ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Translates this matrix by the given scalar values.

📦:transpose() this
~~~~~~~~~~~~~~~~~~~~

   `Transposes <https://en.wikipedia.org/wiki/Transpose>`__ this matrix in place.

📦:transposeIntoArray( Array array ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - array to store the resulting vector in.
   `Transposes <https://en.wikipedia.org/wiki/Transpose>`__ this matrix into the supplied
   array, and returns itself unchanged.



.. _D177:

Matrix4
=======

   https://threejs.org/docs/api/en/math/Matrix4.html

   A class representing a 4x4 `matrix <https://en.wikipedia.org/wiki/Matrix_(mathematics)>`__.
   The most common use of a 4x4 matrix in 3D computer graphics is as a
   `Transformation Matrix <https://en.wikipedia.org/wiki/Transformation_matrix>`__. For an
   introduction to transformation matrices as used in WebGL, check out
   `this tutorial <http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices>`__.
   This allows a ``Vector3`` representing a point in 3D space to undergo transformations
   such as translation, rotation, shear, scale, reflection, orthogonal or perspective
   projection and so on, by being multiplied by the matrix. This is known as ``applying``
   the matrix to the vector.
   Every ``Object3D`` has three associated Matrix4s:

   -  ``Object3D.matrix``: This stores the local transform of the object. This is the
      object's transformation relative to its parent.
   -  ``Object3D.matrixWorld``: The global or world transform of the object. If the object
      has no parent, then this is identical to the local transform stored in
      `matrix <#Object3D.matrix>`__.
   -  ``Object3D.modelViewMatrix``: This represents the object's transformation relative
      to the camera's coordinate system. An object's modelViewMatrix is the object's
      matrixWorld pre-multiplied by the camera's matrixWorldInverse.

   `Cameras <#Camera>`__ have three additional Matrix4s:

   -  ``Camera.matrixWorldInverse``: The view matrix - the inverse of the Camera's
      `matrixWorld <#Object3D.matrixWorld>`__.
   -  ``Camera.projectionMatrix``: Represents the information how to project the scene to
      clip space.
   -  ``Camera.projectionMatrixInverse``: The inverse of projectionMatrix.


   Note: ``Object3D.normalMatrix`` is not a Matrix4, but a ``Matrix3``.

   A Note on Row-Major and Column-Major Ordering
   ---------------------------------------------

   The constructor and ``set``() method take arguments in `row-major` order, while 
   internally they are stored in the `.elements elements <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__
   array in column-major order.

   This means that calling

   .. code:: javascript

      const m = new THREE.Matrix4();
      m.set( 11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34, 41, 42, 43, 44 );
      
   will result in the ``elements`` array containing:

   .. code:: javascript

      m.elements = [ 11, 21, 31, 41, 12, 22, 32, 42, 13, 23, 33, 43, 14, 24, 34, 44 ];


   and internally all calculations are performed using column-major ordering. However, as the
   actual ordering makes no difference mathematically and most people are used to thinking
   about matrices in row-major order, the three.js documentation shows matrices in
   row-major order. Just bear in mind that if you are reading the source code, you'll have
   to take the `transpose <https://en.wikipedia.org/wiki/Transpose>`__ of any matrices
   outlined here to make sense of the calculations.

   Extracting position, rotation and scale
   ---------------------------------------

   There are several options available for extracting position, rotation and scale from a
   Matrix4.

   -  ``Vector3.setFromMatrixPosition``: can be used to extract the translation component.
   -  ``Vector3.setFromMatrixScale``: can be used to extract the scale component.
   -  ``Quaternion.setFromRotationMatrix``, ``Euler.setFromRotationMatrix`` or
      ``extractRotation`` can be used to extract the rotation component
      from a pure (unscaled) matrix.
   -  ``decompose`` can be used to extract position, rotation and scale all at
      once.

   .. Constructor

🐣:Matrix4( Number n11, Number n12, Number n13, Number n14, Number n21, Number n22, Number n23, Number n24, Number n31, Number n32, Number n33, Number n34, Number n41, Number n42, Number n43, Number n44 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a 4x4 matrix with the given arguments in row-major order. If no arguments are
   provided, the constructor initializes the ``Matrix4`` to the 4x4
   `identity matrix <https://en.wikipedia.org/wiki/Identity_matrix>`__.

Properties
----------

⭕:Array elements
~~~~~~~~~~~~~~~~~~

   A `column-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__ 
   list of matrix values.

Methods
-------

📦:clone() Matrix4
~~~~~~~~~~~~~~~~~~~

   Creates a new Matrix4 with identical ``elements`` to this one.

📦:compose( Vector3 position, Quaternion quaternion, Vector3 scale ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this matrix to the transformation composed of `position <#Vector3>`__,
   `quaternion <#Quaternion>`__ and `scale <#Vector3>`__.

📦:copy( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the ``elements`` of matrix `m <#Matrix4>`__ into this matrix.

📦:copyPosition( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the translation component of the supplied matrix `m <#Matrix4>`__ into this
   matrix's translation component.

📦:decompose( Vector3 position, Quaternion quaternion, Vector3 scale ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Decomposes this matrix into its `position <#Vector3>`__, `quaternion <#Quaternion>`__
   and `scale <#Vector3>`__ components.

   Note: Not all matrices are decomposable in this way. For example, if an object has a
   non-uniformly scaled parent, then the object's world matrix may not be decomposable, and
   this method may not be appropriate.

📦:determinant() Float
~~~~~~~~~~~~~~~~~~~~~~~

   Computes and returns the `determinant <https://en.wikipedia.org/wiki/Determinant>`__ of
   this matrix.
   Based on the method outlined
   `here <http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html>`__.

📦:equals( Matrix4 m ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return true if this matrix and `m <#Matrix4>`__ are equal.

📦:extractBasis( Vector3 xAxis, Vector3 yAxis, Vector3 zAxis ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Extracts the `basis <https://en.wikipedia.org/wiki/Basis_(linear_algebra)>`__ of this
   matrix into the three axis vectors provided. If this matrix is:

   .. math::

      \begin{bmatrix}
      a & b & c & d \\
      e & f & g & h \\
      i & j & k & l \\
      m & n & o & p
      \end{bmatrix}

   then the `xAxis <#Vector3>`__, `yAxis <#Vector3>`__, `zAxis <#Vector3>`__ will be set to:


      :math:`{xAxis} = \begin{bmatrix}
      a \\
      e \\
      i
      \end{bmatrix}`, :math:`{yAxis} = \begin{bmatrix}
      b \\
      f \\
      j
      \end{bmatrix}`, and :math:`{zAxis} = \begin{bmatrix}
      c \\
      g \\
      k
      \end{bmatrix}`

📦:extractRotation( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Extracts the rotation component of the supplied matrix `m <#Matrix4>`__ into this matrix's
   rotation component.

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - the array to read the elements from.
   `offset <#Integer>`__ - ( optional ) offset into the array. Default is 0.
   Sets the elements of this matrix based on an `array <#Array>`__ in
   `column-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__ format.

📦:invert() this
~~~~~~~~~~~~~~~~~

   Inverts this matrix, using the
   `analytic method <https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution>`__.
   You can not invert with a determinant of zero. If you attempt this, the method produces a
   zero matrix instead.

📦:getMaxScaleOnAxis() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Gets the maximum scale value of the 3 axes.

📦:identity() this
~~~~~~~~~~~~~~~~~~~

   Resets this matrix to the `identity matrix <https://en.wikipedia.org/wiki/Identity_matrix>`__.

📦:lookAt( Vector3 eye, Vector3 target, Vector3 up ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Constructs a rotation matrix, looking from `eye <#Vector3>`__ towards `target <#Vector3>`__ 
   oriented by the `up <#Vector3>`__ vector.

📦:makeRotationAxis( Vector3 axis, Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `axis <#Vector3>`__ — Rotation axis, should be normalized.
   `theta <#Float>`__ — Rotation angle in radians.
   Sets this matrix as rotation transform around `axis <#Vector3>`__ by `theta <#Float>`__
   radians.
   This is a somewhat controversial but mathematically sound alternative to rotating via
   `Quaternions <#Quaternion>`__. See the discussion
   `here <https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199>`__.

📦:makeBasis( Vector3 xAxis, Vector3 yAxis, Vector3 zAxis ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set this to the `basis <https://en.wikipedia.org/wiki/Basis_(linear_algebra)>`__ matrix
   consisting of the three provided basis vectors:

   .. math::

      \begin{bmatrix}
      {xAxis.x} & {yAxis.x} & {zAxis.x} & 0 \\
      {xAxis.y} & {yAxis.y} & {zAxis.y} & 0 \\
      {xAxis.z} & {yAxis.z} & {zAxis.z} & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makePerspective( Float left, Float right, Float top, Float bottom, Float near, Float far ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a `perspective projection <https://en.wikipedia.org/wiki/3D_projection#Perspective_projection>`__
   matrix. This is used internally by ``PerspectiveCamera.updateProjectionMatrix``()

📦:makeOrthographic( Float left, Float right, Float top, Float bottom, Float near, Float far ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates an `orthographic projection <https://en.wikipedia.org/wiki/Orthographic_projection>`__ 
   matrix. This is used internally by ``OrthographicCamera.updateProjectionMatrix``().

📦:makeRotationFromEuler( Euler euler ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the rotation component (the upper left 3x3 matrix) of this matrix to the rotation
   specified by the given `Euler Angle <#Euler>`__. The rest of the matrix is set to the
   identity. Depending on the `order <#Euler.order>`__ of the `euler <#Euler>`__, there are
   six possible outcomes. See
   `this page <https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix>`__ for a complete
   list.

📦:makeRotationFromQuaternion( Quaternion q ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the rotation component of this matrix to the rotation specified by `q <#Quaternion>`__, 
   as outlined `here <https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion>`__. The
   rest of the matrix is set to the identity. So, given `q <#Quaternion>`__ = w + xi + yj +
   zk, the resulting matrix will be:

   .. math::

      \begin{bmatrix}
      {1 - 2y^{2} - 2z^{2}} & {2xy - 2zw} & {2xz + 2yw} & 0 \\
      {2xy + 2zw} & {1 - 2x^{2} - 2z^{2}} & {2yz - 2xw} & 0 \\
      {2xz - 2yw} & {2yz + 2xw} & {1 - 2x^{2} - 2y^{2}} & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makeRotationX( Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `theta <#Float>`__ — Rotation angle in radians.
   Sets this matrix as a rotational transformation around the X axis by `theta <#Float>`__
   (θ) radians. The resulting matrix will be:

   .. math::

      \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & {\cos\theta} & {- \sin\theta} & 0 \\
      0 & {\sin\theta} & {\cos\theta} & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makeRotationY( Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `theta <#Float>`__ — Rotation angle in radians.
   Sets this matrix as a rotational transformation around the Y axis by `theta <#Float>`__
   (θ) radians. The resulting matrix will be:

   .. math::

      \begin{bmatrix}
      {\cos\theta} & 0 & {\sin\theta} & 0 \\
      0 & 1 & 0 & 0 \\
      {- \sin\theta} & 0 & {\cos\theta} & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makeRotationZ( Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `theta <#Float>`__ — Rotation angle in radians.
   Sets this matrix as a rotational transformation around the Z axis by `theta <#Float>`__
   (θ) radians. The resulting matrix will be:

   .. math::

      \begin{bmatrix}
      {\cos\theta} & {- \sin\theta} & 0 & 0 \\
      {\sin\theta} & {\cos\theta} & 0 & 0 \\
      0 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makeScale( Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - the amount to scale in the X axis.
   `y <#Float>`__ - the amount to scale in the Y axis.
   `z <#Float>`__ - the amount to scale in the Z axis.
   Sets this matrix as scale transform:

   .. math::

      \begin{bmatrix}
      x & 0 & 0 & 0 \\
      0 & y & 0 & 0 \\
      0 & 0 & z & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makeShear( Float xy, Float xz, Float yx, Float yz, Float zx, Float zy ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `xy <#Float>`__ - the amount to shear X by Y.
   `xz <#Float>`__ - the amount to shear X by Z.
   `yx <#Float>`__ - the amount to shear Y by X.
   `yz <#Float>`__ - the amount to shear Y by Z.
   `zx <#Float>`__ - the amount to shear Z by X.
   `zy <#Float>`__ - the amount to shear Z by Y.
   Sets this matrix as a shear transform:

   .. math::

      \begin{bmatrix}
      1 & {yx} & {zx} & 0 \\
      {xy} & 1 & {zy} & 0 \\
      {xz} & {yz} & 1 & 0 \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:makeTranslation( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📦:makeTranslation( Float x, Float y, Float z ) // optional API this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this matrix as a translation transform from vector `v <#Vector3>`__, or numbers
   `x <#Float>`__, `y <#Float>`__ and `z <#Float>`__:

   .. math::

      \begin{bmatrix}
      1 & 0 & 0 & x \\
      0 & 1 & 0 & y \\
      0 & 0 & 1 & z \\
      0 & 0 & 0 & 1
      \end{bmatrix}

📦:multiply( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Post-multiplies this matrix by `m <#Matrix4>`__.

📦:multiplyMatrices( Matrix4 a, Matrix4 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this matrix to `a <#Matrix4>`__ x `b <#Matrix4>`__.

📦:multiplyScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies every component of the matrix by a scalar value `s <#Float>`__.

📦:premultiply( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Pre-multiplies this matrix by `m <#Matrix4>`__.

📦:scale( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies the columns of this matrix by vector `v <#Vector3>`__.

📦:set( Float n11, Float n12, Float n13, Float n14, Float n21, Float n22, Float n23, Float n24, Float n31, Float n32, Float n33, Float n34, Float n41, Float n42, Float n43, Float n44 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the ``elements`` of this matrix to the supplied row-major values
   `n11 <#Float>`__, `n12 <#Float>`__, ... `n44 <#Float>`__.

📦:setFromMatrix3( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the upper 3x3 elements of this matrix to the values of the Matrix3 `m <#Matrix3>`__.

📦:setPosition( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📦:setPosition( Float x, Float y, Float z ) // optional API this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the position component for this matrix from vector `v <#Vector3>`__, without
   affecting the rest of the matrix - i.e. if the matrix is currently:

   .. math::

      \begin{bmatrix}
      a & b & c & d \\
      e & f & g & h \\
      i & j & k & l \\
      m & n & o & p
      \end{bmatrix}

   This becomes:

   .. math::

      \begin{bmatrix}
      a & b & c & {v.x} \\
      e & f & g & {v.y} \\
      i & j & k & {v.z} \\
      m & n & o & p
      \end{bmatrix}

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) array to store the resulting vector in.
   `offset <#Integer>`__ - (optional) offset in the array at which to put the result.
   Writes the elements of this matrix to an array in
   `column-major <https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order>`__ format.

📦:transpose() this
~~~~~~~~~~~~~~~~~~~~

   `Transposes <https://en.wikipedia.org/wiki/Transpose>`__ this matrix.



.. _D178:

Plane
=====

   https://threejs.org/docs/api/en/math/Plane.html

   A two dimensional surface that extends infinitely in 3d space, represented in
   `Hessian normal form <http://mathworld.wolfram.com/HessianNormalForm.html>`__ by a unit
   length normal vector and a constant.

   .. Constructor

🐣:Plane( Vector3 normal, Float constant )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - (optional) a unit length ``Vector3`` defining the normal of
   the plane. Default is ``(1, 0, 0)``.
   `constant <#Float>`__ - (optional) the signed distance from the origin to the plane.
   Default is ``0``.

Properties
----------

⭕:Boolean isPlane
~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Plane``.

⭕:Vector3 normal
~~~~~~~~~~~~~~~~~~

⭕:Float constant
~~~~~~~~~~~~~~~~~~

Methods
-------

📦:applyMatrix4( Matrix4 matrix, Matrix3 optionalNormalMatrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `matrix <#Matrix4>`__ - the [Page:Matrix4] to apply.
   `optionalNormalMatrix <#Matrix3>`__ - (optional) pre-computed normal [Page:Matrix3] of
   the Matrix4 being applied.
   Apply a Matrix4 to the plane. The matrix must be an affine, homogeneous transform.
   If supplying an `optionalNormalMatrix <#Matrix3>`__, it can be created like so:

   .. code:: javascript

      const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );


📦:clone() Plane
~~~~~~~~~~~~~~~~~

   Returns a new plane with the same ``normal`` and ``constant`` as
   this one.

📦:coplanarPoint( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns a ``Vector3`` coplanar to the plane, by calculating the projection of the
   normal vector at the origin onto the plane.

📦:copy( Plane plane ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed plane's ``normal`` and 
   ``constant`` properties to this plane.

📦:distanceToPoint( Vector3 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the signed distance from the `point <#Vector3>`__ to the plane.

📦:distanceToSphere( Sphere sphere ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the signed distance from the `sphere <#Sphere>`__ to the plane.

📦:equals( Plane plane ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Checks to see if two planes are equal (their ``normal`` and 
   ``constant`` properties match).

📦:intersectLine( Line3 line, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `line <#Line3>`__ - the ``Line3`` to check for intersection.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the intersection point of the passed line and the plane. Returns null if the
   line does not intersect. Returns the line's starting point if the line is coplanar with
   the plane.

📦:intersectsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - the ``Box3`` to check for intersection.
   Determines whether or not this plane intersects `box <#Box3>`__.

📦:intersectsLine( Line3 line ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `line <#Line3>`__ - the ``Line3`` to check for intersection.
   Tests whether a line segment intersects with (passes through) the plane.

📦:intersectsSphere( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - the ``Sphere`` to check for intersection.
   Determines whether or not this plane intersects `sphere <#Sphere>`__.

📦:negate() this
~~~~~~~~~~~~~~~~~

   Negates both the normal vector and the constant.

📦:normalize() this
~~~~~~~~~~~~~~~~~~~~

   Normalizes the ``normal`` vector, and adjusts the ``constant``
   value accordingly.

📦:projectPoint( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - the ``Vector3`` to project onto the plane.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Projects a `point <#Vector3>`__ onto the plane.

📦:set( Vector3 normal, Float constant ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - a unit length ``Vector3`` defining the normal of the plane.
   `constant <#Float>`__ - the signed distance from the origin to the plane.
   Sets this plane's ``normal`` and ``constant`` properties by
   copying the values from the given normal.

📦:setComponents( Float x, Float y, Float z, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - x value of the unit length normal vector.
   `y <#Float>`__ - y value of the unit length normal vector.
   `z <#Float>`__ - z value of the unit length normal vector.
   `w <#Float>`__ - the value of the plane's ``constant`` property.
   Set the individual components that define the plane.

📦:setFromCoplanarPoints( Vector3 a, Vector3 b, Vector3 c ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `a <#Vector3>`__ - first point on the plane.
   `b <#Vector3>`__ - second point on the plane.
   `c <#Vector3>`__ - third point on the plane.
   Defines the plane based on the 3 provided points. The winding order is assumed to be
   counter-clockwise, and determines the direction of the ``normal``.

📦:setFromNormalAndCoplanarPoint( Vector3 normal, Vector3 point ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - a unit length ``Vector3`` defining the normal of the plane.
   `point <#Vector3>`__ - ``Vector3``
   Sets the plane's properties as defined by a `normal <#Vector3>`__ and an arbitrary
   coplanar `point <#Vector3>`__.

📦:translate( Vector3 offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `offset <#Vector3>`__ - the amount to move the plane by.
   Translates the plane by the distance defined by the `offset <#Vector3>`__ vector. Note
   that this only affects the plane constant and will not affect the normal vector.



.. _D179:

Quaternion
==========

   https://threejs.org/docs/api/en/math/Quaternion.html

   Implementation of a `quaternion <http://en.wikipedia.org/wiki/Quaternion>`__.
   Quaternions are used in three.js to represent
   `rotations <https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation>`__.

   Iterating through a ``Plane`` instance will yield its components (x, y, z, w) in the
   corresponding order.

   Note that three.js expects Quaternions to be normalized.

   **Code Example**


   .. code:: javascript

      const quaternion = new THREE.Quaternion();
      quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
      const vector = new THREE.Vector3( 1, 0, 0 );
      vector.applyQuaternion( quaternion );


   .. Constructor

🐣:Quaternion( Float x, Float y, Float z, Float w )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - x coordinate
   `y <#Float>`__ - y coordinate
   `z <#Float>`__ - z coordinate
   `w <#Float>`__ - w coordinate

Properties
----------

⭕:Boolean isQuaternion
~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Quaternion``.

⭕:Float x
~~~~~~~~~~~

⭕:Float y
~~~~~~~~~~~

⭕:Float z
~~~~~~~~~~~

⭕:Float w
~~~~~~~~~~~

Methods
-------

📦:angleTo( Quaternion q ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the angle between this quaternion and quaternion `q <#Quaternion>`__ in radians.

📦:clone() Quaternion
~~~~~~~~~~~~~~~~~~~~~~

   Creates a new Quaternion with identical ``x``, ``y``, ``z`` and 
   ``w`` properties to this one.

📦:conjugate() this
~~~~~~~~~~~~~~~~~~~~

   Returns the rotational conjugate of this quaternion. The conjugate of a quaternion
   represents the same rotation in the opposite direction about the rotational axis.

📦:copy( Quaternion q ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the ``x``, ``y``, ``z`` and ``w`` properties of
   `q <#Quaternion>`__ into this quaternion.

📦:equals( Quaternion v ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v <#Quaternion>`__ - Quaternion that this quaternion will be compared to.
   Compares the ``x``, ``y``, ``z`` and ``w`` properties of
   `v <#Quaternion>`__ to the equivalent properties of this quaternion to determine if they
   represent the same rotation.

📦:dot( Quaternion v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Calculates the `dot product <https://en.wikipedia.org/wiki/Dot_product>`__ of quaternions
   `v <#Quaternion>`__ and this one.

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - array of format (x, y, z, w) used to construct the quaternion.
   `offset <#Integer>`__ - (optional) an offset into the array.
   Sets this quaternion's ``x``, ``y``, ``z`` and ``w`` properties
   from an array.

📦:identity() this
~~~~~~~~~~~~~~~~~~~

   Sets this quaternion to the identity quaternion; that is, to the quaternion that
   represents "no rotation".

📦:invert() this
~~~~~~~~~~~~~~~~~

   Inverts this quaternion - calculates the ``conjugate``. The quaternion is
   assumed to have unit length.

📦:length() Float
~~~~~~~~~~~~~~~~~~

   Computes the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line length) of this quaternion, considered as a 4 dimensional vector.

📦:lengthSq() Float
~~~~~~~~~~~~~~~~~~~~

   Computes the squared `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__ 
   (straight-line length) of this quaternion, considered as a 4 dimensional vector.
   This can be useful if you are comparing the lengths of two quaternions, as this is a
   slightly more efficient calculation than ``length``().

📦:normalize() this
~~~~~~~~~~~~~~~~~~~~

   `Normalizes <https://en.wikipedia.org/wiki/Normalized_vector>`__ this quaternion - that
   is, calculated the quaternion that performs the same rotation as this one, but has
   ``length`` equal to ``1``.

📦:multiply( Quaternion q ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this quaternion by `q <#Quaternion>`__.

📦:multiplyQuaternions( Quaternion a, Quaternion b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this quaternion to `a <#Quaternion>`__ x `b <#Quaternion>`__.
   Adapted from the method outlined
   `here <http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.html>`__.

📦:premultiply( Quaternion q ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Pre-multiplies this quaternion by `q <#Quaternion>`__.

📦:random() this
~~~~~~~~~~~~~~~~~

   Sets this quaternion to a uniformly random, normalized quaternion.

📦:rotateTowards( Quaternion q, Float step ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `q <#Quaternion>`__ - The target quaternion.
   `step <#Float>`__ - The angular step in radians.
   Rotates this quaternion by a given angular step to the defined quaternion ``q``. The
   method ensures that the final quaternion will not overshoot ``q``.

📦:slerp( Quaternion qb, Float t ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `qb <#Quaternion>`__ - The other quaternion rotation
   `t <#Float>`__ - interpolation factor in the closed interval ``[0, 1]``.
   Handles the spherical linear interpolation between quaternions. `t <#Float>`__
   represents the amount of rotation between this quaternion (where `t <#Float>`__ is 0)
   and `qb <#Quaternion>`__ (where `t <#Float>`__ is 1). This quaternion is set to the
   result. Also see the static version of the ``slerp`` below.

   .. code:: javascript

      // rotate a mesh towards a target quaternion mesh.quaternion.slerp( endQuaternion, 0.01 );


📦:slerpQuaternions( Quaternion qa, Quaternion qb, Float t ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Performs a spherical linear interpolation between the given quaternions and stores the
   result in this quaternion.

📦:set( Float x, Float y, Float z, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets ``x``, ``y``, ``z``, ``w`` properties of this quaternion.

📦:setFromAxisAngle( Vector3 axis, Float angle ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this quaternion from rotation specified by `axis <#Vector3>`__ and `angle <#Float>`__.
   Adapted from the method
   `here <http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.html>`__.
   ``Axis`` is assumed to be normalized, ``angle`` is in radians.

📦:setFromEuler( Euler euler ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this quaternion from the rotation specified by ``Euler`` angle.

📦:setFromRotationMatrix( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `m <#Matrix4>`__ - a ``Matrix4`` of which the upper 3x3 of matrix is a pure
   `rotation matrix <https://en.wikipedia.org/wiki/Rotation_matrix>`__ (i.e. unscaled).
   Sets this quaternion from rotation component of `m <#Matrix4>`__.
   Adapted from the method
   `here <http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.html>`__.

📦:setFromUnitVectors( Vector3 vFrom, Vector3 vTo ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this quaternion to the rotation required to rotate direction vector `vFrom <#Vector3>`__ 
   to direction vector `vTo <#Vector3>`__.
   Adapted from the method
   `here <http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors>`__.
   `vFrom <#Vector3>`__ and `vTo <#Vector3>`__ are assumed to be normalized.

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - An optional array to store the quaternion. If not specified, a new
   array will be created.
   `offset <#Integer>`__ - (optional) if specified, the result will be copied into this
   ``Array``.
   Returns the numerical elements of this quaternion in an array of format [x, y, z, w].

📦:toJSON() Array
~~~~~~~~~~~~~~~~~~

   This methods defines the serialization result of ``Quaternion``. Returns the numerical elements of
   this quaternion in an array of format [x, y, z, w].

📦:fromBufferAttribute( BufferAttribute attribute, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `attribute <#BufferAttribute>`__ - the source attribute.
   `index <#Integer>`__ - index in the attribute.
   Sets ``x``, ``y``, ``z``, ``w`` properties of this quaternion
   from the `attribute <#BufferAttribute>`__.

Static Methods
--------------

📦:slerpFlat( Array dst, Integer dstOffset, Array src0, Integer srcOffset0, Array src1, Integer srcOffset1, Float t ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `dst <#Array>`__ - The output array.
   `dstOffset <#Integer>`__ - An offset into the output array.
   `src0 <#Array>`__ - The source array of the starting quaternion.
   `srcOffset0 <#Integer>`__ - An offset into the array ``src0``.
   `src1 <#Array>`__ - The source array of the target quaternion.
   `srcOffset1 <#Integer>`__ - An offset into the array ``src1``.
   `t <#Float>`__ - Normalized interpolation factor (between ``0`` and ``1``).
   This SLERP implementation assumes the quaternion data are managed in flat arrays.

📦:multiplyQuaternionsFlat( Array dst, Integer dstOffset, Array src0, Integer srcOffset0, Array src1, Integer srcOffset1 ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `dst <#Array>`__ - The output array.
   `dstOffset <#Integer>`__ - An offset into the output array.
   `src0 <#Array>`__ - The source array of the starting quaternion.
   `srcOffset0 <#Integer>`__ - An offset into the array ``src0``.
   `src1 <#Array>`__ - The source array of the target quaternion.
   `srcOffset1 <#Integer>`__ - An offset into the array ``src1``.
   This multiplication implementation assumes the quaternion data are managed in flat
   arrays.



.. _D180:

Ray
===

   https://threejs.org/docs/api/en/math/Ray.html

   A ray that emits from an origin in a certain direction. This is used by the
   ``Raycaster`` to assist with `raycasting <https://en.wikipedia.org/wiki/Ray_casting>`__. Raycasting is used for mouse picking (working out what objects in the 3D
   space the mouse is over) amongst other things.

   .. Constructor

🐣:Ray( Vector3 origin, Vector3 direction )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `origin <#Vector3>`__ - (optional) the origin of the ``Ray``. Default is a
   ``Vector3`` at (0, 0, 0).
   `direction <#Vector3>`__ - ``Vector3`` The direction of the ``Ray``. This must be
   normalized (with ``Vector3.normalize``) for the methods to operate properly.
   Default is a ``Vector3`` at (0, 0, -1).
   Creates a new ``Ray``.

Properties
----------

⭕:Vector3 origin
~~~~~~~~~~~~~~~~~~

   The origin of the ``Ray``. Default is a ``Vector3`` at ``(0, 0, 0)``.

⭕:Vector3 direction
~~~~~~~~~~~~~~~~~~~~~

   The direction of the ``Ray``. This must be normalized (with ``Vector3.normalize``)
   for the methods to operate properly. Default is a ``Vector3`` at (0, 0, -1).

Methods
-------

📦:applyMatrix4( Matrix4 matrix4 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `matrix4 <#Matrix4>`__ - the ``Matrix4`` to apply to this ``Ray``.
   Transform this ``Ray`` by the ``Matrix4``.

📦:at( Float t, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `t <#Float>`__ - the distance along the ``Ray`` to retrieve a position for.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Get a ``Vector3`` that is a given distance along this ``Ray``.

📦:clone() Ray
~~~~~~~~~~~~~~~

   Creates a new Ray with identical ``origin`` and ``direction`` to
   this one.

📦:closestPointToPoint( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - the point to get the closest approach to.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Get the point along this ``Ray`` that is closest to the ``Vector3`` provided.

📦:copy( Ray ray ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the ``origin`` and ``direction`` properties of `ray <#Ray>`__ into this ray.

📦:distanceSqToPoint( Vector3 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - the ``Vector3`` to compute a distance to.
   Get the squared distance of the closest approach between the ``Ray`` and the
   ``Vector3``.

📦:distanceSqToSegment( Vector3 v0, Vector3 v1, Vector3 optionalPointOnRay, Vector3 optionalPointOnSegment ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v0 <#Vector3>`__ - the start of the line segment.
   `v1 <#Vector3>`__ - the end of the line segment.
   optionalPointOnRay - (optional) if this is provided, it receives the point on this
   ``Ray`` that is closest to the segment.
   optionalPointOnSegment - (optional) if this is provided, it receives the point on the
   line segment that is closest to this ``Ray``.
   Get the squared distance between this ``Ray`` and a line segment.

📦:distanceToPlane( Plane plane ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ - the ``Plane`` to get the distance to.
   Get the distance from ``origin`` to the ``Plane``, or ``null`` if the
   ``Ray`` doesn't intersect the ``Plane``.

📦:distanceToPoint( Vector3 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` The ``Vector3`` to compute a distance to.
   Get the distance of the closest approach between the ``Ray`` and the `point <#Vector3>`__.

📦:equals( Ray ray ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `ray <#Ray>`__ - the ``Ray`` to compare to.
   Returns true if this and the other `ray <#Ray>`__ have equal ``origin`` and
   ``direction``.

📦:intersectBox( Box3 box, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - the ``Box3`` to intersect with.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Intersect this ``Ray`` with a ``Box3``, returning the intersection point or
   ``null`` if there is no intersection.

📦:intersectPlane( Plane plane, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ - the ``Plane`` to intersect with.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Intersect this ``Ray`` with a ``Plane``, returning the intersection point or
   ``null`` if there is no intersection.

📦:intersectSphere( Sphere sphere, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - the ``Sphere`` to intersect with.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Intersect this ``Ray`` with a ``Sphere``, returning the intersection point or
   ``null`` if there is no intersection.

📦:intersectTriangle( Vector3 a, Vector3 b, Vector3 c, Boolean backfaceCulling, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `a <#Vector3>`__, `b <#Vector3>`__, `c <#Vector3>`__ - The ``Vector3`` points making
   up the triangle.
   `backfaceCulling <#Boolean>`__ - whether to use backface culling.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Intersect this ``Ray`` with a triangle, returning the intersection point or ``null``
   if there is no intersection.

📦:intersectsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - the ``Box3`` to intersect with.
   Return true if this ``Ray`` intersects with the ``Box3``.

📦:intersectsPlane( Plane plane ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ - the ``Plane`` to intersect with.
   Return true if this ``Ray`` intersects with the ``Plane``.

📦:intersectsSphere( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - the ``Sphere`` to intersect with.
   Return true if this ``Ray`` intersects with the ``Sphere``.

📦:lookAt( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v <#Vector3>`__ - The ``Vector3`` to look at.
   Adjusts the direction of the ray to point at the vector in world coordinates.

📦:recast( Float t ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   `t <#Float>`__ - The distance along the ``Ray`` to interpolate.
   Shift the origin of this ``Ray`` along its direction by the distance given.

📦:set( Vector3 origin, Vector3 direction ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `origin <#Vector3>`__ - the ``origin`` of the ``Ray``.
   `direction <#Vector3>`__ - the ``direction`` of the ``Ray``. This must
   be normalized (with ``Vector3.normalize``) for the methods to operate properly.
   Sets this ray's ``origin`` and ``direction`` properties by
   copying the values from the given objects.



.. _D181:

Sphere
======

   https://threejs.org/docs/api/en/math/Sphere.html

   A sphere defined by a center and radius.

   .. Constructor

🐣:Sphere( Vector3 center, Float radius )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector3>`__ - center of the sphere. Default is a ``Vector3`` at \`(0, 0,
   0)``.
   `radius <#Float>`__ - radius of the sphere. Default is ``-1``.
   Creates a new ``Sphere``.

Properties
----------

⭕:Vector3 center
~~~~~~~~~~~~~~~~~~

   A ``Vector3`` defining the center of the sphere. Default is ``(0, 0, 0)``.

⭕:Boolean isSphere
~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Sphere``.

⭕:Float radius
~~~~~~~~~~~~~~~~

   The radius of the sphere. Default is -1.

Methods
-------

📦:applyMatrix4( Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `matrix <#Matrix4>`__ - the [Page:Matrix4] to apply
   Transforms this sphere with the provided ``Matrix4``.

📦:clampPoint( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` The point to clamp.
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Clamps a point within the sphere. If the point is outside the sphere, it will clamp it
   to the closest point on the edge of the sphere. Points already inside the sphere will
   not be affected.

📦:clone() Sphere
~~~~~~~~~~~~~~~~~~

   Returns a new sphere with the same ``center`` and ``radius`` as this
   one.

📦:containsPoint( Vector3 point ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - the ``Vector3`` to be checked
   Checks to see if the sphere contains the provided `point <#Vector3>`__ inclusive of the
   surface of the sphere.

📦:copy( Sphere sphere ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed sphere's ``center`` and ``radius``
   properties to this sphere.

📦:distanceToPoint( Vector3 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the closest distance from the boundary of the sphere to the `point <#Vector3>`__.
   If the sphere contains the point, the distance will be negative.

📦:expandByPoint( Vector3 point ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` that should be included in the sphere.
   Expands the boundaries of this sphere to include `point <#Vector3>`__.

📦:isEmpty() Boolean
~~~~~~~~~~~~~~~~~~~~~

   Checks to see if the sphere is empty (the radius set to a negative number).
   Spheres with a radius of ``0`` contain only their center point and are not considered to
   be empty.

📦:makeEmpty() this
~~~~~~~~~~~~~~~~~~~~

   Makes the sphere empty by setting ``center`` to (0, 0, 0) and 
   ``radius`` to -1.

📦:equals( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Checks to see if the two spheres' centers and radii are equal.

📦:getBoundingBox( Box3 target ) Box3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Box3>`__ — the result will be copied into this Box3.
   Returns a`Minimum Bounding Box <https://en.wikipedia.org/wiki/Minimum_bounding_box>`__
   for the sphere.

📦:intersectsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - ``Box3`` to check for intersection against.
   Determines whether or not this sphere intersects a given `box <#Box3>`__.

📦:intersectsPlane( Plane plane ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ - Plane to check for intersection against.
   Determines whether or not this sphere intersects a given `plane <#Plane>`__.

📦:intersectsSphere( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - Sphere to check for intersection against.
   Checks to see if two spheres intersect.

📦:set( Vector3 center, Float radius ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector3>`__ - center of the sphere.
   `radius <#Float>`__ - radius of the sphere.
   Sets the ``center`` and ``radius`` properties of this sphere.
   Please note that this method only copies the values from the given center.

📦:setFromPoints( Array points, Vector3 optionalCenter ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `points <#Array>`__ - an ``Array`` of ``Vector3`` positions.
   `optionalCenter <#Vector3>`__ - Optional ``Vector3`` position for the sphere's
   center.
   Computes the minimum bounding sphere for an array of `points <#Array>`__. If
   `optionalCenter <#Vector3>`__is given, it is used as the sphere's center. Otherwise, the
   center of the axis-aligned bounding box encompassing `points <#Array>`__ is calculated.

📦:translate( Vector3 offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Translate the sphere's center by the provided offset ``Vector3``.

📦:union( Sphere sphere ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ - Bounding sphere that will be unioned with this sphere.
   Expands this sphere to enclose both the original sphere and the given sphere.



.. _D182:

Spherical
=========

   https://threejs.org/docs/api/en/math/Spherical.html

   A point's `spherical coordinates <https://en.wikipedia.org/wiki/Spherical_coordinate_system>`__.

   .. Constructor

🐣:Spherical( Float radius, Float phi, Float theta )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `radius <#Float>`__ - the radius, or the
   `Euclidean distance <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line distance) from the point to the origin. Default is ``1.0``.
   `phi <#Float>`__ - polar angle in radians from the y (up) axis. Default is ``0``.
   `theta <#Float>`__ - equator angle in radians around the y (up) axis. Default is ``0``.
   The poles (phi) are at the positive and negative y axis. The equator (theta) starts at
   positive z.

Properties
----------

⭕:Float radius
~~~~~~~~~~~~~~~~

⭕:Float phi
~~~~~~~~~~~~~

⭕:Float theta
~~~~~~~~~~~~~~~

Methods
-------

📦:clone() Spherical
~~~~~~~~~~~~~~~~~~~~~

   Returns a new spherical with the same ``radius``, ``phi`` and
   ``theta`` properties as this one.

📦:copy( Spherical s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed Spherical's ``radius``, ``phi`` and
   ``theta`` properties to this spherical.

📦:makeSafe() this
~~~~~~~~~~~~~~~~~~~

   Restricts the polar angle ``phi`` to be between 0.000001 and pi - 0.000001.

📦:set( Float radius, Float phi, Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets values of this spherical's ``radius``, ``phi`` and 
   ``theta`` properties.

📦:setFromVector3( Vector3 vec3 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets values of this spherical's ``radius``, ``phi`` and 
   ``theta`` properties from the `Vector3 <#Vector3>`__.

📦:setFromCartesianCoords( Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets values of this spherical's ``radius``, ``phi`` and 
   ``theta`` properties from Cartesian coordinates.



.. _D183:

SphericalHarmonics3
===================

   https://threejs.org/docs/api/en/math/SphericalHarmonics3.html

   Represents a third-order spherical harmonics (SH). Light probes use this class to encode
   lighting information.

   .. Constructor


🐣:SphericalHarmonics3()
~~~~~~~~~~~~~~~~~~~~~~~

   Creates a new instance of ``SphericalHarmonics3``.

Properties
----------

⭕:Array coefficients
~~~~~~~~~~~~~~~~~~~~~~

   An array holding the (9) SH coefficients. A single coefficient is represented as an
   instance of ``Vector3``.

⭕:Boolean isSphericalHarmonics3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``SphericalHarmonics3``.

Methods
-------

📦:add( SphericalHarmonics3 sh ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sh <#SphericalHarmonics3>`__ - The SH to add.
   Adds the given SH to this instance.

📦:addScaledSH( SphericalHarmonics3 sh, Number scale ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sh <#SphericalHarmonics3>`__ - The SH to add.
   `scale <#Number>`__ - The scale factor.
   A convenience method for performing ``.add``() and ``.scale``() at once.

📦:clone() SphericalHarmonics3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a new instance of ``SphericalHarmonics3`` with equal coefficients.

📦:copy( SphericalHarmonics3 sh ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sh <#SphericalHarmonics3>`__ - The SH to copy.
   Copies the given SH to this instance.

📦:equals( SphericalHarmonics3 sh ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sh <#SphericalHarmonics3>`__ - The SH to compare with.
   Returns true if the given SH and this instance have equal coefficients.

📦:fromArray( Array array, Number offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - The array holding the numbers of the SH coefficients.
   `offset <#Number>`__ - (optional) The array offset.
   Sets the coefficients of this instance from the given array.

📦:getAt( Vector3 normal, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - The normal vector (assumed to be unit length).
   `target <#Vector3>`__ - The result vector.
   Returns the radiance in the direction of the given normal.

📦:getIrradianceAt( Vector3 normal, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - The normal vector (assumed to be unit length).
   `target <#Vector3>`__ - The result vector.
   Returns the irradiance (radiance convolved with cosine lobe) in the direction of the
   given normal.

📦:lerp( SphericalHarmonics3 sh, Number alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sh <#SphericalHarmonics3>`__ - The SH to interpolate with.
   `alpha <#Number>`__ - The alpha factor.
   Linear interpolates between the given SH and this instance by the given alpha factor.

📦:scale( Number scale ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scale <#Number>`__ - The scale factor.
   Scales this SH by the given scale factor.

📦:set( Array coefficients ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `coefficients <#Array>`__ - An array of SH coefficients.
   Sets the given SH coefficients to this instance.

📦:toArray( Array array, Number offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) The target array.
   `offset <#Number>`__ - (optional) The array offset.
   Returns an array with the coefficients, or copies them into the provided array. The
   coefficients are represented as numbers.

📦:zero() this
~~~~~~~~~~~~~~~

   Sets all SH coefficients to ``0``.

Static Methods
--------------

📦:getBasisAt( Vector3 normal, Array shBasis ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - The normal vector (assumed to be unit length).
   `shBasis <#Array>`__ - The resulting SH basis.
   Computes the SH basis for the given normal vector.



.. _D184:

Triangle
========

   https://threejs.org/docs/api/en/math/Triangle.html

   A geometric triangle as defined by three `Vector3s <#Vector3>`__ representing its three
   corners.

   .. Constructor

🐣:Triangle( Vector3 a, Vector3 b, Vector3 c )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   - `a` - the first corner of the triangle. Default is a ``Vector3`` at ``(0, 0, 0)``.
   - `b` - the second corner of the triangle. Default is a ``Vector3`` at ``(0, 0, 0)``.
   - `c` - the final corner of the triangle. Default is a ``Vector3`` at ``(0, 0, 0)``.
   Creates a new ``Triangle``.

Properties
----------

⭕:Vector3 a
~~~~~~~~~~~~~

   The first corner of the triangle. Default is a ``Vector3`` at ``(0, 0, 0)``.

⭕:Vector3 b
~~~~~~~~~~~~~

   The second corner of the triangle. Default is a ``Vector3`` at ``(0, 0, 0)``.

⭕:Vector3 c
~~~~~~~~~~~~~

   The final corner of the triangle. Default is a ``Vector3`` at ``(0, 0, 0)``.

Methods
-------

📦:clone() Triangle
~~~~~~~~~~~~~~~~~~~~

   Returns a new triangle with the same ``a``, ``b`` and ``c`` properties
   as this one.

📦:closestPointToPoint( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3``
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Returns the closest point on the triangle to `point <#Vector3>`__.

📦:containsPoint( Vector3 point ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` to check.
   Returns true if the passed point, when projected onto the plane of the triangle, lies
   within the triangle.

📦:copy( Triangle triangle ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed triangles's ``a``, ``b`` and ``c``
   properties to this triangle.

📦:equals( Triangle triangle ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns true if the two triangles have identical ``a``, ``b`` and ``c``
   properties.

📦:getArea() Float
~~~~~~~~~~~~~~~~~~~

   Return the area of the triangle.

📦:getBarycoord( Vector3 point, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3``
   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Return a `barycentric coordinate <https://en.wikipedia.org/wiki/Barycentric_coordinate_system>`__ 
   from the given vector. Returns ``null`` if the triangle is degenerate.
   `Picture of barycentric coordinates <http://commons.wikimedia.org/wiki/File:Barycentric_coordinates_1.png>`__

📦:getMidpoint( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Calculate the midpoint of the triangle.

📦:getNormal( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__ — the result will be copied into this Vector3.
   Calculate the `normal vector <https://en.wikipedia.org/wiki/Normal_(geometry)>`__ of
   the triangle.

📦:getPlane( Plane target ) Plane
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Plane>`__ — the result will be copied into this Plane.
   Calculate a `plane <#Plane>`__ based on the triangle. .

📦:getInterpolation( Vector3 point, Vector3 p1, Vector3 p2, Vector3 p3, Vector v1, Vector v2, Vector v3, Vector target ) Vector
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - Position of interpolated point.
   `p1 <#Vector3>`__ - Position of first vertex.
   `p2 <#Vector3>`__ - Position of second vertex.
   `p3 <#Vector3>`__ - Position of third vertex.
   `v1 <#Vector>`__ - Value of first vertex.
   `v2 <#Vector>`__ - Value of second vertex.
   `v3 <#Vector>`__ - Value of third vertex.
   `target <#Vector>`__ — Result will be copied into this Vector.
   Returns the value barycentrically interpolated for the given point on the triangle.
   Returns ``null`` if the triangle is degenerate.

📦:intersectsBox( Box3 box ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box <#Box3>`__ - Box to check for intersection against.
   Determines whether or not this triangle intersects `box <#Box3>`__.

📦:isFrontFacing( Vector3 direction ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `direction <#Vector3>`__ - The direction to test.
   Whether the triangle is oriented towards the given direction or not.

📦:set( Vector3 a, Vector3 b, Vector3 c ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the triangle's ``a``, ``b`` and ``c`` properties to the passed
   `vector3s <#Vector3>`__.
   Please note that this method only copies the values from the given objects.

📦:setFromAttributeAndIndices( BufferAttribute attribute, Integer i0, Integer i1, Integer i2 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   attribute - ``BufferAttribute`` of vertex data
   i0 - ``Integer`` index
   i1 - ``Integer`` index
   i2 - ``Integer`` index
   Sets the triangle's vertices from the buffer attribute vertex data.

📦:setFromPointsAndIndices( Array points, Integer i0, Integer i1, Integer i2 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points - ``Array`` of ``Vector3``s
   i0 - ``Integer`` index
   i1 - ``Integer`` index
   i2 - ``Integer`` index
   Sets the triangle's vectors to the vectors in the array.



.. _D185:

Vector2
=======

   https://threejs.org/docs/api/en/math/Vector2.html

   Class representing a 2D `vector <https://en.wikipedia.org/wiki/Vector_space>`__. A 2D
   vector is an ordered pair of numbers (labeled x and y), which can be used to represent a
   number of things, such as:

   -  A point in 2D space (i.e. a position on a plane).
   -  A direction and length across a plane. In three.js the length will always be the
      `Euclidean distance <https://en.wikipedia.org/wiki/Euclidean_distance>`__
      (straight-line distance) from ``(0, 0)`` to ``(x, y)`` and the direction is also
      measured from ``(0, 0)`` towards ``(x, y)``.
   -  Any arbitrary ordered pair of numbers.

   There are other things a 2D vector can be used to represent, such as momentum vectors,
   complex numbers and so on, however these are the most common uses in three.js.

   Iterating through a ``Triangle`` instance will yield its components ``(x, y)`` in the
   corresponding order.

   **Code Example**


   .. code:: javascript

      const a = new THREE.Vector2( 0, 1 );
      //no arguments; will be initialised to (0, 0) 
      const b = new THREE.Vector2( );
      const d = a.distanceTo( b );


   .. Constructor

🐣:Vector2( Float x, Float y )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - the x value of this vector. Default is ``0``.
   `y <#Float>`__ - the y value of this vector. Default is ``0``.
   Creates a new ``Vector2``.

Properties
----------

⭕:Float height
~~~~~~~~~~~~~~~~

   Alias for ``y``.

⭕:Boolean isVector2
~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Vector2``.

⭕:Float width
~~~~~~~~~~~~~~~

   Alias for ``x``.

⭕:Float x
~~~~~~~~~~~

⭕:Float y
~~~~~~~~~~~

Methods
-------

📦:add( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds `v <#Vector2>`__ to this vector.

📦:addScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the scalar value `s <#Float>`__ to this vector's ``x`` and ``y`` values.

📦:addScaledVector( Vector2 v, Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the multiple of `v <#Vector2>`__ and `s <#Float>`__ to this vector.

📦:addVectors( Vector2 a, Vector2 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `a <#Vector2>`__ + `b <#Vector2>`__.

📦:angle() Float
~~~~~~~~~~~~~~~~~

   Computes the angle in radians of this vector with respect to the positive x-axis.

📦:angleTo( Vector2 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the angle between this vector and vector `v <#Vector2>`__ in radians.

📦:applyMatrix3( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector (with an implicit 1 as the 3rd component) by m.

📦:ceil() this
~~~~~~~~~~~~~~~

   The ``x`` and ``y`` components of this vector are rounded up to the nearest
   integer value.

📦:clamp( Vector2 min, Vector2 max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector2>`__ - the minimum x and y values.
   `max <#Vector2>`__ - the maximum x and y values in the desired range
   If this vector's x or y value is greater than the max vector's x or y value, it is
   replaced by the corresponding value.
   If this vector's x or y value is less than the min vector's x or y value, it is replaced
   by the corresponding value.

📦:clampLength( Float min, Float max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Float>`__ - the minimum value the length will be clamped to
   `max <#Float>`__ - the maximum value the length will be clamped to
   If this vector's length is greater than the max value, it is replaced by the max value.
   If this vector's length is less than the min value, it is replaced by the min value.

📦:clampScalar( Float min, Float max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Float>`__ - the minimum value the components will be clamped to
   `max <#Float>`__ - the maximum value the components will be clamped to
   If this vector's x or y values are greater than the max value, they are replaced by the
   max value.
   If this vector's x or y values are less than the min value, they are replaced by the min
   value.

📦:clone() Vector2
~~~~~~~~~~~~~~~~~~~

   Returns a new Vector2 with the same ``x`` and ``y`` values as this one.

📦:copy( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed Vector2's ``x`` and ``y`` properties to this
   Vector2.

📦:distanceTo( Vector2 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the distance from this vector to `v <#Vector2>`__.

📦:manhattanDistanceTo( Vector2 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the `Manhattan distance <https://en.wikipedia.org/wiki/Taxicab_geometry>`__ from
   this vector to `v <#Vector2>`__.

📦:distanceToSquared( Vector2 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the squared distance from this vector to `v <#Vector2>`__. If you are just
   comparing the distance with another distance, you should compare the distance squared
   instead as it is slightly more efficient to calculate.

📦:divide( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Divides this vector by `v <#Vector2>`__.

📦:divideScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Divides this vector by scalar `s <#Float>`__.

📦:dot( Vector2 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Calculates the `dot product <https://en.wikipedia.org/wiki/Dot_product>`__ of this vector
   and `v <#Vector2>`__.

📦:cross( Vector2 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Calculates the `cross product <https://en.wikipedia.org/wiki/Cross_product>`__ of this
   vector and `v <#Vector2>`__. Note that a 'cross-product' in 2D is not well-defined. This
   function computes a geometric cross-product often used in 2D graphics

📦:equals( Vector2 v ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns ``true`` if the components of this vector and `v <#Vector2>`__ are strictly equal;
   ``false`` otherwise.

📦:floor() this
~~~~~~~~~~~~~~~~

   The components of this vector are rounded down to the nearest integer value.

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - the source array.
   `offset <#Integer>`__ - (optional) offset into the array. Default is ``0``.
   Sets this vector's ``x`` value to be ``array[ offset ]`` and ``y`` value to
   be ``array[ offset + 1 ]``.

📦:fromBufferAttribute( BufferAttribute attribute, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `attribute <#BufferAttribute>`__ - the source attribute.
   `index <#Integer>`__ - index in the attribute.
   Sets this vector's ``x`` and ``y`` values from the `attribute <#BufferAttribute>`__.

📦:getComponent( Integer index ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ - ``0`` or ``1``.
   If index equals ``0`` returns the ``x`` value.
   If index equals ``1`` returns the ``y`` value.

📦:length() Float
~~~~~~~~~~~~~~~~~~

   Computes the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line length) from (0, 0) to (x, y).

📦:manhattanLength() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the `Manhattan length <http://en.wikipedia.org/wiki/Taxicab_geometry>`__ of this
   vector.

📦:lengthSq() Float
~~~~~~~~~~~~~~~~~~~~

   Computes the square of the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__ 
   (straight-line length) from (0, 0) to (x, y). If you are comparing the
   lengths of vectors, you should compare the length squared instead as it is slightly more
   efficient to calculate.

📦:lerp( Vector2 v, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v <#Vector2>`__ - ``Vector2`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Linearly interpolates between this vector and `v <#Vector2>`__, where alpha is the
   percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be
   `v <#Vector2>`__.

📦:lerpVectors( Vector2 v1, Vector2 v2, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v1 <#Vector2>`__ - the starting ``Vector2``.
   `v2 <#Vector2>`__ - ``Vector2`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Sets this vector to be the vector linearly interpolated between `v1 <#Vector2>`__ and
   `v2 <#Vector2>`__ where alpha is the percent distance along the line connecting the two
   vectors - alpha = 0 will be `v1 <#Vector2>`__, and alpha = 1 will be `v2 <#Vector2>`__.

📦:negate() this
~~~~~~~~~~~~~~~~~

   Inverts this vector - i.e. sets x = -x and y = -y.

📦:normalize() this
~~~~~~~~~~~~~~~~~~~~

   Converts this vector to a `unit vector <https://en.wikipedia.org/wiki/Unit_vector>`__ -
   that is, sets it equal to a vector with the same direction as this one, but 
   ``length`` 1.

📦:max( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   If this vector's x or y value is less than `v <#Vector2>`__'s x or y value, replace that
   value with the corresponding max value.

📦:min( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   If this vector's x or y value is greater than `v <#Vector2>`__'s x or y value, replace
   that value with the corresponding min value.

📦:multiply( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by `v <#Vector2>`__.

📦:multiplyScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by scalar `s <#Float>`__.

📦:rotateAround( Vector2 center, Float angle ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector2>`__ - the point around which to rotate.
   `angle <#Float>`__ - the angle to rotate, in radians.
   Rotates this vector around `center <#Vector2>`__ by `angle <#Float>`__ radians.

📦:round() this
~~~~~~~~~~~~~~~~

   The components of this vector are rounded to the nearest integer value.

📦:roundToZero() this
~~~~~~~~~~~~~~~~~~~~~~

   The components of this vector are rounded towards zero (up if negative, down if positive)
   to an integer value.

📦:set( Float x, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``x`` and ``y`` components of this vector.

📦:setComponent( Integer index, Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ - ``0`` or ``1``.
   `value <#Float>`__ - ``Float``
   If index equals ``0`` set ``x`` to `value <#Float>`__.
   If index equals ``1`` set ``y`` to `value <#Float>`__

📦:setLength( Float l ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to a vector with the same direction as this one, but 
   ``length`` `l <#Float>`__.

📦:setScalar( Float scalar ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``x`` and ``y`` values of this vector both equal to `scalar <#Float>`__.

📦:setX( Float x ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replaces this vector's ``x`` value with `x <#Float>`__.

📦:setY( Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replaces this vector's ``y`` value with `y <#Float>`__.

📦:sub( Vector2 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts `v <#Vector2>`__ from this vector.

📦:subScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts `s <#Float>`__ from this vector's ``x`` and ``y`` components.

📦:subVectors( Vector2 a, Vector2 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `a <#Vector2>`__ - `b <#Vector2>`__.

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) array to store this vector to. If this is not provided,
   a new array will be created.
   `offset <#Integer>`__ - (optional) optional offset into the array.
   Returns an array [x, y], or copies x and y into the provided `array <#Array>`__.

📦:random() this
~~~~~~~~~~~~~~~~~

   Sets each component of this vector to a pseudo-random value between ``0`` and ``1``,
   excluding ``1``.



.. _D186:

Vector3
=======

   https://threejs.org/docs/api/en/math/Vector3.html

   Class representing a 3D `vector <https://en.wikipedia.org/wiki/Vector_space>`__. A 3D
   vector is an ordered triplet of numbers (labeled x, y, and z), which can be used to
   represent a number of things, such as:

   -  A point in 3D space.
   -  A direction and length in 3D space. In three.js the length will always be the
      `Euclidean distance <https://en.wikipedia.org/wiki/Euclidean_distance>`__
      (straight-line distance) from ``(0, 0, 0)`` to ``(x, y, z)`` and the direction is also
      measured from ``(0, 0, 0)`` towards ``(x, y, z)``.
   -  Any arbitrary ordered triplet of numbers.

   There are other things a 3D vector can be used to represent, such as momentum vectors and
   so on, however these are the most common uses in three.js.

   Iterating through a ``Vector2`` instance will yield its components ``(x, y, z)`` in the
   corresponding order.

   **Code Example**


   .. code:: javascript

      const a = new THREE.Vector3( 0, 1, 0 );
      //no arguments;
      will be initialised to (0, 0, 0) const b = new THREE.Vector3( );
      const d = a.distanceTo( b );


   .. Constructor

🐣:Vector3( Float x, Float y, Float z )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - the x value of this vector. Default is ``0``.
   `y <#Float>`__ - the y value of this vector. Default is ``0``.
   `z <#Float>`__ - the z value of this vector. Default is ``0``.
   Creates a new ``Vector3``.

Properties
----------

⭕:Boolean isVector3
~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Vector3``.

⭕:Float x
~~~~~~~~~~~

⭕:Float y
~~~~~~~~~~~

⭕:Float z
~~~~~~~~~~~

Methods
-------

📦:add( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds `v <#Vector3>`__ to this vector.

📦:addScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the scalar value s to this vector's ``x``, ``y`` and ``z`` values.

📦:addScaledVector( Vector3 v, Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the multiple of `v <#Vector3>`__ and `s <#Float>`__ to this vector.

📦:addVectors( Vector3 a, Vector3 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `a <#Vector3>`__ + `b <#Vector3>`__.

📦:applyAxisAngle( Vector3 axis, Float angle ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `axis <#Vector3>`__ - A normalized ``Vector3``.
   `angle <#Float>`__ - An angle in radians.
   Applies a rotation specified by an axis and an angle to this vector.

📦:applyEuler( Euler euler ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies euler transform to this vector by converting the ``Euler`` object to a
   ``Quaternion`` and applying.

📦:applyMatrix3( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by `m <#Matrix3>`__

📦:applyMatrix4( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and divides by
   perspective.

📦:applyNormalMatrix( Matrix3 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by normal matrix `m <#Matrix3>`__ and normalizes the result.

📦:applyQuaternion( Quaternion quaternion ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies a ``Quaternion`` transform to this vector.

📦:angleTo( Vector3 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the angle between this vector and vector `v <#Vector3>`__ in radians.

📦:ceil() this
~~~~~~~~~~~~~~~

   The ``x``, ``y`` and ``z`` components of this vector are rounded up to
   the nearest integer value.

📦:clamp( Vector3 min, Vector3 max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector3>`__ - the minimum ``x``, ``y`` and ``z`` values.
   `max <#Vector3>`__ - the maximum ``x``, ``y`` and ``z`` values in the
   desired range
   If this vector's x, y or z value is greater than the max vector's x, y or z value, it is
   replaced by the corresponding value.
   If this vector's x, y or z value is less than the min vector's x, y or z value, it is
   replaced by the corresponding value.

📦:clampLength( Float min, Float max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Float>`__ - the minimum value the length will be clamped to
   `max <#Float>`__ - the maximum value the length will be clamped to
   If this vector's length is greater than the max value, the vector will be scaled down so
   its length is the max value.
   If this vector's length is less than the min value, the vector will be scaled up so its
   length is the min value.

📦:clampScalar( Float min, Float max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Float>`__ - the minimum value the components will be clamped to
   `max <#Float>`__ - the maximum value the components will be clamped to
   If this vector's x, y or z values are greater than the max value, they are replaced by
   the max value.
   If this vector's x, y or z values are less than the min value, they are replaced by the
   min value.

📦:clone() Vector3
~~~~~~~~~~~~~~~~~~~

   Returns a new vector3 with the same ``x``, ``y`` and ``z`` values as
   this one.

📦:copy( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed vector3's ``x``, ``y`` and ``z``
   properties to this vector3.

📦:cross( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `cross product <https://en.wikipedia.org/wiki/Cross_product>`__ of
   itself and `v <#Vector3>`__.

📦:crossVectors( Vector3 a, Vector3 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `cross product <https://en.wikipedia.org/wiki/Cross_product>`__ of
   `a <#Vector3>`__ and `b <#Vector3>`__.

📦:distanceTo( Vector3 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the distance from this vector to `v <#Vector3>`__.

📦:manhattanDistanceTo( Vector3 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the `Manhattan distance <https://en.wikipedia.org/wiki/Taxicab_geometry>`__ from
   this vector to `v <#Vector3>`__.

📦:distanceToSquared( Vector3 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the squared distance from this vector to `v <#Vector3>`__. If you are just
   comparing the distance with another distance, you should compare the distance squared
   instead as it is slightly more efficient to calculate.

📦:divide( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Divides this vector by `v <#Vector3>`__.

📦:divideScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Divides this vector by scalar `s <#Float>`__.

📦:dot( Vector3 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Calculate the `dot product <https://en.wikipedia.org/wiki/Dot_product>`__ of this vector
   and `v <#Vector3>`__.

📦:equals( Vector3 v ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns ``true`` if the components of this vector and `v <#Vector3>`__ are strictly equal;
   ``false`` otherwise.

📦:floor() this
~~~~~~~~~~~~~~~~

   The components of this vector are rounded down to the nearest integer value.

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - the source array.
   `offset <#Integer>`__ - ( optional) offset into the array. Default is 0.
   Sets this vector's ``x`` value to be ``array[ offset + 0 ]``, ``y`` value to
   be ``array[ offset + 1 ]`` and ``z`` value to be ``array[ offset + 2 ]``.

📦:fromBufferAttribute( BufferAttribute attribute, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `attribute <#BufferAttribute>`__ - the source attribute.
   `index <#Integer>`__ - index in the attribute.
   Sets this vector's ``x``, ``y`` and ``z`` values from the
   `attribute <#BufferAttribute>`__.

📦:getComponent( Integer index ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ - ``0``, ``1`` or ``2``.
   If index equals ``0`` returns the ``x`` value.
   If index equals ``1`` returns the ``y`` value.
   If index equals ``2`` returns the ``z`` value.

📦:length() Float
~~~~~~~~~~~~~~~~~~

   Computes the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line length) from (0, 0, 0) to (x, y, z).

📦:manhattanLength() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the `Manhattan length <http://en.wikipedia.org/wiki/Taxicab_geometry>`__ of this
   vector.

📦:lengthSq() Float
~~~~~~~~~~~~~~~~~~~~

   Computes the square of the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__ 
   (straight-line length) from (0, 0, 0) to (x, y, z). If you are comparing
   the lengths of vectors, you should compare the length squared instead as it is slightly
   more efficient to calculate.

📦:lerp( Vector3 v, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v <#Vector3>`__ - ``Vector3`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Linearly interpolate between this vector and `v <#Vector3>`__, where alpha is the
   percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be
   `v <#Vector3>`__.

📦:lerpVectors( Vector3 v1, Vector3 v2, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v1 <#Vector3>`__ - the starting ``Vector3``.
   `v2 <#Vector3>`__ - ``Vector3`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Sets this vector to be the vector linearly interpolated between `v1 <#Vector3>`__ and
   `v2 <#Vector3>`__ where alpha is the percent distance along the line connecting the two
   vectors - alpha = 0 will be `v1 <#Vector3>`__, and alpha = 1 will be `v2 <#Vector3>`__.

📦:max( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   If this vector's x, y or z value is less than `v <#Vector3>`__'s x, y or z value, replace
   that value with the corresponding max value.

📦:min( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   If this vector's x, y or z value is greater than `v <#Vector3>`__'s x, y or z value,
   replace that value with the corresponding min value.

📦:multiply( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by `v <#Vector3>`__.

📦:multiplyScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by scalar `s <#Float>`__.

📦:multiplyVectors( Vector3 a, Vector3 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector equal to `a <#Vector3>`__ `` `b <#Vector3>`__, component-wise.

📦:negate() this
~~~~~~~~~~~~~~~~~

   Inverts this vector - i.e. sets x = -x, y = -y and z = -z.

📦:normalize() this
~~~~~~~~~~~~~~~~~~~~

   Convert this vector to a `unit vector <https://en.wikipedia.org/wiki/Unit_vector>`__ -
   that is, sets it equal to a vector with the same direction as this one, but 
   ``length`` 1.

📦:project( Camera camera ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__ — camera to use in the projection.
   Projects this vector from world space into the camera's normalized device coordinate
   (NDC) space.

📦:projectOnPlane( Vector3 planeNormal ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `planeNormal <#Vector3>`__ - A vector representing a plane normal.
   `Projects <https://en.wikipedia.org/wiki/Vector_projection>`__ this vector onto a plane
   by subtracting this vector projected onto the plane's normal from this vector.

📦:projectOnVector( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Projects <https://en.wikipedia.org/wiki/Vector_projection>`__ this vector onto
   `v <#Vector3>`__.

📦:reflect( Vector3 normal ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `normal <#Vector3>`__ - the normal to the reflecting plane
   Reflect this vector off of plane orthogonal to `normal <#Vector3>`__. Normal is assumed
   to have unit length.

📦:round() this
~~~~~~~~~~~~~~~~

   The components of this vector are rounded to the nearest integer value.

📦:roundToZero() this
~~~~~~~~~~~~~~~~~~~~~~

   The components of this vector are rounded towards zero (up if negative, down if positive)
   to an integer value.

📦:set( Float x, Float y, Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``x``, ``y`` and ``z`` components of this vector.

📦:setComponent( Integer index, Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ - ``0``, ``1`` or ``2``.
   `value <#Float>`__ - ``Float``
   If index equals ``0`` set ``x`` to `value <#Float>`__.
   If index equals ``1`` set ``y`` to `value <#Float>`__.
   If index equals ``2`` set ``z`` to `value <#Float>`__

📦:setFromColor( Color color ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector's ``x``, ``y`` and ``z`` components from the r, g, and
   b components of the specified `color <#Color>`__.

📦:setFromCylindrical( Cylindrical c ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector from the cylindrical coordinates `c <#Cylindrical>`__.

📦:setFromCylindricalCoords( Float radius, Float theta, Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector from the cylindrical coordinates `radius <#Cylindrical>`__,
   `theta <#Cylindrical>`__ and `y <#Cylindrical>`__.

📦:setFromEuler( Euler euler ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector's ``x``, ``y`` and ``z`` components from the x, y, and
   z components of the specified `Euler Angle <#Euler>`__.

📦:setFromMatrixColumn( Matrix4 matrix, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector's ``x``, ``y`` and ``z`` components from `index <#Integer>`__ 
   column of `matrix <#Matrix4>`__.

📦:setFromMatrix3Column( Matrix3 matrix, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector's ``x``, ``y`` and ``z`` components from `index <#Integer>`__ 
   column of `matrix <#Matrix3>`__.

📦:setFromMatrixPosition( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to the position elements of the
   `transformation matrix <https://en.wikipedia.org/wiki/Transformation_matrix>`__
   `m <#Matrix4>`__.

📦:setFromMatrixScale( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to the scale elements of the
   `transformation matrix <https://en.wikipedia.org/wiki/Transformation_matrix>`__
   `m <#Matrix4>`__.

📦:setFromSpherical( Spherical s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector from the spherical coordinates `s <#Spherical>`__.

📦:setFromSphericalCoords( Float radius, Float phi, Float theta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector from the spherical coordinates `radius <#Spherical>`__, 
   `phi <#Spherical>`__ and `theta <#Spherical>`__.

📦:setLength( Float l ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set this vector to a vector with the same direction as this one, but ``length``
   `l <#Float>`__.

📦:setScalar( Float scalar ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the ``x``, ``y`` and ``z`` values of this vector both equal to
   `scalar <#Float>`__.

📦:setX( Float x ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replace this vector's ``x`` value with `x <#Float>`__.

📦:setY( Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replace this vector's ``y`` value with `y <#Float>`__.

📦:setZ( Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replace this vector's ``z`` value with `z <#Float>`__.

📦:sub( Vector3 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts `v <#Vector3>`__ from this vector.

📦:subScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts `s <#Float>`__ from this vector's ``x``, ``y`` and ``z``
   components.

📦:subVectors( Vector3 a, Vector3 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `a <#Vector3>`__ - `b <#Vector3>`__.

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) array to store this vector to. If this is not provided a
   new array will be created.
   `offset <#Integer>`__ - (optional) optional offset into the array.
   Returns an array [x, y, z], or copies x, y and z into the provided `array <#Array>`__.

📦:transformDirection( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Transforms the direction of this vector by a matrix (the upper left 3 x 3 subset of a
   `m <#Matrix4>`__) and then `normalizes <#.normalize>`__ the result.

📦:unproject( Camera camera ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__ — camera to use in the projection.
   Projects this vector from the camera's normalized device coordinate (NDC) space into
   world space.

📦:random() this
~~~~~~~~~~~~~~~~~

   Sets each component of this vector to a pseudo-random value between ``0`` and ``1``,
   excluding ``1``.

📦:randomDirection() this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to a uniformly random point on a unit sphere.



.. _D187:

Vector4
=======

   https://threejs.org/docs/api/en/math/Vector4.html

   Class representing a 4D `vector <https://en.wikipedia.org/wiki/Vector_space>`__. A 4D
   vector is an ordered quadruplet of numbers (labeled x, y, z, and w), which can be used to
   represent a number of things, such as:

   -  A point in 4D space.
   -  A direction and length in 4D space. In three.js the length will always be the
      `Euclidean distance <https://en.wikipedia.org/wiki/Euclidean_distance>`__
      (straight-line distance) from ``(0, 0, 0, 0)`` to ``(x, y, z, w)`` and the direction is
      also measured from ``(0, 0, 0, 0)`` towards ``(x, y, z, w)``.
   -  Any arbitrary ordered quadruplet of numbers.

   There are other things a 4D vector can be used to represent, however these are the most
   common uses in three.js.

   Iterating through a ``Vector3`` instance will yield its components ``(x, y, z, w)`` in the
   corresponding order.

   **Code Example**


   .. code:: javascript

      const a = new THREE.Vector4( 0, 1, 0, 0 );
      //no arguments; will be initialised to (0, 0, 0, 1) 
      const b = new THREE.Vector4( );
      const d = a.dot( b );


   .. Constructor

🐣:Vector4( Float x, Float y, Float z, Float w )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `x <#Float>`__ - the x value of this vector. Default is ``0``.
   `y <#Float>`__ - the y value of this vector. Default is ``0``.
   `z <#Float>`__ - the z value of this vector. Default is ``0``.
   `w <#Float>`__ - the w value of this vector. Default is ``1``.
   Creates a new ``Vector4``.

Properties
----------

⭕:Boolean isVector4
~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Vector4``.

⭕:Float x
~~~~~~~~~~~

⭕:Float y
~~~~~~~~~~~

⭕:Float z
~~~~~~~~~~~

⭕:Float w
~~~~~~~~~~~

⭕:Float width
~~~~~~~~~~~~~~~

   Alias for ``z``.

⭕:Float height
~~~~~~~~~~~~~~~~

   Alias for ``w``.

Methods
-------

📦:add( Vector4 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds `v <#Vector4>`__ to this vector.

📦:addScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the scalar value s to this vector's ``x``, ``y``, ``z`` and
   ``w`` values.

📦:addScaledVector( Vector4 v, Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the multiple of `v <#Vector4>`__ and `s <#Float>`__ to this vector.

📦:addVectors( Vector4 a, Vector4 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `a <#Vector4>`__ + `b <#Vector4>`__.

📦:applyMatrix4( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by 4 x 4 `m <#Matrix4>`__.

📦:ceil() this
~~~~~~~~~~~~~~~

   The ``x``, ``y``, ``z`` and ``w`` components of this vector are
   rounded up to the nearest integer value.

📦:clamp( Vector4 min, Vector4 max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Vector4>`__ - the minimum ``x``, ``y``, ``z`` and ``w``
   values.
   `max <#Vector4>`__ - the maximum ``x``, ``y``, ``z`` and ``w``
   values in the desired range
   If this vector's x, y, z or w value is greater than the max vector's x, y, z or w value,
   it is replaced by the corresponding value.
   If this vector's x, y, z or w value is less than the min vector's x, y, z or w value, it
   is replaced by the corresponding value.

📦:clampLength( Float min, Float max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Float>`__ - the minimum value the length will be clamped to
   `max <#Float>`__ - the maximum value the length will be clamped to
   If this vector's length is greater than the max value, it is replaced by the max value.
   If this vector's length is less than the min value, it is replaced by the min value.

📦:clampScalar( Float min, Float max ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `min <#Float>`__ - the minimum value the components will be clamped to
   `max <#Float>`__ - the maximum value the components will be clamped to
   If this vector's x, y, z or w values are greater than the max value, they are replaced
   by the max value.
   If this vector's x, y, z or w values are less than the min value, they are replaced by
   the min value.

📦:clone() Vector4
~~~~~~~~~~~~~~~~~~~

   Returns a new Vector4 with the same ``x``, ``y``, ``z`` and ``w``
   values as this one.

📦:copy( Vector4 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the values of the passed Vector4's ``x``, ``y``, ``z`` and
   ``w`` properties to this Vector4.

📦:divideScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Divides this vector by scalar `s <#Float>`__.

📦:dot( Vector4 v ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Calculates the `dot product <https://en.wikipedia.org/wiki/Dot_product>`__ of this vector
   and `v <#Vector4>`__.

📦:equals( Vector4 v ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns ``true`` if the components of this vector and `v <#Vector4>`__ are strictly equal;
   ``false`` otherwise.

📦:floor() this
~~~~~~~~~~~~~~~~

   The components of this vector are rounded down to the nearest integer value.

📦:fromArray( Array array, Integer offset ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - the source array.
   `offset <#Integer>`__ - (optional) offset into the array. Default is ``0``.
   Sets this vector's ``x`` value to be ``array[ offset + 0 ]``, ``y`` value to
   be ``array[ offset + 1 ]`` ``z`` value to be ``array[ offset + 2 ]`` 
   and `w  <#.w>`__ value to be ``array[ offset + 3 ]``.

📦:fromBufferAttribute( BufferAttribute attribute, Integer index ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `attribute <#BufferAttribute>`__ - the source attribute.
   `index <#Integer>`__ - index in the attribute.
   Sets this vector's ``x``, ``y``, ``z`` and ``w`` values from the
   `attribute <#BufferAttribute>`__.

📦:getComponent( Integer index ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ - ``0``, ``1``, ``2`` or ``3``.
   If index equals ``0`` returns the ``x`` value.
   If index equals ``1`` returns the ``y`` value.
   If index equals ``2`` returns the ``z`` value.
   If index equals ``3`` returns the ``w`` value.

📦:length() Float
~~~~~~~~~~~~~~~~~~

   Computes the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line length) from ``(0, 0, 0, 0)`` to ``(x, y, z, w)``.

📦:manhattanLength() Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the `Manhattan length <http://en.wikipedia.org/wiki/Taxicab_geometry>`__ of this
   vector.

📦:lengthSq() Float
~~~~~~~~~~~~~~~~~~~~

   Computes the square of the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__ (straight-line length) from ``(0, 0, 0, 0)`` to ``(x, y, z, w)``. If you
   are comparing the lengths of vectors, you should compare the length squared instead as it
   is slightly more efficient to calculate.

📦:lerp( Vector4 v, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v <#Vector4>`__ - ``Vector4`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Linearly interpolates between this vector and `v <#Vector4>`__, where alpha is the
   percent distance along the line - ``alpha = 0`` will be this vector, and ``alpha = 1``
   will be `v <#Vector4>`__.

📦:lerpVectors( Vector4 v1, Vector4 v2, Float alpha ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `v1 <#Vector4>`__ - the starting ``Vector4``.
   `v2 <#Vector4>`__ - ``Vector4`` to interpolate towards.
   `alpha <#Float>`__ - interpolation factor, typically in the closed interval ``[0, 1]``.
   Sets this vector to be the vector linearly interpolated between `v1 <#Vector4>`__ and
   `v2 <#Vector4>`__ where alpha is the percent distance along the line connecting the two
   vectors - alpha = 0 will be `v1 <#Vector4>`__, and alpha = 1 will be `v2 <#Vector4>`__.

📦:negate() this
~~~~~~~~~~~~~~~~~

   Inverts this vector - i.e. sets x = -x, y = -y, z = -z and w = -w.

📦:normalize() this
~~~~~~~~~~~~~~~~~~~~

   Converts this vector to a `unit vector <https://en.wikipedia.org/wiki/Unit_vector>`__ -
   that is, sets it equal to a vector with the same direction as this one, but 
   ``length`` 1.

📦:max( Vector4 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   If this vector's x, y, z or w value is less than `v <#Vector4>`__'s x, y, z or w value,
   replace that value with the corresponding max value.

📦:min( Vector4 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   If this vector's x, y, z or w value is greater than `v <#Vector4>`__'s x, y, z or w value,
   replace that value with the corresponding min value.

📦:multiply( Vector4 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by `v <#Vector4>`__.

📦:multiplyScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Multiplies this vector by scalar `s <#Float>`__.

📦:round() this
~~~~~~~~~~~~~~~~

   The components of this vector are rounded to the nearest integer value.

📦:roundToZero() this
~~~~~~~~~~~~~~~~~~~~~~

   The components of this vector are rounded towards zero (up if negative, down if positive)
   to an integer value.

📦:set( Float x, Float y, Float z, Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``x``, ``y``, ``z`` and ``w`` components of this vector.

📦:setAxisAngleFromQuaternion( Quaternion q ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `q <#Quaternion>`__ - a normalized ``Quaternion``
   Sets the ``x``, ``y`` and ``z`` components of this vector to the
   quaternion's axis and ``w`` to the angle.

📦:setAxisAngleFromRotationMatrix( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `m <#Matrix4>`__ - a ``Matrix4`` of which the upper left 3x3 matrix is a pure
   rotation matrix.
   Sets the ``x``, ``y`` and ``z`` to the axis of rotation and 
   ``w`` to the angle.

📦:setFromMatrixPosition( Matrix4 m ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to the position elements of the
   `transformation matrix <https://en.wikipedia.org/wiki/Transformation_matrix>`__
   `m <#Matrix4>`__.

📦:setComponent( Integer index, Float value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ - ``0``, ``1``, ``2`` or ``3``.
   `value <#Float>`__ - ``Float``
   If index equals ``0`` set ``x`` to `value <#Float>`__.
   If index equals ``1`` set ``y`` to `value <#Float>`__.
   If index equals ``2`` set ``z`` to `value <#Float>`__.
   If index equals ``3`` set ``w`` to `value <#Float>`__.

📦:setLength( Float l ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to a vector with the same direction as this one, but 
   ``length`` `l <#Float>`__.

📦:setScalar( Float scalar ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the ``x``, ``y``, ``z`` and ``w`` values of this vector both
   equal to `scalar <#Float>`__.

📦:setX( Float x ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replaces this vector's ``x`` value with `x <#Float>`__.

📦:setY( Float y ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replaces this vector's ``y`` value with `y <#Float>`__.

📦:setZ( Float z ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replaces this vector's ``z`` value with `z <#Float>`__.

📦:setW( Float w ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   Replaces this vector's ``w`` value with `w <#Float>`__.

📦:sub( Vector4 v ) this
~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts `v <#Vector4>`__ from this vector.

📦:subScalar( Float s ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Subtracts `s <#Float>`__ from this vector's ``x``, ``y``, ``z`` and
   ``w`` components.

📦:subVectors( Vector4 a, Vector4 b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets this vector to `a <#Vector4>`__ - `b <#Vector4>`__.

📦:toArray( Array array, Integer offset ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `array <#Array>`__ - (optional) array to store this vector to. If this is not provided,
   a new array will be created.
   `offset <#Integer>`__ - (optional) optional offset into the array.
   Returns an array [x, y, z, w], or copies x, y, z and w into the provided `array <#Array>`__.

📦:random() this
~~~~~~~~~~~~~~~~~

   Sets each component of this vector to a pseudo-random value between ``0`` and ``1``,
   excluding ``1``.



.. _D188:

Interpolant → CubicInterpolant
==============================

   https://threejs.org/docs/api/en/math/interpolants/CubicInterpolant.html

   **Code Example**


   .. code:: javascript

      const interpolant = new THREE.CubicInterpolant( 
         new Float32Array( 2 ), 
         new Float32Array( 2 ), 1, 
         new Float32Array( 1 ) 
      );
      interpolant.evaluate( 0.5 );

   .. Constructor

🐣:CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   parameterPositions -- array of positions
   sampleValues -- array of samples
   sampleSize -- number of samples
   resultBuffer -- buffer to store the interpolation results.

Properties
----------

⭕:null parameterPositions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:null resultBuffer
~~~~~~~~~~~~~~~~~~~~~

⭕:null sampleValues
~~~~~~~~~~~~~~~~~~~~~

⭕:Object settings
~~~~~~~~~~~~~~~~~~~

⭕:null valueSize
~~~~~~~~~~~~~~~~~~

Methods
-------

📦:evaluate( Number t ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Evaluate the interpolant at position ``t``.



.. _D189:

Interpolant → DiscreteInterpolant
=================================

   https://threejs.org/docs/api/en/math/interpolants/DiscreteInterpolant.html

   **Code Example**


   .. code:: javascript

      const interpolant = new THREE.DiscreteInterpolant(
            new Float32Array( 2 ),
            new Float32Array( 2 ),
            1,
            new Float32Array( 1 )
      );

      interpolant.evaluate( 0.5 );


   .. Constructor

🐣:DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   parameterPositions -- array of positions
   sampleValues -- array of samples
   sampleSize -- number of samples
   resultBuffer -- buffer to store the interpolation results.

Properties
----------

⭕:null parameterPositions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:null resultBuffer
~~~~~~~~~~~~~~~~~~~~~

⭕:null sampleValues
~~~~~~~~~~~~~~~~~~~~~

⭕:Object settings
~~~~~~~~~~~~~~~~~~~

⭕:null valueSize
~~~~~~~~~~~~~~~~~~

Methods
-------

📦:evaluate( Number t ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Evaluate the interpolant at position ``t``.



.. _D190:

Interpolant → LinearInterpolant
===============================

   https://threejs.org/docs/api/en/math/interpolants/LinearInterpolant.html

   **Code Example**


   .. code:: javascript

      const interpolant = new THREE.LinearInterpolant( 
         new Float32Array( 2 ), 
         new Float32Array( 2 ), 1, 
         new Float32Array( 1 ) 
      );
      interpolant.evaluate( 0.5 );


   .. Constructor

🐣:LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   parameterPositions -- array of positions
   sampleValues -- array of samples
   sampleSize -- number of samples
   resultBuffer -- buffer to store the interpolation results.

Properties
----------

⭕:null parameterPositions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:null resultBuffer
~~~~~~~~~~~~~~~~~~~~~

⭕:null sampleValues
~~~~~~~~~~~~~~~~~~~~~

⭕:Object settings
~~~~~~~~~~~~~~~~~~~

⭕:null valueSize
~~~~~~~~~~~~~~~~~~

Methods
-------

📦:evaluate( Number t ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Evaluate the interpolant at position ``t``.



.. _D191:

Interpolant → QuaternionLinearInterpolant
=========================================

   https://threejs.org/docs/api/en/math/interpolants/QuaternionLinearInterpolant.html

   **Code Example**


   .. code:: javascript

      const interpolant = new THREE.QuaternionLinearInterpolant( 
         new Float32Array( 2 ), 
         new Float32Array( 2 ), 1, 
         new Float32Array( 1 ) 
      );
      interpolant.evaluate( 0.5 );


   .. Constructor

🐣:QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   parameterPositions -- array of positions
   sampleValues -- array of samples
   sampleSize -- number of samples
   resultBuffer -- buffer to store the interpolation results.

Properties
----------

⭕:null parameterPositions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

⭕:null resultBuffer
~~~~~~~~~~~~~~~~~~~~~

⭕:null sampleValues
~~~~~~~~~~~~~~~~~~~~~

⭕:Object settings
~~~~~~~~~~~~~~~~~~~

⭕:null valueSize
~~~~~~~~~~~~~~~~~~

Methods
-------

📦:evaluate( Number t ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Evaluate the interpolant at position ``t``.



.. _D192:

Mesh → BatchedMesh
==================

   https://threejs.org/docs/api/en/objects/BatchedMesh.html

   A special version of ``Mesh`` with multi draw batch rendering support. 
   Use ``QuaternionLinearInterpolant`` if you have to render a large number of 
   objects with the same material but with different world transformations. 
   The usage of ``QuaternionLinearInterpolant`` will help you to reduce the number 
   of draw calls and thus improve the overall rendering performance in your application.
   If the `WEBGL_multi_draw extension <https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_multi_draw>`__ 
   is not supported then a less performant fallback is used.

   **Code Example**


   .. code:: javascript

      const box = new THREE.BoxGeometry( 1, 1, 1 );
      const sphere = new THREE.SphereGeometry( 1, 12, 12 );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

      // initialize and add geometries into the batched mesh
      const batchedMesh = new BatchedMesh( 10, 5000, 10000, material );
      const boxGeometryId = batchedMesh.addGeometry( box );
      const sphereGeometryId = batchedMesh.addGeometry( sphere );

      // create instances of those geometries
      const boxInstancedId1 = batchedMesh.addInstance( boxGeometryId );
      const boxInstancedId2 = batchedMesh.addInstance( boxGeometryId );

      const sphereInstancedId1 = batchedMesh.addInstance( sphereGeometryId );
      const sphereInstancedId2 = batchedMesh.addInstance( sphereGeometryId );

      // position the geometries
      batchedMesh.setMatrixAt( boxInstancedId1, boxMatrix1 );
      batchedMesh.setMatrixAt( boxInstancedId2, boxMatrix2 );

      batchedMesh.setMatrixAt( sphereInstancedId1, sphereMatrix1 );
      batchedMesh.setMatrixAt( sphereInstancedId2, sphereMatrix2 );

      scene.add( batchedMesh );


   **Examples**

   [example:webgl_mesh_batch WebGL / mesh / batch]

   .. Constructor

🐣:BatchedMesh( Integer maxInstanceCount, Integer maxVertexCount, Integer maxIndexCount, Material material, )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `maxInstanceCount <#Integer>`__ - the max number of individual instances planned to be
   added and rendered.
   `maxVertexCount <#Integer>`__ - the max number of vertices to be used by all unique
   geometries.
   `maxIndexCount <#Integer>`__ - the max number of indices to be used by all unique
   geometries.
   `material <#Material>`__ - an instance of ``Material``. Default is a new
   ``MeshBasicMaterial``.

Properties
----------

   See the base ``Mesh`` class for common properties.

⭕:Box3 boundingBox
~~~~~~~~~~~~~~~~~~~~

   This bounding box encloses all instances of the ``BatchedMesh``. Can be calculated with
   ``.computeBoundingBox``(). Default is ``null``.

⭕:Sphere boundingSphere
~~~~~~~~~~~~~~~~~~~~~~~~~

   This bounding sphere encloses all instances of the ``BatchedMesh``. Can be calculated with
   ``.computeBoundingSphere``(). Default is ``null``.

⭕:Boolean perObjectFrustumCulled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If true then the individual objects within the ``BatchedMesh`` are frustum culled.
   Default is ``true``.

⭕:Boolean sortObjects
~~~~~~~~~~~~~~~~~~~~~~~

   If true then the individual objects within the ``BatchedMesh`` are sorted to improve
   overdraw-related artifacts. If the material is marked as "transparent" objects are
   rendered back to front and if not then they are rendered front to back.
   Default is ``true``.

⭕:Integer maxInstanceCount
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The maximum number of individual instances that can be stored in the ``BatchedMesh``. Read only.

⭕:Boolean isBatchedMesh
~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``BatchedMesh``.

Methods
-------

   See the base ``Mesh`` class for common methods.

📦:computeBoundingBox() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding box, updating ``.boundingBox`` attribute.
   Bounding boxes aren't computed by default. They need to be explicitly computed,
   otherwise they are ``null``.

📦:computeBoundingSphere() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding sphere, updating ``.boundingSphere`` attribute.
   Bounding spheres aren't computed by default. They need to be explicitly computed,
   otherwise they are ``null``.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:setCustomSort( Function sortFunction ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Takes a sort a function that is run before render. The function takes a list of instances
   to sort and a camera. The objects in the list include a "z" field to perform a
   depth-ordered sort with.

📦:getColorAt( Integer instanceId, Color target ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `instanceId <#Integer>`__: The id of an instance to get the color of.

   `target <#Color>`__: The target object to copy the color in to.

   Get the color of the defined geometry.

📦:getMatrixAt( Integer instanceId, Matrix4 target ) Matrix4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `instanceId <#Integer>`__: The id of an instance to get the matrix of.

   `target <#Matrix4>`__: This 4x4 matrix will be set to the local transformation matrix of
   the defined instance.

   Get the local transformation matrix of the defined instance.

📦:getVisibleAt( Integer instanceId ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `instanceId <#Integer>`__: The id of an instance to get the visibility state of.

   Get whether the given instance is marked as "visible" or not.

📦:setColorAt( Integer instanceId, Color color ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `instanceId <#Integer>`__: The id of the instance to set the color of.

   `color <#Color>`__: The color to set the instance to.

   Sets the given color to the defined geometry instance.

📦:setMatrixAt( Integer instanceId, Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `instanceId <#Integer>`__: The id of an instance to set the matrix of.

   `matrix <#Matrix4>`__: A 4x4 matrix representing the local transformation of a single
   instance.

   Sets the given local transformation matrix to the defined instance.

📦:setVisibleAt( Integer instanceId, Boolean visible ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `instanceId <#Integer>`__: The id of the instance to set the visibility of.

   `visible <#Boolean>`__: A boolean value indicating the visibility state.

   Sets the visibility of the instance at the given index.

📦:addGeometry( BufferGeometry geometry, Integer reservedVertexRange, Integer reservedIndexRange ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__: The geometry to add into the ``BatchedMesh``.

   `reservedVertexRange <#Integer>`__: Optional parameter specifying the amount of vertex
   buffer space to reserve for the added geometry. This is necessary if it is planned to set
   a new geometry at this index at a later time that is larger than the original geometry.
   Defaults to the length of the given geometry vertex buffer.

   `reservedIndexRange <#Integer>`__: Optional parameter specifying the amount of index
   buffer space to reserve for the added geometry. This is necessary if it is planned to set
   a new geometry at this index at a later time that is larger than the original geometry.
   Defaults to the length of the given geometry index buffer.

   Adds the given geometry to the ``BatchedMesh`` and returns the associated geometry id referring to
   it to be used in other functions.

📦:addInstance( Integer geometryId ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometryId <#Integer>`__: The id of a previously added geometry via "addGeometry" to add
   into the ``BatchedMesh`` to render.

   Adds a new instance to the ``BatchedMesh`` using the geometry of the given geometryId and returns a
   new id referring to the new instance to be used by other functions.

📦:setGeometryAt( Integer geometryId, BufferGeometry geometry ) Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometryId <#Integer>`__: Which geometry id to replace with this geometry.

   `geometry <#BufferGeometry>`__: The geometry to substitute at the given geometry id.

   Replaces the geometry at ``geometryId`` with the provided geometry. Throws an error if
   there is not enough space reserved for geometry. Calling this will change all instances
   that are rendering that geometry.



.. _D193:

Object3D → Bone
===============

   https://threejs.org/docs/api/en/objects/Bone.html

   A bone which is part of a ``Skeleton``. The skeleton in turn is used by the
   ``SkinnedMesh``. Bones are almost identical to a blank ``Object3D``.

   **Code Example**


   .. code:: javascript

      const root = new THREE.Bone();
      const child = new THREE.Bone();
      root.add( child );
      child.position.y = 5;


   .. Constructor


🐣:Bone( )
~~~~~~~~~

   Creates a new ``Bone``.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Boolean isBone
~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Bone``.

⭕:String type
~~~~~~~~~~~~~~~

   Set to 'Bone', this can be used to find all Bones in a scene.

Methods
-------

   See the base ``Object3D`` class for common methods.



.. _D194:

Object3D → Group
================

   https://threejs.org/docs/api/en/objects/Group.html

   This is almost identical to an `Object3D <#Object3D>`__. Its purpose is to make working
   with groups of objects syntactically clearer.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 1, 1, 1 );
      const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );

      const cubeA = new THREE.Mesh( geometry, material );
      cubeA.position.set( 100, 100, 0 );
      const cubeB = new THREE.Mesh( geometry, material );
      cubeB.position.set( -100, -100, 0 );

      //create a group and add the two cubes 
      //These cubes can now be rotated / scaled etc as a group 
      const group = new THREE.Group();
      group.add( cubeA );
      group.add( cubeB );
      scene.add( group );


   .. Constructor


🐣:Group( )
~~~~~~~~~~

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Boolean isGroup
~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Group``.

⭕:String type
~~~~~~~~~~~~~~~

   A string 'Group'. This should not be changed.

Methods
-------

   See the base ``Object3D`` class for common methods.



.. _D195:

Mesh → InstancedMesh
====================

   https://threejs.org/docs/api/en/objects/InstancedMesh.html

   A special version of ``Mesh`` with instanced rendering support. Use ``Group`` if you have
   to render a large number of objects with the same geometry and material(s) but with
   different world transformations. The usage of ``Group`` will help you to reduce the number of
   draw calls and thus improve the overall rendering performance in your application.

   **Examples**

   [example:webgl_instancing_dynamic WebGL / instancing / dynamic]
   [example:webgl_instancing_performance WebGL / instancing / performance]
   [example:webgl_instancing_scatter WebGL / instancing / scatter]
   [example:webgl_instancing_raycast WebGL / instancing / raycast]

   .. Constructor

🐣:InstancedMesh( BufferGeometry geometry, Material material, Integer count )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ - an instance of ``BufferGeometry``.
   `material <#Material>`__ — a single or an array of ``Material``. Default is a new
   ``MeshBasicMaterial``.
   `count <#Integer>`__ - the number of instances.

Properties
----------

   See the base ``Mesh`` class for common properties.

⭕:Box3 boundingBox
~~~~~~~~~~~~~~~~~~~~

   This bounding box encloses all instances of the ``InstancedMesh``. Can be calculated with
   ``.computeBoundingBox``(). Default is ``null``.

⭕:Sphere boundingSphere
~~~~~~~~~~~~~~~~~~~~~~~~~

   This bounding sphere encloses all instances of the ``InstancedMesh``. Can be calculated with
   ``.computeBoundingSphere``(). Default is ``null``.

⭕:Integer count
~~~~~~~~~~~~~~~~~

   The number of instances. The ``count`` value passed into the constructor represents the
   maximum number of instances of this mesh. You can change the number of instances at
   runtime to an integer value in the range [0, count].

   If you need more instances than the original count value, you have to create a new ``InstancedMesh``.

⭕:InstancedBufferAttribute instanceColor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Represents the colors of all instances. ``null`` by default. You have to set its
   `needsUpdate <#BufferAttribute.needsUpdate>`__ flag to true if you modify instanced data
   via ``.setColorAt``().

⭕:InstancedBufferAttribute instanceMatrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Represents the local transformation of all instances. You have to set its
   `needsUpdate <#BufferAttribute.needsUpdate>`__ flag to true if you modify instanced data
   via ``.setMatrixAt``().

⭕:DataTexture morphTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Represents the morph target weights of all instances. You have to set its
   `needsUpdate <#Texture.needsUpdate>`__ flag to true if you modify instanced data via
   ``.setMorphAt``().

⭕:Boolean isInstancedMesh
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``InstancedMesh``.

Methods
-------

   See the base ``Mesh`` class for common methods.

📦:computeBoundingBox() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding box of the instanced mesh, and updates the ``.boundingBox``
   attribute. The bounding box is not computed by the engine; it must be computed by your
   app. You may need to recompute the bounding box if an instance is transformed via
   ``.setMatrixAt``().

📦:computeBoundingSphere() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding sphere of the instanced mesh, and updates the ``.boundingSphere``
   attribute. The engine automatically computes the bounding sphere when it is needed, e.g.,
   for ray casting or view frustum culling. You may need to recompute the bounding sphere if
   an instance is transformed via ``.setMatrixAt``().

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:getColorAt( Integer index, Color color ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__: The index of an instance. Values have to be in the range [0, count].

   `color <#Color>`__: This color object will be set to the color of the defined instance.

   Get the color of the defined instance.

📦:getMatrixAt( Integer index, Matrix4 matrix ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__: The index of an instance. Values have to be in the range [0, count].

   `matrix <#Matrix4>`__: This 4x4 matrix will be set to the local transformation matrix of
   the defined instance.

   Get the local transformation matrix of the defined instance.

📦:getMorphAt( Integer index, Mesh mesh ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__: The index of an instance. Values have to be in the range [0, count].

   `mesh <#Mesh>`__: The `.morphTargetInfluences <#Mesh.morphTargetInfluences>`__ property of
   this mesh will be filled with the morph target weights of the defined instance.

   Get the morph target weights of the defined instance.

📦:setColorAt( Integer index, Color color ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__: The index of an instance. Values have to be in the range [0, count].

   `color <#Color>`__: The color of a single instance.

   Sets the given color to the defined instance. Make sure you set
   ``.instanceColor```.needsUpdate <#BufferAttribute.needsUpdate>`__ to true after
   updating all the colors.

📦:setMatrixAt( Integer index, Matrix4 matrix ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__: The index of an instance. Values have to be in the range [0, count].

   `matrix <#Matrix4>`__: A 4x4 matrix representing the local transformation of a single
   instance.

   Sets the given local transformation matrix to the defined instance. Make sure you set
   ``.instanceMatrix```.needsUpdate <#BufferAttribute.needsUpdate>`__ to true after
   updating all the matrices.

📦:setMorphAt( Integer index, Mesh mesh ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__: The index of an instance. Values have to be in the range [0, count].

   `mesh <#Mesh>`__: A mesh with `.morphTargetInfluences <#Mesh.morphTargetInfluences>`__
   property containing the morph target weights of a single instance.

   Sets the morph target weights to the defined instance. Make sure you set
   ``.morphTexture```.needsUpdate <#Texture.needsUpdate>`__ to true after updating all the
   influences.



.. _D196:

Object3D → Line
===============

   https://threejs.org/docs/api/en/objects/Line.html

   A continuous line.

   This is nearly the same as ``LineSegments``; the only difference is that it is
   rendered using `gl.LINE_STRIP <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__ 
   instead of `gl.LINES <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__

   **Code Example**


   .. code:: javascript

      const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
      const points = [];
      points.push( new THREE.Vector3( - 10, 0, 0 ) );
      points.push( new THREE.Vector3( 0, 10, 0 ) );
      points.push( new THREE.Vector3( 10, 0, 0 ) );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );
      const line = new THREE.Line( geometry, material );
      scene.add( line );


   .. Constructor

🐣:Line( BufferGeometry geometry, Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ — vertices representing the line segment(s). Default is a
   new ``BufferGeometry``.
   `material <#Material>`__ — material for the line. Default is a new
   ``LineBasicMaterial``.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:BufferGeometry geometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Vertices representing the line segment(s).

⭕:Boolean isLine
~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Line``.

⭕:Material material
~~~~~~~~~~~~~~~~~~~~~

   Material for the line.

⭕:Array morphTargetInfluences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An array of weights typically from 0-1 that specify how much of the morph is applied.
   Undefined by default, but reset to a blank array by ``.updateMorphTargets``().

⭕:Object morphTargetDictionary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A dictionary of morphTargets based on the morphTarget.name property. Undefined by default,
   but rebuilt ``.updateMorphTargets``().

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:computeLineDistances() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes an array of distance values which are necessary for ``LineDashedMaterial``.
   For each vertex in the geometry, the method calculates the cumulative length from the
   current point to the very beginning of the line.

📦:raycast( Raycaster raycaster, Array intersects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get intersections between a casted ``Ray`` and this Line.
   ``Raycaster.intersectObject`` will call this method.

📦:clone() Line
~~~~~~~~~~~~~~~~

   Returns a clone of this Line object and its descendants.

📦:updateMorphTargets() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the morphTargets to have no influence on the object. Resets the
   ``.morphTargetInfluences`` and ``.morphTargetDictionary`` properties.



.. _D197:

Object3D → Line → LineLoop
==========================

   https://threejs.org/docs/api/en/objects/LineLoop.html

   A continuous line that connects back to the start.
   This is nearly the same as ``Line``; the only difference is that it is rendered using
   `gl.LINE_LOOP <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__ 
   instead of `gl.LINE_STRIP <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__, 
   which draws a straight line to the next vertex, and connects the last
   vertex back to the first.

   .. Constructor

🐣:LineLoop( BufferGeometry geometry, Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ — List of vertices representing points on the line loop.
   `material <#Material>`__ — Material for the line. Default is `LineBasicMaterial <#LineBasicMaterial>`__.

Properties
----------

   See the base ``Line`` class for common properties.

⭕:Boolean isLineLoop
~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``LineLoop``.

Methods
-------

   See the base ``Line`` class for common methods.



.. _D198:

Object3D → Line → LineSegments
==============================

   https://threejs.org/docs/api/en/objects/LineSegments.html

   A series of lines drawn between pairs of vertices.
   This is nearly the same as ``Line``; the only difference is that it is rendered using
   `gl.LINES <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__ 
   instead of `gl.LINE_STRIP <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__.

   .. Constructor

🐣:LineSegments( BufferGeometry geometry, Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ — Pair(s) of vertices representing each line segment(s).
   `material <#Material>`__ — Material for the line. Default is `LineBasicMaterial <#LineBasicMaterial>`__.

Properties
----------

   See the base ``Line`` class for common properties.

⭕:Boolean isLineSegments
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``LineSegments``.

Methods
-------

   See the base ``Line`` class for common methods.



.. _D199:

Object3D → LOD
==============

   https://threejs.org/docs/api/en/objects/LOD.html

   Level of Detail - show meshes with more or less geometry based on distance from the
   camera.

   Every level is associated with an object, and rendering can be switched between them at
   the distances specified. Typically you would create, say, three meshes, one for far away
   (low detail), one for mid range (medium detail) and one for close up (high detail).

   **Code Example**


   .. code:: javascript

      const lod = new THREE.LOD();
      //Create spheres with 3 levels of detail and create new LOD levels for them for( let i = 0;
      i < 3;
      i++ ) { const geometry = new THREE.IcosahedronGeometry( 10, 3 - i );
      const mesh = new THREE.Mesh( geometry, material );
      lod.addLevel( mesh, i * 75 );
      } scene.add( lod );


   **Examples**

   [example:webgl_lod webgl / lod ]

   .. Constructor


🐣:LOD( )
~~~~~~~~

   Creates a new ``LOD``.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Boolean autoUpdate
~~~~~~~~~~~~~~~~~~~~~~

   Whether the LOD object is updated automatically by the renderer per frame or not. If set
   to false, you have to call ``LOD.update``() in the render loop by yourself. Default is
   true.

⭕:Boolean isLOD
~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``LOD``.

⭕:Array levels
~~~~~~~~~~~~~~~~

   An array of `level <#Object>`__ objects
   Each level is an object with the following properties:
   `object <#Object3D>`__ - The ``Object3D`` to display at this level.
   `distance <#Float>`__ - The distance at which to display this level of detail.
   `hysteresis <#Float>`__ - Threshold used to avoid flickering at LOD boundaries, as a
   fraction of distance.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:addLevel( Object3D object, Float distance, Float hysteresis ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ - The ``Object3D`` to display at this level.
   `distance <#Float>`__ - The distance at which to display this level of detail. Default
   ``0.0``.
   `hysteresis <#Float>`__ - Threshold used to avoid flickering at LOD boundaries, as a
   fraction of distance. Default ``0.0``.
   Adds a mesh that will display at a certain distance and greater. Typically the further
   away the distance, the lower the detail on the mesh.

📦:clone() LOD
~~~~~~~~~~~~~~~

   Returns a clone of this LOD object with its associated levels.

📦:getCurrentLevel() Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get the currently active LOD level. As index of the levels array.

📦:getObjectForDistance( Float distance ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get a reference to the first ``Object3D`` (mesh) that is greater than `distance <#Float>`__.

📦:raycast( Raycaster raycaster, Array intersects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get intersections between a casted ``Ray`` and this LOD.
   ``Raycaster.intersectObject`` will call this method.

📦:toJSON( meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~

   Create a JSON structure with details of this LOD object.

📦:update( Camera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the visibility of each `level <#levels>`__'s `object <#Object3D>`__ based on distance
   from the `camera <#Camera>`__.



.. _D200:

Object3D → Mesh
===============

   https://threejs.org/docs/api/en/objects/Mesh.html

   Class representing triangular `polygon mesh` based objects. Also serves as a base 
   for other classes such as `SkinnedMesh <https://en.wikipedia.org/wiki/Polygon_mesh>`__.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 1, 1, 1 );
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );


   .. Constructor

🐣:Mesh( BufferGeometry geometry, Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ — (optional) an instance of ``BufferGeometry``.
   Default is a new ``BufferGeometry``.
   `material <#Material>`__ — (optional) a single or an array of ``Material``.
   Default is a new ``MeshBasicMaterial``

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:BufferGeometry geometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An instance of ``BufferGeometry`` (or derived classes), defining the object's
   structure.

⭕:Boolean isMesh
~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Mesh``.

⭕:Material material
~~~~~~~~~~~~~~~~~~~~~

   An instance of material derived from the ``Material`` base class or an array of
   materials, defining the object's appearance. Default is a ``MeshBasicMaterial``.

⭕:Array morphTargetInfluences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An array of weights typically from 0-1 that specify how much of the morph is applied.
   Undefined by default, but reset to a blank array by `updateMorphTargets <#Mesh.updateMorphTargets>`__.

⭕:Object morphTargetDictionary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A dictionary of morphTargets based on the morphTarget.name property. Undefined by default,
   but rebuilt `updateMorphTargets <#Mesh.updateMorphTargets>`__.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:clone() Mesh
~~~~~~~~~~~~~~~~

   Returns a clone of this ``Mesh`` object and its descendants.

📦:getVertexPosition( Integer index, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get the local-space position of the vertex at the given index, taking into account the
   current animation state of both morph targets and skinning.

📦:raycast( Raycaster raycaster, Array intersects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get intersections between a casted ray and this mesh. ``Raycaster.intersectObject``
   will call this method, but the results are not ordered.

📦:updateMorphTargets() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the morphTargets to have no influence on the object. Resets the
   `morphTargetInfluences <#Mesh.morphTargetInfluences>`__ and
   `morphTargetDictionary <#Mesh.morphTargetDictionary>`__ properties.



.. _D201:

Object3D → Points
=================

   https://threejs.org/docs/api/en/objects/Points.html

   A class for displaying points. The points are rendered by the ``WebGLRenderer`` using
   `gl.POINTS <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements>`__.

   .. Constructor

🐣:Points( BufferGeometry geometry, Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ — (optional) an instance of ``BufferGeometry``.
   Default is a new ``BufferGeometry``.
   `material <#Material>`__ — (optional) a ``Material``. Default is a new
   ``PointsMaterial``.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:BufferGeometry geometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An instance of ``BufferGeometry`` (or derived classes), defining the object's
   structure.

⭕:Boolean isPoints
~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Points``.

⭕:Material material
~~~~~~~~~~~~~~~~~~~~~

   An instance of ``Material``, defining the object's appearance. Default is a
   ``PointsMaterial``.

⭕:Array morphTargetInfluences
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An array of weights typically from 0-1 that specify how much of the morph is applied.
   Undefined by default, but reset to a blank array by `updateMorphTargets <#Points.updateMorphTargets>`__.

⭕:Object morphTargetDictionary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A dictionary of morphTargets based on the morphTarget.name property. Undefined by default,
   but rebuilt `updateMorphTargets <#Points.updateMorphTargets>`__.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:raycast( Raycaster raycaster, Array intersects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get intersections between a casted ray and this Points. ``Raycaster.intersectObject``
   will call this method.

📦:clone() Points
~~~~~~~~~~~~~~~~~~

   Returns a clone of this Points object and its descendants.

📦:updateMorphTargets() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the morphTargets to have no influence on the object. Resets the
   `morphTargetInfluences <#Points.morphTargetInfluences>`__ and
   `morphTargetDictionary <#Points.morphTargetDictionary>`__ properties.



.. _D202:

Skeleton
========

   https://threejs.org/docs/api/en/objects/Skeleton.html

   Use an array of `bones <#Bone>`__ to create a skeleton that can be used by a
   ``SkinnedMesh``.

   **Code Example**


   .. code:: javascript

      // Create a simple "arm"

      const bones = [];

      const shoulder = new THREE.Bone();
      const elbow = new THREE.Bone();
      const hand = new THREE.Bone();

      shoulder.add( elbow );
      elbow.add( hand );

      bones.push( shoulder );
      bones.push( elbow );
      bones.push( hand );

      shoulder.position.y = -5;
      elbow.position.y = 0;
      hand.position.y = 5;

      const armSkeleton = new THREE.Skeleton( bones );


   See the ``SkinnedMesh`` page for an example of usage with standard
   ``BufferGeometry``.

   .. Constructor

🐣:Skeleton( Array bones, Array boneInverses )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `bones <#Array>`__ - The array of `bones <#Bone>`__. Default is an empty array.
   `boneInverses <#Array>`__ - (optional) An array of `Matrix4s <#Matrix4>`__.
   Creates a new ``Skeleton``.

Properties
----------

⭕:Array bones
~~~~~~~~~~~~~~~

   The array of `bones <#bone>`__. Note this is a copy of the original array, not a
   reference, so you can modify the original array without effecting this one.

⭕:Array boneInverses
~~~~~~~~~~~~~~~~~~~~~~

   An array of `Matrix4s <#Matrix4>`__ that represent the inverse of the `matrixWorld <#Matrix4>`__ of the individual bones.

⭕:Float32Array boneMatrices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The array buffer holding the bone data when using a vertex texture.

⭕:DataTexture boneTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``DataTexture`` holding the bone data when using a vertex texture.

Methods
-------

📦:clone() Skeleton
~~~~~~~~~~~~~~~~~~~~

   Returns a clone of this Skeleton object.

📦:calculateInverses() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Generates the ``boneInverses`` array if not provided in the constructor.

📦:computeBoneTexture() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes an instance of ``DataTexture`` in order to pass the bone data more efficiently
   to the shader. The texture is assigned to ``boneTexture``.

📦:pose() undefined
~~~~~~~~~~~~~~~~~~~~

   Returns the skeleton to the base pose.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the `boneMatrices <#Float32Array>`__ and `boneTexture <#DataTexture>`__ after
   changing the bones. This is called automatically by the ``WebGLRenderer`` if the
   skeleton is used with a ``SkinnedMesh``.

📦:getBoneByName( String name ) Bone
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   name -- String to match to the Bone's .name property.
   Searches through the skeleton's bone array and returns the first with a matching name.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D203:

Object3D → Mesh → SkinnedMesh
=============================

   https://threejs.org/docs/api/en/objects/SkinnedMesh.html

   A mesh that has a ``Skeleton`` with `bones <#Bone>`__ that can then be used to animate
   the vertices of the geometry.

   **Code Example**


   .. code:: javascript

      const geometry = new THREE.CylinderGeometry( 5, 5, 5, 5, 15, 5, 30 );

      // create the skin indices and skin weights manually
      // (typically a loader would read this data from a 3D model for you)

      const position = geometry.attributes.position;

      const vertex = new THREE.Vector3();

      const skinIndices = [];
      const skinWeights = [];

      for ( let i = 0; i < position.count; i ++ ) {

         vertex.fromBufferAttribute( position, i );

         // compute skinIndex and skinWeight based on some configuration data
         const y = ( vertex.y + sizing.halfHeight );
         const skinIndex = Math.floor( y / sizing.segmentHeight );
         const skinWeight = ( y % sizing.segmentHeight ) / sizing.segmentHeight;
         skinIndices.push( skinIndex, skinIndex + 1, 0, 0 );
         skinWeights.push( 1 - skinWeight, skinWeight, 0, 0 );
      }

      geometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );
      geometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );

      // create skinned mesh and skeleton

      const mesh = new THREE.SkinnedMesh( geometry, material );
      const skeleton = new THREE.Skeleton( bones );

      // see example from THREE.Skeleton
      const rootBone = skeleton.bones[ 0 ];
      mesh.add( rootBone );

      // bind the skeleton to the mesh
      mesh.bind( skeleton );

      // move the bones and manipulate the model
      skeleton.bones[ 0 ].rotation.x = -0.1;
      skeleton.bones[ 1 ].rotation.x = 0.2;


   .. Constructor

🐣:SkinnedMesh( BufferGeometry geometry, Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `geometry <#BufferGeometry>`__ - an instance of ``BufferGeometry``.
   `material <#Material>`__ - (optional) an instance of ``Material``. Default is a new
   ``MeshBasicMaterial``.

Properties
----------

   See the base ``Mesh`` class for common properties.

⭕:String bindMode
~~~~~~~~~~~~~~~~~~~

   Either ``AttachedBindMode`` or ``DetachedBindMode``. ``AttachedBindMode`` means the
   skinned mesh shares the same world space as the skeleton. This is not true when using
   ``DetachedBindMode`` which is useful when sharing a skeleton across multiple skinned
   meshes. Default is ``AttachedBindMode``.

⭕:Matrix4 bindMatrix
~~~~~~~~~~~~~~~~~~~~~~

   The base matrix that is used for the bound bone transforms.

⭕:Matrix4 bindMatrixInverse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The base matrix that is used for resetting the bound bone transforms.

⭕:Box3 boundingBox
~~~~~~~~~~~~~~~~~~~~

   The bounding box of the ``SkinnedMesh``. Can be calculated with ``.computeBoundingBox``().
   Default is ``null``.

⭕:Sphere boundingSphere
~~~~~~~~~~~~~~~~~~~~~~~~~

   The bounding sphere of the ``SkinnedMesh``. Can be calculated with ``.computeBoundingSphere``().
   Default is ``null``.

⭕:Boolean isSkinnedMesh
~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``SkinnedMesh``.

⭕:Skeleton skeleton
~~~~~~~~~~~~~~~~~~~~~

   ``Skeleton`` representing the bone hierarchy of the skinned mesh.

Methods
-------

   See the base ``Mesh`` class for common methods.

📦:bind( Skeleton skeleton, Matrix4 bindMatrix ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `skeleton <#Skeleton>`__ - ``Skeleton`` created from a `Bones <#Bone>`__ tree.
   `bindMatrix <#Matrix4>`__ - ``Matrix4`` that represents the base transform of the
   skeleton.
   Bind a skeleton to the skinned mesh. The bindMatrix gets saved to .bindMatrix property
   and the .bindMatrixInverse gets calculated.

📦:clone() SkinnedMesh
~~~~~~~~~~~~~~~~~~~~~~~

   This method does currently not clone an instance of ``SkinnedMesh`` correctly. Please use
   ``SkeletonUtils.clone``() in the meanwhile.

📦:computeBoundingBox() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding box of the skinned mesh, and updates the ``.boundingBox``
   attribute. The bounding box is not computed by the engine; it must be computed by your
   app. If the skinned mesh is animated, the bounding box should be recomputed per frame.

📦:computeBoundingSphere() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the bounding sphere of the skinned mesh, and updates the ``.boundingSphere``
   attribute. The bounding sphere is automatically computed by the engine when it is needed,
   e.g., for ray casting and view frustum culling. If the skinned mesh is animated, the
   bounding sphere should be recomputed per frame.

📦:normalizeSkinWeights() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Normalizes the skin weights.

📦:pose() undefined
~~~~~~~~~~~~~~~~~~~~

   This method sets the skinned mesh in the rest pose (resets the pose).

📦:applyBoneTransform( Integer index, Vector3 vector ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Applies the bone transform associated with the given index to the given position vector.
   Returns the updated vector.



.. _D204:

Object3D → Sprite
=================

   https://threejs.org/docs/api/en/objects/Sprite.html

   A sprite is a plane that always faces towards the camera, generally with a partially
   transparent texture applied.
   Sprites do not cast shadows, setting ``castShadow = true`` will have no effect.

   **Code Example**


   .. code:: javascript

      const map = new THREE.TextureLoader().load( 'sprite.png' );
      const material = new THREE.SpriteMaterial( { map: map } );
      const sprite = new THREE.Sprite( material );
      scene.add( sprite );


   .. Constructor

🐣:Sprite( Material material )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `material <#Material>`__ - (optional) an instance of ``SpriteMaterial``. Default is a
   white ``SpriteMaterial``.
   Creates a new ``Sprite``.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:Boolean isSprite
~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Sprite``.

⭕:SpriteMaterial material
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An instance of ``SpriteMaterial``, defining the object's appearance. Default is a white
   ``SpriteMaterial``.

⭕:Vector2 center
~~~~~~~~~~~~~~~~~~

   The sprite's anchor point, and the point around which the sprite rotates. A value of (0.5,
   0.5) corresponds to the midpoint of the sprite. A value of (0, 0) corresponds to the lower
   left corner of the sprite. The default is (0.5, 0.5).

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:clone() Sprite
~~~~~~~~~~~~~~~~~~

   Returns a clone of this Sprite object and any descendants.

📦:copy( Sprite sprite ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the properties of the passed sprite to this one.

📦:raycast( Raycaster raycaster, Array intersects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get intersections between a casted ray and this sprite. ``Raycaster.intersectObject``()
   will call this method. The raycaster must be initialized by calling
   ``Raycaster.setFromCamera``() before raycasting against sprites.



.. _D205:

WebGLRenderer
=============

   https://threejs.org/docs/api/en/renderers/WebGLRenderer.html

   The WebGL renderer displays your beautifully crafted scenes using
   `WebGL <https://en.wikipedia.org/wiki/WebGL>`__.

   .. Constructor

🐣:WebGLRenderer( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   -  `parameters <#Object>`__ - (optional) object with properties defining the renderer's
      behavior. The constructor also accepts no parameters at all. In all cases, it will
      assume sane defaults when parameters are missing. The following are valid parameters:

   -  `canvas <#DOMElement>`__ - A
      `canvas <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas>`__ where the
      renderer draws its output. This corresponds to the `domElement <#WebGLRenderer.domElement>`__ 
      property below. If not passed in here, a new canvas element will be created.

   -  `context <#WebGLRenderingContext>`__ - This can be used to attach the renderer to an
      existing `RenderingContext <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext>`__. Default is null.

   -  `precision <#String>`__ - Shader precision. Can be ``"highp"``, ``"mediump"`` or
      ``"lowp"``. Defaults to ``"highp"`` if supported by the device.

   -  `alpha <#Boolean>`__ - controls the default clear alpha value. When set to ``true``, the
      value is ``0``. Otherwise it's ``1``. Default is ``false``.

   -  `premultipliedAlpha <#Boolean>`__ - whether the renderer will assume that colors have
      `premultiplied alpha <https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha>`__. Default is ``true``.

   -  `antialias <#Boolean>`__ - whether to perform antialiasing. Default is ``false``.

   -  `stencil <#Boolean>`__ - whether the drawing buffer has a
      `stencil buffer <https://en.wikipedia.org/wiki/Stencil_buffer>`__ of at least 8 bits.
      Default is ``false``.

   -  `preserveDrawingBuffer <#Boolean>`__ - whether to preserve the buffers until manually
      cleared or overwritten. Default is ``false``.

   -  `powerPreference <#String>`__ - Provides a hint to the user agent indicating what
      configuration of GPU is suitable for this WebGL context. Can be ``"high-performance"``,
      ``"low-power"`` or ``"default"``. Default is ``"default"``. See
      `WebGL spec <https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2>`__ for
      details.

   -  `failIfMajorPerformanceCaveat <#Boolean>`__ - whether the renderer creation will fail
      upon low performance is detected. Default is ``false``. See
      `WebGL spec <https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2>`__ for
      details.

   -  `depth <#Boolean>`__ - whether the drawing buffer has a
      `depth buffer <https://en.wikipedia.org/wiki/Z-buffering>`__ of at least 16 bits.
      Default is ``true``.

   -  `logarithmicDepthBuffer <#Boolean>`__ - whether to use a logarithmic depth buffer. It
      may be necessary to use this if dealing with huge differences in scale in a single
      scene. Note that this setting uses gl_FragDepth if available which disables the
      `Early Fragment Test <https://www.khronos.org/opengl/wiki/Early_Fragment_Test>`__
      optimization and can cause a decrease in performance. Default is ``false``. See the
      [example:webgl_camera_logarithmicdepthbuffer camera / logarithmicdepthbuffer] example.

Properties
----------

⭕:Boolean autoClear
~~~~~~~~~~~~~~~~~~~~~

   Defines whether the renderer should automatically clear its output before rendering a
   frame. Default is ``true``.

⭕:Boolean autoClearColor
~~~~~~~~~~~~~~~~~~~~~~~~~~

   If ``autoClear`` is true, defines whether the renderer should clear the
   color buffer. Default is ``true``.

⭕:Boolean autoClearDepth
~~~~~~~~~~~~~~~~~~~~~~~~~~

   If ``autoClear`` is true, defines whether the renderer should clear the
   depth buffer. Default is ``true``.

⭕:Boolean autoClearStencil
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If ``autoClear`` is true, defines whether the renderer should clear the
   stencil buffer. Default is ``true``.

⭕:Object capabilities
~~~~~~~~~~~~~~~~~~~~~~~

   An object containing details about the capabilities of the current
   `RenderingContext <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext>`__.

   -  `floatFragmentTextures <#Boolean>`__: whether the context supports the
      `OES_texture_float <https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float>`__ extension.

   -  `floatVertexTextures <#Boolean>`__: ``true`` if `floatFragmentTextures <#Boolean>`__
      and `vertexTextures <#Boolean>`__ are both true.

   -  `getMaxAnisotropy <#Method>`__(): Returns the maximum available anisotropy.

   -  `getMaxPrecision <#Method>`__(): Returns the maximum available precision for vertex
      and fragment shaders.

   -  `isWebGL2 <#Boolean>`__: ``true`` if the context in use is a WebGL2RenderingContext
      object.

   -  `logarithmicDepthBuffer <#Boolean>`__: ``true`` if the `logarithmicDepthBuffer <#parameter>`__ 
      was set to true in the constructor and the context supports the
      `EXT_frag_depth <https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth>`__
      extension.

   -  `maxAttributes <#Integer>`__: The value of ``gl.MAX_VERTEX_ATTRIBS``.

   -  `maxCubemapSize <#Integer>`__: The value of ``gl.MAX_CUBE_MAP_TEXTURE_SIZE``. Maximum
      height `` width of cube map textures that a shader can use.

   -  `maxFragmentUniforms <#Integer>`__: The value of ``gl.MAX_FRAGMENT_UNIFORM_VECTORS``.
      The number of uniforms that can be used by a fragment shader.

   -  `maxSamples <#Integer>`__: The value of ``gl.MAX_SAMPLES``. Maximum number of samples
      in context of Multisample anti-aliasing (MSAA).

   -  `maxTextureSize <#Integer>`__: The value of ``gl.MAX_TEXTURE_SIZE``. Maximum height ``
      width of a texture that a shader use.

   -  `maxTextures <#Integer>`__: The value of ``gl.MAX_TEXTURE_IMAGE_UNITS``. The maximum
      number of textures that can be used by a shader.

   -  `maxVaryings <#Integer>`__: The value of ``gl.MAX_VARYING_VECTORS``. The number of
      varying vectors that can used by shaders.

   -  `maxVertexTextures <#Integer>`__: The value of ``gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS``.
      The number of textures that can be used in a vertex shader.

   -  `maxVertexUniforms <#Integer>`__: The value of ``gl.MAX_VERTEX_UNIFORM_VECTORS``. The
      maximum number of uniforms that can be used in a vertex shader.

   -  `precision <#String>`__: The shader precision currently being used by the renderer.

   -  `vertexTextures <#Boolean>`__: ``true`` if [property:Integer maxVertexTextures] is
      greater than 0 (i.e. vertex textures can be used).

⭕:Array clippingPlanes
~~~~~~~~~~~~~~~~~~~~~~~~

   User-defined clipping planes specified as THREE.Plane objects in world space. These planes
   apply globally. Points in space whose dot product with the plane is negative are cut away.
   Default is [].

⭕:Object debug
~~~~~~~~~~~~~~~~

   - `checkShaderErrors <#Boolean>`__: If it is true, defines whether material shader
   programs are checked for errors during compilation and linkage process. It may be useful
   to disable this check in production for performance gain. It is strongly recommended to
   keep these checks enabled during development. If the shader does not compile and link -
   it will not work and associated material will not render. Default is ``true``.
   - `onShaderError <#Function>`__( gl, program, glVertexShader, glFragmentShader ): A
   callback function that can be used for custom error reporting. The callback receives the
   WebGL context, an instance of WebGLProgram as well two instances of WebGLShader
   representing the vertex and fragment shader. Assigning a custom function disables the
   default error reporting. Default is ``null``.

⭕:DOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~

   A `canvas <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas>`__ where
   the renderer draws its output.
   This is automatically created by the renderer in the constructor (if not provided
   already); you just need to add it to your page like so:
   ``document.body.appendChild( renderer.domElement );``

⭕:Object extensions
~~~~~~~~~~~~~~~~~~~~~

   - `get <#Object>`__( [param:String extensionName] ): Used to check whether various
   extensions are supported and returns an object with details of the extension if
   available. This method can check for the following extensions:

   -  ``WEBGL_depth_texture``
   -  ``EXT_texture_filter_anisotropic``
   -  ``WEBGL_compressed_texture_s3tc``
   -  ``WEBGL_compressed_texture_pvrtc``
   -  ``WEBGL_compressed_texture_etc1``

⭕:string outputColorSpace
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines the output color space of the renderer. Default is `THREE.SRGBColorSpace <#Textures>`__.

   If a render target has been set using `.setRenderTarget <#WebGLRenderer.setRenderTarget>`__ 
   then renderTarget.texture.colorSpace will be used instead.

   See the `texture constants <#Textures>`__ page for details of other formats.

⭕:Object info
~~~~~~~~~~~~~~~

   An object with a series of statistical information about the graphics board memory and the
   rendering process. Useful for debugging or just for the sake of curiosity. The object
   contains the following fields:

   -  memory:

      -  geometries
      -  textures

   -  render:

      -  calls
      -  triangles
      -  points
      -  lines
      -  frame

   -  programs

   By default these data are reset at each render call but when having multiple render passes
   per frame (e.g. when using post processing) it can be preferred to reset with a custom
   pattern. First, set ``autoReset`` to ``false``. ``renderer.info.autoReset = false;`` Call
   ``reset()`` whenever you have finished to render a single frame.

   .. code:: javascript

      renderer.info.reset();


⭕:Boolean localClippingEnabled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether the renderer respects object-level clipping planes. Default is ``false``.

⭕:Object properties
~~~~~~~~~~~~~~~~~~~~~

   Used internally by the renderer to keep track of various sub object properties.

⭕:WebGLRenderLists renderLists
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Used internally to handle ordering of scene object rendering.

⭕:WebGLShadowMap shadowMap
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This contains the reference to the shadow map, if used.
   - `enabled <#Boolean>`__: If set, use shadow maps in the scene. Default is ``false``.
   - `autoUpdate <#Boolean>`__: Enables automatic updates to the shadows in the scene.
   Default is ``true``.
   If you do not require dynamic lighting / shadows, you may set this to ``false`` when the
   renderer is instantiated.
   - `needsUpdate <#Boolean>`__: When set to ``true``, shadow maps in the scene will be
   updated in the next ``render`` call. Default is ``false``.
   If you have disabled automatic updates to shadow maps (``shadowMap.autoUpdate =
   false``), you will need to set this to ``true`` and then make a render call to update
   the shadows in your scene.
   - `type <#Integer>`__: Defines shadow map type (unfiltered, percentage close filtering,
   percentage close filtering with bilinear filtering in shader). Options are:

   -  THREE.BasicShadowMap
   -  THREE.PCFShadowMap (default)
   -  THREE.PCFSoftShadowMap
   -  THREE.VSMShadowMap

   See `Renderer constants <#Renderer>`__ for details.

⭕:Boolean sortObjects
~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether the renderer should sort objects. Default is ``true``.

   Note: Sorting is used to attempt to properly render objects that have some degree of
   transparency. By definition, sorting objects may not work in all cases. Depending on the
   needs of application, it may be necessary to turn off sorting and use other methods to
   deal with transparency rendering e.g. manually determining each object's rendering
   order.

⭕:Object state
~~~~~~~~~~~~~~~~

   Contains functions for setting various properties of the ``WebGLRenderer.context``
   state.

⭕:Constant toneMapping
~~~~~~~~~~~~~~~~~~~~~~~~

   Default is `NoToneMapping <#Renderer>`__. See the `Renderer constants <#Renderer>`__ for
   other choices.

⭕:Number toneMappingExposure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Exposure level of tone mapping. Default is ``1``.

⭕:WebXRManager xr
~~~~~~~~~~~~~~~~~~~

   Provides access to the WebXR related `interface <#WebXRManager>`__ of the renderer.

Methods
-------

📦:clear( Boolean color, Boolean depth, Boolean stencil ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Tells the renderer to clear its color, depth or stencil drawing buffer(s). This method
   initializes the color buffer to the current clear color value.
   Arguments default to ``true``.

📦:clearColor( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clear the color buffer. Equivalent to calling `.clear <#WebGLRenderer.clear>`__( true,
   false, false ).

📦:clearDepth( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clear the depth buffer. Equivalent to calling `.clear <#WebGLRenderer.clear>`__( false,
   true, false ).

📦:clearStencil( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clear the stencil buffers. Equivalent to calling `.clear <#WebGLRenderer.clear>`__( false,
   false, true ).

📦:compile( Object3D scene, Camera camera, Scene targetScene ) Set
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Compiles all materials in the scene with the camera. This is useful to precompile
   shaders before the first rendering. If you want to add a 3D object to an existing scene,
   use the third optional parameter for applying the target scene.
   Note that the (target) scene's lighting and environment should be configured before
   calling this method.

📦:compileAsync( Object3D scene, Camera camera, Scene targetScene ) Promise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Asynchronous version of `.compile <#WebGLRenderer.compile>`__(). The method returns a
   Promise that resolves when the given scene can be rendered without unnecessary stalling
   due to shader compilation.
   This method makes use of the ``KHR_parallel_shader_compile`` WebGL extension.

📦:copyFramebufferToTexture( FramebufferTexture texture, Vector2 position, Number level ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies pixels from the current WebGLFramebuffer into a 2D texture. Enables access to
   `WebGLRenderingContext.copyTexImage2D <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D>`__.

📦:copyTextureToTexture( Texture srcTexture, Texture dstTexture, Box2 srcRegion, Vector2 dstPosition, Number level ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the pixels of a texture in the bounds '`srcRegion <#Box2>`__' in the destination
   texture starting from the given position. Enables access to
   `WebGLRenderingContext.texSubImage2D <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D>`__.

📦:copyTextureToTexture3D( Texture srcTexture, Texture dstTexture, Box3 srcRegion, Vector3 dstPosition, Number level ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copies the pixels of a texture in the bounds '`srcRegion <#Box3>`__' in the destination
   texture starting from the given position. Enables access to
   `WebGL2RenderingContext.texSubImage3D <https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texSubImage3D>`__.

📦:dispose( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:forceContextLoss() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Simulate loss of the WebGL context. This requires support for the
   `WEBGL_lose_context <https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context>`__ extensions.

📦:forceContextRestore( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Simulate restore of the WebGL context. This requires support for the
   `WEBGL_lose_context <https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context>`__ extensions.

📦:getClearAlpha() Float
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a `float <#Float>`__ with the current clear alpha. Ranges from ``0`` to ``1``.

📦:getClearColor( Color target ) Color
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a `THREE.Color <#Color>`__ instance with the current clear color.

📦:getContext() WebGL2RenderingContext
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return the current WebGL context.

📦:getContextAttributes() WebGLContextAttributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns an object that describes the attributes set on the WebGL context when it was
   created.

📦:getActiveCubeFace() Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the current active cube face.

📦:getActiveMipmapLevel() Integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the current active mipmap level.

📦:getRenderTarget() RenderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the current `RenderTarget <#RenderTarget>`__ if there are; returns ``null``
   otherwise.

📦:getCurrentViewport( Vector4 target ) Vector4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector4>`__ — the result will be copied into this Vector4.
   Returns the current viewport.

📦:getDrawingBufferSize( Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector2>`__ — the result will be copied into this Vector2.
   Returns the width and height of the renderer's drawing buffer, in pixels.

📦:getPixelRatio() number
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns current device pixel ratio used.

📦:getScissor( Vector4 target ) Vector4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector4>`__ — the result will be copied into this Vector4.
   Returns the scissor region.

📦:getScissorTest() Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns ``true`` if scissor test is enabled; returns ``false`` otherwise.

📦:getSize( Vector2 target ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector2>`__ — the result will be copied into this Vector2.
   Returns the width and height of the renderer's output canvas, in pixels.

📦:getViewport( Vector4 target ) Vector4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector4>`__ — the result will be copied into this Vector4.
   Returns the viewport.

📦:initTexture( Texture texture ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Initializes the given texture. Useful for preloading a texture rather than waiting until
   first render (which can cause noticeable lags due to decode and GPU upload overhead).

📦:initRenderTarget( WebGLRenderTarget target ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so
   data can be copied into it using `.copyTextureToTexture <#WebGLRenderer.copyTextureToTexture>`__ 
   before it has been rendered to.

📦:resetGLState( ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Reset the GL state to default. Called internally if the WebGL context is lost.

📦:readRenderTargetPixels( WebGLRenderTarget renderTarget, Float x, Float y, Float width, Float height, TypedArray buffer, Integer activeCubeFaceIndex ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   buffer - Uint8Array is the only destination type supported in all cases, other types are
   renderTarget and platform dependent. See
   `WebGL spec <https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12>`__ for
   details.

   Reads the pixel data from the renderTarget into the buffer you pass in. This is a wrapper
   around
   `WebGLRenderingContext.readPixels <https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels>`__().

   For reading out a `WebGLCubeRenderTarget <#WebGLCubeRenderTarget>`__ use the optional
   parameter activeCubeFaceIndex to determine which face should be read.

📦:readRenderTargetPixelsAsync( WebGLRenderTarget renderTarget, Float x, Float y, Float width, Float height, TypedArray buffer, Integer activeCubeFaceIndex ) Promise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Asynchronous, non-blocking version of `.readRenderTargetPixels <#WebGLRenderer.readRenderTargetPixels>`__. 
   The returned promise resolves once the buffer data is ready to
   be used.

   See the [example:webgl_interactive_cubes_gpu interactive / cubes / gpu] example.

📦:render( Object3D scene, Camera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Render a `scene <#Scene>`__ or another type of `object <#Object3D>`__ using a
   `camera <#Camera>`__.
   The render is done to a previously specified `renderTarget <#WebGLRenderTarget>`__ set
   by calling `.setRenderTarget <#WebGLRenderer.setRenderTarget>`__ or to the canvas as
   usual.
   By default render buffers are cleared before rendering but you can prevent this by
   setting the property `autoClear <#WebGLRenderer.autoClear>`__ to false. If you want to
   prevent only certain buffers being cleared you can set either the
   `autoClearColor <#WebGLRenderer.autoClearColor>`__, `autoClearStencil <#WebGLRenderer.autoClearStencil>`__ 
   or `autoClearDepth <#WebGLRenderer.autoClearDepth>`__ properties to
   false. To forcibly clear one or more buffers call `.clear <#WebGLRenderer.clear>`__.

📦:resetState() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Can be used to reset the internal WebGL state. This method is mostly relevant for
   applications which share a single WebGL context across multiple WebGL libraries.

📦:setAnimationLoop( Function callback ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `callback <#Function>`__ — The function will be called every available frame. If ``null``
   is passed it will stop any already ongoing animation.

   A built in function that can be used instead of
   `requestAnimationFrame <https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame>`__. 
   For WebXR projects this function must be used.

📦:setClearAlpha( Float alpha ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the clear alpha. Valid input is a float between ``0.0`` and ``1.0``.

📦:setClearColor( Color color, Float alpha ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the clear color and opacity.

📦:setPixelRatio( number value ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output
   canvas.

📦:setRenderTarget( WebGLRenderTarget renderTarget, Integer activeCubeFace, Integer activeMipmapLevel ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   renderTarget -- The `renderTarget <#WebGLRenderTarget>`__ that needs to be activated.
   When ``null`` is given, the canvas is set as the active render target instead.
   activeCubeFace -- Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of
   ``WebGLCubeRenderTarget``. When passing a ``WebGLArrayRenderTarget`` or
   ``WebGL3DRenderTarget`` this indicates the z layer to render in to (optional).
   activeMipmapLevel -- Specifies the active mipmap level (optional).
   This method sets the active rendertarget.

📦:setScissor( Vector4 vector ) undefined
📦:setScissor( Integer x, Integer y, Integer width, Integer height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The x, y, width, and height parameters of the scissor region.
   Optionally, a 4-component vector specifying the parameters of the region.
   Sets the scissor region from (x, y) to (x + width, y + height).
   (x, y) is the lower-left corner of the scissor region.

📦:setScissorTest( Boolean boolean ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Enable or disable the scissor test. When this is enabled, only the pixels within the
   defined scissor area will be affected by further renderer actions.

📦:setOpaqueSort( Function method ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the
   default painterSortStable function.

📦:setTransparentSort( Function method ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the
   default reversePainterSortStable function.

📦:setSize( Integer width, Integer height, Boolean updateStyle ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resizes the output canvas to (width, height) with device pixel ratio taken into account,
   and also sets the viewport to fit that size, starting in (0, 0). Setting `updateStyle <#Boolean>`__ 
   to false prevents any style changes to the output canvas.

📦:setViewport( Vector4 vector ) undefined
📦:setViewport( Integer x, Integer y, Integer width, Integer height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The x, y, width, and height parameters of the viewport.
   Optionally, a 4-component vector specifying the parameters of a viewport.
   Sets the viewport to render from (x, y) to (x + width, y + height).
   (x, y) is the lower-left corner of the region.



.. _D206:

WebGLRenderTarget
=================

   https://threejs.org/docs/api/en/renderers/WebGLRenderTarget.html

   A `render target <https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html>`__
    is a buffer where the video card draws pixels for a scene that is being rendered
   in the background. It is used in different effects, such as applying postprocessing to a
   rendered image before displaying it on the screen.

   .. Constructor

🐣:WebGLRenderTarget(Number width, Number height, Object options)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `width <#Float>`__ - The width of the renderTarget. Default is ``1``.
   `height <#Float>`__ - The height of the renderTarget. Default is ``1``.
   options - optional object that holds texture parameters for an auto-generated target
   texture and depthBuffer/stencilBuffer booleans. For an explanation of the texture
   parameters see `Texture <#Texture>`__. The following are valid options:
   `wrapS <#Constant>`__ - default is `ClampToEdgeWrapping <#Textures>`__.
   `wrapT <#Constant>`__ - default is `ClampToEdgeWrapping <#Textures>`__.
   `magFilter <#Constant>`__ - default is `LinearFilter <#Textures>`__.
   `minFilter <#Constant>`__ - default is `LinearFilter <#Textures>`__.
   `generateMipmaps <#Boolean>`__ - default is ``false``.
   `format <#Constant>`__ - default is `RGBAFormat <#Textures>`__.
   `type <#Constant>`__ - default is `UnsignedByteType <#Textures>`__.
   `anisotropy <#Number>`__ - default is ``1``. See ``Texture.anisotropy``
   `colorSpace <#Constant>`__ - default is `NoColorSpace <#Textures>`__.
   `internalFormat <#String>`__ - default is ``null``.
   `depthBuffer <#Boolean>`__ - default is ``true``.
   `stencilBuffer <#Boolean>`__ - default is ``false``.
   `resolveDepthBuffer <#Boolean>`__ - default is ``true``.
   `resolveStencilBuffer <#Boolean>`__ - default is ``true``.
   `samples <#Number>`__ - default is ``0``.
   `count <#Number>`__ - default is ``1``.
   Creates a new ``WebGLRenderTarget``

Properties
----------

⭕:Boolean isWebGLRenderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``WebGLRenderTarget``.

⭕:number width
~~~~~~~~~~~~~~~~

   The width of the render target.

⭕:number height
~~~~~~~~~~~~~~~~~

   The height of the render target.

⭕:Vector4 scissor
~~~~~~~~~~~~~~~~~~~

   A rectangular area inside the render target's viewport. Fragments that are outside the
   area will be discarded.

⭕:Boolean scissorTest
~~~~~~~~~~~~~~~~~~~~~~~

   Indicates whether the scissor test is active or not.

⭕:Vector4 viewport
~~~~~~~~~~~~~~~~~~~~

   The viewport of this render target.

⭕:Texture texture
~~~~~~~~~~~~~~~~~~~

   This texture instance holds the rendered pixels. Use it as input for further processing.

⭕:Texture textures
~~~~~~~~~~~~~~~~~~~~

   An array holding the `texture <#WebGLRenderTarget.texture>`__ references of multiple
   render targets configured with the `count <#Number>`__ option.

⭕:Boolean depthBuffer
~~~~~~~~~~~~~~~~~~~~~~~

   Renders to the depth buffer. Default is true.

⭕:Boolean stencilBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~

   Renders to the stencil buffer. Default is false.

⭕:Boolean resolveDepthBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether the depth buffer should be resolved when rendering into a multisampled
   render target. Default is ``true``.

⭕:Boolean resolveStencilBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines whether the stencil buffer should be resolved when rendering into a multisampled
   render target. This property has no effect when ``.resolveDepthBuffer`` is set to
   ``false``. Default is ``true``.

⭕:DepthTexture depthTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If set, the scene depth will be rendered to this texture. Default is null.

⭕:Number samples
~~~~~~~~~~~~~~~~~~

   Defines the count of MSAA samples. Default is ``0``.

Methods
-------

📦:setSize( Number width, Number height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the size of the render target.

📦:clone() WebGLRenderTarget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a copy of this render target.

📦:copy( WebGLRenderTarget source ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adopts the settings of the given render target.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

   `EventDispatcher <#EventDispatcher>`__ methods are available on this class.



.. _D207:

WebGLRenderTarget → WebGL3DRenderTarget
=======================================

   https://threejs.org/docs/api/en/renderers/WebGL3DRenderTarget.html

   Represents a three-dimensional render target.

   .. Constructor

🐣:WebGL3DRenderTarget( Number width, Number height, Number depth, Object options )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `width <#Number>`__ - the width of the render target, in pixels. Default is ``1``.
   `height <#Number>`__ - the height of the render target, in pixels. Default is ``1``.
   `depth <#Number>`__ - the depth of the render target. Default is ``1``.
   `options <#Object>`__ - optional object that holds texture parameters for an
   auto-generated target texture and depthBuffer/stencilBuffer booleans. See
   ``WebGLRenderTarget`` for details.
   Creates a new ``WebGL3DRenderTarget``.

Properties
----------

   See ``WebGLRenderTarget`` for inherited properties.

⭕:number depth
~~~~~~~~~~~~~~~~

   The depth of the render target.

⭕:Data3DTexture texture
~~~~~~~~~~~~~~~~~~~~~~~~~

   The texture property is overwritten with an instance of ``Data3DTexture``.

Methods
-------

   See ``WebGLRenderTarget`` for inherited methods.



.. _D208:

WebGLRenderTarget → WebGLArrayRenderTarget
==========================================

   https://threejs.org/docs/api/en/renderers/WebGLArrayRenderTarget.html

   This type of render target represents an array of textures.

   **Examples**

   [example:webgl_rendertarget_texture2darray WebGL / render target / array]

   .. Constructor

🐣:WebGLArrayRenderTarget( Number width, Number height, Number depth, Object options )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `width <#Number>`__ - the width of the render target, in pixels. Default is ``1``.
   `height <#Number>`__ - the height of the render target, in pixels. Default is ``1``.
   `depth <#Number>`__ - the depth/layer count of the render target. Default is ``1``.
   `options <#Object>`__ - optional object that holds texture parameters for an
   auto-generated target texture and depthBuffer/stencilBuffer booleans. See
   ``WebGLRenderTarget`` for details.
   Creates a new ``WebGLArrayRenderTarget``.

Properties
----------

   See ``WebGLRenderTarget`` for inherited properties.

⭕:number depth
~~~~~~~~~~~~~~~~

   The depth of the render target.

⭕:DataArrayTexture texture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The texture property is overwritten with an instance of ``DataArrayTexture``.

Methods
-------

   See ``WebGLRenderTarget`` for inherited methods.



.. _D209:

WebGLRenderTarget → WebGLCubeRenderTarget
=========================================

   https://threejs.org/docs/api/en/renderers/WebGLCubeRenderTarget.html

   Used by the ``CubeCamera`` as its ``WebGLRenderTarget``.

   **Examples**

   See ``CubeCamera`` for examples.

   .. Constructor

🐣:WebGLCubeRenderTarget(Number size, Object options)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `size <#Float>`__ - the size, in pixels. Default is ``1``.
   options - (optional) object that holds texture parameters for an auto-generated target
   texture and depthBuffer/stencilBuffer booleans. For an explanation of the texture
   parameters see `Texture <#Texture>`__. The following are valid options:
   `wrapS <#Constant>`__ - default is `ClampToEdgeWrapping <#Textures>`__.
   `wrapT <#Constant>`__ - default is `ClampToEdgeWrapping <#Textures>`__.
   `magFilter <#Constant>`__ - default is `.LinearFilter <#Textures>`__.
   `minFilter <#Constant>`__ - default is `LinearFilter <#Textures>`__.
   `generateMipmaps <#Boolean>`__ - default is ``false``.
   `format <#Constant>`__ - default is `RGBAFormat <#Textures>`__.
   `type <#Constant>`__ - default is `UnsignedByteType <#Textures>`__.
   `anisotropy <#Number>`__ - default is ``1``. See ``Texture.anisotropy``
   `colorSpace <#Constant>`__ - default is `NoColorSpace <#Textures>`__.
   `depthBuffer <#Boolean>`__ - default is ``true``.
   `stencilBuffer <#Boolean>`__ - default is ``false``.
   Creates a new ``WebGLCubeRenderTarget``

Properties
----------

   See ``WebGLRenderTarget`` for inherited properties.

Methods
-------

   See ``WebGLRenderTarget`` for inherited methods.

📦:fromEquirectangularTexture( WebGLRenderer renderer, Texture texture ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderer <#WebGLRenderer>`__ — the renderer.
   `texture <#Texture>`__ — the equirectangular texture.

   Use this method if you want to convert an equirectangular panorama to the cubemap format.

📦:clear( WebGLRenderer renderer, Boolean color, Boolean depth, Boolean stencil ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Call this to clear the renderTarget's color, depth, and/or stencil buffers. The color
   buffer is set to the renderer's current clear color. Arguments default to ``true``.



.. _D210:

ShaderChunk
===========

   https://threejs.org/docs/api/en/renderers/shaders/ShaderChunk.html

   Shader chunks for WebGL Shader library

Properties
----------

Methods
-------



.. _D211:

ShaderLib
=========

   https://threejs.org/docs/api/en/renderers/shaders/ShaderLib.html

   Webgl Shader Library for three.js

Properties
----------

Methods
-------



.. _D212:

UniformsLib
===========

   https://threejs.org/docs/api/en/renderers/shaders/UniformsLib.html

   Uniforms library for shared webgl shaders

Properties
----------

Methods
-------



.. _D213:

UniformsUtils
=============

   https://threejs.org/docs/api/en/renderers/shaders/UniformsUtils.html

   Provides utility functions for managing uniforms.

Methods
-------

📦:clone( Object src ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   src -- An object representing uniform definitions.
   Clones the given uniform definitions by performing a deep-copy. That means if the
   `value <#Uniform.value>`__ of a uniform refers to an object like a ``Vector3`` or
   ``Texture``, the cloned uniform will refer to a new object reference.

📦:merge( Array uniforms ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   uniforms -- An array of objects containing uniform definitions.
   Merges the given uniform definitions into a single object. Since the method internally
   uses ``.clone``(), it performs a deep-copy when producing the merged uniform
   definitions.



.. _D214:

WebXRManager
============

   https://threejs.org/docs/api/en/renderers/webxr/WebXRManager.html

   This class represents an abstraction of the WebXR Device API and is internally used by
   ``WebGLRenderer``. ``WebGLCubeRenderTarget`` also provides a public interface that allows users to
   enable/disable XR and perform XR related tasks like for instance retrieving controllers.

Properties
----------

⭕:Boolean cameraAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether the manager's XR camera should be automatically updated or not.
   Default is ``true``.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   This flag notifies the renderer to be ready for XR rendering. Default is ``false``. Set it
   to ``true`` if you are going to use XR in your app.

⭕:Boolean isPresenting
~~~~~~~~~~~~~~~~~~~~~~~~

   Whether XR presentation is active or not. Default is ``false``. This flag is read-only and
   automatically set by ``WebGLCubeRenderTarget``.

Methods
-------

📦:getCamera() ArrayCamera
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns an instance of ``ArrayCamera`` which represents the XR camera of the active XR
   session. For each view it holds a separate camera object in its `cameras <#ArrayCamera.cameras>`__ property.

   The camera's ``fov`` is currently not used and does not reflect the fov of the XR camera.
   If you need the fov on app level, you have to compute in manually from the XR camera's
   projection matrices.

📦:getController( Integer index ) Group
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ — The index of the controller.
   Returns a ``Group`` representing the so called ``target ray`` space of the XR
   controller. Use this space for visualizing 3D objects that support the user in pointing
   tasks like UI interaction.

📦:getControllerGrip( Integer index ) Group
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ — The index of the controller.
   Returns a ``Group`` representing the so called ``grip`` space of the XR controller.
   Use this space if the user is going to hold other 3D objects like a lightsaber.


   Note: If you want to show something in the user's hand AND offer a pointing ray at the
   same time, you'll want to attached the handheld object to the group returned by
   ``.getControllerGrip``() and the ray to the group returned by ``.getController``().
   The idea is to have two different groups in two different coordinate spaces for the same
   WebXR controller.

📦:getFoveation() Float
~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the amount of foveation used by the XR compositor for the projection layer.

📦:getHand( Integer index ) Group
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `index <#Integer>`__ — The index of the controller.
   Returns a ``Group`` representing the so called ``hand`` or ``joint`` space of the XR
   controller. Use this space for visualizing the user's hands when no physical controllers
   are used.

📦:getReferenceSpace() String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the reference space.

📦:getSession() XRSession
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the ``XRSession`` object which allows a more fine-grained management of active
   WebXR sessions on application level.

📦:setFoveation( Float foveation ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `foveation <#Float>`__ — The foveation to set.
   Specifies the amount of foveation used by the XR compositor for the layer. Must be a
   value between ``0`` and ``1``.

📦:setFramebufferScaleFactor( Float framebufferScaleFactor ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `framebufferScaleFactor <#Float>`__ — The framebuffer scale factor to set.
   Specifies the scaling factor to use when determining the size of the framebuffer when
   rendering to a XR device. The value is relative to the default XR device display
   resolution. Default is ``1``. A value of ``0.5`` would specify a framebuffer with 50% of
   the display's native resolution.


   Note: It is not possible to change the framebuffer scale factor while presenting XR
   content.

📦:setReferenceSpace( XRReferenceSpace referenceSpace ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `referenceSpace <#XRReferenceSpace>`__ — A custom reference space.
   Can be used to configure a custom reference space which overwrites the default reference
   space.

📦:setReferenceSpaceType( String referenceSpaceType ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `referenceSpaceType <#String>`__ — The reference space type to set.
   Can be used to configure a spatial relationship with the user's physical environment.
   Depending on how the user moves in 3D space, setting an appropriate reference space can
   improve tracking. Default is ``local-floor``. Please check out the
   `MDN <https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpaceType>`__ for
   possible values and their use cases.

📦:updateCamera( PerspectiveCamera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the state of the XR camera. Use this method on app level if you set
   ``.cameraAutoUpdate`` to ``false``. The method requires the non-XR camera of the scene
   as a parameter. The passed in camera's transformation is automatically adjusted to the
   position of the XR camera when calling this method.


   Note: It is not possible to change the reference space type while presenting XR content.



.. _D215:

Fog
===

   https://threejs.org/docs/api/en/scenes/Fog.html

   This class contains the parameters that define linear fog, i.e., that grows linearly
   denser with the distance.

   **Code Example**


   .. code:: javascript

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog( 0xcccccc, 10, 15 );


   .. Constructor

🐣:Fog( Integer color, Float near, Float far )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The color parameter is passed to the ``Color`` constructor to set the color property.
   Color can be a hexadecimal integer or a CSS-style string.

Properties
----------

⭕:Boolean isFog
~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Fog``.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name of the object (doesn't need to be unique). Default is an empty string.

⭕:Color color
~~~~~~~~~~~~~~~

   Fog color. Example: If set to black, far away objects will be rendered black.

⭕:Float near
~~~~~~~~~~~~~~

   The minimum distance to start applying fog. Objects that are less than 'near' units from
   the active camera won't be affected by fog.

   Default is ``1``.

⭕:Float far
~~~~~~~~~~~~~

   The maximum distance at which fog stops being calculated and applied. Objects that are
   more than 'far' units away from the active camera won't be affected by fog.

   Default is ``1000``.

Methods
-------

📦:clone() Fog
~~~~~~~~~~~~~~~

   Returns a new fog instance with the same parameters as this one.

📦:toJSON() Object
~~~~~~~~~~~~~~~~~~~

   Return fog data in JSON format.



.. _D216:

FogExp2
=======

   https://threejs.org/docs/api/en/scenes/FogExp2.html

   This class contains the parameters that define exponential squared fog, which gives a
   clear view near the camera and a faster than exponentially densening fog farther from the
   camera.

   **Code Example**


   .. code:: javascript

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );


   .. Constructor

🐣:FogExp2( Integer color, Float density )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The color parameter is passed to the ``Color`` constructor to set the color property.
   Color can be a hexadecimal integer or a CSS-style string.

Properties
----------

⭕:Boolean isFogExp2
~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``FogExp2``.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name of the object (doesn't need to be unique). Default is an empty string.

⭕:Color color
~~~~~~~~~~~~~~~

   Fog color. Example: If set to black, far away objects will be rendered black.

⭕:Float density
~~~~~~~~~~~~~~~~~

   Defines how fast the fog will grow dense.

   Default is ``0.00025``.

Methods
-------

📦:clone() FogExp2
~~~~~~~~~~~~~~~~~~~

   Returns a new FogExp2 instance with the same parameters as this one.

📦:toJSON() Object
~~~~~~~~~~~~~~~~~~~

   Return FogExp2 data in JSON format.



.. _D217:

Object3D → Scene
================

   https://threejs.org/docs/api/en/scenes/Scene.html

   Scenes allow you to set up what and where is to be rendered by three.js. This is where you
   place objects, lights and cameras.

   .. Constructor


🐣:Scene()
~~~~~~~~~

   Create a new scene object.

Properties
----------

⭕:Object background
~~~~~~~~~~~~~~~~~~~~~

   Defines the background of the scene. Default is ``null``. Valid inputs are:

   -  A ``Color`` for defining a uniform colored background.
   -  A ``Texture`` for defining a (flat) textured background.
   -  Texture cubes (``CubeTexture``) or equirectangular textures for defining a skybox.


   Note: Any camera related configurations like ``zoom`` or ``view`` are ignored.

⭕:Float backgroundBlurriness
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the blurriness of the background. Only influences environment maps assigned to
   ``Scene.background``. Valid input is a float between ``0`` and ``1``. Default is ``0``.

⭕:Float backgroundIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Attenuates the color of the background. Only applies to background textures.
   Default is ``1``.

⭕:Euler backgroundRotation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the background in radians. Only influences environment maps assigned to
   ``Scene.background``. Default is ``(0,0,0)``.

⭕:Texture environment
~~~~~~~~~~~~~~~~~~~~~~~

   Sets the environment map for all physical materials in the scene. However, it's not
   possible to overwrite an existing texture assigned to ``MeshStandardMaterial.envMap``.
   Default is ``null``.

⭕:Float environmentIntensity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Attenuates the color of the environment. Only influences environment maps assigned to
   ``Scene.environment``. Default is ``1``.

⭕:Euler environmentRotation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The rotation of the environment map in radians. Only influences physical materials in the
   scene when ``.environment`` is used. Default is ``(0,0,0)``.

⭕:Fog fog
~~~~~~~~~~~

   A `fog <#Fog>`__ instance defining the type of fog that affects everything rendered in the
   scene. Default is ``null``.

⭕:Boolean isScene
~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Scene``.

⭕:Material overrideMaterial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Forces everything in the scene to be rendered with the defined material.
   Default is ``null``.

Methods
-------

📦:toJSON( Object meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- object containing metadata such as textures or images for the scene.
   Convert the scene to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.



.. _D218:

Texture → CanvasTexture
=======================

   https://threejs.org/docs/api/en/textures/CanvasTexture.html

   Creates a texture from a canvas element.
   This is almost the same as the base `Texture <#Texture>`__ class, except that it sets
   `needsUpdate <#Texture.needsUpdate>`__ to ``true`` immediately.

   .. Constructor

🐣:CanvasTexture( HTMLElement canvas, Constant mapping, Constant wrapS, Constant wrapT, Constant magFilter, Constant minFilter, Constant format, Constant type, Number anisotropy )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `canvas <#HTMLElement>`__ -- The HTML canvas element from which to load the texture.
   `mapping <#Constant>`__ -- How the image is applied to the object. An object type of
   `THREE.UVMapping <#Textures>`__. See `mapping constants <#Textures>`__ for other
   choices.
   `wrapS <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. See
   `wrap mode constants <#Textures>`__ for other choices.
   `wrapT <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. See
   `wrap mode constants <#Textures>`__ for other choices.
   `magFilter <#Constant>`__ -- How the texture is sampled when a texel covers more than
   one pixel. The default is `THREE.LinearFilter <#Textures>`__. 
   See `magnification filter constants <#Textures>`__ for other choices.
   `minFilter <#Constant>`__ -- How the texture is sampled when a texel covers less than
   one pixel. The default is `THREE.LinearMipmapLinearFilter <#Textures>`__. See
   `minification filter constants <#Textures>`__ for other choices.
   `format <#Constant>`__ -- The format used in the texture. See `format constants <#Textures>`__ for other choices.
   `type <#Constant>`__ -- Default is `THREE.UnsignedByteType <#Textures>`__. See
   `type constants <#Textures>`__ for other choices.
   `anisotropy <#Number>`__ -- The number of samples taken along the axis through the pixel
   that has the highest density of texels. By default, this value is ``1``. A higher value
   gives a less blurry result than a basic mipmap, at the cost of more texture samples
   being used. Use `renderer.getMaxAnisotropy <#WebGLrenderer.getMaxAnisotropy>`__() to
   find the maximum valid anisotropy value for the GPU; this value is usually a power of 2.

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean isCanvasTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``CanvasTexture``.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   True by default. This is required so that the canvas data is loaded.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D219:

Texture → CompressedTexture
===========================

   https://threejs.org/docs/api/en/textures/CompressedTexture.html

   Creates a texture based on data in compressed form, for example from a
   `DDS <https://en.wikipedia.org/wiki/DirectDraw_Surface>`__ file.
   For use with the `CompressedTextureLoader <#CompressedTextureLoader>`__.

   .. Constructor

🐣:CompressedTexture( Array mipmaps, Number width, Number height, Constant format, Constant type, Constant mapping, Constant wrapS, Constant wrapT, Constant magFilter, Constant minFilter, Number anisotropy, Constant colorSpace )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `mipmaps <#Array>`__ -- The mipmaps array should contain objects with data, width and
      height. The mipmaps should be of the correct format and type.

   -  `width <#Number>`__ -- The width of the biggest mipmap.

   -  `height <#Number>`__ -- The height of the biggest mipmap.

   -  `format <#Constant>`__ -- The format used in the mipmaps. 
      See `ST3C Compressed Texture Formats <#Textures>`__, 
      `PVRTC Compressed Texture Formats <#Textures>`__ 
      and `ETC Compressed Texture Format <#Textures>`__ for other choices.

   -  `type <#Constant>`__ -- Default is `THREE.UnsignedByteType <#Textures>`__. See

   -  `type constants <#Textures>`__ for other choices.

   -  `mapping <#Constant>`__ -- How the image is applied to the object. An object type of
      `THREE.UVMapping <#Textures>`__. See `mapping constants <#Textures>`__ for other
      choices.

   -  `wrapS <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. See

   -  `wrap mode constants <#Textures>`__ for other choices.

   -  `wrapT <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. See

   -  `wrap mode constants <#Textures>`__ for other choices.

   -  `magFilter <#Constant>`__ -- How the texture is sampled when a texel covers more than
      one pixel. The default is `THREE.LinearFilter <#Textures>`__. 
      See `magnification filter constants <#Textures>`__ for other choices.

   -  `minFilter <#Constant>`__ -- How the texture is sampled when a texel covers less than
      one pixel. The default is `THREE.LinearMipmapLinearFilter <#Textures>`__. See

   -  `minification filter constants <#Textures>`__ for other choices.

   -  `anisotropy <#Number>`__ -- The number of samples taken along the axis through the pixel
      that has the highest density of texels. By default, this value is ``1``. A higher value
      gives a less blurry result than a basic mipmap, at the cost of more texture samples
      being used. Use renderer.getMaxAnisotropy() to find the maximum valid anisotropy value
      for the GPU; this value is usually a power of 2.

   -  `colorSpace <#Constant>`__ -- The default is `THREE.NoColorSpace <#Textures>`__. See

   -  `color space constants <#Textures>`__ for other choices.

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean flipY
~~~~~~~~~~~~~~~~~

   False by default. Flipping textures does not work for compressed textures.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   False by default. Mipmaps can't be generated for compressed textures

⭕:Object image
~~~~~~~~~~~~~~~~

   Overridden with a object containing width and height.

⭕:Boolean isCompressedTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``CompressedTexture``.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D220:

CompressedTexture → CompressedArrayTexture
==========================================

   https://threejs.org/docs/api/en/textures/CompressedArrayTexture.html

   Creates an texture 2D array based on data in compressed form, for example from a
   `DDS <https://en.wikipedia.org/wiki/DirectDraw_Surface>`__ file.
   For use with the `CompressedTextureLoader <#CompressedTextureLoader>`__.

   .. Constructor

🐣:CompressedArrayTexture( Array mipmaps, Number width, Number height, Constant format, Constant type )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `mipmaps <#Array>`__ -- The mipmaps array should contain objects with data, width and
      height. The mipmaps should be of the correct format and type.
   -  `width <#Number>`__ -- The width of the biggest mipmap.
   -  `height <#Number>`__ -- The height of the biggest mipmap.
   -  `depth <#Number>`__ -- The number of layers of the 2D array texture.
   -  `format <#Constant>`__ -- The format used in the mipmaps. 
      See `ST3C Compressed Texture Formats <#Textures>`__, 
      `PVRTC Compressed Texture Formats <#Textures>`__ 
      and  `ETC Compressed Texture Format <#Textures>`__ for other choices.
   -  `type <#Constant>`__ -- Default is `THREE.UnsignedByteType <#Textures>`__. 
      See `type constants <#Textures>`__ for other choices.

Properties
----------

   See the base `CompressedTexture <#CompressedTexture>`__ class for common properties.

⭕:number wrapR
~~~~~~~~~~~~~~~~

   This defines how the texture is wrapped in the depth direction.
   The default is `THREE.ClampToEdgeWrapping <#Textures>`__, where the edge is clamped to
   the outer edge texels. The other two choices are `THREE.RepeatWrapping <#Textures>`__
   and `THREE.MirroredRepeatWrapping <#Textures>`__. See the `texture constants <#Textures>`__ 
   page for details.

⭕:Object image
~~~~~~~~~~~~~~~~

   Overridden with a object containing width, height, and depth.

⭕:Set layerUpdates
~~~~~~~~~~~~~~~~~~~~

   A set of all layers which need to be updated in the texture. See
   [Page:CompressedTextureArray.addLayerUpdate addLayerUpdate].

⭕:Boolean isCompressedArrayTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``CompressedArrayTexture``.

Methods
-------

📦:addLayerUpdate( layerIndex ) addLayerUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Describes that a specific layer of the texture needs to be updated. Normally when
   `needsUpdate <#Texture.needsUpdate>`__ is set to true, the entire compressed texture array
   is sent to the GPU. Marking specific layers will only transmit subsets of all mipmaps
   associated with a specific depth in the array which is often much more performant.

📦:clearLayerUpdates() clearLayerUpdates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resets the layer updates registry. See [Page:CompressedTextureArray.addLayerUpdate
   addLayerUpdate].

   See the base `CompressedTexture <#CompressedTexture>`__ class for common methods.



.. _D221:

Texture → CubeTexture
=====================

   https://threejs.org/docs/api/en/textures/CubeTexture.html

   Creates a cube texture made up of six images.

   **Code Example**


   .. code:: javascript

      const loader = new THREE.CubeTextureLoader();
      loader.setPath( 'textures/cube/pisa/' );
      const textureCube = loader.load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] );
      const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );


   .. Constructor

🐣:CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   CubeTexture is almost equivalent in functionality and usage to ``Texture``. The only
   differences are that the images are an array of 6 images as opposed to a single image, and
   the mapping options are `THREE.CubeReflectionMapping <#Textures>`__ (default) or
   `THREE.CubeRefractionMapping <#Textures>`__

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean flipY
~~~~~~~~~~~~~~~~~

   If set to ``true``, the texture is flipped along the vertical axis when uploaded to the
   GPU. Default is ``false``.

⭕:Boolean isCubeTexture
~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``CubeTexture``.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D222:

Texture → Data3DTexture
=======================

   https://threejs.org/docs/api/en/textures/Data3DTexture.html

   Creates a three-dimensional texture from raw data, with parameters to divide it into
   width, height, and depth.

   .. Constructor

🐣:Data3DTexture( TypedArray data, Number width, Number height, Number depth )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `data <#Object>`__ -- `ArrayBufferView` of the texture.
   -  `width <#Number>`__ -- width of the texture.
   -  `height <#Number>`__ -- height of the texture.
   -  `depth <#Number>`__ -- depth of the texture.

   **Code Example**

   This creates a ``Data3DTexture`` with repeating data, 0 to 255


   .. code:: javascript

      // create a buffer with some data
      const sizeX = 64;
      const sizeY = 64;
      const sizeZ = 64;

      const data = new Uint8Array( sizeX * sizeY * sizeZ );
      let i = 0;

      for ( let z = 0; z < sizeZ; z ++ ) {
         for ( let y = 0; y < sizeY; y ++ ) {
            for ( let x = 0; x < sizeX; x ++ ) {
               data[ i ] = i % 256;
               i ++;
            }
         }
      }

      // use the buffer to create the texture
      const texture = new THREE.Data3DTexture( data, sizeX, sizeY, sizeZ );
      texture.needsUpdate = true;


   **Examples**

   [example:webgl_texture3d WebGL / texture3d]
   [example:webgl_texture3d_partialupdate WebGL / texture3d / partialupdate]
   [example:webgl_volume_cloud WebGL / volume / cloud]
   [example:webgl_volume_perlin WebGL / volume / perlin]

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean flipY
~~~~~~~~~~~~~~~~~

   Whether the texture is flipped along the Y axis when uploaded to the GPU.
   Default is ``false``.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to generate mipmaps (if possible) for the texture. Default is ``false``.

⭕:Image image
~~~~~~~~~~~~~~~

   Overridden with a record type holding data, width and height and depth.

⭕:Boolean isData3DTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Data3DTexture``.

⭕:number magFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers more than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__, which uses the value of the closest texel.
   See the `texture constants <#Textures>`__ page for details.

⭕:number minFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers less than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__, which uses the value of the closest texel.
   See the `texture constants <#Textures>`__ page for details.

⭕:number unpackAlignment
~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``1`` by default. Specifies the alignment requirements for the start of each pixel row in
   memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered
   bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See
   `glPixelStorei <https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glPixelStorei.xhtml>`__ 
   for more information.

⭕:number wrapR
~~~~~~~~~~~~~~~~

   This defines how the texture is wrapped in the depth direction.
   The default is `THREE.ClampToEdgeWrapping <#Textures>`__, where the edge is clamped to
   the outer edge texels. The other two choices are `THREE.RepeatWrapping <#Textures>`__
   and `THREE.MirroredRepeatWrapping <#Textures>`__. See the `texture constants <#Textures>`__
   page for details.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D223:

Texture → DataArrayTexture
==========================

   https://threejs.org/docs/api/en/textures/DataArrayTexture.html

   Creates an array of textures directly from raw data, width and height and depth.

   .. Constructor

🐣:DataArrayTexture( data, width, height, depth )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The data argument must be an
   `ArrayBufferView <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>`__.
   The properties inherited from ``Texture`` are the default, except magFilter and
   minFilter default to THREE.NearestFilter. The properties flipY and generateMipmaps are
   initially set to false.

   The interpretation of the data depends on type and format: If the type is
   THREE.UnsignedByteType, a Uint8Array will be useful for addressing the texel data. If
   the format is THREE.RGBAFormat, data needs four values for one texel; Red, Green, Blue
   and Alpha (typically the opacity).
   For the packed types, THREE.UnsignedShort4444Type and THREE.UnsignedShort5551Type all
   color components of one texel can be addressed as bitfields within an integer element of
   a Uint16Array.
   In order to use the types THREE.FloatType and THREE.HalfFloatType, the WebGL
   implementation must support the respective extensions OES_texture_float and
   OES_texture_half_float. In order to use THREE.LinearFilter for component-wise, bilinear
   interpolation of the texels based on these types, the WebGL extensions
   OES_texture_float_linear or OES_texture_half_float_linear must also be present.

   **Code Example**

   This creates a ``DataArrayTexture`` where each texture has a different color.


   .. code:: javascript

      // create a buffer with color data
      const width = 512;
      const height = 512;
      const depth = 100;

      const size = width * height;
      const data = new Uint8Array( 4 * size * depth );

      for ( let i = 0; i < depth; i ++ ) {
         const color = new THREE.Color( Math.random(), Math.random(), Math.random() );
         const r = Math.floor( color.r * 255 );
         const g = Math.floor( color.g * 255 );
         const b = Math.floor( color.b * 255 );

         for ( let j = 0; j < size; j ++ ) {
            const stride = ( i * size + j ) * 4;
            data[ stride ] = r;
            data[ stride + 1 ] = g;
            data[ stride + 2 ] = b;
            data[ stride + 3 ] = 255;
         }
      }

      // used the buffer to create a DataArrayTexture
      const texture = new THREE.DataArrayTexture( data, width, height, depth );
      texture.needsUpdate = true;


   **Examples**

   [example:webgl_texture2darray WebGL / texture2darray]
   [example:webgl_rendertarget_texture2darray WebGL / rendertarget / texture2darray]

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean flipY
~~~~~~~~~~~~~~~~~

   Whether the texture is flipped along the Y axis when uploaded to the GPU.
   Default is ``false``.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to generate mipmaps (if possible) for the texture. Default is ``false``.

⭕:Object image
~~~~~~~~~~~~~~~~

   Overridden with a object holding data, width, height, and depth.

⭕:Boolean isDataArrayTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``DataArrayTexture``.

⭕:number magFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers more than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__, which uses the value of the closest texel.
   See the `texture constants <#Textures>`__ page for details.

⭕:number minFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers less than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__, which uses the value of the closest texel.
   See the `texture constants <#Textures>`__ page for details.

⭕:number unpackAlignment
~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``1`` by default. Specifies the alignment requirements for the start of each pixel row in
   memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered
   bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See
   `glPixelStorei <https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glPixelStorei.xhtml>`__ 
   for more information.

⭕:number wrapR
~~~~~~~~~~~~~~~~

   This defines how the texture is wrapped in the depth direction.
   The default is `THREE.ClampToEdgeWrapping <#Textures>`__, where the edge is clamped to
   the outer edge texels. The other two choices are `THREE.RepeatWrapping <#Textures>`__
   and `THREE.MirroredRepeatWrapping <#Textures>`__. See the `texture constants <#Textures>`__ 
   page for details.

⭕:Set layerUpdates
~~~~~~~~~~~~~~~~~~~~

   A set of all layers which need to be updated in the texture. See
   [Page:DataArrayTexture.addLayerUpdate addLayerUpdate].

Methods
-------

📦:addLayerUpdate( layerIndex ) addLayerUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Describes that a specific layer of the texture needs to be updated. Normally when
   `needsUpdate <#Texture.needsUpdate>`__ is set to true, the entire compressed texture array
   is sent to the GPU. Marking specific layers will only transmit subsets of all mipmaps
   associated with a specific depth in the array which is often much more performant.

📦:clearLayerUpdates() clearLayerUpdates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resets the layer updates registry. See [Page:DataArrayTexture.addLayerUpdate
   addLayerUpdate].

   See the base `Texture <#Texture>`__ class for common methods.



.. _D224:

Texture → DataTexture
=====================

   https://threejs.org/docs/api/en/textures/DataTexture.html

   Creates a texture directly from raw data, width and height.

   .. Constructor

🐣:DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The data argument must be an `ArrayBufferView <https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView>`__.
   Further parameters correspond to the properties inherited from ``Texture``, where both
   magFilter and minFilter default to THREE.NearestFilter.

   The interpretation of the data depends on type and format: If the type is
   THREE.UnsignedByteType, a Uint8Array will be useful for addressing the texel data. If
   the format is THREE.RGBAFormat, data needs four values for one texel; Red, Green, Blue
   and Alpha (typically the opacity).

   For the packed types, THREE.UnsignedShort4444Type and THREE.UnsignedShort5551Type all
   color components of one texel can be addressed as bitfields within an integer element of
   a Uint16Array.

   In order to use the types THREE.FloatType and THREE.HalfFloatType, the WebGL
   implementation must support the respective extensions OES_texture_float and
   OES_texture_half_float. In order to use THREE.LinearFilter for component-wise, bilinear
   interpolation of the texels based on these types, the WebGL extensions
   OES_texture_float_linear or OES_texture_half_float_linear must also be present.

   **Code Example**


   .. code:: javascript

      // create a buffer with color data

      const width = 512;
      const height = 512;

      const size = width * height;
      const data = new Uint8Array( 4 * size );
      const color = new THREE.Color( 0xffffff );

      const r = Math.floor( color.r * 255 );
      const g = Math.floor( color.g * 255 );
      const b = Math.floor( color.b * 255 );

      for ( let i = 0; i < size; i ++ ) {
         const stride = i * 4;
         data[ stride ] = r;
         data[ stride + 1 ] = g;
         data[ stride + 2 ] = b;
         data[ stride + 3 ] = 255;
      }

      // used the buffer to create a DataTexture
      const texture = new THREE.DataTexture( data, width, height );
      texture.needsUpdate = true;



Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean flipY
~~~~~~~~~~~~~~~~~

   If set to ``true``, the texture is flipped along the vertical axis when uploaded to the
   GPU. Default is ``false``.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to generate mipmaps (if possible) for a texture. False by default.

⭕:Object image
~~~~~~~~~~~~~~~~

   Overridden with a object holding data, width, and height.

⭕:Boolean isDataTexture
~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``DataTexture``.

⭕:number unpackAlignment
~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``1`` by default. Specifies the alignment requirements for the start of each pixel row in
   memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered
   bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See
   `glPixelStorei <http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml>`__
   for more information.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D225:

Texture → DepthTexture
======================

   https://threejs.org/docs/api/en/textures/DepthTexture.html

   This class can be used to automatically save the depth information of a rendering into a
   texture.

   **Examples**

   [example:webgl_depth_texture depth / texture]

   .. Constructor

🐣:DepthTexture( Number width, Number height, Constant type, Constant mapping, Constant wrapS, Constant wrapT, Constant magFilter, Constant minFilter, Number anisotropy, Constant format )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `width <#Number>`__ -- width of the texture.
   -  `height <#Number>`__ -- height of the texture.
   -  `type <#Constant>`__ -- Default is `THREE.UnsignedIntType <#Textures>`__. 
      See  `DepthTexture.type <#DepthTexture>`__ for other choices.
   -  `mapping <#Constant>`__ -- See `mapping mode constants <#Textures>`__ for details.
   -  `wrapS <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. 
      See  `wrap mode constants <#Textures>`__ for other choices.
   -  `wrapT <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. 
      See  `wrap mode constants <#Textures>`__ for other choices.
   -  `magFilter <#Constant>`__ -- How the texture is sampled when a texel covers more than
      one pixel. The default is `THREE.NearestFilter <#Textures>`__. 
      See `magnification filter constants <#Textures>`__ for other choices.
   -  `minFilter <#Constant>`__ -- How the texture is sampled when a texel covers less than
      one pixel. The default is `THREE.NearestFilter <#Textures>`__. 
      See `minification filter constants <#Textures>`__ for other choices.
   -  `anisotropy <#Number>`__ -- The number of samples taken along the axis through the pixel
      that has the highest density of texels. By default, this value is ``1``. A higher value
      gives a less blurry result than a basic mipmap, at the cost of more texture samples
      being used. Use `renderer.getMaxAnisotropy <#WebGLrenderer.getMaxAnisotropy>`__() to
      find the maximum valid anisotropy value for the GPU; this value is usually a power of 2.
   -  `format <#Constant>`__ -- must be either `DepthFormat <#Textures>`__ (default) or
      `DepthStencilFormat <#Textures>`__. See `format constants <#Textures>`__ for details.

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties - the following are also
   part of the texture class, but have different defaults here.

   `format <#Texture.format>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Either `DepthFormat <#Textures>`__ (default) or `DepthStencilFormat <#Textures>`__. See
   `format constants <#Textures>`__ for details.

   `type <#Texture.type>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~

   Default is `THREE.UnsignedIntType <#Textures>`__. The following are options and how they
   map to internal gl depth format types depending on the stencil format, as well:
   `THREE.UnsignedIntType <#Textures>`__ -- Uses DEPTH_COMPONENT24 or DEPTH24_STENCIL8
   internally.
   `THREE.FloatType <#Textures>`__ -- Uses DEPTH_COMPONENT32F or DEPTH32F_STENCIL8
   internally.
   `THREE.UnsignedShortType <#Textures>`__ -- Uses DEPTH_COMPONENT16 internally. Stencil
   buffer is unsupported when using this type.

   `magFilter <#Texture.magFilter>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers more than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__. See `magnification filter constants <#Textures>`__
   for other choices.

   `minFilter <#Texture.minFilter>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers less than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__. See `magnification filter constants <#Textures>`__
   for other choices.

   `flipY <#Texture.flipY>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~~~

   Depth textures do not need to be flipped so this is ``false`` by default.

   `.generateMipmaps <#Texture.generateMipmaps>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Depth textures do not use mipmaps.

⭕:Boolean isDepthTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``DepthTexture``.

⭕:number compareFunction
~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is used to define the comparison function used when comparing texels in the depth
   texture to the value in the depth buffer. Default is ``null`` which means comparison is
   disabled.

   See the `texture constants <#Textures>`__ page for details of other functions.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D226:

Texture → FramebufferTexture
============================

   https://threejs.org/docs/api/en/textures/FramebufferTexture.html

   This class can only be used in combination with
   ``WebGLRenderer.copyFramebufferToTexture``().


   .. code:: javascript

      const pixelRatio = window.devicePixelRatio;
      const textureSize = 128 * pixelRatio;

      // instantiate a framebuffer texture
      const frameTexture = new FramebufferTexture( textureSize, textureSize );

      // calculate start position for copying part of the frame data
      const vector = new Vector2();
      vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );
      vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );

      // render the scene
      renderer.clear();
      renderer.render( scene, camera );

      // copy part of the rendered frame into the framebuffer texture
      renderer.copyFramebufferToTexture( frameTexture, vector );


   **Examples**

   [example:webgl_framebuffer_texture]

   .. Constructor

🐣:FramebufferTexture( Number width, Number height )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `width <#Number>`__ -- The width of the texture.
   `height <#Number>`__ -- The height of the texture.

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to generate mipmaps for the ``FramebufferTexture``. Default value is ``false``.

⭕:Boolean isFramebufferTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``FramebufferTexture``.

⭕:number magFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers more than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__, which uses the value of the closest texel.
   See `texture constants <#Textures>`__ for details.

⭕:number minFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers less than one pixel. The default is
   `THREE.NearestFilter <#Textures>`__, which uses the value of the closest texel.
   See `texture constants <#Textures>`__ for details.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   True by default. This is required so that the canvas data is loaded.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.



.. _D227:

Source
======

   https://threejs.org/docs/api/en/textures/Source.html

   Represents the data source of a texture.

   .. Constructor

🐣:Source( Any data )
~~~~~~~~~~~~~~~~~~~~

   `data <#Any>`__ -- The data definition of a texture. Default is ``null``.

Properties
----------

⭕:Any data
~~~~~~~~~~~~

   The actual data of a texture. The type of this property depends on the texture that uses
   this instance.

⭕:Boolean isSource
~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Source``.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   When the property is set to ``true``, the engine allocates the memory for the texture (if
   necessary) and triggers the actual texture upload to the GPU next time the source is used.

⭕:Boolean dataReady
~~~~~~~~~~~~~~~~~~~~~

   This property is only relevant when ``.needUpdate`` is set to ``true`` and provides
   more control on how texture data should be processed. When ``dataReady`` is set to
   ``false``, the engine performs the memory allocation (if necessary) but does not transfer
   the data into the GPU memory. Default is ``true``.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this object
   instance. This gets automatically assigned, so this shouldn't be edited.

⭕:Integer version
~~~~~~~~~~~~~~~~~~~

   This starts at ``0`` and counts how many times `.needsUpdate <#Source.needsUpdate>`__ is
   set to ``true``.

Methods
-------

📦:toJSON( Object meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- optional object containing metadata.
   Convert the data source to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.



.. _D228:

Texture
=======

   https://threejs.org/docs/api/en/textures/Texture.html

   Create a texture to apply to a surface or as a reflection or refraction map.


   Note: After the initial use of a texture, its dimensions, format, and type cannot be
   changed. Instead, call ``.dispose``() on the texture and instantiate a new one.

   **Code Example**


   .. code:: javascript

      // load a texture, set wrap mode to repeat 
      const texture = new THREE.TextureLoader().load( "textures/water.jpg" );
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set( 4, 4 );


   .. Constructor

🐣:Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Properties
----------

⭕:Integer id
~~~~~~~~~~~~~~

   Readonly - unique number for this texture instance.

⭕:Boolean isTexture
~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``Texture``.

⭕:String uuid
~~~~~~~~~~~~~~~

   `UUID <http://en.wikipedia.org/wiki/Universally_unique_identifier>`__ of this object
   instance. This gets automatically assigned, so this shouldn't be edited.

⭕:String name
~~~~~~~~~~~~~~~

   Optional name of the object (doesn't need to be unique). Default is an empty string.

⭕:Image image
~~~~~~~~~~~~~~~

   An image object, typically created using the ``TextureLoader.load`` method. This can
   be any image (e.g., PNG, JPG, GIF, DDS) or video (e.g., MP4, OGG/OGV) type supported by
   three.js.
   To use video as a texture you need to have a playing HTML5 video element as a source for
   your texture image and continuously update this texture as long as video is playing -
   the `VideoTexture <#VideoTexture>`__ class handles this automatically.

⭕:Array mipmaps
~~~~~~~~~~~~~~~~~

   Array of user-specified mipmaps (optional).

⭕:number mapping
~~~~~~~~~~~~~~~~~~

   How the image is applied to the object. An object type of `THREE.UVMapping <#Textures>`__ 
   is the default, where the U,V coordinates are used to apply the map.
   See the `texture constants <#Textures>`__ page for other mapping types.

⭕:Integer channel
~~~~~~~~~~~~~~~~~~~

   Lets you select the uv attribute to map the texture to. ``0`` for ``uv``, ``1`` for
   ``uv1``, ``2`` for ``uv2`` and ``3`` for ``uv3``.

⭕:number wrapS
~~~~~~~~~~~~~~~~

   This defines how the texture is wrapped horizontally and corresponds to ``U`` in UV
   mapping.

   The default is `THREE.ClampToEdgeWrapping <#Textures>`__, where the edge is clamped to
   the outer edge texels. The other two choices are `THREE.RepeatWrapping <#Textures>`__
   and `THREE.MirroredRepeatWrapping <#Textures>`__. See the `texture constants <#Textures>`__ 
   page for details.

⭕:number wrapT
~~~~~~~~~~~~~~~~

   This defines how the texture is wrapped vertically and corresponds to ``V`` in UV
   mapping.
   The same choices are available as for [property:number wrapS].
   NOTE: tiling of images in textures only functions if image dimensions are powers of two
   (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels. Individual
   dimensions need not be equal, but each must be a power of two. This is a limitation of
   WebGL, not three.js.

⭕:number magFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers more than one pixel. The default is
   `THREE.LinearFilter <#Textures>`__, which takes the four closest texels and bilinearly
   interpolates among them. The other option is `THREE.NearestFilter <#Textures>`__, which
   uses the value of the closest texel.
   See the `texture constants <#Textures>`__ page for details.

⭕:number minFilter
~~~~~~~~~~~~~~~~~~~~

   How the texture is sampled when a texel covers less than one pixel. The default is
   `THREE.LinearMipmapLinearFilter <#Textures>`__, which uses mipmapping and a trilinear
   filter.
   See the `texture constants <#Textures>`__ page for all possible choices.

⭕:number anisotropy
~~~~~~~~~~~~~~~~~~~~~

   The number of samples taken along the axis through the pixel that has the highest density
   of texels. By default, this value is ``1``. A higher value gives a less blurry result than
   a basic mipmap, at the cost of more texture samples being used. Use
   `renderer.capabilities.getMaxAnisotropy <#WebGLRenderer.capabilities>`__() to find the
   maximum valid anisotropy value for the GPU; this value is usually a power of 2.

⭕:number format
~~~~~~~~~~~~~~~~~

   The default is `THREE.RGBAFormat <#Textures>`__.
   See the `texture constants <#Textures>`__ page for details of other formats.

⭕:String internalFormat
~~~~~~~~~~~~~~~~~~~~~~~~~

   The default value is obtained using a combination of `.format <#Texture.format>`__ and
   `.type <#Texture.type>`__.
   The GPU format allows the developer to specify how the data is going to be stored on the
   GPU.
   See the `texture constants <#Textures>`__ page for details regarding all supported
   internal formats.

⭕:number type
~~~~~~~~~~~~~~~

   This must correspond to the `.format <#Texture.format>`__. The default is
    `THREE.UnsignedByteType <#Textures>`__, which will be used for most texture formats.
   See the `texture constants <#Textures>`__ page for details of other formats.

⭕:Vector2 offset
~~~~~~~~~~~~~~~~~~

   How much a single repetition of the texture is offset from the beginning, in each
   direction U and V. Typical range is ``0.0`` to ``1.0``.

⭕:Vector2 repeat
~~~~~~~~~~~~~~~~~~

   How many times the texture is repeated across the surface, in each direction U and V. If
   repeat is set greater than 1 in either direction, the corresponding Wrap parameter should
   also be set to `THREE.RepeatWrapping <#Textures>`__ or `THREE.MirroredRepeatWrapping <#Textures>`__ 
   to achieve the desired tiling effect.

⭕:number rotation
~~~~~~~~~~~~~~~~~~~

   How much the texture is rotated around the center point, in radians. Positive values are
   counter-clockwise. Default is ``0``.

⭕:Vector2 center
~~~~~~~~~~~~~~~~~~

   The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of
   the texture. Default is (0, 0), the lower left.

⭕:Boolean matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to update the texture's uv-transform `.matrix <#Texture.matrix>`__ from the
   texture properties `.offset <#Texture.offset>`__, `.repeat <#Texture.repeat>`__,
   `.rotation <#Texture.rotation>`__, and `.center <#Texture.center>`__. True by default. Set
   this to false if you are specifying the uv-transform matrix directly.

⭕:Matrix3 matrix
~~~~~~~~~~~~~~~~~~

   The uv-transform matrix for the texture. Updated by the renderer from the texture
   properties `.offset <#Texture.offset>`__, `.repeat <#Texture.repeat>`__,
   `.rotation <#Texture.rotation>`__, and `.center <#Texture.center>`__ when the texture's
   `.matrixAutoUpdate <#Texture.matrixAutoUpdate>`__ property is true. When
   `.matrixAutoUpdate <#Texture.matrixAutoUpdate>`__ property is false, this matrix may be
   set manually. Default is the identity matrix.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to generate mipmaps (if possible) for a texture. True by default. Set this to
   false if you are creating mipmaps manually.

⭕:Boolean premultiplyAlpha
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If set to ``true``, the alpha channel, if present, is multiplied into the color channels
   when the texture is uploaded to the GPU. Default is ``false``.
   Note that this property has no effect for
   `ImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap>`__. You
   need to configure on bitmap creation instead. See ``ImageBitmapLoader``.

⭕:Boolean flipY
~~~~~~~~~~~~~~~~~

   If set to ``true``, the texture is flipped along the vertical axis when uploaded to the
   GPU. Default is ``true``.
   Note that this property has no effect for
   `ImageBitmap <https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap>`__. You
   need to configure on bitmap creation instead. See ``ImageBitmapLoader``.

⭕:number unpackAlignment
~~~~~~~~~~~~~~~~~~~~~~~~~~

   4 by default. Specifies the alignment requirements for the start of each pixel row in
   memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered
   bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See
   `glPixelStorei <http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml>`__
   for more information.

⭕:string colorSpace
~~~~~~~~~~~~~~~~~~~~~

   `THREE.NoColorSpace <#Textures>`__ is the default. Textures containing color data should
   be annotated with `THREE.SRGBColorSpace <#Textures>`__ or `THREE.LinearSRGBColorSpace <#Textures>`__.

⭕:Integer version
~~~~~~~~~~~~~~~~~~~

   This starts at ``0`` and counts how many times `.needsUpdate <#Texture.needsUpdate>`__ is
   set to ``true``.

⭕:Function onUpdate
~~~~~~~~~~~~~~~~~~~~~

   A callback function, called when the texture is updated (e.g., when needsUpdate has been
   set to true and then the texture is used).

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   Set this to ``true`` to trigger an update next time the texture is used. Particularly
   important for setting the wrap mode.

⭕:Object userData
~~~~~~~~~~~~~~~~~~~

   An object that can be used to store custom data about the texture. It should not hold
   references to functions as these will not be cloned. Default is an empty object ``{}``.

⭕:Source source
~~~~~~~~~~~~~~~~~

   The data definition of a texture. A reference to the data source can be shared across
   textures. This is often useful in context of spritesheets where multiple textures render
   the same data but with different texture transformations.

Methods
-------

   `EventDispatcher <#EventDispatcher>`__ methods are available on this class.

📦:updateMatrix() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the texture's uv-transform `.matrix <#Texture.matrix>`__ from the texture
   properties `.offset <#Texture.offset>`__, `.repeat <#Texture.repeat>`__,
   `.rotation <#Texture.rotation>`__, and `.center <#Texture.center>`__.

📦:clone() Texture
~~~~~~~~~~~~~~~~~~~

   Make copy of the texture. Note this is not a "deep copy", the image is shared. Besides,
   cloning a texture does not automatically mark it for a texture upload. You have to set
   `.needsUpdate <#Texture.needsUpdate>`__ to true as soon as its image property (the data
   source) is fully loaded or ready.

📦:toJSON( Object meta ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   meta -- optional object containing metadata.
   Convert the texture to three.js
   `JSON Object/Scene format <https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4>`__.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:transformUv( Vector2 uv ) Vector2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Transform the uv based on the value of this texture's `.offset <#Texture.offset>`__,
   `.repeat <#Texture.repeat>`__, `.wrapS <#Texture.wrapS>`__, `.wrapT <#Texture.wrapT>`__
   and `.flipY <#Texture.flipY>`__ properties.



.. _D229:

Texture → VideoTexture
======================

   https://threejs.org/docs/api/en/textures/VideoTexture.html

   Creates a texture for use with a video.


   Note: After the initial use of a texture, the video cannot be changed. Instead, call
   ``.dispose``() on the texture and instantiate a new one.

   **Code Example**


   .. code:: javascript

      // assuming you have created a HTML video element with id="video" 
      const video = document.getElementById( 'video' );
      const texture = new THREE.VideoTexture( video );


   **Examples**

   [example:webgl_materials_video materials / video]
   [example:webgl_materials_video_webcam materials / video / webcam]
   [example:webgl_video_kinect video / kinect]
   [example:webgl_video_panorama_equirectangular video / panorama / equirectangular]
   [example:webxr_vr_video vr / video]

   .. Constructor

🐣:VideoTexture( Video video, Constant mapping, Constant wrapS, Constant wrapT, Constant magFilter, Constant minFilter, Constant format, Constant type, Number anisotropy )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-  `video <#Video>`__ -- The video element to use as the texture.
-  `mapping <#Constant>`__ -- How the image is applied to the object. An object type of
-  `THREE.UVMapping <#Textures>`__. See `mapping constants <#Textures>`__ for other
   choices.
-  `wrapS <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. 
   See `wrap mode constants <#Textures>`__ for other choices.
-  `wrapT <#Constant>`__ -- The default is `THREE.ClampToEdgeWrapping <#Textures>`__. 
   See `wrap mode constants <#Textures>`__ for other choices.
-  `magFilter <#Constant>`__ -- How the texture is sampled when a texel covers more than
   one pixel. The default is `THREE.LinearFilter <#Textures>`__. 
   See `magnification filter constants <#Textures>`__ for other choices.
-  `minFilter <#Constant>`__ -- How the texture is sampled when a texel covers less than
   one pixel. The default is `THREE.LinearFilter <#Textures>`__. 
   See `minification filter constants <#Textures>`__ for other choices.
-  `format <#Constant>`__ -- The default is `THREE.RGBAFormat <#Textures>`__. 
   See `format constants <#Textures>`__ for other choices.
-  `type <#Constant>`__ -- Default is `THREE.UnsignedByteType <#Textures>`__. 
   See `type constants <#Textures>`__ for other choices.
-  `anisotropy <#Number>`__ -- The number of samples taken along the axis through the pixel
   that has the highest density of texels. By default, this value is ``1``. A higher value
   gives a less blurry result than a basic mipmap, at the cost of more texture samples
   being used. Use `renderer.getMaxAnisotropy <#WebGLrenderer.getMaxAnisotropy>`__() to
   find the maximum valid anisotropy value for the GPU; this value is usually a power of 2.

Properties
----------

   See the base `Texture <#Texture>`__ class for common properties.

⭕:Boolean generateMipmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether to generate mipmaps. ``false`` by default.

⭕:Boolean isVideoTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Read-only flag to check if a given object is of type ``VideoTexture``.

⭕:Boolean needsUpdate
~~~~~~~~~~~~~~~~~~~~~~~

   You will not need to set this manually here as it is handled by the
   `update <#VideoTexture.update>`__() method.

Methods
-------

   See the base `Texture <#Texture>`__ class for common methods.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   This is called automatically and sets `.needsUpdate <#VideoTexture.needsUpdate>`__ to
   ``true`` every time a new frame is available.



.. _D230:

CCDIKSolver
===========

   https://threejs.org/docs/examples/en/animations/CCDIKSolver.html

   A solver for IK with `CCD Algorithm <https://sites.google.com/site/auraliusproject/ccd-algorithm>`__.
   ``VideoTexture`` solves Inverse Kinematics Problem with CCD Algorithm. ``VideoTexture`` 
   is designed to work with ``SkinnedMesh`` but also can be used with ``MMDLoader``
   or ``GLTFLoader`` skeleton.

   **Import**

   ``VideoTexture`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { CCDIKSolver } from 'three/addons/animation/CCDIKSolver.js';


   **Code Example**


   .. code:: javascript

      let ikSolver;

      //
      // Bones hierarchy:
      //
      //   root
      //     ├── bone0
      //     │    └── bone1
      //     │          └── bone2
      //     │                └── bone3
      //     └── target
      //
      // Positioned as follow on the cylinder:
      //
      //        o      <- target      (y =  20)
      //        
      //   +----o----+ <- bone3       (y =  12)
      //   |         |
      //   |    o    | <- bone2       (y =   4)
      //   |         |
      //   |    o    | <- bone1       (y =  -4)
      //   |         |
      //   +----oo---+ <- root, bone0 (y = -12)
      //

      let bones = []

      // "root"
      let rootBone = new Bone();
      rootBone.position.y = -12;
      bones.push( rootBone );

      // "bone0"
      let prevBone = new Bone();
      prevBone.position.y = 0;
      rootBone.add( prevBone );
      bones.push( prevBone );

      // "bone1", "bone2", "bone3"
      for ( let i = 1; i <= 3; i ++ ) {
         const bone = new Bone();
         bone.position.y = 8;
         bones.push( bone );
         
         prevBone.add( bone );
         prevBone = bone;
      }

      // "target"
      const targetBone = new Bone();
      targetBone.position.y = 24 + 8
      rootBone.add( targetBone );
      bones.push( targetBone );

      //
      // skinned mesh
      //

      const mesh = new SkinnedMesh( geometry,	material );
      const skeleton = new Skeleton( bones );

      mesh.add( bones[ 0 ] ); // "root" bone
      mesh.bind( skeleton );

      //
      // ikSolver
      //

      const iks = [
         {
            target: 5, // "target"
            effector: 4, // "bone3"
            links: [ { index: 3 }, { index: 2 }, { index: 1 } ] // "bone2", "bone1", "bone0"
         }
      ];
      ikSolver = new CCDIKSolver( mesh, iks );

      function render() {
         ikSolver?.update();
         renderer.render( scene, camera );
      }



   **Examples**

   [example:webgl_animation_skinning_ik]
   [example:webgl_loader_mmd]
   [example:webgl_loader_mmd_pose]
   [example:webgl_loader_mmd_audio]

   .. Constructor

🐣:CCDIKSolver( SkinnedMesh mesh, Array iks )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `mesh <#SkinnedMesh>`__ — ``SkinnedMesh`` for which ``CCDIKSolver`` solves IK problem.
   `iks <#Array>`__ — An array of ``Object`` specifying IK parameter. target, effector,
   and link-index are index integers in .skeleton.bones. The bones relation should be
   "links[ n ], links[ n - 1 ], ..., links[ 0 ], effector" in order from parent to child.

   -  `target <#Integer>`__ — Target bone.
   -  `effector <#Integer>`__ — Effector bone.
   -  `links <#Array>`__ — An array of ``Object`` specifying link bones.

      -  `index <#Integer>`__ — Link bone.
      -  `limitation <#Vector3>`__ — (optional) Rotation axis. Default is undefined.
      -  `rotationMin <#Vector3>`__ — (optional) Rotation minimum limit. Default is
         undefined.
      -  `rotationMax <#Vector3>`__ — (optional) Rotation maximum limit. Default is
         undefined.
      -  `enabled <#Boolean>`__ — (optional) Default is true.

   -  `iteration <#Integer>`__ — (optional) Iteration number of calculation. Smaller is
      faster but less precise. Default is 1.
   -  `minAngle <#Number>`__ — (optional) Minimum rotation angle in a step. Default is
      undefined.
   -  `maxAngle <#Number>`__ — (optional) Maximum rotation angle in a step. Default is
      undefined.

   Creates a new ``CCDIKSolver``.

Properties
----------

⭕:Array iks
~~~~~~~~~~~~~

   An array of IK parameter passed to the constructor.

⭕:SkinnedMesh mesh
~~~~~~~~~~~~~~~~~~~~

   ``SkinnedMesh`` passed to the constructor.

Methods
-------

📦:createHelper() CCDIKHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return ``CCDIKHelper``. You can visualize IK bones by adding the helper to scene.

📦:update() this
~~~~~~~~~~~~~~~~~

   Update IK bones quaternion by solving CCD algorithm.

📦:updateOne( Object ikParam ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update an IK bone quaternion by solving CCD algorithm.



.. _D231:

MMDAnimationHelper
==================

   https://threejs.org/docs/examples/en/animations/MMDAnimationHelper.html

   A animation helper for ```MMD`` <https://sites.google.com/view/evpvp/>`__ resources.
   ``CCDIKSolver`` handles animation of MMD assets loaded by ``MMDLoader`` with MMD special
   features as IK, Grant, and Physics. It uses ``CCDIKSolver`` and ``MMDPhysics``
   inside.

   **Import**

   ``CCDIKSolver`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { MMDAnimationHelper } from 'three/addons/animation/MMDAnimationHelper.js';


   **Code Example**


   .. code:: javascript

      // Instantiate a helper
      const helper = new MMDAnimationHelper();

      // Load MMD resources and add to helper
      new MMDLoader().loadWithAnimation(
         'models/mmd/miku.pmd',
         'models/mmd/dance.vmd',
         function ( mmd ) {

            helper.add( mmd.mesh, {
               animation: mmd.animation,
               physics: true
            } );

            scene.add( mmd.mesh );

            new THREE.AudioLoader().load(
               'audios/mmd/song.mp3',
               function ( buffer ) {

                  const listener = new THREE.AudioListener();
                  const audio = new THREE.Audio( listener ).setBuffer( buffer );

                  listener.position.z = 1;

                  scene.add( audio );
                  scene.add( listener );

               }

            );

         }
      );

      function render() {

         helper.update( clock.getDelta() );
         renderer.render( scene, camera );

      }


   **Examples**

   [example:webgl_loader_mmd]
   [example:webgl_loader_mmd_pose]
   [example:webgl_loader_mmd_audio]

   .. Constructor

🐣:MMDAnimationHelper( Object params )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `params <#Object>`__ — (optional)

   -  `sync <#Boolean>`__ - Whether animation durations of added objects are synched. Default
      is true.
   -  `afterglow <#Number>`__ - Default is 0.0.
   -  `resetPhysicsOnLoop <#Boolean>`__ - Default is true.
   -  `pmxAnimation <#Boolean>`__ - If it is set to true, the helper follows the complex and
      costly PMX animation system. Try this option only if your PMX model animation doesn't
      work well. Default is false.

   Creates a new ``MMDAnimationHelper``.

Properties
----------

⭕:Audio audio
~~~~~~~~~~~~~~~

   An ``Audio`` added to helper.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   An ``Camera`` added to helper.

⭕:Array meshes
~~~~~~~~~~~~~~~~

   An array of ``SkinnedMesh`` added to helper.

⭕:WeakMap objects
~~~~~~~~~~~~~~~~~~~

   A ``WeakMap`` which holds animation stuffs used in helper for objects added to helper.
   For example, you can access ``AnimationMixer`` for an added ``SkinnedMesh`` with
   "helper.objects.get( mesh ).mixer"

⭕:Function onBeforePhysics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An optional callback that is executed immediately before the physicis calculation for an
   ``SkinnedMesh``. This function is called with the ``SkinnedMesh``.

Methods
-------

📦:add( Object3D object, Object params ) MMDAnimationHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ — ``SkinnedMesh``, ``Camera``, or ``Audio``
   `params <#Object>`__ — (optional)

   -  `animation <#AnimationClip>`__ - an ``AnimationClip`` or an array of
      ``AnimationClip`` set to object. Only for ``SkinnedMesh`` and ``Camera``.
      Default is undefined.
   -  `physics <#Boolean>`__ - Only for ``SkinnedMesh``. A flag whether turn on physics.
      Default is true.
   -  `warmup <#Integer>`__ - Only for ``SkinnedMesh`` and physics is true. Physics
      parameter. Default is 60.
   -  `unitStep <#Number>`__ - Only for ``SkinnedMesh`` and physics is true. Physics
      parameter. Default is 1 / 65.
   -  `maxStepNum <#Integer>`__ - Only for ``SkinnedMesh`` and physics is true. Physics
      parameter. Default is 3.
   -  `gravity <#Vector3>`__ - Only for ``SkinnedMesh`` and physics is true. Physics
      parameter. Default is ( 0, - 9.8 `` 10, 0 ).
   -  `delayTime <#Number>`__ - Only for ``Audio``. Default is 0.0.

   Add an ``SkinnedMesh``, ``Camera``, or ``Audio`` to helper and setup animation.
   The anmation durations of added objects are synched. If camera/audio has already been
   added, it'll be replaced with a new one.

📦:enable( String key, Boolean enabled ) MMDAnimationHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `key <#String>`__ — Allowed strings are 'animation', 'ik', 'grant', 'physics', and
   'cameraAnimation'.
   `enabled <#Boolean>`__ — true is enable, false is disable

   Enable/Disable an animation feature

📦:pose( SkinnedMesh mesh, Object vpd, Object params ) MMDAnimationHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `mesh <#SkinnedMesh>`__ — ``SkinnedMesh`` which changes the posing. It doesn't need
   to be added to helper.
   `vpd <#Object>`__ — VPD content obtained by ``MMDLoader``.loadVPD
   `params <#Object>`__ — (optional)

   -  `resetPose <#Boolean>`__ - Default is true.
   -  `ik <#Boolean>`__ - Default is true.
   -  `grant <#Boolean>`__ - Default is true.

   Changes the posing of ``SkinnedMesh`` as VPD content specifies.

📦:remove( Object3D object ) MMDAnimationHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ — ``SkinnedMesh``, ``Camera``, or ``Audio``

   Remove an ``SkinnedMesh``, ``Camera``, or ``Audio`` from helper.

📦:update( Number delta ) MMDAnimationHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `delta <#Number>`__ — number in second

   Advance mixer time and update the animations of objects added to helper



.. _D232:

MMDPhysics
==========

   https://threejs.org/docs/examples/en/animations/MMDPhysics.html

   A Physics handler for ```MMD`` <https://sites.google.com/view/evpvp/>`__ resources.
   ``MMDAnimationHelper`` calculates Physics for model loaded by ``MMDLoader`` with
   `ammo.js <https://github.com/kripken/ammo.js/>`__ (Bullet-based JavaScript Physics
   engine).

   **Import**

   ``MMDAnimationHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { MMDPhysics } from 'three/addons/animation/MMDPhysics.js';


   **Code Example**


   .. code:: javascript

      let physics;

      // Load MMD resources and instantiate MMDPhysics
      new MMDLoader().load(
         'models/mmd/miku.pmd',
         function ( mesh ) {

            physics = new MMDPhysics( mesh )
            scene.add( mesh );

         }
      );

      function render() {

         const delta = clock.getDelta();
         animate( delta );  // update bones
         if ( physics !== undefined ) physics.update( delta );
         renderer.render( scene, camera );

      }



   **Examples**

   [example:webgl_loader_mmd]
   [example:webgl_loader_mmd_audio]

   .. Constructor

🐣:MMDPhysics( SkinnedMesh mesh, Array rigidBodyParams, Array constraintParams, Object params )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `mesh <#SkinnedMesh>`__ — ``SkinnedMesh`` for which ``MMDPhysics`` calculates Physics.
   `rigidBodyParams <#Array>`__ — An array of ``Object`` specifying Rigid Body
   parameters.
   `constraintParams <#Array>`__ — (optional) An array of ``Object`` specifying
   Constraint parameters.
   `params <#Object>`__ — (optional)

   -  `unitStep <#Number>`__ - Default is 1 / 65.
   -  `maxStepNum <#Integer>`__ - Default is 3.
   -  `gravity <#Vector3>`__ - Default is ( 0, - 9.8 `` 10, 0 )

   Creates a new ``MMDPhysics``.

Properties
----------

⭕:Array mesh
~~~~~~~~~~~~~~

   ``SkinnedMesh`` passed to the constructor.

Methods
-------

📦:createHelper() MMDPhysicsHelper
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Return ``MMDPhysicsHelper``. You can visualize Rigid bodies by adding the helper to
   scene.

📦:reset() this
~~~~~~~~~~~~~~~~

   Resets Rigid bodies transform to current bone's.

📦:setGravity( Vector3 gravity ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `gravity <#Vector3>`__ — Direction and volume of gravity.

   Set gravity.

📦:update( Number delta ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `delta <#Number>`__ — Time in second.

   Advance Physics calculation and updates bones.

📦:warmup( Integer cycles ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `delta <#Number>`__ — Time in second.

   Warm up Rigid bodies. Calculates cycles steps.



.. _D233:

EventDispatcher → ArcballControls
=================================

   https://threejs.org/docs/examples/en/controls/ArcballControls.html

   Arcball controls allow the camera to be controlled by a virtual trackball with full
   touch support and advanced navigation functionality.

   Cursor/finger positions and movements are mapped over a virtual trackball surface
   represented by a gizmo and mapped in intuitive and consistent camera movements. Dragging
   cursor/fingers will cause camera to orbit around the center of the trackball in a
   conservative way (returning to the starting point will make the camera to return to its
   starting orientation).

   In addition to supporting pan, zoom and pinch gestures, Arcball controls provide *focus*
   functionality with a double click/tap for intuitively moving the object's point of
   interest in the center of the virtual trackball. Focus allows a much better inspection
   and navigation in complex environment. Moreover Arcball controls allow FOV manipulation
   (in a vertigo-style method) and z-rotation. Saving and restoring of Camera State is
   supported also through clipboard (use ctrl+c and ctrl+v shortcuts for copy and paste the
   state).

   Unlike ``OrbitControls`` and ``TrackballControls``, ``MMDPhysics`` doesn't require
   ``.update`` to be called externally in an animation loop when animations are on.
   To use this, as with all files in the /examples directory, you will have to include the
   file separately in your HTML.

   **Import**

   ``MMDPhysics`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { ArcballControls } from 'three/addons/controls/ArcballControls.js';


   **Code Example**


   .. code:: javascript

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
      const controls = new ArcballControls( camera, renderer.domElement, scene );
      controls.addEventListener( 'change', function () { 
         renderer.render( scene, camera );
      } );
      //controls.update() must be called after any manual changes to the camera's transform 
      camera.position.set( 0, 20, 100 );
      controls.update();


   **Examples**

   [example:misc_controls_arcball misc / controls / arcball ]

   .. Constructor

🐣:ArcballControls( Camera camera, HTMLDOMElement domElement, Scene scene )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__: (required) The camera to be controlled. The camera must not be a
   child of another object, unless that object is the scene itself.
   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.
   `scene <#Scene>`__: The scene rendered by the camera. If not given, gizmos cannot be
   shown.


🚀Events
~~~~~~~~~

   ======== ===========================================================
   change   Fires when the camera has been transformed by the controls.
   start    Fires when an interaction was initiated.
   end      Fires when an interaction has finished.
   ======== ===========================================================

Properties
----------

⭕:Boolean adjustNearFar
~~~~~~~~~~~~~~~~~~~~~~~~~

   If true, camera's near and far values will be adjusted every time zoom is performed 
   trying to mantain the same visible portion given by initial near and far values 
   ( ``PerspectiveCamera`` only ). Default is false.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The camera being controlled.

⭕:Boolean cursorZoom
~~~~~~~~~~~~~~~~~~~~~~

   Set to true to make zoom become cursor centered.

⭕:Float dampingFactor
~~~~~~~~~~~~~~~~~~~~~~~

   The damping inertia used if ``.enableAnimations`` is set to true.

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   When set to ``false``, the controls will not respond to user input. Default is ``true``.

⭕:Boolean enableAnimations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set to true to enable animations for rotation (damping) and focus operation. Default is
   true.

⭕:Boolean enableGrid
~~~~~~~~~~~~~~~~~~~~~~

   When set to true, a grid will appear when panning operation is being performed (desktop
   interaction only). Default is false.

⭕:Boolean enablePan
~~~~~~~~~~~~~~~~~~~~~

   Enable or disable camera panning. Default is true.

⭕:Boolean enableRotate
~~~~~~~~~~~~~~~~~~~~~~~~

   Enable or disable camera rotation. Default is true.

⭕:Boolean enableZoom
~~~~~~~~~~~~~~~~~~~~~~

   Enable or disable zooming of the camera.

⭕:Float focusAnimationTime
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Duration time of focus animation.

⭕:Float maxDistance
~~~~~~~~~~~~~~~~~~~~~

   How far you can dolly out ( ``PerspectiveCamera`` only ). Default is Infinity.

⭕:Float maxZoom
~~~~~~~~~~~~~~~~~

   How far you can zoom out ( ``OrthographicCamera`` only ). Default is Infinity.

⭕:Float minDistance
~~~~~~~~~~~~~~~~~~~~~

   How far you can dolly in ( ``PerspectiveCamera`` only ). Default is 0.

⭕:Float minZoom
~~~~~~~~~~~~~~~~~

   How far you can zoom in ( ``OrthographicCamera`` only ). Default is 0.

⭕:Float radiusFactor
~~~~~~~~~~~~~~~~~~~~~~

   The size of the gizmo relative to the screen width and height. Default is 0.67.

⭕:Float rotateSpeed
~~~~~~~~~~~~~~~~~~~~~

   Speed of rotation. Default is 1.

⭕:Float scaleFactor
~~~~~~~~~~~~~~~~~~~~~

   The scaling factor used when performing zoom operation.

⭕:Scene scene
~~~~~~~~~~~~~~~

   The scene rendered by the camera.

⭕:Float wMax
~~~~~~~~~~~~~~

   Maximum angular velocity allowed on rotation animation start.

Methods
-------

📦:activateGizmos ( Boolean isActive ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Make gizmos more or less visible.

📦:copyState () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Copy the current state to clipboard (as a readable JSON text).

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Remove all the event listeners, cancel any pending animation and clean the scene from
   gizmos and grid.

📦:pasteState () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the controls state from the clipboard, assumes that the clipboard stores a JSON text
   as saved from ``.copyState``.

📦:reset () undefined
~~~~~~~~~~~~~~~~~~~~~~

   Reset the controls to their state from either the last time the ``.saveState`` was
   called, or the initial state.

📦:saveState () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Save the current state of the controls. This can later be recovered with ``.reset``.

📦:setCamera ( Camera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the camera to be controlled. Must be called in order to set a new camera to be
   controlled.

📦:setGizmosVisible ( Boolean value ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set the visible property of gizmos.

📦:setTbRadius ( Float value ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the ``radiusFactor`` value, redraw the gizmo and send a ``changeEvent`` to
   visualise the changes.

📦:setMouseAction ( String operation, mouse, key ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set a new mouse action by specifying the operation to be performed and a mouse/key
   combination. In case of conflict, replaces the existing one.
   Operations can be specified as 'ROTATE', 'PAN', 'FOV' or 'ZOOM'.
   Mouse inputs can be specified as mouse buttons 0, 1 and 2 or 'WHEEL' for wheel notches.
   Keyboard modifiers can be specified as 'CTRL', 'SHIFT' or null if not needed.

📦:unsetMouseAction ( mouse, key ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes a mouse action by specifying its mouse/key combination.
   Mouse inputs can be specified as mouse buttons 0, 1 and 2 or 'WHEEL' for wheel notches.
   Keyboard modifiers can be specified as 'CTRL', 'SHIFT' or null if not needed.

📦:update () undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Update the controls. Must be called after any manual changes to the camera's transform.

📦:getRaycaster () Raycaster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the ``Raycaster`` object that is used for user interaction. This object is
   shared between all instances of ArcballControls. If you set the `.layers <#Object3D.layers>`__ 
   property of the ``ArcballControls``, you will also want to set the 
   ``Raycaster.layers`` property on the ``Raycaster`` with a matching value, 
   or else the ``ArcballControls`` won't work as expected.



.. _D234:

EventDispatcher → DragControls
==============================

   https://threejs.org/docs/examples/en/controls/DragControls.html

   This class can be used to provide a drag'n'drop interaction.

   **Import**

   ``ArcballControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { DragControls } from 'three/addons/controls/DragControls.js';


   **Code Example**


   .. code:: javascript

      const controls = new DragControls( objects, camera, renderer.domElement );

      // add event listener to highlight dragged objects

      controls.addEventListener( 'dragstart', function ( event ) {

         event.object.material.emissive.set( 0xaaaaaa );

      } );

      controls.addEventListener( 'dragend', function ( event ) {

         event.object.material.emissive.set( 0x000000 );

      } );


   **Examples**

   [example:misc_controls_drag misc / controls / drag ]

   .. Constructor

🐣:DragControls( Array objects, Camera camera, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `objects <#Array>`__: An array of draggable 3D objects.

   `camera <#Camera>`__: The camera of the rendered scene.

   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.

   Creates a new instance of ``DragControls``.


🚀Events
~~~~~~~~~

   ========== ==================================================================
   dragstart  Fires when the user starts to drag a 3D object.
   drag       Fires when the user drags a 3D object.
   dragend    Fires when the user has finished dragging a 3D object.
   hoveron    Fires when the pointer is moved onto a 3D object, or onto one of its children.
   hoveroff   Fires when the pointer is moved out of a 3D object.
   ========== ==================================================================

Properties
----------

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   Whether or not the controls are enabled.

⭕:Boolean recursive
~~~~~~~~~~~~~~~~~~~~~

   Whether children of draggable objects can be dragged independently from their parent.
   Default is ``true``.

⭕:Boolean transformGroup
~~~~~~~~~~~~~~~~~~~~~~~~~~

   This option only works if the ``DragControls.objects`` array contains a single
   draggable group object. If set to ``true``, ``DragControls`` does not transform individual objects
   but the entire group. Default is ``false``.

⭕:String mode
~~~~~~~~~~~~~~~

   The current transformation mode. Possible values are ``translate``, and ``rotate``.
   Default is ``translate``.

⭕:Float rotateSpeed
~~~~~~~~~~~~~~~~~~~~~

   The speed at which the object will rotate when dragged in ``rotate`` mode. The higher the
   number the faster the rotation. Default is ``1``.

Methods
-------

   See the base ``EventDispatcher`` class for common methods.

📦:activate () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the event listeners of the controls.

📦:deactivate () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes the event listeners of the controls.

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the controls is no longer required.

📦:getObjects () Array
~~~~~~~~~~~~~~~~~~~~~~~

   Returns the array of draggable objects.

📦:getRaycaster () Raycaster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the internal ``Raycaster`` instance that is used for intersection tests.

📦:setObjects ( Array objects ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets an array of draggable objects by overwriting the existing one.



.. _D235:

FirstPersonControls
===================

   https://threejs.org/docs/examples/en/controls/FirstPersonControls.html

   This class is an alternative implementation of ``FlyControls``.

   **Import**

   ``DragControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';


   **Examples**

   [example:webgl_geometry_terrain webgl / geometry / terrain ]

   .. Constructor

🐣:FirstPersonControls( Camera object, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Camera>`__: The camera to be controlled.

   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.

   Creates a new instance of ``FirstPersonControls``.

Properties
----------

⭕:Boolean activeLook
~~~~~~~~~~~~~~~~~~~~~~

   Whether or not it's possible to look around. Default is ``true``.

⭕:Boolean autoForward
~~~~~~~~~~~~~~~~~~~~~~~

   Whether or not the camera is automatically moved forward. Default is ``false``.

⭕:Boolean constrainVertical
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether or not looking around is vertically constrained by [``.verticalMin``,
   ``.verticalMax``]. Default is ``false``.

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   Whether or not the controls are enabled. Default is ``true``.

⭕:Number heightCoef
~~~~~~~~~~~~~~~~~~~~~

   Determines how much faster the camera moves when it's y-component is near
   ``.heightMax``. Default is ``1``.

⭕:Number heightMax
~~~~~~~~~~~~~~~~~~~~

   Upper camera height limit used for movement speed adjustment. Default is ``1``.

⭕:Number heightMin
~~~~~~~~~~~~~~~~~~~~

   Lower camera height limit used for movement speed adjustment. Default is ``0``.

⭕:Boolean heightSpeed
~~~~~~~~~~~~~~~~~~~~~~~

   Whether or not the camera's height influences the forward movement speed.
   Default is ``false``. Use the properties ``.heightCoef``, ``.heightMin`` and ``.heightMax``
   for configuration.

⭕:Boolean lookVertical
~~~~~~~~~~~~~~~~~~~~~~~~

   Whether or not it's possible to vertically look around. Default is ``true``.

⭕:Number lookSpeed
~~~~~~~~~~~~~~~~~~~~

   The look around speed. Default is ``0.005``.

⭕:Boolean mouseDragOn
~~~~~~~~~~~~~~~~~~~~~~~

   Whether or not the mouse is pressed down. Read-only property.

⭕:Number movementSpeed
~~~~~~~~~~~~~~~~~~~~~~~~

   The movement speed. Default is ``1``.

⭕:Camera object
~~~~~~~~~~~~~~~~~

   The camera to be controlled.

⭕:Number verticalMax
~~~~~~~~~~~~~~~~~~~~~~

   How far you can vertically look around, upper limit. Range is 0 to Math.PI radians.
   Default is ``Math.PI``.

⭕:Number verticalMin
~~~~~~~~~~~~~~~~~~~~~~

   How far you can vertically look around, lower limit. Range is 0 to Math.PI radians.
   Default is ``0``.

Methods
-------

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the controls is no longer required.

📦:handleResize () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the application window is resized.

📦:lookAt( Vector3 vector ) FirstPersonControls
📦:lookAt( Float x, Float y, Float z ) FirstPersonControls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   vector - A vector representing the target position.

   Optionally, the x, y, z components of the world space position.

   Ensures the controls orient the camera towards the defined target position.

📦:update ( Number delta ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `delta <#Number>`__: Time delta value.

   Updates the controls. Usually called in the animation loop.



.. _D236:

FlyControls
===========

   https://threejs.org/docs/examples/en/controls/FlyControls.html

   ``FirstPersonControls`` enables a navigation similar to fly modes in DCC tools like Blender. 
   You can arbitrarily transform the camera in 3D space without any limitations (e.g. focus on a
   specific target).

   **Import**

   ``FirstPersonControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { FlyControls } from 'three/addons/controls/FlyControls.js';


   **Examples**

   [example:misc_controls_fly misc / controls / fly ]

   .. Constructor

🐣:FlyControls( Camera object, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Camera>`__: The camera to be controlled.

   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.

   Creates a new instance of ``FlyControls``.


🚀Events
~~~~~~~~~

   ======== ============================================================
   change   Fires when the camera has been transformed by the controls.
   ======== ============================================================


Properties
----------

⭕:Boolean autoForward
~~~~~~~~~~~~~~~~~~~~~~~

   If set to ``true``, the camera automatically moves forward (and does not stop) when
   initially translated. Default is ``false``.

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Boolean dragToLook
~~~~~~~~~~~~~~~~~~~~~~

   If set to ``true``, you can only look around by performing a drag interaction.
   Default is ``false``.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   When set to ``false``, the controls will not respond to user input. Default is ``true``.

⭕:Number movementSpeed
~~~~~~~~~~~~~~~~~~~~~~~~

   The movement speed. Default is ``1``.

⭕:Camera object
~~~~~~~~~~~~~~~~~

   The camera to be controlled.

⭕:Number rollSpeed
~~~~~~~~~~~~~~~~~~~~

   The rotation speed. Default is ``0.005``.

Methods
-------

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the controls is no longer required.

📦:update ( Number delta ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `delta <#Number>`__: Time delta value.

   Updates the controls. Usually called in the animation loop.



.. _D237:

OrbitControls → MapControls
===========================

   https://threejs.org/docs/examples/en/controls/MapControls.html

   ``FlyControls`` is intended for transforming a camera over a map from bird's eye perspective. 
   The class shares its implementation with ``OrbitControls`` but uses a specific preset for
   mouse/touch interaction and disables screen space panning by default.

   **Import**

   ``FlyControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { MapControls } from 'three/addons/controls/MapControls.js';


   **Code Example**


   .. code:: javascript

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );

      camera.position.set( 0, 20, 100 );

      const controls = new MapControls( camera, renderer.domElement );
      controls.enableDamping = true;

      function animate() { 
         requestAnimationFrame( animate );
         // required if controls.enableDamping or controls.autoRotate are set to true 
         controls.update();
         renderer.render( scene, camera );
      }


   **Examples**

   [example:misc_controls_map misc / controls / map ]

   .. Constructor

🐣:MapControls( Camera object, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Camera>`__: (required) The camera to be controlled. The camera must not be a
   child of another object, unless that object is the scene itself.
   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.


🚀Events
~~~~~~~~~

   See the base ``OrbitControls`` class for common events.

Properties
----------

   See the base ``OrbitControls`` class for common properties.

⭕:Object mouseButtons
~~~~~~~~~~~~~~~~~~~~~~~

   This object contains references to the mouse actions used by the controls.

   .. code:: javascript

      controls.mouseButtons = { 
         LEFT: THREE.MOUSE.PAN, 
         MIDDLE: THREE.MOUSE.DOLLY, 
         RIGHT: THREE.MOUSE.ROTATE 
      }


⭕:Boolean screenSpacePanning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines how the camera's position is translated when panning. If true, the camera pans in
   screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
   direction. Default is ``false``.

⭕:Object touches
~~~~~~~~~~~~~~~~~~

   This object contains references to the touch actions used by the controls.

   .. code:: javascript

      controls.touches = { 
         ONE: THREE.TOUCH.PAN, 
         TWO: THREE.TOUCH.DOLLY_ROTATE 
      }


Methods
-------

   See the base ``OrbitControls`` class for common methods.



.. _D238:

OrbitControls
=============

   https://threejs.org/docs/examples/en/controls/OrbitControls.html

   Orbit controls allow the camera to orbit around a target.
   To use this, as with all files in the /examples directory, you will have to include the
   file separately in your HTML.

   **Import**

   ``MapControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';


   **Code Example**


   .. code:: javascript

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );

      const controls = new OrbitControls( camera, renderer.domElement );

      //controls.update() must be called after any manual changes to the camera's transform
      camera.position.set( 0, 20, 100 );
      controls.update();

      function animate() {

         requestAnimationFrame( animate );

         // required if controls.enableDamping or controls.autoRotate are set to true
         controls.update();

         renderer.render( scene, camera );

      }


   **Examples**

   [example:misc_controls_orbit misc / controls / orbit ]

   .. Constructor

🐣:OrbitControls( Camera object, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Camera>`__: (required) The camera to be controlled. The camera must not be a
   child of another object, unless that object is the scene itself.
   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.


🚀Events
~~~~~~~~~

   ========= ============================================================
   change    Fires when the camera has been transformed by the controls.
   start     Fires when an interaction was initiated.
   end       Fires when an interaction has finished.
   ========= ============================================================


Properties
----------

⭕:Boolean autoRotate
~~~~~~~~~~~~~~~~~~~~~~

   Set to true to automatically rotate around the target.
   Note that if this is enabled, you must call ``.update`` () in your animation loop. If
   you want the auto-rotate speed to be independent of the frame rate (the refresh rate of
   the display), you must pass the time ``deltaTime``, in seconds, to ``.update``().

⭕:Float autoRotateSpeed
~~~~~~~~~~~~~~~~~~~~~~~~~

   How fast to rotate around the target if ``.autoRotate`` is true. Default is 2.0,
   which equates to 30 seconds per orbit at 60fps.
   Note that if ``.autoRotate`` is enabled, you must call ``.update`` () in your
   animation loop.

⭕:Float dampingFactor
~~~~~~~~~~~~~~~~~~~~~~~

   The damping inertia used if ``.enableDamping`` is set to ``true``.
   Default is ``0.05``.
   Note that for this to work, you must call ``.update`` () in your animation loop.

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   When set to ``false``, the controls will not respond to user input. Default is ``true``.

⭕:Boolean enableDamping
~~~~~~~~~~~~~~~~~~~~~~~~~

   Set to true to enable damping (inertia), which can be used to give a sense of weight to
   the controls. Default is false.
   Note that if this is enabled, you must call ``.update`` () in your animation loop.

⭕:Boolean enablePan
~~~~~~~~~~~~~~~~~~~~~

   Enable or disable camera panning. Default is true.

⭕:Boolean enableRotate
~~~~~~~~~~~~~~~~~~~~~~~~

   Enable or disable horizontal and vertical rotation of the camera. Default is true.
   Note that it is possible to disable a single axis by setting the min and max of the
   `polar angle <#.minPolarAngle>`__ or `azimuth angle <#.minAzimuthAngle>`__ to the same
   value, which will cause the vertical or horizontal rotation to be fixed at that value.

⭕:Boolean enableZoom
~~~~~~~~~~~~~~~~~~~~~~

   Enable or disable zooming (dollying) of the camera.

⭕:Float keyPanSpeed
~~~~~~~~~~~~~~~~~~~~~

   How fast to pan the camera when the keyboard is used. Default is 7.0 pixels per keypress.

⭕:Object keys
~~~~~~~~~~~~~~~

   This object contains references to the keycodes for controlling camera panning. Default is
   the 4 arrow keys.

   .. code:: javascript

      controls.keys = { 
         LEFT: 'ArrowLeft', //left arrow 
         UP: 'ArrowUp', // up arrow 
         RIGHT: 'ArrowRight', // right arrow 
         BOTTOM: 'ArrowDown' // down arrow 
      }

   See `KeyboardEvent.code <https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code>`__ 
   for a full list of keycodes.

⭕:Float maxAzimuthAngle
~~~~~~~~~~~~~~~~~~~~~~~~~

   How far you can orbit horizontally, upper limit. If set, the interval [ min, max ] must be
   a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI ). Default is Infinity.

⭕:Float maxDistance
~~~~~~~~~~~~~~~~~~~~~

   How far you can dolly out ( ``PerspectiveCamera`` only ). Default is Infinity.

⭕:Float maxPolarAngle
~~~~~~~~~~~~~~~~~~~~~~~

   How far you can orbit vertically, upper limit. Range is 0 to Math.PI radians, and default
   is Math.PI.

⭕:Float maxZoom
~~~~~~~~~~~~~~~~~

   How far you can zoom out ( ``OrthographicCamera`` only ). Default is Infinity.

⭕:Float minTargetRadius
~~~~~~~~~~~~~~~~~~~~~~~~~

   How close you can get the target to the 3D ``.cursor``. Default is 0.

⭕:Float maxTargetRadius
~~~~~~~~~~~~~~~~~~~~~~~~~

   How far you can move the target from the 3D ``.cursor``. Default is Infinity.

⭕:Float minAzimuthAngle
~~~~~~~~~~~~~~~~~~~~~~~~~

   How far you can orbit horizontally, lower limit. If set, the interval [ min, max ] must be
   a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI ). Default is Infinity.

⭕:Float minDistance
~~~~~~~~~~~~~~~~~~~~~

   How far you can dolly in ( ``PerspectiveCamera`` only ). Default is 0.

⭕:Float minPolarAngle
~~~~~~~~~~~~~~~~~~~~~~~

   How far you can orbit vertically, lower limit. Range is 0 to Math.PI radians, and default
   is 0.

⭕:Float minZoom
~~~~~~~~~~~~~~~~~

   How far you can zoom in ( ``OrthographicCamera`` only ). Default is 0.

⭕:Object mouseButtons
~~~~~~~~~~~~~~~~~~~~~~~

   This object contains references to the mouse actions used by the controls.

   .. code:: javascript

      controls.mouseButtons = { 
         LEFT: THREE.MOUSE.ROTATE, 
         MIDDLE: THREE.MOUSE.DOLLY, 
         RIGHT: THREE.MOUSE.PAN 
      }


⭕:Camera object
~~~~~~~~~~~~~~~~~

   The camera being controlled.

⭕:Float panSpeed
~~~~~~~~~~~~~~~~~~

   Speed of panning. Default is 1.

⭕:Vector3 position0
~~~~~~~~~~~~~~~~~~~~~

   Used internally by the ``.saveState`` and ``.reset`` methods.

⭕:Float rotateSpeed
~~~~~~~~~~~~~~~~~~~~~

   Speed of rotation. Default is 1.

⭕:Boolean screenSpacePanning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines how the camera's position is translated when panning. If true, the camera pans in
   screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
   direction. Default is ``true``.

⭕:Vector3 target0
~~~~~~~~~~~~~~~~~~~

   Used internally by the ``.saveState`` and ``.reset`` methods.

⭕:Vector3 target
~~~~~~~~~~~~~~~~~~

   The focus point of the controls, the ``.object`` orbits around this. It can be updated
   manually at any point to change the focus of the controls.

⭕:Vector3 cursor
~~~~~~~~~~~~~~~~~~

   The focus point of the ``.minTargetRadius`` and ``.maxTargetRadius`` limits. It can
   be updated manually at any point to change the center of interest for the ``.target``.

⭕:Object touches
~~~~~~~~~~~~~~~~~~

   This object contains references to the touch actions used by the controls.

   .. code:: javascript

      controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN }


⭕:Float zoom0
~~~~~~~~~~~~~~~

   Used internally by the ``.saveState`` and ``.reset`` methods.

⭕:Float zoomSpeed
~~~~~~~~~~~~~~~~~~~

   Speed of zooming / dollying. Default is 1.

⭕:Boolean zoomToCursor
~~~~~~~~~~~~~~~~~~~~~~~~

   Setting this property to ``true`` allows to zoom to the cursor's position.
   Default is ``false``.

Methods
-------

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Remove all the event listeners.

📦:getAzimuthalAngle () radians
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get the current horizontal rotation, in radians.

📦:getPolarAngle () radians
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Get the current vertical rotation, in radians.

📦:getDistance () Float
~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the distance from the camera to the target.

📦:listenToKeyEvents ( HTMLDOMElement domElement ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Adds key event listeners to the given DOM element. ``window`` is a recommended argument
   for using this method.

📦:reset () undefined
~~~~~~~~~~~~~~~~~~~~~~

   Reset the controls to their state from either the last time the ``.saveState`` was
   called, or the initial state.

📦:saveState () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Save the current state of the controls. This can later be recovered with ``.reset``.

📦:stopListenToKeyEvents () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes the key event listener previously defined with ``.listenToKeyEvents``().

📦:update ( Number deltaTime ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Update the controls. Must be called after any manual changes to the camera's transform, or
   in the update loop if ``.autoRotate`` or ``.enableDamping`` are set. ``deltaTime``,
   in seconds, is optional, and is only required if you want the auto-rotate speed to be
   independent of the frame rate (the refresh rate of the display).



.. _D239:

EventDispatcher → PointerLockControls
=====================================

   https://threejs.org/docs/examples/en/controls/PointerLockControls.html

   The implementation of this class is based on the
   `Pointer Lock API <https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API>`__.
   ``OrbitControls`` is a perfect choice for first person 3D games.

   **Import**

   ``OrbitControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';


   **Code Example**


   .. code:: javascript

      const controls = new PointerLockControls( camera, document.body );
      // add event listener to show/hide a UI (e.g. the game's menu) 

      controls.addEventListener( 'lock', function () { 
         menu.style.display = 'none';
      } );

      controls.addEventListener( 'unlock', function () { 
         menu.style.display = 'block';
      } );


   **Examples**

   [example:misc_controls_pointerlock misc / controls / pointerlock ]

   .. Constructor

🐣:PointerLockControls( Camera camera, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__: The camera of the rendered scene.

   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.

   Creates a new instance of ``PointerLockControls``.


🚀Events
~~~~~~~~~

   ======== ===================================================================
   change   Fires when the user moves the mouse.
   lock     Fires when the pointer lock status is "locked" (in other words: the mouse is captured).
   unlock   Fires when the pointer lock status is "unlocked" (in other words: the mouse is not captured anymore).
   ======== ===================================================================


Properties
----------

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Boolean isLocked
~~~~~~~~~~~~~~~~~~~~

   Whether or not the controls are locked.

⭕:Float maxPolarAngle
~~~~~~~~~~~~~~~~~~~~~~~

   Camera pitch, upper limit. Range is 0 to Math.PI radians. Default is Math.PI.

⭕:Float minPolarAngle
~~~~~~~~~~~~~~~~~~~~~~~

   Camera pitch, lower limit. Range is 0 to Math.PI radians. Default is 0.

⭕:Float pointerSpeed
~~~~~~~~~~~~~~~~~~~~~~

   Multiplier for how much the pointer movement influences the camera rotation. Default is 1.

Methods
-------

   See the base ``EventDispatcher`` class for common methods.

📦:connect () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Adds the event listeners of the controls.

📦:disconnect () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes the event listeners of the controls.

📦:getDirection ( Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vector3>`__: The target vector.

   Returns the look direction of the camera.

📦:lock () undefined
~~~~~~~~~~~~~~~~~~~~~

   Activates the pointer lock.

📦:moveForward ( Number distance ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `distance <#Number>`__: The signed distance.

   Moves the camera forward parallel to the xz-plane. Assumes camera.up is y-up.

📦:moveRight ( Number distance ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `distance <#Number>`__: The signed distance.

   Moves the camera sidewards parallel to the xz-plane.

📦:unlock () undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Exits the pointer lock.



.. _D240:

EventDispatcher → TrackballControls
===================================

   https://threejs.org/docs/examples/en/controls/TrackballControls.html

   ``PointerLockControls`` is similar to ``OrbitControls``. However, it does not maintain a 
   constant camera `up <#Object3D.up>`__ vector. That means if the camera orbits over the 
   “north” and “south” poles, it does not flip to stay "right side up".

   **Import**

   ``PointerLockControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { TrackballControls } from 'three/addons/controls/TrackballControls.js';


   **Examples**

   [example:misc_controls_trackball misc / controls / trackball ]

   .. Constructor

🐣:TrackballControls( Camera camera, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__: The camera of the rendered scene.

   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.

   Creates a new instance of ``TrackballControls``.


🚀Events
~~~~~~~~~

   ======== ============================================================
   change   Fires when the camera has been transformed by the controls.
   start    Fires when an interaction (e.g. touch) was initiated.
   end      Fires when an interaction has finished.
   ======== ============================================================


Properties
----------

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Number dynamicDampingFactor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Defines the intensity of damping. Only considered if ``staticMoving`` is
   set to ``false``. Default is ``0.2``.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   Whether or not the controls are enabled.

⭕:Array keys
~~~~~~~~~~~~~~

   This array holds keycodes for controlling interactions.

   -  When the first defined key is pressed, all mouse interactions (left, middle, right)
      performs orbiting.
   -  When the second defined key is pressed, all mouse interactions (left, middle, right)
      performs zooming.
   -  When the third defined key is pressed, all mouse interactions (left, middle, right)
      performs panning.

   Default is ``KeyA, KeyS, KeyD`` which represents A, S, D.

⭕:Number maxDistance
~~~~~~~~~~~~~~~~~~~~~~

   How far you can dolly out ( ``PerspectiveCamera`` only ). Default is ``Infinity``.

⭕:Number minDistance
~~~~~~~~~~~~~~~~~~~~~~

   How far you can dolly in ( ``PerspectiveCamera`` only ). Default is ``0``.

⭕:Float maxZoom
~~~~~~~~~~~~~~~~~

   How far you can zoom out ( ``OrthographicCamera`` only ). Default is ``Infinity``.

⭕:Float minZoom
~~~~~~~~~~~~~~~~~

   How far you can zoom in ( ``OrthographicCamera`` only ). Default is ``0``.

⭕:Object mouseButtons
~~~~~~~~~~~~~~~~~~~~~~~

   This object contains references to the mouse actions used by the controls.

   -  .LEFT is assigned with ``THREE.MOUSE.ROTATE``
   -  .MIDDLE is assigned with ``THREE.MOUSE.ZOOM``
   -  .RIGHT is assigned with ``THREE.MOUSE.PAN``

⭕:Boolean noPan
~~~~~~~~~~~~~~~~~

   Whether or not panning is disabled. Default is ``false``.

⭕:Boolean noRotate
~~~~~~~~~~~~~~~~~~~~

   Whether or not rotation is disabled. Default is ``false``.

⭕:Boolean noZoom
~~~~~~~~~~~~~~~~~~

   Whether or not zooming is disabled. Default is ``false``.

⭕:Camera object
~~~~~~~~~~~~~~~~~

   The camera being controlled.

⭕:Number panSpeed
~~~~~~~~~~~~~~~~~~~

   The pan speed. Default is ``0.3``.

⭕:Number rotateSpeed
~~~~~~~~~~~~~~~~~~~~~~

   The rotation speed. Default is ``1.0``.

⭕:Object screen
~~~~~~~~~~~~~~~~~

   Represents the properties of the screen. Automatically set when 
   ``handleResize`` () is called.

   -  left: Represents the offset in pixels to the screen's left boundary.
   -  top: Represents the offset in pixels to the screen's top boundary.
   -  width: Represents the screen width in pixels.
   -  height: Represents the screen height in pixels.

⭕:Boolean staticMoving
~~~~~~~~~~~~~~~~~~~~~~~~

   Whether or not damping is disabled. Default is ``false``.

⭕:Vector3 target
~~~~~~~~~~~~~~~~~~

   The focus point of the controls.

⭕:Number zoomSpeed
~~~~~~~~~~~~~~~~~~~~

   The zoom speed. Default is ``1.2``.

Methods
-------

📦:checkDistances () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Ensures the controls stay in the range [minDistance, maxDistance]. Called by 
   ``update`` ().

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the controls is no longer required.

📦:handleResize () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the application window is resized.

📦:panCamera () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Performs panning if necessary. Called by ``update``().

📦:reset () undefined
~~~~~~~~~~~~~~~~~~~~~~

   Resets the controls to its initial state.

📦:rotateCamera () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Rotates the camera if necessary. Called by ``update``().

📦:update () undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Updates the controls. Usually called in the animation loop.

📦:zoomCamera () undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Performs zooming if necessary. Called by ``update``().



.. _D241:

Object3D → TransformControls
============================

   https://threejs.org/docs/examples/en/controls/TransformControls.html

   This class can be used to transform objects in 3D space by adapting a similar
   interaction model of DCC tools like Blender. Unlike other controls, it is not intended
   to transform the scene's camera.
   ``TrackballControls`` expects that its attached 3D object is part of the scene graph.

   **Import**

   ``TrackballControls`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { TransformControls } from 'three/addons/controls/TransformControls.js';


   **Examples**

   [example:misc_controls_transform misc / controls / transform ]

   .. Constructor

🐣:TransformControls( Camera camera, HTMLDOMElement domElement )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `camera <#Camera>`__: The camera of the rendered scene.

   `domElement <#HTMLDOMElement>`__: The HTML element used for event listeners.

   Creates a new instance of ``TransformControls``.


🚀Events
~~~~~~~~~

   ============= ===============================================================
   change        Fires if any type of change (object or property change) is performed. 
                 Property changes are separate events you can add event listeners to. 
                 The event type is "propertyname-changed".
   mouseDown     Fires if a pointer (mouse/touch) becomes active.
   mouseUp       Fires if a pointer (mouse/touch) is no longer active.
   objectChange  Fires if the controlled 3D object is changed.
   ============= ===============================================================



Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:String axis
~~~~~~~~~~~~~~~

   The current transformation axis.

⭕:Camera camera
~~~~~~~~~~~~~~~~~

   The camera of the rendered scene.

⭕:HTMLDOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTMLDOMElement used to listen for mouse / touch events. This must be passed in the
   constructor; changing it here will not set up new event listeners.

⭕:Boolean dragging
~~~~~~~~~~~~~~~~~~~~

   Whether or not dragging is currently performed. Read-only property.

⭕:Boolean enabled
~~~~~~~~~~~~~~~~~~~

   Whether or not the controls are enabled.

⭕:String mode
~~~~~~~~~~~~~~~

   The current transformation mode. Possible values are "translate", "rotate" and "scale".
   Default is ``translate``.

⭕:Object3D object
~~~~~~~~~~~~~~~~~~~

   The 3D object being controlled.

⭕:Number rotationSnap
~~~~~~~~~~~~~~~~~~~~~~~

   By default, 3D objects are continuously rotated. If you set this property to a numeric
   value (radians), you can define in which steps the 3D object should be rotated.
   Default is ``null``.

⭕:Boolean showX
~~~~~~~~~~~~~~~~~

   Whether or not the x-axis helper should be visible. Default is ``true``.

⭕:Boolean showY
~~~~~~~~~~~~~~~~~

   Whether or not the y-axis helper should be visible. Default is ``true``.

⭕:Boolean showZ
~~~~~~~~~~~~~~~~~

   Whether or not the z-axis helper should be visible. Default is ``true``.

⭕:Number size
~~~~~~~~~~~~~~~

   The size of the helper UI (axes/planes). Default is ``1``.

⭕:String space
~~~~~~~~~~~~~~~~

   Defines in which coordinate space transformations should be performed. Possible values are
   "world" and "local". Default is ``world``.

⭕:Number translationSnap
~~~~~~~~~~~~~~~~~~~~~~~~~~

   By default, 3D objects are continuously translated. If you set this property to a numeric
   value (world units), you can define in which steps the 3D object should be translated.
   Default is ``null``.

Methods
-------

   See the base ``Object3D`` class for common methods.

📦:attach ( Object3D object ) TransformControls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__: The 3D object that should be transformed.

   Sets the 3D object that should be transformed and ensures the controls UI is visible.

📦:detach () TransformControls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Removes the current 3D object from the controls and makes the helper UI invisible.

📦:dispose () undefined
~~~~~~~~~~~~~~~~~~~~~~~~

   Should be called if the controls is no longer required.

📦:getRaycaster () Raycaster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the ``Raycaster`` object that is used for user interaction. This object is
   shared between all instances of TransformControls. If you set the `.layers <#Object3D.layers>`__ 
   property of the ``TransformControls``, you will also want to set the `.layers <#Raycaster.layers>`__ 
   property on the ``Raycaster`` with a matching value, or else the ``TransformControls`` 
   won't work as expected.

📦:getMode () String
~~~~~~~~~~~~~~~~~~~~~

   Returns the transformation mode.

📦:reset () undefined
~~~~~~~~~~~~~~~~~~~~~~

   Resets the object's position, rotation and scale to when the current transform began.

📦:setMode ( String mode ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `mode <#String>`__: The transformation mode.

   Sets the transformation mode.

📦:setRotationSnap ( Number rotationSnap ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `rotationSnap <#Number>`__: The rotation snap.

   Sets the rotation snap.

📦:setScaleSnap ( Number scaleSnap ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scaleSnap <#Number>`__: The scale snap.

   Sets the scale snap.

📦:setSize ( Number size ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `size <#Number>`__: The size of the helper UI.

   Sets the size of the helper UI.

📦:setSpace ( String space ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `space <#String>`__: The coordinate space in which transformations are applied.

   Sets the coordinate space in which transformations are applied.

📦:setTranslationSnap ( Number translationSnap ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `translationSnap <#Number>`__: The translation snap.

   Sets the translation snap.



.. _D242:

BufferGeometry → ConvexGeometry
===============================

   https://threejs.org/docs/examples/en/geometries/ConvexGeometry.html

   ``TransformControls`` can be used to generate a convex hull for a given array of 3D points. The average
   time complexity for this task is considered to be O(nlog(n)).

   **Import**

   `` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';


   **Code Example**


   .. code:: javascript

      const geometry = new ConvexGeometry( points );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );


   **Examples**

   [example:webgl_geometry_convex geometry / convex ]

   .. Constructor

🐣:ConvexGeometry( Array points )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   points — Array of `Vector3s <#Vector3>`__ that the resulting convex hull will contain.



.. _D243:

BufferGeometry → DecalGeometry
==============================

   https://threejs.org/docs/examples/en/geometries/DecalGeometry.html

   ``ConvexGeometry`` can be used to create a decal mesh that serves different kinds of purposes e.g.
   adding unique details to models, performing dynamic visual environmental changes or
   covering seams.

   **Import**

   ``ConvexGeometry`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';


   **Code Example**


   .. code:: javascript

      const geometry = new DecalGeometry( mesh, position, orientation, size );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );


   **Examples**

   [example:webgl_decals WebGL / decals]

   .. Constructor

🐣:DecalGeometry( Mesh mesh, Vector3 position, Euler orientation, Vector3 size )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   mesh — Any mesh object.
   position — Position of the decal projector.
   orientation — Orientation of the decal projector.
   size — Size of the decal projector.



.. _D244:

BufferGeometry → ParametricGeometry
===================================

   https://threejs.org/docs/examples/en/geometries/ParametricGeometry.html

   Generate geometry representing a parametric surface.

   **Import**

   ``DecalGeometry`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';


   **Code Example**


   .. code:: javascript

      const geometry = new THREE.ParametricGeometry( THREE.ParametricGeometries.klein, 25, 25 );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const klein = new THREE.Mesh( geometry, material );
      scene.add( klein );


   .. Constructor

🐣:ParametricGeometry(Function func, Integer slices, Integer stacks)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   func — A function that takes in a `u <#Float>`__ and `v <#Float>`__ value each between 0
   and 1 and modifies a third ``Vector3`` argument. Default is a function that generates
   a curved plane surface.
   slices — The count of slices to use for the parametric function. Default is ``8``.
   stacks — The count of stacks to use for the parametric function. Default is ``8``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D245:

SDFGeometryGenerator
====================

   https://threejs.org/docs/examples/en/geometries/SDFGeometryGenerator.html

   ``ParametricGeometry`` generates instances of ``BufferGeometry`` from a Signed Distance Function Uses
   `Mikola Lysenko's Isosurface <https://www.npmjs.com/package/isosurface>`__

   **Import**

   ``ParametricGeometry`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { SDFGeometryGenerator } from 'three/addons/geometries/SDFGeometryGenerator.js';


   **Code Example**


   .. code:: javascript

      const generator = new SDFGeometryGenerator( renderer );
      const sdf = 'float dist( vec3 p ){ return length(p) - 0.5;
      }' // glsl 
      const geometry = generator.generate( 64, sdf, 1 );
      // ~> THREE.BufferGeometry


   **Examples**

   [example:webgl_geometry_sdf geometry / sdf ]

   .. Constructor

🐣:SDFGeometryGenerator( WebGLRenderer renderer )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderer <#WebGLRenderer>`__ -- The renderer used to render the scene.

Methods
-------

📦:generate( Int resolution, String distanceField, Int bounds ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   **resolution** - Int [ mandatory ] Amount of 'voxels' used for triangulation. Must be
   power of 2.
   Gets heavy after 256, most machines won't be able to process over 512. Defaults to 64.

   **distanceField** - String [ mandatory ] String with glsl distance function. Name of
   function must be 'dist', with a vec3 argument. ( see code above ). Defaults to a sphere
   distance.

   **bounds** - Int [ optional ] Bounds in which signed distance field will be evaluated.
   Defaults to 1.



.. _D246:

BufferGeometry → TeapotGeometry
===============================

   https://threejs.org/docs/examples/en/geometries/TeapotGeometry.html

   ``SDFGeometryGenerator`` tesselates the famous Utah teapot database by Martin Newell.

   **Import**

   ``SDFGeometryGenerator`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';


   **Code Example**


   .. code:: javascript

      const geometry = new TeapotGeometry( 50, 18 );
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      const teapot = new THREE.Mesh( geometry, material );
      scene.add( teapot );


   .. Constructor

🐣:TeapotGeometry(Integer size, Integer segments, Boolean bottom, Boolean lid, Boolean body, Boolean fitLid, Boolean blinn)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   size — Relative scale of the teapot. Optional; Defaults to ``50``.
   segments — Number of line segments to subdivide each patch edge. Optional; Defaults to
   ``10``.
   bottom — Whether the bottom of the teapot is generated or not. Optional; Defaults to
   ``true``.
   lid — Whether the lid is generated or not. Optional; Defaults to ``true``.
   body — Whether the body is generated or not. Optional; Defaults to ``true``.
   fitLid — Whether the lid is slightly stretched to prevent gaps between the body and lid
   or not. Optional; Defaults to ``true``.
   blinn — Whether the teapot is scaled vertically for better aesthetics or not. Optional;
   Defaults to ``true``.

Properties
----------

   See the base ``BufferGeometry`` class for common properties.

Methods
-------

   See the base ``BufferGeometry`` class for common methods.



.. _D247:

BufferGeometry → ExtrudeGeometry → TextGeometry
===============================================

   https://threejs.org/docs/examples/en/geometries/TextGeometry.html

   A class for generating text as a single geometry. It is constructed by providing a string
   of text, and a set of parameters consisting of a loaded font and settings for the
   geometry's parent ``ExtrudeGeometry``. See the ``FontLoader`` page for additional
   details.

   **Import**

   ``TeapotGeometry`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';


   **Code Example**


   .. code:: javascript

      const loader = new FontLoader();

      loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

         const geometry = new TextGeometry( 'Hello three.js!', {
            font: font,
            size: 80,
            depth: 5,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 10,
            bevelSize: 8,
            bevelOffset: 0,
            bevelSegments: 5
         } );
      } );


   **Examples**

   [example:webgl_geometry_text geometry / text ]

   .. Constructor

🐣:TextGeometry(String text, Object parameters)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   text — The text that needs to be shown.
   parameters — Object that can contains the following parameters.

   -  font — an instance of THREE.Font.
   -  size — Float. Size of the text. Default is 100.
   -  depth — Float. Thickness to extrude text. Default is 50.
   -  curveSegments — Integer. Number of points on the curves. Default is 12.
   -  bevelEnabled — Boolean. Turn on bevel. Default is False.
   -  bevelThickness — Float. How deep into text bevel goes. Default is 10.
   -  bevelSize — Float. How far from text outline is bevel. Default is 8.
   -  bevelOffset — Float. How far from text outline bevel starts. Default is 0.
   -  bevelSegments — Integer. Number of bevel segments. Default is 3.

Available Fonts
---------------

   TextGeometry uses `typeface.json <http://gero3.github.io/facetype.js/>`__ generated fonts.
   Some existing fonts can be found located in **/examples/fonts** and must be included in
   the page.

   =========== ====== ====== =======================================================
   Font        Weight Style  File Path
   =========== ====== ====== =======================================================
   helvetiker  normal normal /examples/fonts/helvetiker_regular.typeface.json
   helvetiker  bold   normal /examples/fonts/helvetiker_bold.typeface.json
   optimer     normal normal /examples/fonts/optimer_regular.typeface.json
   optimer     bold   normal /examples/fonts/optimer_bold.typeface.json
   gentilis    normal normal /examples/fonts/gentilis_regular.typeface.json
   gentilis    bold   normal /examples/fonts/gentilis_bold.typeface.json
   droid sans  normal normal /examples/fonts/droid/droid_sans_regular.typeface.json
   droid sans  bold   normal /examples/fonts/droid/droid_sans_bold.typeface.json
   droid serif normal normal /examples/fonts/droid/droid_serif_regular.typeface.json
   droid serif bold   normal /examples/fonts/droid/droid_serif_bold.typeface.json
   =========== ====== ====== =======================================================

Properties
----------

   See the base ``ExtrudeGeometry`` class for common properties.

⭕:Object parameters
~~~~~~~~~~~~~~~~~~~~~

   An object with a property for each of the constructor parameters. Any modification after
   instantiation does not change the geometry.

Methods
-------

   See the base ``ExtrudeGeometry`` class for common methods.



.. _D248:

Object3D → Mesh → LightProbeHelper
==================================

   https://threejs.org/docs/examples/en/helpers/LightProbeHelper.html

   Renders a sphere to visualize a light probe in the scene.

   **Import**

   ``TextGeometry`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';


   **Code Example**


   .. code:: javascript

      const helper = new LightProbeHelper( lightProbe, 1 );
      scene.add( helper );


   **Examples**

   [example:webgl_lightprobe_cubecamera WebGL / lightprobe / cubecamera]

   .. Constructor

🐣:LightProbeHelper( LightProbe lightProbe, Number size )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `lightProbe <#LightProbe>`__ -- the light probe.
   `size <#Number>`__ -- size of the helper sphere

Properties
----------

   See the base ``Mesh`` class for common properties.

⭕:LightProbe lightProbe
~~~~~~~~~~~~~~~~~~~~~~~~~

   The light probe.

⭕:Number size
~~~~~~~~~~~~~~~

   The size of the helper sphere.

Methods
-------

   See the base ``Mesh`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D249:

Object3D → Line → PositionalAudioHelper
=======================================

   https://threejs.org/docs/examples/en/helpers/PositionalAudioHelper.html

   This helper displays the directional cone of a ``PositionalAudio``.

   **Import**

   ``LightProbeHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';


   **Code Example**


   .. code:: javascript

      const positionalAudio = new THREE.PositionalAudio( listener );
      positionalAudio.setDirectionalCone( 180, 230, 0.1 );
      const helper = new PositionalAudioHelper( positionalAudio );
      positionalAudio.add( helper );


   **Examples**


      [example:webaudio_orientation webaudio / orientation ]

   .. Constructor

🐣:PositionalAudioHelper( PositionalAudio audio, Number range )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `audio <#PositionalAudio>`__ -- The ``PositionalAudio`` to be visualized.
   `range <#Number>`__ -- (optional) The range of the directional cone.
   `divisionsInnerAngle <#Number>`__ -- (optional) The amount of divisions of the inner
   part of the directional cone.
   `divisionsOuterAngle <#Number>`__ -- (optional) The amount of divisions of the outer
   part of the directional cone.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:PositionalAudio audio
~~~~~~~~~~~~~~~~~~~~~~~~~

   ``PositionalAudio`` to be visualized.

⭕:Number range
~~~~~~~~~~~~~~~~

   The range of the directional cone.

⭕:Number divisionsInnerAngle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The amount of divisions of the inner part of the directional cone.

⭕:Number divisionsOuterAngle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The amount of divisions of the outer part of the directional cone.

Methods
-------

   See the base ``Line`` class for common methods.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the helper.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D250:

Object3D → Line → RectAreaLightHelper
=====================================

   https://threejs.org/docs/examples/en/helpers/RectAreaLightHelper.html

   Creates a visual aid for a ``RectAreaLight``.

   **Import**

   ``PositionalAudioHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';


   **Code Example**


   .. code:: javascript

      const light = new THREE.RectAreaLight( 0xffffbb, 1.0, 5, 5 );
      const helper = new RectAreaLightHelper( light );
      light.add( helper );
      // helper must be added as a child of the light


   .. Constructor

🐣:RectAreaLightHelper( RectAreaLight light, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `light <#RectAreaLight>`__ -- The light being visualized.
   `color <#Hex>`__ -- (optional) if this is not the set the helper will take the color of
   the light.

Properties
----------

   See the base ``Object3D`` class for common properties.

⭕:RectAreaLight light
~~~~~~~~~~~~~~~~~~~~~~~

   Reference to the RectAreaLight being visualized.

⭕:hex color
~~~~~~~~~~~~~

   The color parameter passed in the constructor. Default is ``undefined``. If this is
   changed, the helper's color will update the next time ``update`` is called.

Methods
-------

   See the base ``Line`` class for common methods.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D251:

Object3D → Line → LineSegments → VertexNormalsHelper
====================================================

   https://threejs.org/docs/examples/en/helpers/VertexNormalsHelper.html

   Visualizes an object's vertex normals. Requires that normals have been specified in a
   `custom attribute <#BufferAttribute>`__ or have been calculated using
   `computeVertexNormals <#BufferGeometry.computeVertexNormals>`__.

   **Import**

   ``RectAreaLightHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';


   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 10, 10, 10, 2, 2, 2 );
      const material = new THREE.MeshStandardMaterial();
      const mesh = new THREE.Mesh( geometry, material );
      const helper = new VertexNormalsHelper( mesh, 1, 0xff0000 );
      scene.add( mesh );
      scene.add( helper );


   **Examples**

   [example:webgl_helpers WebGL / helpers]

   .. Constructor

🐣:VertexNormalsHelper( Object3D object, Number size, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ -- object for which to render vertex normals.
   `size <#Number>`__ -- (optional) length of the arrows. Default is ``1``.
   `color <#Hex>`__ -- (optional) hex color of the arrows. Default is ``0xff0000``.

Properties
----------

   See the base ``LineSegments`` class for common properties.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   object's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object3D object
~~~~~~~~~~~~~~~~~~~

   The object for which the vertex normals are being visualized.

⭕:Number size
~~~~~~~~~~~~~~~

   Length of the arrows. Default is ``1``.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the vertex tangents preview based on the object's world transform.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.



.. _D252:

Object3D → Line → LineSegments → VertexTangentsHelper
=====================================================

   https://threejs.org/docs/examples/en/helpers/VertexTangentsHelper.html

   Visualizes an object's vertex tangents. Requires that tangents have been specified in a
   `custom attribute <#BufferAttribute>`__ or have been calculated using
   `computeTangents <#BufferGeometry.computeTangents>`__.

   **Import**

   ``VertexNormalsHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';


   **Code Example**


   .. code:: javascript

      const geometry = new THREE.BoxGeometry( 10, 10, 10, 2, 2, 2 );
      const material = new THREE.MeshStandardMaterial();
      const mesh = new THREE.Mesh( geometry, material );
      const helper = new VertexTangentsHelper( mesh, 1, 0x00ffff );
      scene.add( mesh );
      scene.add( helper );


   **Examples**

   [example:webgl_helpers WebGL / helpers]

   .. Constructor

🐣:VertexTangentsHelper( Object3D object, Number size, Hex color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ -- object for which to render vertex tangents.
   `size <#Number>`__ -- (optional) length of the arrows. Default is ``1``.
   `color <#Hex>`__ -- (optional) hex color of the arrows. Default is ``0x00ffff``.

Properties
----------

   See the base ``LineSegments`` class for common properties.

⭕:Object matrixAutoUpdate
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   See ``Object3D.matrixAutoUpdate``. Set to ``false`` here as the helper is using the
   object's `matrixWorld <#Object3D.matrixWorld>`__.

⭕:Object3D object
~~~~~~~~~~~~~~~~~~~

   The object for which the vertex tangents are being visualized.

⭕:Number size
~~~~~~~~~~~~~~~

   Length of the arrows. Default is ``1``.

Methods
-------

   See the base ``LineSegments`` class for common methods.

📦:update() undefined
~~~~~~~~~~~~~~~~~~~~~~

   Updates the vertex tangents preview based on the object's world transform.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever 
   this instance is no longer used in your app.



.. _D253:

LightProbeGenerator
===================

   https://threejs.org/docs/examples/en/lights/LightProbeGenerator.html

   Utility class for creating instances of ``LightProbe``.

   **Import**

   ``VertexTangentsHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';


   **Examples**

   [example:webgl_lightprobe WebGL / light probe ]
   [example:webgl_lightprobe_cubecamera WebGL / light probe / cube camera ]

Static Methods
--------------

📦:fromCubeTexture ( CubeTexture cubeTexture ) LightProbe
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a light probe from the given (radiance) environment map. The method expects that
   the environment map is represented as a cube texture.

📦:fromCubeRenderTarget ( WebGLRenderer renderer, WebGLCubeRenderTarget cubeRenderTarget ) LightProbe
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a light probe from the given (radiance) environment map. The method expects that
   the environment map is represented as a cube render target.

   The `format <#Texture.format>`__ of the cube render target must be set to ``RGBA``.



.. _D254:

Loader → 3DMLoader
==================

   https://threejs.org/docs/examples/en/loaders/3DMLoader.html

   A loader for Rhinoceros 3d files and objects.

   Rhinoceros is a 3D modeler used to create, edit, analyze, document, render, animate, and
   translate NURBS curves, surfaces, breps, extrusions, point clouds, as well as polygon
   meshes and SubD objects. `rhino3dm.js <https://github.com/mcneel/rhino3dm>`__ is
   compiled to WebAssembly from the open source geometry library
   `openNURBS <https://github.com/mcneel/opennurbs>`__. The loader currently uses
   `rhino3dm.js 8.4.0. <https://www.npmjs.com/package/rhino3dm/v/8.4.0>`__

   **Import**

   ``VertexTangentsHelper`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { Rhino3dmLoader } from 'three/addons/loaders/3DMLoader.js';


Supported Conversions
---------------------

   The ``VertexTangentsHelper`` converts Rhino objects to the following three.js types:

   ==================================== ================================================
   3dm type                             three.js type
   ==================================== ================================================
   Point                                `Points <#Points>`__
   PointSet / PointCloud                `Points <#Points>`__
   TextDot                              `Sprite <#Sprite>`__
   Curve                                `Line <#Line>`__ :sup:`1`
   Mesh                                 `Mesh <#Mesh>`__
   Extrusion                            `Mesh <#Mesh>`__ :sup:`2`
   BREP                                 `Mesh <#Mesh>`__ :sup:`2`
   SubD                                 `Mesh <#Mesh>`__ :sup:`3`
   InstanceReferences                   `Object3D <#Object3D>`__
   DirectionalLight                     `DirectionalLight <#DirectionalLight>`__
   PointLight                           `PointLight <#PointLight>`__
   RectangularLight                     `RectAreaLight <#RectAreaLight>`__
   SpotLight                            `SpotLight <#SpotLight>`__
   File3dm                              `Object3D <#Object3D>`__ :sup:`4`
   Material / Physically Based Material `MeshPhysicalMaterial <#MeshPhysicalMaterial>`__
   ==================================== ================================================

   **Notes:**

   *1 NURBS curves are discretized to a hardcoded resolution.*

   *2 Types which are based on BREPs and NURBS surfaces are represented with their "Render
   Mesh". Render meshes might not be associated with these objects if they have not been
   displayed in an appropriate display mode in Rhino (i.e. "Shaded", "Rendered", etc), or are
   created programmatically, for example, via Grasshopper or directly with the rhino3dm
   library. As of rhino3dm.js@8.0.0-beta2, BrepFace and Extrusions can be assigned a mesh
   representation, but these must be generated by the user.*

   *3 SubD objects are represented by subdividing their control net.*

   *4 Whether a Rhino Document (File3dm) is loaded or parsed, the returned object is an
   `Object3D <#Object3D>`__ with all Rhino objects (File3dmObject) as children. File3dm
   layers and other file level properties are added to the resulting object's userData.*

   *5 All resulting three.js objects have useful properties from the Rhino object (i.e. layer
   index, name, etc.) populated in their userData object.*

   *6 Rhino and Three.js have a different coordinate system. Upon import, you should rotate
   the resulting `Object3D <#Object3D>`__ by -90º in x or set the THREE.Object3D.DEFAULT_UP
   at the beginning of your application: ``THREE.Object3D.DEFAULT_UP.set( 0, 0, 1 );`` Keep
   in mind that this will affect the orientation of all of the Object3Ds in your
   application.*

   **Examples**

   [example:webgl_loader_3dm]



   .. Constructor

🐣:Rhino3dmLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new Rhino3dmLoader.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.3dm`` file.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading from url and call the ``onLoad`` function with the resulting Object3d.


   .. code:: javascript

      // Instantiate a loader
      const loader = new Rhino3dmLoader();
         
      // Specify path to a folder containing WASM/JS libraries or a CDN.
      // For example, /jsm/libs/rhino3dm/ is the location of the library inside the three.js repository
      // loader.setLibraryPath( '/path_to_library/rhino3dm/' );
      loader.setLibraryPath( 'https://cdn.jsdelivr.net/npm/rhino3dm@8.4.0/' );
         
      // Load a 3DM file
      loader.load(
         // resource URL
         'model.3dm',
         // called when the resource is loaded
         function ( object ) {
         
            scene.add( object );
         
         },
         // called as loading progresses
         function ( xhr ) {
         
            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
         
         },
         // called when loading has errors
         function ( error ) {
         
            console.log( 'An error happened' );
         
         }
      );


📦:parse( ArrayBuffer buffer, Function onLoad, Function onProgress, Function onError ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `buffer <#ArrayBuffer>`__ — An ArrayBuffer representing the Rhino ``File3dm`` document.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Parse a File3dm ArrayBuffer and call the ``onLoad`` function with the resulting Object3d.
   See `this example <https://github.com/mcneel/rhino-developer-samples/tree/8/rhino3dm/js/SampleParse3dmObjects>`__ 
   for further reference.


   .. code:: javascript

      import rhino3dm from 'https://cdn.jsdelivr.net/npm/rhino3dm@8.4.0'

      // Instantiate a loader
      const loader = new Rhino3dmLoader();

      // Specify path to a folder containing WASM/JS libraries or a CDN.
      loader.setLibraryPath( 'https://cdn.jsdelivr.net/npm/rhino3dm@8.4.0' );

      const rhino = await rhino3dm();
      console.log('Loaded rhino3dm.');

      // create Rhino Document and add a point to it
      const doc = new rhino.File3dm();
      const ptA = [0, 0, 0];
      const point = new rhino.Point( ptA );
      doc.objects().add( point, null );

      // create a copy of the doc.toByteArray data to get an ArrayBuffer
      const buffer = new Uint8Array( doc.toByteArray() ).buffer;

      loader.parse( buffer, function ( object ) {

         scene.add( object );

      } );


📦:setLibraryPath( String value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `value <#String>`__ — Path to folder containing the JS and WASM libraries.


   .. code:: javascript

      // Instantiate a loader
      const loader = new Rhino3dmLoader();

      // Specify path to a folder containing the WASM/JS library:
      loader.setLibraryPath( '/path_to_library/rhino3dm/' );
      // or from a CDN:
      loader.setLibraryPath( 'https://cdn.jsdelivr.net/npm/rhino3dm@8.4.0' );


📦:setWorkerLimit( Number workerLimit ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `workerLimit <#Number>`__ - Maximum number of workers to be allocated. Default is 4.

   Sets the maximum number of `Web Workers <https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers>`__ 
   to be used during decoding. A lower limit may be preferable if workers are
   also for other tasks in the application.

📦:dispose() this
~~~~~~~~~~~~~~~~~~

   Disposes of the loader resources and deallocates memory.



.. _D255:

Loader → DRACOLoader
====================

   https://threejs.org/docs/examples/en/loaders/DRACOLoader.html

   A loader for geometry compressed with the Draco library.
   `Draco <https://google.github.io/draco/>`__ is an open source library for compressing
   and decompressing 3D meshes and point clouds. Compressed geometry can be significantly
   smaller, at the cost of additional decoding time on the client device.

   Standalone Draco files have a ``.drc`` extension, and contain vertex positions, normals,
   colors, and other attributes. Draco files ``do not`` contain materials, textures,
   animation, or node hierarchies – to use these features, embed Draco geometry inside of a
   glTF file. A normal glTF file can be converted to a Draco-compressed glTF file using
   `glTF-Pipeline <https://github.com/AnalyticalGraphicsInc/gltf-pipeline>`__. When using
   Draco with glTF, an instance of DRACOLoader will be used internally by ``GLTFLoader``.

   It is recommended to create one DRACOLoader instance and reuse it to avoid loading and
   creating multiple decoder instances.

   **Import**

   ``Rhino3dmLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';


   **Code Example**


   .. code:: javascript

      // Instantiate a loader
      const loader = new DRACOLoader();

      // Specify path to a folder containing WASM/JS decoding libraries.
      loader.setDecoderPath( '/examples/jsm/libs/draco/' );

      // Optional: Pre-fetch Draco WASM/JS module.
      loader.preload();

      // Load a Draco geometry
      loader.load(
         // resource URL
         'model.drc',
         // called when the resource is loaded
         function ( geometry ) {

            const material = new THREE.MeshStandardMaterial( { color: 0x606060 } );
            const mesh = new THREE.Mesh( geometry, material );
            scene.add( mesh );

         },
         // called as loading progresses
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );


   **Examples**

   [example:webgl_loader_draco]


   **Browser compatibility**

   DRACOLoader will automatically use either the JS or the WASM decoding library, based on
   browser capabilities.

   

   .. Constructor

🐣:DRACOLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``DRACOLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.drc`` file.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading from url and call the ``onLoad`` function with the decompressed geometry.

📦:setDecoderPath( String value ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `value <#String>`__ — Path to folder containing the JS and WASM decoder libraries.

📦:setDecoderConfig( Object config ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `config.type <#String>`__ - (Optional) ``"js"`` or ``"wasm"``.

   Provides configuration for the decoder libraries. Configuration cannot be changed after
   decoding begins.

📦:setWorkerLimit( Number workerLimit ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `workerLimit <#Number>`__ - Maximum number of workers to be allocated. Default is 4.

   Sets the maximum number of
   `Web Workers <https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers>`__ 
   to be used during decoding. A lower limit may be preferable if workers are
   also for other tasks in the application.

📦:preload() this
~~~~~~~~~~~~~~~~~~

   Requests the decoder libraries, if not already loaded.

📦:dispose() this
~~~~~~~~~~~~~~~~~~

   Disposes of the decoder resources and deallocates memory. The decoder
   `cannot be reloaded afterward <https://github.com/google/draco/issues/349>`__.



.. _D256:

Loader → FontLoader
===================

   https://threejs.org/docs/examples/en/loaders/FontLoader.html

   Class for loading a font in JSON format. Returns a font, which is an array of
   `Shapes <#Shape>`__ representing the font. This uses the ``FileLoader`` internally
   for loading files.
   You can convert fonts online using `facetype.js <https://gero3.github.io/facetype.js/>`__

   **Import**

   ``DRACOLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { FontLoader } from 'three/addons/loaders/FontLoader.js';


   **Code Example**


   .. code:: javascript

      const loader = new FontLoader();
      const font = loader.load(
         // resource URL
         'fonts/helvetiker_bold.typeface.json',

         // onLoad callback
         function ( font ) {
            // do something with the font
            console.log( font );
         },

         // onProgress callback
         function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
         },

         // onError callback
         function ( err ) {
            console.log( 'An error happened' );
         }
      );


   **Examples**

   [example:webgl_geometry_text_shapes geometry / text / shapes ]
   [example:webgl_geometry_text geometry / text ]

   .. Constructor

🐣:FontLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader
   to use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.
   Creates a new ``FontLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — the path or URL to the file. This can also be a
   `Data URI <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs>`__.
   `onLoad <#Function>`__ — Will be called when load completes. The argument will be the
   loaded font.
   `onProgress <#Function>`__ — Will be called while load progresses. The argument will be
   the XMLHttpRequest instance, which contains `total <#Integer>`__ and `loaded <#Integer>`__ bytes. 
   If the server does not set the Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — Will be called when load errors.
   Begin loading from url and pass the loaded font to onLoad.

📦:parse( Object json ) Font
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `json <#Object>`__ — The ``JSON`` structure to parse.
   Parse a ``JSON`` structure and return a font.



.. _D257:

Loader → GLTFLoader
===================

   https://threejs.org/docs/examples/en/loaders/GLTFLoader.html

   A loader for ``glTF 2.0`` resources.
   `glTF <https://www.khronos.org/gltf>`__ (GL Transmission Format) is an
   `open format specification <https://github.com/KhronosGroup/glTF/tree/master/specification/2.0>`__ 
   for efficient delivery and loading of 3D content. Assets may be provided
   either in JSON (.gltf) or binary (.glb) format. External files store textures (.jpg,
   .png) and additional binary data (.bin). A glTF asset may deliver one or more scenes,
   including meshes, materials, textures, skins, skeletons, morph targets, animations,
   lights, and/or cameras.

   ``FontLoader`` uses ``ImageBitmapLoader`` whenever possible. Be advised that image bitmaps are
   not automatically GC-collected when they are no longer referenced, and they require
   special handling during the disposal process. More information in the
   `How to dispose of objects <https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects>`__ guide.

   **Import**

   ``FontLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


   Extensions
   ----------

   GLTFLoader supports the following
   `glTF 2.0 extensions <https://github.com/KhronosGroup/glTF/tree/master/extensions/>`__:

   -  KHR_draco_mesh_compression
   -  KHR_materials_clearcoat
   -  KHR_materials_dispersion
   -  KHR_materials_ior
   -  KHR_materials_specular
   -  KHR_materials_transmission
   -  KHR_materials_iridescence
   -  KHR_materials_unlit
   -  KHR_materials_volume
   -  KHR_mesh_quantization
   -  KHR_lights_punctual
   -  KHR_texture_basisu
   -  KHR_texture_transform
   -  EXT_texture_webp
   -  EXT_meshopt_compression
   -  EXT_mesh_gpu_instancing

   The following glTF 2.0 extension is supported by an external user plugin

   -  `KHR_materials_variants <https://github.com/takahirox/three-gltf-extensions>`__\ :sup:`1`
   -  `MSFT_texture_dds <https://github.com/takahirox/three-gltf-extensions>`__

   *1\ You can also manually process the extension after loading in your application. See
   `Three.js glTF materials variants example <https://threejs.org/examples/#webgl_loader_gltf_variants>`__.*

   **Code Example**


   .. code:: javascript

      // Instantiate a loader 
      const loader = new GLTFLoader();

      // Optional: Provide a DRACOLoader instance to decode compressed mesh data 
      const dracoLoader = new DRACOLoader();

      dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );
      loader.setDRACOLoader( dracoLoader );
      // Load a glTF resource 
      loader.load( 
         // resource URL 
         'models/gltf/duck/duck.gltf', 

         // called when the resource is loaded 
         function ( gltf ) { 
            scene.add( gltf.scene );
            gltf.animations;
            // Array<THREE.AnimationClip> gltf.scene;
            // THREE.Group gltf.scenes;
            // Array<THREE.Group> gltf.cameras;
            // Array<THREE.Camera> gltf.asset;
            // Object 
         }, 

         // called while loading is progressing 
         function ( xhr ) {
            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
         }, 

         // called when loading has errors 
         function ( error ) { 
            console.log( 'An error happened' );
      } );


   **Examples**

   [example:webgl_loader_gltf]

   Textures
   --------

   When loading textures externally (e.g., using ``TextureLoader``) and applying them to a
   glTF model, textures must be configured. Textures referenced from the glTF model are
   configured automatically by GLTFLoader.


   .. code:: javascript

      // If texture is used for color information (.map, .emissiveMap, .specularMap, ...), set color space 
      texture.colorSpace = THREE.SRGBColorSpace;

      // UVs use the convention that (0, 0) corresponds to the upper left corner of a texture. 
      texture.flipY = false;


   Custom extensions
   -----------------

   Metadata from unknown extensions is preserved as “.userData.gltfExtensions” on Object3D,
   Scene, and Material instances, or attached to the response “gltf” object. Example:


   .. code:: javascript

      loader.load('foo.gltf', function ( gltf ) { 
         const scene = gltf.scene; 
         const mesh = scene.children[ 3 ]; 
         const fooExtension = mesh.userData.gltfExtensions.EXT_foo; 
         gltf.parser.getDependency( 'bufferView', fooExtension.bufferView )
            .then( function ( fooBuffer ) { ... } ); 
         } 
      );

   .. Constructor

🐣:GLTFLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``GLTFLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.gltf`` or ``.glb`` file.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed. The function receives the loaded JSON response returned from `parse <#Function>`__.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading from url and call the callback function with the parsed response content.

📦:setDRACOLoader( DRACOLoader dracoLoader ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `dracoLoader <#DRACOLoader>`__ — Instance of DRACOLoader, to be used for decoding assets
   compressed with the KHR_draco_mesh_compression extension.

   Refer to this
   `readme <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/libs/draco#readme>`__
   for the details of Draco and its decoder.

📦:setKTX2Loader( KTX2Loader ktx2Loader ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `ktx2Loader <#KTX2Loader>`__ — Instance of KTX2Loader, to be used for loading KTX2
   compressed textures.

📦:parse( ArrayBuffer data, String path, Function onLoad, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `data <#ArrayBuffer>`__ — glTF asset to parse, as an ``ArrayBuffer``, ``JSON`` string or
   object.
   `path <#String>`__ — The base path from which to find subsequent glTF resources such as
   textures and .bin data files.
   `onLoad <#Function>`__ — A function to be called when parse completes.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   parsing. The function receives error as an argument.

   Parse a glTF-based ``ArrayBuffer``, ``JSON`` string or object and fire `onLoad <#Function>`__ 
   callback when complete. The argument to `onLoad <#Function>`__ will be an
   ``Object`` that contains loaded parts: `scene <#Group>`__, `scenes <#Array>`__,
   `cameras <#Array>`__, `animations <#Array>`__, and `asset <#Object>`__.



.. _D258:

Loader → KTX2Loader
===================

   https://threejs.org/docs/examples/en/loaders/KTX2Loader.html

   Loader for KTX 2.0 GPU Texture containers.
   `KTX 2.0 <http://github.khronos.org/KTX-Specification/>`__ is a container format for
   various GPU texture formats. The loader supports Basis Universal GPU textures, which can
   be quickly transcoded to a wide variety of GPU texture compression formats. While KTX
   2.0 also allows other hardware-specific formats, this loader does not yet parse them.

   This loader parses the KTX 2.0 container and transcodes to a supported GPU compressed
   texture format. The required WASM transcoder and JS wrapper are available from the
   `examples/jsm/libs/basis <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/libs/basis>`__ directory.

   **Import**

   ``GLTFLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';


   **Code Example**


   .. code:: javascript

      var ktx2Loader = new KTX2Loader();
      ktx2Loader.setTranscoderPath( 'examples/jsm/libs/basis/' );
      ktx2Loader.detectSupport( renderer );
      ktx2Loader.load( 'diffuse.ktx2', function ( texture ) { 
         var material = new THREE.MeshStandardMaterial( { map: texture } );
         }, 
         function () { 
            console.log( 'onProgress' );
         }, 
         function ( e ) { 
            console.error( e );
      } );


   **Examples**

   [example:webgl_loader_texture_ktx2]

   **Browser compatibility**

   This loader relies on Web Assembly which is not supported in older browsers.

   

   .. Constructor

🐣:KTX2Loader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The ``LoadingManager`` for the loader to use.
   Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``KTX2Loader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) CompressedTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.ktx2`` file.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Load from url and call the ``onLoad`` function with the transcoded
   ``CompressedTexture``.

📦:detectSupport( WebGLRenderer renderer ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderer <#WebGLRenderer>`__ — A renderer instance.

   Detects hardware support for available compressed texture formats, to determine the output
   format for the transcoder. Must be called before loading a texture.

📦:setTranscoderPath( String path ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `path <#String>`__ — Path to folder containing the WASM transcoder and JS wrapper.

   The WASM transcoder and JS wrapper are available from the
   `examples/jsm/libs/basis <https://github.com/mrdoob/three.js/tree/dev/examples/jsm/libs/basis>`__ directory.

📦:setWorkerLimit( Number limit ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `limit <#Number>`__ — Maximum number of workers. Default is '4'.

   Sets the maximum number of web workers to be allocated by this instance.

📦:dispose() this
~~~~~~~~~~~~~~~~~~

   Disposes the loader object, de-allocating any Web Workers created.



.. _D259:

Loader → LDrawLoader
====================

   https://threejs.org/docs/examples/en/loaders/LDrawLoader.html

   A loader for ``LDraw`` resources.
   `LDraw <https://ldraw.org>`__ (LEGO Draw) is an
   `open format specification <https://ldraw.org/article/218.html>`__ for describing LEGO
   and other construction set 3D models.

   An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a
   single construction piece, or an entire model. In the case of a model the LDraw file can
   reference other LDraw files, which are loaded from a library path set with `setPartsLibraryPath <#Function>`__. 
   You usually download the LDraw official parts library, extract to a
   folder and point setPartsLibraryPath to it.

   Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'.
   These file accesses are not optimal for web environment, so a script tool has been made to
   pack an LDraw file with all its dependencies into a single file, which loads much faster.
   See section 'Packing LDraw models'. The LDrawLoader example loads several packed files.
   The official parts library is not included due to its large size.

   **Import**

   ``KTX2Loader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';


   Extensions
   ----------

   LDrawLoader supports the following extensions:

   -  !COLOUR: Color and surface finish declarations.
   -  BFC: Back Face Culling specification.
   -  !CATEGORY: Model/part category declarations.
   -  !KEYWORDS: Model/part keywords declarations.

   **Code Example**


   .. code:: javascript

      // Instantiate a loader
      const loader = new LDrawLoader();

      // Optionally set library parts path
      // loader.setPartsLibraryPath( path to library );

      // Load a LDraw resource
      loader.load(
         // resource URL
         'models/car.ldr_Packed.mpd',
         // called when the resource is loaded
         function ( group ) {

            // Optionally, use LDrawUtils.mergeObject() from
            // 'examples/jsm/utils/LDrawUtils.js' to merge all
            // geometries by material (it gives better runtime
            // performance, but building steps are lost)
            // group = LDrawUtils.mergeObject( group );

            scene.add( group );

         },
         // called while loading is progressing
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );


   **Examples**

   [example:webgl_loader_ldraw]

   Packing LDraw models
   --------------------

   To pack a model with all its referenced files, download the
   `Official LDraw parts library <https://www.ldraw.org/parts/latest-parts.html>`__ and use
   the following Node script:
   `utils/packLDrawModel.js <https://github.com/mrdoob/three.js/blob/master/utils/packLDrawModel.js>`__ 
   It contains instructions on how to setup the files and execute it.

   Metadata in .userData
   ---------------------

   LDrawLoader returns a ``Group`` object which contains an object hierarchy. Depending
   of each subobject type, its .userData member will contain the following members:
   In a ``Group``, the userData member will contain:

   -  .numBuildingSteps: Only in the root ``Group``, Indicates total number of building
      steps in the model. These can be used to set visibility of objects to show different
      building steps, which is done in the example.
   -  .buildingStep: Indicates the building index of this step.
   -  .category: Contains, if not null, the ``String`` category for this piece or model.
   -  .keywords: Contains, if not null, an array of ``String`` keywords for this piece or
      model.

   In a ``Material``, the userData member will contain:

   -  .code: Indicates the LDraw code for this material.
   -  .edgeMaterial: Only in a ``Mesh`` material, indicates the ``LineBasicMaterial``
      belonging to edges of the same color code (in the LDraw format, each surface material
      is also related to an edge material)
   -  .conditionalEdgeMaterial: Only in a ``LineSegments`` material, indicates the
      ``Material`` belonging to conditional edges of the same color code.

   

   .. Constructor

🐣:LDrawLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``LDrawLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the LDraw file.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed. The function receives the loaded JSON response returned from `parse <#Function>`__.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading from url and call the callback function with the parsed response content.

📦:setPartsLibraryPath( String path ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `path <#String>`__ — Path to library parts files to load referenced parts from. This is
   different from ``Loader.setPath``, which indicates the path to load the main asset
   from.

   This method must be called prior to ``.load`` unless the model to load does not
   reference library parts (usually it will be a model with all its parts packed in a single
   file)

📦:setFileMap( Map fileMap ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `map <#Map>`__ — Set a map from ``String`` to ``String`` which maps referenced
   library filenames to new filenames. If a fileMap is not specified (the default), library
   parts will be accessed by trial and error in subfolders 'parts', 'p' and 'models'.

📦:parse( String text, String path, Function onLoad, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `text <#String>`__ — LDraw asset to parse, as string.
   `path <#String>`__ — The base path from which to find other referenced LDraw asset
   files.
   `onLoad <#Function>`__ — A function to be called when parse completes.

   Parse a LDraw file contents as a String and fire `onLoad <#Function>`__ callback when
   complete. The argument to `onLoad <#Function>`__ will be an ``Group`` that contains
   hierarchy of ``Group``, ``Mesh`` and ``LineSegments`` (with other part data in
   .userData fields).

📦:getMaterial( String colourCode ) Material
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `colourCode <#String>`__ — Color code to get the associated ``Material``.

📦:getMainMaterial() String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the ``Material`` for the main LDraw color.

   For an already loaded LDraw asset, returns the ``Material`` associated with the main
   color code. This method can be useful to modify the main material of a model or part that
   exposes it.

   The main color code is the standard way to color an LDraw part. It is '16' for triangles
   and '24' for edges. Usually a complete model will not expose the main color (that is, no
   part uses the code '16' at the top level, because they are assigned other specific colors)
   An LDraw part file on the other hand will expose the code '16' to be colored, and can have
   additional fixed colors.

📦:getMainEdgeMaterial() String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the ``Material`` for the edges main LDraw color.

📦:preloadMaterials( String path ) void
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `path <#String>`__ — Path of the LDraw materials asset.

   This async method preloads materials from a single LDraw file. In the official parts
   library there is a special file which is loaded always the first (LDConfig.ldr) and
   contains all the standard color codes. This method is intended to be used with not packed
   files, for example in an editor where materials are preloaded and parts are loaded on
   demand.



.. _D260:

Loader → LUT3dlLoader
=====================

   https://threejs.org/docs/examples/en/loaders/LUT3dlLoader.html

   A 3D LUT loader that supports the .3dl file format.
   Based on the following references:

   -  http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492
   -  https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258

   **Import**

   ``LDrawLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { LUT3dlLoader } from 'three/addons/loaders/LUT3dlLoader.js';


   .. Constructor

🐣:LUT3dlLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The LoadingManager to use. Defaults to
   `DefaultLoadingManager <#DefaultLoadingManager>`__

   Creates a new ``LUT3dlLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.3dl`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after the loading is
   successfully completed. The function receives the result of the `parse <#Function>`__
   method.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and return the loaded LUT.

📦:parse( String input ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `input <#String>`__ — The 3dl data string.

   Parse a 3dl data string and fire `onLoad <#Function>`__ callback when complete. The
   argument to `onLoad <#Function>`__ will be an `object <#Object>`__ containing the
   following LUT data: `.size <#Number>`__, `.texture <#DataTexture>`__ and
   `.texture3D <#Data3DTexture>`__.

📦:setType( Number type ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `type <#Number>`__ - The texture type. See the `texture constants <#Textures>`__ page
   for details.

   Sets the desired texture type. Only `THREE.UnsignedByteType <#Textures>`__ and
   `THREE.FloatType <#Textures>`__ are supported. The default is `THREE.UnsignedByteType <#Textures>`__.



.. _D261:

Loader → LUTCubeLoader
======================

   https://threejs.org/docs/examples/en/loaders/LUTCubeLoader.html

   A 3D LUT loader that supports the .cube file format.
   Based on the following reference:

   -  https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf

   **Import**

   ``LUT3dlLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { LUTCubeLoader } from 'three/addons/loaders/LUTCubeLoader.js';


   .. Constructor

🐣:LUTCubeLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The LoadingManager to use. Defaults to
   `DefaultLoadingManager <#DefaultLoadingManager>`__

   Creates a new ``LUTCubeLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.cube`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after the loading is
   successfully completed. The function receives the result of the `parse <#Function>`__
   method.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and return the loaded LUT.

📦:parse( String input ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `input <#String>`__ — The cube data string.

   Parse a cube data string and fire `onLoad <#Function>`__ callback when complete. The
   argument to `onLoad <#Function>`__ will be an `object <#Object>`__ containing the
   following LUT data: `.title <#String>`__, `.size <#Number>`__, `.domainMin <#Vector3>`__,
   `.domainMax <#Vector3>`__, `.texture <#DataTexture>`__ and `.texture3D <#Data3DTexture>`__.

📦:setType( Number type ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `type <#Number>`__ - The texture type. See the `texture constants <#Textures>`__ page
   for details.

   Sets the desired texture type. Only `THREE.UnsignedByteType <#Textures>`__ and
   `THREE.FloatType <#Textures>`__ are supported. The default is `THREE.UnsignedByteType <#Textures>`__.



.. _D262:

Loader → MMDLoader
==================

   https://threejs.org/docs/examples/en/loaders/MMDLoader.html

   A loader for ```MMD`` <https://sites.google.com/view/evpvp/>`__ resources.
   ``LUTCubeLoader`` creates Three.js Objects from MMD resources as PMD, PMX, VMD, and VPD files. See
   ``MMDAnimationHelper`` for MMD animation handling as IK, Grant, and Physics.
   If you want raw content of MMD resources, use .loadPMD/PMX/VMD/VPD methods.

   **Import**

   ``LUTCubeLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';


   **Code Example**


   .. code:: javascript

      // Instantiate a loader
      const loader = new MMDLoader();

      // Load a MMD model
      loader.load(
         // path to PMD/PMX file
         'models/mmd/miku.pmd',
         // called when the resource is loaded
         function ( mesh ) {

            scene.add( mesh );

         },
         // called when loading is in progresses
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );

   **Examples**

   [example:webgl_loader_mmd]
   [example:webgl_loader_mmd_pose]
   [example:webgl_loader_mmd_audio]

   .. Constructor

🐣:MMDLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``MMDLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.pmd`` or ``.pmx`` file.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading PMD/PMX model file from url and fire the callback function with the parsed
   ``SkinnedMesh`` containing ``BufferGeometry`` and an array of
   ``MeshToonMaterial``.

📦:loadAnimation( String url, Object3D object, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string or an array of string containing the path/URL of the
   ``.vmd`` file(s).If two or more files are specified, they'll be merged.
   `object <#Object3D>`__ — ``SkinnedMesh`` or ``Camera``. Clip and its tracks will
   be fitting to this object.
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ and `loaded <#Integer>`__ bytes.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading VMD motion file(s) from url(s) and fire the callback function with the
   parsed ``AnimationClip``.

📦:loadWithAnimation( String modelUrl, String vmdUrl, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `modelUrl <#String>`__ — A string containing the path/URL of the ``.pmd`` or ``.pmx``
   file.
   `vmdUrl <#String>`__ — A string or an array of string containing the path/URL of the
   ``.vmd`` file(s).
   `onLoad <#Function>`__ — A function to be called after the loading is successfully
   completed.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, that contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading PMD/PMX model file and VMD motion file(s) from urls and fire the callback
   function with an ``Object`` containing parsed ``SkinnedMesh`` and
   ``AnimationClip`` fitting to the ``SkinnedMesh``.

📦:setAnimationPath( String animationPath ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `animationPath <#String>`__ — Base path for loading animation data (VMD/VPD files).

   Set the base path for additional resources like textures.



.. _D263:

Loader → MTLLoader
==================

   https://threejs.org/docs/examples/en/loaders/MTLLoader.html

   A loader for loading an ``.mtl`` resource, used internally by ``OBJLoader``.
   The Material Template Library format (MTL) or .MTL File Format is a companion file
   format to .OBJ that describes surface shading (material) properties of objects within
   one or more .OBJ files.

   **Import**

   ``MMDLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';


   .. Constructor

🐣:MTLLoader( LoadingManager loadingManager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `loadingManager <#LoadingManager>`__ — LoadingManager to use. Defaults to
   `DefaultLoadingManager <#DefaultLoadingManager>`__

   Creates a new ``MTLLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.mtl`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after the loading is
   successfully completed. The function receives the loaded ``MTLLoader.MaterialCreator`` instance.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and return the loaded material.

📦:setMaterialOptions( Object options ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `options <#Object>`__ — required

   -  side: Which side to apply the material. THREE.FrontSide (default), THREE.BackSide,
      THREE.DoubleSide
   -  wrap: What type of wrapping to apply for textures. THREE.RepeatWrapping (default),
      THREE.ClampToEdgeWrapping, 
      THREE.MirroredRepeatWrapping
   -  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255. Default: false, assumed to
      be already normalized
   -  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's. Default: false
   -  invertTrProperty: Use values 1 of Tr field for fully opaque. This option is useful for
      obj exported from 3ds MAX, vcglib or meshlab. Default: false

   Set of options on how to construct the materials

📦:parse( String text, param:String path ) MTLLoaderMaterialCreator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `text <#String>`__ — The textual ``mtl`` structure to parse. `path <#String>`__ — The path
   to the MTL file.

   Parse a ``mtl`` text structure and return a ``MTLLoader.MaterialCreator`` instance.



.. _D264:

Loader → OBJLoader
==================

   https://threejs.org/docs/examples/en/loaders/OBJLoader.html

   A loader for loading a ``.obj`` resource.
   The `OBJ file format <https://en.wikipedia.org/wiki/Wavefront_.obj_file>`__ is a
   simple data-format that represents 3D geometry in a human readable format as the
   position of each vertex, the UV position of each texture coordinate vertex, vertex
   normals, and the faces that make each polygon defined as a list of vertices, and texture
   vertices.

   **Import**

   ``MTLLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';


   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new OBJLoader();

      // load a resource
      loader.load(
         // resource URL
         'models/monster.obj',
         // called when resource is loaded
         function ( object ) {

            scene.add( object );

         },
         // called when loading is in progresses
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );


   **Examples**

   [example:webgl_loader_obj]

   .. Constructor

🐣:OBJLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``OBJLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.obj`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after the loading is
   successfully completed. The function receives the loaded ``Object3D`` as an argument.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The function receives a XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives error as an argument.

   Begin loading from url and call onLoad with the parsed response content.

📦:parse( String text ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `text <#String>`__ — The textual ``obj`` structure to parse.

   Returns an ``Object3D``. It contains the parsed meshes as ``Mesh`` and lines as
   ``LineSegments``.
   All geometry is created as ``BufferGeometry``. Default materials are created as
   ``MeshPhongMaterial``.
   If an ``obj`` object or group uses multiple materials while declaring faces, geometry
   groups and an array of materials are used.

📦:setMaterials( MTLLoader.MaterialCreator materials ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `MTLLoader.MaterialCreator materials <#MTLLoaderMaterialCreator>`__ - A MaterialCreator
   instance.

   Sets materials loaded by MTLLoader or any other supplier of a
   `MTLLoader.MaterialCreator <#MTLLoaderMaterialCreator>`__.



.. _D265:

Loader → PCDLoader
==================

   https://threejs.org/docs/examples/en/loaders/PCDLoader.html

   A loader for the PCD (Point Cloud Data) file format. ``OBJLoader`` supports ASCII and
   (compressed) binary files as well as the following PCD fields:

   -  x y z
   -  rgb
   -  normal_x normal_y normal_z
   -  intensity
   -  label

   **Import**

   ``OBJLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';


   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new PCDLoader();

      // load a resource
      loader.load(
         // resource URL
         'pointcloud.pcd',
         // called when the resource is loaded
         function ( points ) {

            scene.add( points );

         },
         // called when loading is in progresses
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );


   **Examples**

   [example:webgl_loader_pcd]

   .. Constructor

🐣:PCDLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``PCDLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

   `littleEndian <#Boolean>`__
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Default value is true.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.pcd`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after loading is
   successfully completed. The function receives loaded ``Object3D`` as an argument.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and call onLoad with the parsed response content.

📦:parse( Arraybuffer data,String url ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `data <#Arraybuffer>`__ — The binary structure to parse.

   `url <#String>`__ — The file name or file url.

   Parse an ``pcd`` binary structure and return an ``Object3D``.
   The object is converted to ``Points`` with a ``BufferGeometry`` and a
   ``PointsMaterial``.



.. _D266:

Loader → PDBLoader
==================

   https://threejs.org/docs/examples/en/loaders/PDBLoader.html

   A loader for loading a ``.pdb`` resource.
   The `Protein Data Bank <http://en.wikipedia.org/wiki/Protein_Data_Bank_(file_format)>`__ 
   file format is a textual file describing the three-dimensional structures of
   molecules.

   **Import**

   ``PCDLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';


   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new PDBLoader();

      // load a PDB resource
      loader.load(
         // resource URL
         'models/pdb/caffeine.pdb',
         // called when the resource is loaded
         function ( pdb ) {

            const geometryAtoms = pdb.geometryAtoms;
            const geometryBonds = pdb.geometryBonds;
            const json = pdb.json;

            console.log( 'This molecule has ' + json.atoms.length + ' atoms' );

         },
         // called when loading is in progresses
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );


   **Examples**

   [example:webgl_loader_pdb]

   .. Constructor

🐣:PDBLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``PDBLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.pdb`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after loading is
   successfully completed. The function receives the object having the following
   properties. `geometryAtoms <#BufferGeometry>`__, `geometryBonds <#BufferGeometry>`__ and
   the `JSON <#Object>`__ structure.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and call onLoad with the parsed response content.

📦:parse( String text ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `text <#String>`__ — The textual ``pdb`` structure to parse.

   Parse a ``pdb`` text and return a ``JSON`` structure.



.. _D267:

Loader → SVGLoader
==================

   https://threejs.org/docs/examples/en/loaders/SVGLoader.html

   A loader for loading a ``.svg`` resource.
   `Scalable Vector Graphics <https://en.wikipedia.org/wiki/Scalable_Vector_Graphics>`__
   is an XML-based vector image format for two-dimensional graphics with support for
   interactivity and animation.

   **Import**

   ``PDBLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';


   **Code Example**


   .. code:: javascript

      // instantiate a loader
      const loader = new SVGLoader();

      // load a SVG resource
      loader.load(
         // resource URL
         'data/svgSample.svg',
         // called when the resource is loaded
         function ( data ) {

            const paths = data.paths;
            const group = new THREE.Group();

            for ( let i = 0; i < paths.length; i ++ ) {

               const path = paths[ i ];

               const material = new THREE.MeshBasicMaterial( {
                  color: path.color,
                  side: THREE.DoubleSide,
                  depthWrite: false
               } );

               const shapes = SVGLoader.createShapes( path );

               for ( let j = 0; j < shapes.length; j ++ ) {

                  const shape = shapes[ j ];
                  const geometry = new THREE.ShapeGeometry( shape );
                  const mesh = new THREE.Mesh( geometry, material );
                  group.add( mesh );

               }

            }

            scene.add( group );

         },
         // called when loading is in progresses
         function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

         },
         // called when loading has errors
         function ( error ) {

            console.log( 'An error happened' );

         }
      );


   **Examples**

   [example:webgl_loader_svg]

   .. Constructor

🐣:SVGLoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``SVGLoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.svg`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after loading is
   successfully completed. The function receives an array of ``ShapePath`` as an
   argument.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains `total <#Integer>`__ 
   and `loaded <#Integer>`__ bytes. If the server does not set the Content-Length
   header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and call onLoad with the response content.

Static Methods
--------------

📦:createShapes( ShapePath shape ) Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `shape <#ShapePath>`__ — A ShapePath from the array of ``ShapePath``, given as
   argument in the onLoad function for the load function of ``SVGLoader``.

   Returns one or more ``Shape`` objects created from the [param:ShapePath shape] provided
   as an argument in this function.



.. _D268:

Loader → TGALoader
==================

   https://threejs.org/docs/examples/en/loaders/TGALoader.html

   A loader for loading a ``.tga`` resource.
   `TGA <https://en.wikipedia.org/wiki/Truevision_TGA>`__ is a raster graphics, image file
   format.

   **Import**

   ``SVGLoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { TGALoader } from 'three/addons/loaders/TGALoader.js';


   **Code Example**


   .. code:: javascript

      // instantiate a loader 
      const loader = new TGALoader();

      // load a resource 
      const texture = loader.load( 
         // resource URL 
         'textures/crate_grey8.tga' 
         
         // called when loading is completed 
         function ( texture ) { console.log( 'Texture is loaded' );
         }, 

         // called when the loading is in progresses 
         function ( xhr ) { 
            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
         }, 

         // called when the loading fails 
         function ( error ) { 
            console.log( 'An error happened' );
      } );

      const material = new THREE.MeshPhongMaterial( { 
         color: 0xffffff, 
         map: texture 
      } );


   **Examples**

   [example:webgl_loader_texture_tga]

   .. Constructor

🐣:TGALoader( LoadingManager manager )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `manager <#LoadingManager>`__ — The `loadingManager <#LoadingManager>`__ for the loader to
   use. Default is `THREE.DefaultLoadingManager <#LoadingManager>`__.

   Creates a new ``TGALoader``.

Properties
----------

   See the base ``Loader`` class for common properties.

Methods
-------

   See the base ``Loader`` class for common methods.

📦:load( String url, Function onLoad, Function onProgress, Function onError ) DataTexture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `url <#String>`__ — A string containing the path/URL of the ``.tga`` file.
   `onLoad <#Function>`__ — (optional) A function to be called after loading is
   successfully completed. The function receives loaded ``DataTexture`` as an argument.
   `onProgress <#Function>`__ — (optional) A function to be called while the loading is in
   progress. The argument will be the XMLHttpRequest instance, which contains
   `total <#Integer>`__ and `loaded <#Integer>`__ bytes. If the server does not set the
   Content-Length header; `total <#Integer>`__ will be 0.
   `onError <#Function>`__ — (optional) A function to be called if an error occurs during
   loading. The function receives the error as an argument.

   Begin loading from url and pass the loaded `texture <#DataTexture>`__ to onLoad. The
   `texture <#DataTexture>`__ is also directly returned for immediate use (but may not be
   fully loaded).



.. _D269:

Mesh → Lensflare
================

   https://threejs.org/docs/examples/en/objects/Lensflare.html

   Creates a simulated lens flare that tracks a light. ``TGALoader`` can only be used when setting
   the ``alpha`` context parameter of ``WebGLRenderer`` to ``true``.

   **Import**

   ``TGALoader`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';


   **Code Example**


   .. code:: javascript

      const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );
      const textureLoader = new THREE.TextureLoader();
      const textureFlare0 = textureLoader.load( "textures/lensflare/lensflare0.png" );
      const textureFlare1 = textureLoader.load( "textures/lensflare/lensflare2.png" );
      const textureFlare2 = textureLoader.load( "textures/lensflare/lensflare3.png" );
      const lensflare = new Lensflare();
      lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
      lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
      lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );
      light.add( lensflare );


   **Examples**

   [example:webgl_lensflares WebGL / lensflares]

   .. Constructor

🐣:LensflareElement( Texture texture, Float size, Float distance, Color color )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `texture <#Texture>`__ - THREE.Texture to use for the flare.
   `size <#Float>`__ - (optional) size in pixels
   `distance <#Float>`__ - (optional) (0-1) from light source (0 = at light source)
   `color <#Color>`__ - (optional) the ``Color`` of the lens flare

Properties
----------

   See the base ``Mesh`` class for common properties.



.. _D270:

Mesh → Sky
==========

   https://threejs.org/docs/examples/en/objects/Sky.html

   ``LensflareElement`` creates a ready to go sky environment for your scenes.

   **Import**

   ``LensflareElement`` is an add-on, and therefore must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { Sky } from 'three/addons/objects/Sky.js';


   **Code Example**

   ``const sky = new Sky();``
   ``sky.scale.setScalar( 450000 );``
   ``const phi = MathUtils.degToRad( 90 );``
   ``const theta = MathUtils.degToRad( 180 );``
   ``const sunPosition = new Vector3().setFromSphericalCoords( 1, phi, theta );``
   ``sky.material.uniforms.sunPosition.value = sunPosition;``
   ``scene.add( sky );``

   **Examples**

   [example:webgl_shaders_sky misc / objects / Sky ]

   .. Constructor


🐣:Sky()
~~~~~~~

   Create a new ``Sky`` instance.

Properties
----------

   ``Sky`` instance is a ``Mesh`` with a pre-defined ``ShaderMaterial``, so every
   property described here should be set using ``Uniform``s.

⭕:Number turbidity
~~~~~~~~~~~~~~~~~~~~

   Haziness of the ``Sky``.

⭕:Number rayleigh
~~~~~~~~~~~~~~~~~~~

   For a more detailed explanation see:
   `Rayleigh scattering <https://en.wikipedia.org/wiki/Rayleigh_scattering>`__ .

⭕:Number mieCoefficient
~~~~~~~~~~~~~~~~~~~~~~~~~

   `Mie scattering <https://en.wikipedia.org/wiki/Mie_scattering>`__ amount.

⭕:Number mieDirectionalG
~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Mie scattering <https://en.wikipedia.org/wiki/Mie_scattering>`__ direction.

⭕:Vector3 sunPosition
~~~~~~~~~~~~~~~~~~~~~~~

   The position of the sun.

⭕:Vector3 up
~~~~~~~~~~~~~~

   The sun's elevation from the horizon, in degrees.



.. _D271:

EffectComposer
==============

   https://threejs.org/docs/examples/en/postprocessing/EffectComposer.html

   Used to implement post-processing effects in three.js. The class manages a chain of
   post-processing passes to produce the final visual result. Post-processing passes are
   executed in order of their addition/insertion. The last pass is automatically rendered to
   screen.

   **Import**

   ``Sky`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';


   **Examples**

   [example:webgl_postprocessing postprocessing]
   [example:webgl_postprocessing_advanced postprocessing advanced]
   [example:webgl_postprocessing_backgrounds postprocessing backgrounds]
   [example:webgl_postprocessing_transition postprocessing transition]
   [example:webgl_postprocessing_dof postprocessing depth-of-field]
   [example:webgl_postprocessing_dof2 postprocessing depth-of-field 2]
   [example:webgl_postprocessing_fxaa postprocessing fxaa]
   [example:webgl_postprocessing_glitch postprocessing glitch]
   [example:webgl_postprocessing_godrays postprocessing godrays]
   [example:webgl_postprocessing_gtao postprocessing gtao]
   [example:webgl_postprocessing_masking postprocessing masking]
   [example:webgl_postprocessing_material_ao postprocessing material ao]
   [example:webgl_postprocessing_outline postprocessing outline]
   [example:webgl_postprocessing_pixel postprocessing pixelate]
   [example:webgl_postprocessing_procedural postprocessing procedural]
   [example:webgl_postprocessing_rgb_halftone postprocessing rgb halftone]
   [example:webgl_postprocessing_sao postprocessing sao]
   [example:webgl_postprocessing_smaa postprocessing smaa]
   [example:webgl_postprocessing_sobel postprocessing sobel]
   [example:webgl_postprocessing_ssaa postprocessing ssaa]
   [example:webgl_postprocessing_ssao postprocessing ssao]
   [example:webgl_postprocessing_taa postprocessing taa]
   [example:webgl_postprocessing_unreal_bloom postprocessing unreal bloom]
   [example:webgl_postprocessing_unreal_bloom_selective postprocessing unreal bloom
   selective]

   .. Constructor

🐣:EffectComposer( WebGLRenderer renderer, WebGLRenderTarget renderTarget )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderer <#WebGLRenderer>`__ -- The renderer used to render the scene.
   `renderTarget <#WebGLRenderTarget>`__ -- (optional) A preconfigured render target
   internally used by ``EffectComposer``.

Properties
----------

⭕:Array passes
~~~~~~~~~~~~~~~~

   An array representing the (ordered) chain of post-processing passes.

⭕:WebGLRenderTarget readBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A reference to the internal read buffer. Passes usually read the previous render result
   from this buffer.

⭕:WebGLRenderer renderer
~~~~~~~~~~~~~~~~~~~~~~~~~~

   A reference to the internal renderer.

⭕:Boolean renderToScreen
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whether the final pass is rendered to the screen (default framebuffer) or not.

⭕:WebGLRenderTarget writeBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A reference to the internal write buffer. Passes usually write their result into this
   buffer.

Methods
-------

📦:addPass( Pass pass ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   pass -- The pass to add to the pass chain.
   Adds the given pass to the pass chain.

📦:dispose() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Frees the GPU-related resources allocated by this instance. Call this method whenever this
   instance is no longer used in your app.

📦:insertPass( Pass pass, Integer index ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   pass -- The pass to insert into the pass chain.
   index -- Defines the position in the pass chain where the pass should be inserted.
   Inserts the given pass into the pass chain at the given index.

📦:isLastEnabledPass( Integer passIndex ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   passIndex -- The pass to check.
   Returns true if the pass for the given index is the last enabled pass in the pass chain.
   Used by ``EffectComposer`` to determine when a pass should be rendered to screen.

📦:removePass( Pass pass ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   pass -- The pass to remove from the pass chain.
   Removes the given pass from the pass chain.

📦:render( Float deltaTime ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   deltaTime -- The delta time value.
   Executes all enabled post-processing passes in order to produce the final frame.

📦:reset( WebGLRenderTarget renderTarget ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderTarget <#WebGLRenderTarget>`__ -- (optional) A preconfigured render target
   internally used by ``EffectComposer``..
   Resets the internal state of the ``EffectComposer``.

📦:setPixelRatio( Float pixelRatio ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   pixelRatio -- The device pixel ratio.
   Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring
   output. Thus, the semantic of the method is similar to
   ``WebGLRenderer.setPixelRatio``().

📦:setSize( Integer width, Integer height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   width -- The width of the ``.
   height -- The height of the ``.
   Resizes the internal render buffers and passes to (width, height) with device pixel
   ratio taken into account. Thus, the semantic of the method is similar to
   ``WebGLRenderer.setSize``().

📦:swapBuffers() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Swaps the internal read/write buffers.



.. _D272:

DRACOExporter
=============

   https://threejs.org/docs/examples/en/exporters/DRACOExporter.html

   An exporter to compress geometry with the Draco library.
   `Draco <https://google.github.io/draco/>`__ is an open source library for compressing
   and decompressing 3D meshes and point clouds. Compressed geometry can be significantly
   smaller, at the cost of additional decoding time on the client device.

   Standalone Draco files have a ``.drc`` extension, and contain vertex positions, normals,
   colors, and other attributes. Draco files ``do not`` contain materials, textures,
   animation, or node hierarchies – to use these features, embed Draco geometry inside of a
   glTF file. A normal glTF file can be converted to a Draco-compressed glTF file using
   `glTF-Pipeline <https://github.com/AnalyticalGraphicsInc/gltf-pipeline>`__.

   **Import**

   `` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';


   **Code Example**


   .. code:: javascript

      // Instantiate a exporter 
      const exporter = new DRACOExporter();

      // Parse the input and generate the DRACO encoded output 
      const binaryData = exporter.parse( mesh, options );



   **Examples**

   [example:misc_exporter_draco]

   .. Constructor


🐣:DRACOExporter()
~~~~~~~~~~~~~~~~~

   Creates a new ``DRACOExporter``.

Methods
-------

📦:parse( Mesh object | Points object, Object options ) Int8Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Mesh>`__ | `object <#Points>`__ — Mesh or Points to encode.
   `options <#Options>`__ — Optional export options

   -  decodeSpeed - int. Indicates how to tune the encoder regarding decode speed (0 gives
      better speed but worst quality). Default is 5
   -  encodeSpeed - int. Indicates how to tune the encoder parameters (0 gives better speed
      but worst quality). Default is 5.
   -  encoderMethod - int. Either sequential (very little compression) or Edgebreaker.
      Edgebreaker traverses the triangles of the mesh in a deterministic, spiral-like way
      which provides most of the benefits of this data format. Default is
      DRACOExporter.MESH_EDGEBREAKER_ENCODING.
   -  quantization - Array of int. Indicates the presision of each type of data stored in the
      draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC). Default is [ 16,
      8, 8, 8, 8 ]
   -  exportUvs - bool. Default is true.
   -  exportNormals - bool. Default is true.
   -  exportColor - bool. Default is false.



.. _D273:

EXRExporter
===========

   https://threejs.org/docs/examples/en/exporters/EXRExporter.html

   An exporter for ``EXR``.

   `EXR <https://www.openexr.com/>`__ ( Extended Dynamic Range) is an
   `open format specification <https://github.com/AcademySoftwareFoundation/openexr>`__
   for professional-grade image storage format of the motion picture industry. The purpose
   of format is to accurately and efficiently represent high-dynamic-range scene-linear
   image data and associated metadata. The library is widely used in host application
   software where accuracy is critical, such as photorealistic rendering, texture access,
   image compositing, deep compositing, and DI.

   **Import**

   ``DRACOExporter`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { EXRExporter } from 'three/addons/exporters/EXRExporter.js';


   **Code Example**


   .. code:: javascript

      // Instantiate a exporter 
      const exporter = new EXRExporter();

      // Parse the input render target data and generate the EXR output 
      const EXR = exporter.parse( renderer, renderTarget, options );
      downloadFile( EXR );



   .. Constructor


🐣:EXRExporter()
~~~~~~~~~~~~~~~

   Creates a new ``EXRExporter``.

Methods
-------

📦:parse( WebGLRenderer renderer, WebGLRenderTarget renderTarget, Object options ) null
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderTarget <#Function>`__ — WebGLRenderTarget containing data used for exporting EXR
   image.
   `options <#Options>`__ — Export options.

   -  type - Output datatype for internal EXR data. Available options:

      .. code:: javascript

         THREE.HalfFloatType // default option THREE.FloatType

   -  compression - Internal compression algorithm. Available options:

      .. code:: javascript

         NO_COMPRESSION ZIP_COMPRESSION // default option ZIPS_COMPRESSION


   Generates a .exr output from the input render target.

📦:parse( DataTexture dataTexture, Object options ) null
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `dataTexture <#Function>`__ — DataTexture containing data used for exporting EXR image.
   `options <#Options>`__ — Export options (details above).

   Generates a .exr output from the input data texture.



.. _D274:

GLTFExporter
============

   https://threejs.org/docs/examples/en/exporters/GLTFExporter.html

   An exporter for ``glTF`` 2.0.
   `glTF <https://www.khronos.org/gltf>`__ (GL Transmission Format) is an
   `open format specification <https://github.com/KhronosGroup/glTF/tree/master/specification/2.0>`__ 
   for efficient delivery and loading of 3D content. Assets may be provided
   either in JSON (.gltf) or binary (.glb) format. External files store textures (.jpg,
   .png) and additional binary data (.bin). A glTF asset may deliver one or more scenes,
   including meshes, materials, textures, skins, skeletons, morph targets, animations,
   lights, and/or cameras.

   **Import**

   ``EXRExporter`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';


   Extensions
   ----------

   GLTFExporter supports the following
   `glTF 2.0 extensions <https://github.com/KhronosGroup/glTF/tree/master/extensions/>`__:

   -  KHR_lights_punctual
   -  KHR_materials_clearcoat
   -  KHR_materials_dispersion
   -  KHR_materials_emissive_strength
   -  KHR_materials_ior
   -  KHR_materials_iridescence
   -  KHR_materials_specular
   -  KHR_materials_sheen
   -  KHR_materials_transmission
   -  KHR_materials_unlit
   -  KHR_materials_volume
   -  KHR_mesh_quantization
   -  KHR_texture_transform

   The following glTF 2.0 extension is supported by an external user plugin

   -  `KHR_materials_variants <https://github.com/takahirox/three-gltf-extensions>`__

   **Code Example**


   .. code:: javascript

      // Instantiate a exporter 
      const exporter = new GLTFExporter();

      // Parse the input and generate the glTF output 
      exporter.parse( scene, 
         // called when the gltf has been generated 
         function ( gltf ) { console.log( gltf );
            downloadJSON( gltf );
         },
         // called when there is an error in the generation 
         function ( error ) { 
            console.log( 'An error happened' );
      }, options );


   **Examples**

   [example:misc_exporter_gltf]

   .. Constructor


🐣:GLTFExporter()
~~~~~~~~~~~~~~~~

   Creates a new ``GLTFExporter``.

Methods
-------

📦:parse( Object3D input, Function onCompleted, Function onError, Object options ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `input <#Object>`__ — Scenes or objects to export. Valid options:

   -  Export scenes

      .. code:: javascript

         exporter.parse( scene1, ... ) exporter.parse( [ scene1, scene2 ], ... )

   -  Export objects (It will create a new Scene to hold all the objects)

      .. code:: javascript

         exporter.parse( object1, ... ) exporter.parse( [ object1, object2 ], ... )

   -  Mix scenes and objects (It will export the scenes as usual but it will create a new
      scene to hold all the single objects).

      .. code:: javascript

         exporter.parse( [ scene1, object1, object2, scene2 ], ... )


   `onCompleted <#Function>`__ — Will be called when the export completes. The argument
   will be the generated glTF JSON or binary ArrayBuffer.
   `onError <#Function>`__ — Will be called if there are any errors during the gltf
   generation.
   `options <#Options>`__ — Export options

   -  ``trs`` - bool. Export position, rotation and scale instead of matrix per node. Default
      is false
   -  ``onlyVisible`` - bool. Export only visible objects. Default is true.
   -  ``binary`` - bool. Export in binary (.glb) format, returning an ArrayBuffer. Default is
      false.
   -  ``maxTextureSize`` - int. Restricts the image maximum size (both width and height) to
      the given value. Default is Infinity.
   -  ``animations`` - Array<`AnimationClip <#AnimationClip>`__>. List of animations to be
      included in the export.
   -  ``includeCustomExtensions`` - bool. Export custom glTF extensions defined on an
      object's ``userData.gltfExtensions`` property. Default is false.

   Generates a .gltf (JSON) or .glb (binary) output from the input (Scenes or Objects)

📦:parseAsync( Object3D input, Object options ) Promise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Generates a .gltf (JSON) or .glb (binary) output from the input (Scenes or Objects).

   This is just like the ``.parse``() method, but instead of accepting callbacks it
   returns a promise that resolves with the result, and otherwise accepts the same options.



.. _D275:

OBJExporter
===========

   https://threejs.org/docs/examples/en/exporters/OBJExporter.html

   An exporter for the `OBJ <https://en.wikipedia.org/wiki/Wavefront_.obj_file>`__ file
   format.
   ``GLTFExporter`` is not able to export material data into MTL files so only geometry data are
   supported.

   **Import**

   ``GLTFExporter`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';


   **Code Example**


   .. code:: javascript

      // Instantiate an exporter 
      const exporter = new OBJExporter();

      // Parse the input and generate the OBJ output 
      const data = exporter.parse( scene );
      downloadFile( data );


   .. Constructor


🐣:OBJExporter()
~~~~~~~~~~~~~~~

   Creates a new ``OBJExporter``.

Methods
-------

📦:parse( Object3D object ) String
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object>`__ — Object3D to be exported.

   Generates a string holding the OBJ data.



.. _D276:

PLYExporter
===========

   https://threejs.org/docs/examples/en/exporters/PLYExporter.html

   An exporter for ``PLY``.
   `PLY <https://en.wikipedia.org/wiki/PLY_(file_format)>`__ (Polygon or Stanford
   Triangle Format) is a file format for efficient delivery and loading of simple, static
   3D content in a dense format. Both binary and ascii formats are supported. PLY can store
   vertex positions, colors, normals and uv coordinates. No textures or texture references
   are saved.

   **Import**

   ``OBJExporter`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';


   **Code Example**


   .. code:: javascript

      // Instantiate an exporter 
      const exporter = new PLYExporter();

      // Parse the input and generate the ply output 
      const data = exporter.parse( scene, options );
      downloadFile( data );


   .. Constructor


🐣:PLYExporter()
~~~~~~~~~~~~~~~

   Creates a new ``PLYExporter``.

Methods
-------

📦:parse( Object3D input, Function onDone, Object options ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `input <#Object>`__ — Object3D
   `onCompleted <#Function>`__ — Will be called when the export completes. The argument
   will be the generated ply ascii or binary ArrayBuffer.
   `options <#Options>`__ — Export options

   -  excludeAttributes - array. Which properties to explicitly exclude from the exported PLY
      file. Valid values are 'color', 'normal', 'uv', and 'index'. If triangle indices are
      excluded, then a point cloud is exported. Default is an empty array.
   -  binary - bool. Export in binary format, returning an ArrayBuffer. Default is false.

   Generates ply file data as string or ArrayBuffer (ascii or binary) output from the input
   object. The data that is returned is the same that is passed into the "onCompleted"
   function. If the object is composed of multiple children and geometry, they are merged
   into a single mesh in the file.



.. _D277:

STLExporter
===========

   https://threejs.org/docs/examples/en/exporters/STLExporter.html

   An exporter for the STL file format.
   `STL <https://en.wikipedia.org/wiki/STL_(file_format)>`__ files describe only the
   surface geometry of a three-dimensional object without any representation of color,
   texture or other common model attributes. The STL format specifies both ASCII and binary
   representations, with binary being more compact. STL files contain no scale information
   or indexes, and the units are arbitrary.

   **Import**

   ``PLYExporter`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { STLExporter } from 'three/addons/exporters/STLExporter.js';


   **Code Example**


   .. code:: javascript

      // Instantiate an exporter 
      const exporter = new STLExporter();

      // Configure export options 
      const options = { binary: true } 

      // Parse the input and generate the STL encoded output 
      const result = exporter.parse( mesh, options );


   **Examples**

   [example:misc_exporter_stl]

   .. Constructor


🐣:STLExporter()
~~~~~~~~~~~~~~~

   Creates a new ``STLExporter``.

Methods
-------

📦:parse( Object3D scene, Object options ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `scene <#Object3D>`__ — Scene, Mesh, or other Object3D based class containing Meshes to
   encode.
   `options <#Options>`__ — Optional export options

   -  binary - bool. Return an ASCII encoded string or binary data buffer. Default is
      ``false``.



.. _D278:

LookupTable
===========

   https://threejs.org/docs/examples/en/math/Lut.html

   Represents a lookup table for colormaps. It is used to determine the color values from a
   range of data values.

   **Import**

   ``STLExporter`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { Lut } from 'three/addons/math/Lut.js';


   **Code Example**


   .. code:: javascript

      const lut = new Lut( 'rainbow', 512 );
      const color = lut.getColor( 0.5 );


   .. Constructor

🐣:Lut( String colormap, Number count )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   colormap - Sets a colormap from predefined colormaps. Available colormaps are:
   ``rainbow``, ``cooltowarm``, ``blackbody``, ``grayscale``. Default is ``rainbow``.
   count - Sets the number of colors used to represent the data array. Default is ``32``.

Properties
----------

⭕:Array lut
~~~~~~~~~~~~~

   The lookup table for the selected color map represented as an array of ``Color``s.

⭕:Array map
~~~~~~~~~~~~~

   The currently selected color map. Default is the ``rainbow`` color map.

⭕:Number minV
~~~~~~~~~~~~~~~

   The minimum value to be represented with the lookup table. Default is ``0``.

⭕:Number maxV
~~~~~~~~~~~~~~~

   The maximum value to be represented with the lookup table. Default is ``1``.

⭕:Number n
~~~~~~~~~~~~

   The number of colors of the current selected color map. Default is ``32``.

Methods
-------

📦:copy( Lut lut ) Lut this this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   color — Lut to copy.

   Copies the given lut.

📦:addColorMap( String name, Array arrayOfColors ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   name — The name of the color map.
   arrayOfColors — An array of color values. Each value is an array holding a threshold and
   the actual color value as a hexadecimal number.

   Adds a color map to this ``Lut`` instance.

📦:createCanvas() HTMLCanvasElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creates a canvas in order to visualize the lookup table as a texture.

📦:getColor( Number alpha ) Color
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   value -- the data value to be displayed as a color.

   Returns an instance of ``Color`` for the given data value.

📦:setColorMap( String colormap, Number count ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   colormap — The name of the color map.
   count — The number of colors. Default is ``32``.

   Configure the lookup table for the given color map and number of colors.

📦:setMin( Number minV ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   minV — The minimum value to be represented with the lookup table

   Sets this Lut with the minimum value to be represented.

📦:setMax( Number maxV ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   maxV — The maximum value to be represented with the lookup table.

   Sets this Lut with the maximum value to be represented.

📦:updateCanvas( HTMLCanvasElement canvas ) HTMLCanvasElement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Updates the canvas with the ``Lut``'s data.



.. _D279:

MeshSurfaceSampler
==================

   https://threejs.org/docs/examples/en/math/MeshSurfaceSampler.html

   Utility class for sampling weighted random points on the surface of a mesh.

   Weighted sampling is useful for effects like heavier foliage growth in certain areas of
   terrain, or concentrated particle emissions from specific parts of a mesh. Vertex weights
   may be written programmatically, or painted by hand as vertex colors in 3D tools like
   Blender.

   **Import**

   ``Lut`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';


   **Code Example**


   .. code:: javascript

      // Create a sampler for a Mesh surface. 
      const sampler = new MeshSurfaceSampler( surfaceMesh ) 
         .setWeightAttribute( 'color' ) 
         .build();
      const mesh = new THREE.InstancedMesh( sampleGeometry, sampleMaterial, 100 );
      const position = new THREE.Vector3();
      const matrix = new THREE.Matrix4();
      // Sample randomly from the surface, creating an instance of the sample 
      // geometry at each sample point. 
      for ( let i = 0; i < 100; i ++ ) { 
         sampler.sample( position );
         matrix.makeTranslation( position.x, position.y, position.z );
         mesh.setMatrixAt( i, matrix );
      } 
      scene.add( mesh );


   **Examples**

   [example:webgl_instancing_scatter]

   .. Constructor

🐣:MeshSurfaceSampler( Mesh mesh )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `mesh <#Mesh>`__ — Surface mesh from which to sample.

   Creates a new ``MeshSurfaceSampler``. If the input geometry is indexed, a non-indexed 
   copy is made. After construction, the sampler is not able to return samples until
   `build <#MeshSurfaceSampler.build>`__ is called.

Methods
-------

📦:setWeightAttribute( String name ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Specifies a vertex attribute to be used as a weight when sampling from the surface. Faces
   with higher weights are more likely to be sampled, and those with weights of zero will not
   be sampled at all. For vector attributes, only *.x* is used in sampling.

   If no weight attribute is selected, sampling is randomly distributed by area.

📦:build() this
~~~~~~~~~~~~~~~~

   Processes the input geometry and prepares to return samples. Any configuration of the
   geometry or sampler must occur before this method is called. Time complexity is *O(n)* for
   a surface with *n* faces.

📦:sample( Vector3 targetPosition, Vector3 targetNormal, Color targetColor, Vector2 targetUV ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Selects a random point on the surface of the input geometry, returning the position and
   optionally the normal vector, color and UV Coordinate at that point. Time complexity is
   *O(log n)* for a surface with *n* faces.



.. _D280:

OBB
===

   https://threejs.org/docs/examples/en/math/OBB.html

   Represents an oriented bounding box (OBB) in 3D space.

   **Import**

   ``MeshSurfaceSampler`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { OBB } from 'three/addons/math/OBB.js';


   **Examples**

   [example:webgl_math_obb]

   .. Constructor

🐣:OBB( Vector3 center, Vector3 halfSize, Matrix3 rotation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector3>`__ — The center of the ``OBB``. (optional)
   `halfSize <#Vector3>`__ — Positive halfwidth extents of the ``OBB`` along each axis.
   (optional)
   `rotation <#Matrix3>`__ — The rotation of the ``OBB``. (optional)

   Creates a new ``OBB``.

Properties
----------

⭕:Vector3 center
~~~~~~~~~~~~~~~~~~

   The center of the ``OBB``. Default is ``( 0, 0, 0 )``.

⭕:Vector3 halfSize
~~~~~~~~~~~~~~~~~~~~

   Positive halfwidth extents of the ``OBB`` along each axis. Default is ``( 0, 0, 0 )``.

⭕:Matrix3 rotation
~~~~~~~~~~~~~~~~~~~~

   The rotation of the ``OBB``. Default is the identity matrix.

Methods
-------

📦:applyMatrix4( Matrix4 matrix ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `matrix <#Matrix4>`__ — A 4x4 transformation matrix.

   Applies the given transformation matrix to this ``OBB``. This method can be used to
   transform the bounding volume with the world matrix of a 3D object in order to keep both
   entities in sync.

📦:clampPoint( Vector3 point, Vector3 clampedPoint ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ — The point that should be clamped within the bounds of this
   ``OBB``.
   `clampedPoint <#Matrix3>`__ — The result will be copied into this vector.

   Clamps the given point within the bounds of this ``OBB``.

📦:clone() OBB
~~~~~~~~~~~~~~~

   Creates a cloned ``OBB`` for this instance.

📦:containsPoint( Vector3 point ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ — The point to test.

   Whether the given point lies within this ``OBB`` or not.

📦:copy( OBB obb ) this
~~~~~~~~~~~~~~~~~~~~~~~~

   `obb <#OBB>`__ — The ``OBB`` to copy.

   Copies the properties of the given ``OBB`` to this ``OBB``.

📦:equals( OBB obb ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `obb <#OBB>`__ — The ``OBB`` to test.

   Whether the given ``OBB`` is equal to this ``OBB`` or not.

📦:fromBox3( Box3 box3 ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box3 <#Box3>`__ — An AABB.

   Defines an ``OBB`` based on the given AABB.

📦:getSize( Vector3 size ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `size <#Vector3>`__ — The result will be copied into this vector.

   Returns the size of this ``OBB`` into the given vector.

📦:intersectsBox3( Box3 box3 ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `box3 <#Box3>`__ — The AABB to test.

   Whether the given AABB intersects this ``OBB`` or not.

📦:intersectsSphere( Sphere sphere ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `sphere <#Sphere>`__ — The bounding sphere to test.

   Whether the given bounding sphere intersects this ``OBB`` or not.

📦:intersectsOBB( OBB obb, Number epsilon ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `obb <#OBB>`__ — The OBB to test.
   `epsilon <#Number>`__ — An optional numeric value to counteract arithmetic errors.
   Default is ``Number.EPSILON``.

   Whether the given ``OBB`` intersects this ``OBB`` or not.

📦:intersectsPlane( Plane plane ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `plane <#Plane>`__ — The plane to test.

   Whether the given plane intersects this ``OBB`` or not.

📦:intersectsRay( Ray ray ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `ray <#Ray>`__ — The ray to test.

   Whether the given ray intersects this ``OBB`` or not.

📦:intersectRay( Ray ray, Vector3 intersectionPoint ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `ray <#Ray>`__ — The ray to test.
   `intersectionPoint <#Vector3>`__ — The result will be copied into this vector.

   Performs a Ray/OBB intersection test and stores the intersection point to the given 3D
   vector. If no intersection is detected, ``null`` is returned.

📦:set( Vector3 center, Vector3 halfSize, Matrix3 rotation ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `center <#Vector3>`__ — The center of the ``OBB``.
   `halfSize <#Vector3>`__ — Positive halfwidth extents of the ``OBB`` along each axis.
   `rotation <#Matrix3>`__ — The rotation of the ``OBB``.

   Defines the ``OBB`` for the given values.



.. _D281:

Timer
=====

   https://threejs.org/docs/examples/en/misc/Timer.html

   This class is an alternative to ``Clock`` with a different API design and behavior. The
   goal is to avoid the conceptual flaws that became apparent in ``Clock`` over time.

   -  ``OBB`` has an ``.update``() method that updates its internal state. That makes it
      possible to call ``.getDelta``() and ``.getElapsed``() multiple times per
      simulation step without getting different values.
   -  The class uses the Page Visibility API to avoid large time delta values when the app is
      inactive (e.g. tab switched or browser hidden).

   **Import**

   ``OBB`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { Timer } from 'three/addons/misc/Timer.js';


   **Code Example**


   .. code:: javascript

      const timer = new Timer();
      function animate( timestamp ) { 
         requestAnimationFrame( animate );
         // timestamp is optional 
         timer.update( timestamp );
         const delta = timer.getDelta();
         // do something with delta 
         renderer.render( scene, camera );
      }


   **Examples**

   [example:webgl_morphtargets_sphere WebGL / morphtargets / sphere]

   .. Constructor

🐣:Timer()
~~~~~~~~~

Methods
-------

📦:getDelta() Number
~~~~~~~~~~~~~~~~~~~~~

   Returns the time delta in seconds.

📦:getElapsed() Number
~~~~~~~~~~~~~~~~~~~~~~~

   Returns the elapsed time in seconds.

📦:setTimescale( Number timescale ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets a time scale that scales the time delta in ``.update``().

📦:reset() this
~~~~~~~~~~~~~~~~

   Resets the time computation for the current simulation step.

📦:dispose() this
~~~~~~~~~~~~~~~~~~

   Can be used to free all internal resources. Usually called when the timer instance isn't
   required anymore.

📦:update( Number timestamp ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   timestamp -- (optional) The current time in milliseconds. Can be obtained from the
   `requestAnimationFrame <https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame>`__ 
   callback argument. If not provided, the current time will be
   determined with `performance.now <https://developer.mozilla.org/en-US/docs/Web/API/Performance/now>`__.
   Updates the internal state of the timer. This method should be called once per
   simulation step and before you perform queries against the timer (e.g. via
   ``.getDelta``()).



.. _D282:

EdgeSplit
=========

   https://threejs.org/docs/examples/en/modifiers/EdgeSplitModifier.html

   ``Timer`` is intended to modify the geometry "dissolving" the edges to give a smoother look.

   **Import**

   ``Timer`` is an add-on, and therefore must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   **Code Example**

   .. code:: javascript

      import { EdgeSplitModifier } from 'three/addons/modifiers/EdgeSplitModifier.js';

      const geometry = new THREE.IcosahedronGeometry( 10, 3 );
      const modifier = new EdgeSplitModifier();
      const cutOffAngle = 0.5;
      const tryKeepNormals = false;
      modifier.modify( geometry, cutOffAngle, tryKeepNormals );


   **Examples**

   [example:webgl_modifier_edgesplit misc / modifiers / EdgeSplit ]

   .. Constructor


🐣:EdgeSplitModifier()
~~~~~~~~~~~~~~~~~~~~~

   Create a new ``EdgeSplitModifier`` object.

Methods
-------

📦:modify( geometry, cutOffAngle, tryKeepNormals ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Using interpolated vertex normals, the mesh faces will blur at the edges and appear
   smooth.
   You can control the smoothness by setting the ``cutOffAngle``.
   To try to keep the original normals, set ``tryKeepNormals`` to ``true``.



.. _D283:

Face
====

   https://threejs.org/docs/examples/en/math/convexhull/Face.html

   Represents a section bounded by a specific amount of half-edges. The current
   implementation assumes that a face always consist of three edges.

   **Import**

   ``EdgeSplitModifier`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { Face } from 'three/addons/math/ConvexHull.js';


   .. Constructor


🐣:Face()
~~~~~~~~

   Creates a new instance of ``Face``.

Properties
----------

⭕:Vector3 normal
~~~~~~~~~~~~~~~~~~

   The normal vector of the face. Default is a ``Vector3`` at (0, 0, 0).

⭕:Vector3 midpoint
~~~~~~~~~~~~~~~~~~~~

   The midpoint or centroid of the face. Default is a ``Vector3`` at (0, 0, 0).

⭕:Float area
~~~~~~~~~~~~~~

   The area of the face. Default is 0.

⭕:Float constant
~~~~~~~~~~~~~~~~~~

   Signed distance from face to the origin. Default is 0.

⭕:VertexNode outside
~~~~~~~~~~~~~~~~~~~~~~

   Reference to a vertex in a vertex list this face can see. Default is null.

⭕:Integer mark
~~~~~~~~~~~~~~~~

   Marks if a face is visible or deleted. Default is 'Visible'.

⭕:HalfEdge edge
~~~~~~~~~~~~~~~~~

   Reference to the base edge of a face. To retrieve all edges, you can use the 'next'
   reference of the current edge. Default is null.

Methods
-------

📦:create( VertexNode a, VertexNode b, VertexNode c ) Face
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `a <#VertexNode>`__ - First vertex of the face.
   `b <#VertexNode>`__ - Second vertex of the face.
   `c <#VertexNode>`__ - Third vertex of the face.
   Creates a face.

📦:getEdge( Integer i ) HalfEdge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `i <#Integer>`__ - The index of the edge.
   Returns an edge by the given index.

📦:compute () this
~~~~~~~~~~~~~~~~~~~

   Computes all properties of the face.

📦:distanceToPoint( Vector3 point ) Float
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - Any point in 3D space.
   Returns the signed distance from a given point to the plane representation of this face.



.. _D284:

HalfEdge
========

   https://threejs.org/docs/examples/en/math/convexhull/HalfEdge.html

   The basis for a half-edge data structure, also known as doubly connected edge list (DCEL).

   **Import**

   ``Face`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { HalfEdge } from 'three/addons/math/ConvexHull.js';


   .. Constructor

🐣:HalfEdge( VertexNode vertex, Face face )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vertex <#VertexNode>`__ - ``VertexNode`` A reference to its destination vertex.
   `face <#Face>`__ - ``Face`` A reference to its face.
   Creates a new instance of ``HalfEdge``.

Properties
----------

⭕:VertexNode vertex
~~~~~~~~~~~~~~~~~~~~~

   Reference to the destination vertex. The origin vertex can be obtained by querying the
   destination of its twin, or of the previous half-edge. Default is undefined.

⭕:HalfEdge prev
~~~~~~~~~~~~~~~~~

   Reference to the previous half-edge of the same face. Default is null.

⭕:HalfEdge next
~~~~~~~~~~~~~~~~~

   Reference to the next half-edge of the same face. Default is null.

⭕:HalfEdge twin
~~~~~~~~~~~~~~~~~

   Reference to the twin half-edge to reach the opposite face. Default is null.

⭕:Face face
~~~~~~~~~~~~~

   Each half-edge bounds a single face and thus has a reference to that face. Default is
   undefined.

Methods
-------

📦:head() VertexNode
~~~~~~~~~~~~~~~~~~~~~

   Returns the destination vertex.

📦:tail() VertexNode
~~~~~~~~~~~~~~~~~~~~~

   Returns the origin vertex.

📦:length() Float
~~~~~~~~~~~~~~~~~~

   Returns the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__
   (straight-line length) of the edge.

📦:lengthSquared() Float
~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns the square of the `Euclidean length <https://en.wikipedia.org/wiki/Euclidean_distance>`__ 
   (straight-line length) of the edge.

📦:setTwin( HalfEdge edge ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `edge <#HalfEdge>`__ - Any half-edge.
   Sets the twin edge of this half-edge. It also ensures that the twin reference of the
   given half-edge is correctly set.



.. _D285:

ConvexHull
==========

   https://threejs.org/docs/examples/en/math/convexhull/ConvexHull.html

   A convex hull class. Implements the Quickhull algorithm by: Dirk Gregorius. March 2014,
   Game Developers Conference:
   `Implementing QuickHull <http://media.steampowered.com/apps/valve/2014/DirkGregorius_ImplementingQuickHull.pdf>`__.

   **Import**

   ``HalfEdge`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { ConvexHull } from 'three/addons/math/ConvexHull.js';


   .. Constructor


🐣:ConvexHull()
~~~~~~~~~~~~~~

   Creates a new instance of ``ConvexHull``.

Properties
----------

⭕:VertexList assigned
~~~~~~~~~~~~~~~~~~~~~~~

   This `vertex list <#VertexList>`__ holds all vertices that are assigned to a face.
   Default is an empty vertex list.

⭕:Array faces
~~~~~~~~~~~~~~~

   The generated faces of the convex hull. Default is an empty array.

⭕:Array newFaces
~~~~~~~~~~~~~~~~~~

   This array holds the faces that are generated within a single iteration. Default is an
   empty array.

⭕:Float tolerance
~~~~~~~~~~~~~~~~~~~

   The epsilon value that is used for internal comparative operations. The calculation of
   this value depends on the size of the geometry. Default is -1.

⭕:VertexList unassigned
~~~~~~~~~~~~~~~~~~~~~~~~~

   This `vertex list <#VertexList>`__ holds all vertices that are not assigned to a face.
   Default is an empty vertex list.

⭕:Array vertices
~~~~~~~~~~~~~~~~~~

   The internal representation of the given geometry data (an array of `vertices <#VertexNode>`__).

Methods
-------

📦:addAdjoiningFace( VertexNode eyeVertex, HalfEdge horizonEdge ) HalfEdge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `eyeVertex <#VertexNode>`__ - The vertex that is added to the hull.
   `horizonEdge <#HalfEdge>`__ - A single edge of the horizon.
   Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and
   'horizonEdge.head' in CCW order. All the half edges are created in CCW order thus the
   face is always pointing outside the hull

📦:addNewFaces( VertexNode eyeVertex, HalfEdge horizonEdge ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `eyeVertex <#VertexNode>`__ - The vertex that is added to the hull.
   `horizon <#HalfEdge>`__ - An array of half-edges that form the horizon.
   Adds 'horizon.length' faces to the hull, each face will be linked with the horizon
   opposite face and the face on the left/right.

📦:addVertexToFace( VertexNode vertex, Face face ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vertex <#VertexNodeNode>`__ - The vertex to add.
   `face <#Face>`__ - The target face.
   Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.

📦:addVertexToHull( VertexNode eyeVertex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `eyeVertex <#VertexNode>`__ - The vertex that is added to the hull.
   Adds a vertex to the hull with the following algorithm

   -  Compute the 'horizon' which is a chain of half edges. For an edge to belong to this
      group it must be the edge connecting a face that can see 'eyeVertex' and a face which
      cannot see 'eyeVertex'.
   -  All the faces that can see 'eyeVertex' have its visible vertices removed from the
      assigned vertex list.
   -  A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each
      face is connected with the opposite horizon face and the face on the left/right.
   -  The vertices removed from all the visible faces are assigned to the new faces if
      possible.

📦:cleanup() this
~~~~~~~~~~~~~~~~~~

   Cleans up internal properties after computing the convex hull.

📦:compute() this
~~~~~~~~~~~~~~~~~~

   Starts the execution of the quick hull algorithm.

📦:computeExtremes() Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the extremes values (min/max vectors) which will be used to compute the initial
   hull.

📦:computeHorizon( Vector3 eyePoint, HalfEdge crossEdge, Face face, Array horizon ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `eyePoint <#Vector3>`__ - The 3D-coordinates of a point.
   `crossEdge <#HalfEdge>`__ - The edge used to jump to the current face.
   `face <#Face>`__ - The current face being tested.
   `horizon <#Array>`__ - The edges that form part of the horizon in CCW order.
   Computes a chain of half edges in CCW order called the 'horizon'. For an edge to be part
   of the horizon it must join a face that can see 'eyePoint' and a face that cannot see
   'eyePoint'.

📦:computeInitialHull() this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computes the initial simplex assigning to its faces all the points that are candidates to
   form part of the hull.

📦:containsPoint( Vector3 point ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - A point in 3D space.
   Returns ``true`` if the given point is inside this convex hull.

📦:deleteFaceVertices( Face face, Face absorbingFace ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `face <#Face>`__ - The given face.
   `absorbingFace <#Face>`__ - An optional face that tries to absorb the vertices of the
   first face.
   Removes all the visible vertices that 'face' is able to see.

   -  If 'absorbingFace' doesn't exist, then all the removed vertices will be added to the
      'unassigned' vertex list.
   -  If 'absorbingFace' exists, then this method will assign all the vertices of 'face' that
      can see 'absorbingFace'.
   -  If a vertex cannot see 'absorbingFace', it's added to the 'unassigned' vertex list.

📦:intersectRay( Ray ray, Vector3 target ) Vector3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `ray <#Ray>`__ - The given ray.
   `target <#Vector3>`__ - The target vector representing the intersection point.
   Performs a ray intersection test with this convext hull. If no intersection is found,
   ``null`` is returned.

📦:intersectsRay( Ray ray ) Boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `ray <#Ray>`__ - The given ray.
   Returns ``true`` if the given ray intersects with this convex hull.

📦:makeEmpty() this
~~~~~~~~~~~~~~~~~~~~

   Makes this convex hull empty.

📦:nextVertexToAdd() VertexNode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Finds the next vertex to create faces with the current hull.

   -  Let the initial face be the first face existing in the 'assigned' vertex list.
   -  If a face doesn't exist then return since there're no vertices left.
   -  Otherwise for each vertex that face sees find the one furthest away from it.

📦:reindexFaces() this
~~~~~~~~~~~~~~~~~~~~~~~

   Removes inactive (e.g. deleted) faces from the internal face list.

📦:removeAllVerticesFromFace( Face face ) VertexNode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `face <#Face>`__ - The given face.
   Removes all the visible vertices that a given face is able to see which are stored in
   the 'assigned' vertex list.

📦:removeVertexFromFace( VertexNode vertex, Face face ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vertex <#VertexNode>`__ - The vertex to remove.
   `face <#Face>`__ - The target face.
   Removes a vertex from the 'assigned' list of vertices and from the given face. It also
   makes sure that the link from 'face' to the first vertex it sees in 'assigned' is linked
   correctly after the removal.

📦:resolveUnassignedPoints( Array newFaces ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `newFaces <#Face>`__ - An array of new faces.
   Reassigns as many vertices as possible from the unassigned list to the new faces.

📦:setFromObject( Object3D object ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `object <#Object3D>`__ - ``Object3D`` to compute the convex hull of.
   Computes the convex hull of an ``Object3D`` (including its children),accounting for
   the world transforms of both the object and its childrens.

📦:setFromPoints( Array points ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `points <#Array>`__ - Array of `Vector3s <#Vector3>`__ that the resulting convex hull
   will contain.
   Computes to convex hull for the given array of points.



.. _D286:

VertexNode
==========

   https://threejs.org/docs/examples/en/math/convexhull/VertexNode.html

   A vertex as a double linked list node.

   **Import**

   ``ConvexHull`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { VertexNode } from 'three/addons/math/ConvexHull.js';


   .. Constructor

🐣:VertexNode( Vector3 point )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `point <#Vector3>`__ - ``Vector3`` A point (x, y, z) in 3D space.
   Creates a new instance of ``VertexNode``.

Properties
----------

⭕:Vector3 point
~~~~~~~~~~~~~~~~~

   A point (x, y, z) in 3D space. Default is undefined.

⭕:VertexNode prev
~~~~~~~~~~~~~~~~~~~

   Reference to the previous vertex in the double linked list. Default is null.

⭕:VertexNode next
~~~~~~~~~~~~~~~~~~~

   Reference to the next vertex in the double linked list. Default is null.

⭕:Face face
~~~~~~~~~~~~~

   Reference to the face that is able to see this vertex. Default is undefined.



.. _D287:

VertexList
==========

   https://threejs.org/docs/examples/en/math/convexhull/VertexList.html

   A doubly linked list of vertices.

   **Import**

   ``VertexNode`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { VertexList } from 'three/addons/math/ConvexHull.js';


   .. Constructor


🐣:VertexList()
~~~~~~~~~~~~~~

   Creates a new instance of ``VertexList``.

Properties
----------

⭕:VertexNode head
~~~~~~~~~~~~~~~~~~~

   Reference to the first vertex of the linked list. Default is null.

⭕:VertexNode tail
~~~~~~~~~~~~~~~~~~~

   Reference to the last vertex of the linked list. Default is null.

Methods
-------

📦:first() VertexNode
~~~~~~~~~~~~~~~~~~~~~~

   Returns the head reference.

📦:last() VertexNode
~~~~~~~~~~~~~~~~~~~~~

   Returns the tail reference.

📦:clear() this
~~~~~~~~~~~~~~~~

   Clears the linked list.

📦:insertBefore( Vertex target, Vertex vertex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vertex>`__ - The target vertex. It's assumed that this vertex belongs to the
   linked list.
   `vertex <#Vertex>`__ - The vertex to insert.
   Inserts a vertex **before** a target vertex.

📦:insertAfter( Vertex target, Vertex vertex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `target <#Vertex>`__ - The target vertex. It's assumed that this vertex belongs to the
   linked list.
   `vertex <#Vertex>`__ - The vertex to insert.
   Inserts a vertex **after** a target vertex.

📦:append( Vertex vertex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vertex <#Vertex>`__ - The vertex to append.
   Appends a vertex to the end of the linked list.

📦:appendChain( Vertex vertex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vertex <#Vertex>`__ - The head vertex of a chain of vertices.
   Appends a chain of vertices where the given vertex is the head.

📦:remove( Vertex vertex ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `vertex <#Vertex>`__ - The vertex to remove.
   Removes a vertex from the linked list.

📦:removeSubList( Vertex a, Vertex b ) this
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `a <#Vertex>`__ - The head of the sublist.
   `b <#Vertex>`__ - The tail of the sublist.
   Removes a sublist of vertices from the linked list.

📦:isEmpty() Boolean
~~~~~~~~~~~~~~~~~~~~~

   Returns true if the linked list is empty.



.. _D288:

CSS2DRenderer
=============

   https://threejs.org/docs/examples/en/renderers/CSS2DRenderer.html

   ``VertexList`` is a simplified version of ``CSS3DRenderer``. The only transformation that is
   supported is translation.
   The renderer is very useful if you want to combine HTML based labels with 3D objects.
   Here too, the respective DOM elements are wrapped into an instance of ``CSS2DObject``
   and added to the scene graph.
   ``VertexList`` only supports 100% browser and display zoom.

   **Import**

   ``VertexList`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { CSS2DRenderer } from 'three/addons/renderers/CSS2DRenderer.js';


   **Examples**

   [example:css2d_label]
   [example:webgl_loader_pdb molecules]

   .. Constructor

🐣:CSS2DRenderer( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `element <#DOMElement>`__ - A
   `HTMLElement <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement>`__ where the
   renderer appends its child-elements. This corresponds to the
   `domElement <#CSS2DRenderer.domElement>`__ property below. If not passed in here, a new
   div element will be created.

Properties
----------

⭕:DOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~

   A `HTMLElement <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement>`__ where
   the renderer appends its child-elements.
   This is automatically created by the renderer in the constructor (if not provided
   already).

Methods
-------

📦:getSize() Object
~~~~~~~~~~~~~~~~~~~~

   Returns an object containing the width and height of the renderer.

📦:render( Scene scene, Camera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Renders a `scene <#Scene>`__ using a `camera <#Camera>`__.

📦:setSize(Number width, Number height) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resizes the renderer to (width, height).



.. _D289:

CSS3DRenderer
=============

   https://threejs.org/docs/examples/en/renderers/CSS3DRenderer.html

   ``CSS2DRenderer`` can be used to apply hierarchical 3D transformations to DOM elements via the CSS3
   `transform <https://www.w3schools.com/cssref/css3_pr_transform.asp>`__ property. This
   renderer is particularly interesting if you want to apply 3D effects to a website
   without canvas based rendering. It can also be used in order to combine DOM elements
   with WebGL content.
   There are, however, some important limitations:

   -  It's not possible to use the material system of three.js.
   -  It's also not possible to use geometries.
   -  ``CSS2DRenderer`` only supports 100% browser and display zoom.

   So ``CSS2DRenderer`` is just focused on ordinary DOM elements. These elements are wrapped into
   special objects (``CSS3DObject`` or ``CSS3DSprite``) and then added to the scene graph.

   **Import**

   ``CSS2DRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { CSS3DRenderer } from 'three/addons/renderers/CSS3DRenderer.js';


   **Examples**

   [example:css3d_molecules molecules]
   [example:css3d_orthographic orthographic camera]
   [example:css3d_periodictable periodictable]
   [example:css3d_sprites sprites]

   .. Constructor

🐣:CSS3DRenderer( Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `element <#DOMElement>`__ - A
   `HTMLElement <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement>`__ where the
   renderer appends its child-elements. This corresponds to the
   `domElement <#CSS3DRenderer.domElement>`__ property below. If not passed in here, a new
   div element will be created.

Properties
----------

⭕:DOMElement domElement
~~~~~~~~~~~~~~~~~~~~~~~~~

   A `HTMLElement <https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement>`__ where
   the renderer appends its child-elements.
   This is automatically created by the renderer in the constructor (if not provided
   already).

Methods
-------

📦:getSize() Object
~~~~~~~~~~~~~~~~~~~~

   Returns an object containing the width and height of the renderer.

📦:render( Scene scene, PerspectiveCamera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Renders a `scene <#Scene>`__ using a `perspective camera <#PerspectiveCamera>`__.

📦:setSize(Number width, Number height) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resizes the renderer to (width, height).



.. _D290:

SVGRenderer
===========

   https://threejs.org/docs/examples/en/renderers/SVGRenderer.html

   .. container:: desc

      ``CSS3DRenderer`` can be used to render geometric data using SVG. The produced vector graphics are
      particular useful in the following use cases:

      -  Animated logos or icons
      -  Interactive 2D/3D diagrams or graphs
      -  Interactive maps
      -  Complex or animated user interfaces

      ``CSS3DRenderer`` has various advantages. It produces crystal-clear and sharp output which is
      independent of the actual viewport resolution.
      SVG elements can be styled via CSS. And they have good accessibility since it's
      possible to add metadata like title or description (useful for search engines or
      screen readers).

      There are, however, some important limitations:

      -  No advanced shading
      -  No texture support
      -  No shadow support

   **Import**

   ``CSS3DRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';


   **Examples**

   [example:svg_lines lines]
   [example:svg_sandbox sandbox]

   .. Constructor


🐣:SVGRenderer()
~~~~~~~~~~~~~~~

Properties
----------

⭕:Number overdraw
~~~~~~~~~~~~~~~~~~~

   Number of fractional pixels to enlarge polygons in order to prevent anti-aliasing gaps.
   Range is [0..1]. Default is ``0.5``.

Methods
-------

📦:clear() undefined
~~~~~~~~~~~~~~~~~~~~~

   Tells the renderer to clear its drawing surface.

📦:getSize() Object
~~~~~~~~~~~~~~~~~~~~

   Returns an object containing the width and height of the renderer.

📦:render( Scene scene, Camera camera ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Renders a `scene <#Scene>`__ using a `camera <#Camera>`__.

📦:setClearColor( Color color, number alpha ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the clearColor and the clearAlpha.

📦:setPrecision( Number precision ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the precision of the data used to create a path.

📦:setQuality() undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets the render quality. Possible values are ``low`` and ``high`` (default).

📦:setSize( Number width, Number height ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Resizes the renderer to (width, height).



.. _D291:

BufferGeometryUtils
===================

   https://threejs.org/docs/examples/en/utils/BufferGeometryUtils.html

   A class containing utility functions for `BufferGeometry <#BufferGeometry>`__ instances.

   **Import**

   ``SVGRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';


Methods
-------

📦:computeMikkTSpaceTangents( BufferGeometry geometry, Object MikkTSpace, Boolean negateSign = true ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  geometry -- Instance of ``BufferGeometry``.
   -  MikkTSpace -- Instance of *examples/jsm/libs/mikktspace.module.js*, or *mikktspace* npm
      package. Await *MikkTSpace.ready* before use.
   -  negateSign -- Whether to negate the sign component (.w) of each tangent. Required for
      normal map conventions in some formats, including glTF.

   Computes vertex tangents using the `MikkTSpace <http://www.mikktspace.com/>`__ algorithm.
   MikkTSpace generates the same tangents consistently, and is used in most modelling tools
   and normal map bakers. Use MikkTSpace for materials with normal maps, because inconsistent
   tangents may lead to subtle visual issues in the normal map, particularly around mirrored
   UV seams.

   In comparison to this method, ``BufferGeometry.computeTangents`` (a custom algorithm)
   generates tangents that probably will not match the tangents in other software. The custom
   algorithm is sufficient for general use with a ``ShaderMaterial``, and may be faster
   than MikkTSpace.

   Returns the original ``BufferGeometry``. Indexed geometries will be de-indexed.
   Requires position, normal, and uv attributes.

📦:computeMorphedAttributes( Mesh | Line | Points object ) Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   object -- Instance of `Mesh <#Mesh>`__ \| `Line <#Line>`__ \| `Points <#Points>`__.
   Returns the current attributes (Position and Normal) of a morphed/skinned `Object3D <#Object3D>`__ 
   whose geometry is a `BufferGeometry <#BufferGeometry>`__, together with the
   original ones: An Object with 4 properties: ``positionAttribute``, ``normalAttribute``,
   ``morphedPositionAttribute`` and ``morphedNormalAttribute``. Helpful for Raytracing or
   Decals (i.e. a `DecalGeometry <#DecalGeometry>`__ applied to a morphed Object with a
   `BufferGeometry <#BufferGeometry>`__ will use the original BufferGeometry, not the
   morphed/skinned one, generating an incorrect result. Using this function to create a
   shadow Object3D the DecalGeometry can be correctly generated).

📦:estimateBytesUsed( BufferGeometry geometry ) Number
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry -- Instance of `BufferGeometry <#BufferGeometry>`__ to estimate the memory use
   of.
   Returns the amount of bytes used by all attributes to represent the geometry.

📦:interleaveAttributes( Array attributes ) InterleavedBufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   attributes -- Array of `BufferAttribute <#BufferAttribute>`__ instances.
   Interleaves a set of attributes and returns a new array of corresponding attributes that
   share a single InterleavedBuffer instance. All attributes must have compatible types. If
   merge does not succeed, the method returns null.

📦:mergeAttributes( Array attributes ) BufferAttribute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   attributes -- Array of `BufferAttribute <#BufferAttribute>`__ instances.
   Merges a set of attributes into a single instance. All attributes must have compatible
   properties and types, and `InterleavedBufferAttributes <#InterleavedBufferAttribute>`__
   are not supported. If merge does not succeed, the method returns null.

📦:mergeGeometries( Array geometries, Boolean useGroups ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometries -- Array of `BufferGeometry <#BufferGeometry>`__ instances.
   useGroups -- Whether groups should be generated for the merged geometry or not.
   Merges a set of geometries into a single instance. All geometries must have compatible
   attributes. If merge does not succeed, the method returns null.

📦:mergeGroups( BufferGeometry geometry ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry -- Instance of `BufferGeometry <#BufferGeometry>`__ to merge the groups of.
   Merges the `groups <#BufferGeometry.groups>`__ for the given geometry.

📦:mergeVertices( BufferGeometry geometry, Number tolerance ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry -- Instance of `BufferGeometry <#BufferGeometry>`__ to merge the vertices of.
   tolerance -- The maximum allowable difference between vertex attributes to merge.
   Defaults to 1e-4.
   Returns a new `BufferGeometry <#BufferGeometry>`__ with vertices for which all similar
   vertex attributes (within tolerance) are merged.

📦:toCreasedNormals( BufferGeometry geometry, Number creaseAngle ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  geometry -- The input geometry.
   -  creaseAngle -- The crease angle in radians.

   Modifies the supplied geometry if it is non-indexed, otherwise creates a new, non-indexed
   geometry.

   Returns the geometry with smooth normals everywhere except faces that meet at an angle
   greater than the crease angle.

📦:toTrianglesDrawMode( BufferGeometry geometry, TrianglesDrawMode drawMode ) BufferGeometry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry -- Instance of `BufferGeometry <#BufferGeometry>`__.
   drawMode -- The draw mode of the given geometry. Valid inputs are
   ``THREE.TriangleStripDrawMode`` and ``THREE.TriangleFanDrawMode``.
   Returns a new indexed geometry based on ``THREE.TrianglesDrawMode`` draw mode. This mode
   corresponds to the ``gl.TRIANGLES`` WebGL primitive.



.. _D292:

CameraUtils
===========

   https://threejs.org/docs/examples/en/utils/CameraUtils.html

   A class containing useful utility functions for camera manipulation.

   **Import**

   ``SVGRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import * as CameraUtils from 'three/addons/utils/CameraUtils.js';


Methods
-------

📦:frameCorners( PerspectiveCamera camera, Vector3 bottomLeftCorner, Vector3 bottomRightCorner, Vector3 topLeftCorner, boolean estimateViewFrustum ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Set a PerspectiveCamera's projectionMatrix and quaternion to exactly frame the corners of
   an arbitrary rectangle using `Kooima's Generalized Perspective Projection formulation <https://web.archive.org/web/20191110002841/http://csc.lsu.edu/~kooima/articles/genperspective/index.html>`__. 
   NOTE: This function ignores the standard parameters; do not call 
   ``updateProjectionMatrix()`` after this! toJSON will also not
   capture the off-axis matrix generated by this function.



.. _D293:

SceneUtils
==========

   https://threejs.org/docs/examples/en/utils/SceneUtils.html

   A class containing useful utility functions for scene manipulation.

   **Import**

   ``SVGRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import * as SceneUtils from 'three/addons/utils/SceneUtils.js';


Methods
-------

📦:createMeshesFromInstancedMesh( InstancedMesh instancedMesh ) Group
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   instancedMesh -- The instanced mesh.

   Creates a new group object that contains a new mesh for each instance of the given
   instanced mesh.

📦:createMeshesFromMultiMaterialMesh( Mesh mesh ) Group
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   mesh -- A mesh with multiple materials.

   Converts the given multi-material mesh into an instance of ``Group`` holding for each
   material a separate mesh.

📦:createMultiMaterialObject( BufferGeometry geometry, Array materials ) Group
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   geometry -- The geometry for the set of materials.
   materials -- The materials for the object.

   Creates a new Group that contains a new mesh for each material defined in materials.
   Beware that this is not the same as an array of materials which defines multiple
   materials for 1 mesh.
   This is mostly useful for objects that need both a material and a wireframe
   implementation.

📦:reduceVertices( Object3D object, function func, T initialValue ) T
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   object -- The object to traverse (uses `traverseVisible <#Object3D.traverseVisible>`__
   internally).
   func -- The binary function applied for the reduction. Must have the signature: (value:
   T, vertex: Vector3): T.
   initialValue -- The value to initialize the reduction with. This is required as it also
   sets the reduction type, which is not required to be Vector3.

   Akin to Array.prototype.reduce(), but operating on the vertices of all the visible
   descendant objects, in world space. Additionally, it can operate as a transform-reduce,
   returning a different type T than the Vector3 input. This can be useful for e.g. fitting a
   viewing frustum to the scene.

📦:sortInstancedMesh( InstancedMesh mesh, Function compareFn ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   mesh -- InstancedMesh in which instances will be sorted.
   compareFn -- Comparator function defining the sort order.

   Sorts the instances within an ``InstancedMesh``, according to a user-defined callback.
   The callback will be provided with two arguments, *indexA* and *indexB*, and must return a
   numerical value. See `Array.prototype.sort <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description>`__ 
   for more information on sorting callbacks and their return values.

   Because of the high performance cost, three.js does not sort ``InstancedMesh``
   instances automatically. Manually sorting may be helpful to improve display of alpha
   blended materials (back to front), and to reduce overdraw in opaque materials (front to
   back).

📦:traverseGenerator( Object3D object ) Generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   object -- The 3D object to traverse.

   A generator based version of ``Object3D.traverse``().

📦:traverseVisibleGenerator( Object3D object ) Generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   object -- The 3D object to traverse.

   A generator based version of ``Object3D.traverseVisible``().

📦:traverseAncestorsGenerator( Object3D object ) Generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   object -- The 3D object to traverse.

   A generator based version of ``Object3D.traverseAncestors``().



.. _D294:

SkeletonUtils
=============

   https://threejs.org/docs/examples/en/utils/SkeletonUtils.html

   Utility functions for ``Skeleton``, ``SkinnedMesh``, and ``Bone`` manipulation.

   **Import**

   ``SVGRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';


Methods
-------

📦:clone( Object3D object ) Object3D
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Clones the given object and its descendants, ensuring that any ``SkinnedMesh``
   instances are correctly associated with their bones. Bones are also cloned, and must be
   descendants of the object passed to this method. Other data, like geometries and
   materials, are reused by reference.

📦:retarget( SkeletonHelper target, SkeletonHelper source, Object options ) undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📦:retargetClip( SkeletonHelper target, SkeletonHelper source, AnimationClip clip, Object options ) AnimationClip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. _D295:

Group → XREstimatedLight
========================

   https://threejs.org/docs/examples/en/webxr/XREstimatedLight.html

   XREstimatedLight uses WebXR's light estimation to create a light probe, a directional
   light, and (optionally) an environment map that model the user's real-world environment
   and lighting.

   As WebXR updates the light and environment estimation, XREstimatedLight automatically
   updates the light probe, directional light, and environment map.

   It's important to specify ``light-estimation`` as an optional or required feature when
   creating the WebXR session, otherwise the light estimation can't work.

   See `here <https://developer.mozilla.org/en-US/docs/Web/API/XRLightProbe#browser_compatibility>`__
   for browser compatibility information, as this is still an experimental feature in
   WebXR.

   To use this, as with all files in the /examples directory, you will have to include the
   file separately in your HTML.

   **Import**

   ``SVGRenderer`` is an add-on, and must be imported explicitly. See
   `Installation / Addons <#manual/introduction/Installation>`__.


   .. code:: javascript

      import { XREstimatedLight } from 'three/addons/webxr/XREstimatedLight.js';


   **Code Example**


   .. code:: javascript

      renderer.xr.enabled = true;

      // Don't add the XREstimatedLight to the scene initially.
      // It doesn't have any estimated lighting values until an AR session starts.
      const xrLight = new XREstimatedLight( renderer );

      xrLight.addEventListener( 'estimationstart' , () => {

         scene.add( xrLight );

         if ( xrLight.environment ) {

            scene.environment = xrLight.environment;

         }

      } );

      xrLight.addEventListener( 'estimationend', () => {

         scene.remove( xrLight );

         scene.environment = null;

      } );

      // In order for lighting estimation to work, 'light-estimation' must be included as either
      // an optional or required feature.
      document.body.appendChild( XRButton.createButton( renderer, {
         optionalFeatures: [ 'light-estimation' ]
      } ) );


   **Examples**

   [example:webxr_ar_lighting webxr / light estimation]

   .. Constructor

🐣:XREstimatedLight( WebGLRenderer renderer, Boolean environmentEstimation )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `renderer <#WebGLRenderer>`__: (required) The renderer used to render the Scene. Mainly
   used to interact with WebXRManager.
   environmentEstimation: If ``true``, use WebXR to estimate an environment map.


🚀Events
~~~~~~~~~

   ================ ============================================================
   estimationstart  Fires when the estimated lighting values start being updated.
   estimationend    Fires when the estimated lighting values stop being updated.
   ================ ============================================================



Properties
----------

⭕:Texture environment
~~~~~~~~~~~~~~~~~~~~~~~

   The environment map estimated by WebXR. This is only available if environmentEstimation
   is ``true``.
   It can be used as the ``Scene.environment``, for ``MeshStandardMaterial.envMap``,
   or as the ``Scene.background``.



.. _D296:

WebGLProgram
============

   https://threejs.org/docs/api/en/renderers/webgl/WebGLProgram.html

   Constructor for the GLSL program sent to vertex and fragment shaders, including default
   uniforms and attributes.

   Built-in uniforms and attributes
   --------------------------------

   Vertex shader (unconditional):
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


      .. code:: javascript

         // = object.matrixWorld
         uniform mat4 modelMatrix;

         // = camera.matrixWorldInverse * object.matrixWorld
         uniform mat4 modelViewMatrix;

         // = camera.projectionMatrix
         uniform mat4 projectionMatrix;

         // = camera.matrixWorldInverse
         uniform mat4 viewMatrix;

         // = inverse transpose of modelViewMatrix
         uniform mat3 normalMatrix;

         // = camera position in world space
         uniform vec3 cameraPosition;
         // default vertex attributes provided by BufferGeometry
         attribute vec3 position;
         attribute vec3 normal;
         attribute vec2 uv;


      Note that you can therefore calculate the position of a vertex in the vertex shader by:

      .. code:: javascript

         gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
         

      or alternatively

      .. code:: javascript

         gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );
         

   Vertex shader (conditional):
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~


      .. code:: javascript

         #ifdef USE_TANGENT
            attribute vec4 tangent;
         #endif
         #if defined( USE_COLOR_ALPHA )
            // vertex color attribute with alpha
            attribute vec4 color;
         #elif defined( USE_COLOR )
            // vertex color attribute
            attribute vec3 color;
         #endif
         #ifdef USE_MORPHTARGETS

            attribute vec3 morphTarget0;
            attribute vec3 morphTarget1;
            attribute vec3 morphTarget2;
            attribute vec3 morphTarget3;

            #ifdef USE_MORPHNORMALS

               attribute vec3 morphNormal0;
               attribute vec3 morphNormal1;
               attribute vec3 morphNormal2;
               attribute vec3 morphNormal3;

            #else

               attribute vec3 morphTarget4;
               attribute vec3 morphTarget5;
               attribute vec3 morphTarget6;
               attribute vec3 morphTarget7;

            #endif
         #endif
         #ifdef USE_SKINNING
            attribute vec4 skinIndex;
            attribute vec4 skinWeight;
         #endif
         #ifdef USE_INSTANCING
            // Note that modelViewMatrix is not set when rendering an instanced model,
            // but can be calculated from viewMatrix * modelMatrix.
            //
            // Basic Usage:
            //   gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);
            attribute mat4 instanceMatrix;
         #endif


   Fragment shader:
   ~~~~~~~~~~~~~~~~

      .. code:: javascript

         uniform mat4 viewMatrix;
         uniform vec3 cameraPosition;
         

   .. Constructor

🐣:WebGLProgram( WebGLRenderer renderer, String cacheKey, Object parameters )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   For parameters see `WebGLRenderer <#WebGLRenderer>`__.

Properties
----------

⭕:String name
~~~~~~~~~~~~~~~

   The name of the respective shader program.

⭕:String id
~~~~~~~~~~~~~

   The identifier of this instance.

⭕:String cacheKey
~~~~~~~~~~~~~~~~~~~

   This key enables the reusability of a single ``WebGLProgram`` for different materials.

⭕:Integer usedTimes
~~~~~~~~~~~~~~~~~~~~~

   How many times this instance is used for rendering render items.

⭕:Object program
~~~~~~~~~~~~~~~~~~

   The actual shader program.

⭕:WebGLShader vertexShader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The vertex shader.

⭕:WebGLShader fragmentShader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The fragment shader.

Methods
-------

📦:getUniforms() Object
~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a name-value mapping of all active uniform locations.

📦:getAttributes() Object
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Returns a name-value mapping of all active vertex attribute locations.

📦:destroy() undefined
~~~~~~~~~~~~~~~~~~~~~~~

   Destroys an instance of ``WebGLProgram``.

