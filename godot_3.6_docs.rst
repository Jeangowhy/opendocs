

===================================================
/. /RST docs combine script
===================================================

文档合并脚本中使用了 sed 流式文档处理工具，使用教程参考： 

1. [Sed in 5 Minutes](https://github.com/Jeangowhy/opendocs/blob/main/sed.info) "
2. [AWK in 5 Minutes](https://github.com/Jeangowhy/opendocs/blob/main/sed.info)"

.. code-block:: bash

    #! /usr/bin/env bash
    
    print_title () {
        printf '\n%.0s' {1..2};
        printf '=%.0s' {1..51};
        printf "\n/. $1\n"
        printf '=%.0s' {1..51};
        printf '\n%.0s' {1..2};
    }
    
    print_title "/RST docs combine script"
    cat << EOF
    文档合并脚本中使用了 sed 流式文档处理工具，使用教程参考： 
    
    1. [Sed in 5 Minutes](https://github.com/Jeangowhy/opendocs/blob/main/sed.info) "
    2. [AWK in 5 Minutes](https://github.com/Jeangowhy/opendocs/blob/main/sed.info)"
    
    EOF
    echo '.. code-block:: bash'
    echo ''
    cat $0 | sed -n 's/^/    /p'
    
    function filter {
        local parent=`echo $1 | sed -n 's/[^/\]\+$//p'`
        for it in `sed -n "/^.. toctree::/,$ { s/^ \+[^ :]\+$/\0/p }" $1`
        do
            rst=`echo "$parent$it.rst" | sed -n 's/\.rst\.rst/.rst/; p'`
            echo $rst
            filter $rst
        done
    }
    
    while read -r line
    do 
        print_title "$line"
        cat $line
    done << EOF
    `
    echo ./README.md
    filter ./index.rst
    `
    EOF
    


===================================================
/. ./README.md
===================================================

# Godot Engine documentation

This repository contains the source files of [Godot Engine](https://godotengine.org)'s documentation, in reStructuredText markup language (reST).

They are meant to be parsed with the [Sphinx](https://www.sphinx-doc.org/) documentation builder to build the HTML documentation on [Godot's website](https://docs.godotengine.org).

## Download for offline use

You can [download an HTML copy](https://nightly.link/godotengine/godot-docs/workflows/build_offline_docs/master/godot-docs-html-stable.zip)
for offline reading (updated every Monday). Extract the ZIP archive then open
the top-level `index.html` in a web browser.

## Theming

The Godot documentation uses the default ``sphinx_rtd_theme`` with many
[customizations](_static/) applied on top. It will automatically switch between
the light and dark theme depending on your browser/OS' theming preference.

If you use Firefox and wish to use the dark theme regardless of your OS
configuration, you can install the
[Dark Website Forcer](https://addons.mozilla.org/en-US/firefox/addon/dark-mode-website-switcher/)
add-on.

## Contributing changes

**Pull Requests should use the `master` branch by default. Only make Pull Requests against other branches (e.g. `2.1` or `3.0`) if your changes only apply to that specific version of Godot.**

Though arguably less convenient to edit than a wiki, this Git repository is meant to receive pull requests to always improve the documentation, add new pages, etc. Having direct access to the source files in a revision control system is a big plus to ensure the quality of our documentation.

### Editing existing pages

To edit an existing page, locate its .rst source file and open it in your favorite text editor. You can then commit the changes, push them to your fork and make a pull request.
**Note that the pages in `classes/` should not be edited here, they are automatically generated from Godot's [XML class references](https://github.com/godotengine/godot/tree/master/doc/classes).**
See [Contribute to the Class Reference](https://docs.godotengine.org/en/latest/community/contributing/updating_the_class_reference.html) for details.

### Adding new pages

To add a new page, create a .rst file with a meaningful name in the section you want to add a file to, e.g. `tutorials/3d/light_baking.rst`. Write its content like you would do for any other file, and make sure to define a reference name for Sphinx at the beginning of the file (check other files for the syntax), based on the file name with a "doc_" prefix (e.g. `.. _doc_light_baking:`).

You should then add your page to the relevant "toctree" (table of contents, e.g. `tutorials/3d/index.rst`). By convention, the files used to define the various levels of toctree are prefixed with an underscore, so in the above example the file should be referenced in `tutorials/3d/_3d_graphics.rst`. Add your new filename to the list on a new line, using a relative path and no extension, e.g. here `light_baking`.

### Sphinx and reStructuredText syntax

Check Sphinx's [reST Primer](https://www.sphinx-doc.org/en/stable/rest.html) and the [official reference](http://docutils.sourceforge.net/rst.html) for details on the syntax.

Sphinx uses specific reST comments to do specific operations, like defining the table of contents (`:toctree:`) or cross-referencing pages. Check the [official Sphinx documentation](https://www.sphinx-doc.org/en/stable/index.html) for more details, or see how things are done in existing pages and adapt it to your needs.

### Adding images and attachments

To add images, please put them in an `img/` folder next to the .rst file with a meaningful name and include them in your page with:
```rst
.. image:: img/image_name.png
```

Similarly, you can include attachments (like assets as support material for a tutorial) by placing them into a `files/` folder next to the .rst file, and using this inline markup:
```rst
:download:`myfilename.zip <files/myfilename.zip>`
```

## Building with Sphinx

To build the HTML website (or any other format supported by Sphinx, like PDF, EPUB or LaTeX), you need to install [Sphinx](https://www.sphinx-doc.org/) >= 1.3 as well as (for the HTML) the [readthedocs.org theme](https://github.com/snide/sphinx_rtd_theme).
You also need to install the Sphinx extensions defined in `requirements.txt`.

Those tools are best installed using [pip](https://pip.pypa.io), Python's module installer. The Python 3 version might be provided (on Linux distros) as `pip3` or `python3-pip`. You can then run:

```sh
pip install -r requirements.txt
```

You can then build the HTML documentation from the root folder of this repository with:

```sh
make html
```

or:

```sh
make SPHINXBUILD=~/.local/bin/sphinx-build html
```

Building the documentation requires at least 8 GB of RAM to be done without swapping. If you have at least 16 GB of RAM, you can speed up compilation by using:

```bash
# On Linux/macOS
make html SPHINXOPTS=-j2

# On Windows
set SPHINXOPTS=-j2 && make html
```

The compilation might take some time as the `classes/` folder contains many files to parse.

In case of a `MemoryError` or `EOFError`, you can remove the `classes/` folder and run `make` again. This will drop the class references from the final HTML documentation but will keep the rest intact. Make sure to avoid using `git add .` in this case when working on a pull request, or the whole `classes/` folder will be removed when you make a commit. See [#3157](https://github.com/godotengine/godot-docs/issues/3157) for more details.

You can then test the changes live by opening `_build/html/index.html` in your favorite browser.

### Building with Sphinx on Windows

On Windows, you need to:
* Download the Python installer [here](https://www.python.org/downloads/).
* Install Python. Don't forget to check the "Add Python to PATH" box.
* Use the above `pip` commands.

Building is still done at the root folder of this repository using the provided `make.bat`:
```sh
make.bat html
```

Alternatively, you can build with this command instead:
```sh
sphinx-build -b html ./ _build
```

Note that during the first build, various installation prompts may appear and ask to install LaTeX plugins.
Make sure you don't miss them, especially if they open behind other windows, else the build may appear to hang until you confirm these prompts.

You could also install a normal `make` toolchain (for example via MinGW) and build the docs using the normal `make html`.

### Building with Sphinx and virtualenv

If you want your Sphinx installation scoped to the project, you can install it using virtualenv.
Execute this from the root folder of this repository:

```sh
virtualenv --system-site-packages env/
. env/bin/activate
pip install -r requirements.txt
```

Then do `make html` like above.

## License

At the exception of the `classes/` folder, all the content of this repository is licensed under the Creative Commons Attribution 3.0 Unported license ([CC BY 3.0](https://creativecommons.org/licenses/by/3.0/)) and is to be attributed to "Juan Linietsky, Ariel Manzur and the Godot community".
See [LICENSE.txt](/LICENSE.txt) for details.

The files in the `classes/` folder are derived from [Godot's main source repository](https://github.com/godotengine/godot) and are distributed under the MIT license, with the same authors as above.


===================================================
/. ./about/introduction.rst
===================================================

.. _doc_about_intro:

Introduction
============

::

    func _ready():
        $Label.text = "Hello world!"

Welcome to the official documentation of Godot Engine, the free and open source
community-driven 2D and 3D game engine! Behind this mouthful, you will find a
powerful yet user-friendly tool that you can use to develop any kind of game,
for any platform and with no usage restriction whatsoever.

This page gives a broad presentation of the engine and of the contents
of this documentation, so that you know where to start if you are a beginner or
where to look if you need info on a specific feature.

Before you start
----------------

The :ref:`Tutorials and resources <doc_community_tutorials>` page lists
video tutorials contributed by the community. If you prefer video to text,
those may be worth a look.

In case you have trouble with one of the tutorials or your project,
you can find help on the various :ref:`Community channels <doc_community_channels>`,
especially the Godot Discord community, Q&A, and IRC.

About Godot Engine
------------------

A game engine is a complex tool, and it is therefore difficult to present Godot
in a few words. Here's a quick synopsis, which you are free to reuse
if you need a quick writeup about Godot Engine.

    Godot Engine is a feature-packed, cross-platform game engine to create 2D
    and 3D games from a unified interface. It provides a comprehensive set of
    common tools, so users can focus on making games without having to
    reinvent the wheel. Games can be exported in one click to a number of
    platforms, including the major desktop platforms (Linux, macOS, Windows)
    as well as mobile (Android, iOS) and web-based (HTML5) platforms.

    Godot is completely free and open source under the permissive MIT
    license. No strings attached, no royalties, nothing. Users' games are
    theirs, down to the last line of engine code. Godot's development is fully
    independent and community-driven, empowering users to help shape their
    engine to match their expectations. It is supported by the `Software
    Freedom Conservancy <https://sfconservancy.org>`_ not-for-profit.

For a more in-depth view of the engine, you are encouraged to read this
documentation further, especially the :ref:`Step by step
<toc-learn-step_by_step>` tutorial.

About the documentation
-----------------------

This documentation is continuously written, corrected, edited, and revamped by
members of the Godot Engine community. It is edited via text files in the
`reStructuredText <http://www.sphinx-doc.org/en/stable/rest.html>`_ markup
language and then compiled into a static website/offline document using the
open source `Sphinx <http://www.sphinx-doc.org>`_ and `ReadTheDocs
<https://readthedocs.org/>`_ tools.

.. note:: You can contribute to Godot's documentation by opening issue tickets
          or sending patches via pull requests on its GitHub
          `source repository <https://github.com/godotengine/godot-docs>`_, or
          translating it into your language on `Hosted Weblate
          <https://hosted.weblate.org/projects/godot-engine/godot-docs/>`_.

All the contents are under the permissive Creative Commons Attribution 3.0
(`CC-BY 3.0 <https://creativecommons.org/licenses/by/3.0/>`_) license, with
attribution to "Juan Linietsky, Ariel Manzur and the Godot Engine community".

Organization of the documentation
---------------------------------

This documentation is organized in five sections with an impressively
unbalanced distribution of contents – but the way it is split up should be
relatively intuitive:

- The :ref:`sec-general` section contains this introduction as well as
  information about the engine, its history, its licensing, authors, etc. It
  also contains the :ref:`doc_faq`.
- The :ref:`sec-learn` section is the *raison d'être* of this
  documentation, as it contains all the necessary information on using the
  engine to make games. It starts with the :ref:`Step by step
  <toc-learn-step_by_step>` tutorial which should be the entry point for all
  new users.
- The :ref:`sec-tutorials` section can be read as needed,
  in any order. It contains feature-specific tutorials and documentation.
- The :ref:`sec-devel` section is intended for advanced users and contributors
  to the engine development, with information on compiling the engine,
  developing C++ modules or editor plugins.
- The :ref:`sec-community` section gives information related to contributing to
  engine development and the life of its community, e.g. how to report bugs,
  help with the documentation, etc. It also points to various community channels
  like IRC and Discord and contains a list of recommended third-party tutorials
  outside of this documentation.
- Finally, the :ref:`sec-class-ref` is the documentation of the Godot API,
  which is also available directly within the engine's script editor. It is
  generated automatically from a file in the main source repository, therefore
  the generated files of the documentation are not meant to be modified. See
  :ref:`doc_updating_the_class_reference` for details.

In addition to this documentation you may also want to take a look at the
various `Godot demo projects <https://github.com/godotengine/godot-demo-projects>`_.

Have fun reading and making games with Godot Engine!


===================================================
/. ./about/faq.rst
===================================================

.. meta::
    :keywords: FAQ

.. _doc_faq:

Frequently asked questions
==========================

What can I do with Godot? How much does it cost? What are the license terms?
----------------------------------------------------------------------------

Godot is `Free and Open-Source Software <https://en.wikipedia.org/wiki/Free_and_open-source_software>`_ available under the `OSI-approved <https://opensource.org/licenses/MIT>`_ MIT license. This means it is free as in "free speech" as well as in "free beer."

In short:

* You are free to download and use Godot for any purpose: personal, non-profit, commercial, or otherwise.
* You are free to modify, distribute, redistribute, and remix Godot to your heart's content, for any reason, both non-commercially and commercially.

All the contents of this accompanying documentation are published under
the permissive Creative Commons Attribution 3.0 (`CC-BY 3.0 <https://creativecommons.org/licenses/by/3.0/>`_) license, with attribution
to "Juan Linietsky, Ariel Manzur and the Godot Engine community."

Logos and icons are generally under the same Creative Commons license. Note
that some third-party libraries included with Godot's source code may have
different licenses.

For full details, look at the `COPYRIGHT.txt <https://github.com/godotengine/godot/blob/master/COPYRIGHT.txt>`_ as well
as the `LICENSE.txt <https://github.com/godotengine/godot/blob/master/LICENSE.txt>`_ and `LOGO_LICENSE.txt <https://github.com/godotengine/godot/blob/master/LOGO_LICENSE.md>`_ files
in the Godot repository.

Also, see `the license page on the Godot website <https://godotengine.org/license>`_.

Which platforms are supported by Godot?
---------------------------------------

**For the editor:**

* Windows
* macOS
* X11 (Linux, \*BSD)
* :ref:`Web <doc_using_the_web_editor>`
* Android (experimental)

**For exporting your games:**

* Windows (and UWP)
* macOS
* X11 (Linux, \*BSD)
* Android
* iOS
* Web

Both 32- and 64-bit binaries are supported where it makes sense, with 64
being the default.

Some users also report building and using Godot successfully on ARM-based
systems with Linux, like the Raspberry Pi.

Additionally, there is some unofficial third-party work being done on building
for some consoles. However, none of this is included in the default build
scripts or export templates at this time.

For more on this, see the sections on :ref:`exporting <toc-learn-workflow-export>`
and :ref:`compiling Godot yourself <toc-devel-compiling>`.

Which programming languages are supported in Godot?
---------------------------------------------------

The officially supported languages for Godot are GDScript, Visual Scripting,
C#, and C++. See the subcategories for each language in the
:ref:`scripting <toc-learn-scripting>` section.

If you are just starting out with either Godot or game development in general,
GDScript is the recommended language to learn and use since it is native to Godot.
While scripting languages tend to be less performant than lower-level languages in
the long run, for prototyping, developing Minimum Viable Products (MVPs), and
focusing on Time-To-Market (TTM), GDScript will provide a fast, friendly, and capable
way of developing your games.

Note that C# support is still relatively new, and as such, you may encounter some
issues along the way. Our friendly and hard-working development community is always
ready to tackle new problems as they arise, but since this is an open-source project,
we recommend that you first do some due diligence yourself. Searching through
discussions on `open issues <https://github.com/godotengine/godot/issues>`_ is a
great way to start your troubleshooting.

As for new languages, support is possible via third parties using the GDNative /
NativeScript / PluginScript facilities. (See the question about plugins below.)
Work is currently underway, for example, on unofficial bindings for Godot
to `Python <https://github.com/touilleMan/godot-python>`_ and `Nim <https://github.com/pragmagic/godot-nim>`_.

.. _doc_faq_what_is_gdscript:

What is GDScript and why should I use it?
-----------------------------------------

GDScript is Godot's integrated scripting language. It was built from the ground
up to maximize Godot's potential in the least amount of code, affording both novice
and expert developers alike to capitalize on Godot's strengths as fast as possible.
If you've ever written anything in a language like Python before then you'll feel
right at home. For examples, history, and a complete overview of the power GDScript
offers you, check out the :ref:`GDScript scripting guide <doc_gdscript>`.

There are several reasons to use GDScript--especially when you are prototyping, in
alpha/beta stages of your project, or are not creating the next AAA title--but the
most salient reason is the overall **reduction of complexity**.

The original intent of creating a tightly integrated, custom scripting language for
Godot was two-fold: first, it reduces the amount of time necessary to get up and running
with Godot, giving developers a rapid way of exposing themselves to the engine with a
focus on productivity; second, it reduces the overall burden of maintenance, attenuates
the dimensionality of issues, and allows the developers of the engine to focus on squashing
bugs and improving features related to the engine core--rather than spending a lot of time
trying to get a small set of incremental features working across a large set of languages.

Since Godot is an open-source project, it was imperative from the start to prioritize a
more integrated and seamless experience over attracting additional users by supporting
more familiar programming languages--especially when supporting those more familiar
languages would result in a worse experience. We understand if you would rather use
another language in Godot (see the list of supported options above). That being said, if
you haven't given GDScript a try, try it for **three days**. Just like Godot,
once you see how powerful it is and rapid your development becomes, we think GDScript
will grow on you.

More information about getting comfortable with GDScript or dynamically typed
languages can be found in the :ref:`doc_gdscript_more_efficiently` tutorial.

What were the motivations behind creating GDScript?
---------------------------------------------------

In the early days, the engine used the `Lua <https://www.lua.org>`__
scripting language. Lua is fast, but creating bindings to an object
oriented system (by using fallbacks) was complex and slow and took an
enormous amount of code. After some experiments with
`Python <https://www.python.org>`__, it also proved difficult to embed.

The main reasons for creating a custom scripting language for Godot were:

1. Poor threading support in most script VMs, and Godot uses threads
   (Lua, Python, Squirrel, JavaScript, ActionScript, etc.).
2. Poor class-extending support in most script VMs, and adapting to
   the way Godot works is highly inefficient (Lua, Python, JavaScript).
3. Many existing languages have horrible interfaces for binding to C++, resulting in large amount of
   code, bugs, bottlenecks, and general inefficiency (Lua, Python,
   Squirrel, JavaScript, etc.) We wanted to focus on a great engine, not a great amount of integrations.
4. No native vector types (vector3, matrix4, etc.), resulting in highly
   reduced performance when using custom types (Lua, Python, Squirrel,
   JavaScript, ActionScript, etc.).
5. Garbage collector results in stalls or unnecessarily large memory
   usage (Lua, Python, JavaScript, ActionScript, etc.).
6. Difficulty to integrate with the code editor for providing code
   completion, live editing, etc. (all of them). This is well-supported
   by GDScript.

GDScript was designed to curtail the issues above, and more.

What type of 3D model formats does Godot support?
-------------------------------------------------

Godot supports Collada via the `OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/OpenCOLLADA-Tools>`_ exporter (Maya, 3DSMax).
If you are using Blender, take a look at our own `Better Collada Exporter <https://godotengine.org/download>`_.

As of Godot 3.0, glTF is supported.

FBX is supported via the Open Asset Import library. However, FBX is proprietary
so we recommend using other formats listed above, if suitable for your workflow.

Will [insert closed SDK such as FMOD, GameWorks, etc.] be supported in Godot?
-----------------------------------------------------------------------------

The aim of Godot is to create a free and open-source MIT-licensed engine that
is modular and extendable. There are no plans for the core engine development
community to support any third-party, closed-source/proprietary SDKs, as integrating
with these would go against Godot's ethos.

That said, because Godot is open-source and modular, nothing prevents you or
anyone else interested in adding those libraries as a module and shipping your
game with them--as either open- or closed-source.

To see how support for your SDK of choice could still be provided, look at the
Plugins question below.

If you know of a third-party SDK that is not supported by Godot but that offers
free and open-source integration, consider starting the integration work yourself.
Godot is not owned by one person; it belongs to the community, and it grows along
with ambitious community contributors like you.

How do I install the Godot editor on my system (for desktop integration)?
-------------------------------------------------------------------------

Since you don't need to actually install Godot on your system to run it,
this means desktop integration is not performed automatically.
There are two ways to overcome this. You can install Godot from
`Steam <https://store.steampowered.com/app/404790/Godot_Engine/>`__ (all platforms),
`Scoop <https://scoop.sh/>`__ (Windows), `Homebrew <https://brew.sh/>`__ (macOS)
or `Flathub <https://flathub.org/apps/details/org.godotengine.Godot>`__ (Linux).
This will automatically perform the required steps for desktop integration.

Alternatively, you can manually perform the steps that an installer would do for you:

Windows
^^^^^^^

- Move the Godot executable to a stable location (i.e. outside of your Downloads folder),
  so you don't accidentally move it and break the shortcut in the future.
- Right-click the Godot executable and choose **Create Shortcut**.
- Move the created shortcut to ``%LOCALAPPDATA%\Microsoft\Windows\Start Menu\Programs``.
  This is the user-wide location for shortcuts that will appear in the Start menu.
  You can also pin Godot in the task bar by right-clicking the executable and choosing
  **Pin to Task Bar**.

macOS
^^^^^

Drag the extracted Godot application to ``/Applications/Godot.app``, then drag it
to the Dock if desired. Spotlight will be able to find Godot as long as it's in
``/Applications`` or ``~/Applications``.

Linux
^^^^^

- Move the Godot binary to a stable location (i.e. outside of your Downloads folder),
  so you don't accidentally move it and break the shortcut in the future.
- Rename and move the Godot binary to a location present in your ``PATH`` environment variable.
  This is typically ``/usr/local/bin/godot`` or ``/usr/bin/godot``.
  Doing this requires administrator privileges,
  but this also allows you to
  :ref:`run the Godot editor from a terminal <doc_command_line_tutorial>` by entering ``godot``.

  - If you cannot move the Godot editor binary to a protected location, you can
    keep the binary somewhere in your home directory, and modify the ``Path=``
    line in the ``.desktop`` file linked below to contain the full *absolute* path
    to the Godot binary.

- Save `this .desktop file <https://raw.githubusercontent.com/godotengine/godot/3.x/misc/dist/linux/org.godotengine.Godot.desktop>`__
  to ``$HOME/.local/share/applications/``. If you have administrator privileges,
  you can also save the ``.desktop`` file to ``/usr/local/share/applications``
  to make the shortcut available for all users.

Is the Godot editor a portable application?
-------------------------------------------

In its default configuration, Godot is *semi-portable*. Its executable can run
from any location (including non-writable locations) and never requires
administrator privileges.

However, configuration files will be written to the user-wide configuration or
data directory. This is usually a good approach, but this means configuration files
will not carry across machines if you copy the folder containing the Godot executable.
See :ref:`doc_data_paths` for more information.

If *true* portable operation is desired (e.g. for use on an USB stick),
follow the steps in :ref:`doc_data_paths_self_contained_mode`.

Why does Godot use Vulkan or OpenGL instead of Direct3D?
--------------------------------------------------------

Godot aims for cross-platform compatibility and open standards first and
foremost. OpenGL and Vulkan are the technologies that are both open and
available (nearly) on all platforms. Thanks to this design decision, a project
developed with Godot on Windows will run out of the box on Linux, macOS, and
more.

Since Godot only has a few people working on its renderer, we would prefer
having fewer rendering backends to maintain. On top of that, using a single API
on all platforms allows for greater consistency with fewer platform-specific
issues.

In the long term, we may develop a Direct3D 12 renderer for Godot (mainly for
the Xbox's purposes), but Vulkan and OpenGL will remain the default rendering
backends on all platforms, including Windows.

Why does Godot aim to keep its core feature set small?
------------------------------------------------------

Godot intentionally does not include features that can be implemented by add-ons
unless they are used very often. One example of this would be advanced
artificial intelligence functionality.

There are several reasons for this:

- **Code maintenance and surface for bugs.** Every time we accept new code in
  the Godot repository, existing contributors often take the reponsibility of
  maintaining it. Some contributors don't always stick around after getting
  their code merged, which can make it difficult for us to maintain the code in
  question. This can lead to poorly maintained features with bugs that are never
  fixed. On top of that, the "API surface" that needs to be tested and checked
  for regressions keeps increasing over time.

- **Ease of contribution.** By keeping the codebase small and tidy, it can remain
  fast and easy to compile from source. This makes it easier for new
  contributors to get started with Godot, without requiring them to purchase
  high-end hardware.

- **Keeping the binary size small for the editor.** Not everyone has a fast Internet
  connection. Ensuring that everyone can download the Godot editor, extract it
  and run it in less than 5 minutes makes Godot more accessible to developers in
  all countries.

- **Keeping the binary size small for export templates.** This directly impacts the
  size of projects exported with Godot. On mobile and web platforms, keeping
  file sizes low is primordial to ensure fast installation and loading on
  underpowered devices. Again, there are many countries where high-speed
  Internet is not readily available. To add to this, strict data usage caps are
  often in effect in those countries.

For all the reasons above, we have to be selective of what we can accept as core
functionality in Godot. This is why we are aiming to move some core
functionality to officially supported add-ons in future versions of Godot. In
terms of binary size, this also has the advantage of making you pay only for what
you actually use in your project. (In the meantime, you can
:ref:`compile custom export templates with unused features disabled <doc_optimizing_for_size>`
to optimize the distribution size of your project.)

How should assets be created to handle multiple resolutions and aspect ratios?
------------------------------------------------------------------------------

This question pops up often and it's probably thanks to the misunderstanding
created by Apple when they originally doubled the resolution of their devices.
It made people think that having the same assets in different resolutions was a
good idea, so many continued towards that path. That originally worked to a
point and only for Apple devices, but then several Android and Apple devices
with different resolutions and aspect ratios were created, with a very wide
range of sizes and DPIs.

The most common and proper way to achieve this is to, instead, use a single
base resolution for the game and only handle different screen aspect ratios.
This is mostly needed for 2D, as in 3D it's just a matter of Camera XFov or YFov.

1. Choose a single base resolution for your game. Even if there are
   devices that go up to 2K and devices that go down to 400p, regular
   hardware scaling in your device will take care of this at little or
   no performance cost. Most common choices are either near 1080p
   (1920x1080) or 720p (1280x720). Keep in mind the higher the
   resolution, the larger your assets, the more memory they will take
   and the longer the time it will take for loading.

2. Use the stretch options in Godot; 2D stretching while keeping aspect
   ratios works best. Check the :ref:`doc_multiple_resolutions` tutorial
   on how to achieve this.

3. Determine a minimum resolution and then decide if you want your game
   to stretch vertically or horizontally for different aspect ratios, or
   if there is one aspect ratio and you want black bars to appear
   instead. This is also explained in :ref:`doc_multiple_resolutions`.

4. For user interfaces, use the :ref:`anchoring <doc_size_and_anchors>`
   to determine where controls should stay and move. If UIs are more
   complex, consider learning about Containers.

And that's it! Your game should work in multiple resolutions.

If there is a desire to make your game also work on ancient
devices with tiny screens (fewer than 300 pixels in width), you can use
the export option to shrink images, and set that build to be used for
certain screen sizes in the App Store or Google Play.

How can I extend Godot?
-----------------------

For extending Godot, like creating Godot Editor plugins or adding support
for additional languages, take a look at :ref:`EditorPlugins <doc_making_plugins>`
and tool scripts.

Also, see the official blog posts on these topics:

* `A look at the GDNative architecture <https://godotengine.org/article/look-gdnative-architecture>`_
* `GDNative is here! <https://godotengine.org/article/dlscript-here>`_

You can also take a look at the GDScript implementation, the Godot modules,
as well as the `unofficial Python support <https://github.com/touilleMan/godot-python>`_ for Godot.
This would be a good starting point to see how another third-party library
integrates with Godot.

When is the next release of Godot out?
--------------------------------------

When it's ready! See :ref:`doc_release_policy_when_is_next_release_out` for more
information.

I would like to contribute! How can I get started?
--------------------------------------------------

Awesome! As an open-source project, Godot thrives off of the innovation and
ambition of developers like you.

The first place to get started is in the `issues <https://github.com/godotengine/godot/issues>`_.
Find an issue that resonates with you, then proceed to the `How to Contribute <https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#contributing-pull-requests>`_
guide to learn how to fork, modify, and submit a Pull Request (PR) with your changes.

I have a great idea for Godot. How can I share it?
--------------------------------------------------

It might be tempting to want to bring ideas to Godot, like ones that
result in massive core changes, some sort of mimicry of what another
game engine does, or alternative workflows that you'd like built into
the editor. These are great, and we are thankful to have such motivated
people want to contribute, but Godot's focus is and always will be the
core functionality as outlined in the `Roadmap <https://github.com/godotengine/godot-roadmap/blob/master/ROADMAP.md>`_,
`squashing bugs and addressing issues <https://github.com/godotengine/godot/issues>`_,
and conversations between Godot community members.

Most developers in the Godot community will be more interested to learn
about things like:

-  Your experience using the software and the problems you have (we
   care about this much more than ideas on how to improve it).
-  The features you would like to see implemented because you need them
   for your project.
-  The concepts that were difficult to understand while learning the software.
-  The parts of your workflow you would like to see optimized.
-  Parts where you missed clear tutorials or where the documentation wasn't clear.

Please don't feel like your ideas for Godot are unwelcome. Instead,
try to reformulate them as a problem first, so developers and the community
have a functional foundation to ground your ideas on.

A good way to approach sharing your ideas and problems with the community
is as a set of user stories. Explain what you are trying to do, what behavior
you expect to happen, and then what behavior actually happened. Framing problems
and ideas this way will help the whole community stay focused on improving
developer experiences as a whole.

Bonus points for bringing screenshots, concrete numbers, test cases, or example
projects (if applicable).

.. _doc_faq_non_game_applications:

Is it possible to use Godot to create non-game applications?
------------------------------------------------------------

Yes! Godot features an extensive built-in UI system, and its small distribution
size can make it a suitable alternative to frameworks like Electron or Qt.

When creating a non-game application, make sure to enable
:ref:`low-processor mode <class_ProjectSettings_property_application/run/low_processor_mode>`
in the Project Settings to decrease CPU and GPU usage.

That said, we wouldn't recommend using Godot to create a *mobile* application
since low-processor mode isn't supported on mobile platforms yet.

Check out `Material Maker <https://github.com/RodZill4/material-maker>`__ and
`Pixelorama <https://github.com/Orama-Interactive/Pixelorama>`__ for examples of
open source applications made with Godot.

.. _doc_faq_use_godot_as_library:

Is it possible to use Godot as a library?
-----------------------------------------

Godot is meant to be used with its editor. We recommend you give it a try, as it
will most likely save you time in the long term. There are no plans to make
Godot usable as a library, as it would make the rest of the engine more
convoluted and difficult to use for casual users.

If you want to use a rendering library, look into using an established rendering
engine instead. Keep in mind rendering engines usually have smaller communities
compared to Godot. This will make it more difficult to find answers to your
questions.

What user interface toolkit does Godot use?
-------------------------------------------

Godot does not use a standard :abbr:`GUI (Graphical User Interface)` toolkit
like GTK, Qt or wxWidgets. Instead, Godot uses its own user interface toolkit,
rendered using OpenGL ES or Vulkan. This toolkit is exposed in the form of
Control nodes, which are used to render the editor (which is written in C++).
These Control nodes can also be used in projects from any scripting language
supported by Godot.

This custom toolkit makes it possible to benefit from hardware acceleration and
have a consistent appearance across all platforms. On top of that, it doesn't
have to deal with the LGPL licensing caveats that come with GTK or Qt. Lastly,
this means Godot is "eating its own dog food" since the editor itself is one of
the most complex users of Godot's UI system.

This custom UI toolkit :ref:`can't be used as a library <doc_faq_use_godot_as_library>`,
but you can still
:ref:`use Godot to create non-game applications by using the editor <doc_faq_non_game_applications>`.

.. _doc_faq_why_not_stl:

Why does Godot not use STL (Standard Template Library)?
-------------------------------------------------------

Like many other libraries (Qt as an example), Godot does not make use of
STL. We believe STL is a great general purpose library, but we had special
requirements for Godot.

* STL templates create very large symbols, which results in huge debug binaries. We use few templates with very short names instead.
* Most of our containers cater to special needs, like Vector, which uses copy on write and we use to pass data around, or the RID system, which requires O(1) access time for performance. Likewise, our hash map implementations are designed to integrate seamlessly with internal engine types.
* Our containers have memory tracking built-in, which helps better track memory usage.
* For large arrays, we use pooled memory, which can be mapped to either a preallocated buffer or virtual memory.
* We use our custom String type, as the one provided by STL is too basic and lacks proper internationalization support.

Why does Godot not use exceptions?
----------------------------------

We believe games should not crash, no matter what. If an unexpected
situation happens, Godot will print an error (which can be traced even to
script), but then it will try to recover as gracefully as possible and keep
going.

Additionally, exceptions significantly increase binary size for the
executable.

Why does Godot not enforce RTTI?
--------------------------------

Godot provides its own type-casting system, which can optionally use RTTI
internally. Disabling RTTI in Godot means considerably smaller binary sizes can
be achieved, at a little performance cost.

Why does Godot not force users to implement DoD (Data oriented Design)?
-----------------------------------------------------------------------

While Godot internally for a lot of the heavy performance tasks attempts
to use cache coherency as well as possible, we believe most users don't
really need to be forced to use DoD practices.

DoD is mostly a cache coherency optimization that can only gain you
significant performance improvements when dealing with dozens of
thousands of objects (which are processed every frame with little
modification). As in, if you are moving a few hundred sprites or enemies
per frame, DoD won't help you, and you should consider a different approach
to optimization.

The vast majority of games do not need this and Godot provides handy helpers
to do the job for most cases when you do.

If a game that really needs to process such large amount of objects is
needed, our recommendation is to use C++ and GDNative for the high
performance parts and GDScript (or C#) for the rest of the game.

How can I support Godot development or contribute?
--------------------------------------------------

See :ref:`doc_ways_to_contribute`.

Who is working on Godot? How can I contact you?
-----------------------------------------------

See the corresponding page on the `Godot website <https://godotengine.org/contact>`_.


===================================================
/. ./about/troubleshooting.rst
===================================================

.. _doc_troubleshooting:

Troubleshooting
===============

This page lists common issues encountered when using Godot and possible solutions.

.. seealso::

    See :ref:`doc_using_the_web_editor` for caveats specific to the HTML5 version
    of the Godot editor.

Everything I do in the editor or project manager appears delayed by one frame
-----------------------------------------------------------------------------

This is a `known bug <https://github.com/godotengine/godot/issues/23069>`__ on
Intel graphics drivers on Windows. Updating to the latest graphics driver
version *provided by Intel* should fix the issue.

You should use the graphics driver provided by Intel rather than the one
provided by your desktop or laptop's manufacturer because their version is often
outdated.

The grid disappears and meshes turn black when I rotate the 3D camera in the editor
-----------------------------------------------------------------------------------

This is a `known bug <https://github.com/godotengine/godot/issues/30330>`__ on
Intel graphics drivers on Windows.

The only workaround, for now, is to switch to the GLES2 renderer. You can switch
the renderer in the top-right corner of the editor or the Project Settings.

If you use a computer allowing you to switch your graphics card, like NVIDIA
Optimus, you can use the dedicated graphics card to run Godot.

The editor or project takes a very long time to start
-----------------------------------------------------

This is a `known bug <https://github.com/godotengine/godot/issues/20566>`__ on
Windows when you have specific USB peripherals connected. In particular,
Corsair's iCUE software seems to cause the bug. Try updating your USB
peripherals' drivers to their latest version. If the bug persists, you need to
disconnect the faulty peripherals before opening the editor. You can then
connect the peripheral again.

Editor tooltips in the Inspector and Node docks blink when they're displayed
----------------------------------------------------------------------------

This is a `known issue <https://github.com/godotengine/godot/issues/32990>`__
caused by the third-party Stardock Fences application on Windows.
The only known workaround is to disable Stardock Fences while using Godot.

The Godot editor appears frozen after clicking the system console
-----------------------------------------------------------------

When running Godot on Windows with the system console enabled, you can
accidentally enable *selection mode* by clicking inside the command window. This
Windows-specific behavior pauses the application to let you select text inside
the system console. Godot cannot override this system-specific behavior.

To solve this, select the system console window and press Enter to leave
selection mode.

Some text such as "NO DC" appears in the top-left corner of the project manager and editor window
-------------------------------------------------------------------------------------------------

This is caused by the NVIDIA graphics driver injecting an overlay to display information.

To disable this overlay on Windows, restore your graphics driver settings to the
default values in the NVIDIA Control Panel.

To disable this overlay on Linux, open ``nvidia-settings``, go to **X Screen 0 >
OpenGL Settings** then uncheck **Enable Graphics API Visual Indicator**.

The project window appears blurry, unlike the editor
----------------------------------------------------

Unlike the editor, the project isn't marked as DPI-aware by default. This is
done to improve performance, especially on integrated graphics, where rendering
3D scenes in hiDPI is slow.

To resolve this, open **Project > Project Settings** and enable **Display >
Window > Dpi > Allow Hidpi**. On top of that, make sure your project is
configured to support :ref:`multiple resolutions <doc_multiple_resolutions>`.

The project window doesn't appear centered when I run the project
-----------------------------------------------------------------

This is a `known bug <https://github.com/godotengine/godot/issues/13017>`__. To
resolve this, open **Project > Project Settings** and enable **Display > Window
> Dpi > Allow Hidpi**. On top of that, make sure your project is configured to
support :ref:`multiple resolutions <doc_multiple_resolutions>`.

The editor/project freezes or displays glitched visuals after resuming the PC from suspend
------------------------------------------------------------------------------------------

This is a known issue on Linux with NVIDIA graphics when using the proprietary
driver. There is no definitive fix yet, as suspend on Linux + NVIDIA is often
buggy when OpenGL is involved.

The NVIDIA driver offers an *experimental*
`option to preserve video memory after suspend <https://wiki.archlinux.org/title/NVIDIA/Tips_and_tricks#Preserve_video_memory_after_suspend>`__
which may resolve this issue. This option has been reported to work better with
more recent NVIDIA driver versions.

To avoid losing work, save scenes in the editor before putting the PC to sleep.

The project works when run from the editor, but fails to load some files when running from an exported copy
-----------------------------------------------------------------------------------------------------------

This is usually caused by forgetting to specify a filter for non-resource files
in the Export dialog. By default, Godot will only include actual *resources*
into the PCK file. Some files commonly used, such as JSON files, are not
considered resources. For example, if you load ``test.json`` in the exported
project, you need to specify ``*.json`` in the non-resource export filter. See
:ref:`doc_exporting_projects_export_mode` for more information.

On Windows, this can also be due to :ref:`case sensitivity
<doc_project_organization_case_sensitivity>` issues. If you reference a resource
in your script with a different case than on the filesystem, loading will fail
once you export the project. This is because the virtual PCK filesystem is
case-sensitive, while Windows's filesystem is case-insensitive by default.


===================================================
/. ./about/list_of_features.rst
===================================================

.. _doc_list_of_features:

List of features
================

This page aims to list all features currently supported by Godot.

.. note::

    This page lists features supported by the current stable version of
    Godot (3.5). `More features <https://docs.godotengine.org/en/latest/about/list_of_features.html>`__
    are available in the latest development version (4.0).

Features
--------

Platforms
^^^^^^^^^

**Can run both the editor and exported projects:**

- Windows 7 and later (64-bit and 32-bit).
- macOS 10.12 and later (64-bit, x86 and ARM).
- Linux (64-bit and 32-bit, x86 and ARM).

   - Binaries are statically linked and can run on any distribution if compiled
     on an old enough base distribution.
   - Official binaries are compiled on Ubuntu 14.04.

- HTML5 via WebAssembly (Firefox, Chrome, Edge, Opera).

**Runs exported projects:**

- Android 4.4 and later.
- iOS 10.0 and later.
- :ref:`Consoles <doc_consoles>`.
- :ref:`Headless Linux and macOS servers <doc_exporting_for_dedicated_servers>`.

Godot aims to be as platform-independent as possible and can be ported to new
platforms with relative ease.

Editor
^^^^^^

**Features:**

- Scene tree editor.
- Built-in script editor.
- Support for :ref:`external script editors <doc_external_editor>` such as
  Visual Studio Code or Vim.
- GDScript :ref:`debugger <doc_debugger_panel>`.

   - No support for debugging in threads yet.
- Performance monitoring tools.
- Live script reloading.
- Live scene editing.

   - Changes will reflect in the editor and will be kept after closing the running project.

- Remote inspector.

   - Changes won't reflect in the editor and won't be kept after closing the running project.

- Live camera replication.

   - Move the in-editor camera and see the result in the running project.

- Built-in offline class reference documentation.
- Use the editor in dozens of languages contributed by the community.

**Plugins:**

- Editor plugins can be downloaded from the
  :ref:`asset library <doc_what_is_assetlib>` to extend editor functionality.
- :ref:`Create your own plugins <doc_making_plugins>` using GDScript to add new
  features or speed up your workflow.
- :ref:`Download projects from the asset library <doc_using_assetlib_editor>`
  in the project manager and import them directly.

2D graphics
^^^^^^^^^^^

**Two renderers available:**

- OpenGL ES 3.0 renderer (uses OpenGL 3.3 on desktop platforms).

   - High-end visuals. Recommended on desktop platforms.

- OpenGL ES 2.0 renderer (uses OpenGL 2.1 on desktop platforms).

   - Recommended on mobile and Web platforms.

**Features:**

- Sprite, polygon and line rendering.

   - High-level tools to draw lines and polygons such as Polygon2D and Line2D.

- AnimatedSprite as a helper for creating animated sprites.
- Parallax layers.

   - Pseudo-3D support including preview in the editor.

- 2D lighting with normal maps.

   - Hard or soft shadows.

- Font rendering using bitmaps (BitmapFont) or rasterization using FreeType (DynamicFont).

   - Bitmap fonts can be exported using tools like BMFont.
   - DynamicFont supports monochrome fonts as well as colored fonts (e.g. for emoji).
     Supported formats are TTF, OTF, WOFF1 and WOFF2.
   - DynamicFont supports optional font outlines with adjustable width and color.
   - Support for font oversampling to keep fonts sharp at higher resolutions.

- GPU-based particles with support for custom particle shaders.
- CPU-based particles.

2D tools
^^^^^^^^

- 2D camera with built-in smoothing and drag margins.
- Path2D node to represent a path in 2D space.

   - Can be drawn in the editor or generated procedurally.
   - PathFollow2D node to make nodes follow a Path2D.

- 2D geometry helper class.
- Line2D node to draw textured 2D lines.

2D physics
^^^^^^^^^^

**Physics bodies:**

- Static bodies.
- Rigid bodies.
- Kinematic bodies.
- Joints.
- Areas to detect bodies entering or leaving it.

**Collision detection:**

- Built-in shapes: line, box, circle, capsule.
- Collision polygons (can be drawn manually or generated from a sprite in the editor).

3D graphics
^^^^^^^^^^^

**Two renderers available:**

- OpenGL ES 3.0 renderer (uses OpenGL 3.3 on desktop platforms).

   - High-end visuals. Recommended on desktop platforms.
   - Optional HDR rendering with sRGB (enabled by default).
   - Uses an optional depth prepass (enabled by default) to reduce the cost of
     overdraw, which speeds up complex scene rendering.

- OpenGL ES 2.0 renderer (uses OpenGL 2.1 on desktop platforms).

   - Recommended on mobile and Web platforms.
   - LDR rendering for greater compatibility.
   - Not all features are available. Features available only when using
     the OpenGL ES 3.0 renderer are marked *GLES3* below.

**Camera:**

- Perspective, orthographic and frustum-offset cameras.

**Physically-based rendering (built-in material features):**

- Follows the Disney PBR model.
- Supports Lambert, Lambert Wrap (half-Lambert), Oren-Nayar and Toon diffuse shading modes.
- Supports Schlick-GGX, Blinn, Phong, Toon and Disabled specular shading modes.
- Uses a roughness-metallic workflow with support for ORM textures.
- Uses horizon specular occlusion (Filament model) to improve material appearance
- Normal mapping.
- Detail mapping for the albedo and normal maps.
- Distance fade which can use alpha blending or dithering to avoid going through
  the transparent pipeline.
- Dithering can be determined on a per-pixel or per-object basis.
- *GLES3:* Parallax/relief mapping with automatic level of detail based on distance.
- *GLES3:* Sub-surface scattering and transmittance.
- *GLES3:* Screen-space refraction with support for material roughness (resulting in blurry refraction).
  On GLES2, refraction is still functional but lacks support for material roughness.
- *GLES3:* Proximity fade (soft particles).

**Real-time lighting:**

- Directional lights (sun/moon). Up to 4 per scene.
- Omnidirectional lights.
- Spot lights with adjustable cone angle and attenuation.
- Specular energy can be adjusted on a per-light basis.
- *GLES3:* Lighting is done with a single-pass forward approach.
  By default, up to 32 omni light and 32 spot lights can be displayed per mesh resource.
  If needed, this limit can be increased at the cost of increased shader compilation times and lower performance.
  GLES2 uses a multi-pass forward approach to lighting, which doesn't have a
  limit on the number of lights but is slower with many lights.

**Shadow mapping:**

- *DirectionalLight:* Orthogonal (fastest), PSSM 2-split and 4-split.
  Supports blending between splits.
- *OmniLight:* Dual paraboloid (fast) or cubemap (slower but more accurate).
  Supports colored projector textures in the form of panoramas.
- *SpotLight:* Single texture.

**Global illumination with indirect lighting:**

- Baked lightmaps (fast, but can't be updated at run-time).

   - Supports baking indirect light only or baking both direct and indirect lighting.
     The bake mode can be adjusted on a per-light basis to allow for hybrid light
     baking setups.
   - Supports lighting dynamic objects using an automatic octree-based system.
     No manual probe placement is required.
   - Lightmaps are baked on the CPU.

- *GLES3:* GI probes (slower, semi-real-time). Supports reflections.

**Reflections:**

- Fast baked reflections or slow real-time reflections using ReflectionProbe.
  Parallax box correction can optionally be enabled.
- Reflection techniques can be mixed together for greater accuracy or scalability.
- *GLES3:* Voxel-based reflections (when using GI probes).
- *GLES3:* Screen-space reflections.

**Sky:**

- Panorama sky (using an HDRI).
- Procedural sky.

**Fog:**

- Depth fog with an adjustable attenuation curve.
- Height fog (floor or ceiling) with adjustable attenuation.
- Support for automatic depth fog color depending on the camera direction
  (to match the sun color).
- Optional transmittance to make lights more visible in the fog.

**Particles:**

- CPU-based particles.
- *GLES3:* GPU-based particles with support for custom particle shaders.

**Post-processing:**

- Tonemapping (Linear, Reinhard, Filmic, ACES).
- Glow/bloom with optional bicubic upscaling and several blend modes available:
  Screen, Soft Light, Add, Replace.
- Color correction using an one-dimensional ramp.
- Brightness, contrast and saturation adjustments.
- *GLES3:* Automatic exposure adjustments based on viewport brightness.
- *GLES3:* Near and far depth of field.
- *GLES3:* Screen-space ambient occlusion (SSAO).
- *GLES3:* Optional debanding to avoid color banding (effective when HDR rendering is enabled).

**Texture filtering:**

- Nearest, bilinear, trilinear or anisotropic filtering.

**Texture compression:**

- Lossless or lossy WebP (does not save VRAM; only reduces storage size).
- S3TC (only supported on desktop platforms).
- ETC1 (recommended when using the GLES2 renderer).
- *GLES3:* BPTC for high-quality compression (not supported on macOS).
- *GLES3:* ETC2 (not supported on macOS).

**Anti-aliasing:**

- Multi-sample antialiasing (MSAA).
- Fast approximate antialiasing (FXAA).

**Performance:**

- Occlusion culling with :ref:`rooms and portals <doc_rooms_and_portals>`.
  Supports gameplay notifications with primary and secondary visibility to
  disable AI/physics processing for nodes that don't need it.
- Real-time occluder shapes (sphere and polygon). Not as effective as rooms and portals
  (and doesn't support gameplay notifications), but easier to set up.

.. note::

    Most of the effects listed above can be adjusted for better performance or
    to further improve quality. This can be helpful when using Godot for
    offline rendering.

3D tools
^^^^^^^^

- Built-in meshes: cube, cylinder/cone, (hemi)sphere, prism, plane, quad.
- Tools for :ref:`procedural geometry generation <doc_procedural_geometry>`.
- :ref:`Constructive solid geometry <doc_csg_tools>` (intended for prototyping).
- Path3D node to represent a path in 3D space.

   - Can be drawn in the editor or generated procedurally.
   - PathFollow3D node to make nodes follow a Path3D.

- 3D geometry helper class.
- Support for exporting the current scene as a glTF 2.0 file from the editor.

3D physics
^^^^^^^^^^

**Physics bodies:**

- Static bodies.
- Rigid bodies.
- Kinematic bodies.
- Vehicle bodies (intended for arcade physics, not simulation).
- Joints.
- Soft bodies.
- Ragdolls.
- Areas to detect bodies entering or leaving it.

**Collision detection:**

- Built-in shapes: cuboid, sphere, capsule, cylinder.
- Generate triangle collision shapes for any mesh from the editor.
- Generate one or several convex collision shapes for any mesh from the editor.

Shaders
^^^^^^^

- *2D:* Custom vertex, fragment, and light shaders.
- *3D:* Custom vertex, fragment, light, and sky shaders.
- Text-based shaders using a :ref:`shader language inspired by GLSL <doc_shading_language>`.
- Visual shader editor.

   - Support for visual shader plugins.

Scripting
^^^^^^^^^

**General:**

- Object-oriented design pattern with scripts extending nodes.
- Signals and groups for communicating between scripts.
- Support for :ref:`cross-language scripting <doc_cross_language_scripting>`.
- Many 2D and 3D linear algebra data types such as vectors and transforms.

:ref:`GDScript: <toc-learn-scripting-gdscript>`

- :ref:`High-level interpreted language <doc_gdscript>` with
  :ref:`optional static typing <doc_gdscript_static_typing>`.
- Syntax inspired by Python.
- Syntax highlighting is provided on GitHub.
- :ref:`Use threads <doc_using_multiple_threads>` to perform asynchronous actions
  or make use of multiple processor cores.

:ref:`C#: <toc-learn-scripting-C#>`

- Packaged in a separate binary to keep file sizes and dependencies down.
- Uses Mono 6.x.

   - Full support for the C# 7.0 syntax and features.

- Supports all platforms.
- Using an external editor is recommended to benefit from IDE functionality.

:ref:`VisualScript: <toc-learn-scripting-visual_script>`

- :ref:`Graph-based visual scripting language <doc_what_is_visual_script>`.
- Works best when used for specific purposes (such as level-specific logic)
  rather than as a language to create entire projects.

**GDNative (C, C++, Rust, D, ...):**

- When you need it, link to native libraries for higher performance and third-party integrations.

   - For scripting game logic, GDScript or C# are recommended if their
     performance is suitable.

- Official bindings for C and C++.

   - Use any build system and language features you wish.

- Maintained D, Kotlin, Python, Nim, and Rust bindings provided by the community.

.. warning::

    `Godot 4.0 will remove VisualScript from core entirely. <https://godotengine.org/article/godot-4-will-discontinue-visual-scripting>`__
    As a result, creating new projects using visual scripting in Godot is not recommended.
    Future Godot 4.x releases may have VisualScript reimplemented as an extension.

    While Godot 3.x will keep VisualScript supported, we recommend
    :ref:`trying out GDScript <toc-learn-scripting-gdscript>` instead,
    especially if you intend to migrate your project to Godot 4.

Audio
^^^^^

**Features:**

- Mono, stereo, 5.1 and 7.1 output.
- Non-positional and positional playback in 2D and 3D.

   - Optional Doppler effect in 2D and 3D.

- Support for re-routable :ref:`audio buses <doc_audio_buses>` and effects
  with dozens of effects included.
- Listener2D and Listener3D nodes to listen from a position different than the camera.
- Audio input to record microphones with real-time access using the AudioEffectCapture class.
- MIDI input.

   - No support for MIDI output yet.

**APIs used:**

- *Windows:* WASAPI.
- *macOS:* CoreAudio.
- *Linux:* PulseAudio or ALSA.

Import
^^^^^^

- Support for :ref:`custom import plugins <doc_import_plugins>`.

**Formats:**

- *Images:* See :ref:`doc_import_images`.
- *Audio:*

   - WAV with optional IMA-ADPCM compression.
   - Ogg Vorbis.
   - MP3.

- *3D scenes:*

   - glTF 2.0 *(recommended)*.
   - `ESCN <https://github.com/godotengine/godot-blender-exporter>`__
     (direct export from Blender).
   - FBX (experimental, static meshes only).
   - Collada (.dae).
   - Wavefront OBJ (static scenes only, can be loaded directly as a mesh).

- 3D meshes use `Mikktspace <http://www.mikktspace.com/>`__ to generate tangents
  on import, which ensures consistency with other 3D applications such as Blender.

Input
^^^^^

- Input mapping system using hardcoded input events or remappable input actions.

   - Axis values can be mapped to two different actions with a configurable deadzone.
   - Use the same code to support both keyboards and gamepads.

- Keyboard input.

   - Keys can be mapped in "physical" mode to be independent of the keyboard layout.

- Mouse input.

   - The mouse cursor can be visible, hidden, captured or confined within the window.
   - When captured, raw input will be used on Windows and Linux to
     sidestep the OS' mouse acceleration settings.

- Gamepad input (up to 8 simultaneous controllers).
- Pen/tablet input with pressure support.
- Gamepad, keyboard and mouse input support are also available on Android.

Navigation
^^^^^^^^^^

- A* algorithm in 2D and 3D.
- Navigation meshes with dynamic obstacle avoidance.
- Generate navigation meshes from the editor or at run-time (including from an exported project).

Networking
^^^^^^^^^^

- Low-level TCP networking using StreamPeer and TCP_Server.
- Low-level UDP networking using PacketPeer and UDPServer.
- Low-level HTTP requests using HTTPClient.
- High-level HTTP requests using HTTPRequest.

   - Supports HTTPS out of the box using bundled certificates.

- High-level multiplayer API using UDP and ENet.

   - Automatic replication using remote procedure calls (RPCs).
   - Supports unreliable, reliable and ordered transfers.

- WebSocket client and server, available on all platforms.
- WebRTC client and server, available on all platforms.
- Support for UPnP to sidestep the requirement to forward ports when hosting
  a server behind a NAT.

Internationalization
^^^^^^^^^^^^^^^^^^^^

- Full support for Unicode including emoji.
- Store localization strings using :ref:`CSV <doc_internationalizing_games>`
  or :ref:`gettext <doc_localization_using_gettext>`.
- Use localized strings in your project automatically in GUI elements or by
  using the ``tr()`` function.
- Support for right-to-left typesetting and text shaping planned in Godot 4.0.

Windowing and OS integration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Move, resize, minimize, and maximize the window spawned by the project.
- Change the window title and icon.
- Request attention (will cause the title bar to blink on most platforms).
- Fullscreen mode.

   - Doesn't use exclusive fullscreen, so the screen resolution can't be changed this way.
     Use a Viewport with a different resolution instead.

- Borderless window (fullscreen or non-fullscreen).
- Ability to keep the window always on top.
- Transparent window with per-pixel transparency.
- Global menu integration on macOS.
- Execute commands in a blocking or non-blocking manner.
- Open file paths and URLs using default or custom protocol handlers (if registered on the system).
- Parse custom command line arguments.
- :ref:`Headless/server binaries <doc_exporting_for_dedicated_servers>` can be
  downloaded for Linux and :ref:`compiled for macOS <doc_compiling_for_osx>`.
  Any binary can be used without a window using the ``--no-window``
  :ref:`command line argument <doc_command_line_tutorial>`.

Mobile
^^^^^^

- In-app purchases on Android and iOS.
- Support for advertisements using third-party modules.
- Support for subview embedding on Android.

XR support (AR and VR)
^^^^^^^^^^^^^^^^^^^^^^

- Support for ARKit on iOS out of the box.
- Support for the OpenXR APIs.

   - Includes support for popular headsets like the Meta Quest and the Valve Index.

- Support for the OpenVR APIs.

GUI system
^^^^^^^^^^

Godot's GUI is built using the same Control nodes used to make games in Godot.
The editor UI can easily be extended in many ways using add-ons.

**Nodes:**

- Buttons.
- Checkboxes, check buttons, radio buttons.
- Text entry using LineEdit (single line) and TextEdit (multiple lines).
- Dropdown menus using PopupMenu and OptionButton.
- Scrollbars.
- Labels.
- RichTextLabel for :ref:`text formatted using BBCode <doc_bbcode_in_richtextlabel>`.
- Trees (can also be used to represent tables).
- Color picker with RGB and HSV modes.
- Containers (horizontal, vertical, grid, flow, center, margin, aspect ratio, draggable splitter, ...).
- Controls can be rotated and scaled.

**Sizing:**

- Anchors to keep GUI elements in a specific corner, edge or centered.
- Containers to place GUI elements automatically following certain rules.

   - :ref:`Stack <class_BoxContainer>` layouts.
   - :ref:`Grid <class_GridContainer>` layouts.
   - :ref:`Margin <class_MarginContainer>` and :ref:`centered <class_CenterContainer>`
     layouts.
   - :ref:`Draggable splitter <class_SplitContainer>` layouts.

- Scale to multiple resolutions using the ``2d`` or ``viewport`` stretch modes.
- Support any aspect ratio using anchors and the ``expand`` stretch aspect.

**Theming:**

- Built-in theme editor.

   - Generate a theme based on the current editor theme settings.

- Procedural vector-based theming using :ref:`class_StyleBoxFlat`.

   - Supports rounded/beveled corners, drop shadows, per-border widths and antialiasing.

- Texture-based theming using :ref:`class_StyleBoxTexture`.

Godot's small distribution size can make it a suitable alternative to frameworks
like Electron or Qt.

Animation
^^^^^^^^^

- Direct kinematics and inverse kinematics.
- :ref:`Tween <class_Tween>` node to easily perform procedural animations by code.
- Support for animating any property with customizable interpolation.
- Support for calling methods in animation tracks.
- Support for playing sounds in animation tracks.
- Support for Bézier curves in animation.

File formats
^^^^^^^^^^^^

- Scenes and resources can be saved in :ref:`text-based <doc_tscn_file_format>` or binary formats.

   - Text-based formats are human-readable and more friendly to version control.
   - Binary formats are faster to save/load for large scenes/resources.

- Read and write text or binary files using :ref:`class_File`.

   - Can optionally be compressed or encrypted.

- Read and write :ref:`class_JSON` files.
- Read and write INI-style configuration files using :ref:`class_ConfigFile`.

   - Can (de)serialize any Godot datatype, including Vector2/3, Color, ...

- Read XML files using :ref:`class_XMLParser`.
- Pack game data into a PCK file (custom format optimized for fast seeking),
  into a ZIP archive, or directly into the executable for single-file distribution.
- :ref:`Export additional PCK files<doc_exporting_pcks>` that can be read
  by the engine to support mods and DLCs.

Miscellaneous
^^^^^^^^^^^^^

- :ref:`Low-level access to servers <doc_using_servers>` which allows bypassing
  the scene tree's overhead when needed.
- :ref:`Command line interface <doc_command_line_tutorial>` for automation.

   - Export and deploy projects using continuous integration platforms.
   - `Shell completion scripts <https://github.com/godotengine/godot/tree/master/misc/dist/shell>`__
     are available for Bash, zsh and fish.

- Support for :ref:`C++ modules <doc_custom_modules_in_c++>` statically linked
  into the engine binary.
- Engine and editor written in C++03.

   - Can be :ref:`compiled <doc_introduction_to_the_buildsystem>` using GCC,
     Clang and MSVC. MinGW is also supported.
   - Friendly towards packagers. In most cases, system libraries can be used
     instead of the ones provided by Godot. The build system doesn't download anything.
     Builds can be fully reproducible.
   - Godot 4.0 will be written in C++17.

- Licensed under the permissive MIT license.

   - Open developement process with :ref:`contributions welcome <doc_ways_to_contribute>`.

.. seealso::

    The `Godot proposals repository <https://github.com/godotengine/godot-proposals>`__
    lists features that have been requested by the community and may be implemented
    in future Godot releases.


===================================================
/. ./about/docs_changelog.rst
===================================================

.. _doc_docs_changelog:

Documentation changelog
=======================

The documentation is continually being improved. The release of version 3.2
includes many new tutorials, many fixes and updates for old tutorials, and many updates
to the :ref:`class reference <doc_class_reference>`. Below is a list of new tutorials
added since version 3.1.

.. note:: This document only contains new tutorials so not all changes are reflected,
          many tutorials have been substantially updated but are not reflected in this document.

New tutorials since version 3.1
-------------------------------

Project workflow
^^^^^^^^^^^^^^^^

- :ref:`doc_android_custom_build`

2D
^^

- :ref:`doc_2d_sprite_animation`

Audio
^^^^^

- :ref:`doc_recording_with_microphone`
- :ref:`doc_sync_with_audio`

Math
^^^^

- :ref:`doc_beziers_and_curves`
- :ref:`doc_interpolation`

Inputs
^^^^^^

- :ref:`doc_input_examples`

Internationalization
^^^^^^^^^^^^^^^^^^^^

- :ref:`doc_localization_using_gettext`

Shading
^^^^^^^

- Your First Shader Series:
    - :ref:`doc_introduction_to_shaders`
    - :ref:`doc_your_first_canvasitem_shader`
    - :ref:`doc_your_first_spatial_shader`
    - :ref:`doc_your_second_spatial_shader`
- :ref:`doc_visual_shaders`

Networking
^^^^^^^^^^

- :ref:`doc_webrtc`

VR
^^

- :ref:`doc_vr_starter_tutorial_part_one`
- :ref:`doc_vr_starter_tutorial_part_two`

Plugins
^^^^^^^

- :ref:`doc_android_plugin`
- :ref:`doc_inspector_plugins`
- :ref:`doc_visual_shader_plugins`

Multi-threading
^^^^^^^^^^^^^^^

- :ref:`doc_using_multiple_threads`

Creating content
^^^^^^^^^^^^^^^^

Procedural geometry series:
  - :ref:`Procedural geometry <toc-procedural_geometry>`
  - :ref:`doc_arraymesh`
  - :ref:`doc_surfacetool`
  - :ref:`doc_meshdatatool`
  - :ref:`doc_immediategeometry`

Optimization
^^^^^^^^^^^^

- :ref:`doc_using_multimesh`
- :ref:`doc_using_servers`

Legal
^^^^^

- :ref:`doc_complying_with_licenses`

New tutorials since version 3.0
-------------------------------

Step by step
^^^^^^^^^^^^

- :ref:`doc_signals`
- :ref:`doc_exporting_basics`

Scripting
^^^^^^^^^

- :ref:`doc_gdscript_static_typing`

Project workflow
^^^^^^^^^^^^^^^^

Best Practices:

- :ref:`doc_introduction_best_practices`
- :ref:`doc_what_are_godot_classes`
- :ref:`doc_scene_organization`
- :ref:`doc_scenes_versus_scripts`
- :ref:`doc_autoloads_versus_internal_nodes`
- :ref:`doc_node_alternatives`
- :ref:`doc_godot_interfaces`
- :ref:`doc_godot_notifications`
- :ref:`doc_data_preferences`
- :ref:`doc_logic_preferences`

2D
^^

- :ref:`doc_2d_lights_and_shadows`
- :ref:`doc_2d_meshes`

3D
^^

- :ref:`doc_csg_tools`
- :ref:`doc_animating_thousands_of_fish`
- :ref:`doc_controlling_thousands_of_fish`

Physics
^^^^^^^

- :ref:`doc_ragdoll_system`
- :ref:`doc_soft_body`

Animation
^^^^^^^^^

- :ref:`doc_2d_skeletons`
- :ref:`doc_animation_tree`

GUI
^^^

- :ref:`doc_gui_containers`

Viewports
^^^^^^^^^

- :ref:`doc_viewport_as_texture`
- :ref:`doc_custom_postprocessing`

Shading
^^^^^^^

- :ref:`doc_converting_glsl_to_godot_shaders`
- :ref:`doc_advanced_postprocessing`

Shading Reference:

- :ref:`doc_introduction_to_shaders`
- :ref:`doc_shading_language`
- :ref:`doc_spatial_shader`
- :ref:`doc_canvas_item_shader`
- :ref:`doc_particle_shader`

Plugins
^^^^^^^

- :ref:`doc_making_main_screen_plugins`
- :ref:`doc_spatial_gizmo_plugins`

Platform-specific
^^^^^^^^^^^^^^^^^

- :ref:`doc_customizing_html5_shell`

Multi-threading
^^^^^^^^^^^^^^^

- :ref:`doc_thread_safe_apis`

Creating content
^^^^^^^^^^^^^^^^

- :ref:`doc_making_trees`

Miscellaneous
^^^^^^^^^^^^^

- :ref:`doc_jitter_stutter`
- :ref:`doc_running_code_in_the_editor`
- :ref:`doc_change_scenes_manually`
- :ref:`doc_gles2_gles3_differences`

Compiling
^^^^^^^^^

- :ref:`doc_optimizing_for_size`
- :ref:`doc_compiling_with_script_encryption_key`

Engine development
^^^^^^^^^^^^^^^^^^

- :ref:`doc_binding_to_external_libraries`


===================================================
/. ./about/release_policy.rst
===================================================

.. _doc_release_policy:

Godot release policy
====================

Godot's release policy is in constant evolution. What is described below is
intended to give a general idea of what to expect, but what will actually
happen depends on the choices of core contributors, and the needs of the
community at a given time.

Godot versioning
----------------

Godot loosely follows `Semantic Versioning <https://semver.org/>`__ with a
``major.minor.patch`` versioning system, albeit with an interpretation of each
term adapted to the complexity of a game engine:

- The ``major`` version is incremented when major compatibility breakages happen
  which imply significant porting work to move projects from one major version
  to another.

  For example, porting Godot projects from Godot 2.1 to Godot 3.0 required
  running the project through a conversion tool, and then performing a number
  of further adjustments manually for what the tool could not do automatically.

- The ``minor`` version is incremented for feature releases which do not break
  compatibility in a major way. Minor compatibility breakage in very specific
  areas *may* happen in minor versions, but the vast majority of projects
  should not be affected or require significant porting work.

  The reason for this is that as a game engine, Godot covers many areas such
  as rendering, physics, scripting, etc., and fixing bugs or implementing new
  features in a given area may sometimes require changing the behavior of a
  feature, or modifying the interface of a given class, even if the rest of
  the engine API remains backwards compatible.

.. tip::

    Upgrading to a new minor version is therefore recommended for all users,
    but some testing is necessary to ensure that your project still behaves as
    expected in a new minor version.

- The ``patch`` version is incremented for maintenance releases which focus on
  fixing bugs and security issues, implementing new requirements for platform
  support, and backporting safe usability enhancements. Patch releases are
  backwards compatible.

  Patch versions may include minor new features which do not impact the
  existing API, and thus have no risk of impacting existing projects.

.. tip::

    Updating to new patch versions is therefore considered safe and strongly
    recommended to all users of a given stable branch.

We call ``major.minor`` combinations *stable branches*. Each stable branch
starts with a ``major.minor`` release (without the ``0`` for ``patch``) and is
further developed for maintenance releases in a Git branch of the same name
(for example patch updates for the 3.3 stable branch are developed in the
``3.3`` Git branch).

.. note::

    As mentioned in the introduction, Godot's release policy is evolving, and
    earlier Godot releases may not have followed the above rules to the letter.
    In particular, the 3.2 stable branch received a number of new features in
    3.2.2 which would have warranted a ``minor`` version increment.

Release support timeline
------------------------

Stable branches are supported *at minimum* until the next stable branch is
released and has received its first patch update. In practice, we support
stable branches on a *best effort* basis for as long as they have active users
who need maintenance updates.

Whenever a new major version is released, we make the previous stable branch a
long-term supported release, and do our best to provide fixes for issues
encountered by users of that branch who cannot port complex projects to the new
major version. This was the case for the 2.1 branch, and will be the case for
the latest 3.x stable branch by the time Godot 4.0 is released.

In a given minor release series, only the latest patch release receives support.
If you experience an issue using an older patch release, please upgrade to the
latest patch release of that series and test again before reporting an issue
on GitHub.

+-------------+----------------------+--------------------------------------------------------------------------+
| **Version** | **Release date**     | **Support level**                                                        |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 4.0   | Q1 2023 (estimate)   | |unstable| *Beta.* Current focus of development (unstable).              |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.6   | Q1-Q2 2023 (estimate)| |supported| *Beta.* Receives new features as well as bug fixes while     |
| (LTS)       |                      | under development. Will be released *after* 4.0.                         |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.5   | August 2022          | |supported| Receives fixes for bugs, security and platform support       |
|             |                      | issues, as well as backwards-compatible usability enhancements.          |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.4   | November 2021        | |partial| Receives fixes for security and platform support issues only.  |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.3   | April 2021           | |eol| No longer supported as fully superseded by the compatible 3.4      |
|             |                      | release (last update: 3.3.4).                                            |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.2   | January 2020         | |eol| No longer supported (last update: 3.2.3).                          |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.1   | March 2019           | |eol| No longer supported (last update: 3.1.2).                          |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 3.0   | January 2018         | |eol| No longer supported (last update: 3.0.6).                          |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 2.1   | July 2016            | |eol| No longer supported (last update: 2.1.6).                          |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 2.0   | February 2016        | |eol| No longer supported (last update: 2.0.4.1).                        |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 1.1   | May 2015             | |eol| No longer supported.                                               |
+-------------+----------------------+--------------------------------------------------------------------------+
| Godot 1.0   | December 2014        | |eol| No longer supported.                                               |
+-------------+----------------------+--------------------------------------------------------------------------+

.. |supported| image:: img/supported.png
.. |partial| image:: img/partial.png
.. |eol| image:: img/eol.png
.. |unstable| image:: img/unstable.png

**Legend:**
|supported| Full support –
|partial| Partial support –
|eol| No support (end of life) –
|unstable| Development version

Pre-release Godot versions aren't intended to be used in production and are
provided for testing purposes only.

.. _doc_release_policy_when_is_next_release_out:

When is the next release out?
-----------------------------

While Godot contributors aren't working under any deadlines, we strive to
publish minor releases relatively frequently, with an average of two 3.x minor
releases per year since Godot 3.3.

Maintenance (patch) releases are released as needed with potentially very
short development cycles, to provide users of the current stable branch with
the latest bug fixes for their production needs.

As for the upcoming Godot 4.0, as of December 2022, we are well into the *beta*
phase, and are aiming for a stable release in Q1 2023.
`Follow the Godot blog <https://godotengine.org/news>`__ for the latest updates.


===================================================
/. ./about/complying_with_licenses.rst
===================================================

.. _doc_complying_with_licenses:

Complying with licenses
=======================

What are licenses?
------------------

Godot is created and distributed under the `MIT License <https://opensource.org/licenses/MIT>`_.
It doesn't have a sole owner either, as every contributor that submits code to
the project does it under this same license and keeps ownership of the
contribution.

The license is the legal requirement for you (or your company) to use and
distribute the software (and derivative projects, including games made with it).
Your game or project can have a different license, but it still needs to comply
with the original one.

.. warning::

    In your project's credits screen, remember to also list third-party notices
    for assets you're using, such as textures, models, sounds, music and fonts.

    Free assets in particular often come with licenses that require attribution.
    Double-check their license before using those assets in a project.

Requirements
------------

In the case of the MIT license, the only requirement is to include the license
text somewhere in your game or derivative project.

This text reads as follows:

    This game uses Godot Engine, available under the following license:

    Copyright (c) 2014-present Godot Engine contributors.
    Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

.. note::

    Your games do not need to be under the same license. You are free to release
    your Godot projects under any license and to create commercial games with
    the engine.

Inclusion
---------

The license does not specify how it has to be included, so anything is valid as
long as it can be displayed under some condition. These are the most common
approaches (only need to implement one of them, not all).

Credits screen
^^^^^^^^^^^^^^

Include the above license text somewhere in the credits screen. It can be at the
bottom after showing the rest of the credits. Most large studios use this
approach with open source licenses.

Licenses screen
^^^^^^^^^^^^^^^

Some games have a special menu (often in the settings) to display licenses.

Output log
^^^^^^^^^^

Just printing the licensing text using the :ref:`print() <class_@GDScript_method_print>`
function may be enough on platforms where a global output log is readable.
This is the case on desktop platforms, Android and HTML5 (but not iOS and UWP).

Accompanying file
^^^^^^^^^^^^^^^^^

If the game is distributed on desktop platforms, a file containing the license
can be added to the software that is installed to the user PC.

Printed manual
^^^^^^^^^^^^^^

If the game includes printed manuals, license text can be included there.

Link to the license
^^^^^^^^^^^^^^^^^^^

The Godot Engine developers consider that a link to ``godotengine.org/license``
in your game documentation or credits would be an acceptable way to satisfy
the license terms.

Third-party licenses
--------------------

Godot itself contains software written by
`third parties <https://github.com/godotengine/godot/blob/master/COPYRIGHT.txt>`_.
Most of it does not require license inclusion, but some do.
Make sure to do it if these are compiled in your Godot export template. If
you're using the official export templates, all libraries are enabled. This
means you need to provide attribution for all the libraries listed below.

Here's a list of libraries requiring attribution:

FreeType
^^^^^^^^

Godot uses `FreeType <https://www.freetype.org/>`_ to render fonts. Its license
requires attribution, so the following text must be included together with the
Godot license:

    Portions of this software are copyright © <year> The FreeType Project (www.freetype.org).  All rights reserved.

.. note::

    <year> should correspond to the value from the FreeType version used
    in your build. This information can be found in the editor by opening
    the **Help > About** dialog and going to the **Third-party Licenses**
    tab.

ENet
^^^^

Godot includes the `ENet <http://enet.bespin.org/>`_ library to handle
high-level multiplayer. ENet has similar licensing terms as Godot:


    Copyright (c) 2002-2020 Lee Salzman

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

mbed TLS
^^^^^^^^

If the project is exported with Godot 3.1 or later, it includes `mbed TLS <https://tls.mbed.org>`_.
The Apache license needs to be complied to by including the following text:

    Copyright The Mbed TLS Contributors

    Licensed under the Apache License, Version 2.0 (the "License"); you may
    not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

.. note::

    If you exported your project using a
    :ref:`custom build with specific modules disabled <doc_optimizing_for_size>`,
    you don't need to list the disabled modules' licenses in your exported project.


===================================================
/. ./getting_started/introduction/index.rst
===================================================

.. Intention: provide the necessary information to make the most of the getting
   started series, answering questions like "do I want to learn Godot?", "how
   does it look and feel?", "how does it work?", and "how do I best learn it?".

Introduction
============

This series will introduce you to Godot and give you an overview of its
features.

In the following pages, you will get answers to questions such as "Is Godot for
me?" or "What can I do with Godot?". We will then introduce the engine's most
essential concepts, run you through the editor's interface, and give you tips to
make the most of your time learning it.

.. toctree::
   :maxdepth: 1
   :name: toc-learn-introduction

   introduction_to_godot
   learn_to_code_with_gdscript
   key_concepts_overview
   first_look_at_the_editor
   learning_new_features
   godot_design_philosophy


===================================================
/. ./getting_started/introduction/introduction_to_godot.rst
===================================================

.. _doc_introduction_to_godot:

Introduction to Godot
=====================

This article is here to help you figure out whether Godot might be a good fit
for you. We will introduce some broad features of the engine to give you a feel
for what you can achieve with it and answer questions such as "what do I need to
know to get started?".

This is by no means an exhaustive overview. We will introduce many more features
in this getting started series.

What is Godot?
--------------

Godot is a general-purpose 2D and 3D game engine designed to support all sorts
of projects. You can use it to create games or applications you can then release
on desktop or mobile, as well as on the web.

You can also create console games with it, although you either need strong
programming skills or a developer to port the game for you.

.. note:: The Godot team can't provide an open-source console export due to the
          licensing terms imposed by console manufacturers. Regardless of the
          engine you use, though, releasing games on consoles is always a lot of
          work. You can read more on that here: :ref:`doc_consoles`.

What can the engine do?
-----------------------

Godot was initially developed in-house by an Argentinan game studio. Its
development started in 2001, and the engine was rewritten and improved
tremendously since its open-source release in 2014.

Some examples of games created with Godot include Ex-Zodiac and Helms of Fury.

.. image:: img/introduction_ex_zodiac.png

.. image:: img/introduction_helms_of_fury.jpg

As for applications, the open-source pixel art drawing program Pixelorama is
powered by Godot, and so is the voxel RPG creator RPG in a box.

.. image:: img/introduction_rpg_in_a_box.png

You can find many more examples in the `official showcase videos`_.

How does it work and look?
--------------------------

Godot comes with a fully-fledged game editor with integrated tools to answer the
most common needs. It includes a code editor, an animation editor, a tilemap
editor, a shader editor, a debugger, a profiler, and more.

.. image:: img/introduction_editor.png

The team strives to offer a feature-rich game editor with a consistent user
experience. While there is always room for improvement, the user interface keeps
getting refined.

Of course, if you prefer, you can work with external programs. We officially
support importing 3D scenes designed in Blender_ and maintain plugins to code in
VSCode_ and Emacs_ for GDScript and C#. We also support Visual Studio for C# on
Windows.

.. image:: img/introduction_vscode.png

Programming languages
---------------------

Let's talk about the available programming languages.

You can code your games using :ref:`GDScript <toc-learn-scripting-gdscript>`, a
Godot-specific and tightly integrated language with a lightweight syntax, or
:ref:`C# <toc-learn-scripting-C#>`, which is popular in the games industry.
These are the two main scripting languages we support.

Godot also supports a node-based visual programming language named
:ref:`VisualScript <toc-learn-scripting-visual_script>`.

With the :ref:`GDNative <toc-tutorials-gdnative>` technology, you can also write
gameplay or high-performance algorithms in C or C++ without recompiling the
engine. You can use this technology to integrate third-party libraries and other
Software Development Kits (SDK) in the engine.

Of course, you can also directly add modules and features to the engine, as it's
completely free and open-source.

.. seealso:: These are the five officially supported programming languages. The
             community maintains support for many more. For more information,
             see :ref:`GDNative third-party bindings
             <doc_what_is_gdnative_third_party_bindings>`.

What do I need to know to use Godot?
------------------------------------

Godot is a feature-packed game engine. With its thousands of features, there is
a lot to learn. To make the most of it, you need good programming foundations.
While we try to make the engine accessible, you will benefit a lot from knowing
how to think like a programmer first.

In the next part, we'll show you a free and open-source app you can use to learn
the basics of programming with Godot's GDScript programming language.

.. _Blender: https://www.blender.org/
.. _VSCode: https://github.com/godotengine/godot-vscode-plugin
.. _Emacs: https://github.com/godotengine/emacs-gdscript-mode
.. _official showcase videos: https://www.youtube.com/playlist?list=PLeG_dAglpVo6EpaO9A1nkwJZOwrfiLdQ8


===================================================
/. ./getting_started/introduction/learn_to_code_with_gdscript.rst
===================================================

.. _doc_learn_to_code_with_gdscript:

Learn to code with GDScript
===========================

In Godot, you can write code using the GDScript and C# programming languages.

If you are new to programming, we recommend starting with GDScript because we
designed it to be simpler than all-purpose languages like C#. It will be both
faster and easier to learn.

While GDScript is a language specific to Godot, the techniques you will learn
with it will apply to other programming languages.

Note that it is completely normal for a programmer to learn and use multiple
languages. Programming languages have more similarities than differences, so
once you know one, you can learn another much faster.

Learn in your browser with the GDScript app
-------------------------------------------

To learn GDScript, you can use the app Learn GDScript From Zero. It is a
complete beginner course with interactive practices you can do right in your
browser.

.. image:: img/learn_gdscript_app.png

Click here to access the app: `Learn GDScript From Zero app`_

This app is an open-source project. To report bugs or contribute, head to the
app's source code repository: `GitHub repository`_.

In the next part, you will get an overview of the engine's essential concepts.

.. _Learn GDScript From Zero app: https://gdquest.github.io/learn-gdscript/?ref=godot-docs
.. _GitHub repository: https://github.com/GDQuest/learn-gdscript


===================================================
/. ./getting_started/introduction/key_concepts_overview.rst
===================================================

.. Intention: introduce only a handful of key concepts and avoid a big cognitive
   load. Readers will then be reminded of the concepts further in the getting
   started series, reinforcing their learning.

.. _doc_key_concepts_overview:

Overview of Godot's key concepts
================================

Every game engine revolves around abstractions you use to build your
applications. In Godot, a game is a **tree** of **nodes** that you group
together into **scenes**. You can then wire these nodes so they can communicate
using **signals**.

These are the four concepts you will learn here. We're going to look at them
briefly to give you a sense of how the engine works. In the getting started
series, you will get to use them in practice.

Scenes
------

In Godot, you break down your game in reusable scenes. A scene can be a character,
a weapon, a menu in the user interface, a single house, an entire level, or
anything you can think of. Godot's scenes are flexible; they fill the role of
both prefabs and scenes in some other game engines.

.. image:: img/key_concepts_main_menu.png

You can also nest scenes. For example, you can put your character in a level,
and drag and drop a scene as a child of it.

.. image:: img/key_concepts_scene_example.png

Nodes
-----

A scene is composed of one or more **nodes**. Nodes are your game's smallest
building blocks that you arrange into trees. Here's an example of a character's
nodes.

.. image:: img/key_concepts_character_nodes.png

It is made of a ``KinematicBody2D`` node named "Character", a ``Sprite``, a
``Camera2D``, and a ``CollisionShape2D``.

.. note:: The node names end with "2D" because this is a 2D scene. Their 3D
          counterpart have names that end with "3D".

Notice how nodes and scenes look the same in the editor. When you save a tree of
nodes as a scene, it then shows as a single node, with its internal structure
hidden in the editor.

Godot provides an extensive library of base node types you can combine and
extend to build more powerful ones. 2D, 3D, or user interface, you will do most
things with these nodes.

.. image:: img/key_concepts_node_menu.png

The scene tree
--------------

All your game's scenes come together in the **scene tree**, literally a tree of
scenes. And as scenes are trees of nodes, the scene tree also is a tree of
nodes. But it's easier to think of your game in terms of scenes as they can
represent characters, weapons, doors, or your user interface.

.. image:: img/key_concepts_scene_tree.png

Signals
-------

Nodes emit signals when some event occurs. This feature allows you to make
nodes communicate without hard-wiring them in code. It gives you a lot of
flexibility in how you structure your scenes.

.. image:: img/key_concepts_signals.png

.. note:: Signals are Godot's version of the *observer* pattern. You can read
          more about it here:
          https://gameprogrammingpatterns.com/observer.html

For example, buttons emit a signal when pressed. You can connect to this signal
to run code in reaction to this event, like starting the game or opening a menu.

Other built-in signals can tell you when two objects collided, when a character
or monster entered a given area, and much more. You can also define new signals
tailored to your game.

Summary
-------

Nodes, scenes, the scene tree, and signals are four core concepts in Godot that
you will manipulate all the time.

Nodes are your game's smallest building blocks. You combine them to create scenes
that you then combine and nest into the scene tree. You can then use signals to
make nodes react to events in other nodes or different scene tree branches.

After this short breakdown, you probably have many questions. Bear with us as
you will get many answers throughout the getting started series.


===================================================
/. ./getting_started/introduction/first_look_at_the_editor.rst
===================================================

.. This page is only here to introduce the interface to the user broadly. To
   cover individual areas in greater detail, write the corresponding pages in
   the most appropriate section, and link them. E.g. the animation editor goes
   to the animation section. General pages, for instance, about the project
   manager, should go in the editor manual.

.. _doc_intro_to_the_editor_interface:

First look at Godot's editor
============================

This page will give you a brief overview of Godot's interface. We're going to
look at the different main screens and docks to help you situate yourself.

.. seealso:: For a comprehensive breakdown of the editor's interface and how to
             use it, see the :ref:`Editor manual <toc-learn-editor>`.

The Project manager
-------------------

When you launch Godot, the first window you see is the Project Manager. In the
default tab, "Projects," you can manage existing projects, import or create new
ones, and more.

.. image:: img/editor_intro_project_manager.png

At the top of the window, there is another tab named "Asset Library Projects".
In the open-source asset library you can search for demo projects, templates,
and completed projects, including many that are developed by the community.

.. image:: img/editor_intro_project_templates.png

You can also change the editor's language using the drop-down menu to the right
of the engine's version in the window's top-right corner. By default, it is in
English (EN).

.. image:: img/editor_intro_language.png

First look at Godot's editor
----------------------------

When you open a new or an existing project, the editor's interface appears.
Let's look at its main areas.

.. image:: img/editor_intro_editor_empty.png

By default, it features **menus**, **main screens**, and playtest buttons along
the window's top edge.

.. image:: img/editor_intro_top_menus.png

In the center is the **viewport** with its **toolbar** at the top, where you'll
find tools to move, scale, or lock the scene's nodes.

.. image:: img/editor_intro_3d_viewport.png

On either side of the viewport sit the **docks**. And at the bottom of the
window lies the **bottom panel**.

The toolbar changes based on the context and selected node. Here is the 2D toolbar.

.. image:: img/editor_intro_toolbar_2d.png

Below is the 3D one.

.. image:: img/editor_intro_toolbar_3d.png

Let's look at the docks. The **FileSystem** dock lists your project files, be it
scripts, images, audio samples, and more.

.. image:: img/editor_intro_filesystem_dock.png

The **Scene** dock lists the active scene's nodes.

.. image:: img/editor_intro_scene_dock.png

The **Inspector** allows you to edit the properties of a selected node.

.. image:: img/editor_intro_inspector_dock.png

The **bottom panel**, situated below the viewport, is the host for the debug
console, the animation editor, the audio mixer, and more. They can take precious
space, that's why they're folded by default.

.. image:: img/editor_intro_bottom_panels.png

When you click on one, it expands vertically. Below, you can see the animation editor opened.

.. image:: img/editor_intro_bottom_panel_animation.png

The four main screens
---------------------

There are four main screen buttons centered at the top of the editor:
2D, 3D, Script, and AssetLib.

You'll use the **2D screen** for all types of games. In addition to 2D games,
the 2D screen is where you'll build your interfaces.

.. image:: img/editor_intro_workspace_2d.png

In the **3D screen**, you can work with meshes, lights, and design levels for
3D games.

.. image:: img/editor_intro_workspace_3d.png

Notice the perspective button under the toolbar. Clicking on it opens a list of
options related to the 3D view.

.. image:: img/editor_intro_3d_viewport_perspective.png

.. note:: Read :ref:`doc_introduction_to_3d` for more detail about the **3D
          main screen**.

The **Script screen** is a complete code editor with a debugger, rich
auto-completion, and built-in code reference.

.. image:: img/editor_intro_workspace_script.png

Finally, the **AssetLib** is a library of free and open-source add-ons, scripts,
and assets to use in your projects.

.. image:: img/editor_intro_workspace_assetlib.png

.. seealso:: You can learn more about the asset library in
             :ref:`doc_what_is_assetlib`.

Integrated class reference
--------------------------

Godot comes with a built-in class reference.

You can search for information about a class, method, property, constant, or
signal by any one of the following methods:

* Pressing :kbd:`F1` (or :kbd:`Alt + Space` on macOS) anywhere in the editor.
* Clicking the "Search Help" button in the top-right of the Script main screen.
* Clicking on the Help menu and Search Help.
* Clicking while pressing the :kbd:`Ctrl` key on a class name, function name, 
  or built-in variable in the script editor.


.. image:: img/editor_intro_search_help_button.png

When you do any of these, a window pops up. Type to search for any item. You can
also use it to browse available objects and methods.

.. image:: img/editor_intro_search_help.png

Double-click on an item to open the corresponding page in the script main screen.

.. image:: img/editor_intro_help_class_animated_sprite.png


===================================================
/. ./getting_started/introduction/learning_new_features.rst
===================================================

.. Keep this page short and sweet! We want users to read it to the end, so they
   know where to find information, how to get help, and how to maximize chances
   of getting answers.

.. _doc_learning_new_features:

Learning new features
=====================

Godot is a feature-rich game engine. There is a lot to learn about it. This page
explains how you can use the online manual, built-in code reference, and join
online communities to learn new features and techniques.

Making the most of this manual
------------------------------

What you are reading now is the user manual. It documents each of the engine's
concepts and available features. When learning a new topic, you can start by
browsing the corresponding section of this website. The left menu allows you to
explore broad topics while the search bar will help you find more specific
pages. If a page exists for a given theme, it will often link to more related
content.

.. image:: img/manual_search.png

The manual has a companion class reference that explains each Godot class's
available functions and properties when programming. While the manual covers
general features, concepts, and how to use the editor, the reference is all
about using Godot's scripting API (Application Programming Interface). You can
access it both online and offline. We recommend browsing the reference offline,
from within the Godot editor. To do so, go to Help -> Search or press
:kbd:`F1`.

.. image:: img/manual_class_reference_search.png

To browse it online, head to the manual's :ref:`Class Reference <doc_class_reference>`
section.

A class reference's page tells you:

1. Where the class exists in the inheritance hierarchy. You can click the top
   links to jump to parent classes and see the properties and methods a type
   inherits.

   .. image:: img/manual_class_reference_inheritance.png

2. A summary of the class's role and use cases.

3. An explanation of the class's properties, methods, signals, enums, and
   constants.

4. Links to manual pages further detailing the class.

.. note:: If the manual or class reference is missing or has insufficient
          information, please open an Issue in the official `godot-docs
          <https://github.com/godotengine/godot-docs/issues>`_ GitHub repository
          to report it.

You can Ctrl-click any underlined text like the name of a class, property,
method, signal, or constant to jump to it.

Learning with the community
---------------------------

Godot has a growing community of users. If you're stuck on a problem or need
help to better understand how to achieve something, you can ask other users for
help on one of the many `active
communities <https://godotengine.org/community>`_.

The best place to ask for questions and find already answered ones is the
official `Questions & Answers <https://godotengine.org/qa/>`_ site. These
responses show up in search engine results and get saved, allowing other users
to benefit from discussions on the platform. Once you asked a question there,
you can share its link on other social platforms. Before asking a question, be
sure to look for existing answers that might solve your problem on this website
or using your preferred search engine.

Asking questions well and providing details will help others answer you faster
and better. When asking questions, we recommend including the following
information:

1. **Describe your goal**. You want to explain what you are trying to achieve
   design-wise. If you are having trouble figuring out how to make a solution
   work, there may be a different, easier solution that accomplishes the same
   goal.

2. If there is an error involved, **share the exact error message**. You
   can copy the exact error message in the editor's Debugger bottom panel by
   clicking the Copy Error icon. Knowing what it says can help community members
   better identify how you triggered the error.

3. If there is code involved, **share a code sample**. Other users won't be able
   to help you fix a problem without seeing your code. Share the code as text
   directly. To do so, you can copy and paste a short code snippet in a chat
   box, or use a website like `Pastebin <https://pastebin.com/>`_ to share long
   files.

4. **Share a screenshot** of your *Scene* dock along with your written code. Most of
   the code you write affects nodes in your scenes. As a result, you should
   think of those scenes as part of your source code.

   .. image:: img/key_concepts_scene_tree.png

   Also, please don't take a picture with your phone, the low quality and screen
   reflections can make it hard to understand the image. Your operating system
   should have a built-in tool to take screenshots with the :kbd:`PrtSc` (Print
   Screen) key.

   Alternatively, you can use a program like `ShareX <https://getsharex.com/>`_
   on Windows or `FlameShot <https://flameshot.org/>`_ on Linux.

5. Sharing a video of your running game can also be really **useful to
   troubleshoot your game**. You can use programs like `OBS Studio
   <https://obsproject.com/>`_ and `Screen to GIF
   <https://www.screentogif.com/>`_ to capture your screen.

   You can then use a service like `streamable <https://streamable.com/>`_ or a
   cloud provider to upload and share your videos for free.

6. If you're not using the stable version of Godot, please mention the version
   you're using. The answer can be different as available features and the
   interface evolve rapidly.

Following these guidelines will maximize your chances of getting the answer
you're looking for. They will save time both to you and the persons helping you.

Community tutorials
-------------------

This manual aims to provide a comprehensive reference of Godot's features. Aside
from the 2D and 3D getting started series, it does not contain tutorials to
implement specific game genres. If you're looking for a tutorial about creating
a role-playing game, a platformer, or other, please see
:ref:`doc_community_tutorials`, which lists content made by the Godot community.


===================================================
/. ./getting_started/introduction/godot_design_philosophy.rst
===================================================

.. _doc_godot_design_philosophy:

Godot's design philosophy
=========================

Now that you've gotten your feet wet, let's talk about Godot's design.

**Every game engine is different and fits different needs.**
Not only do they offer a range of features, but the design of each engine
is unique. This leads to different workflows and different ways to form
your games' structures. This all stems from their respective design philosophies.

This page is here to help you understand how Godot works, starting
with some of its core pillars. It is not a list of available features, nor
is it an engine comparison. To know if any engine can be a good fit for
your project, you need to try it out for yourself and
understand its design and limitations.

Please watch
`Godot explained in 5 minutes <https://www.youtube.com/watch?v=KjX5llYZ5eQ>`_
if you're looking for an overview of the engine's features.

Object-oriented design and composition
--------------------------------------

Godot embraces object-oriented design at its core with its flexible
scene system and Node hierarchy. It tries to stay away from strict
programming patterns to offer an intuitive way to structure your game.

For one, Godot lets you **compose or aggregate** scenes.
It's like nested prefabs: you can create a BlinkingLight scene and
a BrokenLantern scene that uses the BlinkingLight.
Then, create a city filled with BrokenLanterns.
Change the BlinkingLight's color, save, and all the
BrokenLanterns in the city will update instantly.

On top of that, you can **inherit** from any scene.

A Godot scene could be a Weapon, a Character, an Item, a Door, a Level,
part of a level… anything you'd like. It works like a class in pure code,
except you're free to design it by using the editor, using only the
code, or mixing and matching the two.

It's different from prefabs you find in several 3D engines, as you can
then inherit from and extend those scenes. You may create a Magician
that extends your Character. Modify the Character in the editor and the Magician
will update as well. It helps you build your projects so that their
structure matches the game's design.

|image0|

Also note that Godot offers many different types of objects called
nodes, each with a specific purpose. Nodes are part of a tree and always
inherit from their parents up to the Node class. Although the engine
does feature some nodes like collision shapes that a parent physics
body will use, most nodes work independently from one another.

In other words, Godot's nodes do not work like components in some
other game engines.

|image1|

Sprite is a Node2D, a CanvasItem and a Node. It has all the properties
and features of its three parent classes, like transforms or the ability
to draw custom shapes and render with a custom shader.

All-inclusive package
---------------------

Godot tries to provide its own tools to answer most common
needs. It has a dedicated scripting workspace, an animation editor, a
tilemap editor, a shader editor, a debugger, a profiler,
the ability to hot-reload locally and on remote devices, etc.

|image2|

The goal is to offer a full package to create games and a continuous
user experience. You can still work with external programs as long as
there is an import plugin for it. Or you can create one, like the `Tiled
Map Importer <https://github.com/vnen/godot-tiled-importer>`__.

That is also partly why Godot offers its own programming languages
GDScript and VisualScript, along with C#. They're designed for the needs
of game developers and game designers, and they're tightly integrated in
the engine and the editor.

GDScript lets you write code using an indentation-based syntax,
yet it detects types and offers a static language's quality of auto-completion.
It is also optimized for gameplay code with built-in types like Vectors and Colors.

Note that with GDNative, you can write high-performance code using compiled
languages like C, C++, Rust, or Python (using the Cython compiler)
without recompiling the engine.

|image3|

*VisualScript is a node-based programming language that integrates well
in the editor. You can drag and drop nodes or resources into the graph
to create new code blocks.*

Note that the 3D workspace doesn't feature as many tools as the 2D workspace.
You'll need external programs or add-ons to edit terrains, animate complex characters, and so on.
Godot provides a complete API to extend the editor's functionality using
game code. See `The Godot editor is a Godot game`_ below.

|image4|

*A State Machine editor plugin in Godot 2 by kubecz3k. It lets you
manage states and transitions visually.*


.. warning::

    `Godot 4.0 will remove VisualScript from core entirely. <https://godotengine.org/article/godot-4-will-discontinue-visual-scripting>`__
    As a result, creating new projects using visual scripting in Godot is not recommended.
    Future Godot 4.x releases may have VisualScript reimplemented as an extension.

    While Godot 3.x will keep VisualScript supported, we recommend
    :ref:`trying out GDScript <toc-learn-scripting-gdscript>` instead,
    especially if you intend to migrate your project to Godot 4.

Open source
-----------

Godot offers a fully open source codebase under the **MIT license**.
This means all the technologies that ship with it have to be Free
(as in freedom) as well.
For the most part, they're developed from the ground up by contributors.

Anyone can plug in proprietary tools for the needs of their projects —
they just won't ship with the engine. This may include Google AdMob,
or FMOD. Any of these can come as
third-party plugins instead.

On the other hand, an open codebase means you can **learn from and extend
the engine** to your heart's content. You can also debug games easily,
as Godot will print errors with a stack trace, even if they come from the engine itself.

.. note::

   This **does not affect the work you do with Godot** in any way: there's
   no strings attached to the engine or anything you make with it.

Community-driven
----------------

**Godot is made by its community, for the community, and for all game
creators out there.** It's the needs of the users and open discussions
that drive the core updates. New features from the core developers often
focus on what will benefit the most users first.

That said, although a handful of core developers work on it full-time,
the project has over 600 contributors at the time of writing. Benevolent
programmers work on features they may need themselves, so you'll see
improvements in all corners of the engine at the same time in every
major release.

The Godot editor is a Godot game
--------------------------------

The Godot editor runs on the game engine. It uses the engine's own UI
system, it can hot-reload code and scenes when you test your projects,
or run game code in the editor. This means you can **use the same code**
and scenes for your games, or **build plugins and extend the editor.**

This leads to a reliable and flexible UI system, as it powers the editor
itself. With the ``tool`` keyword, you can run any game code in the editor.

|image5|

*RPG in a Box is a voxel RPG editor made with Godot 2. It uses Godot's
UI tools for its node-based programming system and for the rest of the
interface.*

Put the ``tool`` keyword at the top of any GDScript file and it will run
in the editor. This lets you import and export plugins, create plugins
like custom level editors, or create scripts with the same nodes and API
you use in your projects.

.. note::

   The editor is fully written in C++ and is statically compiled into the
   binary. This means you can't import it as a typical project that would have a
   ``project.godot`` file.

Separate 2D and 3D engines
--------------------------

Godot offers dedicated 2D and 3D rendering engines. As a result, **the
base unit for 2D scenes is pixels.** Even though the engines are
separate, you can render 2D in 3D, 3D in 2D, and overlay 2D sprites and
interfaces over your 3D world.

.. |image0| image:: img/engine_design_01.png
.. |image1| image:: img/engine_design_02.png
.. |image2| image:: img/engine_design_03.png
.. |image3| image:: img/engine_design_visual_script.png
.. |image4| image:: img/engine_design_fsm_plugin.png
.. |image5| image:: img/engine_design_rpg_in_a_box.png


===================================================
/. ./getting_started/step_by_step/index.rst
===================================================

Step by step
============

This series builds upon the :ref:`Introduction to Godot
<toc-learn-introduction>` and will get you started with the editor and the
engine. You will learn more about nodes and scenes, code your first classes with
GDScript, use signals to make nodes communicate with one another, and more.

The following lessons are here to prepare you for :ref:`doc_your_first_2d_game`, a
step-by-step tutorial where you will code a game from scratch. By the end of it,
you will have the necessary foundations to explore more features in other
sections. We also included links to pages that cover a given topic in-depth
where appropriate.

.. toctree::
   :maxdepth: 1
   :name: toc-learn-step_by_step

   nodes_and_scenes
   instancing
   scripting_languages
   scripting_first_script
   scripting_player_input
   signals


===================================================
/. ./getting_started/step_by_step/nodes_and_scenes.rst
===================================================

.. The goal of this page is to explain more than doc_key_concepts_overview about nodes and scenes, get the user to create their first concrete scene.

.. _doc_nodes_and_scenes:

Nodes and Scenes
================

In :ref:`doc_key_concepts_overview`, we saw that a Godot game is a tree of
scenes and that each scene is a tree of nodes. In this lesson, we explain a bit
more about them. You will also create your first scene.

Nodes
-----

**Nodes are the fundamental building blocks of your game**. They are like the
ingredients in a recipe. There are dozens of kinds that can display an image,
play a sound, represent a camera, and much more.

.. image:: img/nodes_and_scenes_nodes.png

All nodes have the following attributes:

- A name.
- Editable properties.
- They receive callbacks to update every frame.
- You can extend them with new properties and functions.
- You can add them to another node as a child.

The last attribute is key. **Together, nodes form a tree**, which is a powerful
feature to organize projects. Since different nodes have different functions,
combining them produces more complex behavior. As we saw before, you can build a
playable character the camera follows using a kinematic body node named
"Character", a sprite node, a camera node, and a collision shape node.

.. image:: img/nodes_and_scenes_character_nodes.png

Scenes
------

When you organize nodes in a tree, like our character, we call this construct a
scene. Once saved, scenes work like new node types in the editor, where you can
add them as a child of an existing node. In that case, the instance of the scene
appears as a single node with its internals hidden.

Scenes allow you to structure your game's code however you want. You can
**compose nodes** to create custom and complex node types, like a game character
that runs and jumps, a life bar, a chest with which you can interact, and more.

.. image:: img/nodes_and_scenes_3d_scene_example.png

The Godot editor essentially is a **scene editor**. It has plenty of tools for
editing 2D and 3D scenes, as well as user interfaces. A Godot project can
contain as many of these scenes as you need. The engine only requires one as
your application's **main scene**. This is the scene Godot will first load when
you or a player runs the game.

On top of acting like nodes, scenes have the following attributes:

1. They always have one root node, like the "Character" in our example.
2. You can save them to your hard drive and load them later.
3. You can create as many instances of a scene as you'd like. You could have
   five or ten characters in your game, created from your Character scene.

Creating your first scene
-------------------------

Let's create our first scene with a single node. To do so, you will need to
create a new project first. After opening the project, you should see an empty
editor.

.. image:: img/nodes_and_scenes_01_empty_editor.png

In an empty scene, the Scene dock on the left shows several options to add a
root node quickly. "2D Scene" adds a Node2D node, "3D Scene" adds a Spatial
node, and "User Interface" adds a Control node. These presets
are here for convenience; they are not mandatory. "Other Node" lets you select any
node to be the root node. In an empty scene, "Other Node" is equivalent to pressing
the "Add Child Node" button at the top-left of the Scene dock, which usually adds
a new node as a child of the currently selected node.

We're going to add a single Label node to our scene. Its function is to draw
text on the screen.

Press the "Add Child Node" button or "Other Node" to create a root node.

.. image:: img/nodes_and_scenes_02_scene_dock.png

The Create Node dialog opens, showing the long list of available nodes.

.. image:: img/nodes_and_scenes_03_create_node_window.png

Select the Label node. You can type its name to filter down the list.

.. image:: img/nodes_and_scenes_04_create_label_window.png

Click on the Label node to select it and click the Create button at the bottom
of the window.

.. image:: img/nodes_and_scenes_05_editor_with_label.png

A lot happens when you add a scene's first node. The scene changes to the 2D
workspace because Label is a 2D node type. The Label appears, selected, in the
top-left corner of the viewport. The node appears in the Scene dock on the left,
and the node's properties appear in the Inspector dock on the right.

Changing a node's properties
----------------------------

The next step is to change the Label's "Text" property. Let's change it to
"Hello World".

Head to the Inspector dock on the right of the viewport. Click inside the field
below the Text property and type "Hello World".

.. image:: img/nodes_and_scenes_06_label_text.png

You will see the text draw in the viewport as you type.

You can move your Label node in the viewport by selecting the move tool in the
toolbar.

.. image:: img/nodes_and_scenes_07_move_tool.png

With the Label selected, click and drag anywhere in the viewport to
move it to the center of the view delimited by the rectangle.

.. image:: img/nodes_and_scenes_08_hello_world_text.png

Running the scene
-----------------

Everything's ready to run the scene! Press the Play Scene button in the
top-right of the screen or press :kbd:`F6` (:kbd:`Cmd + R` on macOS).

.. image:: img/nodes_and_scenes_09_play_scene_button.png

A popup invites you to save the scene, which is required to run it.

.. image:: img/nodes_and_scenes_10_save_scene_popup.png

Click the Yes button, and in the file browser that appears, press the Save
button to save it as "Label.tscn".

.. image:: img/nodes_and_scenes_11_save_scene_as.png

.. note:: The Save Scene As dialog, like other file dialogs in the editor, only
          allows you to save files inside the project. The ``res://`` path at
          the top of the window represents the project's root directory and
          stands for "resource path". For more information about file paths in
          Godot, see :ref:`doc_filesystem`.

The application should open in a new window and display the text "Hello World".

.. image:: img/nodes_and_scenes_12_final_result.png

Close the window or press :kbd:`F8` to quit the running scene.

.. note::

    If this doesn't immediately work and you have a hiDPI display on at least
    one of your monitors, go to Project -> Project Settings -> Display ->
    Window then enable Allow Hidpi under Dpi.

Setting the main scene
----------------------

To run our test scene, we used the Play Scene button. Another button next to it
allows you to set and run the project's main scene. You can press :kbd:`F5`
(:kbd:`Cmd + B` on macOS) to do so.

.. image:: img/nodes_and_scenes_13_play_button.png

A popup window appears and invites you to select the main scene.

.. image:: img/nodes_and_scenes_14_main_scene_popup.png

Click the Select button, and in the file dialog that appears, double click on
Label.tscn.

.. image:: img/nodes_and_scenes_15_select_main_scene.png

The demo should run again. Moving forward, every time you run the project, Godot
will use this scene as a starting point.

.. note:: The editor saves the main scene's path in a project.godot file in your
          project's directory. While you can edit this text file directly to
          change project settings, you can also use the "Project -> Project
          Settings" window to do so.

In the next part, we will discuss another key concept in games and in Godot:
creating instances of a scene.


===================================================
/. ./getting_started/step_by_step/instancing.rst
===================================================

.. _doc_instancing:

Creating instances
==================

In the previous part, we saw that a scene is a collection of nodes organized in
a tree structure, with a single node as its root. You can split your project
into any number of scenes. This feature helps you break down and organize your
game's different components.

You can create as many scenes as you'd like and save them as files with the
``.tscn`` extension, which stands for "text scene". The ``Label.tscn`` file from
the previous lesson was an example. We call those files "Packed Scenes" as they
pack information about your scene's content.

Here's an example of a ball. It's composed of a :ref:`RigidBody2D
<class_RigidBody2D>` node as its root named Ball, which allows the ball to fall
and bounce on walls, a :ref:`Sprite <class_Sprite>` node, and a
:ref:`CollisionShape2D <class_CollisionShape2D>`.

.. image:: img/instancing_ball_scene.png

Once you saved a scene, it works as a blueprint: you can reproduce it in other
scenes as many times as you'd like. Replicating an object from a template like
this is called **instancing**.

.. image:: img/instancing_ball_instances_example.png

As we mentioned in the previous part, instanced scenes behave like a node: the
editor hides their content by default. When you instance the Ball, you only see
the Ball node. Notice also how each duplicate has a unique name.

Every instance of the Ball scene starts with the same structure and properties
as ``Ball.tscn``. However, you can modify each independently, such as changing
how they bounce, how heavy they are, or any property exposed by the source
scene.

In practice
-----------

Let's use instancing in practice to see how it works in Godot. We invite
you to download the ball's sample project we prepared for you:
:download:`instancing.zip <files/instancing.zip>`.

Extract the archive on your computer. Then, open Godot, and in the project
manager, click the Import button to import the project.

.. image:: img/instancing_import_button.png

In the pop-up that appears, click the browse button and navigate to the folder
you extracted.

.. image:: img/instancing_import_browse.png

Double-click the ``project.godot`` file to open it.

.. image:: img/instancing_import_project_file.png

Finally, click the Import & Edit button.

.. image:: img/instancing_import_and_edit_button.png

The project contains two packed scenes: ``Main.tscn``, containing walls against
which the ball collides, and ``Ball.tscn``. The Main scene should open
automatically.

.. image:: img/instancing_main_scene.png

Let's add a ball as a child of the Main node. In the Scene dock, select the Main
node. Then, click the link icon at the top of the scene dock. This button allows
you to add an instance of a scene as a child of the currently selected node.

.. image:: img/instancing_scene_link_button.png

Double-click the ball scene to instance it.

.. image:: img/instancing_instance_child_window.png

The ball appears in the top-left corner of the viewport.

.. image:: img/instancing_ball_instanced.png

Click on it and drag it towards the center of the view.

.. image:: img/instancing_ball_moved.png

Play the game by pressing F5. You should see it fall.

Now, we want to create more instances of the Ball node. With the ball still
selected, press :kbd:`Ctrl-D` (:kbd:`Cmd-D` on macOS) to call the duplicate
command. Click and drag to move the new ball to a different location.

.. image:: img/instancing_ball_duplicated.png

You can repeat this process until you have several in the scene.

.. image:: img/instancing_main_scene_with_balls.png

Play the game again. You should now see every ball fall independently from one
another. This is what instances do. Each is an independent reproduction of a
template scene.

Editing scenes and instances
----------------------------

There is more to instances. With this feature, you can:

1. Change the properties of one ball without affecting the others using the
   Inspector.
2. Change the default properties of every Ball by opening the ``Ball.tscn`` scene
   and making a change to the Ball node there. Upon saving, all instances of the
   Ball in the project will see their values update.

.. note:: Changing a property on an instance always overrides values from the
          corresponding packed scene.

Let's try this. Open ``Ball.tscn`` and select the Ball node. In the Inspector on
the right, click on the PhysicsMaterial property to expand it.

.. image:: img/instancing_physics_material_expand.png

Set its Bounce property to ``2`` by clicking on the number field, typing ``2``,
and pressing :kbd:`Enter`.

.. image:: img/instancing_property_bounce_updated.png

Play the game by pressing :kbd:`F5` and notice how all balls now bounce a lot
more. As the Ball scene is a template for all instances, modifying it and saving
causes all instances to update accordingly.

Let's now adjust an individual instance. Head back to the Main scene by clicking
on the corresponding tab above the viewport.

.. image:: img/instancing_scene_tabs.png

Select one of the instanced Ball nodes and, in the Inspector, set its Gravity
Scale value to ``10``.

.. image:: img/instancing_property_gravity_scale.png

A grey "revert" button appears next to the adjusted property.

.. image:: img/instancing_property_revert_icon.png

This icon indicates you are overriding a value from the source packed scene.
Even if you modify the property in the original scene, the value override will
be preserved in the instance. Clicking the revert icon will restore the
property to the value in the saved scene.

Rerun the game and notice how this ball now falls much faster than the others.

.. note:: If you change a value on the ``PhysicsMaterial`` of one instance, it
          will affect all the others. This is because ``PhysicsMaterial`` is a
          resource, and resources are shared between instances. To make a
          resource unique for one instance, right-click on it in the Inspector
          and click Make Unique in the contextual menu.

          Resources are another essential building block of Godot games we will
          cover in a later lesson.

Scene instances as a design language
------------------------------------

Instances and scenes in Godot offer an excellent design language, setting the
engine apart from others out there. We designed Godot around this concept from
the ground up.

We recommend dismissing architectural code patterns when making games with
Godot, such as Model-View-Controller (MVC) or Entity-Relationship diagrams.
Instead, you can start by imagining the elements players will see in your game
and structure your code around them.

For example, you could break down a shooter game like so:

.. image:: img/instancing_diagram_shooter.png

You can come up with a diagram like this for almost any type of game. Each
rectangle represents an entity that's visible in the game from the player's
perspective. The arrows tell you which scene owns which.

Once you have a diagram, we recommended creating a scene for each element listed
in it to develop your game. You'll use instancing, either by code or directly in
the editor, to build your tree of scenes.

Programmers tend to spend a lot of time designing abstract architectures and
trying to fit components into it. Designing based on scenes makes development
faster and more straightforward, allowing you to focus on the game logic itself.
Because most game components map directly to a scene, using a design based on
scene instantiation means you need little other architectural code.

Here's the example of a scene diagram for an open-world game with tons of assets
and nested elements:

.. image:: img/instancing_diagram_open_world.png

Imagine we started by creating the room. We could make a couple of different
room scenes, with unique arrangements of furniture in them. Later, we could make
a house scene that uses multiple room instances for the interior. We would
create a citadel out of many instanced houses and a large terrain on which we
would place the citadel. Each of these would be a scene instancing one or more sub-scenes.

Later, we could create scenes representing guards and add them to the citadel.
They would be indirectly added to the overall game world.

With Godot, it's easy to iterate on your game like this, as all you need to do
is create and instantiate more scenes. We designed the editor to be accessible
to programmers, designers, and artists alike. A typical team development process
can involve 2D or 3D artists, level designers, game designers, and animators,
all working with the Godot editor.

Summary
-------

Instancing, the process of producing an object from a blueprint has many handy
uses. With scenes, it gives you:

- The ability to divide your game into reusable components.
- A tool to structure and encapsulate complex systems.
- A language to think about your game project's structure in a natural way.


===================================================
/. ./getting_started/step_by_step/scripting_languages.rst
===================================================

.. Intention: only introduce what a script does in general and options for
   scripting languages.

.. _doc_scripting:

Scripting languages
===================

This lesson will give you an overview of the available scripting languages in
Godot. You will learn the pros and cons of each option. In the next part, you
will write your first script using GDScript.

**Scripts attach to a node and extend its behavior**. This means that scripts
inherit all functions and properties of the node they attach to.

For example, take a game where a Camera2D node follows a ship. The Camera2D node
follows its parent by default. Imagine you want the camera to shake when the player
takes damage. As this feature is not built into Godot, you would attach a script
to the Camera2D node and code the shake.

.. image:: img/scripting_camera_shake.gif

Available scripting languages
-----------------------------

Godot offers **five gameplay programming languages**: GDScript, C#,
VisualScript, and, via its GDNative technology, C and C++. There are more
:ref:`community-supported languages <doc_what_is_gdnative_third_party_bindings>`,
but these are the official ones.

You can use multiple languages in a single project. For instance, in a team, you
could code gameplay logic in GDScript as it's fast to write, let level designers
script quests in the graphical language VisualScript, and use C# or C++ to
implement complex algorithms and maximize their performance. Or you can write
everything in GDScript or C#. It's your call.

We provide this flexibility to answer the needs of different game projects and
developers.

.. warning::

    `Godot 4.0 will remove VisualScript from core entirely. <https://godotengine.org/article/godot-4-will-discontinue-visual-scripting>`__
    As a result, creating new projects using visual scripting in Godot is not recommended.
    Future Godot 4.x releases may have VisualScript reimplemented as an extension.

    While Godot 3.x will keep VisualScript supported, we recommend
    :ref:`trying out GDScript <toc-learn-scripting-gdscript>` instead,
    especially if you intend to migrate your project to Godot 4.

Which language should I use?
----------------------------

If you're a beginner, we recommend to **start with GDScript**. We made this
language specifically for Godot and the needs of game developers. It has a
lightweight and straightforward syntax and provides the tightest integration
with Godot.

.. image:: img/scripting_gdscript.png

For C#, you will need an external code editor like
`VSCode <https://code.visualstudio.com/>`_ or Visual Studio. While C# support is
now mature, you will find fewer learning resources for it compared to
GDScript. That's why we recommend C# mainly to users who already have experience
with the language.

Let's look at each language's features, as well as its pros and cons.

GDScript
~~~~~~~~

:ref:`GDScript<doc_gdscript>` is an
`object-oriented <https://en.wikipedia.org/wiki/Object-oriented_programming>`_ and
`imperative <https://en.wikipedia.org/wiki/Imperative_programming>`_
programming language built for Godot. It's made by and for game developers
to save you time coding games. Its features include:

- A simple syntax that leads to short files.
- Blazing fast compilation and loading times.
- Tight editor integration, with code completion for nodes, signals, and more
  information from the scene it's attached to.
- Built-in vector and transform types, making it efficient for heavy use of
  linear algebra, a must for games.
- Supports multiple threads as efficiently as statically typed languages.
- No `garbage collection
  <https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>`_, as
  this feature eventually gets in the way when creating games. The engine counts
  references and manages the memory for you in most cases by default, but you
  can also control memory if you need to.
- `Gradual typing <https://en.wikipedia.org/wiki/Gradual_typing>`_. Variables
  have dynamic types by default, but you also can use type hints for strong type
  checks.

GDScript looks like Python as you structure your code blocks using indentations,
but it doesn't work the same way in practice. It's inspired by multiple
languages, including Squirrel, Lua, and Python.

.. note::

    Why don't we use Python or Lua directly?

    Years ago, Godot used Python, then Lua. Both languages' integration took a
    lot of work and had severe limitations. For example, threading support was a
    big challenge with Python.

    Developing a dedicated language doesn't take us more work and we can tailor
    it to game developers' needs. We're now working on performance optimizations
    and features that would've been difficult to offer with third-party
    languages.

.NET / C#
~~~~~~~~~

As Microsoft's `C#
<https://en.wikipedia.org/wiki/C_Sharp_(programming_language)>`_ is a favorite
amongst game developers, we officially support it. C# is a mature and flexible
language with tons of libraries written for it. We could add support for it
thanks to a generous donation from Microsoft.

.. image:: img/scripting_csharp.png

C# offers a good tradeoff between performance and ease of use, although you
should be aware of its garbage collector.

.. note:: You must use the Mono edition of the Godot editor to script in C#. You
          can download it on the Godot website's `download
          <https://godotengine.org/download/>`_ page.

Since Godot uses the `Mono <https://mono-project.com>`_ .NET runtime, in theory,
you can use any third-party .NET library or framework in Godot, as well as any
Common Language Infrastructure-compliant programming language, such as F#, Boo,
or ClojureCLR. However, C# is the only officially supported .NET option.

.. note:: GDScript code itself doesn't execute as fast as compiled C# or C++.
          However, most script code calls functions written with fast algorithms
          in C++ code inside the engine. In many cases, writing gameplay logic
          in GDScript, C#, or C++ won't have a significant impact on
          performance.

VisualScript
~~~~~~~~~~~~

.. warning::

    `Godot 4.0 will remove VisualScript from core entirely. <https://godotengine.org/article/godot-4-will-discontinue-visual-scripting>`__
    As a result, creating new projects using visual scripting in Godot is not recommended.
    Future Godot 4.x releases may have VisualScript reimplemented as an extension.

    While Godot 3.x will keep VisualScript supported, we recommend
    :ref:`trying out GDScript <toc-learn-scripting-gdscript>` instead,
    especially if you intend to migrate your project to Godot 4.

:ref:`Visual Scripting<doc_what_is_visual_script>` is a graph-based visual
programming language where you connect blocks. It can be a great tool for
non-programmers like game designers and artists.

.. image:: img/scripting_visualscript.png

You can use other languages to create custom blocks that are specific to your
game, for example, to script AIs, quests, or dialogues. That's where the
strength of VisualScript lies.

While it provides all the basic building blocks you need to code complete games,
we do not recommend to use VisualScript this way. Programming everything with it
is slow compared to using other programming languages.

.. seealso::

    For more information, see
    :ref:`Getting started with VisualScript <doc_getting_started_visual_script>`.

C and C++ via GDNative
~~~~~~~~~~~~~~~~~~~~~~

GDNative allows you to write game code in C or C++ without needing to recompile
or even restart Godot.

.. image:: img/scripting_cpp.png

You can use any version of the language or mix compiler brands and versions for
the generated shared libraries, thanks to our use of an internal C API Bridge.

GDNative is the best choice for performance. You don't need to use it
throughout an entire game, as you can write other parts in GDScript, C#, or
VisualScript.

When working with GDNative, the available types, functions, and properties
closely resemble Godot's actual C++ API.

Summary
-------

Scripts are files containing code that you attach to a node to extend its
functionality.

Godot supports five official scripting languages, offering you flexibility
between performance and ease of use.

You can mix languages, for instance, to implement demanding algorithms with C or
C++ and write most of the game logic with GDScript or C#.


===================================================
/. ./getting_started/step_by_step/scripting_first_script.rst
===================================================

..
    Intention:

    - Giving a *short* and sweet hands-on intro to GDScript. The page should
      focus on working in the code editor.
    - We assume the reader has programming foundations, as explained in
    getting_started/introduction.

    Techniques:

    - Creating a sprite.
    - Creating a script.
    - _init() and _process().
    - Moving an object on screen.

.. _doc_scripting_first_script:

Creating your first script
==========================

In this lesson, you will code your first script to make the Godot icon turn in
circles using GDScript. As we mentioned :ref:`in the introduction
<toc-learn-introduction>`, we assume you have programming foundations.
The equivalent C# code has been included in another tab for convenience.

.. image:: img/scripting_first_script_rotating_godot.gif

.. seealso:: To learn more about GDScript, its keywords, and its syntax, head to
             the :ref:`GDScript reference<doc_gdscript>`.

.. seealso:: To learn more about C#, head to the :ref:`C# basics <doc_c_sharp>` page.

Project setup
-------------

Please create a new project to start with a clean slate. Your project should
contain one picture: the Godot icon, which we often use for prototyping in the
community.

.. Godot icon

We need to create a Sprite node to display it in the game. In the Scene dock,
click the Other Node button.

.. image:: img/scripting_first_script_click_other_node.png

Type "Sprite" in the search bar to filter nodes and double-click on Sprite to
create the node.

.. image:: img/scripting_first_script_add_sprite_node.png

Your Scene tab should now only have a Sprite node.

.. image:: img/scripting_first_script_scene_tree.png

A Sprite node needs a texture to display. In the Inspector on the right, you can
see that the Texture property says "[empty]". To display the Godot icon, click
and drag the file ``icon.png`` from the FileSystem dock onto the Texture slot.

.. image:: img/scripting_first_script_setting_texture.png

.. note::

    You can create Sprite nodes automatically by dragging and dropping images on
    the viewport.

    .. image:: img/scripting_first_script_dragging_sprite.png

Then, click and drag the icon in the viewport to center it in the game view.

.. image:: img/scripting_first_script_centering_sprite.png

Creating a new script
---------------------

To create and attach a new script to our node, right-click on Sprite in the
scene dock and select "Attach Script".

.. image:: img/scripting_first_script_attach_script.png

The Attach Node Script window appears. It allows you to select the script's
language and file path, among other options.

Change the Template from Default to Empty to start with a clean file. Leave the
other options by default and click the Create button to create the script.

.. image:: img/scripting_first_script_attach_node_script.png

The Script workspace should appear with your new ``Sprite.gd`` file open and the
following line of code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Sprite

 .. code-tab:: csharp C#

    public class Sprite : Godot.Sprite
    // Declare member variables here. Examples:
    // private int a = 2;
    // private string b = "text";

    // Called when the node enters the scene tree for the first time.
    public override void _Ready()
    {

    }

    //  // Called every frame. 'delta' is the elapsed time since the previous frame.
    //  public override void _Process(float delta)
    //  {
    //
    //  }

Every GDScript file is implicitly a class. The ``extends`` keyword defines the
class this script inherits or extends. In this case, it's ``Sprite``, meaning
our script will get access to all the properties and functions of the Sprite
node, including classes it extends, like ``Node2D``, ``CanvasItem``, and
``Node``.

.. note:: In GDScript, if you omit the line with the ``extends`` keyword, your
          class will implicitly extend :ref:`Reference <class_Reference>`, which
          Godot uses to manage your application's memory.

Inherited properties include the ones you can see in the Inspector dock, like
our node's ``texture``.

.. note::

    By default, the Inspector displays a node's properties in "Title Case", with
    capitalized words separated by a space. In GDScript code, these properties
    are in "snake_case", which is lowercase with words separated by an underscore.

    You can hover any property's name in the Inspector to see a description and
    its identifier in code.

Hello, world!
-------------

Our script currently doesn't do anything. Let's make it print the text "Hello,
world!" to the Output bottom panel to get started.

Add the following code to your script:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _init():
        print("Hello, world!")

 .. code-tab:: csharp C#

    public Sprite()
    {
        GD.Print("Hello, world!");
    }


Let's break it down. The ``func`` keyword defines a new function named
``_init``. This is a special name for our class's constructor. The engine calls
``_init()`` on every object or node upon creating it in memory, if you define
this function.

.. note:: GDScript is an indent-based language. The tab at the start of the line
          that says ``print()`` is necessary for the code to work. If you omit
          it or don't indent a line correctly, the editor will highlight it in
          red and display the following error message: "Indented block expected".

Save the scene if you haven't already, then press :kbd:`F6` (:kbd:`Cmd + R` on macOS)
to run it. Look at the **Output** bottom panel that expands.
It should display "Hello, world!".

.. image:: img/scripting_first_script_print_hello_world.png

Delete the ``_init()`` function, so you're only left with the line ``extends
Sprite``.

Turning around
--------------

It's time to make our node move and rotate. To do so, we're going to add two
member variables to our script: the movement speed in pixels per second and the
angular speed in radians per second.

.. tabs::
 .. code-tab:: gdscript GDScript

    var speed = 400
    var angular_speed = PI

 .. code-tab:: csharp C#

    private int Speed = 400;
    private float AngularSpeed = Mathf.Pi;

Member variables sit near the top of the script, after any "extends" lines,
but before functions. Every node
instance with this script attached to it will have its own copy of the ``speed``
and ``angular_speed`` properties.

.. note:: Angles in Godot work in radians by default,
          but you have built-in functions and properties available if you prefer
          to calculate angles in degrees instead.

To move our icon, we need to update its position and rotation every frame in the
game loop. We can use the ``_process()`` virtual function of the ``Node`` class.
If you define it in any class that extends the Node class, like Sprite, Godot
will call the function every frame and pass it an argument named ``delta``, the
time elapsed since the last frame.

.. note::

    Games work by rendering many images per second, each called a frame, and
    they do so in a loop. We measure the rate at which a game produces images in
    Frames Per Second (FPS). Most games aim for 60 FPS, although you might find
    figures like 30 FPS on slower mobile devices or 90 to 240 for virtual
    reality games.

    The engine and game developers do their best to update the game world and
    render images at a constant time interval, but there are always small
    variations in frame render times. That's why the engine provides us with
    this delta time value, making our motion independent of our framerate.

At the bottom of the script, define the function:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        rotation += angular_speed * delta

 .. code-tab:: csharp C#

    public override void _Process(float delta)
    {
        Rotation += AngularSpeed * delta;
    }

The ``func`` keyword defines a new function. After it, we have to write the
function's name and arguments it takes in parentheses. A colon ends the
definition, and the indented blocks that follow are the function's content or
instructions.

.. note:: Notice how ``_process()``, like ``_init()``, starts with a leading
          underscore. By convention, Godot's virtual functions, that is to say,
          built-in functions you can override to communicate with the engine,
          start with an underscore.

The line inside the function, ``rotation += angular_speed * delta``, increments
our sprite's rotation every frame. Here, ``rotation`` is a property inherited
from the class ``Node2D``, which ``Sprite`` extends. It controls the rotation of
our node and works with radians.

.. tip:: In the code editor, you can ctrl-click on any built-in property or
         function like ``position``, ``rotation``, or ``_process`` to open the
         corresponding documentation in a new tab.

Run the scene to see the Godot icon turn in-place.

.. image:: img/scripting_first_script_godot_turning_in_place.gif

Moving forward
~~~~~~~~~~~~~~

Let's now make the node move. Add the following two lines to the ``_process()``
function, ensuring the new lines are indented the same way as the one before
them.

.. tabs::
 .. code-tab:: gdscript GDScript

    var velocity = Vector2.UP.rotated(rotation) * speed

    position += velocity * delta

 .. code-tab:: csharp C#

    var velocity = Vector2.Up.Rotated(Rotation) * Speed;

    Position += velocity * delta;

As we already saw, the ``var`` keyword defines a new variable. If you put it at
the top of the script, it defines a property of the class. Inside a function, it
defines a local variable: it only exists within the function's scope.

We define a local variable named ``velocity``, a 2D vector representing both a
direction and a speed. To make the node move forward, we start from the Vector2
class's constant Vector2.UP, a vector pointing up, and rotate it by calling the
``Vector2.rotated()`` method. This expression, ``Vector2.UP.rotated(rotation)``,
is a vector pointing forward relative to our icon. Multiplied by our ``speed``
property, it gives us a velocity we can use to move the node forward.

We add ``velocity * delta`` to the node's ``position`` to move it. The position
itself is of type :ref:`Vector2 <class_Vector2>`, a built-in type in Godot
representing a 2D vector.

Run the scene to see the Godot head run in circles.

.. image:: img/scripting_first_script_rotating_godot.gif

.. note:: Moving a node like that does not take into account colliding with
          walls or the floor. In :ref:`doc_your_first_2d_game`, you will learn
          another approach to moving objects while detecting collisions.

Our node currently moves by itself. In the next part
:ref:`doc_scripting_player_input`, we'll use player input to control it.

Complete script
---------------

Here is the complete ``Sprite.gd`` file for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Sprite

    var speed = 400
    var angular_speed = PI


    func _process(delta):
        rotation += angular_speed * delta

        var velocity = Vector2.UP.rotated(rotation) * speed

        position += velocity * delta

 .. code-tab:: csharp C#

    using Godot;

    public class Sprite : Godot.Sprite
    {
        private int Speed = 400;
        private float AngularSpeed = Mathf.Pi;

        public override void _Process(float delta)
        {
            Rotation += AngularSpeed * delta;
            var velocity = Vector2.Up.Rotated(Rotation) * Speed;

            Position += velocity * delta;

        }
    }


===================================================
/. ./getting_started/step_by_step/scripting_player_input.rst
===================================================

.. Intention: only introduce one necessary input method at this point. The
   Inputs section of the docs should provide more guides comparing the various
   tools you have to manage the complexity of user input.

.. _doc_scripting_player_input:

Listening to player input
=========================

Building upon the previous lesson :ref:`doc_scripting_first_script`, let's look
at another important feature of any game: giving control to the player.
To add this, we need to modify our ``Sprite.gd`` code.

.. image:: img/scripting_first_script_moving_with_input.gif

You have two main tools to process the player's input in Godot:

1. The built-in input callbacks, mainly ``_unhandled_input()``. Like
   ``_process()``, it's a built-in virtual function that Godot calls every time
   the player presses a key. It's the tool you want to use to react to events
   that don't happen every frame, like pressing :kbd:`Space` to jump. To learn
   more about input callbacks, see :ref:`doc_inputevent`.
2. The ``Input`` singleton. A singleton is a globally accessible object. Godot
   provides access to several in scripts. It's the right tool to check for input
   every frame.

We're going to use the ``Input`` singleton here as we need to know if the player
wants to turn or move every frame.

For turning, we should use a new variable: ``direction``. In our ``_process()``
function, replace the ``rotation += angular_speed * delta`` line with the
code below.

.. tabs::
 .. code-tab:: gdscript GDScript

    var direction = 0
    if Input.is_action_pressed("ui_left"):
        direction = -1
    if Input.is_action_pressed("ui_right"):
        direction = 1

    rotation += angular_speed * direction * delta

 .. code-tab:: csharp C#

    var direction = 0;
    if (Input.IsActionPressed("ui_left"))
    {
        direction = -1;
    }
    if (Input.IsActionPressed("ui_right"))
    {
        direction = 1;
    }

    Rotation += AngularSpeed * direction * delta;

Our ``direction`` local variable is a multiplier representing the direction in
which the player wants to turn. A value of ``0`` means the player isn't pressing
the left or the right arrow key. A value of ``1`` means the player wants to turn
right, and ``-1`` means they want to turn left.

To produce these values, we introduce conditions and the use of ``Input``. A
condition starts with the ``if`` keyword in GDScript and ends with a colon. The
condition is the expression between the keyword and the end of the line.

To check if a key was pressed this frame, we call ``Input.is_action_pressed()``.
The method takes a text string representing an input action and returns ``true``
if the action is pressed, ``false`` otherwise.

The two actions we use above, "ui_left" and "ui_right", are predefined in every
Godot project. They respectively trigger when the player presses the left and
right arrows on the keyboard or left and right on a gamepad's D-pad.

.. note:: You can see and edit input actions in your project by going to Project
          -> Project Settings and clicking on the Input Map tab.

Finally, we use the ``direction`` as a multiplier when we update the node's
``rotation``: ``rotation += angular_speed * direction * delta``.

If you run the scene with this code, the icon should rotate when you press
:kbd:`Left` and :kbd:`Right`.

Moving when pressing "up"
-------------------------

To only move when pressing a key, we need to modify the code that calculates the
velocity. Replace the line starting with ``var velocity`` with the code below.

.. tabs::
 .. code-tab:: gdscript GDScript

    var velocity = Vector2.ZERO
    if Input.is_action_pressed("ui_up"):
        velocity = Vector2.UP.rotated(rotation) * speed

 .. code-tab:: csharp C#

    var velocity = Vector2.Zero;
    if (Input.IsActionPressed("ui_up"))
    {
        velocity = Vector2.Up.Rotated(Rotation) * Speed;
    }

We initialize the ``velocity`` with a value of ``Vector2.ZERO``, another
constant of the built-in ``Vector`` type representing a 2D vector of length 0.

If the player presses the "ui_up" action, we then update the velocity's value,
causing the sprite to move forward.

Complete script
---------------

Here is the complete ``Sprite.gd`` file for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Sprite

    var speed = 400
    var angular_speed = PI


    func _process(delta):
        var direction = 0
        if Input.is_action_pressed("ui_left"):
            direction = -1
        if Input.is_action_pressed("ui_right"):
            direction = 1

        rotation += angular_speed * direction * delta

        var velocity = Vector2.ZERO
        if Input.is_action_pressed("ui_up"):
            velocity = Vector2.UP.rotated(rotation) * speed

        position += velocity * delta

 .. code-tab:: csharp C#

    using Godot;

    public class Sprite : Godot.Sprite
    {
        private float Speed = 400;
        private float AngularSpeed = Mathf.Pi;

        public override void _Process(float delta)
        {
            var direction = 0;
            if (Input.IsActionPressed("ui_left"))
            {
                direction = -1;
            }
            if (Input.IsActionPressed("ui_right"))
            {
                direction = 1;
            }

            Rotation += AngularSpeed * direction * delta;

            var velocity = Vector2.Zero;
            if (Input.IsActionPressed("ui_up"))
            {
                velocity = Vector2.Up.Rotated(Rotation) * Speed;
            }

            Position += velocity * delta;
        }
    }

If you run the scene, you should now be able to rotate with the left and right
arrow keys and move forward by pressing :kbd:`Up`.

.. image:: img/scripting_first_script_moving_with_input.gif

Summary
-------

In summary, every script in Godot represents a class and extends one of the
engine's built-in classes. The node types your classes inherit from give you
access to properties like ``rotation`` and ``position`` in our sprite's case.
You also inherit many functions, which we didn't get to use in this example.

In GDScript, the variables you put at the top of the file are your class's
properties, also called member variables. Besides variables, you can define
functions, which, for the most part, will be your classes' methods.

Godot provides several virtual functions you can define to connect your class
with the engine. These include ``_process()``, to apply changes to the node
every frame, and ``_unhandled_input()``, to receive input events like key and
button presses from the users. There are quite a few more.

The ``Input`` singleton allows you to react to the players' input anywhere in
your code. In particular, you'll get to use it in the ``_process()`` loop.

In the next lesson :ref:`doc_signals`, we'll build upon the relationship between
scripts and nodes by having our nodes trigger code in scripts.


===================================================
/. ./getting_started/step_by_step/signals.rst
===================================================

.. Intention: give the user a first taste of signals. We should write more
   documentation in the scripting/ section.
.. Note: GDScript snippets use one line return instead of two because they're
   really short.

.. meta::
    :keywords: Signal

.. _doc_signals:

Using signals
=============

In this lesson, we will look at signals. They are messages that nodes emit when
something specific happens to them, like a button being pressed. Other nodes can
connect to that signal and call a function when the event occurs.

Signals are a delegation mechanism built into Godot that allows one game object to
react to a change in another without them referencing one another. Using signals
limits `coupling
<https://en.wikipedia.org/wiki/Coupling_(computer_programming)>`_ and keeps your
code flexible.

For example, you might have a life bar on the screen that represents the
player’s health. When the player takes damage or uses a healing potion, you want
the bar to reflect the change. To do so, in Godot, you would use signals.

.. note:: As mentioned in the introduction, signals are Godot's version of the
          observer pattern. You can learn more about it here:
          https://gameprogrammingpatterns.com/observer.html

We will now use a signal to make our Godot icon from the previous lesson
(:ref:`doc_scripting_player_input`) move and stop by pressing a button.

.. Example

Scene setup
-----------

To add a button to our game, we will create a new "main" scene which will
include both a button and the ``Sprite.tscn`` scene that we scripted in previous
lessons.

Create a new scene by going to the menu Scene -> New Scene.

.. image:: img/signals_01_new_scene.png

In the Scene dock, click the 2D Scene button. This will add a Node2D as our
root.

.. image:: img/signals_02_2d_scene.png

In the FileSystem dock, click and drag the ``Sprite.tscn`` file you saved
previously onto the Node2D to instantiate it.

.. image:: img/signals_03_dragging_scene.png

We want to add another node as a sibling of the Sprite. To do so, right-click on
Node2D and select Add Child Node.

.. image:: img/signals_04_add_child_node.png

Search for the Button node type and add it.

.. image:: img/signals_05_add_button.png

The node is small by default. Click and drag on the bottom-right handle of the
Button in the viewport to resize it.

.. image:: img/signals_06_drag_button.png

If you don't see the handles, ensure the select tool is active in the toolbar.

.. image:: img/signals_07_select_tool.png

Click and drag on the button itself to move it closer to the sprite.

You can also write a label on the Button by editing its Text property in the
Inspector. Enter "Toggle motion".

.. image:: img/signals_08_toggle_motion_text.png

Your scene tree and viewport should look like this.

.. image:: img/signals_09_scene_setup.png

Save your newly created scene. You can then run it with :kbd:`F6`.
At the moment, the button will be visible, but nothing will happen if you
press it.

Connecting a signal in the editor
---------------------------------

Here, we want to connect the Button's "pressed" signal to our Sprite, and we
want to call a new function that will toggle its motion on and off. We need to
have a script attached to the Sprite node, which we do from the previous lesson.

You can connect signals in the Node dock. Select the Button node and, on the
right side of the editor, click on the tab named "Node" next to the Inspector.

.. image:: img/signals_10_node_dock.png

The dock displays a list of signals available on the selected node.

.. image:: img/signals_11_pressed_signals.png

Double-click the "pressed" signal to open the node connection window.

.. image:: img/signals_12_node_connection.png

There, you can connect the signal to the Sprite node. The node needs a receiver
method, a function that Godot will call when the Button emits the signal. The
editor generates one for you. By convention, we name these callback methods
"_on_NodeName_signal_name". Here, it'll be "_on_Button_pressed".

.. note::

   When connecting signals via the editor's Node dock, you can use two
   modes. The simple one only allows you to connect to nodes that have a
   script attached to them and creates a new callback function on them.

   .. image:: img/signals_advanced_connection_window.png

   The advanced view lets you connect to any node and any built-in
   function, add arguments to the callback, and set options. You can
   toggle the mode in the window's bottom-right by clicking the Advanced
   button.

Click the Connect button to complete the signal connection and jump to the
Script workspace. You should see the new method with a connection icon in the
left margin.

.. image:: img/signals_13_signals_connection_icon.png

If you click the icon, a window pops up and displays information about the
connection. This feature is only available when connecting nodes in the editor.

.. image:: img/signals_14_signals_connection_info.png

Let's replace the line with the ``pass`` keyword with code that'll toggle the
node's motion.

Our Sprite moves thanks to code in the ``_process()`` function. Godot provides a
method to toggle processing on and off: :ref:`Node.set_process()
<class_Node_method_set_process>`. Another method of the Node class,
``is_processing()``, returns ``true`` if idle processing is active. We can use
the ``not`` keyword to invert the value.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_Button_pressed():
        set_process(not is_processing())

This function will toggle processing and, in turn, the icon's motion on and off
upon pressing the button.

Before trying the game, we need to simplify our ``_process()`` function to move
the node automatically and not wait for user input. Replace it with the
following code, which we saw two lessons ago:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        rotation += angular_speed * delta
        var velocity = Vector2.UP.rotated(rotation) * speed
        position += velocity * delta

Your complete ``Sprite.gd`` code should look like the following.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Sprite

    var speed = 400
    var angular_speed = PI


    func _process(delta):
        rotation += angular_speed * delta
        var velocity = Vector2.UP.rotated(rotation) * speed
        position += velocity * delta


    func _on_Button_pressed():
        set_process(not is_processing())

Run the scene now and click the button to see the sprite start and stop.

Connecting a signal via code
----------------------------

You can connect signals via code instead of using the editor. This is necessary
when you create nodes or instantiate scenes inside of a script.

Let's use a different node here. Godot has a :ref:`Timer <class_Timer>` node
that's useful to implement skill cooldown times, weapon reloading, and more.

Head back to the 2D workspace. You can either click the "2D" text at the top of
the window or press :kbd:`Ctrl + F1` (:kbd:`Alt + 1` on macOS).

In the Scene dock, right-click on the Sprite node and add a new child node.
Search for Timer and add the corresponding node. Your scene should now look like
this.

.. image:: img/signals_15_scene_tree.png

With the Timer node selected, go to the Inspector and check the **Autostart**
property.

.. image:: img/signals_18_timer_autostart.png

Click the script icon next to Sprite to jump back to the scripting workspace.

.. image:: img/signals_16_click_script.png

We need to do two operations to connect the nodes via code:

1. Get a reference to the Timer from the Sprite.
2. Call the Timer's ``connect()`` method.

.. note:: To connect to a signal via code, you need to call the ``connect()``
          method of the node you want to listen to. In this case, we want to
          listen to the Timer's "timeout" signal.

We want to connect the signal when the scene is instantiated, and we can do that
using the :ref:`Node._ready() <class_Node_method__ready>` built-in function,
which is called automatically by the engine when a node is fully instantiated.

To get a reference to a node relative to the current one, we use the method
:ref:`Node.get_node() <class_Node_method_get_node>`. We can store the reference
in a variable.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        var timer = get_node("Timer")

The function ``get_node()`` looks at the Sprite's children and gets nodes by
their name. For example, if you renamed the Timer node to "BlinkingTimer" in the
editor, you would have to change the call to ``get_node("BlinkingTimer")``.

.. add seealso to a page that explains node features.

We can now connect the Timer to the Sprite in the ``_ready()`` function.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        var timer = get_node("Timer")
        timer.connect("timeout", self, "_on_Timer_timeout")

The line reads like so: we connect the Timer's "timeout" signal to the node to
which the script is attached (``self``). When the Timer emits "timeout", we want
to call the function "_on_Timer_timeout", that we need to define. Let's add it
at the bottom of our script and use it to toggle our sprite's visibility.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_Timer_timeout():
        visible = not visible

The ``visible`` property is a boolean that controls the visibility of our node.
The line ``visible = not visible`` toggles the value. If ``visible`` is
``true``, it becomes ``false``, and vice-versa.

If you run the scene now, you will see that the sprite blinks on and off, at one
second intervals.

Complete script
---------------

That's it for our little moving and blinking Godot icon demo!
Here is the complete ``Sprite.gd`` file for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Sprite

    var speed = 400
    var angular_speed = PI


    func _ready():
        var timer = get_node("Timer")
        timer.connect("timeout", self, "_on_Timer_timeout")


    func _process(delta):
        rotation += angular_speed * delta
        var velocity = Vector2.UP.rotated(rotation) * speed
        position += velocity * delta


    func _on_Button_pressed():
        set_process(not is_processing())


    func _on_Timer_timeout():
        visible = not visible

Custom signals
--------------

.. note:: This section is a reference on how to define and use your own signals,
          and does not build upon the project created in previous lessons.

You can define custom signals in a script. Say, for example, that you want to
show a game over screen when the player's health reaches zero. To do so, you
could define a signal named "died" or "health_depleted" when their health
reaches 0.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node2D

    signal health_depleted

    var health = 10

.. note:: As signals represent events that just occurred, we generally use an
          action verb in the past tense in their names.

Your signals work the same way as built-in ones: they appear in the Node tab and
you can connect to them like any other.

.. image:: img/signals_17_custom_signal.png

To emit a signal in your scripts, call ``emit_signal()``.

.. tabs::
 .. code-tab:: gdscript GDScript

    func take_damage(amount):
        health -= amount
        if health <= 0:
            emit_signal("health_depleted")

A signal can optionally declare one or more arguments. Specify the argument
names between parentheses:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node

    signal health_changed(old_value, new_value)

.. note::

    The signal arguments show up in the editor's node dock, and Godot can use
    them to generate callback functions for you. However, you can still emit any
    number of arguments when you emit signals. So it's up to you to emit the
    correct values.

To emit values along with the signal, add them as extra arguments to the
``emit_signal()`` function:

.. tabs::
 .. code-tab:: gdscript GDScript

    func take_damage(amount):
        var old_health = health
        health -= amount
        emit_signal("health_changed", old_health, health)

Summary
-------

Any node in Godot emits signals when something specific happens to them, like a
button being pressed. Other nodes can connect to individual signals and react to
selected events.

Signals have many uses. With them, you can react to a node entering or exiting
the game world, to a collision, to a character entering or leaving an area, to
an element of the interface changing size, and much more.

For example, an :ref:`Area2D <class_Area2D>` representing a coin emits a
``body_entered`` signal whenever the player's physics body enters its collision
shape, allowing you to know when the player collected it.

In the next section, :ref:`doc_your_first_2d_game`, you'll create a complete 2D
game and put everything you learned so far into practice.


===================================================
/. ./getting_started/first_2d_game/index.rst
===================================================

.. _doc_your_first_2d_game:

Your first 2D game
==================

In this step-by-step tutorial series, you will create your first complete 2D
game with Godot. By the end of the series, you will have a simple yet complete
game of your own, like the image below.

|image0|

You will learn how the Godot editor works, how to structure a project, and build
a 2D game.

.. note:: This project is an introduction to the Godot engine. It assumes that
          you have some programming experience already. If you're new to
          programming entirely, you should start here: :ref:`doc_scripting`.

The game is called "Dodge the Creeps!". Your character must move and avoid the
enemies for as long as possible. 

You will learn to:

- Create a complete 2D game with the Godot editor.
- Structure a simple game project.
- Move the player character and change its sprite.
- Spawn random enemies.
- Count the score.

And more.

You'll find another series where you'll create a similar game but in 3D. We
recommend you to start with this one, though.

**Why start with 2D?**

3D games are much more complex than 2D ones. It would be best if you stuck to 2D
until you understood the game development process and how to use Godot well.

You can find a completed version of this project at this location:

- https://github.com/godotengine/godot-demo-projects

Prerequisites
-------------

This step-by-step tutorial is intended for beginners who followed the complete
:ref:`Getting Started <toc-learn-step_by_step>`.

If you're an experienced programmer, you can find the complete demo's source
code here: `Godot demo projects
<https://github.com/godotengine/godot-demo-projects>`__.

We prepared some game assets you'll need to download so we can jump straight to
the code.

You can download them by clicking the link below.

:download:`dodge_assets.zip <files/dodge_assets.zip>`.

Contents
--------

.. toctree::
   :maxdepth: 1
   :name: toc-learn-first_2d_game

   01.project_setup
   02.player_scene
   03.coding_the_player
   04.creating_the_enemy
   05.the_main_game_scene
   06.heads_up_display
   07.finishing-up

.. |image0| image:: img/dodge_preview.gif


===================================================
/. ./getting_started/first_2d_game/01.project_setup.rst
===================================================

.. _doc_your_first_2d_game_project_setup:

Setting up the project
======================

In this short first part, we'll set up and organize the project.

Launch Godot and create a new project.

.. image:: img/new-project-button.png

.. tabs::
 .. tab:: GDScript

    Download :download:`dodge_assets.zip <files/dodge_assets.zip>`.
    The archive contains the images and sounds you'll be using
    to make the game. Extract the archive and move the ``art/``
    and ``fonts/`` directories to your project's directory.

 .. tab:: C#

    Download :download:`dodge_assets.zip <files/dodge_assets.zip>`.
    The archive contains the images and sounds you'll be using
    to make the game. Extract the archive and move the ``art/``
    and ``fonts/`` directories to your project's directory.

    Ensure that you have the required dependencies to use C# in Godot.
    You need the .NET Core 3.1 SDK, and an editor such as VS Code.
    See :ref:`doc_c_sharp_setup`.

 .. tab:: GDNative C++

    Download :download:`dodge_assets_with_gdnative.zip
    <files/dodge_assets_with_gdnative.zip>`.
    The archive contains the images and sounds you'll be using
    to make the game. It also contains a starter GDNative project
    including a ``SConstruct`` file, a ``dodge_the_creeps.gdnlib``
    file, a ``player.gdns`` file, and an ``entry.cpp`` file.

    Ensure that you have the required dependencies to use GDNative C++.
    You need a C++ compiler such as GCC or Clang or MSVC that supports C++14.
    On Windows you can download Visual Studio 2019 and select the C++ workload.
    You also need SCons to use the build system (the SConstruct file).
    Then you need to `download the Godot C++ bindings <https://github.com/godotengine/godot-cpp>`_
    and place them in your project.

Your project folder should look like this.

.. image:: img/folder-content.png

This game is designed for portrait mode, so we need to adjust the size of the
game window. Click on *Project -> Project Settings* to open the project settings
window and in the left column, open the *Display -> Window* tab. There, set
"Width" to ``480`` and "Height" to ``720``.

.. image:: img/setting-project-width-and-height.png

Also, scroll down to the bottom of the section and, under the "Stretch" options,
set ``Mode`` to "2d" and ``Aspect`` to "keep". This ensures that the game scales
consistently on different sized screens.

.. image:: img/setting-stretch-mode.png

Organizing the project
~~~~~~~~~~~~~~~~~~~~~~

In this project, we will make 3 independent scenes: ``Player``, ``Mob``, and
``HUD``, which we will combine into the game's ``Main`` scene.

In a larger project, it might be useful to create folders to hold the various
scenes and their scripts, but for this relatively small game, you can save your
scenes and scripts in the project's root folder, identified by ``res://``. You
can see your project folders in the FileSystem dock in the lower left corner:

.. image:: img/filesystem_dock.png

With the project in place, we're ready to design the player scene in the next lesson.


===================================================
/. ./getting_started/first_2d_game/02.player_scene.rst
===================================================

.. _doc_your_first_2d_game_player_scene:

Creating the player scene
=========================

With the project settings in place, we can start working on the
player-controlled character.

The first scene will define the ``Player`` object. One of the benefits of
creating a separate Player scene is that we can test it separately, even before
we've created other parts of the game.

Node structure
~~~~~~~~~~~~~~

To begin, we need to choose a root node for the player object. As a general
rule, a scene's root node should reflect the object's desired functionality -
what the object *is*. Click the "Other Node" button and add an :ref:`Area2D
<class_Area2D>` node to the scene.

.. image:: img/add_node.png

Godot will display a warning icon next to the node in the scene tree. You can
ignore it for now. We will address it later.

With ``Area2D`` we can detect objects that overlap or run into the player.
Change the node's name to ``Player`` by double-clicking on it. Now that we've
set the scene's root node, we can add additional nodes to give it more
functionality.

Before we add any children to the ``Player`` node, we want to make sure we don't
accidentally move or resize them by clicking on them. Select the node and click
the icon to the right of the lock; its tooltip says "Makes sure the object's
children are not selectable."

.. image:: img/lock_children.png

Save the scene. Click Scene -> Save, or press :kbd:`Ctrl + S` on Windows/Linux
or :kbd:`Cmd + S` on macOS.

.. note:: For this project, we will be following the Godot naming conventions.

          - **GDScript**: Classes (nodes) use PascalCase, variables and
            functions use snake_case, and constants use ALL_CAPS (See
            :ref:`doc_gdscript_styleguide`).

          - **C#**: Classes, export variables and methods use PascalCase,
            private fields use _camelCase, local variables and parameters use
            camelCase (See :ref:`doc_c_sharp_styleguide`). Be careful to type
            the method names precisely when connecting signals.


Sprite animation
~~~~~~~~~~~~~~~~

Click on the ``Player`` node and add an :ref:`AnimatedSprite
<class_AnimatedSprite>` node as a child. The ``AnimatedSprite`` will handle the
appearance and animations for our player. Notice that there is a warning symbol
next to the node. An ``AnimatedSprite`` requires a :ref:`SpriteFrames
<class_SpriteFrames>` resource, which is a list of the animations it can
display. To create one, find the ``Frames`` property in the Inspector and click
"[empty]" -> "New SpriteFrames". Click again to open the "SpriteFrames" panel:

.. image:: img/spriteframes_panel.png


On the left is a list of animations. Click the "default" one and rename it to
"walk". Then click the "New Animation" button to create a second animation named
"up". Find the player images in the "FileSystem" tab - they're in the ``art``
folder you unzipped earlier. Drag the two images for each animation, named
``playerGrey_up[1/2]`` and ``playerGrey_walk[1/2]``, into the "Animation Frames"
side of the panel for the corresponding animation:

.. image:: img/spriteframes_panel2.png

The player images are a bit too large for the game window, so we need to scale
them down. Click on the ``AnimatedSprite`` node and set the ``Scale`` property
to ``(0.5, 0.5)``. You can find it in the Inspector under the ``Node2D``
heading.

.. image:: img/player_scale.png

Finally, add a :ref:`CollisionShape2D <class_CollisionShape2D>` as a child of
``Player``. This will determine the player's "hitbox", or the bounds of its
collision area. For this character, a ``CapsuleShape2D`` node gives the best
fit, so next to "Shape" in the Inspector, click "[empty]"" -> "New
CapsuleShape2D". Using the two size handles, resize the shape to cover the
sprite:

.. image:: img/player_coll_shape.png

When you're finished, your ``Player`` scene should look like this:

.. image:: img/player_scene_nodes.png

Make sure to save the scene again after these changes.

In the next part, we'll add a script to the player node to move and animate it.
Then, we'll set up collision detection to know when the player got hit by
something.


===================================================
/. ./getting_started/first_2d_game/03.coding_the_player.rst
===================================================

.. _doc_your_first_2d_game_coding_the_player:

Coding the player
=================

In this lesson, we'll add player movement, animation, and set it up to detect
collisions.

To do so, we need to add some functionality that we can't get from a built-in
node, so we'll add a script. Click the ``Player`` node and click the "Attach
Script" button:

.. image:: img/add_script_button.png

In the script settings window, you can leave the default settings alone. Just
click "Create":

.. note:: If you're creating a C# script or other languages, select the language
          from the `language` drop down menu before hitting create.

.. image:: img/attach_node_window.png

.. note:: If this is your first time encountering GDScript, please read
          :ref:`doc_scripting` before continuing.

Start by declaring the member variables this object will need:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Area2D

    export var speed = 400 # How fast the player will move (pixels/sec).
    var screen_size # Size of the game window.

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Player : Area2D
    {
        [Export]
        public int Speed = 400; // How fast the player will move (pixels/sec).

        public Vector2 ScreenSize; // Size of the game window.
    }

 .. code-tab:: cpp

    // A `player.gdns` file has already been created for you. Attach it to the Player node.

    // Create two files `player.cpp` and `player.hpp` next to `entry.cpp` in `src`.
    // This code goes in `player.hpp`. We also define the methods we'll be using here.
    #ifndef PLAYER_H
    #define PLAYER_H

    #include <AnimatedSprite.hpp>
    #include <Area2D.hpp>
    #include <CollisionShape2D.hpp>
    #include <Godot.hpp>
    #include <Input.hpp>

    class Player : public godot::Area2D {
        GODOT_CLASS(Player, godot::Area2D)

        godot::AnimatedSprite *_animated_sprite;
        godot::CollisionShape2D *_collision_shape;
        godot::Input *_input;
        godot::Vector2 _screen_size; // Size of the game window.

    public:
        real_t speed = 400; // How fast the player will move (pixels/sec).

        void _init() {}
        void _ready();
        void _process(const double p_delta);
        void start(const godot::Vector2 p_position);
        void _on_Player_body_entered(godot::Node2D *_body);

        static void _register_methods();
    };

    #endif // PLAYER_H

Using the ``export`` keyword on the first variable ``speed`` allows us to set
its value in the Inspector. This can be handy for values that you want to be
able to adjust just like a node's built-in properties. Click on the ``Player``
node and you'll see the property now appears in the "Script Variables" section
of the Inspector. Remember, if you change the value here, it will override the
value written in the script.

.. warning:: If you're using C#, you need to (re)build the project assemblies
             whenever you want to see new export variables or signals. This
             build can be manually triggered by clicking the word "Mono" at the
             bottom of the editor window to reveal the Mono Panel, then clicking
             the "Build Project" button.

.. image:: img/export_variable.png

The ``_ready()`` function is called when a node enters the scene tree, which is
a good time to find the size of the game window:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        screen_size = get_viewport_rect().size

 .. code-tab:: csharp

    public override void _Ready()
    {
        ScreenSize = GetViewportRect().Size;
    }

 .. code-tab:: cpp

    // This code goes in `player.cpp`.
    #include "player.hpp"

    void Player::_ready() {
        _animated_sprite = get_node<godot::AnimatedSprite>("AnimatedSprite");
        _collision_shape = get_node<godot::CollisionShape2D>("CollisionShape2D");
        _input = godot::Input::get_singleton();
        _screen_size = get_viewport_rect().size;
    }

Now we can use the ``_process()`` function to define what the player will do.
``_process()`` is called every frame, so we'll use it to update elements of our
game, which we expect will change often. For the player, we need to do the
following:

- Check for input.
- Move in the given direction.
- Play the appropriate animation.

First, we need to check for input - is the player pressing a key? For this game,
we have 4 direction inputs to check. Input actions are defined in the Project
Settings under "Input Map". Here, you can define custom events and assign
different keys, mouse events, or other inputs to them. For this game, we will
map the arrow keys to the four directions.

Click on *Project -> Project Settings* to open the project settings window and
click on the *Input Map* tab at the top. Type "move_right" in the top bar and
click the "Add" button to add the ``move_right`` action.

.. image:: img/input-mapping-add-action.png

We need to assign a key to this action. Click the "+" icon on the right, then
click the "Key" option in the drop-down menu. A dialog asks you to type in the
desired key. Press the right arrow on your keyboard and click "Ok".

.. image:: img/input-mapping-add-key.png

Repeat these steps to add three more mappings:

1. ``move_left`` mapped to the left arrow key.
2. ``move_up`` mapped to the up arrow key.
3. And ``move_down`` mapped to the down arrow key.

Your input map tab should look like this:

.. image:: img/input-mapping-completed.png

Click the "Close" button to close the project settings.

.. note::

   We only mapped one key to each input action, but you can map multiple keys,
   joystick buttons, or mouse buttons to the same input action.

You can detect whether a key is pressed using ``Input.is_action_pressed()``,
which returns ``true`` if it's pressed or ``false`` if it isn't.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        var velocity = Vector2.ZERO # The player's movement vector.
        if Input.is_action_pressed("move_right"):
            velocity.x += 1
        if Input.is_action_pressed("move_left"):
            velocity.x -= 1
        if Input.is_action_pressed("move_down"):
            velocity.y += 1
        if Input.is_action_pressed("move_up"):
            velocity.y -= 1

        if velocity.length() > 0:
            velocity = velocity.normalized() * speed
            $AnimatedSprite.play()
        else:
            $AnimatedSprite.stop()

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        var velocity = Vector2.Zero; // The player's movement vector.

        if (Input.IsActionPressed("move_right"))
        {
            velocity.x += 1;
        }

        if (Input.IsActionPressed("move_left"))
        {
            velocity.x -= 1;
        }

        if (Input.IsActionPressed("move_down"))
        {
            velocity.y += 1;
        }

        if (Input.IsActionPressed("move_up"))
        {
            velocity.y -= 1;
        }

        var animatedSprite = GetNode<AnimatedSprite>("AnimatedSprite");

        if (velocity.Length() > 0)
        {
            velocity = velocity.Normalized() * Speed;
            animatedSprite.Play();
        }
        else
        {
            animatedSprite.Stop();
        }
    }

 .. code-tab:: cpp

    // This code goes in `player.cpp`.
    void Player::_process(const double p_delta) {
        godot::Vector2 velocity(0, 0);

        velocity.x = _input->get_action_strength("move_right") - _input->get_action_strength("move_left");
        velocity.y = _input->get_action_strength("move_down") - _input->get_action_strength("move_up");

        if (velocity.length() > 0) {
            velocity = velocity.normalized() * speed;
            _animated_sprite->play();
        } else {
            _animated_sprite->stop();
        }
    }

We start by setting the ``velocity`` to ``(0, 0)`` - by default, the player
should not be moving. Then we check each input and add/subtract from the
``velocity`` to obtain a total direction. For example, if you hold ``right`` and
``down`` at the same time, the resulting ``velocity`` vector will be ``(1, 1)``.
In this case, since we're adding a horizontal and a vertical movement, the
player would move *faster* diagonally than if it just moved horizontally.

We can prevent that if we *normalize* the velocity, which means we set its
*length* to ``1``, then multiply by the desired speed. This means no more fast
diagonal movement.

.. tip:: If you've never used vector math before, or need a refresher, you can
         see an explanation of vector usage in Godot at :ref:`doc_vector_math`.
         It's good to know but won't be necessary for the rest of this tutorial.

We also check whether the player is moving so we can call ``play()`` or
``stop()`` on the AnimatedSprite.

.. tip:: ``$`` is shorthand for ``get_node()``. So in the code above,
         ``$AnimatedSprite.play()`` is the same as
         ``get_node("AnimatedSprite").play()``.

         In GDScript, ``$`` returns the node at the relative path from the
         current node, or returns ``null`` if the node is not found. Since
         AnimatedSprite is a child of the current node, we can use
         ``$AnimatedSprite``.

Now that we have a movement direction, we can update the player's position. We
can also use ``clamp()`` to prevent it from leaving the screen. *Clamping* a
value means restricting it to a given range. Add the following to the bottom of
the ``_process`` function (make sure it's not indented under the `else`):

.. tabs::
 .. code-tab:: gdscript GDScript

        position += velocity * delta
        position.x = clamp(position.x, 0, screen_size.x)
        position.y = clamp(position.y, 0, screen_size.y)

 .. code-tab:: csharp

        Position += velocity * delta;
        Position = new Vector2(
            x: Mathf.Clamp(Position.x, 0, ScreenSize.x),
            y: Mathf.Clamp(Position.y, 0, ScreenSize.y)
        );

 .. code-tab:: cpp

        godot::Vector2 position = get_position();
        position += velocity * (real_t)p_delta;
        position.x = godot::Math::clamp(position.x, (real_t)0.0, _screen_size.x);
        position.y = godot::Math::clamp(position.y, (real_t)0.0, _screen_size.y);
        set_position(position);

.. tip:: The `delta` parameter in the `_process()` function refers to the *frame
        length* - the amount of time that the previous frame took to complete.
        Using this value ensures that your movement will remain consistent even
        if the frame rate changes.

Click "Play Scene" (:kbd:`F6`, :kbd:`Cmd + R` on macOS) and confirm you can move
the player around the screen in all directions.

.. warning:: If you get an error in the "Debugger" panel that says

            ``Attempt to call function 'play' in base 'null instance' on a null
            instance``

            this likely means you spelled the name of the AnimatedSprite node
            wrong. Node names are case-sensitive and ``$NodeName`` must match
            the name you see in the scene tree.

Choosing animations
~~~~~~~~~~~~~~~~~~~

Now that the player can move, we need to change which animation the
AnimatedSprite is playing based on its direction. We have the "walk" animation,
which shows the player walking to the right. This animation should be flipped
horizontally using the ``flip_h`` property for left movement. We also have the
"up" animation, which should be flipped vertically with ``flip_v`` for downward
movement. Let's place this code at the end of the ``_process()`` function:

.. tabs::
 .. code-tab:: gdscript GDScript

        if velocity.x != 0:
            $AnimatedSprite.animation = "walk"
            $AnimatedSprite.flip_v = false
            # See the note below about boolean assignment.
            $AnimatedSprite.flip_h = velocity.x < 0
        elif velocity.y != 0:
            $AnimatedSprite.animation = "up"
            $AnimatedSprite.flip_v = velocity.y > 0

 .. code-tab:: csharp

        if (velocity.x != 0)
        {
            animatedSprite.Animation = "walk";
            animatedSprite.FlipV = false;
            // See the note below about boolean assignment.
            animatedSprite.FlipH = velocity.x < 0;
        }
        else if (velocity.y != 0)
        {
            animatedSprite.Animation = "up";
            animatedSprite.FlipV = velocity.y > 0;
        }

 .. code-tab:: cpp

        if (velocity.x != 0) {
            _animated_sprite->set_animation("walk");
            _animated_sprite->set_flip_v(false);
            // See the note below about boolean assignment.
            _animated_sprite->set_flip_h(velocity.x < 0);
        } else if (velocity.y != 0) {
            _animated_sprite->set_animation("up");
            _animated_sprite->set_flip_v(velocity.y > 0);
        }

.. Note:: The boolean assignments in the code above are a common shorthand for
          programmers. Since we're doing a comparison test (boolean) and also
          *assigning* a boolean value, we can do both at the same time. Consider
          this code versus the one-line boolean assignment above:

          .. tabs::
           .. code-tab :: gdscript GDScript

             if velocity.x < 0:
                 $AnimatedSprite.flip_h = true
             else:
                 $AnimatedSprite.flip_h = false

           .. code-tab:: csharp

             if (velocity.x < 0)
             {
                 animatedSprite.FlipH = true;
             }
             else
             {
                 animatedSprite.FlipH = false;
             }

Play the scene again and check that the animations are correct in each of the
directions.

.. tip:: A common mistake here is to type the names of the animations wrong. The
        animation names in the SpriteFrames panel must match what you type in
        the code. If you named the animation ``"Walk"``, you must also use a
        capital "W" in the code.

When you're sure the movement is working correctly, add this line to
``_ready()``, so the player will be hidden when the game starts:

.. tabs::
 .. code-tab:: gdscript GDScript

    hide()

 .. code-tab:: csharp

    Hide();

 .. code-tab:: cpp

    hide();

Preparing for collisions
~~~~~~~~~~~~~~~~~~~~~~~~

We want ``Player`` to detect when it's hit by an enemy, but we haven't made any
enemies yet! That's OK, because we're going to use Godot's *signal*
functionality to make it work.

Add the following at the top of the script, after ``extends Area2D``:

.. tabs::
 .. code-tab:: gdscript GDScript

    signal hit

 .. code-tab:: csharp

    // Don't forget to rebuild the project so the editor knows about the new signal.

    [Signal]
    public delegate void Hit();

 .. code-tab:: cpp

    // This code goes in `player.cpp`.
    // We need to register the signal here, and while we're here, we can also
    // register the other methods and register the speed property.
    void Player::_register_methods() {
        godot::register_method("_ready", &Player::_ready);
        godot::register_method("_process", &Player::_process);
        godot::register_method("start", &Player::start);
        godot::register_method("_on_Player_body_entered", &Player::_on_Player_body_entered);
        godot::register_property("speed", &Player::speed, (real_t)400.0);
        // This below line is the signal.
        godot::register_signal<Player>("hit", godot::Dictionary());
    }

This defines a custom signal called "hit" that we will have our player emit
(send out) when it collides with an enemy. We will use ``Area2D`` to detect the
collision. Select the ``Player`` node and click the "Node" tab next to the
Inspector tab to see the list of signals the player can emit:

.. image:: img/player_signals.png

Notice our custom "hit" signal is there as well! Since our enemies are going to
be ``RigidBody2D`` nodes, we want the ``body_entered(body: Node)`` signal. This
signal will be emitted when a body contacts the player. Click "Connect.." and
the "Connect a Signal" window appears. We don't need to change any of these
settings so click "Connect" again. Godot will automatically create a function in
your player's script.

.. image:: img/player_signal_connection.png

Note the green icon indicating that a signal is connected to this function. Add
this code to the function:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_Player_body_entered(body):
        hide() # Player disappears after being hit.
        emit_signal("hit")
        # Must be deferred as we can't change physics properties on a physics callback.
        $CollisionShape2D.set_deferred("disabled", true)

 .. code-tab:: csharp

    public void OnPlayerBodyEntered(PhysicsBody2D body)
    {
        Hide(); // Player disappears after being hit.
        EmitSignal(nameof(Hit));
        // Must be deferred as we can't change physics properties on a physics callback.
        GetNode<CollisionShape2D>("CollisionShape2D").SetDeferred("disabled", true);
    }

 .. code-tab:: cpp

    // This code goes in `player.cpp`.
    void Player::_on_Player_body_entered(godot::Node2D *_body) {
        hide(); // Player disappears after being hit.
        emit_signal("hit");
        // Must be deferred as we can't change physics properties on a physics callback.
        _collision_shape->set_deferred("disabled", true);
    }

Each time an enemy hits the player, the signal is going to be emitted. We need
to disable the player's collision so that we don't trigger the ``hit`` signal
more than once.

.. Note:: Disabling the area's collision shape can cause an error if it happens
          in the middle of the engine's collision processing. Using
          ``set_deferred()`` tells Godot to wait to disable the shape until it's
          safe to do so.

The last piece is to add a function we can call to reset the player when
starting a new game.

.. tabs::
 .. code-tab:: gdscript GDScript

    func start(pos):
        position = pos
        show()
        $CollisionShape2D.disabled = false

 .. code-tab:: csharp

    public void Start(Vector2 pos)
    {
        Position = pos;
        Show();
        GetNode<CollisionShape2D>("CollisionShape2D").Disabled = false;
    }

 .. code-tab:: cpp

    // This code goes in `player.cpp`.
    void Player::start(const godot::Vector2 p_position) {
        set_position(p_position);
        show();
        _collision_shape->set_disabled(false);
    }

With the player working, we'll work on the enemy in the next lesson.


===================================================
/. ./getting_started/first_2d_game/04.creating_the_enemy.rst
===================================================

.. _doc_your_first_2d_game_creating_the_enemy:

Creating the enemy
==================

Now it's time to make the enemies our player will have to dodge. Their behavior
will not be very complex: mobs will spawn randomly at the edges of the screen,
choose a random direction, and move in a straight line.

We'll create a ``Mob`` scene, which we can then *instance* to create any number
of independent mobs in the game.

Node setup
~~~~~~~~~~

Click Scene -> New Scene and add the following nodes:

- :ref:`RigidBody2D <class_RigidBody2D>` (named ``Mob``)

   - :ref:`AnimatedSprite <class_AnimatedSprite>`
   - :ref:`CollisionShape2D <class_CollisionShape2D>`
   - :ref:`VisibilityNotifier2D <class_VisibilityNotifier2D>`

Don't forget to set the children so they can't be selected, like you did with
the Player scene.

In the :ref:`RigidBody2D <class_RigidBody2D>` properties, set ``Gravity Scale``
to ``0``, so the mob will not fall downward. In addition, under the
:ref:`CollisionObject2D <class_CollisionObject2D>` section, click the ``Mask`` property and uncheck the first
box. This will ensure the mobs do not collide with each other.

.. image:: img/set_collision_mask.png

Set up the :ref:`AnimatedSprite <class_AnimatedSprite>` like you did for the
player. This time, we have 3 animations: ``fly``, ``swim``, and ``walk``. There
are two images for each animation in the art folder.

Adjust the "Speed (FPS)" to ``3`` for all animations.

.. image:: img/mob_animations.gif

Set the ``Playing`` property in the Inspector to "On".

We'll select one of these animations randomly so that the mobs will have some
variety.

Like the player images, these mob images need to be scaled down. Set the
``AnimatedSprite``'s ``Scale`` property to ``(0.75, 0.75)``.

As in the ``Player`` scene, add a ``CapsuleShape2D`` for the collision. To align
the shape with the image, you'll need to set the ``Rotation Degrees`` property
to ``90`` (under "Transform" in the Inspector).

Save the scene.

Enemy script
~~~~~~~~~~~~

Add a script to the ``Mob`` like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends RigidBody2D

 .. code-tab:: csharp

    public class Mob : RigidBody2D
    {
        // Don't forget to rebuild the project.
    }

 .. code-tab:: cpp

    // Copy `player.gdns` to `mob.gdns` and replace `Player` with `Mob`.
    // Attach the `mob.gdns` file to the Mob node.

    // Create two files `mob.cpp` and `mob.hpp` next to `entry.cpp` in `src`.
    // This code goes in `mob.hpp`. We also define the methods we'll be using here.
    #ifndef MOB_H
    #define MOB_H

    #include <AnimatedSprite.hpp>
    #include <Godot.hpp>
    #include <RigidBody2D.hpp>

    class Mob : public godot::RigidBody2D {
        GODOT_CLASS(Mob, godot::RigidBody2D)

        godot::AnimatedSprite *_animated_sprite;

    public:
        void _init() {}
        void _ready();
        void _on_VisibilityNotifier2D_screen_exited();

        static void _register_methods();
    };

    #endif // MOB_H

Now let's look at the rest of the script. In ``_ready()`` we play the animation
and randomly choose one of the three animation types:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        $AnimatedSprite.playing = true
        var mob_types = $AnimatedSprite.frames.get_animation_names()
        $AnimatedSprite.animation = mob_types[randi() % mob_types.size()]

 .. code-tab:: csharp

    public override void _Ready()
    {
        var animSprite = GetNode<AnimatedSprite>("AnimatedSprite");
        animSprite.Playing = true;
        string[] mobTypes = animSprite.Frames.GetAnimationNames();
        animSprite.Animation = mobTypes[GD.Randi() % mobTypes.Length];
    }

 .. code-tab:: cpp

    // This code goes in `mob.cpp`.
    #include "mob.hpp"

    #include <RandomNumberGenerator.hpp>
    #include <SpriteFrames.hpp>

    void Mob::_ready() {
        godot::Ref<godot::RandomNumberGenerator> random = godot::RandomNumberGenerator::_new();
        random->randomize();
        _animated_sprite = get_node<godot::AnimatedSprite>("AnimatedSprite");
        _animated_sprite->_set_playing(true);
        godot::PoolStringArray mob_types = _animated_sprite->get_sprite_frames()->get_animation_names();
        _animated_sprite->set_animation(mob_types[random->randi() % mob_types.size()]);
    }

First, we get the list of animation names from the AnimatedSprite's ``frames``
property. This returns an Array containing all three animation names: ``["walk",
"swim", "fly"]``.

We then need to pick a random number between ``0`` and ``2`` to select one of
these names from the list (array indices start at ``0``). ``randi() % n``
selects a random integer between ``0`` and ``n-1``.

.. note:: You must use ``randomize()`` if you want your sequence of "random"
            numbers to be different every time you run the scene. We're going to
            use ``randomize()`` in our ``Main`` scene, so we won't need it here.

The last piece is to make the mobs delete themselves when they leave the screen.
Connect the ``screen_exited()`` signal of the ``VisibilityNotifier2D`` node and
add this code:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_VisibilityNotifier2D_screen_exited():
        queue_free()

 .. code-tab:: csharp

    public void OnVisibilityNotifier2DScreenExited()
    {
        QueueFree();
    }

 .. code-tab:: cpp

    // This code goes in `mob.cpp`.
    void Mob::_on_VisibilityNotifier2D_screen_exited() {
        queue_free();
    }

This completes the `Mob` scene.

With the player and enemies ready, in the next part, we'll bring them together
in a new scene. We'll make enemies spawn randomly around the game board and move
forward, turning our project into a playable game.


===================================================
/. ./getting_started/first_2d_game/05.the_main_game_scene.rst
===================================================

.. _doc_your_first_2d_game_the_main_game_scene:

The main game scene
===================

Now it's time to bring everything we did together into a playable game scene.

Create a new scene and add a :ref:`Node <class_Node>` named ``Main``.
(The reason we are using Node instead of Node2D is because this node will
be a container for handling game logic. It does not require 2D functionality itself.)

Click the **Instance** button (represented by a chain link icon) and select your saved
``Player.tscn``.

.. image:: img/instance_scene.png

Now, add the following nodes as children of ``Main``, and name them as shown
(values are in seconds):

- :ref:`Timer <class_Timer>` (named ``MobTimer``) - to control how often mobs
  spawn
- :ref:`Timer <class_Timer>` (named ``ScoreTimer``) - to increment the score
  every second
- :ref:`Timer <class_Timer>` (named ``StartTimer``) - to give a delay before
  starting
- :ref:`Position2D <class_Position2D>` (named ``StartPosition``) - to indicate
  the player's start position

Set the ``Wait Time`` property of each of the ``Timer`` nodes as follows:

- ``MobTimer``: ``0.5``
- ``ScoreTimer``: ``1``
- ``StartTimer``: ``2``

In addition, set the ``One Shot`` property of ``StartTimer`` to "On" and set
``Position`` of the ``StartPosition`` node to ``(240, 450)``.

Spawning mobs
~~~~~~~~~~~~~

The Main node will be spawning new mobs, and we want them to appear at a random
location on the edge of the screen. Add a :ref:`Path2D <class_Path2D>` node
named ``MobPath`` as a child of ``Main``. When you select ``Path2D``, you will
see some new buttons at the top of the editor:

.. image:: img/path2d_buttons.png

Select the middle one ("Add Point") and draw the path by clicking to add the
points at the corners shown. To have the points snap to the grid, make sure "Use
Grid Snap" and "Use Snap" are both selected. These options can be found to the
left of the "Lock" button, appearing as a magnet next to some dots and
intersecting lines, respectively.

.. image:: img/grid_snap_button.png

.. important:: Draw the path in *clockwise* order, or your mobs will spawn
               pointing *outwards* instead of *inwards*!

.. image:: img/draw_path2d.gif

After placing point ``4`` in the image, click the "Close Curve" button and your
curve will be complete.

Now that the path is defined, add a :ref:`PathFollow2D <class_PathFollow2D>`
node as a child of ``MobPath`` and name it ``MobSpawnLocation``. This node will
automatically rotate and follow the path as it moves, so we can use it to select
a random position and direction along the path.

Your scene should look like this:

.. image:: img/main_scene_nodes.png

Main script
~~~~~~~~~~~

Add a script to ``Main``. At the top of the script, we use ``export
(PackedScene)`` to allow us to choose the Mob scene we want to instance.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node

    export(PackedScene) var mob_scene
    var score

 .. code-tab:: csharp

    public class Main : Node
    {
        // Don't forget to rebuild the project so the editor knows about the new export variable.

    #pragma warning disable 649
        // We assign this in the editor, so we don't need the warning about not being assigned.
        [Export]
        public PackedScene MobScene;
    #pragma warning restore 649

        public int Score;
    }

 .. code-tab:: cpp

    // Copy `player.gdns` to `main.gdns` and replace `Player` with `Main`.
    // Attach the `main.gdns` file to the Main node.

    // Create two files `main.cpp` and `main.hpp` next to `entry.cpp` in `src`.
    // This code goes in `main.hpp`. We also define the methods we'll be using here.
    #ifndef MAIN_H
    #define MAIN_H

    #include <AudioStreamPlayer.hpp>
    #include <CanvasLayer.hpp>
    #include <Godot.hpp>
    #include <Node.hpp>
    #include <PackedScene.hpp>
    #include <PathFollow2D.hpp>
    #include <RandomNumberGenerator.hpp>
    #include <Timer.hpp>

    #include "hud.hpp"
    #include "player.hpp"

    class Main : public godot::Node {
        GODOT_CLASS(Main, godot::Node)

        int score;
        HUD *_hud;
        Player *_player;
        godot::Node2D *_start_position;
        godot::PathFollow2D *_mob_spawn_location;
        godot::Timer *_mob_timer;
        godot::Timer *_score_timer;
        godot::Timer *_start_timer;
        godot::AudioStreamPlayer *_music;
        godot::AudioStreamPlayer *_death_sound;
        godot::Ref<godot::RandomNumberGenerator> _random;

    public:
        godot::Ref<godot::PackedScene> mob_scene;

        void _init() {}
        void _ready();
        void game_over();
        void new_game();
        void _on_MobTimer_timeout();
        void _on_ScoreTimer_timeout();
        void _on_StartTimer_timeout();

        static void _register_methods();
    };

    #endif // MAIN_H

We also add a call to ``randomize()`` here so that the random number
generator generates different random numbers each time the game is run:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        randomize()

 .. code-tab:: csharp

    public override void _Ready()
    {
        GD.Randomize();
    }

 .. code-tab:: cpp

    // This code goes in `main.cpp`.
    #include "main.hpp"

    #include <SceneTree.hpp>

    #include "mob.hpp"

    void Main::_ready() {
        _hud = get_node<HUD>("HUD");
        _player = get_node<Player>("Player");
        _start_position = get_node<godot::Node2D>("StartPosition");
        _mob_spawn_location = get_node<godot::PathFollow2D>("MobPath/MobSpawnLocation");
        _mob_timer = get_node<godot::Timer>("MobTimer");
        _score_timer = get_node<godot::Timer>("ScoreTimer");
        _start_timer = get_node<godot::Timer>("StartTimer");
        // Uncomment these after adding the nodes in the "Sound effects" section of "Finishing up".
        //_music = get_node<godot::AudioStreamPlayer>("Music");
        //_death_sound = get_node<godot::AudioStreamPlayer>("DeathSound");
        _random = (godot::Ref<godot::RandomNumberGenerator>)godot::RandomNumberGenerator::_new();
        _random->randomize();
    }

Click the ``Main`` node and you will see the ``Mob Scene`` property in the Inspector
under "Script Variables".

You can assign this property's value in two ways:

- Drag ``Mob.tscn`` from the "FileSystem" dock and drop it in the **Mob Scene**
  property.
- Click the down arrow next to "[empty]" and choose "Load". Select ``Mob.tscn``.

Next, select the ``Player`` node in the Scene dock, and access the Node dock on
the sidebar. Make sure to have the Signals tab selected in the Node dock.

You should see a list of the signals for the ``Player`` node. Find and
double-click the ``hit`` signal in the list (or right-click it and select
"Connect..."). This will open the signal connection dialog. We want to make a
new function named ``game_over``, which will handle what needs to happen when a
game ends. Type "game_over" in the "Receiver Method" box at the bottom of the
signal connection dialog and click "Connect". Add the following code to the new
function, as well as a ``new_game`` function that will set everything up for a
new game:

.. tabs::
 .. code-tab:: gdscript GDScript

    func game_over():
        $ScoreTimer.stop()
        $MobTimer.stop()

    func new_game():
        score = 0
        $Player.start($StartPosition.position)
        $StartTimer.start()

 .. code-tab:: csharp

    public void GameOver()
    {
        GetNode<Timer>("MobTimer").Stop();
        GetNode<Timer>("ScoreTimer").Stop();
    }

    public void NewGame()
    {
        Score = 0;

        var player = GetNode<Player>("Player");
        var startPosition = GetNode<Position2D>("StartPosition");
        player.Start(startPosition.Position);

        GetNode<Timer>("StartTimer").Start();
    }

 .. code-tab:: cpp

    // This code goes in `main.cpp`.
    void Main::game_over() {
        _score_timer->stop();
        _mob_timer->stop();
    }

    void Main::new_game() {
        score = 0;
        _player->start(_start_position->get_position());
        _start_timer->start();
    }

Now connect the ``timeout()`` signal of each of the Timer nodes (``StartTimer``,
``ScoreTimer`` , and ``MobTimer``) to the main script. ``StartTimer`` will start
the other two timers. ``ScoreTimer`` will increment the score by 1.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_ScoreTimer_timeout():
        score += 1

    func _on_StartTimer_timeout():
        $MobTimer.start()
        $ScoreTimer.start()

 .. code-tab:: csharp

    public void OnScoreTimerTimeout()
    {
        Score++;
    }

    public void OnStartTimerTimeout()
    {
        GetNode<Timer>("MobTimer").Start();
        GetNode<Timer>("ScoreTimer").Start();
    }

 .. code-tab:: cpp

    // This code goes in `main.cpp`.
    void Main::_on_ScoreTimer_timeout() {
        score += 1;
    }

    void Main::_on_StartTimer_timeout() {
        _mob_timer->start();
        _score_timer->start();
    }

    // Also add this to register all methods and the mob scene property.
    void Main::_register_methods() {
        godot::register_method("_ready", &Main::_ready);
        godot::register_method("game_over", &Main::game_over);
        godot::register_method("new_game", &Main::new_game);
        godot::register_method("_on_MobTimer_timeout", &Main::_on_MobTimer_timeout);
        godot::register_method("_on_ScoreTimer_timeout", &Main::_on_ScoreTimer_timeout);
        godot::register_method("_on_StartTimer_timeout", &Main::_on_StartTimer_timeout);
        godot::register_property("mob_scene", &Main::mob_scene, (godot::Ref<godot::PackedScene>)nullptr);
    }

In ``_on_MobTimer_timeout()``, we will create a mob instance, pick a random
starting location along the ``Path2D``, and set the mob in motion. The
``PathFollow2D`` node will automatically rotate as it follows the path, so we
will use that to select the mob's direction as well as its position.
When we spawn a mob, we'll pick a random value between ``150.0`` and
``250.0`` for how fast each mob will move (it would be boring if they were
all moving at the same speed).

Note that a new instance must be added to the scene using ``add_child()``.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_MobTimer_timeout():
        # Create a new instance of the Mob scene.
        var mob = mob_scene.instance()

        # Choose a random location on Path2D.
        var mob_spawn_location = get_node("MobPath/MobSpawnLocation")
        mob_spawn_location.offset = randi()

        # Set the mob's direction perpendicular to the path direction.
        var direction = mob_spawn_location.rotation + PI / 2

        # Set the mob's position to a random location.
        mob.position = mob_spawn_location.position

        # Add some randomness to the direction.
        direction += rand_range(-PI / 4, PI / 4)
        mob.rotation = direction

        # Choose the velocity for the mob.
        var velocity = Vector2(rand_range(150.0, 250.0), 0.0)
        mob.linear_velocity = velocity.rotated(direction)

        # Spawn the mob by adding it to the Main scene.
        add_child(mob)

 .. code-tab:: csharp

    public void OnMobTimerTimeout()
    {
        // Note: Normally it is best to use explicit types rather than the `var`
        // keyword. However, var is acceptable to use here because the types are
        // obviously Mob and PathFollow2D, since they appear later on the line.

        // Create a new instance of the Mob scene.
        var mob = (Mob)MobScene.Instance();

        // Choose a random location on Path2D.
        var mobSpawnLocation = GetNode<PathFollow2D>("MobPath/MobSpawnLocation");
        mobSpawnLocation.Offset = GD.Randi();

        // Set the mob's direction perpendicular to the path direction.
        float direction = mobSpawnLocation.Rotation + Mathf.Pi / 2;

        // Set the mob's position to a random location.
        mob.Position = mobSpawnLocation.Position;

        // Add some randomness to the direction.
        direction += (float)GD.RandRange(-Mathf.Pi / 4, Mathf.Pi / 4);
        mob.Rotation = direction;

        // Choose the velocity.
        var velocity = new Vector2((float)GD.RandRange(150.0, 250.0), 0);
        mob.LinearVelocity = velocity.Rotated(direction);

        // Spawn the mob by adding it to the Main scene.
        AddChild(mob);
    }

 .. code-tab:: cpp

    // This code goes in `main.cpp`.
    void Main::_on_MobTimer_timeout() {
        // Create a new instance of the Mob scene.
        godot::Node *mob = mob_scene->instance();

        // Choose a random location on Path2D.
        _mob_spawn_location->set_offset((real_t)_random->randi());

        // Set the mob's direction perpendicular to the path direction.
        real_t direction = _mob_spawn_location->get_rotation() + (real_t)Math_PI / 2;

        // Set the mob's position to a random location.
        mob->set("position", _mob_spawn_location->get_position());

        // Add some randomness to the direction.
        direction += _random->randf_range((real_t)-Math_PI / 4, (real_t)Math_PI / 4);
        mob->set("rotation", direction);

        // Choose the velocity for the mob.
        godot::Vector2 velocity = godot::Vector2(_random->randf_range(150.0, 250.0), 0.0);
        mob->set("linear_velocity", velocity.rotated(direction));

        // Spawn the mob by adding it to the Main scene.
        add_child(mob);
    }

.. important:: Why ``PI``? In functions requiring angles, Godot uses *radians*,
               not degrees. Pi represents a half turn in radians, about
               ``3.1415`` (there is also ``TAU`` which is equal to ``2 * PI``).
               If you're more comfortable working with degrees, you'll need to
               use the ``deg2rad()`` and ``rad2deg()`` functions to convert
               between the two.

Testing the scene
~~~~~~~~~~~~~~~~~

Let's test the scene to make sure everything is working. Add this ``new_game``
call to ``_ready()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        randomize()
        new_game()

 .. code-tab:: csharp

    public override void _Ready()
    {
        NewGame();
    }

 .. code-tab:: cpp

    // This code goes in `main.cpp`.
    void Main::_ready() {
        new_game();
    }

Let's also assign ``Main`` as our "Main Scene" - the one that runs automatically
when the game launches. Press the "Play" button and select ``Main.tscn`` when
prompted.

.. tip:: If you had already set another scene as the "Main Scene", you can right
         click ``Main.tscn`` in the FileSystem dock and select "Set As Main Scene".

You should be able to move the player around, see mobs spawning, and see the
player disappear when hit by a mob.

When you're sure everything is working, remove the call to ``new_game()`` from
``_ready()``.

What's our game lacking? Some user interface. In the next lesson, we'll add a
title screen and display the player's score.


===================================================
/. ./getting_started/first_2d_game/06.heads_up_display.rst
===================================================

.. _doc_your_first_2d_game_heads_up_display:

Heads up display
================

The final piece our game needs is a User Interface (UI) to display things like
score, a "game over" message, and a restart button.

Create a new scene, and add a :ref:`CanvasLayer <class_CanvasLayer>` node named
``HUD``. "HUD" stands for "heads-up display", an informational display that
appears as an overlay on top of the game view.

The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements on
a layer above the rest of the game, so that the information it displays isn't
covered up by any game elements like the player or mobs.

The HUD needs to display the following information:

- Score, changed by ``ScoreTimer``.
- A message, such as "Game Over" or "Get Ready!"
- A "Start" button to begin the game.

The basic node for UI elements is :ref:`Control <class_Control>`. To create our
UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:`Label
<class_Label>` and :ref:`Button <class_Button>`.

Create the following as children of the ``HUD`` node:

- :ref:`Label <class_Label>` named ``ScoreLabel``.
- :ref:`Label <class_Label>` named ``Message``.
- :ref:`Button <class_Button>` named ``StartButton``.
- :ref:`Timer <class_Timer>` named ``MessageTimer``.

Click on the ``ScoreLabel`` and type a number into the ``Text`` field in the
Inspector. The default font for ``Control`` nodes is small and doesn't scale
well. There is a font file included in the game assets called
"Xolonium-Regular.ttf". To use this font, do the following:

1. Under **Theme overrides > Fonts** click on the empty box and select "New DynamicFont"

.. image:: img/custom_font1.png

2. Click on the "DynamicFont" you added, and under **Font > FontData**,
   choose "Load" and select the "Xolonium-Regular.ttf" file.

.. image:: img/custom_font2.png

Set the "Size" property under ``Settings``, ``64`` works well.

.. image:: img/custom_font3.png

Once you've done this on the ``ScoreLabel``, you can click the down arrow next
to the Font property and choose "Copy", then "Paste" it in the same place
on the other two Control nodes.

.. note:: **Anchors and Margins:** ``Control`` nodes have a position and size,
          but they also have anchors and margins. Anchors define the origin -
          the reference point for the edges of the node. Margins update
          automatically when you move or resize a control node. They represent
          the distance from the control node's edges to its anchor.

Arrange the nodes as shown below. Click the "Layout" button to set a Control
node's layout:

.. image:: img/ui_anchor.png

You can drag the nodes to place them manually, or for more precise placement,
use the following settings:

ScoreLabel
~~~~~~~~~~

-  *Layout* : "Top Wide"
-  *Text* : ``0``
-  *Align* : "Center"

Message
~~~~~~~~~~~~

-  *Layout* : "HCenter Wide"
-  *Text* : ``Dodge the Creeps!``
-  *Align* : "Center"
-  *Autowrap* : "On"

StartButton
~~~~~~~~~~~

-  *Text* : ``Start``
-  *Layout* : "Center Bottom"
-  *Margin* :

   -  Top: ``-200``
   -  Bottom: ``-100``

On the ``MessageTimer``, set the ``Wait Time`` to ``2`` and set the ``One Shot``
property to "On".

Now add this script to ``HUD``:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends CanvasLayer

    signal start_game

 .. code-tab:: csharp

    public class HUD : CanvasLayer
    {
        // Don't forget to rebuild the project so the editor knows about the new signal.

        [Signal]
        public delegate void StartGame();
    }

 .. code-tab:: cpp

    // Copy `player.gdns` to `hud.gdns` and replace `Player` with `HUD`.
    // Attach the `hud.gdns` file to the HUD node.

    // Create two files `hud.cpp` and `hud.hpp` next to `entry.cpp` in `src`.
    // This code goes in `hud.hpp`. We also define the methods we'll be using here.
    #ifndef HUD_H
    #define HUD_H

    #include <Button.hpp>
    #include <CanvasLayer.hpp>
    #include <Godot.hpp>
    #include <Label.hpp>
    #include <Timer.hpp>

    class HUD : public godot::CanvasLayer {
        GODOT_CLASS(HUD, godot::CanvasLayer)

        godot::Label *_score_label;
        godot::Label *_message_label;
        godot::Timer *_start_message_timer;
        godot::Timer *_get_ready_message_timer;
        godot::Button *_start_button;
        godot::Timer *_start_button_timer;

    public:
        void _init() {}
        void _ready();
        void show_get_ready();
        void show_game_over();
        void update_score(const int score);
        void _on_StartButton_pressed();
        void _on_StartMessageTimer_timeout();
        void _on_GetReadyMessageTimer_timeout();

        static void _register_methods();
    };

    #endif // HUD_H

The ``start_game`` signal tells the ``Main`` node that the button
has been pressed.

.. tabs::
 .. code-tab:: gdscript GDScript

    func show_message(text):
        $Message.text = text
        $Message.show()
        $MessageTimer.start()

 .. code-tab:: csharp

    public void ShowMessage(string text)
    {
        var message = GetNode<Label>("Message");
        message.Text = text;
        message.Show();

        GetNode<Timer>("MessageTimer").Start();
    }

 .. code-tab:: cpp

    // This code goes in `hud.cpp`.
    #include "hud.hpp"

    void HUD::_ready() {
        _score_label = get_node<godot::Label>("ScoreLabel");
        _message_label = get_node<godot::Label>("MessageLabel");
        _start_message_timer = get_node<godot::Timer>("StartMessageTimer");
        _get_ready_message_timer = get_node<godot::Timer>("GetReadyMessageTimer");
        _start_button = get_node<godot::Button>("StartButton");
        _start_button_timer = get_node<godot::Timer>("StartButtonTimer");
    }

    void HUD::_register_methods() {
        godot::register_method("_ready", &HUD::_ready);
        godot::register_method("show_get_ready", &HUD::show_get_ready);
        godot::register_method("show_game_over", &HUD::show_game_over);
        godot::register_method("update_score", &HUD::update_score);
        godot::register_method("_on_StartButton_pressed", &HUD::_on_StartButton_pressed);
        godot::register_method("_on_StartMessageTimer_timeout", &HUD::_on_StartMessageTimer_timeout);
        godot::register_method("_on_GetReadyMessageTimer_timeout", &HUD::_on_GetReadyMessageTimer_timeout);
        godot::register_signal<HUD>("start_game", godot::Dictionary());
    }

This function is called when we want to display a message
temporarily, such as "Get Ready".

.. tabs::
 .. code-tab:: gdscript GDScript

    func show_game_over():
        show_message("Game Over")
        # Wait until the MessageTimer has counted down.
        yield($MessageTimer, "timeout")

        $Message.text = "Dodge the\nCreeps!"
        $Message.show()
        # Make a one-shot timer and wait for it to finish.
        yield(get_tree().create_timer(1), "timeout")
        $StartButton.show()

 .. code-tab:: csharp

    async public void ShowGameOver()
    {
        ShowMessage("Game Over");

        var messageTimer = GetNode<Timer>("MessageTimer");
        await ToSignal(messageTimer, "timeout");

        var message = GetNode<Label>("Message");
        message.Text = "Dodge the\nCreeps!";
        message.Show();

        await ToSignal(GetTree().CreateTimer(1), "timeout");
        GetNode<Button>("StartButton").Show();
    }

 .. code-tab:: cpp

    // This code goes in `hud.cpp`.
    // There is no `yield` in GDNative, so we need to have every
    // step be its own method that is called on timer timeout.
    void HUD::show_get_ready() {
        _message_label->set_text("Get Ready");
        _message_label->show();
        _get_ready_message_timer->start();
    }

    void HUD::show_game_over() {
        _message_label->set_text("Game Over");
        _message_label->show();
        _start_message_timer->start();
    }

This function is called when the player loses. It will show "Game Over" for 2
seconds, then return to the title screen and, after a brief pause, show the
"Start" button.

.. note:: When you need to pause for a brief time, an alternative to using a
          Timer node is to use the SceneTree's ``create_timer()`` function. This
          can be very useful to add delays such as in the above code, where we
          want to wait some time before showing the "Start" button.

.. tabs::
 .. code-tab:: gdscript GDScript

    func update_score(score):
        $ScoreLabel.text = str(score)

 .. code-tab:: csharp

    public void UpdateScore(int score)
    {
        GetNode<Label>("ScoreLabel").Text = score.ToString();
    }

 .. code-tab:: cpp

    // This code goes in `hud.cpp`.
    void HUD::update_score(const int p_score) {
        _score_label->set_text(godot::Variant(p_score));
    }

This function is called by ``Main`` whenever the score changes.

Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()``
signal of ``StartButton`` and add the following code to the new functions:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_StartButton_pressed():
        $StartButton.hide()
        emit_signal("start_game")

    func _on_MessageTimer_timeout():
        $Message.hide()

 .. code-tab:: csharp

    public void OnStartButtonPressed()
    {
        GetNode<Button>("StartButton").Hide();
        EmitSignal("StartGame");
    }

    public void OnMessageTimerTimeout()
    {
        GetNode<Label>("Message").Hide();
    }

 .. code-tab:: cpp

    // This code goes in `hud.cpp`.
    void HUD::_on_StartButton_pressed() {
        _start_button_timer->stop();
        _start_button->hide();
        emit_signal("start_game");
    }

    void HUD::_on_StartMessageTimer_timeout() {
        _message_label->set_text("Dodge the\nCreeps");
        _message_label->show();
        _start_button_timer->start();
    }

    void HUD::_on_GetReadyMessageTimer_timeout() {
        _message_label->hide();
    }

Connecting HUD to Main
~~~~~~~~~~~~~~~~~~~~~~

Now that we're done creating the ``HUD`` scene, go back to ``Main``. Instance
the ``HUD`` scene in ``Main`` like you did the ``Player`` scene. The scene tree
should look like this, so make sure you didn't miss anything:

.. image:: img/completed_main_scene.png

Now we need to connect the ``HUD`` functionality to our ``Main`` script. This
requires a few additions to the ``Main`` scene:

In the Node tab, connect the HUD's ``start_game`` signal to the ``new_game()``
function of the Main node by typing "new_game" in the "Receiver Method" in the
"Connect a Signal" window. Verify that the green connection icon now appears
next to ``func new_game()`` in the script.

In ``new_game()``, update the score display and show the "Get Ready" message:

.. tabs::
 .. code-tab:: gdscript GDScript

        $HUD.update_score(score)
        $HUD.show_message("Get Ready")

 .. code-tab:: csharp

        var hud = GetNode<HUD>("HUD");
        hud.UpdateScore(Score);
        hud.ShowMessage("Get Ready!");

 .. code-tab:: cpp

        _hud->update_score(score);
        _hud->show_get_ready();

In ``game_over()`` we need to call the corresponding ``HUD`` function:

.. tabs::
 .. code-tab:: gdscript GDScript

        $HUD.show_game_over()

 .. code-tab:: csharp

        GetNode<HUD>("HUD").ShowGameOver();

 .. code-tab:: cpp

        _hud->show_game_over();

Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in sync
with the changing score:

.. tabs::
 .. code-tab:: gdscript GDScript

        $HUD.update_score(score)

 .. code-tab:: csharp

        GetNode<HUD>("HUD").UpdateScore(Score);

 .. code-tab:: cpp

        _hud->update_score(score);

Now you're ready to play! Click the "Play the Project" button. You will be asked
to select a main scene, so choose ``Main.tscn``.

Removing old creeps
~~~~~~~~~~~~~~~~~~~

If you play until "Game Over" and then start a new game right away, the creeps
from the previous game may still be on the screen. It would be better if they
all disappeared at the start of a new game. We just need a way to tell *all* the
mobs to remove themselves. We can do this with the "group" feature.

In the ``Mob`` scene, select the root node and click the "Node" tab next to the
Inspector (the same place where you find the node's signals). Next to "Signals",
click "Groups" and you can type a new group name and click "Add".

.. image:: img/group_tab.png

Now all mobs will be in the "mobs" group. We can then add the following line to
the ``new_game()`` function in ``Main``:

.. tabs::
 .. code-tab:: gdscript GDScript

        get_tree().call_group("mobs", "queue_free")

 .. code-tab:: csharp

        // Note that for calling Godot-provided methods with strings,
        // we have to use the original Godot snake_case name.
        GetTree().CallGroup("mobs", "queue_free");

 .. code-tab:: cpp

        get_tree()->call_group("mobs", "queue_free");

The ``call_group()`` function calls the named function on every node in a
group - in this case we are telling every mob to delete itself.

The game's mostly done at this point. In the next and last part, we'll polish it
a bit by adding a background, looping music, and some keyboard shortcuts.


===================================================
/. ./getting_started/first_2d_game/07.finishing-up.rst
===================================================

.. _doc_your_first_2d_game_finishing_up:

Finishing up
============

We have now completed all the functionality for our game. Below are some
remaining steps to add a bit more "juice" to improve the game experience.

Feel free to expand the gameplay with your own ideas.

Background
~~~~~~~~~~

The default gray background is not very appealing, so let's change its color.
One way to do this is to use a :ref:`ColorRect <class_ColorRect>` node. Make it
the first node under ``Main`` so that it will be drawn behind the other nodes.
``ColorRect`` only has one property: ``Color``. Choose a color you like and
select "Layout" -> "Full Rect" so that it covers the screen.

You could also add a background image, if you have one, by using a
``TextureRect`` node instead.

Sound effects
~~~~~~~~~~~~~

Sound and music can be the single most effective way to add appeal to the game
experience. In your game assets folder, you have two sound files: "House In a
Forest Loop.ogg" for background music, and "gameover.wav" for when the player
loses.

Add two :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` nodes as children of
``Main``. Name one of them ``Music`` and the other ``DeathSound``. On each one,
click on the ``Stream`` property, select "Load", and choose the corresponding
audio file.

To play the music, add ``$Music.play()`` in the ``new_game()`` function and
``$Music.stop()`` in the ``game_over()`` function.

Finally, add ``$DeathSound.play()`` in the ``game_over()`` function.

Keyboard shortcut
~~~~~~~~~~~~~~~~~

Since the game is played with keyboard controls, it would be convenient if we
could also start the game by pressing a key on the keyboard. We can do this with
the "Shortcut" property of the ``Button`` node.

In a previous lesson, we created four input actions to move the character. We
will create a similar input action to map to the start button.

Select "Project" -> "Project Settings" and then click on the "Input Map"
tab. In the same way you created the movement input actions, create a new
input action called ``start_game`` and add a key mapping for the :kbd:`Enter`
key.

In the ``HUD`` scene, select the ``StartButton`` and find its *Shortcut*
property in the Inspector. Select "New Shortcut" and click on the "Shortcut"
item. A second *Shortcut* property will appear. Select "New InputEventAction"
and click the new "InputEventAction". Finally, in the *Action* property, type
the name ``start_game``.

.. image:: img/start_button_shortcut.png

Now when the start button appears, you can either click it or press :kbd:`Enter`
to start the game.

And with that, you completed your first 2D game in Godot.

.. image:: img/dodge_preview.gif

You got to make a player-controlled character, enemies that spawn randomly
around the game board, count the score, implement a game over and replay, user
interface, sounds, and more. Congratulations!

There's still much to learn, but you can take a moment to appreciate what you
achieved.

And when you're ready, you can move on to :ref:`doc_your_first_3d_game` to learn
to create a complete 3D game from scratch, in Godot.


===================================================
/. ./getting_started/first_3d_game/index.rst
===================================================

.. _doc_your_first_3d_game:

Your first 3D game
==================

In this step-by-step tutorial series, you will create your first complete 3D
game with Godot. By the end of the series, you will have a simple yet finished
project of your own like the animated gif below.

|image0|

The game we'll code here is similar to :ref:`doc_your_first_2d_game`, with a twist:
you can now jump and your goal is to squash the creeps. This way, you will both
**recognize patterns** you learned in the previous tutorial and **build upon
them** with new code and features.

You will learn to:

- Work with 3D coordinates with a jumping mechanic.
- Use kinematic bodies to move 3D characters and detect when and how they
  collide.
- Use physics layers and a group to detect interactions with specific entities.
- Code basic procedural gameplay by instancing monsters at regular time
  intervals.
- Design a movement animation and change its speed at run-time.
- Draw a user interface on a 3D game.

And more.

This tutorial is for beginners who followed the complete getting started series.
We'll start slow with detailed instructions and shorten them as we do similar
steps. If you're an experienced programmer, you can browse the complete demo's
source code here: `Squash the Creep source code
<https://github.com/GDQuest/godot-3d-dodge-the-creeps/>`__.

.. note::

    You can follow this series without having done the 2D one. However, if
    you're new to game development, we recommend you to start with 2D. 3D game
    code is always more complex and the 2D series will give you foundations to
    follow along more comfortably.

We prepared some game assets so we can jump straight to the code. You can
download them here: `Squash the Creeps assets
<https://github.com/GDQuest/godot-3d-dodge-the-creeps/releases/tag/1.1.0>`__.

We will first work on a basic prototype for the player's movement. We will then
add the monsters that we'll spawn randomly around the screen. After that, we'll
implement the jump and squashing mechanic before refining the game with some
nice animation. We'll wrap up with the score and the retry screen.

Contents
--------

.. toctree::
   :maxdepth: 1
   :name: toc-learn-first_3d_game

   01.game_setup
   02.player_input
   03.player_movement_code
   04.mob_scene
   05.spawning_mobs
   06.jump_and_squash
   07.killing_player
   08.score_and_replay
   09.adding_animations
   going_further

.. |image0| image:: img/squash-the-creeps-final.gif


===================================================
/. ./getting_started/first_3d_game/01.game_setup.rst
===================================================

.. _doc_first_3d_game_game_area:

Setting up the game area
========================

In this first part, we're going to set up the game area. Let's get started by
importing the start assets and setting up the game scene.

We've prepared a Godot project with the 3D models and sounds we'll use for this
tutorial, linked in the index page. If you haven't done so yet, you can download
the archive here: `Squash the Creeps assets
<https://github.com/GDQuest/godot-3d-dodge-the-creeps/releases/tag/1.0.0>`__.

Once you downloaded it, extract the .zip archive on your computer. Open the
Godot project manager and click the *Import* button.

|image1|

In the import popup, enter the full path to the freshly created directory
``squash_the_creeps_start/``. You can click the *Browse* button on the right to
open a file browser and navigate to the ``project.godot`` file the folder
contains.

|image2|

Click *Import & Edit* to open the project in the editor.

|image3|

The start project contains an icon and two folders: ``art/`` and ``fonts/``.
There, you will find the art assets and music we'll use in the game.

|image4|

There are two 3D models, ``player.glb`` and ``mob.glb``, some materials that
belong to these models, and a music track.

Setting up the playable area
----------------------------

We're going to create our main scene with a plain *Node* as its root. In the
*Scene* dock, click the *Add Node* button represented by a "+" icon in the
top-left and double-click on *Node*. Name the node "Main". Alternatively, to add
a node to the scene, you can press :kbd:`Ctrl + a` (or :kbd:`Cmd + a` on macOS).

|image5|

Save the scene as ``Main.tscn`` by pressing :kbd:`Ctrl + s` (:kbd:`Cmd + s` on macOS).

We'll start by adding a floor that'll prevent the characters from falling. To
create static colliders like the floor, walls, or ceilings, you can use
*StaticBody* nodes. They require *CollisionShape* child nodes to
define the collision area. With the *Main* node selected, add a *StaticBody*
node, then a *CollisionShape*. Rename the *StaticBody* as *Ground*.

|image6|

A warning sign next to the *CollisionShape* appears because we haven't defined
its shape. If you click the icon, a popup appears to give you more information.

|image7|

To create a shape, with the *CollisionShape* selected, head to the *Inspector*
and click the *[empty]* field next to the *Shape* property. Create a new *Box
Shape*.

|image8|

The box shape is perfect for flat ground and walls. Its thickness makes it
reliable to block even fast-moving objects.

A box's wireframe appears in the viewport with three orange dots. You can click
and drag these to edit the shape's extents interactively. We can also precisely
set the size in the inspector. Click on the *BoxShape* to expand the resource.
Set its *Extents* to ``30`` on the X axis, ``1`` for the Y axis, and ``30`` for
the Z axis.

|image9|

.. note::

    In 3D, translation and size units are in meters. The box's total size is
    twice its extents: ``60`` by ``60`` meters on the ground plane and ``2``
    units tall. The ground plane is defined by the X and Z axes, while the Y
    axis represents the height.

Collision shapes are invisible. We need to add a visual floor that goes along
with it. Select the *Ground* node and add a *MeshInstance* as its child.

|image10|

In the *Inspector*, click on the field next to *Mesh* and create a *CubeMesh*
resource to create a visible cube.

|image11|

Once again, it's too small by default. Click the cube icon to expand the
resource and set its *Size* to ``60``, ``2``, and ``60``. As the cube
resource works with a size rather than extents, we need to use these values so
it matches our collision shape.

|image12|

You should see a wide grey slab that covers the grid and blue and red axes in
the viewport.

We're going to move the ground down so we can see the floor grid. Select the
*Ground* node, hold the :kbd:`Ctrl` key down to turn on grid snapping (:kbd:`Cmd` on macOS),
and click and drag down on the Y axis. It's the green arrow in the move gizmo.

|image13|

.. note::

    If you can't see the 3D object manipulator like on the image above, ensure
    the *Select Mode* is active in the toolbar above the view.

|image14|

Move the ground down ``1`` meter. A label in the bottom-left corner of the
viewport tells you how much you're translating the node.

|image15|

.. note::

    Moving the *Ground* node down moves both children along with it.
    Ensure you move the *Ground* node, **not** the *MeshInstance* or the
    *CollisionShape*.

Let's add a directional light so our scene isn't all grey. Select the *Main*
node and add a *DirectionalLight* as a child of it. We need to move it and
rotate it. Move it up by clicking and dragging on the manipulator's green arrow
and click and drag on the red arc to rotate it around the X axis, until the
ground is lit.

In the *Inspector*, turn on *Shadow -> Enabled* by clicking the checkbox.

|image16|

At this point, your project should look like this.

|image17|

That's our starting point. In the next part, we will work on the player scene
and base movement.

.. |image1| image:: img/01.game_setup/01.import_button.png
.. |image2| image:: img/01.game_setup/02.browse_to_project_folder.png
.. |image3| image:: img/01.game_setup/03.import_and_edit.png
.. |image4| image:: img/01.game_setup/04.start_assets.png
.. |image5| image:: img/01.game_setup/05.main_node.png
.. |image6| image:: img/01.game_setup/06.staticbody_node.png
.. |image7| image:: img/01.game_setup/07.collision_shape_warning.png
.. |image8| image:: img/01.game_setup/08.create_box_shape.png
.. |image9| image:: img/01.game_setup/09.box_extents.png
.. |image10| image:: img/01.game_setup/10.mesh_instance.png
.. |image11| image:: img/01.game_setup/11.cube_mesh.png
.. |image12| image:: img/01.game_setup/12.cube_resized.png
.. |image13| image:: img/01.game_setup/13.move_gizmo_y_axis.png
.. |image14| image:: img/01.game_setup/14.select_mode_icon.png
.. |image15| image:: img/01.game_setup/15.translation_amount.png
.. |image16| image:: img/01.game_setup/16.turn_on_shadows.png
.. |image17| image:: img/01.game_setup/17.project_with_light.png


===================================================
/. ./getting_started/first_3d_game/02.player_input.rst
===================================================

.. _doc_first_3d_game_player_scene_and_input:

Player scene and input actions
==============================

In the next two lessons, we will design the player scene, register custom input
actions, and code player movement. By the end, you'll have a playable character
that moves in eight directions.

.. TODO: add player animated gif?
.. player_movement.gif

Create a new scene by going to the Scene menu in the top-left and clicking *New
Scene*. Create a *KinematicBody* node as the root and name it *Player*.

|image0|

Kinematic bodies are complementary to the area and rigid bodies used in the 2D
game tutorial. Like rigid bodies, they can move and collide with the
environment, but instead of being controlled by the physics engine, you dictate
their movement. You will see how we use the node's unique features when we code
the jump and squash mechanics.

.. seealso::

    To learn more about the different physics node types, see the
    :ref:`doc_physics_introduction`.

For now, we're going to create a basic rig for our character's 3D model. This
will allow us to rotate the model later via code while it plays an animation.

Add a *Spatial* node as a child of *Player* and name it *Pivot*. Then, in the
FileSystem dock, expand the ``art/`` folder by double-clicking it and drag and
drop ``player.glb`` onto the *Pivot* node.

|image1|

This should instantiate the model as a child of *Pivot*. You can rename it to
*Character*.

|image2|

.. note::

    The ``.glb`` files contain 3D scene data based on the open-source GLTF 2.0
    specification. They're a modern and powerful alternative to a proprietary format
    like FBX, which Godot also supports. To produce these files, we designed the
    model in `Blender 3D <https://www.blender.org/>`__ and exported it to GLTF.

As with all kinds of physics nodes, we need a collision shape for our character
to collide with the environment. Select the *Player* node again and add a
*CollisionShape*. In the *Inspector*, assign a *SphereShape* to the *Shape*
property. The sphere's wireframe appears below the character.

|image3|

It will be the shape the physics engine uses to collide with the environment, so
we want it to better fit the 3D model. Shrink it a bit by dragging the orange
dot in the viewport. My sphere has a radius of about ``0.8`` meters.

Then, move the shape up so its bottom roughly aligns with the grid's plane.

|image4|

You can toggle the model's visibility by clicking the eye icon next to the
*Character* or the *Pivot* nodes.

|image5|

Save the scene as ``Player.tscn``.

With the nodes ready, we can almost get coding. But first, we need to define
some input actions.

Creating input actions
----------------------

To move the character, we will listen to the player's input, like pressing the
arrow keys. In Godot, while we could write all the key bindings in code, there's
a powerful system that allows you to assign a label to a set of keys and
buttons. This simplifies our scripts and makes them more readable.

This system is the Input Map. To access its editor, head to the *Project* menu
and select *Project Settings…*.

|image6|

At the top, there are multiple tabs. Click on *Input Map*. This window allows
you to add new actions at the top; they are your labels. In the bottom part, you
can bind keys to these actions.

|image7|

Godot projects come with some predefined actions designed for user interface
design, which we could use here. But we're defining our own to support gamepads.

We're going to name our actions ``move_left``, ``move_right``, ``move_forward``,
``move_back``, and ``jump``.

To add an action, write its name in the bar at the top and press Enter.

|image8|

Create the five actions. Your window should have them all listed at the bottom.

|image9|

To bind a key or button to an action, click the "+" button to its right. Do this
for ``move_left`` and in the drop-down menu, click *Key*.

|image10|

This option allows you to add a keyboard input. A popup appears and waits for
you to press a key. Press the left arrow key and click *OK*.

|image11|

Do the same for the A key.

|image12|

Let's now add support for a gamepad's left joystick. Click the "+" button again
but this time, select *Joy Axis*.

|image13|

The popup gives you two drop-down menus. On the left, you can select a gamepad
by index. *Device 0* corresponds to the first plugged gamepad, *Device 1*
corresponds to the second, and so on. You can select the joystick and direction
you want to bind to the input action on the right. Leave the default values and
press the *Add* button.

|image14|

Do the same for the other input actions. For example, bind the right arrow, D,
and the left joystick's right axis to ``move_right``. After binding all keys,
your interface should look like this.

|image15|

We have the ``jump`` action left to set up. Bind the Space key and the gamepad's
A button. To bind a gamepad's button, select the *Joy Button* option in the menu.

|image16|

Leave the default values and click the *Add* button.

|image17|

Your jump input action should look like this.

|image18|

That's all the actions we need for this game. You can use this menu to label any
groups of keys and buttons in your projects.

In the next part, we'll code and test the player's movement.

.. |image0| image:: img/02.player_input/01.new_scene.png
.. |image1| image:: img/02.player_input/02.instantiating_the_model.png
.. |image2| image:: img/02.player_input/03.scene_structure.png
.. |image3| image:: img/02.player_input/04.sphere_shape.png
.. |image4| image:: img/02.player_input/05.moving_the_sphere_up.png
.. |image5| image:: img/02.player_input/06.toggling_visibility.png
.. |image6| image:: img/02.player_input/07.project_settings.png
.. |image7| image:: img/02.player_input/07.input_map_tab.png
.. |image8| image:: img/02.player_input/07.adding_action.png
.. |image9| image:: img/02.player_input/08.actions_list_empty.png
.. |image10| image:: img/02.player_input/08.create_key_action.png
.. |image11| image:: img/02.player_input/09.keyboard_key_popup.png
.. |image12| image:: img/02.player_input/09.keyboard_keys.png
.. |image13| image:: img/02.player_input/10.joy_axis_option.png
.. |image14| image:: img/02.player_input/11.joy_axis_popup.png
.. |image15| image:: img/02.player_input/12.move_inputs_mapped.png
.. |image16| image:: img/02.player_input/13.joy_button_option.png
.. |image17| image:: img/02.player_input/14.add_jump_button.png
.. |image18| image:: img/02.player_input/14.jump_input_action.png


===================================================
/. ./getting_started/first_3d_game/03.player_movement_code.rst
===================================================

.. _doc_first_3d_game_player_movement:

Moving the player with code
===========================

It's time to code! We're going to use the input actions we created in the last
part to move the character.

Right-click the *Player* node and select *Attach Script* to add a new script to
it. In the popup, set the *Template* to *Empty* before pressing the *Create*
button.

|image0|

Let's start with the class's properties. We're going to define a movement speed,
a fall acceleration representing gravity, and a velocity we'll use to move the
character.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # How fast the player moves in meters per second.
   export var speed = 14
   # The downward acceleration when in the air, in meters per second squared.
   export var fall_acceleration = 75

   var velocity = Vector3.ZERO

 .. code-tab:: csharp

    public class Player : KinematicBody
    {
        // Don't forget to rebuild the project so the editor knows about the new export variable.

        // How fast the player moves in meters per second.
        [Export]
        public int Speed = 14;
        // The downward acceleration when in the air, in meters per second squared.
        [Export]
        public int FallAcceleration = 75;

        private Vector3 _velocity = Vector3.Zero;
    }


These are common properties for a moving body. The ``velocity`` is a 3D vector
combining a speed with a direction. Here, we define it as a property because
we want to update and reuse its value across frames.

.. note::

    The values are quite different from 2D code because distances are in meters.
    While in 2D, a thousand units (pixels) may only correspond to half of your
    screen's width, in 3D, it's a kilometer.

Let's code the movement now. We start by calculating the input direction vector
using the global ``Input`` object, in ``_physics_process()``.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _physics_process(delta):
       # We create a local variable to store the input direction.
       var direction = Vector3.ZERO

       # We check for each move input and update the direction accordingly.
       if Input.is_action_pressed("move_right"):
           direction.x += 1
       if Input.is_action_pressed("move_left"):
           direction.x -= 1
       if Input.is_action_pressed("move_back"):
           # Notice how we are working with the vector's x and z axes.
           # In 3D, the XZ plane is the ground plane.
           direction.z += 1
       if Input.is_action_pressed("move_forward"):
           direction.z -= 1

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // We create a local variable to store the input direction.
        var direction = Vector3.Zero;

        // We check for each move input and update the direction accordingly
        if (Input.IsActionPressed("move_right"))
        {
            direction.x += 1f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.x -= 1f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            // Notice how we are working with the vector's x and z axes.
            // In 3D, the XZ plane is the ground plane.
            direction.z += 1f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.z -= 1f;
        }
    }

Here, we're going to make all calculations using the ``_physics_process()``
virtual function. Like ``_process()``, it allows you to update the node every
frame, but it's designed specifically for physics-related code like moving a
kinematic or rigid body.

.. seealso::

    To learn more about the difference between ``_process()`` and
    ``_physics_process()``, see :ref:`doc_idle_and_physics_processing`.

We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, we
check if the player is pressing one or more of the ``move_*`` inputs and update
the vector's ``x`` and ``z`` components accordingly. These correspond to the
ground plane's axes.

These four conditions give us eight possibilities and eight possible directions.

In case the player presses, say, both W and D simultaneously, the vector will
have a length of about ``1.4``. But if they press a single key, it will have a
length of ``1``. We want the vector's length to be consistent. To do so, we can
call its ``normalize()`` method.

.. tabs::
 .. code-tab:: gdscript GDScript

   #func _physics_process(delta):
       #...

       if direction != Vector3.ZERO:
           direction = direction.normalized()
           $Pivot.look_at(translation + direction, Vector3.UP)

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // ...

        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            GetNode<Spatial>("Pivot").LookAt(Translation + direction, Vector3.Up);
        }
    }

Here, we only normalize the vector if the direction has a length greater than
zero, which means the player is pressing a direction key.

In this case, we also get the *Pivot* node and call its ``look_at()`` method.
This method takes a position in space to look at in global coordinates and the
up direction. In this case, we can use the ``Vector3.UP`` constant.

.. note::

    A node's local coordinates, like ``translation``, are relative to their
    parent. Global coordinates are relative to the world's main axes you can see
    in the viewport instead.

In 3D, the property that contains a node's position is ``translation``. By
adding the ``direction`` to it, we get a position to look at that's one meter
away from the *Player*.

Then, we update the velocity. We have to calculate the ground velocity and the
fall speed separately. Be sure to go back one tab so the lines are inside the
``_physics_process()`` function but outside the condition we just wrote.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _physics_process(delta):
        #...
        if direction != Vector3.ZERO:
            #...

        # Ground velocity
        velocity.x = direction.x * speed
        velocity.z = direction.z * speed
        # Vertical velocity
        velocity.y -= fall_acceleration * delta
        # Moving the character
        velocity = move_and_slide(velocity, Vector3.UP)

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // ...

        // Ground velocity
        _velocity.x = direction.x * Speed;
        _velocity.z = direction.z * Speed;
        // Vertical velocity
        _velocity.y -= FallAcceleration * delta;
        // Moving the character
        _velocity = MoveAndSlide(_velocity, Vector3.Up);
    }

For the vertical velocity, we subtract the fall acceleration multiplied by the
delta time every frame. Notice the use of the ``-=`` operator, which is a
shorthand for ``variable = variable - ...``.

This line of code will cause our character to fall in every frame. This may seem
strange if it's already on the floor. But we have to do this for the character
to collide with the ground every frame.

The physics engine can only detect interactions with walls, the floor, or other
bodies during a given frame if movement and collisions happen. We will use this
property later to code the jump.

On the last line, we call ``KinematicBody.move_and_slide()``. It's a powerful
method of the ``KinematicBody`` class that allows you to move a character
smoothly. If it hits a wall midway through a motion, the engine will try to
smooth it out for you.

The function takes two parameters: our velocity and the up direction. It moves
the character and returns a leftover velocity after applying collisions. When
hitting the floor or a wall, the function will reduce or reset the speed in that
direction from you. In our case, storing the function's returned value prevents
the character from accumulating vertical momentum, which could otherwise get so
big the character would move through the ground slab after a while.

And that's all the code you need to move the character on the floor.

Here is the complete ``Player.gd`` code for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # How fast the player moves in meters per second.
   export var speed = 14
   # The downward acceleration when in the air, in meters per second squared.
   export var fall_acceleration = 75

   var velocity = Vector3.ZERO


   func _physics_process(delta):
       var direction = Vector3.ZERO

       if Input.is_action_pressed("move_right"):
           direction.x += 1
       if Input.is_action_pressed("move_left"):
           direction.x -= 1
       if Input.is_action_pressed("move_back"):
           direction.z += 1
       if Input.is_action_pressed("move_forward"):
           direction.z -= 1

       if direction != Vector3.ZERO:
           direction = direction.normalized()
           $Pivot.look_at(translation + direction, Vector3.UP)

       velocity.x = direction.x * speed
       velocity.z = direction.z * speed
       velocity.y -= fall_acceleration * delta
       velocity = move_and_slide(velocity, Vector3.UP)

 .. code-tab:: csharp

    public class Player : KinematicBody
    {
        // How fast the player moves in meters per second.
        [Export]
        public int Speed = 14;
        // The downward acceleration when in the air, in meters per second squared.
        [Export]
        public int FallAcceleration = 75;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            // We create a local variable to store the input direction.
            var direction = Vector3.Zero;

            // We check for each move input and update the direction accordingly
            if (Input.IsActionPressed("move_right"))
            {
                direction.x += 1f;
            }
            if (Input.IsActionPressed("move_left"))
            {
                direction.x -= 1f;
            }
            if (Input.IsActionPressed("move_back"))
            {
                // Notice how we are working with the vector's x and z axes.
                // In 3D, the XZ plane is the ground plane.
                direction.z += 1f;
            }
            if (Input.IsActionPressed("move_forward"))
            {
                direction.z -= 1f;
            }

            if (direction != Vector3.Zero)
            {
                direction = direction.Normalized();
                GetNode<Spatial>("Pivot").LookAt(Translation + direction, Vector3.Up);
            }

            // Ground velocity
            _velocity.x = direction.x * Speed;
            _velocity.z = direction.z * Speed;
            // Vertical velocity
            _velocity.y -= FallAcceleration * delta;
            // Moving the character
            _velocity = MoveAndSlide(_velocity, Vector3.Up);
        }
    }

Testing our player's movement
-----------------------------

We're going to put our player in the *Main* scene to test it. To do so, we need
to instantiate the player and then add a camera. Unlike in 2D, in 3D, you won't
see anything if your viewport doesn't have a camera pointing at something.

Save your *Player* scene and open the *Main* scene. You can click on the *Main*
tab at the top of the editor to do so.

|image1|

If you closed the scene before, head to the *FileSystem* dock and double-click
``Main.tscn`` to re-open it.

To instantiate the *Player*, right-click on the *Main* node and select *Instance
Child Scene*.

|image2|

In the popup, double-click *Player.tscn*. The character should appear in the
center of the viewport.

Adding a camera
~~~~~~~~~~~~~~~

Let's add the camera next. Like we did with our *Player*\ 's *Pivot*, we're
going to create a basic rig. Right-click on the *Main* node again and select
*Add Child Node* this time. Create a new *Position3D*, name it *CameraPivot*,
and add a *Camera* node as a child of it. Your scene tree should look like this.

|image3|

Notice the *Preview* checkbox that appears in the top-left when you have the
*Camera* selected. You can click it to preview the in-game camera projection.

|image4|

We're going to use the *Pivot* to rotate the camera as if it was on a crane.
Let's first split the 3D view to be able to freely navigate the scene and see
what the camera sees.

In the toolbar right above the viewport, click on *View*, then *2 Viewports*.
You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS).

|image5|

On the bottom view, select the *Camera* and turn on camera preview by clicking
the checkbox.

|image6|

In the top view, move the camera about ``19`` units on the Z axis (the blue
one).

|image7|

Here's where the magic happens. Select the *CameraPivot* and rotate it ``-45``
degrees around the X axis (using the red circle). You'll see the camera move as
if it was attached to a crane.

|image8|

You can run the scene by pressing :kbd:`F6` and press the arrow keys to move the
character.

|image9|

We can see some empty space around the character due to the perspective
projection. In this game, we're going to use an orthographic projection instead
to better frame the gameplay area and make it easier for the player to read
distances.

Select the *Camera* again and in the *Inspector*, set the *Projection* to
*Orthogonal* and the *Size* to ``19``. The character should now look flatter and
the ground should fill the background.

|image10|

With that, we have both player movement and the view in place. Next, we will
work on the monsters.

.. |image0| image:: img/03.player_movement_code/01.attach_script_to_player.png
.. |image1| image:: img/03.player_movement_code/02.clicking_main_tab.png
.. |image2| image:: img/03.player_movement_code/03.instance_child_scene.png
.. |image3| image:: img/03.player_movement_code/04.scene_tree_with_camera.png
.. |image4| image:: img/03.player_movement_code/05.camera_preview_checkbox.png
.. |image5| image:: img/03.player_movement_code/06.two_viewports.png
.. |image6| image:: img/03.player_movement_code/07.camera_preview_checkbox.png
.. |image7| image:: img/03.player_movement_code/08.camera_moved.png
.. |image8| image:: img/03.player_movement_code/09.camera_rotated.png
.. |image9| image:: img/03.player_movement_code/10.camera_perspective.png
.. |image10| image:: img/03.player_movement_code/11.camera_orthographic.png


===================================================
/. ./getting_started/first_3d_game/04.mob_scene.rst
===================================================

.. _doc_first_3d_game_designing_the_mob_scene:

Designing the mob scene
=======================

In this part, you're going to code the monsters, which we'll call mobs. In the
next lesson, we'll spawn them randomly around the playable area.

Let's design the monsters themselves in a new scene. The node structure is going
to be similar to the *Player* scene.

Create a scene with, once again, a *KinematicBody* node as its root. Name it
*Mob*. Add a *Spatial* node as a child of it, name it *Pivot*. And drag and drop
the file ``mob.glb`` from the *FileSystem* dock onto the *Pivot* to add the
monster's 3D model to the scene. You can rename the newly created *mob* node
into *Character*.

|image0|

We need a collision shape for our body to work. Right-click on the *Mob* node,
the scene's root, and click *Add Child Node*.

|image1|

Add a *CollisionShape*.

|image2|

In the *Inspector*, assign a *BoxShape* to the *Shape* property.

|image3|

We should change its size to fit the 3D model better. You can do so
interactively by clicking and dragging on the orange dots.

The box should touch the floor and be a little thinner than the model. Physics
engines work in such a way that if the player's sphere touches even the box's
corner, a collision will occur. If the box is a little too big compared to the
3D model, you may die at a distance from the monster, and the game will feel
unfair to the players.

|image4|

Notice that my box is taller than the monster. It is okay in this game because
we're looking at the scene from above and using a fixed perspective. Collision
shapes don't have to match the model exactly. It's the way the game feels when
you test it that should dictate their form and size.

Removing monsters off-screen
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We're going to spawn monsters at regular time intervals in the game level. If
we're not careful, their count could increase to infinity, and we don't want
that. Each mob instance has both a memory and a processing cost, and we don't
want to pay for it when the mob's outside the screen.

Once a monster leaves the screen, we don't need it anymore, so we can delete it.
Godot has a node that detects when objects leave the screen,
*VisibilityNotifier*, and we're going to use it to destroy our mobs.

.. note::

    When you keep instancing an object in games, there's a technique you can
    use to avoid the cost of creating and destroying instances all the time
    called pooling. It consists of pre-creating an array of objects and reusing
    them over and over.

    When working with GDScript, you don't need to worry about this. The main
    reason to use pools is to avoid freezes with garbage-collected languages
    like C# or Lua. GDScript uses a different technique to manage memory,
    reference counting, which doesn't have that caveat. You can learn more
    about that here :ref:`doc_gdscript_basics_memory_management`.

Select the *Mob* node and add a *VisibilityNotifier* as a child of it. Another
box, pink this time, appears. When this box completely leaves the screen, the
node will emit a signal.

|image5|

Resize it using the orange dots until it covers the entire 3D model.

|image6|

Coding the mob's movement
-------------------------

Let's implement the monster's motion. We're going to do this in two steps.
First, we'll write a script on the *Mob* that defines a function to initialize
the monster. We'll then code the randomized spawn mechanism in the *Main* scene
and call the function from there.

Attach a script to the *Mob*.

|image7|

Here's the movement code to start with. We define two properties, ``min_speed``
and ``max_speed``, to define a random speed range. We then define and initialize
the ``velocity``.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # Minimum speed of the mob in meters per second.
   export var min_speed = 10
   # Maximum speed of the mob in meters per second.
   export var max_speed = 18

   var velocity = Vector3.ZERO


   func _physics_process(_delta):
       move_and_slide(velocity)

 .. code-tab:: csharp

    public class Mob : KinematicBody
    {
        // Don't forget to rebuild the project so the editor knows about the new export variable.

        // Minimum speed of the mob in meters per second
        [Export]
        public int MinSpeed = 10;
        // Maximum speed of the mob in meters per second
        [Export]
        public int MaxSpeed = 18;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            MoveAndSlide(_velocity);
        }
    }

Similarly to the player, we move the mob every frame by calling
``KinematicBody``\ 's ``move_and_slide()`` method. This time, we don't update
the ``velocity`` every frame: we want the monster to move at a constant speed
and leave the screen, even if it were to hit an obstacle.

You may see a warning in GDScript that the return value from
``move_and_slide()`` is unused. This is expected. You can simply ignore the
warning or, if you want to hide it entirely, add the comment
``# warning-ignore:return_value_discarded`` just above the
``move_and_slide(velocity)`` line. To read more about the GDScript warning
system, see :ref:`doc_gdscript_warning_system`.

We need to define another function to calculate the start velocity. This
function will turn the monster towards the player and randomize both its angle
of motion and its velocity.

The function will take a ``start_position``, the mob's spawn position, and the
``player_position`` as its arguments.

We position the mob at ``start_position`` and turn it towards the player using
the ``look_at_from_position()`` method, and randomize the angle by rotating a
random amount around the Y axis. Below, ``rand_range()`` outputs a random value
between ``-PI / 4`` radians and ``PI / 4`` radians.

.. tabs::
 .. code-tab:: gdscript GDScript

   # We will call this function from the Main scene.
   func initialize(start_position, player_position):
       # We position the mob and turn it so that it looks at the player.
       look_at_from_position(start_position, player_position, Vector3.UP)
       # And rotate it randomly so it doesn't move exactly toward the player.
       rotate_y(rand_range(-PI / 4, PI / 4))

 .. code-tab:: csharp

    // We will call this function from the Main scene
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob and turn it so that it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // And rotate it randomly so it doesn't move exactly toward the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));
    }

We then calculate a random speed using ``rand_range()`` once again and we use it
to calculate the velocity.

We start by creating a 3D vector pointing forward, multiply it by our
``random_speed``, and finally rotate it using the ``Vector3`` class's
``rotated()`` method.

.. tabs::
 .. code-tab:: gdscript GDScript

   func initialize(start_position, player_position):
       # ...

       # We calculate a random speed.
       var random_speed = rand_range(min_speed, max_speed)
       # We calculate a forward velocity that represents the speed.
       velocity = Vector3.FORWARD * random_speed
       # We then rotate the vector based on the mob's Y rotation to move in the direction it's looking.
       velocity = velocity.rotated(Vector3.UP, rotation.y)

 .. code-tab:: csharp

    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // ...

        // We calculate a random speed.
        float randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        _velocity = Vector3.Forward * randomSpeed;
        // We then rotate the vector based on the mob's Y rotation to move in the direction it's looking
        _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);
    }

Leaving the screen
------------------

We still have to destroy the mobs when they leave the screen. To do so, we'll
connect our *VisibilityNotifier* node's ``screen_exited`` signal to the *Mob*.

Head back to the 3D viewport by clicking on the *3D* label at the top of the
editor. You can also press :kbd:`Ctrl + F2` (:kbd:`Alt + 2` on macOS).

|image8|

Select the *VisibilityNotifier* node and on the right side of the interface,
navigate to the *Node* dock. Double-click the *screen_exited()* signal.

|image9|

Connect the signal to the *Mob*.

|image10|

This will take you back to the script editor and add a new function for you,
``_on_VisibilityNotifier_screen_exited()``. From it, call the ``queue_free()``
method. This will destroy the mob instance when the *VisibilityNotifier* \'s box
leaves the screen.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _on_VisibilityNotifier_screen_exited():
       queue_free()

 .. code-tab:: csharp

    // We also specified this function name in PascalCase in the editor's connection window
    public void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }


Our monster is ready to enter the game! In the next part, you will spawn
monsters in the game level.

Here is the complete ``Mob.gd`` script for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # Minimum speed of the mob in meters per second.
   export var min_speed = 10
   # Maximum speed of the mob in meters per second.
   export var max_speed = 18

   var velocity = Vector3.ZERO


   func _physics_process(_delta):
       move_and_slide(velocity)

   func initialize(start_position, player_position):
       look_at_from_position(start_position, player_position, Vector3.UP)
       rotate_y(rand_range(-PI / 4, PI / 4))

       var random_speed = rand_range(min_speed, max_speed)
       velocity = Vector3.FORWARD * random_speed
       velocity = velocity.rotated(Vector3.UP, rotation.y)


   func _on_VisibilityNotifier_screen_exited():
       queue_free()

 .. code-tab:: csharp

    public class Mob : KinematicBody
    {
        // Minimum speed of the mob in meters per second
        [Export]
        public int MinSpeed = 10;
        // Maximum speed of the mob in meters per second
        [Export]
        public int MaxSpeed = 18;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            MoveAndSlide(_velocity);
        }

        // We will call this function from the Main scene
        public void Initialize(Vector3 startPosition, Vector3 playerPosition)
        {
            LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
            RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

            var randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
            _velocity = Vector3.Forward * randomSpeed;
            _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);
        }

        // We also specified this function name in PascalCase in the editor's connection window
        public void OnVisibilityNotifierScreenExited()
        {
            QueueFree();
        }
    }

.. |image0| image:: img/04.mob_scene/01.initial_three_nodes.png
.. |image1| image:: img/04.mob_scene/02.add_child_node.png
.. |image2| image:: img/04.mob_scene/03.scene_with_collision_shape.png
.. |image3| image:: img/04.mob_scene/04.create_box_shape.png
.. |image4| image:: img/04.mob_scene/05.box_final_size.png
.. |image5| image:: img/04.mob_scene/06.visibility_notifier.png
.. |image6| image:: img/04.mob_scene/07.visibility_notifier_bbox_resized.png
.. |image7| image:: img/04.mob_scene/08.mob_attach_script.png
.. |image8| image:: img/04.mob_scene/09.switch_to_3d_workspace.png
.. |image9| image:: img/04.mob_scene/10.node_dock.png
.. |image10| image:: img/04.mob_scene/11.connect_signal.png


===================================================
/. ./getting_started/first_3d_game/05.spawning_mobs.rst
===================================================

.. _doc_first_3d_game_spawning_monsters:

Spawning monsters
=================

In this part, we're going to spawn monsters along a path randomly. By the end,
you will have monsters roaming the game board.

|image0|

Double-click on ``Main.tscn`` in the *FileSystem* dock to open the *Main* scene.

Before drawing the path, we're going to change the game resolution. Our game has
a default window size of ``1024x600``. We're going to set it to ``720x540``, a
nice little box.

Go to *Project -> Project Settings*.

|image1|

In the left menu, navigate down to *Display -> Window*. On the right, set the
*Width* to ``720`` and the *Height* to ``540``.

|image2|

Creating the spawn path
-----------------------

Like you did in the 2D game tutorial, you're going to design a path and use a
*PathFollow* node to sample random locations on it.

In 3D though, it's a bit more complicated to draw the path. We want it to be
around the game view so monsters appear right outside the screen. But if we draw
a path, we won't see it from the camera preview.

To find the view's limits, we can use some placeholder meshes. Your viewport
should still be split into two parts, with the camera preview at the bottom. If
that isn't the case, press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS) to split the view into two.
Select the *Camera* node and click the *Preview* checkbox in the bottom
viewport.

|image3|

Adding placeholder cylinders
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's add the placeholder meshes. Add a new *Spatial* node as a child of the
*Main* node and name it *Cylinders*. We'll use it to group the cylinders. As a
child of it, add a *MeshInstance* node.

|image4|

In the *Inspector*, assign a *CylinderMesh* to the *Mesh* property.

|image5|

Set the top viewport to the top orthogonal view using the menu in the viewport's
top-left corner. Alternatively, you can press the keypad's 7 key.

|image6|

The grid is a bit distracting for me. You can toggle it by going to the *View*
menu in the toolbar and clicking *View Grid*.

|image7|

You now want to move the cylinder along the ground plane, looking at the camera
preview in the bottom viewport. I recommend using grid snap to do so. You can
toggle it by clicking the magnet icon in the toolbar or pressing Y.

|image8|

Place the cylinder so it's right outside the camera's view in the top-left
corner.

|image9|

We're going to create copies of the mesh and place them around the game area.
Press :kbd:`Ctrl + D` (:kbd:`Cmd + D` on macOS) to duplicate the node. You can also right-click
the node in the *Scene* dock and select *Duplicate*. Move the copy down along
the blue Z axis until it's right outside the camera's preview.

Select both cylinders by pressing the :kbd:`Shift` key and clicking on the unselected
one and duplicate them.

|image10|

Move them to the right by dragging the red X axis.

|image11|

They're a bit hard to see in white, aren't they? Let's make them stand out by
giving them a new material.

In 3D, materials define a surface's visual properties like its color, how it
reflects light, and more. We can use them to change the color of a mesh.

We can update all four cylinders at once. Select all the mesh instances in the
*Scene* dock. To do so, you can click on the first one and Shift click on the
last one.

|image12|

In the *Inspector*, expand the *Material* section and assign a *SpatialMaterial*
to slot *0*.

|image13|

Click the sphere icon to open the material resource. You get a preview of the
material and a long list of sections filled with properties. You can use these
to create all sorts of surfaces, from metal to rock or water.

Expand the *Albedo* section and set the color to something that contrasts with
the background, like a bright orange.

|image14|

We can now use the cylinders as guides. Fold them in the *Scene* dock by
clicking the grey arrow next to them. Moving forward, you can also toggle their
visibility by clicking the eye icon next to *Cylinders*.

|image15|

Add a *Path* node as a child of *Main*. In the toolbar, four icons appear. Click
the *Add Point* tool, the icon with the green "+" sign.

|image16|

.. note:: You can hover any icon to see a tooltip describing the tool.

Click in the center of each cylinder to create a point. Then, click the *Close
Curve* icon in the toolbar to close the path. If any point is a bit off, you can
click and drag on it to reposition it.

|image17|

Your path should look like this.

|image18|

To sample random positions on it, we need a *PathFollow* node. Add a
*PathFollow* as a child of the *Path*. Rename the two nodes to *SpawnPath* and
*SpawnLocation*, respectively. It's more descriptive of what we'll use them for.

|image19|

With that, we're ready to code the spawn mechanism.

Spawning monsters randomly
--------------------------

Right-click on the *Main* node and attach a new script to it.

We first export a variable to the *Inspector* so that we can assign ``Mob.tscn``
or any other monster to it.

Then, as we're going to spawn the monsters procedurally, we want to randomize
numbers every time we play the game. If we don't do that, the monsters will
always spawn following the same sequence.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends Node

   export (PackedScene) var mob_scene


   func _ready():
       randomize()

 .. code-tab:: csharp

    public class Main : Node
    {
        // Don't forget to rebuild the project so the editor knows about the new export variable.

    #pragma warning disable 649
        // We assign this in the editor, so we don't need the warning about not being assigned.
        [Export]
        public PackedScene MobScene;
    #pragma warning restore 649

        public override void _Ready()
        {
            GD.Randomize();
        }
    }

We want to spawn mobs at regular time intervals. To do this, we need to go back
to the scene and add a timer. Before that, though, we need to assign the
``Mob.tscn`` file to the ``mob_scene`` property.

Head back to the 3D screen and select the *Main* node. Drag ``Mob.tscn`` from
the *FileSystem* dock to the *Mob Scene* slot in the *Inspector*.

|image20|

Add a new *Timer* node as a child of *Main*. Name it *MobTimer*.

|image21|

In the *Inspector*, set its *Wait Time* to ``0.5`` seconds and turn on
*Autostart* so it automatically starts when we run the game.

|image22|

Timers emit a ``timeout`` signal every time they reach the end of their *Wait
Time*. By default, they restart automatically, emitting the signal in a cycle.
We can connect to this signal from the *Main* node to spawn monsters every
``0.5`` seconds.

With the *MobTimer* still selected, head to the *Node* dock on the right and
double-click the ``timeout`` signal.

|image23|

Connect it to the *Main* node.

|image24|

This will take you back to the script, with a new empty
``_on_MobTimer_timeout()`` function.

Let's code the mob spawning logic. We're going to:

1. Instantiate the mob scene.
2. Sample a random position on the spawn path.
3. Get the player's position.
4. Call the mob's ``initialize()`` method, passing it the random position and
   the player's position.
5. Add the mob as a child of the *Main* node.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _on_MobTimer_timeout():
       # Create a new instance of the Mob scene.
       var mob = mob_scene.instance()

       # Choose a random location on the SpawnPath.
       # We store the reference to the SpawnLocation node.
       var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
       # And give it a random offset.
       mob_spawn_location.unit_offset = randf()

       var player_position = $Player.transform.origin
       mob.initialize(mob_spawn_location.translation, player_position)

       add_child(mob)

 .. code-tab:: csharp

    // We also specified this function name in PascalCase in the editor's connection window
    public void OnMobTimerTimeout()
    {
        // Create a new instance of the Mob scene.
        Mob mob = (Mob)MobScene.Instance();

        // Choose a random location on the SpawnPath.
        // We store the reference to the SpawnLocation node.
        var mobSpawnLocation = GetNode<PathFollow>("SpawnPath/SpawnLocation");
        // And give it a random offset.
        mobSpawnLocation.UnitOffset = GD.Randf();

        Vector3 playerPosition = GetNode<Player>("Player").Transform.origin;
        mob.Initialize(mobSpawnLocation.Translation, playerPosition);

        AddChild(mob);

    }

Above, ``randf()`` produces a random value between ``0`` and ``1``, which is
what the *PathFollow* node's ``unit_offset`` expects.

Here is the complete ``Main.gd`` script so far, for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends Node

   export (PackedScene) var mob_scene


   func _ready():
       randomize()


   func _on_MobTimer_timeout():
       var mob = mob_scene.instance()

       var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
       mob_spawn_location.unit_offset = randf()
       var player_position = $Player.transform.origin
       mob.initialize(mob_spawn_location.translation, player_position)

       add_child(mob)

 .. code-tab:: csharp

    public class Main : Node
    {
    #pragma warning disable 649
        [Export]
        public PackedScene MobScene;
    #pragma warning restore 649

        public override void _Ready()
        {
            GD.Randomize();
        }

        public void OnMobTimerTimeout()
        {
            Mob mob = (Mob)MobScene.Instance();

            var mobSpawnLocation = GetNode<PathFollow>("SpawnPath/SpawnLocation");
            mobSpawnLocation.UnitOffset = GD.Randf();

            Vector3 playerPosition = GetNode<Player>("Player").Transform.origin;
            mob.Initialize(mobSpawnLocation.Translation, playerPosition);

            AddChild(mob);
        }
    }

You can test the scene by pressing :kbd:`F6`. You should see the monsters spawn and
move in a straight line.

|image25|

For now, they bump and slide against one another when their paths cross. We'll
address this in the next part.

.. |image0| image:: img/05.spawning_mobs/01.monsters_path_preview.png
.. |image1| image:: img/05.spawning_mobs/02.project_settings.png
.. |image2| image:: img/05.spawning_mobs/03.window_settings.png
.. |image3| image:: img/05.spawning_mobs/04.camera_preview.png
.. |image4| image:: img/05.spawning_mobs/05.cylinders_node.png
.. |image5| image:: img/05.spawning_mobs/06.cylinder_mesh.png
.. |image6| image:: img/05.spawning_mobs/07.top_view.png
.. |image7| image:: img/05.spawning_mobs/08.toggle_view_grid.png
.. |image8| image:: img/05.spawning_mobs/09.toggle_grid_snap.png
.. |image9| image:: img/05.spawning_mobs/10.place_first_cylinder.png
.. |image10| image:: img/05.spawning_mobs/11.both_cylinders_selected.png
.. |image11| image:: img/05.spawning_mobs/12.four_cylinders.png
.. |image12| image:: img/05.spawning_mobs/13.selecting_all_cylinders.png
.. |image13| image:: img/05.spawning_mobs/14.spatial_material.png
.. |image14| image:: img/05.spawning_mobs/15.bright-cylinders.png
.. |image15| image:: img/05.spawning_mobs/16.cylinders_fold.png
.. |image16| image:: img/05.spawning_mobs/17.points_options.png
.. |image17| image:: img/05.spawning_mobs/18.close_path.png
.. |image18| image:: img/05.spawning_mobs/19.path_result.png
.. |image19| image:: img/05.spawning_mobs/20.spawn_nodes.png
.. |image20| image:: img/05.spawning_mobs/20.mob_scene_property.png
.. |image21| image:: img/05.spawning_mobs/21.mob_timer.png
.. |image22| image:: img/05.spawning_mobs/22.mob_timer_properties.png
.. |image23| image:: img/05.spawning_mobs/23.timeout_signal.png
.. |image24| image:: img/05.spawning_mobs/24.connect_timer_to_main.png
.. |image25| image:: img/05.spawning_mobs/25.spawn_result.png


===================================================
/. ./getting_started/first_3d_game/06.jump_and_squash.rst
===================================================

.. _doc_first_3d_game_jumping_and_squashing_monsters:

Jumping and squashing monsters
==============================

In this part, we'll add the ability to jump, to squash the monsters. In the next
lesson, we'll make the player die when a monster hits them on the ground.

First, we have to change a few settings related to physics interactions. Enter
the world of :ref:`physics layers
<doc_physics_introduction_collision_layers_and_masks>`.

Controlling physics interactions
--------------------------------

Physics bodies have access to two complementary properties: layers and masks.
Layers define on which physics layer(s) an object is.

Masks control the layers that a body will listen to and detect. This affects
collision detection. When you want two bodies to interact, you need at least one
to have a mask corresponding to the other.

If that's confusing, don't worry, we'll see three examples in a second.

The important point is that you can use layers and masks to filter physics
interactions, control performance, and remove the need for extra conditions in
your code.

By default, all physics bodies and areas are set to both layer and mask ``0``.
This means they all collide with each other.

Physics layers are represented by numbers, but we can give them names to keep
track of what's what.

Setting layer names
~~~~~~~~~~~~~~~~~~~

Let's give our physics layers a name. Go to *Project -> Project Settings*.

|image0|

In the left menu, navigate down to *Layer Names -> 3D Physics*. You can see a
list of layers with a field next to each of them on the right. You can set their
names there. Name the first three layers *player*, *enemies*, and *world*,
respectively.

|image1|

Now, we can assign them to our physics nodes.

Assigning layers and masks
~~~~~~~~~~~~~~~~~~~~~~~~~~

In the *Main* scene, select the *Ground* node. In the *Inspector*, expand the
*Collision* section. There, you can see the node's layers and masks as a grid of
buttons.

|image2|

The ground is part of the world, so we want it to be part of the third layer.
Click the lit button to toggle off the first *Layer* and toggle on the third
one. Then, toggle off the *Mask* by clicking on it.

|image3|

As I mentioned above, the *Mask* property allows a node to listen to interaction
with other physics objects, but we don't need it to have collisions. The
*Ground* doesn't need to listen to anything; it's just there to prevent
creatures from falling.

Note that you can click the "..." button on the right side of the properties to
see a list of named checkboxes.

|image4|

Next up are the *Player* and the *Mob*. Open ``Player.tscn`` by double-clicking
the file in the *FileSystem* dock.

Select the *Player* node and set its *Collision -> Mask* to both "enemies" and
"world". You can leave the default *Layer* property as the first layer is the
"player" one.

|image5|

Then, open the *Mob* scene by double-clicking on ``Mob.tscn`` and select the
*Mob* node.

Set its *Collision -> Layer* to "enemies" and unset its *Collision -> Mask*,
leaving the mask empty.

|image6|

These settings mean the monsters will move through one another. If you want the
monsters to collide with and slide against each other, turn on the "enemies"
mask.

.. note::

    The mobs don't need to mask the "world" layer because they only move
    on the XZ plane. We don't apply any gravity to them by design.

Jumping
-------

The jumping mechanic itself requires only two lines of code. Open the *Player*
script. We need a value to control the jump's strength and update
``_physics_process()`` to code the jump.

After the line that defines ``fall_acceleration``, at the top of the script, add
the ``jump_impulse``.

.. tabs::
 .. code-tab:: gdscript GDScript

   #...
   # Vertical impulse applied to the character upon jumping in meters per second.
   export var jump_impulse = 20

 .. code-tab:: csharp

    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // ...
    // Vertical impulse applied to the character upon jumping in meters per second.
    [Export]
    public int JumpImpulse = 20;

Inside ``_physics_process()``, add the following code before the line where we
called ``move_and_slide()``.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _physics_process(delta):
       #...

       # Jumping.
       if is_on_floor() and Input.is_action_just_pressed("jump"):
           velocity.y += jump_impulse

       #...

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // ...

        // Jumping.
        if (IsOnFloor() && Input.IsActionJustPressed("jump"))
        {
            _velocity.y += JumpImpulse;
        }

        // ...
    }

That's all you need to jump!

The ``is_on_floor()`` method is a tool from the ``KinematicBody`` class. It
returns ``true`` if the body collided with the floor in this frame. That's why
we apply gravity to the *Player*: so we collide with the floor instead of
floating over it like the monsters.

If the character is on the floor and the player presses "jump", we instantly
give them a lot of vertical speed. In games, you really want controls to be
responsive and giving instant speed boosts like these, while unrealistic, feel
great.

Notice that the Y axis is positive upwards. That's unlike 2D, where the Y axis
is positive downward.

Squashing monsters
------------------

Let's add the squash mechanic next. We're going to make the character bounce
over monsters and kill them at the same time.

We need to detect collisions with a monster and to differentiate them from
collisions with the floor. To do so, we can use Godot's :ref:`group
<doc_groups>` tagging feature.

Open the scene ``Mob.tscn`` again and select the *Mob* node. Go to the *Node*
dock on the right to see a list of signals. The *Node* dock has two tabs:
*Signals*, which you've already used, and *Groups*, which allows you to assign
tags to nodes.

Click on it to reveal a field where you can write a tag name. Enter "mob" in the
field and click the *Add* button.

|image7|

An icon appears in the *Scene* dock to indicate the node is part of at least one
group.

|image8|

We can now use the group from the code to distinguish collisions with monsters
from collisions with the floor.

Coding the squash mechanic
~~~~~~~~~~~~~~~~~~~~~~~~~~

Head back to the *Player* script to code the squash and bounce.

At the top of the script, we need another property, ``bounce_impulse``. When
squashing an enemy, we don't necessarily want the character to go as high up as
when jumping.

.. tabs::
 .. code-tab:: gdscript GDScript

   # Vertical impulse applied to the character upon bouncing over a mob in
   # meters per second.
   export var bounce_impulse = 16

 .. code-tab:: csharp

    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
    [Export]
    public int BounceImpulse = 16;

Then, at the bottom of ``_physics_process()``, add the following loop. With
``move_and_slide()``, Godot makes the body move sometimes multiple times in a
row to smooth out the character's motion. So we have to loop over all collisions
that may have happened.

In every iteration of the loop, we check if we landed on a mob. If so, we kill
it and bounce.

With this code, if no collisions occurred on a given frame, the loop won't run.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _physics_process(delta):
       #...
       for index in range(get_slide_count()):
           # We check every collision that occurred this frame.
           var collision = get_slide_collision(index)
           # If we collide with a monster...
           if collision.collider.is_in_group("mob"):
               var mob = collision.collider
               # ...we check that we are hitting it from above.
               if Vector3.UP.dot(collision.normal) > 0.1:
                   # If so, we squash it and bounce.
                   mob.squash()
                   velocity.y = bounce_impulse

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // ...

        for (int index = 0; index < GetSlideCount(); index++)
        {
            // We check every collision that occurred this frame.
            KinematicCollision collision = GetSlideCollision(index);
            // If we collide with a monster...
            if (collision.Collider is Mob mob && mob.IsInGroup("mob"))
            {
                // ...we check that we are hitting it from above.
                if (Vector3.Up.Dot(collision.Normal) > 0.1f)
                {
                    // If so, we squash it and bounce.
                    mob.Squash();
                    _velocity.y = BounceImpulse;
                }
            }
        }
    }

 That's a lot of new functions. Here's some more information about them.

The functions ``get_slide_count()`` and ``get_slide_collision()`` both come from
the :ref:`KinematicBody<class_KinematicBody>` class and are related to
``move_and_slide()``.

``get_slide_collision()`` returns a
:ref:`KinematicCollision<class_KinematicCollision>` object that holds
information about where and how the collision occurred. For example, we use its
``collider`` property to check if we collided with a "mob" by calling
``is_in_group()`` on it: ``collision.collider.is_in_group("mob")``.

.. note::

    The method ``is_in_group()`` is available on every :ref:`Node<class_Node>`.

To check that we are landing on the monster, we use the vector dot product:
``Vector3.UP.dot(collision.normal) > 0.1``. The collision normal is a 3D vector
that is perpendicular to the plane where the collision occurred. The dot product
allows us to compare it to the up direction.

With dot products, when the result is greater than ``0``, the two vectors are at
an angle of fewer than 90 degrees. A value higher than ``0.1`` tells us that we
are roughly above the monster.

We are calling one undefined function, ``mob.squash()``. We have to add it to
the Mob class.

Open the script ``Mob.gd`` by double-clicking on it in the *FileSystem* dock. At
the top of the script, we want to define a new signal named ``squashed``. And at
the bottom, you can add the squash function, where we emit the signal and
destroy the mob.

.. tabs::
 .. code-tab:: gdscript GDScript

   # Emitted when the player jumped on the mob.
   signal squashed

   # ...


   func squash():
       emit_signal("squashed")
       queue_free()

 .. code-tab:: csharp

    // Don't forget to rebuild the project so the editor knows about the new signal.

    // Emitted when the played jumped on the mob.
    [Signal]
    public delegate void Squashed();

    // ...

    public void Squash()
    {
        EmitSignal(nameof(Squashed));
        QueueFree();
    }

We will use the signal to add points to the score in the next lesson.

With that, you should be able to kill monsters by jumping on them. You can press
:kbd:`F5` to try the game and set ``Main.tscn`` as your project's main scene.

However, the player won't die yet. We'll work on that in the next part.

.. |image0| image:: img/06.jump_and_squash/02.project_settings.png
.. |image1| image:: img/06.jump_and_squash/03.physics_layers.png
.. |image2| image:: img/06.jump_and_squash/04.default_physics_properties.png
.. |image3| image:: img/06.jump_and_squash/05.toggle_layer_and_mask.png
.. |image4| image:: img/06.jump_and_squash/06.named_checkboxes.png
.. |image5| image:: img/06.jump_and_squash/07.player_physics_mask.png
.. |image6| image:: img/06.jump_and_squash/08.mob_physics_mask.png
.. |image7| image:: img/06.jump_and_squash/09.groups_tab.png
.. |image8| image:: img/06.jump_and_squash/10.group_scene_icon.png


===================================================
/. ./getting_started/first_3d_game/07.killing_player.rst
===================================================

.. _doc_first_3d_game_killing_the_player:

Killing the player
==================

We can kill enemies by jumping on them, but the player still can't die.
Let's fix this.

We want to detect being hit by an enemy differently from squashing them.
We want the player to die when they're moving on the floor, but not if
they're in the air. We could use vector math to distinguish the two
kinds of collisions. Instead, though, we will use an *Area* node, which
works well for hitboxes.

Hitbox with the Area node
-------------------------

Head back to the *Player* scene and add a new *Area* node. Name it
*MobDetector*. Add a *CollisionShape* node as a child of it.

|image0|

In the *Inspector*, assign a cylinder shape to it.

|image1|

Here is a trick you can use to make the collisions only happen when the
player is on the ground or close to it. You can reduce the cylinder's
height and move it up to the top of the character. This way, when the
player jumps, the shape will be too high up for the enemies to collide
with it.

|image2|

You also want the cylinder to be wider than the sphere. This way, the
player gets hit before colliding and being pushed on top of the
monster's collision box.

The wider the cylinder, the more easily the player will get killed.

Next, select the *MobDetector* node again, and in the *Inspector*, turn
off its *Monitorable* property. This makes it so other physics nodes
cannot detect the area. The complementary *Monitoring* property allows
it to detect collisions. Then, remove the *Collision -> Layer* and set
the mask to the "enemies" layer.

|image3|

When areas detect a collision, they emit signals. We're going to connect
one to the *Player* node. In the *Node* tab, double-click the
``body_entered`` signal and connect it to the *Player*.

|image4|

The *MobDetector* will emit ``body_entered`` when a *KinematicBody* or a
*RigidBody* node enters it. As it only masks the "enemies" physics
layers, it will only detect the *Mob* nodes.

Code-wise, we're going to do two things: emit a signal we'll later use
to end the game and destroy the player. We can wrap these operations in
a ``die()`` function that helps us put a descriptive label on the code.

.. tabs::
 .. code-tab:: gdscript GDScript

   # Emitted when the player was hit by a mob.
   # Put this at the top of the script.
   signal hit


   # And this function at the bottom.
   func die():
       emit_signal("hit")
       queue_free()


   func _on_MobDetector_body_entered(_body):
       die()

 .. code-tab:: csharp

    // Don't forget to rebuild the project so the editor knows about the new signal.

    // Emitted when the player was hit by a mob.
    [Signal]
    public delegate void Hit();

    // ...

    private void Die()
    {
        EmitSignal(nameof(Hit));
        QueueFree();
    }

    // We also specified this function name in PascalCase in the editor's connection window
    public void OnMobDetectorBodyEntered(Node body)
    {
        Die();
    }

Try the game again by pressing :kbd:`F5`. If everything is set up correctly,
the character should die when an enemy runs into it.

However, note that this depends entirely on the size and position of the
*Player* and the *Mob*\ 's collision shapes. You may need to move them
and resize them to achieve a tight game feel.

Ending the game
---------------

We can use the *Player*\ 's ``hit`` signal to end the game. All we need
to do is connect it to the *Main* node and stop the *MobTimer* in
reaction.

Open ``Main.tscn``, select the *Player* node, and in the *Node* dock,
connect its ``hit`` signal to the *Main* node.

|image5|

Get and stop the timer in the ``_on_Player_hit()`` function.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _on_Player_hit():
       $MobTimer.stop()

 .. code-tab:: csharp

    // We also specified this function name in PascalCase in the editor's connection window
    public void OnPlayerHit()
    {
        GetNode<Timer>("MobTimer").Stop();
    }

If you try the game now, the monsters will stop spawning when you die,
and the remaining ones will leave the screen.

You can pat yourself in the back: you prototyped a complete 3D game,
even if it's still a bit rough.

From there, we'll add a score, the option to retry the game, and you'll
see how you can make the game feel much more alive with minimalistic
animations.

Code checkpoint
---------------

Here are the complete scripts for the *Main*, *Mob*, and *Player* nodes,
for reference. You can use them to compare and check your code.

Starting with ``Main.gd``.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends Node

   export(PackedScene) var mob_scene


   func _ready():
       randomize()


   func _on_MobTimer_timeout():
       # Create a new instance of the Mob scene.
       var mob = mob_scene.instance()

       # Choose a random location on the SpawnPath.
       var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
       # And give it a random offset.
       mob_spawn_location.unit_offset = randf()

       # Communicate the spawn location and the player's location to the mob.
       var player_position = $Player.transform.origin
       mob.initialize(mob_spawn_location.translation, player_position)

       # Spawn the mob by adding it to the Main scene.
       add_child(mob)


   func _on_Player_hit():
       $MobTimer.stop()

 .. code-tab:: csharp

    public class Main : Node
    {
    #pragma warning disable 649
        [Export]
        public PackedScene MobScene;
    #pragma warning restore 649

        public override void _Ready()
        {
            GD.Randomize();
        }

        public void OnMobTimerTimeout()
        {
            // Create a new instance of the Mob scene.
            var mob = (Mob)MobScene.Instance();

            // Choose a random location on the SpawnPath.
            // We store the reference to the SpawnLocation node.
            var mobSpawnLocation = GetNode<PathFollow>("SpawnPath/SpawnLocation");
            // And give it a random offset.
            mobSpawnLocation.UnitOffset = GD.Randf();

            // Communicate the spawn location and the player's location to the mob.
            Vector3 playerPosition = GetNode<Player>("Player").Transform.origin;
            mob.Initialize(mobSpawnLocation.Translation, playerPosition);

            // Spawn the mob by adding it to the Main scene.
            AddChild(mob);
        }

        public void OnPlayerHit()
        {
            GetNode<Timer>("MobTimer").Stop();
        }
    }

Next is ``Mob.gd``.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # Emitted when the player jumped on the mob.
   signal squashed

   # Minimum speed of the mob in meters per second.
   export var min_speed = 10
   # Maximum speed of the mob in meters per second.
   export var max_speed = 18

   var velocity = Vector3.ZERO


   func _physics_process(_delta):
       move_and_slide(velocity)


   func initialize(start_position, player_position):
       look_at_from_position(start_position, player_position, Vector3.UP)
       rotate_y(rand_range(-PI / 4, PI / 4))

       var random_speed = rand_range(min_speed, max_speed)
       velocity = Vector3.FORWARD * random_speed
       velocity = velocity.rotated(Vector3.UP, rotation.y)


    func squash():
       emit_signal("squashed")
       queue_free()


   func _on_VisibilityNotifier_screen_exited():
       queue_free()

 .. code-tab:: csharp

    public class Mob : KinematicBody
    {
        // Emitted when the played jumped on the mob.
        [Signal]
        public delegate void Squashed();

        // Minimum speed of the mob in meters per second
        [Export]
        public int MinSpeed = 10;
        // Maximum speed of the mob in meters per second
        [Export]
        public int MaxSpeed = 18;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            MoveAndSlide(_velocity);
        }

        public void Initialize(Vector3 startPosition, Vector3 playerPosition)
        {
            LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
            RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

            float randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
            _velocity = Vector3.Forward * randomSpeed;
            _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);
        }

        public void Squash()
        {
            EmitSignal(nameof(Squashed));
            QueueFree();
        }

        public void OnVisibilityNotifierScreenExited()
        {
            QueueFree();
        }
    }

Finally, the longest script, ``Player.gd``.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # Emitted when a mob hit the player.
   signal hit

   # How fast the player moves in meters per second.
   export var speed = 14
   # The downward acceleration when in the air, in meters per second squared.
   export var fall_acceleration = 75
   # Vertical impulse applied to the character upon jumping in meters per second.
   export var jump_impulse = 20
   # Vertical impulse applied to the character upon bouncing over a mob in meters per second.
   export var bounce_impulse = 16

   var velocity = Vector3.ZERO


   func _physics_process(delta):
       var direction = Vector3.ZERO

       if Input.is_action_pressed("move_right"):
           direction.x += 1
       if Input.is_action_pressed("move_left"):
           direction.x -= 1
       if Input.is_action_pressed("move_back"):
           direction.z += 1
       if Input.is_action_pressed("move_forward"):
           direction.z -= 1

       if direction != Vector3.ZERO:
           direction = direction.normalized()
           $Pivot.look_at(translation + direction, Vector3.UP)

       velocity.x = direction.x * speed
       velocity.z = direction.z * speed

       # Jumping.
       if is_on_floor() and Input.is_action_just_pressed("jump"):
           velocity.y += jump_impulse

       velocity.y -= fall_acceleration * delta
       velocity = move_and_slide(velocity, Vector3.UP)

       for index in range(get_slide_count()):
           var collision = get_slide_collision(index)
           if collision.collider.is_in_group("mob"):
               var mob = collision.collider
               if Vector3.UP.dot(collision.normal) > 0.1:
                   mob.squash()
                   velocity.y = bounce_impulse


   func die():
       emit_signal("hit")
       queue_free()


   func _on_MobDetector_body_entered(_body):
       die()

 .. code-tab:: csharp

    public class Player : KinematicBody
    {
        // Emitted when the player was hit by a mob.
        [Signal]
        public delegate void Hit();

        // How fast the player moves in meters per second.
        [Export]
        public int Speed = 14;
        // The downward acceleration when in the air, in meters per second squared.
        [Export]
        public int FallAcceleration = 75;
        // Vertical impulse applied to the character upon jumping in meters per second.
        [Export]
        public int JumpImpulse = 20;
        // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
        [Export]
        public int BounceImpulse = 16;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            var direction = Vector3.Zero;

            if (Input.IsActionPressed("move_right"))
            {
                direction.x += 1f;
            }
            if (Input.IsActionPressed("move_left"))
            {
                direction.x -= 1f;
            }
            if (Input.IsActionPressed("move_back"))
            {
                direction.z += 1f;
            }
            if (Input.IsActionPressed("move_forward"))
            {
                direction.z -= 1f;
            }

            if (direction != Vector3.Zero)
            {
                direction = direction.Normalized();
                GetNode<Spatial>("Pivot").LookAt(Translation + direction, Vector3.Up);
            }

            _velocity.x = direction.x * Speed;
            _velocity.z = direction.z * Speed;

            // Jumping.
            if (IsOnFloor() && Input.IsActionJustPressed("jump"))
            {
                _velocity.y += JumpImpulse;
            }

            _velocity.y -= FallAcceleration * delta;
            _velocity = MoveAndSlide(_velocity, Vector3.Up);

            for (int index = 0; index < GetSlideCount(); index++)
            {
                KinematicCollision collision = GetSlideCollision(index);
                if (collision.Collider is Mob mob && mob.IsInGroup("mob"))
                {
                    if (Vector3.Up.Dot(collision.Normal) > 0.1f)
                    {
                        mob.Squash();
                        _velocity.y = BounceImpulse;
                    }
                }
            }
        }

        private void Die()
        {
            EmitSignal(nameof(Hit));
            QueueFree();
        }

        public void OnMobDetectorBodyEntered(Node body)
        {
            Die();
        }
    }

See you in the next lesson to add the score and the retry option.

.. |image0| image:: img/07.killing_player/01.adding_area_node.png
.. |image1| image:: img/07.killing_player/02.cylinder_shape.png
.. |image2| image:: img/07.killing_player/03.cylinder_in_editor.png
.. |image3| image:: img/07.killing_player/04.mob_detector_properties.png
.. |image4| image:: img/07.killing_player/05.body_entered_signal.png
.. |image5| image:: img/07.killing_player/06.player_hit_signal.png


===================================================
/. ./getting_started/first_3d_game/08.score_and_replay.rst
===================================================

.. _doc_first_3d_game_score_and_replay:

Score and replay
================

In this part, we'll add the score, music playback, and the ability to restart
the game.

We have to keep track of the current score in a variable and display it on
screen using a minimal interface. We will use a text label to do that.

In the main scene, add a new *Control* node as a child of *Main* and name it
*UserInterface*. You will automatically be taken to the 2D screen, where you can
edit your User Interface (UI).

Add a *Label* node and rename it to *ScoreLabel*.

|image0|

In the *Inspector*, set the *Label*'s *Text* to a placeholder like "Score: 0".

|image1|

Also, the text is white by default, like our game's background. We need to
change its color to see it at runtime.

Scroll down to *Theme Overrides*, and expand *Colors* and click the black box next to *Font Color* to
tint the text.

|image2|

Pick a dark tone so it contrasts well with the 3D scene.

|image3|

Finally, click and drag on the text in the viewport to move it away from the
top-left corner.

|image4|

The *UserInterface* node allows us to group our UI in a branch of the scene tree
and use a theme resource that will propagate to all its children. We'll use it
to set our game's font.

Creating a UI theme
-------------------

Once again, select the *UserInterface* node. In the *Inspector*, create a new
theme resource in *Theme -> Theme*.

|image5|

Click on it to open the theme editor In the bottom panel. It gives you a preview
of how all the built-in UI widgets will look with your theme resource.

|image6|

By default, a theme only has one property, the *Default Font*.

.. seealso::

    You can add more properties to the theme resource to design complex user
    interfaces, but that is beyond the scope of this series. To learn more about
    creating and editing themes, see :ref:`doc_gui_skinning`.

Click the *Default Font* property and create a new *DynamicFont*.

|image7|

Expand the *DynamicFont* by clicking on it and expand its *Font* section. There,
you will see an empty *Font Data* field.

|image8|

This one expects a font file like the ones you have on your computer.
DynamicFont supports the following formats:

- TrueType (``.ttf``)
- OpenType (``.otf``)
- Web Open Font Format 1 (``.woff``)
- Web Open Font Format 2 (``.woff2``, since Godot 3.5)

In the *FileSystem* dock, expand the ``fonts`` directory and click and drag the
``Montserrat-Medium.ttf`` file we included in the project onto the *Font Data*.
The text will reappear in the theme preview.

The text is a bit small. Set the *Settings -> Size* to ``22`` pixels to increase
the text's size.

|image9|

Keeping track of the score
--------------------------

Let's work on the score next. Attach a new script to the *ScoreLabel* and define
the ``score`` variable.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends Label

   var score = 0

 .. code-tab:: csharp

    public class ScoreLabel : Label
    {
        private int _score = 0;
    }

The score should increase by ``1`` every time we squash a monster. We can use
their ``squashed`` signal to know when that happens. However, as we instantiate
monsters from the code, we cannot do the connection in the editor.

Instead, we have to make the connection from the code every time we spawn a
monster.

Open the script ``Main.gd``. If it's still open, you can click on its name in
the script editor's left column.

|image10|

Alternatively, you can double-click the ``Main.gd`` file in the *FileSystem*
dock.

At the bottom of the ``_on_MobTimer_timeout()`` function, add the following
line.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _on_MobTimer_timeout():
       #...
       # We connect the mob to the score label to update the score upon squashing one.
       mob.connect("squashed", $UserInterface/ScoreLabel, "_on_Mob_squashed")

 .. code-tab:: csharp

    public void OnMobTimerTimeout()
    {
        // ...
        // We connect the mob to the score label to update the score upon squashing one.
        mob.Connect(nameof(Mob.Squashed), GetNode<ScoreLabel>("UserInterface/ScoreLabel"), nameof(ScoreLabel.OnMobSquashed));
    }

This line means that when the mob emits the ``squashed`` signal, the
*ScoreLabel* node will receive it and call the function ``_on_Mob_squashed()``.

Head back to the ``ScoreLabel.gd`` script to define the ``_on_Mob_squashed()``
callback function.

There, we increment the score and update the displayed text.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _on_Mob_squashed():
       score += 1
       text = "Score: %s" % score

 .. code-tab:: csharp

    public void OnMobSquashed()
    {
        _score += 1;
        Text = string.Format("Score: {0}", _score);
    }

The second line uses the value of the ``score`` variable to replace the
placeholder ``%s``. When using this feature, Godot automatically converts values
to text, which is convenient to output text in labels or using the ``print()``
function.

.. seealso::

    You can learn more about string formatting here: :ref:`doc_gdscript_printf`.

You can now play the game and squash a few enemies to see the score
increase.

|image11|

.. note::

    In a complex game, you may want to completely separate your user interface
    from the game world. In that case, you would not keep track of the score on
    the label. Instead, you may want to store it in a separate, dedicated
    object. But when prototyping or when your project is simple, it is fine to
    keep your code simple. Programming is always a balancing act.

Retrying the game
-----------------

We'll now add the ability to play again after dying. When the player dies, we'll
display a message on the screen and wait for input.

Head back to the *Main* scene, select the *UserInterface* node, add a
*ColorRect* node as a child of it and name it *Retry*. This node fills a
rectangle with a uniform color and will serve as an overlay to darken the
screen.

To make it span over the whole viewport, you can use the *Layout* menu in the
toolbar.

|image12|

Open it and apply the *Full Rect* command.

|image13|

Nothing happens. Well, almost nothing: only the four green pins move to the
corners of the selection box.

|image14|

This is because UI nodes (all the ones with a green icon) work with anchors and
margins relative to their parent's bounding box. Here, the *UserInterface* node
has a small size and the *Retry* one is limited by it.

Select the *UserInterface* and apply *Layout -> Full Rect* to it as well. The
*Retry* node should now span the whole viewport.

Let's change its color so it darkens the game area. Select *Retry* and in the
*Inspector*, set its *Color* to something both dark and transparent. To do so,
in the color picker, drag the *A* slider to the left. It controls the color's
alpha channel, that is to say, its opacity.

|image15|

Next, add a *Label* as a child of *Retry* and give it the *Text* "Press Enter to
retry."

|image16|

To move it and anchor it in the center of the screen, apply *Layout -> Center*
to it.

|image17|

Coding the retry option
~~~~~~~~~~~~~~~~~~~~~~~

We can now head to the code to show and hide the *Retry* node when the player
dies and plays again.

Open the script ``Main.gd``. First, we want to hide the overlay at the start of
the game. Add this line to the ``_ready()`` function.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _ready():
       #...
       $UserInterface/Retry.hide()

 .. code-tab:: csharp

    public override void _Ready()
    {
        // ...
        GetNode<Control>("UserInterface/Retry").Hide();
    }

Then, when the player gets hit, we show the overlay.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _on_Player_hit():
       #...
       $UserInterface/Retry.show()

 .. code-tab:: csharp

    public void OnPlayerHit()
    {
        //...
        GetNode<Control>("UserInterface/Retry").Show();
    }

Finally, when the *Retry* node is visible, we need to listen to the player's
input and restart the game if they press enter. To do this, we use the built-in
``_unhandled_input()`` callback.

If the player pressed the predefined ``ui_accept`` input action and *Retry* is
visible, we reload the current scene.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _unhandled_input(event):
       if event.is_action_pressed("ui_accept") and $UserInterface/Retry.visible:
           # This restarts the current scene.
           get_tree().reload_current_scene()

 .. code-tab:: csharp

    public override void _UnhandledInput(InputEvent @event)
    {
        if (@event.IsActionPressed("ui_accept") && GetNode<Control>("UserInterface/Retry").Visible)
        {
            // This restarts the current scene.
            GetTree().ReloadCurrentScene();
        }
    }

The function ``get_tree()`` gives us access to the global :ref:`SceneTree
<class_SceneTree>` object, which allows us to reload and restart the current
scene.

Adding music
------------

To add music that plays continuously in the background, we're going to use
another feature in Godot: :ref:`autoloads <doc_singletons_autoload>`.

To play audio, all you need to do is add an *AudioStreamPlayer* node to your
scene and attach an audio file to it. When you start the scene, it can play
automatically. However, when you reload the scene, like we do to play again, the
audio nodes are also reset, and the music starts back from the beginning.

You can use the autoload feature to have Godot load a node or a scene
automatically at the start of the game, outside the current scene. You can also
use it to create globally accessible objects.

Create a new scene by going to the *Scene* menu and clicking *New Scene*.

|image18|

Click the *Other Node* button to create an *AudioStreamPlayer* and rename it to
*MusicPlayer*.

|image19|

We included a music soundtrack in the ``art/`` directory, ``House In a Forest
Loop.ogg``. Click and drag it onto the *Stream* property in the *Inspector*.
Also, turn on *Autoplay* so the music plays automatically at the start of the
game.

|image20|

Save the scene as ``MusicPlayer.tscn``.

We have to register it as an autoload. Head to the *Project -> Project
Settings…* menu and click on the *Autoload* tab.

In the *Path* field, you want to enter the path to your scene. Click the folder
icon to open the file browser and double-click on ``MusicPlayer.tscn``. Then,
click the *Add* button on the right to register the node.

|image21|

If you run the game now, the music will play automatically. And even when you
lose and retry, it keeps going.

Before we wrap up this lesson, here's a quick look at how it works under the
hood. When you run the game, your *Scene* dock changes to give you two tabs:
*Remote* and *Local*.

|image22|

The *Remote* tab allows you to visualize the node tree of your running game.
There, you will see the *Main* node and everything the scene contains and the
instantiated mobs at the bottom.

|image23|

At the top are the autoloaded *MusicPlayer* and a *root* node, which is your
game's viewport.

And that does it for this lesson. In the next part, we'll add an animation to
make the game both look and feel much nicer.

Here is the complete ``Main.gd`` script for reference.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends Node

   export (PackedScene) var mob_scene


   func _ready():
       randomize()
       $UserInterface/Retry.hide()


   func _unhandled_input(event):
       if event.is_action_pressed("ui_accept") and $UserInterface/Retry.visible:
           get_tree().reload_current_scene()


   func _on_MobTimer_timeout():
       var mob = mob_scene.instance()

       var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
       mob_spawn_location.unit_offset = randf()

       var player_position = $Player.transform.origin
       mob.initialize(mob_spawn_location.translation, player_position)

       add_child(mob)
       mob.connect("squashed", $UserInterface/ScoreLabel, "_on_Mob_squashed")


   func _on_Player_hit():
       $MobTimer.stop()
       $UserInterface/Retry.show()

 .. code-tab:: csharp

    public class Main : Node
    {
    #pragma warning disable 649
        [Export]
        public PackedScene MobScene;
    #pragma warning restore 649

        public override void _Ready()
        {
            GD.Randomize();
            GetNode<Control>("UserInterface/Retry").Hide();
        }

        public override void _UnhandledInput(InputEvent @event)
        {
            if (@event.IsActionPressed("ui_accept") && GetNode<Control>("UserInterface/Retry").Visible)
            {
                GetTree().ReloadCurrentScene();
            }
        }

        public void OnMobTimerTimeout()
        {
            Mob mob = (Mob)MobScene.Instance();

            var mobSpawnLocation = GetNode<PathFollow>("SpawnPath/SpawnLocation");
            mobSpawnLocation.UnitOffset = GD.Randf();

            Vector3 playerPosition = GetNode<Player>("Player").Transform.origin;
            mob.Initialize(mobSpawnLocation.Translation, playerPosition);

            AddChild(mob);
            mob.Connect(nameof(Mob.Squashed), GetNode<ScoreLabel>("UserInterface/ScoreLabel"), nameof(ScoreLabel.OnMobSquashed));
        }

        public void OnPlayerHit()
        {
            GetNode<Timer>("MobTimer").Stop();
            GetNode<Control>("UserInterface/Retry").Show();
        }
    }


.. |image0| image:: img/08.score_and_replay/01.label_node.png
.. |image1| image:: img/08.score_and_replay/02.score_placeholder.png
.. |image2| image:: img/08.score_and_replay/02.score_custom_color.png
.. |image3| image:: img/08.score_and_replay/02.score_color_picker.png
.. |image4| image:: img/08.score_and_replay/02.score_label_moved.png
.. |image5| image:: img/08.score_and_replay/03.creating_theme.png
.. |image6| image:: img/08.score_and_replay/04.theme_preview.png
.. |image7| image:: img/08.score_and_replay/05.dynamic_font.png
.. |image8| image:: img/08.score_and_replay/06.font_data.png
.. |image9| image:: img/08.score_and_replay/07.font_size.png
.. |image10| image:: img/08.score_and_replay/08.open_main_script.png
.. |image11| image:: img/08.score_and_replay/09.score_in_game.png
.. |image12| image:: img/08.score_and_replay/10.layout_icon.png
.. |image13| image:: img/08.score_and_replay/11.full_rect_option.png
.. |image14| image:: img/08.score_and_replay/12.anchors_updated.png
.. |image15| image:: img/08.score_and_replay/13.retry_color_picker.png
.. |image16| image:: img/08.score_and_replay/14.retry_node.png
.. |image17| image:: img/08.score_and_replay/15.layout_center.png
.. |image18| image:: img/08.score_and_replay/16.new_scene.png
.. |image19| image:: img/08.score_and_replay/17.music_player_node.png
.. |image20| image:: img/08.score_and_replay/18.music_node_properties.png
.. |image21| image:: img/08.score_and_replay/19.register_autoload.png
.. |image22| image:: img/08.score_and_replay/20.scene_dock_tabs.png
.. |image23| image:: img/08.score_and_replay/21.remote_scene_tree.png


===================================================
/. ./getting_started/first_3d_game/09.adding_animations.rst
===================================================

.. _doc_first_3d_game_character_animation:

Character animation
===================

In this final lesson, we'll use Godot's built-in animation tools to make our
characters float and flap. You'll learn to design animations in the editor and
use code to make your game feel alive.

|image0|

We'll start with an introduction to using the animation editor.

Using the animation editor
--------------------------

The engine comes with tools to author animations in the editor. You can then use
the code to play and control them at runtime.

Open the player scene, select the player node, and add an *AnimationPlayer* node.

The *Animation* dock appears in the bottom panel.

|image1|

It features a toolbar and the animation drop-down menu at the top, a track
editor in the middle that's currently empty, and filter, snap, and zoom options
at the bottom.

Let's create an animation. Click on *Animation -> New*.

|image2|

Name the animation "float".

|image3|

Once you created the animation, the timeline appears with numbers representing
time in seconds.

|image4|

We want the animation to start playback automatically at the start of the game.
Also, it should loop.

To do so, you can click the button with an "A+" icon in the animation toolbar
and the looping arrows, respectively.

|image5|

You can also pin the animation editor by clicking the pin icon in the top-right.
This prevents it from folding when you click on the viewport and deselect the
nodes.

|image6|

Set the animation duration to ``1.2`` seconds in the top-right of the dock.

|image7|

You should see the gray ribbon widen a bit. It shows you the start and end of
your animation and the vertical blue line is your time cursor.

|image8|

You can click and drag the slider in the bottom-right to zoom in and out of the
timeline.

|image9|

The float animation
-------------------

With the animation player node, you can animate most properties on as many nodes
as you need. Notice the key icon next to properties in the *Inspector*. You can
click any of them to create a keyframe, a time and value pair for the
corresponding property. The keyframe gets inserted where your time cursor is in
the timeline.

Let's insert our first keys. Here, we will animate both the translation and the
rotation of the *Character* node.

Select the *Character* and click the key icon next to *Translation* in the
*Inspector*. Do the same for *Rotation Degrees*.

|image10|

Two tracks appear in the editor with a diamond icon representing each keyframe.

|image11|

You can click and drag on the diamonds to move them in time. Move the
translation key to ``0.2`` seconds and the rotation key to ``0.1`` seconds.

|image12|

Move the time cursor to ``0.5`` seconds by clicking and dragging on the gray
timeline. In the *Inspector*, set the *Translation*'s *Y* axis to about
``0.65`` meters and the *Rotation Degrees*' *X* axis to ``8``.

|image13|

Create a keyframe for both properties and shift the translation key to ``0.7``
seconds by dragging it on the timeline.

|image14|

.. note::

    A lecture on the principles of animation is beyond the scope of this
    tutorial. Just note that you don't want to time and space everything evenly.
    Instead, animators play with timing and spacing, two core animation
    principles. You want to offset and contrast in your character's motion to
    make them feel alive.

Move the time cursor to the end of the animation, at ``1.2`` seconds. Set the Y
translation to about ``0.35`` and the X rotation to ``-9`` degrees. Once again,
create a key for both properties.

You can preview the result by clicking the play button or pressing :kbd:`Shift + D`.
Click the stop button or press :kbd:`S` to stop playback.

|image15|

You can see that the engine interpolates between your keyframes to produce a
continuous animation. At the moment, though, the motion feels very robotic. This
is because the default interpolation is linear, causing constant transitions,
unlike how living things move in the real world.

We can control the transition between keyframes using easing curves.

Click and drag around the first two keys in the timeline to box select them.

|image16|

You can edit the properties of both keys simultaneously in the *Inspector*,
where you can see an *Easing* property.

|image17|

Click and drag on the curve, pulling it towards the left. This will make it
ease-out, that is to say, transition fast initially and slow down as the time
cursor reaches the next keyframe.

|image18|

Play the animation again to see the difference. The first half should already
feel a bit bouncier.

Apply an ease-out to the second keyframe in the rotation track.

|image19|

Do the opposite for the second translation keyframe, dragging it to the right.

|image20|

Your animation should look something like this.

|image21|

.. note::

    Animations update the properties of the animated nodes every frame,
    overriding initial values. If we directly animated the *Player* node, it
    would prevent us from moving it in code. This is where the *Pivot* node
    comes in handy: even though we animated the *Character*, we can still move
    and rotate the *Pivot* and layer changes on top of the animation in a
    script.

If you play the game, the player's creature will now float!

If the creature is a little too close to the floor, you can move the *Pivot* up
to offset it.

Controlling the animation in code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can use code to control the animation playback based on the player's input.
Let's change the animation speed when the character is moving.

Open the *Player*'s script by clicking the script icon next to it.

|image22|

In ``_physics_process()``, after the line where we check the ``direction``
vector, add the following code.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _physics_process(delta):
       #...
       #if direction != Vector3.ZERO:
           #...
           $AnimationPlayer.playback_speed = 4
       else:
           $AnimationPlayer.playback_speed = 1

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // ...
        if (direction != Vector3.Zero)
        {
            // ...
            GetNode<AnimationPlayer>("AnimationPlayer").PlaybackSpeed = 4;
        }
        else
        {
            GetNode<AnimationPlayer>("AnimationPlayer").PlaybackSpeed = 1;
        }
    }

This code makes it so when the player moves, we multiply the playback speed by
``4``. When they stop, we reset it to normal.

We mentioned that the pivot could layer transforms on top of the animation. We
can make the character arc when jumping using the following line of code. Add it
at the end of ``_physics_process()``.

.. tabs::
 .. code-tab:: gdscript GDScript

   func _physics_process(delta):
       #...
       $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // ...
        var pivot = GetNode<Spatial>("Pivot");
        pivot.Rotation = new Vector3(Mathf.Pi / 6f * _velocity.y / JumpImpulse, pivot.Rotation.y, pivot.Rotation.z);
    }

Animating the mobs
------------------

Here's another nice trick with animations in Godot: as long as you use a similar
node structure, you can copy them to different scenes.

For example, both the *Mob* and the *Player* scenes have a *Pivot* and a
*Character* node, so we can reuse animations between them.

Open the *Player* scene, select the animation player node and open the "float" animation.
Next, click on **Animation > Copy**. Then open ``Mob.tscn`` and open its animation
player. Click **Animation > Paste**. That's it; all monsters will now play the float
animation.

We can change the playback speed based on the creature's ``random_speed``. Open
the *Mob*'s script and at the end of the ``initialize()`` function, add the
following line.

.. tabs::
 .. code-tab:: gdscript GDScript

   func initialize(start_position, player_position):
       #...
       $AnimationPlayer.playback_speed = random_speed / min_speed

 .. code-tab:: csharp

    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // ...
        GetNode<AnimationPlayer>("AnimationPlayer").PlaybackSpeed = randomSpeed / MinSpeed;
    }

And with that, you finished coding your first complete 3D game.

**Congratulations**!

In the next part, we'll quickly recap what you learned and give you some links
to keep learning more. But for now, here are the complete ``Player.gd`` and
``Mob.gd`` so you can check your code against them.

Here's the *Player* script.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # Emitted when the player was hit by a mob.
   signal hit

   # How fast the player moves in meters per second.
   export var speed = 14
   # The downward acceleration when in the air, in meters per second per second.
   export var fall_acceleration = 75
   # Vertical impulse applied to the character upon jumping in meters per second.
   export var jump_impulse = 20
   # Vertical impulse applied to the character upon bouncing over a mob in meters per second.
   export var bounce_impulse = 16

   var velocity = Vector3.ZERO


   func _physics_process(delta):
       var direction = Vector3.ZERO

       if Input.is_action_pressed("move_right"):
           direction.x += 1
       if Input.is_action_pressed("move_left"):
           direction.x -= 1
       if Input.is_action_pressed("move_back"):
           direction.z += 1
       if Input.is_action_pressed("move_forward"):
           direction.z -= 1

       if direction != Vector3.ZERO:
           direction = direction.normalized()
           $Pivot.look_at(translation + direction, Vector3.UP)
           $AnimationPlayer.playback_speed = 4
       else:
           $AnimationPlayer.playback_speed = 1

       velocity.x = direction.x * speed
       velocity.z = direction.z * speed

       # Jumping
       if is_on_floor() and Input.is_action_just_pressed("jump"):
           velocity.y += jump_impulse

       velocity.y -= fall_acceleration * delta
       velocity = move_and_slide(velocity, Vector3.UP)

       for index in range(get_slide_count()):
           var collision = get_slide_collision(index)
           if collision.collider.is_in_group("mob"):
               var mob = collision.collider
               if Vector3.UP.dot(collision.normal) > 0.1:
                   mob.squash()
                   velocity.y = bounce_impulse

       $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse


   func die():
       emit_signal("hit")
       queue_free()


   func _on_MobDetector_body_entered(_body):
       die()

 .. code-tab:: csharp

    public class Player : KinematicBody
    {
        // Emitted when the player was hit by a mob.
        [Signal]
        public delegate void Hit();

        // How fast the player moves in meters per second.
        [Export]
        public int Speed = 14;
        // The downward acceleration when in the air, in meters per second squared.
        [Export]
        public int FallAcceleration = 75;
        // Vertical impulse applied to the character upon jumping in meters per second.
        [Export]
        public int JumpImpulse = 20;
        // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
        [Export]
        public int BounceImpulse = 16;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            var direction = Vector3.Zero;

            if (Input.IsActionPressed("move_right"))
            {
                direction.x += 1f;
            }
            if (Input.IsActionPressed("move_left"))
            {
                direction.x -= 1f;
            }
            if (Input.IsActionPressed("move_back"))
            {
                direction.z += 1f;
            }
            if (Input.IsActionPressed("move_forward"))
            {
                direction.z -= 1f;
            }

            if (direction != Vector3.Zero)
            {
                direction = direction.Normalized();
                GetNode<Spatial>("Pivot").LookAt(Translation + direction, Vector3.Up);
                GetNode<AnimationPlayer>("AnimationPlayer").PlaybackSpeed = 4;
            }
            else
            {
                GetNode<AnimationPlayer>("AnimationPlayer").PlaybackSpeed = 1;
            }

            _velocity.x = direction.x * Speed;
            _velocity.z = direction.z * Speed;

            // Jumping.
            if (IsOnFloor() && Input.IsActionJustPressed("jump"))
            {
                _velocity.y += JumpImpulse;
            }

            _velocity.y -= FallAcceleration * delta;
            _velocity = MoveAndSlide(_velocity, Vector3.Up);

            for (int index = 0; index < GetSlideCount(); index++)
            {
                KinematicCollision collision = GetSlideCollision(index);
                if (collision.Collider is Mob mob && mob.IsInGroup("mob"))
                {
                    if (Vector3.Up.Dot(collision.Normal) > 0.1f)
                    {
                        mob.Squash();
                        _velocity.y = BounceImpulse;
                    }
                }
            }

            var pivot = GetNode<Spatial>("Pivot");
            pivot.Rotation = new Vector3(Mathf.Pi / 6f * _velocity.y / JumpImpulse, pivot.Rotation.y, pivot.Rotation.z);
        }

        private void Die()
        {
            EmitSignal(nameof(Hit));
            QueueFree();
        }

        public void OnMobDetectorBodyEntered(Node body)
        {
            Die();
        }
    }


And the *Mob*'s script.

.. tabs::
 .. code-tab:: gdscript GDScript

   extends KinematicBody

   # Emitted when the player jumped on the mob.
   signal squashed

   # Minimum speed of the mob in meters per second.
   export var min_speed = 10
   # Maximum speed of the mob in meters per second.
   export var max_speed = 18

   var velocity = Vector3.ZERO


   func _physics_process(_delta):
       move_and_slide(velocity)


   func initialize(start_position, player_position):
       look_at_from_position(start_position, player_position, Vector3.UP)
       rotate_y(rand_range(-PI / 4, PI / 4))

       var random_speed = rand_range(min_speed, max_speed)
       velocity = Vector3.FORWARD * random_speed
       velocity = velocity.rotated(Vector3.UP, rotation.y)

       $AnimationPlayer.playback_speed = random_speed / min_speed


    func squash():
       emit_signal("squashed")
       queue_free()


   func _on_VisibilityNotifier_screen_exited():
       queue_free()

 .. code-tab:: csharp

    public class Mob : KinematicBody
    {
        // Emitted when the played jumped on the mob.
        [Signal]
        public delegate void Squashed();

        // Minimum speed of the mob in meters per second
        [Export]
        public int MinSpeed = 10;
        // Maximum speed of the mob in meters per second
        [Export]
        public int MaxSpeed = 18;

        private Vector3 _velocity = Vector3.Zero;

        public override void _PhysicsProcess(float delta)
        {
            MoveAndSlide(_velocity);
        }

        public void Initialize(Vector3 startPosition, Vector3 playerPosition)
        {
            LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
            RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

            float randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
            _velocity = Vector3.Forward * randomSpeed;
            _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);

            GetNode<AnimationPlayer>("AnimationPlayer").PlaybackSpeed = randomSpeed / MinSpeed;
        }

        public void Squash()
        {
            EmitSignal(nameof(Squashed));
            QueueFree();
        }

        public void OnVisibilityNotifierScreenExited()
        {
            QueueFree();
        }
    }

.. |image0| image:: img/squash-the-creeps-final.gif
.. |image1| image:: img/09.adding_animations/01.animation_player_dock.png
.. |image2| image:: img/09.adding_animations/02.new_animation.png
.. |image3| image:: img/09.adding_animations/03.float_name.png
.. |image4| image:: img/09.adding_animations/03.timeline.png
.. |image5| image:: img/09.adding_animations/04.autoplay_and_loop.png
.. |image6| image:: img/09.adding_animations/05.pin_icon.png
.. |image7| image:: img/09.adding_animations/06.animation_duration.png
.. |image8| image:: img/09.adding_animations/07.editable_timeline.png
.. |image9| image:: img/09.adding_animations/08.zoom_slider.png
.. |image10| image:: img/09.adding_animations/09.creating_first_keyframe.png
.. |image11| image:: img/09.adding_animations/10.initial_keys.png
.. |image12| image:: img/09.adding_animations/11.moving_keys.png
.. |image13| image:: img/09.adding_animations/12.second_keys_values.png
.. |image14| image:: img/09.adding_animations/13.second_keys.png
.. |image15| image:: img/09.adding_animations/14.play_button.png
.. |image16| image:: img/09.adding_animations/15.box_select.png
.. |image17| image:: img/09.adding_animations/16.easing_property.png
.. |image18| image:: img/09.adding_animations/17.ease_out.png
.. |image19| image:: img/09.adding_animations/18.ease_out_second_rotation_key.png
.. |image20| image:: img/09.adding_animations/19.ease_in_second_translation_key.png
.. |image21| image:: img/09.adding_animations/20.float_animation.gif
.. |image22| image:: img/09.adding_animations/21.script_icon.png


===================================================
/. ./getting_started/first_3d_game/going_further.rst
===================================================

.. _doc_first_3d_game_going_further:

Going further
=============

You can pat yourself on the back for having completed your first 3D game with
Godot.

In this series, we went over a wide range of techniques and editor features.
Hopefully, you’ve witnessed how intuitive Godot’s scene system can be and
learned a few tricks you can apply in your projects.

But we just scratched the surface: Godot has a lot more in store for you to save
time creating games. And you can learn all that by browsing the documentation.

Where should you begin? Below, you’ll find a few pages to start exploring and
build upon what you’ve learned so far.

But before that, here’s a link to download a completed version of the project:
`<https://github.com/GDQuest/godot-3d-dodge-the-creeps>`_.

Exploring the manual
--------------------

The manual is your ally whenever you have a doubt or you’re curious about a
feature. It does not contain tutorials about specific game genres or mechanics.
Instead, it explains how Godot works in general. In it, you will find
information about 2D, 3D, physics, rendering and performance, and much more.

Here are the sections we recommend you to explore next:

1. Read the :ref:`Scripting section <toc-scripting-core-features>` to learn essential programming features you’ll use
   in every project.
2. The :ref:`3D <toc-learn-features-3d>` and :ref:`Physics <toc-learn-features-physics>` sections will teach you more about 3D game creation in the
   engine.
3. :ref:`Inputs <toc-learn-features-inputs>` is another important one for any game project.

You can start with these or, if you prefer, look at the sidebar menu on the left
and pick your options.

We hope you enjoyed this tutorial series, and we’re looking forward to seeing
what you achieve using Godot.


===================================================
/. ./tutorials/best_practices/index.rst
===================================================

Best practices
==============

.. toctree::
   :maxdepth: 1
   :name: toc-best-practices

   introduction_best_practices
   what_are_godot_classes
   scene_organization
   scenes_versus_scripts
   autoloads_versus_internal_nodes
   node_alternatives
   godot_interfaces
   godot_notifications
   data_preferences
   logic_preferences
   project_organization
   version_control_systems


===================================================
/. ./tutorials/best_practices/introduction_best_practices.rst
===================================================

.. _doc_introduction_best_practices:

Introduction
============

This series is a collection of best practices to help you work efficiently with
Godot.

Godot allows for a great amount of flexibility in how you structure a project's
codebase and break it down into scenes. Each approach has its pros and
cons, and they can be hard to weigh until you've worked with the engine for long enough.

There are always many ways to structure your code and solve specific programming
problems. It would be impossible to cover them all here.

That is why each article starts from a real-world problem. We will break down
each problem in fundamental questions, suggest solutions, analyze the pros and
cons of each option, and highlight the best course of action for the problem at hand.

You should start by reading :ref:`doc_what_are_godot_classes`. It explains how
Godot's nodes and scenes relate to classes and objects in other
Object-Oriented programming languages. It will help you make sense of the rest of the series.

.. note::

   The best practices in Godot rely on Object-Oriented design principles. We
   use tools like the `single responsibility
   <https://en.wikipedia.org/wiki/Single_responsibility_principle>`_ principle and
   `encapsulation <https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>`_.


===================================================
/. ./tutorials/best_practices/what_are_godot_classes.rst
===================================================

.. _doc_what_are_godot_classes:

Applying object-oriented principles in Godot
============================================

The engine offers two main ways to create reusable objects: scripts and scenes. Neither of these
technically define classes under the hood.

Still, many best practices using Godot involve applying object-oriented programming principles to
the scripts and scenes that compose your game. That is why it's useful to understand how we can
think of them as classes.

This guide briefly explains how scripts and scenes work in the engine's core to help you understand
how they work under the hood.

How scripts work in the engine
------------------------------

The engine provides built-in classes like :ref:`Node <class_Node>`. You can extend those to create
derived types using a script.

These scripts are not technically classes. Instead, they are resources that tell the engine a
sequence of initializations to perform on one of the engine's built-in classes.

Godot's internal classes have methods that register a class's data with a :ref:`ClassDB
<class_ClassDB>`. This database provides runtime access to class information. ``ClassDB`` contains
information about classes like:

- Properties.
- Methods.
- Constants.
- Signals.

This ``ClassDB`` is what objects check against when performing an operation like accessing a
property or calling a method. It checks the database's records and the object's base types' records
to see if the object supports the operation.

Attaching a :ref:`Script <class_Script>` to your object extends the methods, properties, and signals
available from the ``ClassDB``.

.. note::

    Even scripts that don't use the ``extends`` keyword implicitly inherit from the engine's base
    :ref:`Reference <class_Reference>` class. As a result, you can instantiate scripts without the
    ``extends`` keyword from code. Since they extend ``Reference`` though, you cannot attach them to
    a :ref:`Node <class_Node>`.

Scenes
------

The behavior of scenes has many similarities to classes, so it can make sense to think of a scene as
a class. Scenes are reusable, instantiable, and inheritable groups of nodes. Creating a scene is
similar to having a script that creates nodes and adds them as children using ``add_child()``.

We often pair a scene with a scripted root node that makes use of the scene's nodes. As such, the
scene is often an extension of the script's declarative code.

The content of a scene helps to define:

- What nodes are available to the script
- How they are organized
- How they are initialized
- What signal connections they have with each other

Why is any of this important to scene organization? Because instances of scenes *are* objects. As a
result, many object-oriented principles that apply to written code also apply to scenes: single
responsibility, encapsulation, and others.

The scene is *always an extension of the script attached to its root node*, so you can interpret it
as part of a class.

Most of the techniques explained in this best practices series build on this point.


===================================================
/. ./tutorials/best_practices/scene_organization.rst
===================================================

.. _doc_scene_organization:

Scene organization
==================

This article covers topics related to the effective organization of
scene content. Which nodes should one use? Where should one place them?
How should they interact?

How to build relationships effectively
--------------------------------------

When Godot users begin crafting their own scenes, they often run into the
following problem:

They create their first scene and fill it with content only to eventually end
up saving branches of their scene into separate scenes as the nagging feeling
that they should split things up starts to accumulate. However, they then
notice that the hard references they were able to rely on before are no longer
possible. Re-using the scene in multiple places creates issues because the
node paths do not find their targets and signal connections established in the
editor break.

To fix these problems, one must instantiate the sub-scenes without them
requiring details about their environment. One needs to be able to trust
that the sub-scene will create itself without being picky about how one uses
it.

One of the biggest things to consider in OOP is maintaining
focused, singular-purpose classes with
`loose coupling <https://en.wikipedia.org/wiki/Loose_coupling>`_
to other parts of the codebase. This keeps the size of objects small (for
maintainability) and improves their reusability.

These OOP best practices have *several* implications for best practices
in scene structure and script usage.

**If at all possible, one should design scenes to have no dependencies.**
That is, one should create scenes that keep everything they need within
themselves.

If a scene must interact with an external context, experienced developers
recommend the use of
`Dependency Injection <https://en.wikipedia.org/wiki/Dependency_injection>`_.
This technique involves having a high-level API provide the dependencies of the
low-level API. Why do this? Because classes which rely on their external
environment can inadvertently trigger bugs and unexpected behavior.

To do this, one must expose data and then rely on a parent context to
initialize it:

1. Connect to a signal. Extremely safe, but should be used only to "respond" to
   behavior, not start it. Note that signal names are usually past-tense verbs
   like "entered", "skill_activated", or "item_collected".

   .. tabs::
     .. code-tab:: gdscript GDScript

       # Parent
       $Child.connect("signal_name", object_with_method, "method_on_the_object")

       # Child
       emit_signal("signal_name") # Triggers parent-defined behavior.

     .. code-tab:: csharp

       // Parent
       GetNode("Child").Connect("SignalName", ObjectWithMethod, "MethodOnTheObject");

       // Child
       EmitSignal("SignalName"); // Triggers parent-defined behavior.

2. Call a method. Used to start behavior.

   .. tabs::
     .. code-tab:: gdscript GDScript

       # Parent
       $Child.method_name = "do"

       # Child, assuming it has String property 'method_name' and method 'do'.
       call(method_name) # Call parent-defined method (which child must own).

     .. code-tab:: csharp

       // Parent
       GetNode("Child").Set("MethodName", "Do");

       // Child
       Call(MethodName); // Call parent-defined method (which child must own).

3. Initialize a :ref:`FuncRef <class_FuncRef>` property. Safer than a method
   as ownership of the method is unnecessary. Used to start behavior.

   .. tabs::
     .. code-tab:: gdscript GDScript

       # Parent
       $Child.func_property = funcref(object_with_method, "method_on_the_object")

       # Child
       func_property.call_func() # Call parent-defined method (can come from anywhere).

     .. code-tab:: csharp

       // Parent
       GetNode("Child").Set("FuncProperty", GD.FuncRef(ObjectWithMethod, "MethodOnTheObject"));

       // Child
       FuncProperty.CallFunc(); // Call parent-defined method (can come from anywhere).

4. Initialize a Node or other Object reference.

   .. tabs::
     .. code-tab:: gdscript GDScript

       # Parent
       $Child.target = self

       # Child
       print(target) # Use parent-defined node.

     .. code-tab:: csharp

       // Parent
       GetNode("Child").Set("Target", this);

       // Child
       GD.Print(Target); // Use parent-defined node.

5. Initialize a NodePath.

   .. tabs::
     .. code-tab:: gdscript GDScript

       # Parent
       $Child.target_path = ".."

       # Child
       get_node(target_path) # Use parent-defined NodePath.

     .. code-tab:: csharp

       // Parent
       GetNode("Child").Set("TargetPath", NodePath(".."));

       // Child
       GetNode(TargetPath); // Use parent-defined NodePath.

These options hide the points of access from the child node. This in turn
keeps the child **loosely coupled** to its environment. One can reuse it
in another context without any extra changes to its API.

.. note::

  Although the examples above illustrate parent-child relationships,
  the same principles apply towards all object relations. Nodes which
  are siblings should only be aware of their hierarchies while an ancestor
  mediates their communications and references.

  .. tabs::
    .. code-tab:: gdscript GDScript

      # Parent
      $Left.target = $Right.get_node("Receiver")

      # Left
      var target: Node
      func execute():
          # Do something with 'target'.

      # Right
      func _init():
          var receiver = Receiver.new()
          add_child(receiver)

    .. code-tab:: csharp

      // Parent
      GetNode<Left>("Left").Target = GetNode("Right/Receiver");

      public class Left : Node
      {
          public Node Target = null;

          public void Execute()
          {
              // Do something with 'Target'.
          }
      }

      public class Right : Node
      {
          public Node Receiver = null;

          public Right()
          {
              Receiver = ResourceLoader.Load<Script>("Receiver.cs").New();
              AddChild(Receiver);
          }
      }

  The same principles also apply to non-Node objects that maintain dependencies
  on other objects. Whichever object actually owns the objects should manage
  the relationships between them.

.. warning::

  One should favor keeping data in-house (internal to a scene) though as
  placing a dependency on an external context, even a loosely coupled one,
  still means that the node will expect something in its environment to be
  true. The project's design philosophies should prevent this from happening.
  If not, the code's inherent liabilities will force developers to use
  documentation to keep track of object relations on a microscopic scale; this
  is otherwise known as development hell. Writing code that relies on external
  documentation for one to use it safely is error-prone by default.

  To avoid creating and maintaining such documentation, one converts the
  dependent node ("child" above) into a tool script that implements
  :ref:`_get_configuration_warning() <class_Node_method__get_configuration_warning>`.
  Returning a non-empty string from it will make the Scene dock generate a
  warning icon with the string as a tooltip by the node. This is the same icon
  that appears for nodes such as the
  :ref:`Area2D <class_Area2D>` node when it has no child
  :ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The editor
  then self-documents the scene through the script code. No content duplication
  via documentation is necessary.

  A GUI like this can better inform project users of critical information about
  a Node. Does it have external dependencies? Have those dependencies been
  satisfied? Other programmers, and especially designers and writers, will need
  clear instructions in the messages telling them what to do to configure it.

So, why do all this complex switcharoo work? Well, because scenes operate
best when they operate alone. If unable to work alone, then working with
others anonymously (with minimal hard dependencies, i.e. loose coupling)
is the next best thing. Inevitably, changes may need to be made to a class and
if these changes cause it to interact with other scenes in unforeseen ways,
then things will start to break down. The whole point of all this indirection
is to avoid ending up in a situation where changing one class results in
adversely effecting other classes.

Scripts and scenes, as extensions of engine classes, should abide
by *all* OOP principles. Examples include...

- `SOLID <https://en.wikipedia.org/wiki/SOLID>`_
- `DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_
- `KISS <https://en.wikipedia.org/wiki/KISS_principle>`_
- `YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_

Choosing a node tree structure
------------------------------

So, a developer starts work on a game only to stop at the vast possibilities
before them. They might know what they want to do, what systems they want to
have, but *where* to put them all? Well, how one goes about making their game
is always up to them. One can construct node trees in countless ways.
But, for those who are unsure, this helpful guide can give them a sample of
a decent structure to start with.

A game should always have a sort of "entry point"; somewhere the developer can
definitively track where things begin so that they can follow the logic as it
continues elsewhere. This place also serves as a bird's eye view of all of the
other data and logic in the program. For traditional applications, this would
be the "main" function. In this case, it would be a Main node.

    - Node "Main" (main.gd)

The ``main.gd`` script would then serve as the primary controller of one's
game.

Then one has their actual in-game "World" (a 2D or 3D one). This can be a child
of Main. In addition, one will need a primary GUI for their game that manages
the various menus and widgets the project needs.

    - Node "Main" (main.gd)
        - Node2D/Spatial "World" (game_world.gd)
        - Control "GUI" (gui.gd)

When changing levels, one can then swap out the children of the "World" node.
:ref:`Changing scenes manually <doc_change_scenes_manually>` gives users full
control over how their game world transitions.

The next step is to consider what gameplay systems one's project requires.
If one has a system that...

1. tracks all of its data internally
2. should be globally accessible
3. should exist in isolation

... then one should create an :ref:`autoload 'singleton' node <doc_singletons_autoload>`.

.. note::

  For smaller games, a simpler alternative with less control would be to have
  a "Game" singleton that simply calls the
  :ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>` method
  to swap out the main scene's content. This structure more or less keeps
  the "World" as the main game node.

  Any GUI would need to also be a
  singleton; be a transitory part of the "World"; or be manually added as a
  direct child of the root. Otherwise, the GUI nodes would also delete
  themselves during scene transitions.

If one has systems that modify other systems' data, one should define those as
their own scripts or scenes rather than autoloads. For more information on the
reasons, please see the
:ref:`Autoloads versus regular nodes <doc_autoloads_versus_internal_nodes>`
documentation.

Each subsystem within one's game should have its own section within the
SceneTree. One should use parent-child relationships only in cases where nodes
are effectively elements of their parents. Does removing the parent reasonably
mean that one should also remove the children? If not, then it should have its
own place in the hierarchy as a sibling or some other relation.

.. note::

  In some cases, one needs these separated nodes to *also* position themselves
  relative to each other. One can use the
  :ref:`RemoteTransform <class_RemoteTransform>` /
  :ref:`RemoteTransform2D <class_RemoteTransform2D>` nodes for this purpose.
  They will allow a target node to conditionally inherit selected transform
  elements from the Remote\* node. To assign the ``target``
  :ref:`NodePath <class_NodePath>`, use one of the following:

  1. A reliable third party, likely a parent node, to mediate the assignment.
  2. A group, to easily pull a reference to the desired node (assuming there
     will only ever be one of the targets).

  When should one do this? Well, this is subjective. The dilemma arises when
  one must micro-manage when a node must move around the SceneTree to preserve
  itself. For example...

  - Add a "player" node to a "room".
  - Need to change rooms, so one must delete the current room.
  - Before the room can be deleted, one must preserve and/or move the player.

    Is memory a concern?

    - If not, one can just create the two rooms, move the player
      and delete the old one. No problem.

    If so, one will need to...

    - Move the player somewhere else in the tree.
    - Delete the room.
    - Instantiate and add the new room.
    - Re-add the player.

  The issue is that the player here is a "special case"; one where the
  developers must *know* that they need to handle the player this way for the
  project. As such, the only way to reliably share this information as a team
  is to *document* it. Keeping implementation details in documentation however
  is dangerous. It's a maintenance burden, strains code readability, and bloats
  the intellectual content of a project unnecessarily.

  In a more complex game with larger assets, it can be a better idea to simply
  keep the player somewhere else in the SceneTree entirely. This results in:

  1. More consistency.
  2. No "special cases" that must be documented and maintained somewhere.
  3. No opportunity for errors to occur because these details are not accounted
     for.

  In contrast, if one ever needs to have a child node that does *not* inherit
  the transform of their parent, one has the following options:

  1. The **declarative** solution: place a :ref:`Node <class_Node>` in between
     them. As nodes with no transform, Nodes will not pass along such
     information to their children.
  2. The **imperative** solution: Use the ``set_as_toplevel`` setter for the
     :ref:`CanvasItem <class_CanvasItem_method_set_as_toplevel>` or
     :ref:`Spatial <class_Spatial_method_set_as_toplevel>` node. This will make
     the node ignore its inherited transform.

.. note::

  If building a networked game, keep in mind which nodes and gameplay systems
  are relevant to all players versus those just pertinent to the authoritative
  server. For example, users do not all need to have a copy of every players'
  "PlayerController" logic. Instead, they need only their own. As such, keeping
  these in a separate branch from the "world" can help simplify the management
  of game connections and the like.

The key to scene organization is to consider the SceneTree in relational terms
rather than spatial terms. Are the nodes dependent on their parent's existence?
If not, then they can thrive all by themselves somewhere else.
If they are dependent, then it stands to reason that they should be children of
that parent (and likely part of that parent's scene if they aren't already).

Does this mean nodes themselves are components? Not at all.
Godot's node trees form an aggregation relationship, not one of composition.
But while one still has the flexibility to move nodes around, it is still best
when such moves are unnecessary by default.


===================================================
/. ./tutorials/best_practices/scenes_versus_scripts.rst
===================================================

.. _doc_scenes_versus_scripts:

When to use scenes versus scripts
=================================

We've already covered how scenes and scripts are different. Scripts
define an engine class extension with imperative code, scenes with
declarative code.

Each system's capabilities are different as a result.
Scenes can define how an extended class initializes, but not what its
behavior actually is. Scenes are often used in conjunction with a script so
that the scene acts as an extension of the scripts declarative code.

Anonymous types
---------------

It *is* possible to completely define a scenes' contents using a script alone.
This is, in essence, what the Godot Editor does, only in the C++ constructor
of its objects.

But, choosing which one to use can be a dilemma. Creating script instances
is identical to creating in-engine classes whereas handling scenes requires
a change in API:

    .. tabs::
      .. code-tab:: gdscript GDScript

        const MyNode = preload("my_node.gd")
        const MyScene = preload("my_scene.tscn")
        var node = Node.new()
        var my_node = MyNode.new() # Same method call
        var my_scene = MyScene.instance() # Different method call
        var my_inherited_scene = MyScene.instance(PackedScene.GEN_EDIT_STATE_MAIN) # Create scene inheriting from MyScene

      .. code-tab:: csharp

        using System;
        using Godot;

        public class Game : Node
        {
            public readonly Script MyNodeScr = (Script)ResourceLoader.Load("MyNode.cs");
            public readonly PackedScene MySceneScn = (PackedScene)ResourceLoader.Load("MyScene.tscn");
            public Node ANode;
            public Node MyNode;
            public Node MyScene;
            public Node MyInheritedScene;

            public Game()
            {
                ANode = new Node();
                MyNode = new MyNode(); // Same syntax
                MyScene = MySceneScn.Instance(); // Different. Instantiated from a PackedScene
                MyInheritedScene = MySceneScn.Instance(PackedScene.GenEditState.Main); // Create scene inheriting from MyScene
            }
        }

Also, scripts will operate a little slower than scenes due to the
speed differences between engine and script code. The larger and more complex
the node, the more reason there is to build it as a scene.

Named types
-----------

In some cases, a user can register a script as a new type within the editor
itself. This displays it as a new type in the node or resource creation dialog
with an optional icon. In these cases, the user's ability to use the script
is much more streamlined. Rather than having to...

1. Know the base type of the script they would like to use.

2. Create an instance of that base type.

3. Add the script to the node.

   1. (Drag-n-drop method)

      1. Find the script in the FileSystem dock.

      2. Drag and drop the script onto the node in the Scene dock.

   2. (Property method)

      1. Scroll down to the bottom of the Inspector to find the ``script`` property and select it.

      2. Select "Load" from the dropdown.

      3. Select the script from the file dialog.

With a registered script, the scripted type instead becomes a creation option
like the other nodes and resources in the system. One need not do any of the
above work. The creation dialog even has a search bar to look up the type by
name.

There are two systems for registering types...

- :ref:`Custom Types <doc_making_plugins>`

   - Editor-only. Typenames are not accessible at runtime.

   - Does not support inherited custom types.

   - An initializer tool. Creates the node with the script. Nothing more.

   - Editor has no type-awareness of the script or its relationship
     to other engine types or scripts.

   - Allows users to define an icon.

   - Works for all scripting languages because it deals with Script resources in abstract.

   - Set up using :ref:`EditorPlugin.add_custom_type <class_EditorPlugin_method_add_custom_type>`.

- :ref:`Script Classes <doc_gdscript_basics_class_name>`

   - Editor and runtime accessible.

   - Displays inheritance relationships in full.

   - Creates the node with the script, but can also change types
     or extend the type from the editor.

   - Editor is aware of inheritance relationships between scripts,
     script classes, and engine C++ classes.

   - Allows users to define an icon.

   - Engine developers must add support for languages manually (both name exposure and
     runtime accessibility).

   - Godot 3.1+ only.

   - The Editor scans project folders and registers any exposed names for all
     scripting languages. Each scripting language must implement its own
     support for exposing this information.

Both methodologies add names to the creation dialog, but script classes, in
particular, also allow for users to access the typename without loading the
script resource. Creating instances and accessing constants or static methods
is viable from anywhere.

With features like these, one may wish their type to be a script without a
scene due to the ease of use it grants users. Those developing plugins or
creating in-house tools for designers to use will find an easier time of things
this way.

On the downside, it also means having to use largely imperative programming.

Performance of Script vs PackedScene
------------------------------------

One last aspect to consider when choosing scenes and scripts is execution speed.

As the size of objects increases, the scripts' necessary size to create and
initialize them grows much larger. Creating node hierarchies demonstrates this.
Each Node's logic could be several hundred lines of code in length.

The code example below creates a new ``Node``, changes its name, assigns a
script to it, sets its future parent as its owner so it gets saved to disk along
with it, and finally adds it as a child of the ``Main`` node:

.. tabs::
  .. code-tab:: gdscript GDScript

    # Main.gd
    extends Node

    func _init():
        var child = Node.new()
        child.name = "Child"
        child.script = preload("Child.gd")
        child.owner = self
        add_child(child)

  .. code-tab:: csharp

    using System;
    using Godot;

    public class Main : Resource
    {
        public Node Child { get; set; }

        public Main()
        {
            Child = new Node();
            Child.Name = "Child";
            Child.Script = ResourceLoader.Load<Script>("child.gd");
            Child.Owner = this;
            AddChild(Child);
        }
    }

Script code like this is much slower than engine-side C++ code. Each instruction
makes a call to the scripting API which leads to many "lookups" on the back-end
to find the logic to execute.

Scenes help to avoid this performance issue. :ref:`PackedScene
<class_PackedScene>`, the base type that scenes inherit from, defines resources
that use serialized data to create objects. The engine can process scenes in
batches on the back-end and provide much better performance than scripts.

Conclusion
----------

In the end, the best approach is to consider the following:

- If one wishes to create a basic tool that is going to be re-used in several
  different projects and which people of all skill levels will likely use
  (including those who don't label themselves as "programmers"), then chances
  are that it should probably be a script, likely one with a custom name/icon.

- If one wishes to create a concept that is particular to their game, then it
  should always be a scene. Scenes are easier to track/edit and provide more
  security than scripts.

- If one would like to give a name to a scene, then they can still sort of do
  this in 3.1 by declaring a script class and giving it a scene as a constant.
  The script becomes, in effect, a namespace:

  .. tabs::
    .. code-tab:: gdscript GDScript

      # game.gd
      extends Reference
      class_name Game # extends Reference, so it won't show up in the node creation dialog
      const MyScene = preload("my_scene.tscn")

      # main.gd
      extends Node
      func _ready():
          add_child(Game.MyScene.instance())


===================================================
/. ./tutorials/best_practices/autoloads_versus_internal_nodes.rst
===================================================

.. _doc_autoloads_versus_internal_nodes:

Autoloads versus regular nodes
==============================

Godot offers a feature to automatically load nodes at the root of your project,
allowing you to access them globally, that can fulfill the role of a Singleton:
:ref:`doc_singletons_autoload`. These auto-loaded nodes are not freed when you
change the scene from code with :ref:`SceneTree.change_scene <class_SceneTree_method_change_scene>`.

In this guide, you will learn when to use the Autoload feature, and techniques
you can use to avoid it.

The cutting audio issue
-----------------------

Other engines can encourage the use of creating manager classes, singletons that
organize a lot of functionality into a globally accessible object. Godot offers
many ways to avoid global state thanks to the node tree and signals.

For example, let's say we are building a platformer and want to collect coins
that play a sound effect. There's a node for that: the :ref:`AudioStreamPlayer
<class_AudioStreamPlayer>`. But if we call the ``AudioStreamPlayer`` while it is
already playing a sound, the new sound interrupts the first.

A solution is to code a global, auto-loaded sound manager class. It generates a
pool of ``AudioStreamPlayer`` nodes that cycle through as each new request for
sound effects comes in. Say we call that class ``Sound``, you can use it from
anywhere in your project by calling ``Sound.play("coin_pickup.ogg")``. This
solves the problem in the short term but causes more problems:

1. **Global state**: one object is now responsible for all objects' data. If the
   ``Sound`` class has errors or doesn't have an AudioStreamPlayer available,
   all the nodes calling it can break.

2. **Global access**: now that any object can call ``Sound.play(sound_path)``
   from anywhere, there's no longer an easy way to find the source of a bug.

3. **Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes
   stored from the start, you can either have too few and face bugs, or too many
   and use more memory than you need.

.. note::

   About global access, the problem is that Any code anywhere could pass wrong
   data to the ``Sound`` autoload in our example. As a result, the domain to
   explore to fix the bug spans the entire project.

   When you keep code inside a scene, only one or two scripts may be
   involved in audio.

Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as it
needs within itself and all these problems go away:

1. Each scene manages its own state information. If there is a problem with the
   data, it will only cause issues in that one scene.

2. Each scene accesses only its own nodes. Now, if there is
   a bug, it's easy to find which node is at fault.

3. Each scene allocates exactly the amount of resources it needs.

Managing shared functionality or data
-------------------------------------

Another reason to use an Autoload can be that you want to reuse the same method
or data across many scenes.

In the case of functions, you can create a new type of ``Node`` that provides
that feature for an individual scene using the :ref:`class_name
<doc_gdscript_basics_class_name>` keyword in GDScript.

When it comes to data, you can either:

1. Create a new type of :ref:`Resource <class_Resource>` to share the data.

2. Store the data in an object to which each node has access, for example using
   the ``owner`` property to access the scene's root node.

When you should use an Autoload
-------------------------------

Auto-loaded nodes can simplify your code in some cases:

- **Static Data**: if you need data that is exclusive to one class, like a
  database, then an autoload can be a good tool. There is no scripting API in
  Godot to create and manage static data otherwise.

- **Static functions**: creating a library of functions that only return values.

- **Systems with a wide scope**: If the singleton is managing its own
  information and not invading the data of other objects, then it's a great way to
  create systems that handle broad-scoped tasks. For example, a quest or a
  dialogue system.

Until Godot 3.1, another use was just for convenience: autoloads have a global
variable for their name generated in GDScript, allowing you to call them from
any script file in your project. But now, you can use the ``class_name`` keyword
instead to get auto-completion for a type in your entire project.

.. note::

   Autoload is not exactly a Singleton. Nothing prevents you from instantiating
   copies of an auto-loaded node. It is only a tool that makes a node load
   automatically as a child of the root of your scene tree, regardless of your
   game's node structure or which scene you run, e.g. by pressing :kbd:`F6` key.

   As a result, you can get the auto-loaded node, for example an autoload called
   ``Sound``, by calling ``get_node("/root/Sound")``.


===================================================
/. ./tutorials/best_practices/node_alternatives.rst
===================================================

.. _doc_node_alternatives:

When and how to avoid using nodes for everything
================================================


Nodes are cheap to produce, but even they have their limits. A project may
have tens of thousands of nodes all doing things. The more complex their
behavior though, the larger the strain each one adds to a project's
performance.

Godot provides more lightweight objects for creating APIs which nodes use.
Be sure to keep these in mind as options when designing how you wish to build
your project's features.

1. :ref:`Object <class_Object>`: The ultimate lightweight object, the original
   Object must use manual memory management. With that said, it isn't too
   difficult to create one's own custom data structures, even node structures,
   that are also lighter than the :ref:`Node <class_Node>` class.

   - **Example:** See the :ref:`Tree <class_Tree>` node. It supports a high level
     of customization for a table of content with an arbitrary number of
     rows and columns. The data that it uses to generate its visualization
     though is actually a tree of :ref:`TreeItem <class_TreeItem>` Objects.

   - **Advantages:** Simplifying one's API to smaller scoped objects helps improve
     its accessibility and improve iteration time. Rather than working with the
     entire Node library, one creates an abbreviated set of Objects from which
     a node can generate and manage the appropriate sub-nodes.

   .. note:: One should be careful when handling them. One can store an Object
     into a variable, but these references can become invalid without warning.
     For example, if the object's creator decides to delete it out of nowhere,
     this would trigger an error state when one next accesses it.

2. :ref:`Reference <class_Reference>`: Only a little more complex than Object.
   They track references to themselves, only deleting loaded memory when no
   further references to themselves exist. These are useful in the majority of
   cases where one needs data in a custom class.

   - **Example:** See the :ref:`File <class_File>` object. It functions
     just like a regular Object except that one need not delete it themselves.

   - **Advantages:** same as the Object.

3. :ref:`Resource <class_Resource>`: Only slightly more complex than Reference.
   They have the innate ability to serialize/deserialize (i.e. save and load)
   their object properties to/from Godot resource files.

   - **Example:** Scripts, PackedScene (for scene files), and other types like
     each of the :ref:`AudioEffect <class_AudioEffect>` classes. Each of these
     can be save and loaded, therefore they extend from Resource.

   - **Advantages:** Much has
     :ref:`already been said <doc_resources>`
     on :ref:`Resource <class_Resource>`'s advantages over traditional data
     storage methods. In the context of using Resources over Nodes though,
     their main advantage is in Inspector-compatibility. While nearly as
     lightweight as Object/Reference, they can still display and export
     properties in the Inspector. This allows them to fulfill a purpose much
     like sub-Nodes on the usability front, but also improve performance if
     one plans to have many such Resources/Nodes in their scenes.


===================================================
/. ./tutorials/best_practices/godot_interfaces.rst
===================================================

.. _doc_godot_interfaces:

Godot interfaces
================

Often one needs scripts that rely on other objects for features. There
are 2 parts to this process:

1. Acquiring a reference to the object that presumably has the features.

2. Accessing the data or logic from the object.

The rest of this tutorial outlines the various ways of doing all this.

Acquiring object references
---------------------------

For all :ref:`Object <class_Object>`\s, the most basic way of referencing them
is to get a reference to an existing object from another acquired instance.

.. tabs::
  .. code-tab:: gdscript GDScript

    var obj = node.object # Property access.
    var obj = node.get_object() # Method access.

  .. code-tab:: csharp

    Object obj = node.Object; // Property access.
    Object obj = node.GetObject(); // Method access.

The same principle applies for :ref:`Reference <class_Reference>` objects.
While users often access :ref:`Node <class_Node>` and
:ref:`Resource <class_Resource>` this way, alternative measures are available.

Instead of property or method access, one can get Resources by load
access.

.. tabs::
  .. code-tab:: gdscript GDScript

    var preres = preload(path) # Load resource during scene load
    var res = load(path) # Load resource when program reaches statement

    # Note that users load scenes and scripts, by convention, with PascalCase
    # names (like typenames), often into constants.
    const MyScene : = preload("my_scene.tscn") as PackedScene # Static load
    const MyScript : = preload("my_script.gd") as Script

    # This type's value varies, i.e. it is a variable, so it uses snake_case.
    export(Script) var script_type: Script

    # If need an "export const var" (which doesn't exist), use a conditional
    # setter for a tool script that checks if it's executing in the editor.
    tool # Must place at top of file.

    # Must configure from the editor, defaults to null.
    export(Script) var const_script setget set_const_script
    func set_const_script(value):
        if Engine.is_editor_hint():
            const_script = value

    # Warn users if the value hasn't been set.
    func _get_configuration_warning():
        if not const_script:
            return "Must initialize property 'const_script'."
        return ""

  .. code-tab:: csharp

    // Tool script added for the sake of the "const [Export]" example.
    [Tool]
    public MyType
    {
        // Property initializations load during Script instancing, i.e. .new().
        // No "preload" loads during scene load exists in C#.

        // Initialize with a value. Editable at runtime.
        public Script MyScript = GD.Load<Script>("MyScript.cs");

        // Initialize with same value. Value cannot be changed.
        public readonly Script MyConstScript = GD.Load<Script>("MyScript.cs");

        // Like 'readonly' due to inaccessible setter.
        // But, value can be set during constructor, i.e. MyType().
        public Script Library { get; } = GD.Load<Script>("res://addons/plugin/library.gd");

        // If need a "const [Export]" (which doesn't exist), use a
        // conditional setter for a tool script that checks if it's executing
        // in the editor.
        private PackedScene _enemyScn;

        [Export]
        public PackedScene EnemyScn
        {
            get { return _enemyScn; }
            set
            {
                if (Engine.IsEditorHint())
                {
                    _enemyScn = value;
                }
            }
        };

        // Warn users if the value hasn't been set.
        public String _GetConfigurationWarning()
        {
            if (EnemyScn == null)
                return "Must initialize property 'EnemyScn'.";
            return "";
        }
    }

Note the following:

1. There are many ways in which a language can load such resources.

2. When designing how objects will access data, don't forget
   that one can pass resources around as references as well.

3. Keep in mind that loading a resource fetches the cached resource
   instance maintained by the engine. To get a new object, one must
   :ref:`duplicate <class_Resource_method_duplicate>` an existing reference
   or instantiate one from scratch with ``new()``.

Nodes likewise have an alternative access point: the SceneTree.

.. tabs::
  .. code-tab:: gdscript GDScript

    extends Node

    # Slow.
    func dynamic_lookup_with_dynamic_nodepath():
        print(get_node("Child"))

    # Faster. GDScript only.
    func dynamic_lookup_with_cached_nodepath():
        print($Child)

    # Fastest. Doesn't break if node moves later.
    # Note that `onready` keyword is GDScript only.
    # Other languages must do...
    #     var child
    #     func _ready():
    #         child = get_node("Child")
    onready var child = $Child
    func lookup_and_cache_for_future_access():
        print(child)

    # Delegate reference assignment to an external source.
    # Con: need to perform a validation check.
    # Pro: node makes no requirements of its external structure.
    #      'prop' can come from anywhere.
    var prop
    func call_me_after_prop_is_initialized_by_parent():
        # Validate prop in one of three ways.

        # Fail with no notification.
        if not prop:
            return

        # Fail with an error message.
        if not prop:
            printerr("'prop' wasn't initialized")
            return

        # Fail and terminate.
        # Note: Scripts run from a release export template don't
        # run `assert` statements.
        assert(prop, "'prop' wasn't initialized")

    # Use an autoload.
    # Dangerous for typical nodes, but useful for true singleton nodes
    # that manage their own data and don't interfere with other objects.
    func reference_a_global_autoloaded_variable():
        print(globals)
        print(globals.prop)
        print(globals.my_getter())

  .. code-tab:: csharp

    public class MyNode
    {
        // Slow
        public void DynamicLookupWithDynamicNodePath()
        {
            GD.Print(GetNode(NodePath("Child")));
        }

        // Fastest. Lookup node and cache for future access.
        // Doesn't break if node moves later.
        public Node Child;
        public void _Ready()
        {
            Child = GetNode(NodePath("Child"));
        }
        public void LookupAndCacheForFutureAccess()
        {
            GD.Print(Child);
        }

        // Delegate reference assignment to an external source.
        // Con: need to perform a validation check.
        // Pro: node makes no requirements of its external structure.
        //      'prop' can come from anywhere.
        public object Prop;
        public void CallMeAfterPropIsInitializedByParent()
        {
            // Validate prop in one of three ways.

            // Fail with no notification.
            if (prop == null)
            {
                return;
            }

            // Fail with an error message.
            if (prop == null)
            {
                GD.PrintErr("'Prop' wasn't initialized");
                return;
            }

            // Fail and terminate.
            Debug.Assert(Prop, "'Prop' wasn't initialized");
        }

        // Use an autoload.
        // Dangerous for typical nodes, but useful for true singleton nodes
        // that manage their own data and don't interfere with other objects.
        public void ReferenceAGlobalAutoloadedVariable()
        {
            Node globals = GetNode(NodePath("/root/Globals"));
            GD.Print(globals);
            GD.Print(globals.prop);
            GD.Print(globals.my_getter());
        }
    };

.. _doc_accessing_data_or_logic_from_object:

Accessing data or logic from an object
--------------------------------------

Godot's scripting API is duck-typed. This means that if a script executes an
operation, Godot doesn't validate that it supports the operation by **type**.
It instead checks that the object **implements** the individual method.

For example, the :ref:`CanvasItem <class_CanvasItem>` class has a ``visible``
property. All properties exposed to the scripting API are in fact a setter and
getter pair bound to a name. If one tried to access
:ref:`CanvasItem.visible <class_CanvasItem_property_visible>`, then Godot would do the
following checks, in order:

- If the object has a script attached, it will attempt to set the property
  through the script. This leaves open the opportunity for scripts to override
  a property defined on a base object by overriding the setter method for the
  property.

- If the script does not have the property, it performs a HashMap lookup in
  the ClassDB for the "visible" property against the CanvasItem class and all
  of its inherited types. If found, it will call the bound setter or getter.
  For more information about HashMaps, see the
  :ref:`data preferences <doc_data_preferences>` docs.

- If not found, it does an explicit check to see if the user wants to access
  the "script" or "meta" properties.

- If not, it checks for a ``_set``/``_get`` implementation (depending on type
  of access) in the CanvasItem and its inherited types. These methods can
  execute logic that gives the impression that the Object has a property. This
  is also the case with the ``_get_property_list`` method.

  - Note that this happens even for non-legal symbol names such as in the
    case of :ref:`TileSet <class_TileSet>`'s "1/tile_name" property. This
    refers to the name of the tile with ID 1, i.e.
    :ref:`TileSet.tile_get_name(1) <class_TileSet_method_tile_get_name>`.

As a result, this duck-typed system can locate a property either in the script,
the object's class, or any class that object inherits, but only for things
which extend Object.

Godot provides a variety of options for performing runtime checks on these
accesses:

- A duck-typed property access. These will property check (as described above).
  If the operation isn't supported by the object, execution will halt.

  .. tabs::
    .. code-tab:: gdscript GDScript

      # All Objects have duck-typed get, set, and call wrapper methods.
      get_parent().set("visible", false)

      # Using a symbol accessor, rather than a string in the method call,
      # will implicitly call the `set` method which, in turn, calls the
      # setter method bound to the property through the property lookup
      # sequence.
      get_parent().visible = false

      # Note that if one defines a _set and _get that describe a property's
      # existence, but the property isn't recognized in any _get_property_list
      # method, then the set() and get() methods will work, but the symbol
      # access will claim it can't find the property.

    .. code-tab:: csharp

      // All Objects have duck-typed Get, Set, and Call wrapper methods.
      GetParent().Set("visible", false);

      // C# is a static language, so it has no dynamic symbol access, e.g.
      // `GetParent().Visible = false` won't work.

- A method check. In the case of
  :ref:`CanvasItem.visible <class_CanvasItem_property_visible>`, one can
  access the methods, ``set_visible`` and ``is_visible`` like any other method.

  .. tabs::
    .. code-tab:: gdscript GDScript

      var child = get_child(0)

      # Dynamic lookup.
      child.call("set_visible", false)

      # Symbol-based dynamic lookup.
      # GDScript aliases this into a 'call' method behind the scenes.
      child.set_visible(false)

      # Dynamic lookup, checks for method existence first.
      if child.has_method("set_visible"):
          child.set_visible(false)

      # Cast check, followed by dynamic lookup.
      # Useful when you make multiple "safe" calls knowing that the class
      # implements them all. No need for repeated checks.
      # Tricky if one executes a cast check for a user-defined type as it
      # forces more dependencies.
      if child is CanvasItem:
          child.set_visible(false)
          child.show_on_top = true

      # If one does not wish to fail these checks without notifying users,
      # one can use an assert instead. These will trigger runtime errors
      # immediately if not true.
      assert(child.has_method("set_visible"))
      assert(child.is_in_group("offer"))
      assert(child is CanvasItem)

      # Can also use object labels to imply an interface, i.e. assume it
      # implements certain methods.
      # There are two types, both of which only exist for Nodes: Names and
      # Groups.

      # Assuming...
      # A "Quest" object exists and 1) that it can "complete" or "fail" and
      # that it will have text available before and after each state...

      # 1. Use a name.
      var quest = $Quest
      print(quest.text)
      quest.complete() # or quest.fail()
      print(quest.text) # implied new text content

      # 2. Use a group.
      for a_child in get_children():
          if a_child.is_in_group("quest"):
              print(quest.text)
              quest.complete() # or quest.fail()
              print(quest.text) # implied new text content

      # Note that these interfaces are project-specific conventions the team
      # defines (which means documentation! But maybe worth it?).
      # Any script that conforms to the documented "interface" of the name or
      # group can fill in for it.

    .. code-tab:: csharp

      Node child = GetChild(0);

      // Dynamic lookup.
      child.Call("SetVisible", false);

      // Dynamic lookup, checks for method existence first.
      if (child.HasMethod("SetVisible"))
      {
          child.Call("SetVisible", false);
      }

      // Use a group as if it were an "interface", i.e. assume it implements
      // certain methods.
      // Requires good documentation for the project to keep it reliable
      // (unless you make editor tools to enforce it at editor time).
      // Note, this is generally not as good as using an actual interface in
      // C#, but you can't set C# interfaces from the editor since they are
      // language-level features.
      if (child.IsInGroup("Offer"))
      {
          child.Call("Accept");
          child.Call("Reject");
      }

      // Cast check, followed by static lookup.
      CanvasItem ci = GetParent() as CanvasItem;
      if (ci != null)
      {
          ci.SetVisible(false);

          // useful when you need to make multiple safe calls to the class
          ci.ShowOnTop = true;
      }

      // If one does not wish to fail these checks without notifying users,
      // one can use an assert instead. These will trigger runtime errors
      // immediately if not true.
      Debug.Assert(child.HasMethod("set_visible"));
      Debug.Assert(child.IsInGroup("offer"));
      Debug.Assert(CanvasItem.InstanceHas(child));

      // Can also use object labels to imply an interface, i.e. assume it
      // implements certain methods.
      // There are two types, both of which only exist for Nodes: Names and
      // Groups.

      // Assuming...
      // A "Quest" object exists and 1) that it can "Complete" or "Fail" and
      // that it will have Text available before and after each state...

      // 1. Use a name.
      Node quest = GetNode("Quest");
      GD.Print(quest.Get("Text"));
      quest.Call("Complete"); // or "Fail".
      GD.Print(quest.Get("Text")); // Implied new text content.

      // 2. Use a group.
      foreach (Node AChild in GetChildren())
      {
          if (AChild.IsInGroup("quest"))
          {
            GD.Print(quest.Get("Text"));
            quest.Call("Complete"); // or "Fail".
            GD.Print(quest.Get("Text")); // Implied new text content.
          }
      }

      // Note that these interfaces are project-specific conventions the team
      // defines (which means documentation! But maybe worth it?).
      // Any script that conforms to the documented "interface" of the
      // name or group can fill in for it. Also note that in C#, these methods
      // will be slower than static accesses with traditional interfaces.

- Outsource the access to a :ref:`FuncRef <class_FuncRef>`. These may be useful
  in cases where one needs the max level of freedom from dependencies. In
  this case, one relies on an external context to setup the method.

.. tabs::
  .. code-tab:: gdscript GDScript

    # child.gd
    extends Node
    var fn = null

    func my_method():
        if fn:
            fn.call_func()

    # parent.gd
    extends Node

    onready var child = $Child

    func _ready():
        child.fn = funcref(self, "print_me")
        child.my_method()

    func print_me():
        print(name)

  .. code-tab:: csharp

    // Child.cs
    public class Child : Node
    {
        public FuncRef FN = null;

        public void MyMethod()
        {
            Debug.Assert(FN != null);
            FN.CallFunc();
        }
    }

    // Parent.cs
    public class Parent : Node
    {
        public Node Child;

        public void _Ready()
        {
            Child = GetNode("Child");
            Child.Set("FN", GD.FuncRef(this, "PrintMe"));
            Child.MyMethod();
        }

        public void PrintMe() {
        {
            GD.Print(GetClass());
        }
    }

These strategies contribute to Godot's flexible design. Between them, users
have a breadth of tools to meet their specific needs.


===================================================
/. ./tutorials/best_practices/godot_notifications.rst
===================================================

.. _doc_godot_notifications:

Godot notifications
===================

Every Object in Godot implements a
:ref:`_notification <class_Object_method__notification>` method. Its purpose is to
allow the Object to respond to a variety of engine-level callbacks that may
relate to it. For example, if the engine tells a
:ref:`CanvasItem <class_CanvasItem>` to "draw", it will call
``_notification(NOTIFICATION_DRAW)``.

Some of these notifications, like draw, are useful to override in scripts. So
much so that Godot exposes many of them with dedicated functions:

- ``_ready()`` : NOTIFICATION_READY

- ``_enter_tree()`` : NOTIFICATION_ENTER_TREE

- ``_exit_tree()`` : NOTIFICATION_EXIT_TREE

- ``_process(delta)`` : NOTIFICATION_PROCESS

- ``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS

- ``_draw()`` : NOTIFICATION_DRAW

What users might *not* realize is that notifications exist for types other
than Node alone:

- :ref:`Object::NOTIFICATION_POSTINITIALIZE <class_Object_constant_NOTIFICATION_POSTINITIALIZE>`:
  a callback that triggers during object initialization. Not accessible to scripts.

- :ref:`Object::NOTIFICATION_PREDELETE <class_Object_constant_NOTIFICATION_PREDELETE>`:
  a callback that triggers before the engine deletes an Object, i.e. a
  'destructor'.

- :ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER <class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`:
  a callback that triggers when the mouse enters the window in the operating
  system that displays the game content.

And many of the callbacks that *do* exist in Nodes don't have any dedicated
methods, but are still quite useful.

- :ref:`Node::NOTIFICATION_PARENTED <class_Node_constant_NOTIFICATION_PARENTED>`:
  a callback that triggers anytime one adds a child node to another node.

- :ref:`Node::NOTIFICATION_UNPARENTED <class_Node_constant_NOTIFICATION_UNPARENTED>`:
  a callback that triggers anytime one removes a child node from another
  node.

- :ref:`Popup::NOTIFICATION_POST_POPUP <class_Popup_constant_NOTIFICATION_POST_POPUP>`:
  a callback that triggers after a Popup node completes any ``popup*`` method.
  Note the difference from its ``about_to_show`` signal which triggers
  *before* its appearance.

One can access all these custom notifications from the universal
``_notification`` method.

.. note::
  Methods in the documentation labeled as "virtual" are also intended to be
  overridden by scripts.

  A classic example is the
  :ref:`_init <class_Object_method__init>` method in Object. While it has no
  ``NOTIFICATION_*`` equivalent, the engine still calls the method. Most languages
  (except C#) rely on it as a constructor.

So, in which situation should one use each of these notifications or
virtual functions?

_process vs. _physics_process vs. \*_input
------------------------------------------

Use ``_process`` when one needs a framerate-dependent deltatime between
frames. If code that updates object data needs to update as often as
possible, this is the right place. Recurring logic checks and data caching
often execute here, but it comes down to the frequency at which one needs
the evaluations to update. If they don't need to execute every frame, then
implementing a Timer-yield-timeout loop is another option.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Infinitely loop, but only execute whenever the Timer fires.
    # Allows for recurring operations that don't trigger script logic
    # every frame (or even every fixed frame).
    while true:
        my_method()
        $Timer.start()
        yield($Timer, "timeout")

Use ``_physics_process`` when one needs a framerate-independent deltatime
between frames. If code needs consistent updates over time, regardless
of how fast or slow time advances, this is the right place.
Recurring kinematic and object transform operations should execute here.

While it is possible, to achieve the best performance, one should avoid
making input checks during these callbacks. ``_process`` and
``_physics_process`` will trigger at every opportunity (they do not "rest" by
default). In contrast, ``*_input`` callbacks will trigger only on frames in
which the engine has actually detected the input.

One can check for input actions within the input callbacks just the same.
If one wants to use delta time, one can fetch it from the related
deltatime methods as needed.

.. tabs::
  .. code-tab:: gdscript GDScript

    # Called every frame, even when the engine detects no input.
    func _process(delta):
        if Input.is_action_just_pressed("ui_select"):
            print(delta)

    # Called during every input event.
    func _unhandled_input(event):
        match event.get_class():
            "InputEventKey":
                if Input.is_action_just_pressed("ui_accept"):
                    print(get_process_delta_time())

  .. code-tab:: csharp

    public class MyNode : Node
    {

        // Called every frame, even when the engine detects no input.
        public void _Process(float delta)
        {
            if (Input.IsActionJustPressed("ui_select"))
                GD.Print(delta);
        }

        // Called during every input event. Equally true for _input().
        public void _UnhandledInput(InputEvent event)
        {
            switch (event)
            {
                case InputEventKey keyEvent:
                    if (Input.IsActionJustPressed("ui_accept"))
                        GD.Print(GetProcessDeltaTime());
                    break;
                default:
                    break;
            }
        }

    }

_init vs. initialization vs. export
-----------------------------------

If the script initializes its own node subtree, without a scene,
that code should execute here. Other property or SceneTree-independent
initializations should also run here. This triggers before ``_ready`` or
``_enter_tree``, but after a script creates and initializes its properties.

Scripts have three types of property assignments that can occur during
instantiation:

.. tabs::
  .. code-tab:: gdscript GDScript

    # "one" is an "initialized value". These DO NOT trigger the setter.
    # If someone set the value as "two" from the Inspector, this would be an
    # "exported value". These DO trigger the setter.
    export(String) var test = "one" setget set_test

    func _init():
        # "three" is an "init assignment value".
        # These DO NOT trigger the setter, but...
        test = "three"
        # These DO trigger the setter. Note the `self` prefix.
        self.test = "three"

    func set_test(value):
        test = value
        print("Setting: ", test)

  .. code-tab:: csharp

    public class MyNode : Node
    {
        private string _test = "one";

        // Changing the value from the inspector does trigger the setter in C#.
        [Export]
        public string Test
        {
            get { return _test; }
            set
            {
                _test = value;
                GD.Print("Setting: " + _test);
            }
        }

        public MyNode()
        {
            // Triggers the setter as well
            Test = "three";
        }
    }

When instantiating a scene, property values will set up according to the
following sequence:

1. **Initial value assignment:** instantiation will assign either the
   initialization value or the init assignment value. Init assignments take
   priority over initialization values.

2. **Exported value assignment:** If instancing from a scene rather than
   a script, Godot will assign the exported value to replace the initial
   value defined in the script.

As a result, instantiating a script versus a scene will affect both the
initialization *and* the number of times the engine calls the setter.

_ready vs. _enter_tree vs. NOTIFICATION_PARENTED
------------------------------------------------

When instantiating a scene connected to the first executed scene, Godot will
instantiate nodes down the tree (making ``_init`` calls) and build the tree
going downwards from the root. This causes ``_enter_tree`` calls to cascade
down the tree. Once the tree is complete, leaf nodes call ``_ready``. A node
will call this method once all child nodes have finished calling theirs. This
then causes a reverse cascade going up back to the tree's root.

When instantiating a script or a standalone scene, nodes are not
added to the SceneTree upon creation, so no ``_enter_tree`` callbacks
trigger. Instead, only the ``_init`` call occurs. When the scene is added
to the SceneTree, the ``_enter_tree`` and ``_ready`` calls occur.

If one needs to trigger behavior that occurs as nodes parent to another,
regardless of whether it occurs as part of the main/active scene or not, one
can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` notification.
For example, here is a snippet that connects a node's method to
a custom signal on the parent node without failing. Useful on data-centric
nodes that one might create at runtime.

.. tabs::
  .. code-tab:: gdscript GDScript

    extends Node

    var parent_cache

    func connection_check():
        return parent.has_user_signal("interacted_with")

    func _notification(what):
        match what:
            NOTIFICATION_PARENTED:
                parent_cache = get_parent()
                if connection_check():
                    parent_cache.connect("interacted_with", self, "_on_parent_interacted_with")
            NOTIFICATION_UNPARENTED:
                if connection_check():
                    parent_cache.disconnect("interacted_with", self, "_on_parent_interacted_with")

    func _on_parent_interacted_with():
        print("I'm reacting to my parent's interaction!")

  .. code-tab:: csharp

    public class MyNode : Node
    {
        public Node ParentCache = null;

        public void ConnectionCheck()
        {
            return ParentCache.HasUserSignal("InteractedWith");
        }

        public void _Notification(int what)
        {
            switch (what)
            {
                case NOTIFICATION_PARENTED:
                    ParentCache = GetParent();
                    if (ConnectionCheck())
                        ParentCache.Connect("InteractedWith", this, "OnParentInteractedWith");
                    break;
                case NOTIFICATION_UNPARENTED:
                    if (ConnectionCheck())
                        ParentCache.Disconnect("InteractedWith", this, "OnParentInteractedWith");
                    break;
            }
        }

        public void OnParentInteractedWith()
        {
            GD.Print("I'm reacting to my parent's interaction!");
        }
    }


===================================================
/. ./tutorials/best_practices/data_preferences.rst
===================================================

.. _doc_data_preferences:

Data preferences
================

Ever wondered whether one should approach problem X with data structure
Y or Z? This article covers a variety of topics related to these dilemmas.

.. note::

  This article makes references to "[something]-time" operations. This
  terminology comes from algorithm analysis'
  `Big O Notation <https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/>`_.

  Long-story short, it describes the worst-case scenario of runtime length.
  In laymen's terms:

  "As the size of a problem domain increases, the runtime length of the
  algorithm..."

  - Constant-time, ``O(1)``: "...does not increase."
  - Logarithmic-time, ``O(log n)``: "...increases at a slow rate."
  - Linear-time, ``O(n)``: "...increases at the same rate."
  - Etc.

  Imagine if one had to process 3 million data points within a single frame. It
  would be impossible to craft the feature with a linear-time algorithm since
  the sheer size of the data would increase the runtime far beyond the time allotted.
  In comparison, using a constant-time algorithm could handle the operation without
  issue.

  By and large, developers want to avoid engaging in linear-time operations as
  much as possible. But, if one keeps the scale of a linear-time operation
  small, and if one does not need to perform the operation often, then it may
  be acceptable. Balancing these requirements and choosing the right
  algorithm / data structure for the job is part of what makes programmers'
  skills valuable.

Array vs. Dictionary vs. Object
-------------------------------

Godot stores all variables in the scripting API in the
:ref:`Variant <doc_variant_class>` class.
class. Variants can store Variant-compatible data structures such as
:ref:`Array <class_Array>` and :ref:`Dictionary <class_Dictionary>` as well as
:ref:`Object <class_Object>` s.

Godot implements Array as a ``Vector<Variant>``. The engine stores the Array
contents in a contiguous section of memory, i.e. they are in a row adjacent
to each other.

.. note::
  For those unfamiliar with C++, a Vector is the name of the
  array object in traditional C++ libraries. It is a "templated"
  type, meaning that its records can only contain a particular type (denoted
  by angled brackets). So, for example, a
  :ref:`PoolStringArray <class_PoolStringArray>` would be something like
  a ``Vector<String>``.

Contiguous memory stores imply the following operation performance:

- **Iterate:** Fastest. Great for loops.

    - Op: All it does is increment a counter to get to the next record.

- **Insert, Erase, Move:** Position-dependent. Generally slow.

    - Op: Adding/removing/moving content involves moving the adjacent records
      over (to make room / fill space).

    - Fast add/remove *from the end*.

    - Slow add/remove *from an arbitrary position*.

    - Slowest add/remove *from the front*.

    - If doing many inserts/removals *from the front*, then...

        1. invert the array.

        2. do a loop which executes the Array changes *at the end*.

        3. re-invert the array.

      This makes only 2 copies of the array (still constant time, but slow)
      versus copying roughly 1/2 of the array, on average, N times (linear time).

- **Get, Set:** Fastest *by position*. E.g. can request 0th, 2nd, 10th record, etc.
  but cannot specify which record you want.

    - Op: 1 addition operation from array start position up to desired index.

- **Find:** Slowest. Identifies the index/position of a value.

    - Op: Must iterate through array and compare values until one finds a match.

        - Performance is also dependent on whether one needs an exhaustive
          search.

    - If kept ordered, custom search operations can bring it to logarithmic
      time (relatively fast). Laymen users won't be comfortable with this
      though. Done by re-sorting the Array after every edit and writing an
      ordered-aware search algorithm.

Godot implements Dictionary as an ``OrderedHashMap<Variant, Variant>``. The engine
stores a small array (initialized to 2^3 or 8 records) of key-value pairs. When
one attempts to access a value, they provide it a key. It then *hashes* the
key, i.e. converts it into a number. The "hash" is used to calculate the index
into the array. As an array, the OHM then has a quick lookup within the "table"
of keys mapped to values. When the HashMap becomes too full, it increases to
the next power of 2 (so, 16 records, then 32, etc.) and rebuilds the structure.

Hashes are to reduce the chance of a key collision. If one occurs, the table
must recalculate another index for the value that takes the previous position
into account. In all, this results in constant-time access to all records at
the expense of memory and some minor operational efficiency.

1. Hashing every key an arbitrary number of times.

    - Hash operations are constant-time, so even if an algorithm must do more
      than one, as long as the number of hash calculations doesn't become
      too dependent on the density of the table, things will stay fast.
      Which leads to...

2. Maintaining an ever-growing size for the table.

    - HashMaps maintain gaps of unused memory interspersed in the table
      on purpose to reduce hash collisions and maintain the speed of
      accesses. This is why it constantly increases in size quadratically by
      powers of 2.

As one might be able to tell, Dictionaries specialize in tasks that Arrays
do not. An overview of their operational details is as follows:

- **Iterate:** Fast.

    - Op: Iterate over the map's internal vector of hashes. Return each key.
      Afterwards, users then use the key to jump to and return the desired
      value.

- **Insert, Erase, Move:** Fastest.

    - Op: Hash the given key. Do 1 addition operation to look up the
      appropriate value (array start + offset). Move is two of these
      (one insert, one erase). The map must do some maintenance to preserve
      its capabilities:

        - update ordered List of records.

        - determine if table density mandates a need to expand table capacity.

    - The Dictionary remembers in what
      order users inserted its keys. This enables it to execute reliable iterations.

- **Get, Set:** Fastest. Same as a lookup *by key*.

    - Op: Same as insert/erase/move.

- **Find:** Slowest. Identifies the key of a value.

    - Op: Must iterate through records and compare the value until a match is
      found.

    - Note that Godot does not provide this feature out-of-the-box (because
      they aren't meant for this task).

Godot implements Objects as stupid, but dynamic containers of data content.
Objects query data sources when posed questions. For example, to answer
the question, "do you have a property called, 'position'?", it might ask
its :ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`.
One can find more information about what objects are and how they work in
the :ref:`doc_what_are_godot_classes` article.

The important detail here is the complexity of the Object's task. Every time
it performs one of these multi-source queries, it runs through *several*
iteration loops and HashMap lookups. What's more, the queries are linear-time
operations dependent on the Object's inheritance hierarchy size. If the class
the Object queries (its current class) doesn't find anything, the request
defers to the next base class, all the way up until the original Object class.
While these are each fast operations in isolation, the fact that it must make
so many checks is what makes them slower than both of the alternatives for
looking up data.

.. note::

  When developers mention how slow the scripting API is, it is this chain
  of queries they refer to. Compared to compiled C++ code where the
  application knows exactly where to go to find anything, it is inevitable
  that scripting API operations will take much longer. They must locate the
  source of any relevant data before they can attempt to access it.

  The reason GDScript is slow is because every operation it performs passes
  through this system.

  C# can process some content at higher speeds via more optimized bytecode.
  But, if the C# script calls into an engine class'
  content or if the script tries to access something external to it, it will
  go through this pipeline.

  NativeScript C++ goes even further and keeps everything internal by default.
  Calls into external structures will go through the scripting API. In
  NativeScript C++, registering methods to expose them to the scripting API is
  a manual task. It is at this point that external, non-C++ classes will use
  the API to locate them.

So, assuming one extends from Reference to create a data structure, like
an Array or Dictionary, why choose an Object over the other two options?

1. **Control:** With objects comes the ability to create more sophisticated
   structures. One can layer abstractions over the data to ensure the external
   API doesn't change in response to internal data structure changes. What's
   more, Objects can have signals, allowing for reactive behavior.

2. **Clarity:** Objects are a reliable data source when it comes to the data
   that scripts and engine classes define for them. Properties may not hold the
   values one expects, but one doesn't need to worry about whether the property
   exists in the first place.

3. **Convenience:** If one already has a similar data structure in mind, then
   extending from an existing class makes the task of building the data
   structure much easier. In comparison, Arrays and Dictionaries don't
   fulfill all use cases one might have.

Objects also give users the opportunity to create even more specialized data
structures. With it, one can design their own List, Binary Search Tree, Heap,
Splay Tree, Graph, Disjoint Set, and any host of other options.

"Why not use Node for tree structures?" one might ask. Well, the Node
class contains things that won't be relevant to one's custom data structure.
As such, it can be helpful to construct one's own node type when building
tree structures.

.. tabs::
  .. code-tab:: gdscript GDScript

    extends Object
    class_name TreeNode

    var _parent : TreeNode = null
    var _children : = [] setget

    func _notification(p_what):
        match p_what:
            NOTIFICATION_PREDELETE:
                # Destructor.
                for a_child in _children:
                    a_child.free()

  .. code-tab:: csharp

    // Can decide whether to expose getters/setters for properties later
    public class TreeNode : Object
    {
        private TreeNode _parent = null;

        private object[] _children = new object[0];

        public override void Notification(int what)
        {
            switch (what)
            {
                case NotificationPredelete:
                    foreach (object child in _children)
                    {
                        TreeNode node = child as TreeNode;
                        if (node != null)
                            node.Free();
                    }
                    break;
                default:
                    break;
            }
        }
    }

From here, one can then create their own structures with specific features,
limited only by their imagination.

Enumerations: int vs. string
----------------------------

Most languages offer an enumeration type option. GDScript is no different, but
unlike most other languages, it allows one to use either integers or strings for
the enum values (the latter only when using the ``export`` keyword in GDScript).
The question then arises, "which should one use?"

The short answer is, "whichever you are more comfortable with." This
is a feature specific to GDScript and not Godot scripting in general;
The languages prioritizes usability over performance.

On a technical level, integer comparisons (constant-time) will happen
faster than string comparisons (linear-time). If one wants to keep
up other languages' conventions though, then one should use integers.

The primary issue with using integers comes up when one wants to *print*
an enum value. As integers, attempting to print MY_ENUM will print
``5`` or what-have-you, rather than something like ``"MyEnum"``. To
print an integer enum, one would have to write a Dictionary that maps the
corresponding string value for each enum.

If the primary purpose of using an enum is for printing values and one wishes
to group them together as related concepts, then it makes sense to use them as
strings. That way, a separate data structure to execute on the printing is
unnecessary.

AnimatedTexture vs. AnimatedSprite vs. AnimationPlayer vs. AnimationTree
------------------------------------------------------------------------

Under what circumstances should one use each of Godot's animation classes?
The answer may not be immediately clear to new Godot users.

:ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that
the engine draws as an animated loop rather than a static image.
Users can manipulate...

1. the rate at which it moves across each section of the texture (fps).

2. the number of regions contained within the texture (frames).

Godot's :ref:`VisualServer <class_VisualServer>` then draws
the regions in sequence at the prescribed rate. The good news is that this
involves no extra logic on the part of the engine. The bad news is
that users have very little control.

Also note that AnimatedTexture is a :ref:`Resource <class_Resource>` unlike
the other :ref:`Node <class_Node>` objects discussed here. One might create
a :ref:`Sprite <class_Sprite>` node that uses AnimatedTexture as its texture.
Or (something the others can't do) one could add AnimatedTextures as tiles
in a :ref:`TileSet <class_TileSet>` and integrate it with a
:ref:`TileMap <class_TileMap>` for many auto-animating backgrounds that
all render in a single batched draw call.

The AnimatedSprite node, in combination with the
:ref:`SpriteFrames <class_SpriteFrames>` resource, allows one to create a
variety of animation sequences through spritesheets, flip between animations,
and control their speed, regional offset, and orientation. This makes them
well-suited to controlling 2D frame-based animations.

If one needs trigger other effects in relation to animation changes (for
example, create particle effects, call functions, or manipulate other
peripheral elements besides the frame-based animation), then will need to use
an :ref:`AnimationPlayer <class_AnimationPlayer>` node in conjunction with
the AnimatedSprite.

AnimationPlayers are also the tool one will need to use if they wish to design
more complex 2D animation systems, such as...

1. **Cut-Out animations:** editing sprites' transforms at runtime.

2. **2D Mesh animations:** defining a region for the sprite's texture and
   rigging a skeleton to it. Then one animates the bones which
   stretch and bend the texture in proportion to the bones' relationships to
   each other.

3. A mix of the above.

While one needs an AnimationPlayer to design each of the individual
animation sequences for a game, it can also be useful to combine animations
for blending, i.e. enabling smooth transitions between these animations. There
may also be a hierarchical structure between animations that one plans out for
their object. These are the cases where the :ref:`AnimationTree <class_AnimationTree>`
shines. One can find an in-depth guide on using the AnimationTree
:ref:`here <doc_animation_tree>`.


===================================================
/. ./tutorials/best_practices/logic_preferences.rst
===================================================

.. _doc_logic_preferences:

Logic preferences
=================

Ever wondered whether one should approach problem X with strategy Y or Z?
This article covers a variety of topics related to these dilemmas.

Loading vs. preloading
----------------------

In GDScript, there exists the global
:ref:`preload <class_@GDScript_method_preload>` method. It loads resources as
early as possible to front-load the "loading" operations and avoid loading
resources while in the middle of performance-sensitive code.

Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads a
resource only when it reaches the load statement. That is, it will load a
resource in-place which can cause slowdowns when it occurs in the middle of
sensitive processes. The ``load`` function is also an alias for
:ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` which is
accessible to *all* scripting languages.

So, when exactly does preloading occur versus loading, and when should one use
either? Let's see an example:

.. tabs::
  .. code-tab:: gdscript GDScript

    # my_buildings.gd
    extends Node

    # Note how constant scripts/scenes have a different naming scheme than
    # their property variants.

    # This value is a constant, so it spawns when the Script object loads.
    # The script is preloading the value. The advantage here is that the editor
    # can offer autocompletion since it must be a static path.
    const BuildingScn = preload("res://building.tscn")

    # 1. The script preloads the value, so it will load as a dependency
    #    of the 'my_buildings.gd' script file. But, because this is a
    #    property rather than a constant, the object won't copy the preloaded
    #    PackedScene resource into the property until the script instantiates
    #    with .new().
    #
    # 2. The preloaded value is inaccessible from the Script object alone. As
    #    such, preloading the value here actually does not benefit anyone.
    #
    # 3. Because the user exports the value, if this script stored on
    #    a node in a scene file, the scene instantiation code will overwrite the
    #    preloaded initial value anyway (wasting it). It's usually better to
    #    provide null, empty, or otherwise invalid default values for exports.
    #
    # 4. It is when one instantiates this script on its own with .new() that
    #    one will load "office.tscn" rather than the exported value.
    export(PackedScene) var a_building = preload("office.tscn")

    # Uh oh! This results in an error!
    # One must assign constant values to constants. Because `load` performs a
    # runtime lookup by its very nature, one cannot use it to initialize a
    # constant.
    const OfficeScn = load("res://office.tscn")

    # Successfully loads and only when one instantiates the script! Yay!
    var office_scn = load("res://office.tscn")

  .. code-tab:: csharp

    using System;
    using Godot;

    // C# and other languages have no concept of "preloading".
    public class MyBuildings : Node
    {
        //This is a read-only field, it can only be assigned when it's declared or during a constructor.
        public readonly PackedScene Building = ResourceLoader.Load<PackedScene>("res://building.tscn");

        public PackedScene ABuilding;

        public override void _Ready()
        {
            // Can assign the value during initialization.
            ABuilding = GD.Load<PackedScene>("res://office.tscn");
        }
    }

Preloading allows the script to handle all the loading the moment one loads the
script. Preloading is useful, but there are also times when one doesn't wish
for it. To distinguish these situations, there are a few things one can
consider:

1. If one cannot determine when the script might load, then preloading a
   resource, especially a scene or script, could result in further loads one
   does not expect. This could lead to unintentional, variable-length
   load times on top of the original script's load operations.

2. If something else could replace the value (like a scene's exported
   initialization), then preloading the value has no meaning. This point isn't
   a significant factor if one intends to always create the script on its own.

3. If one wishes only to 'import' another class resource (script or scene),
   then using a preloaded constant is often the best course of action. However,
   in exceptional cases, one may wish not to do this:

   1. If the 'imported' class is liable to change, then it should be a property
      instead, initialized either using an ``export`` or a ``load`` (and
      perhaps not even initialized until later).

   2. If the script requires a great many dependencies, and one does not wish
      to consume so much memory, then one may wish to, load and unload various
      dependencies at runtime as circumstances change. If one preloads
      resources into constants, then the only way to unload these resources
      would be to unload the entire script. If they are instead loaded
      properties, then one can set them to ``null`` and remove all references
      to the resource entirely (which, as a
      :ref:`Reference <class_Reference>`-extending type, will cause the
      resources to delete themselves from memory).

Large levels: static vs. dynamic
--------------------------------

If one is creating a large level, which circumstances are most appropriate?
Should they create the level as one static space? Or should they load the
level in pieces and shift the world's content as needed?

Well, the simple answer is , "when the performance requires it." The
dilemma associated with the two options is one of the age-old programming
choices: does one optimize memory over speed, or vice versa?

The naive answer is to use a static level that loads everything at once.
But, depending on the project, this could consume a large amount of
memory. Wasting users' RAM leads to programs running slow or outright
crashing from everything else the computer tries to do at the same time.

No matter what, one should break larger scenes into smaller ones (to aid
in reusability of assets). Developers can then design a node that manages the
creation/loading and deletion/unloading of resources and nodes in real-time.
Games with large and varied environments or procedurally generated
elements often implement these strategies to avoid wasting memory.

On the flip side, coding a dynamic system is more complex, i.e. uses more
programmed logic, which results in opportunities for errors and bugs. If one
isn't careful, they can develop a system that bloats the technical debt of
the application.

As such, the best options would be...

1. To use a static level for smaller games.

2. If one has the time/resources on a medium/large game, create a library or
   plugin that can code the management of nodes and resources. If refined
   over time, so as to improve usability and stability, then it could evolve
   into a reliable tool across projects.

3. Code the dynamic logic for a medium/large game because one has the coding
   skills, but not the time or resources to refine the code (game's
   gotta get done). Could potentially refactor later to outsource the code
   into a plugin.

For an example of the various ways one can swap scenes around at runtime,
please see the :ref:`"Change scenes manually" <doc_change_scenes_manually>`
documentation.


===================================================
/. ./tutorials/best_practices/project_organization.rst
===================================================

.. _doc_project_organization:

Project organization
====================

Introduction
------------

Since Godot has no restrictions on project structure or filesystem usage,
organizing files when learning the engine can seem challenging. This
tutorial suggests a workflow which should be a good starting point.
We will also cover using version control with Godot.

Organization
------------

Godot is scene-based in nature, and uses the filesystem as-is,
without metadata or an asset database.

Unlike other engines, many resources are contained within the scene
itself, so the amount of files in the filesystem is considerably lower.

Considering that, the most common approach is to group assets as close
to scenes as possible; when a project grows, it makes it more
maintainable.

As an example, one can usually place into a single folder their basic assets,
such as sprite images, 3D model meshes, materials, and music, etc.
They can then use a separate folder to store built levels that use them.

.. code-block:: none

    /project.godot
    /docs/.gdignore  # See "Ignoring specific folders" below
    /docs/learning.html
    /models/town/house/house.dae
    /models/town/house/window.png
    /models/town/house/door.png
    /characters/player/cubio.dae
    /characters/player/cubio.png
    /characters/enemies/goblin/goblin.dae
    /characters/enemies/goblin/goblin.png
    /characters/npcs/suzanne/suzanne.dae
    /characters/npcs/suzanne/suzanne.png
    /levels/riverdale/riverdale.scn

Style guide
-----------

For consistency across projects, we recommend following these guidelines:

- Use **snake_case** for folder and file names (with the exception of C#
  scripts). This sidesteps case sensitivity issues that can crop up after
  exporting a project on Windows. C# scripts are an exception to this rule,
  as the convention is to name them after the class name which should be
  in PascalCase.
- Use **PascalCase** for node names, as this matches built-in node casing.
- In general, keep third-party resources in a top-level ``addons/`` folder, even
  if they aren't editor plugins. This makes it easier to track which files are
  third-party. There are some exceptions to this rule; for instance, if you use
  third-party game assets for a character, it makes more sense to include them
  within the same folder as the character scenes and scripts.

Importing
---------

Godot versions prior to 3.0 did the import process from files outside
the project. While this can be useful in large projects, it
resulted in an organization hassle for most developers.

Because of this, assets are now transparently imported from within the project
folder.

Ignoring specific folders
~~~~~~~~~~~~~~~~~~~~~~~~~

To prevent Godot from importing files contained in a specific folder, create
an empty file called ``.gdignore`` in the folder (the leading ``.`` is required).
This can be useful to speed up the initial project importing.

.. note::

    To create a file whose name starts with a dot on Windows, you can use a
    text editor such as Notepad++ or use the following command in a
    command prompt: ``type nul > .gdignore``

Once the folder is ignored, resources in that folder can't be loaded anymore
using the ``load()`` and ``preload()`` methods. Ignoring a folder will also
automatically hide it from the FileSystem dock, which can be useful to reduce clutter.

Note that the ``.gdignore`` file's contents are ignored, which is why the file
should be empty. It does not support patterns like ``.gitignore`` files do.

.. _doc_project_organization_case_sensitivity:

Case sensitivity
----------------

Windows and recent macOS versions use case-insensitive filesystems by default,
whereas Linux distributions use a case-sensitive filesystem by default.
This can cause issues after exporting a project, since Godot's PCK virtual
filesystem is case-sensitive. To avoid this, it's recommended to stick to
``snake_case`` naming for all files in the project (and lowercase characters
in general).

.. note::

    You can break this rule when style guides say otherwise (such as the
    C# style guide). Still, be consistent to avoid mistakes.

On Windows 10, to further avoid mistakes related to case sensitivity,
you can also make the project folder case-sensitive. After enabling the Windows
Subsystem for Linux feature, run the following command in a PowerShell window::

    # To enable case-sensitivity:
    fsutil file setcasesensitiveinfo <path to project folder> enable

    # To disable case-sensitivity:
    fsutil file setcasesensitiveinfo <path to project folder> disable

If you haven't enabled the Windows Subsystem for Linux, you can enter the
following line in a PowerShell window *running as Administrator* then reboot
when asked::

    Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux


===================================================
/. ./tutorials/best_practices/version_control_systems.rst
===================================================

.. _doc_version_control_systems:

Version Control Systems
=======================

Introduction
------------

Godot aims to be VCS friendly and generate mostly readable and mergeable files.
Godot also supports the use of version control systems in the editor itself.
However, VCS in the editor requires a plugin for the specific VCS you are using.
VCS can be setup or shut down in the editor under **Project > Version Control**.

.. image:: img/version_control_menu.png

Official Git plugin
-------------------

Using Git from inside the editor is supported with an official plugin.
You can find the latest releases
`here <https://github.com/godotengine/godot-git-plugin/releases>`__. Documentation on how to use the Git
plugin can be found
`here <https://github.com/godotengine/godot-git-plugin/wiki>`__.

Files to exclude from VCS
-------------------------

There are some folders Godot creates you should have your VCS ignore:

- ``.import/``: This folder stores all the files it imports automatically based on
  your source assets and their import flags.
- ``*.translation``: These files are binary imported translations generated from CSV files.
- ``export_presets.cfg``: This file contains all the export presets for the
  project, including sensitive information such as Android keystore credentials.
- ``.mono/``: This folder stores automatically-generated Mono files. It only exists
  in projects that use the Mono version of Godot.

Working with Git on Windows
---------------------------

Most Git for Windows clients are configured with the ``core.autocrlf`` set to ``true``.
This can lead to files unnecessarily being marked as modified by Git due to their line endings being converted automatically.
It is better to set this option as::

    git config --global core.autocrlf input


===================================================
/. ./tutorials/editor/index.rst
===================================================

Editor manual
=============

In this section, we cover the Godot editor in general, from its interface to
using it with the command line. We cover some specific editors' interface in
other sections where appropriate. For example, the :ref:`animation editor
<doc_introduction_animation>`.

.. toctree::
   :maxdepth: 1
   :name: toc-learn-editor

   command_line_tutorial
   external_editor
   default_key_mapping
   using_the_web_editor
   managing_editor_features


===================================================
/. ./tutorials/editor/command_line_tutorial.rst
===================================================

.. _doc_command_line_tutorial:

Command line tutorial
=====================

.. highlight:: shell

Some developers like using the command line extensively. Godot is
designed to be friendly to them, so here are the steps for working
entirely from the command line. Given the engine relies on almost no
external libraries, initialization times are pretty fast, making it
suitable for this workflow.

.. note::

    On Windows and Linux, you can run a Godot binary in a terminal by specifying
    its relative or absolute path.

    On macOS, the process is different due to Godot being contained within an
    ``.app`` bundle (which is a *folder*, not a file). To run a Godot binary
    from a terminal on macOS, you have to ``cd`` to the folder where the Godot
    application bundle is located, then run ``Godot.app/Contents/MacOS/Godot``
    followed by any command line arguments. If you've renamed the application
    bundle from ``Godot`` to another name, make sure to edit this command line
    accordingly.

Command line reference
----------------------

**General options**

+----------------------------+----------------------------------------------------------------------+
| Command                    | Description                                                          |
+----------------------------+----------------------------------------------------------------------+
| ``-h``, ``--help``, ``/?`` | Display the list of command line options.                            |
+----------------------------+----------------------------------------------------------------------+
| ``--version``              | Display the version string.                                          |
+----------------------------+----------------------------------------------------------------------+
| ``-v``, ``--verbose``      | Use verbose stdout mode.                                             |
+----------------------------+----------------------------------------------------------------------+
| ``--quiet``                | Quiet mode, silences stdout messages. Errors are still displayed.    |
+----------------------------+----------------------------------------------------------------------+

**Run options**

+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Command                                  | Description                                                                                                                                                  |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``-e``, ``--editor``                     | Start the editor instead of running the scene (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                    |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``-p``, ``--project-manager``            | Start the project manager, even if a project is auto-detected (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                    |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``-q``, ``--quit``                       | Quit after the first iteration.                                                                                                                              |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``-l <locale>``, ``--language <locale>`` | Use a specific locale (<locale> being a two-letter code). See :ref:`doc_locales` for more details.                                                           |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--path <directory>``                   | Path to a project (<directory> must contain a 'project.godot' file).                                                                                         |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``-u``, ``--upwards``                    | Scan folders upwards for 'project.godot' file.                                                                                                               |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--main-pack <file>``                   | Path to a pack (.pck) file to load.                                                                                                                          |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--render-thread <mode>``               | Render thread mode ('unsafe', 'safe', 'separate'). See :ref:`Thread Model <class_ProjectSettings_property_rendering/threads/thread_model>` for more details. |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--remote-fs <address>``                | Remote filesystem (``<host/IP>[:<port>]`` address).                                                                                                          |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--audio-driver <driver>``              | Audio driver. Use ``--help`` first to display the list of available drivers.                                                                                 |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--video-driver <driver>``              | Video driver. Use ``--help`` first to display the list of available drivers.                                                                                 |
+------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Display options**

+-----------------------------+----------------------------------------------------------------------------+
| Command                     | Description                                                                |
+-----------------------------+----------------------------------------------------------------------------+
| ``-f``, ``--fullscreen``    | Request fullscreen mode.                                                   |
+-----------------------------+----------------------------------------------------------------------------+
| ``-m``, ``--maximized``     | Request a maximized window.                                                |
+-----------------------------+----------------------------------------------------------------------------+
| ``-w``, ``--windowed``      | Request windowed mode.                                                     |
+-----------------------------+----------------------------------------------------------------------------+
| ``-t``, ``--always-on-top`` | Request an always-on-top window.                                           |
+-----------------------------+----------------------------------------------------------------------------+
| ``--resolution <W>x<H>``    | Request window resolution.                                                 |
+-----------------------------+----------------------------------------------------------------------------+
| ``--position <X>,<Y>``      | Request window position.                                                   |
+-----------------------------+----------------------------------------------------------------------------+
| ``--low-dpi``               | Force low-DPI mode (macOS and Windows only).                               |
+-----------------------------+----------------------------------------------------------------------------+
| ``--no-window``             | Run with invisible window. Useful together with ``--script``.              |
+-----------------------------+----------------------------------------------------------------------------+

**Debug options**

.. note::

    Debug options are only available in the editor and debug export templates
    (they require ``debug`` or ``release_debug`` build targets, see
    :ref:`doc_introduction_to_the_buildsystem_target` for more details).

+------------------------------+---------------------------------------------------------------------------------------------+
| Command                      | Description                                                                                 |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``-d``, ``--debug``          | Debug (local stdout debugger).                                                              |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``-b``, ``--breakpoints``    | Breakpoint list as source::line comma-separated pairs, no spaces (use %%20 instead).        |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--profiling``              | Enable profiling in the script debugger.                                                    |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--remote-debug <address>`` | Remote debug (``<host/IP>:<port>`` address).                                                |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--debug-collisions``       | Show collision shapes when running the scene.                                               |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--debug-navigation``       | Show navigation polygons when running the scene.                                            |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--frame-delay <ms>``       | Simulate high CPU load (delay each frame by <ms> milliseconds).                             |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--time-scale <scale>``     | Force time scale (higher values are faster, 1.0 is normal speed).                           |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--disable-render-loop``    | Disable render loop so rendering only occurs when called explicitly from script.            |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--disable-crash-handler``  | Disable crash handler when supported by the platform code.                                  |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--fixed-fps <fps>``        | Force a fixed number of frames per second. This setting disables real-time synchronization. |
+------------------------------+---------------------------------------------------------------------------------------------+
| ``--print-fps``              | Print the frames per second to the stdout.                                                  |
+------------------------------+---------------------------------------------------------------------------------------------+

**Standalone tools**

+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Command                                | Description                                                                                                                                                                        |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``-s <script>``, ``--script <script>`` | Run a script.                                                                                                                                                                      |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--check-only``                       | Only parse for errors and quit (use with ``--script``).                                                                                                                            |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--export <target>``                  | Export the project using the given export target. Export only main pack if path ends with .pck or .zip (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled). |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--export-debug <target>``            | Like ``--export``, but use debug template (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                                              |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--doctool <path>``                   | Dump the engine API reference to the given <path> in XML format, merging if existing files are found (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).   |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--no-docbase``                       | Disallow dumping the base types (used with ``--doctool``, :ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                               |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--build-solutions``                  | Build the scripting solutions (e.g. for C# projects, :ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                                    |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--gdnative-generate-json-api``       | Generate JSON dump of the Godot API for GDNative bindings (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                              |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--test <test>``                      | Run a unit test. Use ``--help`` first to display the list of tests. (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                    |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``--export-pack <preset> <path>``      | Like ``--export``, but only export the game pack for the given preset. The <path> extension determines whether it will be in PCK or ZIP format.                                    |
|                                        | (:ref:`tools <doc_introduction_to_the_buildsystem_tools>` must be enabled).                                                                                                        |
+----------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Path
----

It is recommended that your Godot binary be in your PATH environment
variable, so it can be executed easily from any place by typing
``godot``. You can do so on Linux by placing the Godot binary in
``/usr/local/bin`` and making sure it is called ``godot``.

Setting the project path
------------------------

Depending on where your Godot binary is located and what your current
working directory is, you may need to set the path to your project
for any of the following commands to work correctly.

This can be done by giving the path to the ``project.godot`` file
of your project as either the first argument, like this:

::

    godot path_to_your_project/project.godot [other] [commands] [and] [args]

Or by using the ``--path`` argument:

::

    godot --path path_to_your_project [other] [commands] [and] [args]

For example, the full command for exporting your game (as explained below) might look like this:

::

    godot --path path_to_your_project --export my_export_preset_name game.exe

Creating a project
------------------


Creating a project from the command line can be done by navigating the
shell to the desired place and making a project.godot file.


::

    mkdir newgame
    cd newgame
    touch project.godot


The project can now be opened with Godot.


Running the editor
------------------

Running the editor is done by executing Godot with the ``-e`` flag. This
must be done from within the project directory or a subdirectory,
otherwise the command is ignored and the project manager appears.

::

    godot -e

If a scene has been created and saved, it can be edited later by running
the same code with that scene as argument.

::

    godot -e scene.tscn

Erasing a scene
---------------

Godot is friends with your filesystem and will not create extra
metadata files. Use ``rm`` to erase a scene file. Make sure nothing
references that scene or else an error will be thrown upon opening.

::

    rm scene.tscn

Running the game
----------------

To run the game, simply execute Godot within the project directory or
subdirectory.

::

    godot

When a specific scene needs to be tested, pass that scene to the command
line.

::

    godot scene.tscn

Debugging
---------

Catching errors in the command line can be a difficult task because they
just fly by. For this, a command line debugger is provided by adding
``-d``. It works for running either the game or a simple scene.

::

    godot -d

::

    godot -d scene.tscn

.. _doc_command_line_tutorial_exporting:

Exporting
---------

Exporting the project from the command line is also supported. This is
especially useful for continuous integration setups. The version of Godot
that is headless (server build, no video) is ideal for this.

::

    godot --export "Linux/X11" /var/builds/project
    godot --export Android /var/builds/project.apk

The preset name must match the name of an export preset defined in the
project's ``export_presets.cfg`` file. If the preset name contains spaces or
special characters (such as "Windows Desktop"), it must be surrounded with quotes.

To export a debug version of the game, use the ``--export-debug`` switch
instead of ``--export``. Their parameters and usage are the same.

To export only a PCK file, use the ``--export-pack`` option followed by the
preset name and output path, with the file extension, instead of ``--export``.
The output path extension determines the package's format, either PCK or ZIP.

.. warning::

    When specifying a relative path as the path for `--export`, `--export-debug`
    or `--export-pack`, the path will be relative to the directory containing
    the ``project.godot`` file, **not** relative to the current working directory.

Running a script
----------------

It is possible to run a simple ``.gd`` script from the command line.
This feature is especially useful in large projects, e.g. for batch
conversion of assets or custom import/export.

The script must inherit from ``SceneTree`` or ``MainLoop``.

Here is a simple ``sayhello.gd`` example of how it works:

.. code-block:: python

    #!/usr/bin/env -S godot -s
    extends SceneTree

    func _init():
        print("Hello!")
        quit()

And how to run it:

::

    # Prints "Hello!" to standard output.
    godot -s sayhello.gd

If no ``project.godot`` exists at the path, current path is assumed to be the
current working directory (unless ``--path`` is specified).

The first line of ``sayhello.gd`` above is commonly referred to as
a *shebang*. If the Godot binary is in your ``PATH`` as ``godot``,
it allows you to run the script as follows in modern Linux
distributions, as well as macOS:

::

    # Mark script as executable.
    chmod +x sayhello.gd
    # Prints "Hello!" to standard output.
    ./sayhello.gd

If the above doesn't work in your current version of Linux or macOS, you can
always have the shebang run Godot straight from where it is located as follows:

::

    #!/usr/bin/godot -s


===================================================
/. ./tutorials/editor/external_editor.rst
===================================================

.. _doc_external_editor:

Using an external text editor
==============================

This page explains how to code using an external text editor.

Godot can be used with an external text editor, such as Sublime Text or Visual
Studio Code. Browse to the relevant editor settings: ``Editor -> Editor Settings
-> Text Editor -> External``

.. image:: img/editor_settings.png

There are two fields: the executable path and command-line flags. The flags
allow you to integrate the editor with Godot, passing it the file path to open
and other relevant arguments. Godot will replace the following placeholders in
the flags string:

+---------------------+-----------------------------------------------------+
| Field in Exec Flags | Is replaced with                                    |
+=====================+=====================================================+
| ``{project}``       | The absolute path to the project directory          |
+---------------------+-----------------------------------------------------+
| ``{file}``          | The absolute path to the file                       |
+---------------------+-----------------------------------------------------+
| ``{col}``           | The column number of the error                      |
+---------------------+-----------------------------------------------------+
| ``{line}``          | The line number of the error                        |
+---------------------+-----------------------------------------------------+

Some example Exec Flags for various editors include:

+---------------------+-----------------------------------------------------+
| Editor              | Exec Flags                                          |
+=====================+=====================================================+
| Geany/Kate          | ``{file} --line {line} --column {col}``             |
+---------------------+-----------------------------------------------------+
| Atom/Sublime Text   | ``{file}:{line}``                                   |
+---------------------+-----------------------------------------------------+
| JetBrains Rider     | ``{project} --line {line} {file}``                  |
+---------------------+-----------------------------------------------------+
| Visual Studio Code  | ``{project} --goto {file}:{line}:{col}``            |
+---------------------+-----------------------------------------------------+
| Vim (gVim)          | ``"+call cursor({line}, {col})" {file}``            |
+---------------------+-----------------------------------------------------+
| Emacs               | ``emacs +{line}:{col} {file}``                      |
+---------------------+-----------------------------------------------------+

.. note:: For Visual Studio Code, you will have to point to the ``code.cmd``
          file. For Emacs, you can call ``emacsclient`` instead of ``emacs`` if
          you use the server mode.

Official editor plugins
-----------------------

We have official plugins for the following code editors:

- `Visual Studio Code <https://github.com/godotengine/godot-vscode-plugin>`_
- `Emacs <https://github.com/godotengine/emacs-gdscript-mode>`_


===================================================
/. ./tutorials/editor/default_key_mapping.rst
===================================================

.. meta::
    :keywords: cheatsheet, cheat sheet, shortcut

.. _doc_default_key_mapping:

Default editor shortcuts
========================
Many of Godot Editor functions can be executed with keyboard shortcuts. This page
lists functions which have associated shortcuts by default, but many others are
available for customization in editor settings as well. To change keys associated
with these and other actions navigate to ``Editor -> Editor Settings -> Shortcuts``.

While some actions are universal, a lot of shortcuts are specific to individual
tools. For this reason it is possible for some key combinations to be assigned
to more than one function. The correct action will be performed depending on the
context.

.. note:: While Windows and Linux builds of the editor share most of the default settings,
          some shortcuts may differ for macOS version. This is done for better integration
          of the editor into macOS ecosystem. Users fluent with standard shortcuts on that
          OS should find Godot Editor's default key mapping intuitive.

General Editor Actions
----------------------

+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Action name           | Windows, Linux                | macOS                        | Editor setting                   |
+=======================+===============================+==============================+==================================+
| Open 2D Editor        | :kbd:`Ctrl + F1`              | :kbd:`Alt + 1`               | ``editor/editor_2d``             |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Open 3D Editor        | :kbd:`Ctrl + F2`              | :kbd:`Alt + 2`               | ``editor/editor_3d``             |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Open Script Editor    | :kbd:`Ctrl + F3`              | :kbd:`Alt + 3`               | ``editor/editor_script``         |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Search Help           | :kbd:`F1`                     | :kbd:`Alt + Space`           | ``editor/editor_help``           |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Distraction Free Mode | :kbd:`Ctrl + Shift + F11`     | :kbd:`Cmd + Ctrl + D`        | ``editor/distraction_free_mode`` |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Next tab              | :kbd:`Ctrl + Tab`             | :kbd:`Cmd + Tab`             | ``editor/next_tab``              |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Previous tab          | :kbd:`Ctrl + Shift + Tab`     | :kbd:`Cmd + Shift + Tab`     | ``editor/prev_tab``              |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Filter Files          | :kbd:`Ctrl + Alt + P`         | :kbd:`Cmd + Alt + P`         | ``editor/filter_files``          |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Open Scene            | :kbd:`Ctrl + O`               | :kbd:`Cmd + O`               | ``editor/open_scene``            |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Close Scene           | :kbd:`Ctrl + Shift + W`       | :kbd:`Cmd + Shift + W`       | ``editor/close_scene``           |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Reopen Closed Scene   | :kbd:`Ctrl + Shift + T`       | :kbd:`Cmd + Shift + T`       | ``editor/reopen_closed_scene``   |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Save Scene            | :kbd:`Ctrl + S`               | :kbd:`Cmd + S`               | ``editor/save_scene``            |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Save Scene As         | :kbd:`Ctrl + Shift + S`       | :kbd:`Cmd + Shift + S`       | ``editor/save_scene_as``         |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Save All Scenes       | :kbd:`Ctrl + Shift + Alt + S` | :kbd:`Cmd + Shift + Alt + S` | ``editor/save_all_scenes``       |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Quick Open            | :kbd:`Shift + Alt + O`        | :kbd:`Shift + Alt + O`       | ``editor/quick_open``            |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Quick Open Scene      | :kbd:`Ctrl + Shift + O`       | :kbd:`Cmd + Shift + O`       | ``editor/quick_open_scene``      |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Quick Open Script     | :kbd:`Ctrl + Alt + O`         | :kbd:`Cmd + Alt + O`         | ``editor/quick_open_script``     |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Undo                  | :kbd:`Ctrl + Z`               | :kbd:`Cmd + Z`               | ``editor/undo``                  |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Redo                  | :kbd:`Ctrl + Shift + Z`       | :kbd:`Cmd + Shift + Z`       | ``editor/redo``                  |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Quit                  | :kbd:`Ctrl + Q`               | :kbd:`Cmd + Q`               | ``editor/file_quit``             |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Quit to Project List  | :kbd:`Ctrl + Shift + Q`       | :kbd:`Shift + Alt + Q`       | ``editor/quit_to_project_list``  |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Take Screenshot       | :kbd:`Ctrl + F12`             | :kbd:`Cmd + F12`             | ``editor/take_screenshot``       |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Toggle Fullscreen     | :kbd:`Shift + F11`            | :kbd:`Cmd + Ctrl + F`        | ``editor/fullscreen_mode``       |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Play                  | :kbd:`F5`                     | :kbd:`Cmd + B`               | ``editor/play``                  |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Pause Scene           | :kbd:`F7`                     | :kbd:`Cmd + Ctrl + Y`        | ``editor/pause_scene``           |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Stop                  | :kbd:`F8`                     | :kbd:`Cmd + .`               | ``editor/stop``                  |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Play Scene            | :kbd:`F6`                     | :kbd:`Cmd + R`               | ``editor/play_scene``            |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Play Custom Scene     | :kbd:`Ctrl + Shift + F5`      | :kbd:`Cmd + Shift + R`       | ``editor/play_custom_scene``     |
+-----------------------+-------------------------------+------------------------------+----------------------------------+
| Expand Bottom Panel   | :kbd:`Shift + F12`            | :kbd:`Shift + F12`           | ``editor/bottom_panel_expand``   |
+-----------------------+-------------------------------+------------------------------+----------------------------------+

2D / Canvas Item Editor
-----------------------

+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Action name                  | Windows, Linux          | macOS                  | Editor setting                                         |
+==============================+=========================+========================+========================================================+
| Zoom In                      | :kbd:`Ctrl + =`         | :kbd:`Cmd + =`         | ``canvas_item_editor/zoom_plus``                       |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Zoom Out                     | :kbd:`Ctrl + -`         | :kbd:`Cmd + -`         | ``canvas_item_editor/zoom_minus``                      |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Zoom Reset                   | :kbd:`Ctrl + 0`         | :kbd:`Cmd + 0`         | ``canvas_item_editor/zoom_reset``                      |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Pan View                     | :kbd:`Space`            | :kbd:`Space`           | ``canvas_item_editor/pan_view``                        |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Select Mode                  | :kbd:`Q`                | :kbd:`Q`               | ``canvas_item_editor/select_mode``                     |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Move Mode                    | :kbd:`W`                | :kbd:`W`               | ``canvas_item_editor/move_mode``                       |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Rotate Mode                  | :kbd:`E`                | :kbd:`E`               | ``canvas_item_editor/rotate_mode``                     |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Scale Mode                   | :kbd:`S`                | :kbd:`S`               | ``canvas_item_editor/scale_mode``                      |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Ruler Mode                   | :kbd:`R`                | :kbd:`R`               | ``canvas_item_editor/ruler_mode``                      |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Use Smart Snap               | :kbd:`Shift + S`        | :kbd:`Shift + S`       | ``canvas_item_editor/use_smart_snap``                  |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Use Grid Snap                | :kbd:`Shift + G`        | :kbd:`Shift + G`       | ``canvas_item_editor/use_grid_snap``                   |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Multiply grid step by 2      | :kbd:`Num *`            | :kbd:`Num *`           | ``canvas_item_editor/multiply_grid_step``              |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Divide grid step by 2        | :kbd:`Num /`            | :kbd:`Num /`           | ``canvas_item_editor/divide_grid_step``                |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Always Show Grid             | :kbd:`G`                | :kbd:`G`               | ``canvas_item_editor/show_grid``                       |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Show Helpers                 | :kbd:`H`                | :kbd:`H`               | ``canvas_item_editor/show_helpers``                    |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Show Guides                  | :kbd:`Y`                | :kbd:`Y`               | ``canvas_item_editor/show_guides``                     |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Center Selection             | :kbd:`F`                | :kbd:`F`               | ``canvas_item_editor/center_selection``                |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Frame Selection              | :kbd:`Shift + F`        | :kbd:`Shift + F`       | ``canvas_item_editor/frame_selection``                 |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Preview Canvas Scale         | :kbd:`Ctrl + Shift + P` | :kbd:`Cmd + Shift + P` | ``canvas_item_editor/preview_canvas_scale``            |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Insert Key                   | :kbd:`Ins`              | :kbd:`Ins`             | ``canvas_item_editor/anim_insert_key``                 |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Insert Key (Existing Tracks) | :kbd:`Ctrl + Ins`       | :kbd:`Cmd + Ins`       | ``canvas_item_editor/anim_insert_key_existing_tracks`` |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Make Custom Bones from Nodes | :kbd:`Ctrl + Shift + B` | :kbd:`Cmd + Shift + B` | ``canvas_item_editor/skeleton_make_bones``             |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+
| Clear Pose                   | :kbd:`Shift + K`        | :kbd:`Shift + K`       | ``canvas_item_editor/anim_clear_pose``                 |
+------------------------------+-------------------------+------------------------+--------------------------------------------------------+

3D / Spatial Editor
-------------------

+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Action name                        | Windows, Linux        | macOS                | Editor setting                                   |
+====================================+=======================+======================+==================================================+
| Toggle Freelook                    | :kbd:`Shift + F`      | :kbd:`Shift + F`     | ``spatial_editor/freelook_toggle``               |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Left                      | :kbd:`A`              | :kbd:`A`             | ``spatial_editor/freelook_left``                 |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Right                     | :kbd:`D`              | :kbd:`D`             | ``spatial_editor/freelook_right``                |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Forward                   | :kbd:`W`              | :kbd:`W`             | ``spatial_editor/freelook_forward``              |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Backwards                 | :kbd:`S`              | :kbd:`S`             | ``spatial_editor/freelook_backwards``            |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Up                        | :kbd:`E`              | :kbd:`E`             | ``spatial_editor/freelook_up``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Down                      | :kbd:`Q`              | :kbd:`Q`             | ``spatial_editor/freelook_down``                 |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Speed Modifier            | :kbd:`Shift`          | :kbd:`Shift`         | ``spatial_editor/freelook_speed_modifier``       |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Freelook Slow Modifier             | :kbd:`Alt`            | :kbd:`Alt`           | ``spatial_editor/freelook_slow_modifier``        |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Select Mode                        | :kbd:`Q`              | :kbd:`Q`             | ``spatial_editor/tool_select``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Move Mode                          | :kbd:`W`              | :kbd:`W`             | ``spatial_editor/tool_move``                     |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Rotate Mode                        | :kbd:`E`              | :kbd:`E`             | ``spatial_editor/tool_rotate``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Scale Mode                         | :kbd:`R`              | :kbd:`R`             | ``spatial_editor/tool_scale``                    |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Use Local Space                    | :kbd:`T`              | :kbd:`T`             | ``spatial_editor/local_coords``                  |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Use Snap                           | :kbd:`Y`              | :kbd:`Y`             | ``spatial_editor/snap``                          |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Snap Object to Floor               | :kbd:`PgDown`         | :kbd:`PgDown`        | ``spatial_editor/snap_to_floor``                 |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Top View                           | :kbd:`Num 7`          | :kbd:`Num 7`         | ``spatial_editor/top_view``                      |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Bottom View                        | :kbd:`Alt + Num 7`    | :kbd:`Alt + Num 7`   | ``spatial_editor/bottom_view``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Front View                         | :kbd:`Num 1`          | :kbd:`Num 1`         | ``spatial_editor/front_view``                    |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Rear View                          | :kbd:`Alt + Num 1`    | :kbd:`Alt + Num 1`   | ``spatial_editor/rear_view``                     |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Right View                         | :kbd:`Num 3`          | :kbd:`Num 3`         | ``spatial_editor/right_view``                    |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Left View                          | :kbd:`Alt + Num 3`    | :kbd:`Alt + Num 3`   | ``spatial_editor/left_view``                     |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Switch Perspective/Orthogonal View | :kbd:`Num 5`          | :kbd:`Num 5`         | ``spatial_editor/switch_perspective_orthogonal`` |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Insert Animation Key               | :kbd:`K`              | :kbd:`K`             | ``spatial_editor/insert_anim_key``               |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Focus Origin                       | :kbd:`O`              | :kbd:`O`             | ``spatial_editor/focus_origin``                  |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Focus Selection                    | :kbd:`F`              | :kbd:`F`             | ``spatial_editor/focus_selection``               |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Align Transform with View          | :kbd:`Ctrl + Alt + M` | :kbd:`Cmd + Alt + M` | ``spatial_editor/align_transform_with_view``     |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| Align Rotation with View           | :kbd:`Ctrl + Alt + F` | :kbd:`Cmd + Alt + F` | ``spatial_editor/align_rotation_with_view``      |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| 1 Viewport                         | :kbd:`Ctrl + 1`       | :kbd:`Cmd + 1`       | ``spatial_editor/1_viewport``                    |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| 2 Viewports                        | :kbd:`Ctrl + 2`       | :kbd:`Cmd + 2`       | ``spatial_editor/2_viewports``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| 2 Viewports (Alt)                  | :kbd:`Ctrl + Alt + 2` | :kbd:`Cmd + Alt + 2` | ``spatial_editor/2_viewports_alt``               |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| 3 Viewports                        | :kbd:`Ctrl + 3`       | :kbd:`Cmd + 3`       | ``spatial_editor/3_viewports``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| 3 Viewports (Alt)                  | :kbd:`Ctrl + Alt + 3` | :kbd:`Cmd + Alt + 3` | ``spatial_editor/3_viewports_alt``               |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+
| 4 Viewports                        | :kbd:`Ctrl + 4`       | :kbd:`Cmd + 4`       | ``spatial_editor/4_viewports``                   |
+------------------------------------+-----------------------+----------------------+--------------------------------------------------+

Text Editor
-----------

+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Action name               | Windows, Linux           | macOS                      | Editor setting                                  |
+===========================+==========================+============================+=================================================+
| Cut                       | :kbd:`Ctrl + X`          | :kbd:`Cmd + X`             | ``script_text_editor/cut``                      |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Copy                      | :kbd:`Ctrl + C`          | :kbd:`Cmd + C`             | ``script_text_editor/copy``                     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Paste                     | :kbd:`Ctrl + V`          | :kbd:`Cmd + V`             | ``script_text_editor/paste``                    |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Select All                | :kbd:`Ctrl + A`          | :kbd:`Cmd + A`             | ``script_text_editor/select_all``               |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Find                      | :kbd:`Ctrl + F`          | :kbd:`Cmd + F`             | ``script_text_editor/find``                     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Find Next                 | :kbd:`F3`                | :kbd:`Cmd + G`             | ``script_text_editor/find_next``                |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Find Previous             | :kbd:`Shift + F3`        | :kbd:`Cmd + Shift + G`     | ``script_text_editor/find_previous``            |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Find in Files             | :kbd:`Ctrl + Shift + F`  | :kbd:`Cmd + Shift + F`     | ``script_text_editor/find_in_files``            |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Replace                   | :kbd:`Ctrl + R`          | :kbd:`Alt + Cmd + F`       | ``script_text_editor/replace``                  |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Replace in Files          | :kbd:`Ctrl + Shift + R`  | :kbd:`Cmd + Shift + R`     | ``script_text_editor/replace_in_files``         |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Undo                      | :kbd:`Ctrl + Z`          | :kbd:`Cmd + Z`             | ``script_text_editor/undo``                     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Redo                      | :kbd:`Ctrl + Y`          | :kbd:`Cmd + Y`             | ``script_text_editor/redo``                     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Move Up                   | :kbd:`Alt + Up Arrow`    | :kbd:`Alt + Up Arrow`      | ``script_text_editor/move_up``                  |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Move Down                 | :kbd:`Alt + Down Arrow`  | :kbd:`Alt + Down Arrow`    | ``script_text_editor/move_down``                |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Delete Line               | :kbd:`Ctrl + Shift + K`  | :kbd:`Cmd + Shift + K`     | ``script_text_editor/delete_line``              |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Toggle Comment            | :kbd:`Ctrl + K`          | :kbd:`Cmd + K`             | ``script_text_editor/toggle_comment``           |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Fold/Unfold Line          | :kbd:`Alt + F`           | :kbd:`Alt + F`             | ``script_text_editor/toggle_fold_line``         |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Clone Down                | :kbd:`Ctrl + D`          | :kbd:`Cmd + Shift + C`     | ``script_text_editor/clone_down``               |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Complete Symbol           | :kbd:`Ctrl + Space`      | :kbd:`Ctrl + Space`        | ``script_text_editor/complete_symbol``          |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Evaluate Selection        | :kbd:`Ctrl + Shift + E`  | :kbd:`Cmd + Shift + E`     | ``script_text_editor/evaluate_selection``       |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Trim Trailing Whitespace  | :kbd:`Ctrl + Alt + T`    | :kbd:`Cmd + Alt + T`       | ``script_text_editor/trim_trailing_whitespace`` |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Uppercase                 | :kbd:`Shift + F4`        | :kbd:`Shift + F4`          | ``script_text_editor/convert_to_uppercase``     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Lowercase                 | :kbd:`Shift + F5`        | :kbd:`Shift + F5`          | ``script_text_editor/convert_to_lowercase``     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Capitalize                | :kbd:`Shift + F6`        | :kbd:`Shift + F6`          | ``script_text_editor/capitalize``               |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Convert Indent to Spaces  | :kbd:`Ctrl + Shift + Y`  | :kbd:`Cmd + Shift + Y`     | ``script_text_editor/convert_indent_to_spaces`` |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Convert Indent to Tabs    | :kbd:`Ctrl + Shift + I`  | :kbd:`Cmd + Shift + I`     | ``script_text_editor/convert_indent_to_tabs``   |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Auto Indent               | :kbd:`Ctrl + I`          | :kbd:`Cmd + I`             | ``script_text_editor/auto_indent``              |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Toggle Bookmark           | :kbd:`Ctrl + Alt + B`    | :kbd:`Cmd + Alt + B`       | ``script_text_editor/toggle_bookmark``          |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Go to Next Bookmark       | :kbd:`Ctrl + B`          | :kbd:`Cmd + B`             | ``script_text_editor/goto_next_bookmark``       |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Go to Previous Bookmark   | :kbd:`Ctrl + Shift + B`  | :kbd:`Cmd + Shift + B`     | ``script_text_editor/goto_previous_bookmark``   |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Go to Function            | :kbd:`Ctrl + Alt + F`    | :kbd:`Ctrl + Cmd + J`      | ``script_text_editor/goto_function``            |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Go to Line                | :kbd:`Ctrl + L`          | :kbd:`Cmd + L`             | ``script_text_editor/goto_line``                |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Toggle Breakpoint         | :kbd:`F9`                | :kbd:`Cmd + Shift + B`     | ``script_text_editor/toggle_breakpoint``        |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Remove All Breakpoints    | :kbd:`Ctrl + Shift + F9` | :kbd:`Cmd + Shift + F9`    | ``script_text_editor/remove_all_breakpoints``   |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Go to Next Breakpoint     | :kbd:`Ctrl + .`          | :kbd:`Cmd + .`             | ``script_text_editor/goto_next_breakpoint``     |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Go to Previous Breakpoint | :kbd:`Ctrl + ,`          | :kbd:`Cmd + ,`             | ``script_text_editor/goto_previous_breakpoint`` |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+
| Contextual Help           | :kbd:`Alt + F1`          | :kbd:`Alt + Shift + Space` | ``script_text_editor/contextual_help``          |
+---------------------------+--------------------------+----------------------------+-------------------------------------------------+

Script Editor
-------------

+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Action name          | Windows, Linux                  | macOS                           | Editor setting                         |
+======================+=================================+=================================+========================================+
| Find                 | :kbd:`Ctrl + F`                 | :kbd:`Cmd + F`                  | ``script_editor/find``                 |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Find Next            | :kbd:`F3`                       | :kbd:`F3`                       | ``script_editor/find_next``            |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Find Previous        | :kbd:`Shift + F3`               | :kbd:`Shift + F3`               | ``script_editor/find_previous``        |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Find in Files        | :kbd:`Ctrl + Shift + F`         | :kbd:`Cmd + Shift + F`          | ``script_editor/find_in_files``        |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Move Up              | :kbd:`Shift + Alt + Up Arrow`   | :kbd:`Shift + Alt + Up Arrow`   | ``script_editor/window_move_up``       |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Move Down            | :kbd:`Shift + Alt + Down Arrow` | :kbd:`Shift + Alt + Down Arrow` | ``script_editor/window_move_down``     |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Next Script          | :kbd:`Ctrl + Shift + .`         | :kbd:`Cmd + Shift + .`          | ``script_editor/next_script``          |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Previous Script      | :kbd:`Ctrl + Shift + ,`         | :kbd:`Cmd + Shift + ,`          | ``script_editor/prev_script``          |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Reopen Closed Script | :kbd:`Ctrl + Shift + T`         | :kbd:`Cmd + Shift + T`          | ``script_editor/reopen_closed_script`` |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Save                 | :kbd:`Ctrl + Alt + S`           | :kbd:`Cmd + Alt + S`            | ``script_editor/save``                 |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Save All             | :kbd:`Ctrl + Shift + Alt + S`   | :kbd:`Cmd + Shift + Alt + S`    | ``script_editor/save_all``             |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Soft Reload Script   | :kbd:`Ctrl + Shift + R`         | :kbd:`Cmd + Shift + R`          | ``script_editor/reload_script_soft``   |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| History Previous     | :kbd:`Alt + Left Arrow`         | :kbd:`Alt + Left Arrow`         | ``script_editor/history_previous``     |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| History Next         | :kbd:`Alt + Right Arrow`        | :kbd:`Alt + Right Arrow`        | ``script_editor/history_next``         |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Close                | :kbd:`Ctrl + W`                 | :kbd:`Cmd + W`                  | ``script_editor/close_file``           |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Run                  | :kbd:`Ctrl + Shift + X`         | :kbd:`Cmd + Shift + X`          | ``script_editor/run_file``             |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Toggle Scripts Panel | :kbd:`Ctrl + \\`                | :kbd:`Cmd + \\`                 | ``script_editor/toggle_scripts_panel`` |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Zoom In              | :kbd:`Ctrl + =`                 | :kbd:`Cmd + =`                  | ``script_editor/zoom_in``              |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Zoom Out             | :kbd:`Ctrl + -`                 | :kbd:`Cmd + -`                  | ``script_editor/zoom_out``             |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+
| Reset Zoom           | :kbd:`Ctrl + 0`                 | :kbd:`Cmd + 0`                  | ``script_editor/reset_zoom``           |
+----------------------+---------------------------------+---------------------------------+----------------------------------------+

Visual Script Editor
--------------------

+-------------------+-----------------+-------------------+--------------------------------------------+
| Action name       | Windows, Linux  | macOS             | Editor setting                             |
+===================+=================+===================+============================================+
| Find Node Type    | :kbd:`Ctrl + F` | :kbd:`Cmd + F`    | ``visual_script_editor/find_node_type``    |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Copy Nodes        | :kbd:`Ctrl + C` | :kbd:`Cmd + C`    | ``visual_script_editor/copy_nodes``        |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Cut Nodes         | :kbd:`Ctrl + X` | :kbd:`Cmd + X`    | ``visual_script_editor/cut_nodes``         |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Paste Nodes       | :kbd:`Ctrl + V` | :kbd:`Cmd + V`    | ``visual_script_editor/paste_nodes``       |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Delete Selected   | :kbd:`Del`      | :kbd:`Cmd + BkSp` | ``visual_script_editor/delete_selected``   |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Make Function     | :kbd:`Ctrl + G` | :kbd:`Cmd + G`    | ``visual_script_editor/create_function``   |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Edit Member       | :kbd:`Ctrl + E` | :kbd:`Cmd + E`    | ``visual_script_editor/edit_member``       |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Refresh Graph     | :kbd:`Ctrl + R` | :kbd:`Cmd + R`    | ``visual_script_editor/refresh_nodes``     |
+-------------------+-----------------+-------------------+--------------------------------------------+
| Toggle Breakpoint | :kbd:`F9`       | :kbd:`F9`         | ``visual_script_editor/toggle_breakpoint`` |
+-------------------+-----------------+-------------------+--------------------------------------------+

Editor Output
-------------

+----------------+-------------------------+------------------------+-------------------------+
| Action name    | Windows, Linux          | macOS                  | Editor setting          |
+================+=========================+========================+=========================+
| Copy Selection | :kbd:`Ctrl + C`         | :kbd:`Cmd + C`         | ``editor/copy_output``  |
+----------------+-------------------------+------------------------+-------------------------+
| Clear Output   | :kbd:`Ctrl + Shift + K` | :kbd:`Cmd + Shift + K` | ``editor/clear_output`` |
+----------------+-------------------------+------------------------+-------------------------+

Debugger
--------

+-------------+----------------+------------+------------------------+
| Action name | Windows, Linux | macOS      | Editor setting         |
+=============+================+============+========================+
| Step Into   | :kbd:`F11`     | :kbd:`F11` | ``debugger/step_into`` |
+-------------+----------------+------------+------------------------+
| Step Over   | :kbd:`F10`     | :kbd:`F10` | ``debugger/step_over`` |
+-------------+----------------+------------+------------------------+
| Continue    | :kbd:`F12`     | :kbd:`F12` | ``debugger/continue``  |
+-------------+----------------+------------+------------------------+

File Dialog
-----------

+---------------------+--------------------------+--------------------------+-------------------------------------+
| Action name         | Windows, Linux           | macOS                    | Editor setting                      |
+=====================+==========================+==========================+=====================================+
| Go Back             | :kbd:`Alt + Left Arrow`  | :kbd:`Alt + Left Arrow`  | ``file_dialog/go_back``             |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Go Forward          | :kbd:`Alt + Right Arrow` | :kbd:`Alt + Right Arrow` | ``file_dialog/go_forward``          |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Go Up               | :kbd:`Alt + Up Arrow`    | :kbd:`Alt + Up Arrow`    | ``file_dialog/go_up``               |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Refresh             | :kbd:`F5`                | :kbd:`F5`                | ``file_dialog/refresh``             |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Toggle Hidden Files | :kbd:`Ctrl + H`          | :kbd:`Cmd + H`           | ``file_dialog/toggle_hidden_files`` |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Toggle Favorite     | :kbd:`Alt + F`           | :kbd:`Alt + F`           | ``file_dialog/toggle_favorite``     |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Toggle Mode         | :kbd:`Alt + V`           | :kbd:`Alt + V`           | ``file_dialog/toggle_mode``         |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Create Folder       | :kbd:`Ctrl + N`          | :kbd:`Cmd + N`           | ``file_dialog/create_folder``       |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Delete              | :kbd:`Del`               | :kbd:`Cmd + BkSp`        | ``file_dialog/delete``              |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Focus Path          | :kbd:`Ctrl + D`          | :kbd:`Cmd + D`           | ``file_dialog/focus_path``          |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Move Favorite Up    | :kbd:`Ctrl + Up Arrow`   | :kbd:`Cmd + Up Arrow`    | ``file_dialog/move_favorite_up``    |
+---------------------+--------------------------+--------------------------+-------------------------------------+
| Move Favorite Down  | :kbd:`Ctrl + Down Arrow` | :kbd:`Cmd + Down Arrow`  | ``file_dialog/move_favorite_down``  |
+---------------------+--------------------------+--------------------------+-------------------------------------+

FileSystem Dock
---------------

+-------------+-----------------+-------------------+-------------------------------+
| Action name | Windows, Linux  | macOS             | Editor setting                |
+=============+=================+===================+===============================+
| Copy Path   | :kbd:`Ctrl + C` | :kbd:`Cmd + C`    | ``filesystem_dock/copy_path`` |
+-------------+-----------------+-------------------+-------------------------------+
| Duplicate   | :kbd:`Ctrl + D` | :kbd:`Cmd + D`    | ``filesystem_dock/duplicate`` |
+-------------+-----------------+-------------------+-------------------------------+
| Delete      | :kbd:`Del`      | :kbd:`Cmd + BkSp` | ``filesystem_dock/delete``    |
+-------------+-----------------+-------------------+-------------------------------+

Scene Tree Dock
---------------

+----------------+--------------------------+-------------------------+----------------------------------+
| Action name    | Windows, Linux           | macOS                   | Editor setting                   |
+================+==========================+=========================+==================================+
| Add Child Node | :kbd:`Ctrl + A`          | :kbd:`Cmd + A`          | ``scene_tree/add_child_node``    |
+----------------+--------------------------+-------------------------+----------------------------------+
| Batch Rename   | :kbd:`Ctrl + F2`         | :kbd:`Cmd + F2`         | ``scene_tree/batch_rename``      |
+----------------+--------------------------+-------------------------+----------------------------------+
| Copy Node Path | :kbd:`Ctrl + C`          | :kbd:`Cmd + C`          | ``scene_tree/copy_node_path``    |
+----------------+--------------------------+-------------------------+----------------------------------+
| Delete         | :kbd:`Del`               | :kbd:`Cmd + BkSp`       | ``scene_tree/delete``            |
+----------------+--------------------------+-------------------------+----------------------------------+
| Force Delete   | :kbd:`Shift + Del`       | :kbd:`Shift + Del`      | ``scene_tree/delete_no_confirm`` |
+----------------+--------------------------+-------------------------+----------------------------------+
| Duplicate      | :kbd:`Ctrl + D`          | :kbd:`Cmd + D`          | ``scene_tree/duplicate``         |
+----------------+--------------------------+-------------------------+----------------------------------+
| Move Up        | :kbd:`Ctrl + Up Arrow`   | :kbd:`Cmd + Up Arrow`   | ``scene_tree/move_up``           |
+----------------+--------------------------+-------------------------+----------------------------------+
| Move Down      | :kbd:`Ctrl + Down Arrow` | :kbd:`Cmd + Down Arrow` | ``scene_tree/move_down``         |
+----------------+--------------------------+-------------------------+----------------------------------+

Animation Track Editor
----------------------

+----------------------+---------------------------+--------------------------+-----------------------------------------------------+
| Action name          | Windows, Linux            | macOS                    | Editor setting                                      |
+======================+===========================+==========================+=====================================================+
| Duplicate Selection  | :kbd:`Ctrl + D`           | :kbd:`Cmd + D`           | ``animation_editor/duplicate_selection``            |
+----------------------+---------------------------+--------------------------+-----------------------------------------------------+
| Duplicate Transposed | :kbd:`Ctrl + Shift + D`   | :kbd:`Cmd + Shift + D`   | ``animation_editor/duplicate_selection_transposed`` |
+----------------------+---------------------------+--------------------------+-----------------------------------------------------+
| Delete Selection     | :kbd:`Del`                | :kbd:`Cmd + BkSp`        | ``animation_editor/delete_selection``               |
+----------------------+---------------------------+--------------------------+-----------------------------------------------------+
| Go to Next Step      | :kbd:`Ctrl + Right Arrow` | :kbd:`Cmd + Right Arrow` | ``animation_editor/goto_next_step``                 |
+----------------------+---------------------------+--------------------------+-----------------------------------------------------+
| Go to Previous Step  | :kbd:`Ctrl + Left Arrow`  | :kbd:`Cmd + Left Arrow`  | ``animation_editor/goto_prev_step``                 |
+----------------------+---------------------------+--------------------------+-----------------------------------------------------+

Tile Map Editor
---------------

+-------------------+-----------------+-------------------+-------------------------------------+
| Action name       | Windows, Linux  | macOS             | Editor setting                      |
+===================+=================+===================+=====================================+
| Find Tile         | :kbd:`Ctrl + F` | :kbd:`Cmd + F`    | ``tile_map_editor/find_tile``       |
+-------------------+-----------------+-------------------+-------------------------------------+
| Pick Tile         | :kbd:`I`        | :kbd:`I`          | ``tile_map_editor/pick_tile``       |
+-------------------+-----------------+-------------------+-------------------------------------+
| Paint Tile        | :kbd:`P`        | :kbd:`P`          | ``tile_map_editor/paint_tile``      |
+-------------------+-----------------+-------------------+-------------------------------------+
| Bucket Fill       | :kbd:`G`        | :kbd:`G`          | ``tile_map_editor/bucket_fill``     |
+-------------------+-----------------+-------------------+-------------------------------------+
| Transpose         | :kbd:`T`        | :kbd:`T`          | ``tile_map_editor/transpose``       |
+-------------------+-----------------+-------------------+-------------------------------------+
| Flip Horizontally | :kbd:`X`        | :kbd:`X`          | ``tile_map_editor/flip_horizontal`` |
+-------------------+-----------------+-------------------+-------------------------------------+
| Flip Vertically   | :kbd:`Z`        | :kbd:`Z`          | ``tile_map_editor/flip_vertical``   |
+-------------------+-----------------+-------------------+-------------------------------------+
| Rotate Left       | :kbd:`A`        | :kbd:`A`          | ``tile_map_editor/rotate_left``     |
+-------------------+-----------------+-------------------+-------------------------------------+
| Rotate Right      | :kbd:`S`        | :kbd:`S`          | ``tile_map_editor/rotate_right``    |
+-------------------+-----------------+-------------------+-------------------------------------+
| Clear Transform   | :kbd:`W`        | :kbd:`W`          | ``tile_map_editor/clear_transform`` |
+-------------------+-----------------+-------------------+-------------------------------------+
| Select            | :kbd:`M`        | :kbd:`M`          | ``tile_map_editor/select``          |
+-------------------+-----------------+-------------------+-------------------------------------+
| Cut Selection     | :kbd:`Ctrl + X` | :kbd:`Cmd + X`    | ``tile_map_editor/cut_selection``   |
+-------------------+-----------------+-------------------+-------------------------------------+
| Copy Selection    | :kbd:`Ctrl + C` | :kbd:`Cmd + C`    | ``tile_map_editor/copy_selection``  |
+-------------------+-----------------+-------------------+-------------------------------------+
| Erase Selection   | :kbd:`Del`      | :kbd:`Cmd + BkSp` | ``tile_map_editor/erase_selection`` |
+-------------------+-----------------+-------------------+-------------------------------------+

Tileset Editor
--------------

+---------------------+----------------+---------------+----------------------------------------+
| Action name         | Windows, Linux | macOS         | Editor setting                         |
+=====================+================+===============+========================================+
| Next Coordinate     | :kbd:`PgDown`  | :kbd:`PgDown` | ``tileset_editor/next_shape``          |
+---------------------+----------------+---------------+----------------------------------------+
| Previous Coordinate | :kbd:`PgUp`    | :kbd:`PgUp`   | ``tileset_editor/previous_shape``      |
+---------------------+----------------+---------------+----------------------------------------+
| Region Mode         | :kbd:`1`       | :kbd:`1`      | ``tileset_editor/editmode_region``     |
+---------------------+----------------+---------------+----------------------------------------+
| Collision Mode      | :kbd:`2`       | :kbd:`2`      | ``tileset_editor/editmode_collision``  |
+---------------------+----------------+---------------+----------------------------------------+
| Occlusion Mode      | :kbd:`3`       | :kbd:`3`      | ``tileset_editor/editmode_occlusion``  |
+---------------------+----------------+---------------+----------------------------------------+
| Navigation Mode     | :kbd:`4`       | :kbd:`4`      | ``tileset_editor/editmode_navigation`` |
+---------------------+----------------+---------------+----------------------------------------+
| Bitmask Mode        | :kbd:`5`       | :kbd:`5`      | ``tileset_editor/editmode_bitmask``    |
+---------------------+----------------+---------------+----------------------------------------+
| Priority Mode       | :kbd:`6`       | :kbd:`6`      | ``tileset_editor/editmode_priority``   |
+---------------------+----------------+---------------+----------------------------------------+
| Icon Mode           | :kbd:`7`       | :kbd:`7`      | ``tileset_editor/editmode_icon``       |
+---------------------+----------------+---------------+----------------------------------------+
| Z Index Mode        | :kbd:`8`       | :kbd:`8`      | ``tileset_editor/editmode_z_index``    |
+---------------------+----------------+---------------+----------------------------------------+


===================================================
/. ./tutorials/editor/using_the_web_editor.rst
===================================================

.. _doc_using_the_web_editor:

Using the Web editor
====================

Since Godot 3.3, there is a `Web editor <https://editor.godotengine.org/>`__
you can use to work on new or existing projects.

.. note::

    The web editor is in a preliminary stage. While its feature set may be
    sufficient for educational purposes, it is currently **not recommended for
    production work**. See :ref:`doc_using_the_web_editor_limitations` below.

Browser support
---------------

The Web editor requires support for WebAssembly's SharedArrayBuffer. This
is in turn required to support threading in the browser. The following desktop
browsers support WebAssembly threading and can therefore run the web editor:

- Chrome 68 or later
- Firefox 79 or later
- Edge 79 or later

Opera and Safari are not supported yet. Safari may work in the future once
proper threading support is added.

**Mobile browsers are currently not supported.**

The web editor supports both the GLES3 and GLES2 renderers, although GLES2 is
recommended for better performance and compatibility with old/low-end hardware.

.. note::

    If you use Linux, due to
    `poor Firefox WebGL performance <https://bugzilla.mozilla.org/show_bug.cgi?id=1010527>`__,
    it's recommended to use a Chromium-based browser instead of Firefox.

.. _doc_using_the_web_editor_limitations:

Limitations
-----------

Due to limitations on the Godot or Web platform side, the following features
are currently missing:

- No C#/Mono support.
- No GDNative support.
- No debugging support. This means GDScript debugging/profiling, live scene
  editing, the Remote Scene tree dock and other features that rely on the debugger
  protocol will not work.
- No project exporting. As a workaround, you can download the project source
  using **Project > Tools > Download Project Source** and export it using a
  `native version of the Godot editor <https://godotengine.org/download>`__.
- The editor won't warn you when closing the tab with unsaved changes.
- No lightmap baking support. You can still use existing lightmaps if they were
  baked with a native version of the Godot editor
  (e.g. by importing an existing project).

The following features are unlikely to be supported due to inherent limitations
of the Web platform:

- No support for external script editors.
- No support for Android one-click deploy.

.. seealso::

    See the
    `list of open issues on GitHub related to the web editor <https://github.com/godotengine/godot/issues?q=is%3Aopen+is%3Aissue+label%3Aplatform%3Ahtml5+label%3Atopic%3Aeditor>`__ for a list of known bugs.

Importing a project
-------------------

To import an existing project, the current process is as follows:

- Specify a ZIP file to preload on the HTML5 filesystem using the
  **Preload project ZIP** input.
- Run the editor by clicking **Start Godot editor**.
  The Godot project manager should appear after 10-20 seconds.
  On slower machines or connections, loading may take up to a minute.
- In the dialog that appears at the middle of the window, specify a name for
  the folder to create then click the **Create Folder** button
  (it doesn't have to match the ZIP archive's name).
- Click **Install & Edit** and the project will open in the editor.

.. attention::

    It's important to place the project folder somewhere in ``/home/web_user/``.
    If your project folder is placed outside ``/home/web_user/``, you will
    lose your project when closing the editor!

    When you follow the steps described above, the project folder will always be
    located in ``/home/web_user/projects``, keeping it safe.

Editing and running a project
-----------------------------

Unlike the native version of Godot, the web editor is constrained to a single
window. Therefore, it cannot open a new window when running the project.
Instead, when you run the project by clicking the Run button or pressing
:kbd:`F5`, it will appear to "replace" the editor window.

The web editor offers an alternative way to deal with the editor and game
windows (which are now "tabs"). You can switch between the **Editor** and
**Game** tabs using the buttons on the top. You can also close the running game
or editor by clicking the **×** button next to those tabs.

Where are my project files?
---------------------------

Due to browser security limitations, the editor will save the project files to
the browser's IndexedDB storage. This storage isn't accessible as a regular folder
on your machine, but is abstracted away in a database.

You can download the project files as a ZIP archive by using
**Project > Tools > Download Project Source**. This can be used to export the
project using a `native Godot editor <https://godotengine.org/download>`__,
since exporting from the web editor isn't supported yet.

In the future, it may be possible to use the
`HTML5 FileSystem API <https://developer.mozilla.org/en-US/docs/Web/API/FileSystem>`__
to store the project files on the user's filesystem as the native editor would do.
However, this isn't implemented yet.


===================================================
/. ./tutorials/editor/managing_editor_features.rst
===================================================

.. _doc_managing_editor_features:

Managing editor features
========================

Introduction
------------

In certain situations, it may be desirable to limit what features can be used
in the Godot editor. For example, a UI designer on a team who doesn't need to
see 3D features, or an educator slowly introducing features to students. Godot
has a built in system called "feature profiles" to do this.

With feature profiles, major features and nodes can be hidden from the editor.
This only hides parts of the interface and does not actually remove support for
these features, so scenes and scripts relying on those features will still work fine.
This also means feature profiles are not an optimization technique. For
information on how to optimize Godot see :ref:`doc_optimization`.

Creating a profile
------------------

To manage editor features go to **Editor > Manage Editor Features**. This
will open the **Manage Editor Feature Profiles** window. By default there
will be no profile. Click on **Create Profile** and give it a name. You will
then see a list of all the features in the Godot editor.

..img:: img/configure_profile.png

The first section allows major editor features to be removed, such as the 3D
editor or scripting editor. Below the main features is every class and node in
Godot, which can be disabled as well. Click on a node and all of its properties
and options will be listed in the **Extra Items** box, these can all be
individually disabled.

..img:: img/node_features.png

Sharing a profile
-----------------

To share profiles between editors click on the **Export** button. Save the custom
profile somewhere as a ``.profile`` file. To use this in another editor open that
editor's **Manage Editor Feature Profiles** window and click import, then select the
``.profile`` file.

This process is potentially cumbersome however if a large amount of computers need
custom profiles. As an alternative, you can enable self-contained mode for Godot,
which allows putting all editor configuration in the same folder as the editor binary.
See :ref:`doc_data_paths_self_contained_mode` for details.


===================================================
/. ./tutorials/2d/index.rst
===================================================

2D
==

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-2d

   canvas_layers
   2d_transforms
   using_tilemaps
   particle_systems_2d
   2d_movement
   2d_lights_and_shadows
   2d_meshes
   custom_drawing_in_2d
   2d_sprite_animation


===================================================
/. ./tutorials/2d/canvas_layers.rst
===================================================

.. _doc_canvas_layers:

Canvas layers
=============

Viewport and Canvas items
-------------------------

:ref:`CanvasItem <class_CanvasItem>` is the base for all 2D nodes, be it regular
2D nodes, such as :ref:`Node2D <class_Node2D>`, or :ref:`Control <class_Control>`.
Both inherit from :ref:`CanvasItem <class_CanvasItem>`.
You can arrange canvas items in trees. Each item will inherit its parent's
transform: when the parent moves, its children move too.

CanvasItem nodes, and nodes inheriting from them, are direct or indirect children of a
:ref:`Viewport <class_Viewport>`, that display them.

A Viewport has the property
:ref:`Viewport.canvas_transform <class_Viewport_property_canvas_transform>`,
allows to apply a custom :ref:`Transform2D <class_Transform2D>`
transform to the CanvasItem hierarchy it contains. Nodes such as
:ref:`Camera2D <class_Camera2D>` work by changing that transform.

To achieve effects like scrolling, manipulating the canvas transform property is
more efficient than moving the root canvas item and the entire scene with it.

Usually though, we don't want *everything* in the game or app to be subject to the canvas
transform. For example:

-  **Parallax Backgrounds**: Backgrounds that move slower than the rest
   of the stage.
-  **UI**: Think of a user interface (UI) or head-up display (HUD) superimposed on our view of the game world. We want a life counter, score display and other elements to retain their screen positions even when our view of the game world changes.
-  **Transitions**: We may want visual effects used for transitions (fades, blends) to remain at a fixed screen location.

How can these problems be solved in a single scene tree?

CanvasLayers
------------

The answer is :ref:`CanvasLayer <class_CanvasLayer>`,
which is a node that adds a separate 2D rendering layer for all its
children and grand-children. Viewport children will draw by default at
layer "0", while a CanvasLayer will draw at any numeric layer. Layers
with a greater number will be drawn above those with a smaller number.
CanvasLayers also have their own transform and do not depend on the
transform of other layers. This allows the UI to be fixed in screen-space
while our view on the game world changes.

An example of this is creating a parallax background. This can be done
with a CanvasLayer at layer "-1". The screen with the points, life
counter and pause button can also be created at layer "1".

Here's a diagram of how it looks:

.. image:: img/canvaslayers.png

CanvasLayers are independent of tree order, and they only depend on
their layer number, so they can be instantiated when needed.

.. note::   CanvasLayers aren't necessary to control the drawing order of nodes.
            The standard way to ensuring that a node is  correctly drawn 'in front' or 'behind' others is to manipulate the
            order of the nodes in the scene panel. Perhaps counterintuitively, the topmost nodes in the scene panel are drawn
            on *behind* lower ones in the viewport. 2d nodes also have a property for controlling their drawing order
            (see :ref:`Node2D.z_index <class_Node2D_property_z_index>`).


===================================================
/. ./tutorials/2d/2d_transforms.rst
===================================================

.. _doc_viewport_and_canvas_transforms:

Viewport and canvas transforms
==============================

Introduction
------------

This is an overview of the 2D transforms going on for nodes from the
moment they draw their content locally to the time they are drawn onto
the screen. This overview discusses very low level details of the engine.

Canvas transform
----------------

As mentioned in the previous tutorial, :ref:`doc_canvas_layers`, every
CanvasItem node (remember that Node2D and Control based nodes use
CanvasItem as their common root) will reside in a *Canvas Layer*. Every
canvas layer has a transform (translation, rotation, scale, etc.) that
can be accessed as a :ref:`Transform2D <class_Transform2D>`.

Also covered in the previous tutorial, nodes are drawn by default in Layer 0,
in the built-in canvas. To put nodes in a different layer, a :ref:`CanvasLayer
<class_CanvasLayer>` node can be used.

Global canvas transform
-----------------------

Viewports also have a Global Canvas transform (also a
:ref:`Transform2D <class_Transform2D>`). This is the master transform and
affects all individual *Canvas Layer* transforms. Generally, this
transform is not of much use, but is used in the CanvasItem Editor
in Godot's editor.

Stretch transform
-----------------

Finally, viewports have a *Stretch Transform*, which is used when
resizing or stretching the screen. This transform is used internally (as
described in :ref:`doc_multiple_resolutions`), but can also be manually set
on each viewport.

Input events received in the :ref:`MainLoop._input_event() <class_MainLoop_method__input_event>`
callback are multiplied by this transform but lack the ones above. To
convert InputEvent coordinates to local CanvasItem coordinates, the
:ref:`CanvasItem.make_input_local() <class_CanvasItem_method_make_input_local>`
function was added for convenience.

Transform order
---------------

For a coordinate in CanvasItem local properties to become an actual
screen coordinate, the following chain of transforms must be applied:

.. image:: img/viewport_transforms2.png

Transform functions
-------------------

Obtaining each transform can be achieved with the following functions:

+----------------------------------+---------------------------------------------------------------------------------------------+
| Type                             | Transform                                                                                   |
+==================================+=============================================================================================+
| CanvasItem                       | :ref:`CanvasItem.get_global_transform() <class_CanvasItem_method_get_global_transform>`     |
+----------------------------------+---------------------------------------------------------------------------------------------+
| CanvasLayer                      | :ref:`CanvasItem.get_canvas_transform() <class_CanvasItem_method_get_canvas_transform>`     |
+----------------------------------+---------------------------------------------------------------------------------------------+
| CanvasLayer+GlobalCanvas+Stretch | :ref:`CanvasItem.get_viewport_transform() <class_CanvasItem_method_get_viewport_transform>` |
+----------------------------------+---------------------------------------------------------------------------------------------+

Finally, then, to convert a CanvasItem local coordinates to screen
coordinates, just multiply in the following order:

.. tabs::
 .. code-tab:: gdscript GDScript

    var screen_coord = get_viewport_transform() * (get_global_transform() * local_pos)

 .. code-tab:: csharp

    var screenCord = (GetViewportTransform() * GetGlobalTransform()).Xform(localPos);

Keep in mind, however, that it is generally not desired to work with
screen coordinates. The recommended approach is to simply work in Canvas
coordinates (``CanvasItem.get_global_transform()``), to allow automatic
screen resolution resizing to work properly.

Feeding custom input events
---------------------------

It is often desired to feed custom input events to the scene tree. With
the above knowledge, to correctly do this, it must be done the following
way:

.. tabs::
 .. code-tab:: gdscript GDScript

    var local_pos = Vector2(10, 20) # local to Control/Node2D
    var ie = InputEventMouseButton.new()
    ie.button_index = BUTTON_LEFT
    ie.position = get_viewport_transform() * (get_global_transform() * local_pos)
    get_tree().input_event(ie)

 .. code-tab:: csharp

    var localPos = new Vector2(10,20); // local to Control/Node2D
    var ie = new InputEventMouseButton();
    ie.ButtonIndex = (int)ButtonList.Left;
    ie.Position = (GetViewportTransform() * GetGlobalTransform()).Xform(localPos);
    GetTree().InputEvent(ie);


===================================================
/. ./tutorials/2d/using_tilemaps.rst
===================================================

.. _doc_using_tilemaps:

Using TileMaps
==============

Introduction
------------

A tilemap is a grid of tiles used to create a game's layout. There are several
benefits to using :ref:`TileMap <class_TileMap>` nodes to design your levels.
First, they make it possible to draw the layout by "painting" the tiles onto a
grid, which is much faster than placing individual :ref:`Sprite <class_Sprite>`
nodes one by one. Second, they allow for much larger levels because they are
optimized for drawing large numbers of tiles. Finally, you can add collision,
occlusion, and navigation shapes to tiles, adding additional functionality to
the TileMap.

.. image:: img/tileset_draw_atlas.png

Project setup
-------------

This demo will use the following tiles taken from Kenney's "Abstract Platformer"
art pack. You can find the complete set `here <https://kenney.nl/assets/abstract-platformer>`_
but for this demo we'll stick to this small set.

.. image:: img/tilesheet.png

Create a new project and place the above image in the project folder.

When using a tileset, it's important that adjacent tiles match up. Godot's default
is to import 2D images using an interpolated "filter" mode, which will result in
ugly borders between the tiles. Select the image and click the Import tab. Turn
off ``Filter`` and click "Reimport". See :ref:`doc_import_images` for details.

TileMap node
------------

Add a new :ref:`TileMap <class_TileMap>` node to the scene. By default, a TileMap
uses a square grid of tiles. You can also use a perspective-based "Isometric" mode
or define your own custom tile shape.

.. image:: img/tilemap_mode.png

Under the "Cell" section in the Inspector are many properties you can adjust to
customize your tilemap's behavior:

.. image:: img/tilemap_size.png

- ``Cell Size``
    This defines the size of the grid. This should match the pixel size
    of your tiles. The default value is ``(64, 64)``.

- ``YSort``
    This causes tiles to be drawn in order of their ``Y`` position, so that
    "lower" tiles are drawn on top of "higher" ones.

- ``Half Offset`` and ``Tile Origin``
    These properties affect the position of the tile relative to the grid position.

- ``Quadrant``
    Defines the chunk size used for batched drawing. This can negatively
    affect performance. Don't change it unless you know what you're doing.

- ``Custom Transform``
    Used to alter the tile's shape. Use this if you have non-square tiles.

All of these options can be left at their defaults for this demo.

Creating a TileSet
------------------

Once you've configured your tilemap, it's time to add a
:ref:`TileSet <class_TileSet>`. A TileSet is a
:ref:`Resource <class_Resource>` that contains the data about your
tiles - their   textures, collision shapes, and other properties. When the game
runs, the TileMap combines the individual tiles into a single object.

To add a new TileSet, click on the "Tile Set" property and select "New
TileSet".

.. image:: img/tilemap_add_tileset.png

Click on the TileSet property, and the "TileSet" panel will open at the bottom
of the editor window:

.. image:: img/tilemap_tool.png

First, you need to add the texture(s) that you'll use for the tiles. Click the
"Add Texture(s) to TileSet" button and select the ``tilesheet.png`` image.

Next, click "New Single Tile" and drag in the image to select the tile you want.
Click the "Enable Snap" button to make it easier to select the entire tile. A
yellow rectangle appears around the selected tile.

.. image:: img/tilemap_add_tile.png

Click on the TileMap in the scene tree, and you'll see that the newly created
tile now appears on the right side. Click in the viewport and you can place
tiles. Right-click to remove them.

.. image:: img/tilemap_draw.png

It's easy to accidentally select and move the tilemap node. To avoid this, use
the node's lock button:

.. image:: img/tile_lock.png

Collision shapes
----------------

If you're making a map that needs collisions - walls, floor, or other obstacles,
for example - then you'll need to add collision shapes to any tiles that you
want to be considered "solid".

Click "TileSet" at the bottom of the editor window to return to the tileset
tool. Click the tile you previously defined (outlined in yellow). Select the
"Collision" tab and click the "Create a new rectangle" button. Make sure you
still have grid snap enabled, then click and drag in the tile. A square
collision shape appears in light blue:

.. image:: img/tileset_add_collision.png

You can add occlusion and navigation shapes to the tile in the same way.

Atlas tiles
-----------

Rather than adding individual tiles one at a time, you can define a group of
tiles all at once using an atlas. This also allows you to randomly generate
tiles from the group.

Click "New Atlas" and drag to select the entire tile sheet.

.. image:: img/tileset_atlas.png

If you haven't already, make sure to change the "Step" in the snap settings to
`(64, 64)`, or your tiles may be chopped into smaller pieces. You can find
this in the Inspector:

.. image:: img/tileset_snap.png

Once you've defined the atlas you can add collision shapes to the individual
tiles as before. You can also click "Icon" to select one of the tiles to represent
the atlas.

Back in the TileMap, you can select the atlas tile and you'll see all of the
tiles it contains:

.. image:: img/tileset_draw_atlas.png

In addition to saving time when defining the tiles, this can help by grouping
similar tiles together when you're working with a large number of tiles.

Random tile priorities
~~~~~~~~~~~~~~~~~~~~~~

When drawing with atlas tiles, enabling the "Use priority" option causes tiles
to be selected at random. By default, each tile in the tileset has an equal
likelihood of occurring. You can change the likelihood by setting different
priorities for each tile. For example, a tile with priority 2 is twice as
likely to be selected as a tile with priority 1, and a tile with priority 3 is
50% more likely to be selected than a tile with priority 2.

Autotiles
---------

Autotiles allow you to define a group of tiles, then add rules to control which
tile gets used for drawing based on the content of adjacent cells.

Click "New Autotile" and drag to select the tiles you wish to use. You can add
collisions, occlusion, navigation shapes, tile priorities, and select an icon
tile in the same manner as for atlas tiles.

Tile selection is controlled by bitmasks. Bitmasks can be added by clicking
"Bitmask", then clicking parts of the tiles to add or remove bits in the mask.
Left-clicking an area of the tile adds a bit, right-click removes "off",
and shift-left-click sets an "ignore" bit.

Whenever Godot updates a cell using an autotile, it first creates a pattern
based on which adjacent cells are already set. Then, it searches the autotile
for a single tile with a bitmask matching the created pattern. If no matching
bitmask is found, the "icon" tile will be used instead. If more than one
matching bitmask is found, one of them will be selected randomly, using the
tile priorities.

The rules for matching a bitmask to a pattern depend on the tileset's autotile
bitmask mode. This can be set in the "Inspector" tab, under the "Selected Tile"
heading. Allowed values are "2x2", "3x3 (minimal)", and "3x3".

All "on" and "off" bits must be satisfied for a bitmask to match, but "ignore"
bits are ignored.

2x2
~~~

In 2x2 mode, each bitmask contains four bits, one for each corner.

Where a bit is "on", all cells connected to that corner must be filled using
the same autotile, in order for the bitmask to match.
For example, if the top-left bit is set, the cell directly above,
directly left, and diagonally above-left must be filled.

Where a bit is "off", at least one cell connected to that corner must not be
set using the same autotile.

At least one bit must be set for the tile to be used, so a total of 15 tiles
would be needed to provide exactly one tile for each arrangement that this mode
can test for.

2x2 mode can only match cells that are part of a 2-by-2 block - cells with no
neighbors and lines only one cell wide are not supported.

**Template - Generic:**

This template can be used for sideways or fully top-down perspectives.
It's designed for a TileMap cell size of 64x64.

Key:

- Red: "on"
- White: "off"

.. image:: img/autotile_template_2x2.png

3x3 (minimal)
~~~~~~~~~~~~~

In 3x3 (minimal) mode, each bitmask contains 9 bits (4 corners, 4 edges,
1 center). The 4 corner bits work the same as in 2x2 mode.

When an edge bit is "on", the cell which shares that edge must be filled.
When an edge bit is "off", the cell which shares that edge must be empty.

The center bit should be "on" for any tile you wish to use. Note that in this
mode, it makes no sense for a corner bit to be "on" when either edge bit
adjacent to it is not "on".

A total of 47 tiles would be needed to provide exactly one bitmask for each
arrangement that this mode can test for.

.. note::

    Right-click an image and choose **Save image as…** to save it.

**Template - Generic:**

This template can be used for sideways or fully top-down perspectives.
All templates below are designed for a TileMap cell size of 64x64, but you may
have to use different subtile sizes for top-down templates as described below.

Key:

- Red: "on"
- White: "off"

.. image:: img/autotile_template_3x3_minimal.png


**Template - Generic 16 tiles:**

This template can be used for tilesets that only have 16 tiles - for simpler art
styles the missing tiles will not be noticeable.

Key:

- Red: "on"
- White: "off"
- Blue-checkered: "ignore"

.. image:: img/autotile_template_3x3_minimal_16.png


**Template - Top-down floor in 3/4 perspective:**

Key (applies to the four templates below):

- Green: floor
- Cyan: wall
- Yellow: top of wall
- Grey: hidden due to overlap
- Transparent: air

.. image:: img/autotile_template_3x3_minimal_topdown_floor.png

**Template - Top-down wall in 3/4 perspective:**

.. image:: img/autotile_template_3x3_minimal_topdown_walls.png

**Template - Top-down wall in 3/4 perspective (thick walls):**

When using this template, set the TileSet subtile size to ``Vector2(64, 88)``.

.. image:: img/autotile_template_3x3_minimal_topdown_walls_thick.png

**Template - Top-down wall in 3/4 perspective (tall walls):**

When using this template, set the "Snap Options" Step to ``Vector2(64, 184)``
and the "Selected Tile" Texture offset to height minus the cell size.
This means the texture offset should be ``Vector2(0, -120)``:

.. image:: img/autotile_template_3x3_minimal_topdown_walls_tall.png

3x3
~~~

In 3x3 mode, each bitmask contains 9 bits (4 corners, 4 edges, 1 center)

Each bit checks a single adjacent cell. Corner bits only check diagonally
adjacent cells. The center bit should be "on" for any tile you wish to use.

A total of 256 tiles would be needed to provide exactly one bitmask for each
arrangement that this mode can test for.


Disabling autotile
~~~~~~~~~~~~~~~~~~

When using an autotile, it is possible to turn off the autotile behaviour and
select tiles manually, by clicking "Disable Autotile" at the top of the tile
selection window.

Autotile binding
~~~~~~~~~~~~~~~~

By default, autotile only checks for adjacent cells filled using the same
autotile. This behaviour can be overridden in order to have autotiles bind to
each other, or even bind to empty cells. At present, this can only be done
through scripting. You will need to add a script to your tileset, and define
a function named "_is_tile_bound(drawn_id, neighbor_id)". This function will
be called for each adjacent cell that does not contain the same autotile, and
should return true if you want the drawn cell to "bind" to the neighbor cell.
You can find the id of an autotile using "find_tile_by_name(name)", empty cells
are given an id of -1.

Note that to use this in the editor, the script should start with a "tool"
declaration, and you may need to close and reload the scene for these changes
to take effect.

Tips and tricks
---------------

- If you're using a :ref:`Camera2D <class_Camera2D>` to scroll your level, you
  may notice lines appearing between your tiles. To fix this, open Project
  Settings and enable **Use Gpu Pixel Snap** in the **Rendering > 2d > Snapping** section.

- You can flip and rotate tiles using the icons at the top right of the editor.

- To draw straight lines, hold :kbd:`Shift` while clicking and dragging a tile.

- Tools such as copy, paste, and bucket fill, can be found in the "TileMap"
  menu in the upper-right.

.. image:: img/tilemap_menu.png


===================================================
/. ./tutorials/2d/particle_systems_2d.rst
===================================================

.. _doc_particle_systems_2d:

Particle systems (2D)
=====================

Intro
-----

A simple (but flexible enough for most uses) particle system is
provided. Particle systems are used to simulate complex physical effects,
such as sparks, fire, magic particles, smoke, mist, etc.

The idea is that a "particle" is emitted at a fixed interval and with a
fixed lifetime. During its lifetime, every particle will have the same
base behavior. What makes each particle different from the rest and provides a more
organic look is the "randomness" associated with each parameter. In
essence, creating a particle system means setting base physics
parameters and then adding randomness to them.

Particle nodes
~~~~~~~~~~~~~~

Godot provides two different nodes for 2D particles, :ref:`class_Particles2D` and
:ref:`class_CPUParticles2D`.
Particles2D is more advanced and uses the GPU to process particle effects, but that limits
it to higher end graphics API, and in our case to the GLES3 renderer. For projects using
the GLES2 backend, CPUParticles2D is a CPU-driven option with near feature parity with
Particles2D, but lesser performance. While Particles2D is configured via a
:ref:`class_ParticlesMaterial` (and optionally with a custom shader), the matching options
are provided via node properties in CPUParticles2D (with the exception of the trail settings).
You can convert a Particles2D node into a CPUParticles2D node by clicking on the node in the
inspector, and selecting "Convert to CPUParticles2D" in the "Particles" menu of the toolbar.

.. image:: img/particles_convert.png

The rest of this tutorial is going to use the Particles2D node. First, add a Particles2D
node to your scene. After creating that node you will notice that only a white dot was created,
and that there is a warning icon next to your Particles2D node in the scene dock. This
is because the node needs a ParticlesMaterial to function.

ParticlesMaterial
~~~~~~~~~~~~~~~~~

To add a process material to your particles node, go to ``Process Material`` in
your inspector panel. Click on the box next to ``Material``, and from the dropdown
menu select ``New ParticlesMaterial``.

.. image:: img/particles_material.png

Your Particles2D node should now be emitting
white points downward.

.. image:: img/particles1.png

Texture
~~~~~~~

A particle system uses a single texture (in the future this might be
extended to animated textures via spritesheet). The texture is set via
the relevant texture property:

.. image:: img/particles2.png

Time parameters
---------------

Lifetime
~~~~~~~~

The time in seconds that every particle will stay alive. When lifetime
ends, a new particle is created to replace it.

Lifetime: 0.5

.. image:: img/paranim14.gif

Lifetime: 4.0

.. image:: img/paranim15.gif

One Shot
~~~~~~~~

When enabled, a Particles2D node will emit all of its particles once
and then never again.

Preprocess
~~~~~~~~~~

Particle systems begin with zero particles emitted, then start emitting.
This can be an inconvenience when loading a scene and systems like
a torch, mist, etc. begin emitting the moment you enter. Preprocess is
used to let the system process a given number of seconds before it is
actually drawn the first time.

Speed Scale
~~~~~~~~~~~

The speed scale has a default value of ``1`` and is used to adjust the
speed of a particle system. Lowering the value will make the particles
slower while increasing the value will make the particles much faster.

Explosiveness
~~~~~~~~~~~~~

If lifetime is ``1`` and there are 10 particles, it means a particle
will be emitted every 0.1 seconds. The explosiveness parameter changes
this, and forces particles to be emitted all together. Ranges are:

-  0: Emit particles at regular intervals (default value).
-  1: Emit all particles simultaneously.

Values in the middle are also allowed. This feature is useful for
creating explosions or sudden bursts of particles:

.. image:: img/paranim18.gif

Randomness
~~~~~~~~~~

All physics parameters can be randomized. Random values range from ``0`` to
``1``. The formula to randomize a parameter is:

::

    initial_value = param_value + param_value * randomness

Fixed FPS
~~~~~~~~~

This setting can be used to set the particle system to render at a fixed
FPS. For instance, changing the value to ``2`` will make the particles render
at 2 frames per second. Note this does not slow down the particle system itself.

Fract Delta
~~~~~~~~~~~

This can be used to turn Fract Delta on or off.

Drawing parameters
------------------

Visibility Rect
~~~~~~~~~~~~~~~


The visibility rectangle controls the visibility of the particles on screen. If this rectangle is outside of the viewport, the engine will not render the particles on screen.

The rectangle's ``W`` and ``H`` properties respectively control its Width and its Height.
The ``X`` and ``Y`` properties control the position of the upper-left
corner of the rectangle, relative to the particle emitter.

You can have Godot generate a Visibility Rect automatically using the toolbar above the 2d view. To do so, select the Particles2D node and Click ``Particles > Generate Visibility Rect``. Godot will simulate the Particles2D node emitting particles for a few seconds and set the rectangle to fit the surface the particles take.

You can control the emit duration with the ``Generation Time (sec)`` option. The maximum value is 25 seconds. If you need more time for your particles to move around, you can temporarily change the ``preprocess`` duration on the Particles2D node.

Local Coords
~~~~~~~~~~~~

By default this option is on, and it means that the space that particles
are emitted to is relative to the node. If the node is moved, all
particles are moved with it:

.. image:: img/paranim20.gif

If disabled, particles will emit to global space, meaning that if the
node is moved, already emitted particles are not affected:

.. image:: img/paranim21.gif

Draw Order
~~~~~~~~~~

This controls the order in which individual particles are drawn. ``Index``
means particles are drawn according to their emission order (default).
``Lifetime`` means they are drawn in order of remaining lifetime.

ParticlesMaterial settings
--------------------------

Direction
~~~~~~~~~

This is the base direction at which particles emit. The default is
``Vector3(1, 0, 0)`` which makes particles emit to the right. However,
with the default gravity settings, particles will go straight down.

.. image:: img/direction1.png

For this property to be noticeable, you need an *initial velocity* greater
than 0. Here, we set the initial velocity to 40. You'll notice that
particles emit toward the right, then go down because of gravity.

.. image:: img/direction2.png

Spread
~~~~~~

This parameter is the angle in degrees which will be randomly added in
either direction to the base ``Direction``. A spread of ``180`` will emit
in all directions (+/- 180). For spread to do anything the "Initial Velocity"
parameter must be greater than 0.

.. image:: img/paranim3.gif

Flatness
~~~~~~~~

This property is only useful for 3D particles.

Gravity
~~~~~~~

The gravity applied to every particle.

.. image:: img/paranim7.gif

Initial Velocity
~~~~~~~~~~~~~~~~

Initial velocity is the speed at which particles will be emitted (in
pixels/sec). Speed might later be modified by gravity or other
accelerations (as described further below).

.. image:: img/paranim4.gif

Angular Velocity
~~~~~~~~~~~~~~~~

Angular velocity is the initial angular velocity applied to particles.

Spin Velocity
~~~~~~~~~~~~~

Spin velocity is the speed at which particles turn around their center
(in degrees/sec).

.. image:: img/paranim5.gif

Orbit Velocity
~~~~~~~~~~~~~~

Orbit velocity is used to make particles turn around their center.

.. image:: img/paranim6.gif

Linear Acceleration
~~~~~~~~~~~~~~~~~~~

The linear acceleration applied to each particle.

Radial Acceleration
~~~~~~~~~~~~~~~~~~~

If this acceleration is positive, particles are accelerated away from
the center. If negative, they are absorbed towards it.

.. image:: img/paranim8.gif

Tangential Acceleration
~~~~~~~~~~~~~~~~~~~~~~~

This acceleration will use the tangent vector to the center. Combining
with radial acceleration can do nice effects.

.. image:: img/paranim9.gif

Damping
~~~~~~~

Damping applies friction to the particles, forcing them to stop. It is
especially useful for sparks or explosions, which usually begin with a
high linear velocity and then stop as they fade.

.. image:: img/paranim10.gif

Angle
~~~~~

Determines the initial angle of the particle (in degrees). This parameter
is mostly useful randomized.

.. image:: img/paranim11.gif

Scale
~~~~~

Determines the initial scale of the particles.

.. image:: img/paranim12.gif

Color
~~~~~

Used to change the color of the particles being emitted.

Hue variation
~~~~~~~~~~~~~

The ``Variation`` value sets the initial hue variation applied to each
particle. The ``Variation Random`` value controls the hue variation
randomness ratio.

Emission Shapes
---------------

ParticlesMaterials allow you to set an Emission Mask, which dictates
the area and direction in which particles are emitted.
These can be generated from textures in your project.

Ensure that a ParticlesMaterial is set, and the Particles2D node is selected.
A "Particles" menu should appear in the Toolbar:

.. image:: img/emission_shapes1.png

Open it and select "Load Emission Mask":

.. image:: img/emission_shapes2.png

Then select which texture you want to use as your mask:

.. image:: img/emission_shapes3.png

A dialog box with several settings will appear.

Emission Mask
~~~~~~~~~~~~~

Three types of emission masks can be generated from a texture:

-  Solid Pixels: Particles will spawn from any area of the texture,
   excluding transparent areas.

.. image:: img/emission_mask_solid.gif

-  Border Pixels: Particles will spawn from the outer edges of the texture.

.. image:: img/emission_mask_border.gif

-  Directed Border Pixels: Similar to Border Pixels, but adds extra
   information to the mask to give particles the ability to emit away
   from the borders. Note that an ``Initial Velocity`` will need to
   be set in order to utilize this.

.. image:: img/emission_mask_directed_border.gif

Emission Colors
~~~~~~~~~~~~~~~

``Capture from Pixel`` will cause the particles to inherit the color of the mask at their spawn points.

Once you click "OK", the mask will be generated and set to the ParticlesMaterial, under the ``Emission Shape`` section:

.. image:: img/emission_shapes4.png

All of the values within this section have been automatically generated by the
"Load Emission Mask" menu, so they should generally be left alone.

.. note:: An image should not be added to ``Point Texture`` or ``Color Texture`` directly.
          The "Load Emission Mask" menu should always be used instead.


===================================================
/. ./tutorials/2d/2d_movement.rst
===================================================

.. _doc_2d_movement:

2D movement overview
====================

Introduction
------------

Every beginner has been there: "How do I move my character?" Depending on the
style of game you're making, you may have special requirements, but in general
the movement in most 2D games is based on a small number of designs.

We'll use :ref:`KinematicBody2D <class_KinematicBody2D>` for these examples,
but the principles will apply to other node types (Area2D, RigidBody2D) as well.

.. _doc_2d_movement_setup:

Setup
-----

Each example below uses the same scene setup. Start with a ``KinematicBody2D`` with two
children: ``Sprite`` and ``CollisionShape2D``. You can use the Godot icon ("icon.png")
for the Sprite's texture or use any other 2D image you have.

Open ``Project -> Project Settings`` and select the "Input Map" tab. Add the following
input actions (see :ref:`InputEvent <doc_inputevent>` for details):

.. image:: img/movement_inputs.png

8-way movement
--------------

In this scenario, you want the user to press the four directional keys (up/left/down/right
or W/A/S/D) and move in the selected direction. The name "8-way movement" comes from the
fact that the player can move diagonally by pressing two keys at the same time.

.. image:: img/movement_8way.gif

Add a script to the kinematic body and add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    export (int) var speed = 200

    var velocity = Vector2()

    func get_input():
        velocity = Vector2()
        if Input.is_action_pressed("right"):
            velocity.x += 1
        if Input.is_action_pressed("left"):
            velocity.x -= 1
        if Input.is_action_pressed("down"):
            velocity.y += 1
        if Input.is_action_pressed("up"):
            velocity.y -= 1
        velocity = velocity.normalized() * speed

    func _physics_process(delta):
        get_input()
        velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Movement : KinematicBody2D
    {
        [Export] public int speed = 200;

        public Vector2 velocity = new Vector2();

        public void GetInput()
        {
            velocity = new Vector2();

            if (Input.IsActionPressed("right"))
                velocity.x += 1;

            if (Input.IsActionPressed("left"))
                velocity.x -= 1;

            if (Input.IsActionPressed("down"))
                velocity.y += 1;

            if (Input.IsActionPressed("up"))
                velocity.y -= 1;

            velocity = velocity.Normalized() * speed;
        }

        public override void _PhysicsProcess(float delta)
        {
            GetInput();
            velocity = MoveAndSlide(velocity);
        }
    }

In the ``get_input()`` function, we check for the four key events and sum them
up to get the velocity vector. This has the benefit of making two opposite keys
cancel each other out, but will also result in diagonal movement being faster
due to the two directions being added together.

We can prevent that if we *normalize* the velocity, which means we set
its *length* to ``1``, and multiply by the desired speed.

.. tip:: If you've never used vector math before, or need a refresher,
         you can see an explanation of vector usage in Godot at :ref:`doc_vector_math`.

.. note::

    If the code above does nothing when you press the keys, double-check that
    you've set up input actions correctly as described in the
    :ref:`doc_2d_movement_setup` part of this tutorial.

Rotation + movement
-------------------

This type of movement is sometimes called "Asteroids-style" because it resembles
how that classic arcade game worked. Pressing left/right rotates the character,
while up/down moves it forward or backward in whatever direction it's facing.

.. image:: img/movement_rotate1.gif

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    export (int) var speed = 200
    export (float) var rotation_speed = 1.5

    var velocity = Vector2()
    var rotation_dir = 0

    func get_input():
        rotation_dir = 0
        velocity = Vector2()
        if Input.is_action_pressed("right"):
            rotation_dir += 1
        if Input.is_action_pressed("left"):
            rotation_dir -= 1
        if Input.is_action_pressed("down"):
            velocity = Vector2(-speed, 0).rotated(rotation)
        if Input.is_action_pressed("up"):
            velocity = Vector2(speed, 0).rotated(rotation)

    func _physics_process(delta):
        get_input()
        rotation += rotation_dir * rotation_speed * delta
        velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Movement : KinematicBody2D
    {
        [Export] public int speed = 200;
        [Export] public float rotationSpeed = 1.5f;

        public Vector2 velocity = new Vector2();
        public int rotationDir = 0;

        public void GetInput()
        {
            rotationDir = 0;
            velocity = new Vector2();

            if (Input.IsActionPressed("right"))
                rotationDir += 1;

            if (Input.IsActionPressed("left"))
                rotationDir -= 1;

            if (Input.IsActionPressed("down"))
                velocity = new Vector2(-speed, 0).Rotated(Rotation);

            if (Input.IsActionPressed("up"))
                velocity = new Vector2(speed, 0).Rotated(Rotation);

            velocity = velocity.Normalized() * speed;
        }

        public override void _PhysicsProcess(float delta)
        {
            GetInput();
            Rotation += rotationDir * rotationSpeed * delta;
            velocity = MoveAndSlide(velocity);
        }
    }

Here we've added two new variables to track our rotation direction and speed.
Again, pressing both keys at once will cancel out and result in no rotation.
The rotation is applied directly to the body's ``rotation`` property.

To set the velocity, we use the ``Vector2.rotated()`` method, so that it points
in the same direction as the body. ``rotated()`` is a useful vector function
that you can use in many circumstances where you would otherwise need to apply
trigonometric functions.

Rotation + movement (mouse)
---------------------------

This style of movement is a variation of the previous one. This time, the direction
is set by the mouse position instead of the keyboard. The character will always
"look at" the mouse pointer. The forward/back inputs remain the same, however.

.. image:: img/movement_rotate2.gif

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    export (int) var speed = 200

    var velocity = Vector2()

    func get_input():
        look_at(get_global_mouse_position())
        velocity = Vector2()
        if Input.is_action_pressed("down"):
            velocity = Vector2(-speed, 0).rotated(rotation)
        if Input.is_action_pressed("up"):
            velocity = Vector2(speed, 0).rotated(rotation)

    func _physics_process(delta):
        get_input()
        velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Movement : KinematicBody2D
    {
        [Export] public int speed = 200;

        public Vector2 velocity = new Vector2();

        public void GetInput()
        {
            LookAt(GetGlobalMousePosition());
            velocity = new Vector2();

            if (Input.IsActionPressed("down"))
                velocity = new Vector2(-speed, 0).Rotated(Rotation);

            if (Input.IsActionPressed("up"))
                velocity = new Vector2(speed, 0).Rotated(Rotation);

            velocity = velocity.Normalized() * speed;
        }

        public override void _PhysicsProcess(float delta)
        {
            GetInput();
            velocity = MoveAndSlide(velocity);
        }
    }

Here we're using the :ref:`Node2D <class_Node2D>` ``look_at()`` method to
point the player towards a given position. Without this function, you
could get the same effect by setting the angle like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    rotation = get_global_mouse_position().angle_to_point(position)

 .. code-tab:: csharp

    var rotation = GetGlobalMousePosition().AngleToPoint(Position);


Click-and-move
--------------

This last example uses only the mouse to control the character. Clicking
on the screen will cause the player to move to the target location.

.. image:: img/movement_click.gif

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    export (int) var speed = 200

    onready var target = position
    var velocity = Vector2()

    func _input(event):
        if event.is_action_pressed("click"):
            target = get_global_mouse_position()

    func _physics_process(delta):
        velocity = position.direction_to(target) * speed
        # look_at(target)
        if position.distance_to(target) > 5:
            velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Movement : KinematicBody2D
    {
        [Export] public int speed = 200;

        public Vector2 target;
        public Vector2 velocity = new Vector2();

        public override void _Ready()
        {
            target = Position;
        }

        public override void _Input(InputEvent @event)
        {
            if (@event.IsActionPressed("click"))
            {
                target = GetGlobalMousePosition();
            }
        }

        public override void _PhysicsProcess(float delta)
        {
            velocity = Position.DirectionTo(target) * speed;
            // LookAt(target);
            if (Position.DistanceTo(target) > 5)
            {
                velocity = MoveAndSlide(velocity);
            }
        }
    }


Note the ``distance_to()`` check we make prior to movement. Without this test,
the body would "jitter" upon reaching the target position, as it moves
slightly past the position and tries to move back, only to move too far and
repeat.

Uncommenting the ``look_at()`` line will also turn the body to point in its
direction of motion if you prefer.

.. tip:: This technique can also be used as the basis of a "following" character.
         The ``target`` position can be that of any object you want to move to.

Summary
-------

You may find these code samples useful as starting points for your own projects.
Feel free to use them and experiment with them to see what you can make.

You can download this sample project here:
:download:`2D_movement_demo.zip <files/2D_movement_demo.zip>`


===================================================
/. ./tutorials/2d/2d_lights_and_shadows.rst
===================================================

.. _doc_2d_lights_and_shadows:

2D lights and shadows
=====================

Introduction
------------

This tutorial explains how the 2D lighting works in the
`lights and shadows <https://github.com/godotengine/godot-demo-projects/tree/master/2d/lights_and_shadows>`_ demo project.
It begins with a brief description of the resources used in the final demo and then describes how
to make a scene like the demo step by step.

.. image:: img/light_shadow_main.png

All the resources for this tutorial can be found in the `official demo repository <https://github.com/godotengine/godot-demo-projects>`_
on GitHub. I suggest you download it before starting. Alternatively,
it can be downloaded from the Project Manager. Launch Godot and in the top
bar select "Templates" and search for "2D Lights and Shadows Demo".

Setup
-----

For this demo we use four textures: two for the lights, one for the shadow casters,
and one for the background. I've included links to them all here if you want to download them
separately from the demo.

The first is the background image (`background.png <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/background.png>`_)
used in the demo. You do not necessarily need a background, but we use one for the demo.

The second is a plain black image (`caster.png <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/caster.png>`_)
to use as our shadow caster object. For a top down game this could be a wall or any
other object that casts a shadow.

Next is the light itself (`light.png <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/light.png>`_).
If you click the link you will notice how large it is. The image you use
for a light should cover the area you want your light to cover. This image is
1024x1024 pixels, so you should use it to cover 1024x1024 pixels in your game.

Lastly, we have the spotlight image (`spot.png <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/spot.png>`_).
The demo uses a blob to show where the light is and the larger light
image to show the effect of the light upon the rest of the scene.


Nodes
-----

The demo uses four different nodes:
  * :ref:`CanvasModulate <class_CanvasModulate>`
  * :ref:`Sprite <class_Sprite>`
  * :ref:`Light2D <class_Light2D>`
  * :ref:`LightOccluder2D <class_LightOccluder2D>`

:ref:`CanvasModulate<class_CanvasModulate>` is used to darken the scene.

:ref:`Sprites <class_Sprite>` are used to display the textures for the light blobs, the
background, and for the shadow casters.

:ref:`Light2Ds <class_Light2D>` are used to light the scene. The way a light typically works
is by adding a selected texture over the rest of the scene to simulate lighting. But it can be
used in other ways, for example masking out parts of the scene.

:ref:`LightOccluder2Ds <class_LightOccluder2D>` are used to tell the shader which parts of
the scene cast shadows. The shadows appear only on areas covered by the :ref:`Light2D <class_Light2D>` and
their direction is based on the center of the :ref:`Light <class_Light2D>`.

Lights
------

:ref:`Lights <class_Light2D>` cover the entire extent of their respective Texture. They use additive
blending to add the color of their texture to the scene.

.. image:: img/light_shadow_light.png

:ref:`Lights <class_Light2D>` have four ``Modes``: ``Add``, ``Sub``, ``Mix``, and ``Mask``.

``Add`` adds the color of the light texture to the scene. It brightens the area under the light.

``Sub`` subtracts the color of the light from the scene. It darkens the area under the light.

``Mix`` mixes the color of the light with the underlying scene. The resulting brightness is
halfway between the color of the light and the color underneath.

``Mask`` is used to mask out areas that are covered by the light. Masked out areas are hidden or revealed based on
the color of the light.

For the demo the lights have two components, the :ref:`Light <class_Light2D>` itself (which
is the effect of the light), and a :ref:`Sprite <class_Sprite>` blob which is an image showing the
location of the light source. A child :ref:`Sprite <class_Sprite>` is not necessary to make a
:ref:`Light <class_Light2D>` work.

.. image:: img/light_shadow_light_blob.png

Shadows
-------

Shadows are made by intersecting a :ref:`Light <class_Light2D>` with a :ref:`LightOccluder2D <class_LightOccluder2D>`.

By default shadows are turned off. To turn them on click on the :ref:`Light <class_Light2D>`
and under the Shadows section check ``Enabled``.

In the demo we are using a :ref:`Sprite <class_Sprite>` with a Texture on it to make the "Shadow Casters",
but in reality all you need is a couple of :ref:`LightOccluder2Ds <class_LightOccluder2D>`. By itself
the :ref:`LightOccluder2D <class_LightOccluder2D>` looks like a dark spot and in this demo the :ref:`Sprite <class_Sprite>` is
just a black square.

Step by step
------------

Now that we have covered the basics of the nodes being used, we can now walk step by step through
the process of making a scene like the one found in the demo.

First add a :ref:`Sprite <class_Sprite>` and set its texture to the `background image <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/background.png>`_. For your game this can be any
background you choose. For this style of shadow it is most likely to be a floor texture.

.. image:: img/light_shadow_background.png

Next create three :ref:`Light2D's <class_Light2D>` and set their textures to the `light image <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/light.png>`_. You can alter their
color in the top section. By default shadows are turned off and the ``mode`` is set to ``add``. This
means that each light adds its own color to whatever is underneath.

.. image:: img/light_shadow_all_lights_no_blob.png

Next add a child :ref:`Sprite <class_Sprite>` to each of the :ref:`Light <class_Light2D>` nodes, and set
the :ref:`Sprite's <class_Sprite>` texture to the `blob image <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/spot.png>`_. Each of these
should stay centered on the :ref:`Light <class_Light2D>` node. The blob is the image of the light
itself while the :ref:`Light <class_Light2D>` shows the effect that the light has on the scene. The
:ref:`LightOccluder2D's <class_LightOccluder2D>` will treat the position of the light as the center of the :ref:`Light <class_Light2D>`
node, which is why we want the blob to be centered on its parent :ref:`Light <class_Light2D>`.

.. image:: img/light_shadow_all_lights.png

.. note:: The animations in the demo will not be covered here. See :ref:`doc_introduction_animation`
          for information on creating animations.

Right now the scene should look too bright. This is because all three lights are adding color to the scene.
This is why the demo uses a :ref:`CanvasModulate <class_CanvasModulate>` in the scene. The
:ref:`CanvasModulate <class_CanvasModulate>` multiples the entire viewport by a specific color.

Add a :ref:`CanvasModulate <class_CanvasModulate>` to the scene and set its color to ``rgb(70, 70, 70)``.
This will make the scene sufficiently dark to see the effects of the lights distinctly.

.. image:: img/light_shadow_ambient.png

Now we add the shadow casters.

The demo uses a :ref:`Node <class_Node2D>` named "casters" to organize the shadow casters. Add a
:ref:`Node2D <class_Node2D>` to the scene. It will be used to group all the shadow casters together.
This way we can show and hide them all at the same time.

Each shadow caster is made of a :ref:`Sprite <class_Sprite>`, with a :ref:`LightOccluder2D <class_LightOccluder2D>`
child. For the demo the :ref:`Sprite <class_Sprite>` has a texture
set to the `caster image <https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/caster.png>`_ and nothing else. The child :ref:`LightOccluder2D <class_LightOccluder2D>` is where all the magic happens. In a
game the :ref:`Sprite <class_Sprite>` could be more than a black box; it could be an image of whatever object is casting
the shadow: a wall, a magical chest, or anything else.

.. image:: img/light_shadow_sprites.png

:ref:`LightOccluder2Ds <class_LightOccluder2D>` tell the game what shape the occluder has. They hold
an :ref:`OccluderPolygon2D <class_OccluderPolygon2D>`, which is a container
for a polygon and some other information. For this demo, since our wall is a square, we
set ``Polygon`` to a square. The other default settings are fine.

The first setting, ``Closed`` can be either ``on`` or ``off``. A closed polygon occludes light
coming from all directions. An open polygon only occludes light from one direction.

``Cull Mode`` lets you select which direction gets culled. The default is ``Disabled``, meaning the occluder
will cast a shadow no matter which side the light is on. The other two settings ``Clockwise`` and
``Counter-Clockwise`` refer to the winding order of the vertices of the polygon. The winding order
is used to determine which side of the line is inside the polygon. Only outward facing lines cast shadows.

To illustrate the difference, here is an image of a :ref:`LightOccluder2D <class_LightOccluder2D>` with ``Closed``
set to ``off`` in the corresponding :ref:`OccluderPolygon2D <class_OccluderPolygon2D>`, so that the
lines of the polygon can be seen:

.. image:: img/light_shadow_cull_disabled.png

.. note:: ``Cull Mode`` is set to ``Disabled``. All three lines cast shadows.

.. image:: img/light_shadow_cull_clockwise.png

.. note:: ``Cull Mode`` is set to ``Clockwise``. Only the top and right lines cast shadows.

.. image:: img/light_shadow_cull_counter_clockwise.png

.. note:: ``Cull Mode`` is set to ``Counter-Clockwise``. Only the bottom line casts a shadow.
          If ``Closed`` was set to ``on`` there would be an additional vertical line on the
          left which would cast a shadow as well.

When you have added the :ref:`LightOccluder2Ds <class_LightOccluder2D>` the shadows still won't
appear. You need to go back into the :ref:`Light2Ds <class_Light2D>` and under the Shadow
section set ``Enable`` to ``on``. This turns on shadows with hard edges like in the image below.

.. image:: img/light_shadow_filter0_pcf0.png

To give the shadows that nice, soft edge look we set the variables ``filter``, ``filter smooth``, and
``gradient length``. Godot supports `Percentage Closer Filtering <https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html>`_
(PCF), which takes multiple samples of the shadow map around a pixel and blurs them to create
a smooth shadow effect. The higher the number of samples the smoother the shadow will
look, but the slower it will run. That is why Godot provides 3-13 samples by default and allows you to choose.
The demo uses PCF7.

.. image:: img/light_shadow_normal.png

.. note:: This is a shadow rendered with the demo's settings. ``gradient length`` is set
          to ``1.3``, ``filter smooth`` is set to ``11.1``, and ``filter`` is set to ``PCF7``.

.. image:: img/light_shadow_pcf13.png

.. note:: ``filter`` is set to ``PCF13``. Notice how the shadow becomes wider, this is because the
          distance between samples is based on the variable ``filter smooth``.

In order to make use of filtering you need to set the ``filter smooth`` variable.
This dictates how far apart the samples are. If you want the soft area to extend quite far, you can increase
the size of ``filter smooth``. However, with few samples and a large filter smooth, you can see lines
forming between the samples.

.. image:: img/light_shadow_filter30.png

.. note:: ``filter smooth`` is set to ``30``.

The different :ref:`Light <class_Light2D>` nodes in the demo use different values for filter smooth.
Play around with it and see what you like.

.. image:: img/light_shadow_filter0.png

.. note:: ``filter smooth`` is set to ``0``.

Lastly, there is the variable ``gradient length``. For some smooth shadows it is preferable not to have the
shadow start immediately on the object, as this produces a hard edge. The gradient length variable creates
a smooth gradient to begin the shadow to reduce the effect of the hard edge.

.. image:: img/light_shadow_grad0.png

.. note:: ``gradient length`` is set to ``0``.

.. image:: img/light_shadow_grad10.png

.. note:: ``gradient length`` is set to ``10``.

You will need to play around with the options a bit to find settings that suit your project. There is no right solution
for everyone, which is why Godot provides so much flexibility. Just keep in mind that the higher ``filter``
set the more expensive the shadows will be.


===================================================
/. ./tutorials/2d/2d_meshes.rst
===================================================

.. _doc_2d_meshes:

2D meshes
=========

Introduction
------------

In 3D, meshes are used to display the world. In 2D, they are rare as images are used more often.
Godot's 2D engine is a pure two-dimensional engine, so it can't really display 3D meshes directly (although it can be done
via ``Viewport`` and ``ViewportTexture``).

.. seealso:: If you are interested in displaying 3D meshes on a 2D viewport, see the :ref:`doc_viewport_as_texture` tutorial.

2D meshes are meshes that contain two-dimensional geometry (Z can be omitted or ignored) instead of 3D.
You can experiment creating them yourself using ``SurfaceTool`` from code and displaying them in a ``MeshInstance2D`` node.

Currently, the only way to generate a 2D mesh within the editor is by either importing an OBJ file as a mesh, or converting it from a Sprite.

Optimizing pixels drawn
-----------------------

This workflow is useful for optimizing 2D drawing in some situations. When drawing large images with transparency, Godot will draw the whole quad to the screen. The large transparent areas will still be drawn.

This can affect performance, especially on mobile devices, when drawing very large images (generally screen sized),
or layering multiple images on top of each other with large transparent areas (for example, when using ``ParallaxBackground``).

Converting to a mesh will ensure that only the opaque parts will be drawn and the rest will be ignored.

Converting Sprites to 2D meshes
-------------------------------

You can take advantage of this optimization by converting a ``Sprite`` to a ``MeshInstance2D``.
Start with an image that contains large amounts of transparency on the edges, like this tree:

.. image:: img/mesh2d1.png

Put it in a ``Sprite`` and select "Convert to 2D Mesh" from the menu:

.. image:: img/mesh2d2.png

A dialog will appear, showing a preview of how the 2D mesh will be created:

.. image:: img/mesh2d3.png

The default values are good enough for many cases, but you can change growth and simplification according to your needs:

.. image:: img/mesh2d4.png

Finally, push the ``Convert 2D Mesh`` button and your Sprite will be replaced:

.. image:: img/mesh2d5.png


===================================================
/. ./tutorials/2d/custom_drawing_in_2d.rst
===================================================

.. _doc_custom_drawing_in_2d:

Custom drawing in 2D
====================

Introduction
------------

Godot has nodes to draw sprites, polygons, particles, and all sorts of
stuff. For most cases, this is enough; but not always. Before crying in fear,
angst, and rage because a node to draw that specific *something* does not exist...
it would be good to know that it is possible to easily make any 2D node (be it
:ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`
based) draw custom commands. It is *really* easy to do it, too.

Custom drawing in a 2D node is *really* useful. Here are some use cases:

-  Drawing shapes or logic that existing nodes can't do, such as an image
   with trails or a special animated polygon.
-  Visualizations that are not that compatible with nodes, such as a
   tetris board. (The tetris example uses a custom draw function to draw
   the blocks.)
-  Drawing a large number of simple objects. Custom drawing avoids the
   overhead of using a large number of nodes, possibly lowering memory
   usage and improving performance.
-  Making a custom UI control. There are plenty of controls available,
   but when you have unusual needs, you will likely need a custom
   control.

Drawing
-------

Add a script to any :ref:`CanvasItem <class_CanvasItem>`
derived node, like :ref:`Control <class_Control>` or
:ref:`Node2D <class_Node2D>`. Then override the ``_draw()`` function.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node2D

    func _draw():
        # Your draw commands here
        pass

 .. code-tab:: csharp

    public override void _Draw()
    {
        // Your draw commands here
    }

Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>`
class reference. There are plenty of them.

Updating
--------

The ``_draw()`` function is only called once, and then the draw commands
are cached and remembered, so further calls are unnecessary.

If re-drawing is required because a state or something else changed,
call :ref:`CanvasItem.update() <class_CanvasItem_method_update>`
in that same node and a new ``_draw()`` call will happen.

Here is a little more complex example, a texture variable that will be
redrawn if modified:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node2D

    export (Texture) var texture setget _set_texture

    func _set_texture(value):
        # If the texture variable is modified externally,
        # this callback is called.
        texture = value  # Texture was changed.
        update()  # Update the node's visual representation.

    func _draw():
        draw_texture(texture, Vector2())

 .. code-tab:: csharp

    public class CustomNode2D : Node2D
    {
        private Texture _texture;
        public Texture Texture
        {
            get
            {
                return _texture;
            }

            set
            {
                _texture = value;
                Update();
            }
        }

        public override void _Draw()
        {
            DrawTexture(_texture, new Vector2());
        }
    }

In some cases, it may be desired to draw every frame. For this, just
call ``update()`` from the ``_process()`` callback, like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node2D

    func _draw():
        # Your draw commands here
        pass

    func _process(delta):
        update()

 .. code-tab:: csharp

    public class CustomNode2D : Node2D
    {
        public override void _Draw()
        {
            // Your draw commands here
        }

        public override void _Process(float delta)
        {
            Update();
        }
    }


An example: drawing circular arcs
----------------------------------

We will now use the custom drawing functionality of the Godot Engine to draw
something that Godot doesn't provide functions for. As an example, Godot provides
a ``draw_circle()`` function that draws a whole circle. However, what about drawing a
portion of a circle? You will have to code a function to perform this and draw it yourself.

Arc function
^^^^^^^^^^^^

An arc is defined by its support circle parameters, that is, the center position
and the radius. The arc itself is then defined by the angle it starts from
and the angle at which it stops. These are the 4 arguments that we have to provide to our drawing function.
We'll also provide the color value, so we can draw the arc in different colors if we wish.

Basically, drawing a shape on the screen requires it to be decomposed into a certain number of points
linked from one to the next. As you can imagine, the more points your shape is made of,
the smoother it will appear, but the heavier it will also be in terms of processing cost. In general,
if your shape is huge (or in 3D, close to the camera), it will require more points to be drawn without
it being angular-looking. On the contrary, if your shape is small (or in 3D, far from the camera),
you may decrease its number of points to save processing costs; this is known as *Level of Detail (LOD)*.
In our example, we will simply use a fixed number of points, no matter the radius.

.. tabs::
 .. code-tab:: gdscript GDScript

    func draw_circle_arc(center, radius, angle_from, angle_to, color):
        var nb_points = 32
        var points_arc = PoolVector2Array()

        for i in range(nb_points + 1):
            var angle_point = deg2rad(angle_from + i * (angle_to-angle_from) / nb_points - 90)
            points_arc.push_back(center + Vector2(cos(angle_point), sin(angle_point)) * radius)

        for index_point in range(nb_points):
            draw_line(points_arc[index_point], points_arc[index_point + 1], color)

 .. code-tab:: csharp

    public void DrawCircleArc(Vector2 center, float radius, float angleFrom, float angleTo, Color color)
    {
        int nbPoints = 32;
        var pointsArc = new Vector2[nbPoints];

        for (int i = 0; i < nbPoints; ++i)
        {
            float anglePoint = Mathf.Deg2Rad(angleFrom + i * (angleTo - angleFrom) / nbPoints - 90f);
            pointsArc[i] = center + new Vector2(Mathf.Cos(anglePoint), Mathf.Sin(anglePoint)) * radius;
        }

        for (int i = 0; i < nbPoints - 1; ++i)
            DrawLine(pointsArc[i], pointsArc[i + 1], color);
    }


Remember the number of points our shape has to be decomposed into? We fixed this
number in the ``nb_points`` variable to a value of ``32``. Then, we initialize an empty
``PoolVector2Array``, which is simply an array of ``Vector2``\ s.

The next step consists of computing the actual positions of these 32 points that
compose an arc. This is done in the first for-loop: we iterate over the number of
points for which we want to compute the positions, plus one to include the last point.
We first determine the angle of each point, between the starting and ending angles.

The reason why each angle is decreased by 90° is that we will compute 2D positions
out of each angle using trigonometry (you know, cosine and sine stuff...). However,
to be simple, ``cos()`` and ``sin()`` use radians, not degrees. The angle of 0° (0 radian)
starts at 3 o'clock, although we want to start counting at 12 o'clock. So we decrease
each angle by 90° in order to start counting from 12 o'clock.

The actual position of a point located on a circle at angle ``angle`` (in radians)
is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` and ``sin()`` return values
between -1 and 1, the position is located on a circle of radius 1. To have this
position on our support circle, which has a radius of ``radius``, we simply need to
multiply the position by ``radius``. Finally, we need to position our support circle
at the ``center`` position, which is performed by adding it to our ``Vector2`` value.
Finally, we insert the point in the ``PoolVector2Array`` which was previously defined.

Now, we need to actually draw our points. As you can imagine, we will not simply
draw our 32 points: we need to draw everything that is between each of them.
We could have computed every point ourselves using the previous method, and drew
it one by one. But this is too complicated and inefficient (except if explicitly needed),
so we simply draw lines between each pair of points. Unless the radius of our
support circle is big, the length of each line between a pair of points will
never be long enough to see them. If that were to happen, we would simply need to
increase the number of points.

Draw the arc on the screen
^^^^^^^^^^^^^^^^^^^^^^^^^^

We now have a function that draws stuff on the screen;
it is time to call it inside the ``_draw()`` function:

.. tabs::

 .. code-tab:: gdscript GDScript

    func _draw():
        var center = Vector2(200, 200)
        var radius = 80
        var angle_from = 75
        var angle_to = 195
        var color = Color(1.0, 0.0, 0.0)
        draw_circle_arc(center, radius, angle_from, angle_to, color)

 .. code-tab:: csharp

    public override void _Draw()
    {
        var center = new Vector2(200, 200);
        float radius = 80;
        float angleFrom = 75;
        float angleTo = 195;
        var color = new Color(1, 0, 0);
        DrawCircleArc(center, radius, angleFrom, angleTo, color);
    }

Result:

.. image:: img/result_drawarc.png

Arc polygon function
^^^^^^^^^^^^^^^^^^^^

We can take this a step further and not only write a function that draws the plain
portion of the disc defined by the arc, but also its shape. The method is exactly
the same as before, except that we draw a polygon instead of lines:

.. tabs::
 .. code-tab:: gdscript GDScript

    func draw_circle_arc_poly(center, radius, angle_from, angle_to, color):
        var nb_points = 32
        var points_arc = PoolVector2Array()
        points_arc.push_back(center)
        var colors = PoolColorArray([color])

        for i in range(nb_points + 1):
            var angle_point = deg2rad(angle_from + i * (angle_to - angle_from) / nb_points - 90)
            points_arc.push_back(center + Vector2(cos(angle_point), sin(angle_point)) * radius)
        draw_polygon(points_arc, colors)

 .. code-tab:: csharp

    public void DrawCircleArcPoly(Vector2 center, float radius, float angleFrom, float angleTo, Color color)
    {
        int nbPoints = 32;
        var pointsArc = new Vector2[nbPoints + 1];
        pointsArc[0] = center;
        var colors = new Color[] { color };

        for (int i = 0; i < nbPoints; ++i)
        {
            float anglePoint = Mathf.Deg2Rad(angleFrom + i * (angleTo - angleFrom) / nbPoints - 90);
            pointsArc[i + 1] = center + new Vector2(Mathf.Cos(anglePoint), Mathf.Sin(anglePoint)) * radius;
        }

        DrawPolygon(pointsArc, colors);
    }


.. image:: img/result_drawarc_poly.png

Dynamic custom drawing
^^^^^^^^^^^^^^^^^^^^^^

All right, we are now able to draw custom stuff on the screen. However, it is static;
let's make this shape turn around the center. The solution to do this is simply
to change the angle_from and angle_to values over time. For our example,
we will simply increment them by 50. This increment value has to remain
constant or else the rotation speed will change accordingly.

First, we have to make both angle_from and angle_to variables global at the top
of our script. Also note that you can store them in other nodes and access them
using ``get_node()``.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node2D

    var rotation_angle = 50
    var angle_from = 75
    var angle_to = 195

 .. code-tab:: csharp

    public class CustomNode2D : Node2D
    {
        private float _rotationAngle = 50;
        private float _angleFrom = 75;
        private float _angleTo = 195;
    }

We make these values change in the _process(delta) function.

We also increment our angle_from and angle_to values here. However, we must not
forget to ``wrap()`` the resulting values between 0 and 360°! That is, if the angle
is 361°, then it is actually 1°. If you don't wrap these values, the script will
work correctly, but the angle values will grow bigger and bigger over time until
they reach the maximum integer value Godot can manage (``2^31 - 1``).
When this happens, Godot may crash or produce unexpected behavior.

Finally, we must not forget to call the ``update()`` function, which automatically
calls ``_draw()``. This way, you can control when you want to refresh the frame.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        angle_from += rotation_angle
        angle_to += rotation_angle

        # We only wrap angles when both of them are bigger than 360.
        if angle_from > 360 and angle_to > 360:
            angle_from = wrapf(angle_from, 0, 360)
            angle_to = wrapf(angle_to, 0, 360)
        update()

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        _angleFrom += _rotationAngle;
        _angleTo += _rotationAngle;

        // We only wrap angles when both of them are bigger than 360.
        if (_angleFrom > 360 && _angleTo > 360)
        {
            _angleFrom = Mathf.Wrap(_angleFrom, 0, 360);
            _angleTo = Mathf.Wrap(_angleTo, 0, 360);
        }
        Update();
    }


Also, don't forget to modify the ``_draw()`` function to make use of these variables:

.. tabs::
 .. code-tab:: gdscript GDScript

     func _draw():
        var center = Vector2(200, 200)
        var radius = 80
        var color = Color(1.0, 0.0, 0.0)

        draw_circle_arc( center, radius, angle_from, angle_to, color )

 .. code-tab:: csharp

    public override void _Draw()
    {
        var center = new Vector2(200, 200);
        float radius = 80;
        var color = new Color(1, 0, 0);

        DrawCircleArc(center, radius, _angleFrom, _angleTo, color);
    }


Let's run!
It works, but the arc is rotating insanely fast! What's wrong?

The reason is that your GPU is actually displaying the frames as fast as it can.
We need to "normalize" the drawing by this speed; to achieve that, we have to make
use of the ``delta`` parameter of the ``_process()`` function. ``delta`` contains the
time elapsed between the two last rendered frames. It is generally small
(about 0.0003 seconds, but this depends on your hardware), so using ``delta`` to
control your drawing ensures that your program runs at the same speed on
everybody's hardware.

In our case, we simply need to multiply our ``rotation_angle`` variable by ``delta``
in the ``_process()`` function. This way, our 2 angles will be increased by a much
smaller value, which directly depends on the rendering speed.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        angle_from += rotation_angle * delta
        angle_to += rotation_angle * delta

        # We only wrap angles when both of them are bigger than 360.
        if angle_from > 360 and angle_to > 360:
            angle_from = wrapf(angle_from, 0, 360)
            angle_to = wrapf(angle_to, 0, 360)
        update()

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        _angleFrom += _rotationAngle * delta;
        _angleTo += _rotationAngle * delta;

        // We only wrap angles when both of them are bigger than 360.
        if (_angleFrom > 360 && _angleTo > 360)
        {
            _angleFrom = Wrap(_angleFrom, 0, 360);
            _angleTo = Wrap(_angleTo, 0, 360);
        }
        Update();
    }


Let's run again! This time, the rotation displays fine!

Antialiased drawing
^^^^^^^^^^^^^^^^^^^

Godot offers method parameters in :ref:`draw_line<class_CanvasItem_method_draw_line>`
to enable antialiasing, but it doesn't work reliably in all situations
(for instance, on mobile/web platforms, or when HDR is enabled).
There is also no ``antialiased`` parameter available in
:ref:`draw_polygon<class_CanvasItem_method_draw_polygon>`.

As a workaround, install and use the
`Antialiased Line2D add-on <https://github.com/godot-extended-libraries/godot-antialiased-line2d>`__
(which also supports antialiased Polygon2D drawing). Note that this add-on relies
on high-level nodes, rather than low-level ``_draw()`` functions.

Tools
-----

Drawing your own nodes might also be desired while running them in the
editor. This can be used as a preview or visualization of some feature or
behavior. See :ref:`doc_running_code_in_the_editor` for more information.


===================================================
/. ./tutorials/2d/2d_sprite_animation.rst
===================================================

.. _doc_2d_sprite_animation:

2D Sprite animation
===================

Introduction
------------

In this tutorial, you'll learn how to create 2D animated
characters with the AnimatedSprite class and the AnimationPlayer. Typically, when you create or download an animated character, it
will come in one of two ways: as individual images or as a single sprite sheet
containing all the animation's frames. Both can be animated in Godot with the AnimatedSprite class.

First, we'll use :ref:`AnimatedSprite <class_AnimatedSprite>` to
animate a collection of individual images. Then we will animate a sprite sheet using this class. Finally, we will learn another way to animate a sprite sheet
with :ref:`AnimationPlayer <class_AnimationPlayer>` and the *Animation*
property of :ref:`Sprite <class_Sprite>`.

.. note:: Art for the following examples by https://opengameart.org/users/ansimuz and by
                                           https://opengameart.org/users/tgfcoder

Individual images with AnimatedSprite
-------------------------------------

In this scenario, you have a collection of images, each containing one of your
character's animation frames. For this example, we'll use the following
animation:

.. image:: img/2d_animation_run_preview.gif

You can download the images here:
:download:`run_animation.zip <files/run_animation.zip>`

Unzip the images and place them in your project folder. Set up your scene tree
with the following nodes:

.. image:: img/2d_animation_tree1.png

.. note:: The root node could also be :ref:`Area2D <class_Area2D>` or
          :ref:`RigidBody2D <class_RigidBody2D>`. The animation will still be
          made in the same way. Once the animation is completed, you can
          assign a shape to the CollisionShape2D. See
          :ref:`Physics Introduction <doc_physics_introduction>` for more
          information.

Now select the ``AnimatedSprite`` and in its *SpriteFrames* property, select
"New SpriteFrames".

.. image:: img/2d_animation_new_spriteframes.png

Click on the new SpriteFrames resource and you'll see a new panel appear at the
bottom of the editor window:

.. image:: img/2d_animation_spriteframes.png

From the FileSystem dock on the left side, drag the 8 individual images into
the center part of the SpriteFrames panel. On the left side, change the name
of the animation from "default" to "run".

.. image:: img/2d_animation_spriteframes_done.png

Back in the Inspector, check the box for the *Playing* property. You should
now see the animation playing in the viewport. However, it is a bit slow. To
fix this, change the *Speed (FPS)* setting in the SpriteFrames panel to 10.

You can add additional animations by clicking the "New Animation" button and
adding additional images.

Controlling the animation
~~~~~~~~~~~~~~~~~~~~~~~~~

Once the animation is complete, you can control the animation via code using
the ``play()`` and ``stop()`` methods. Here is a brief example to play the
animation while the right arrow key is held, and stop it when the key is
released.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    onready var _animated_sprite = $AnimatedSprite

    func _process(_delta):
        if Input.is_action_pressed("ui_right"):
            _animated_sprite.play("run")
        else:
            _animated_sprite.stop()

 .. code-tab:: csharp

    public class Character : KinematicBody2D
    {
        private AnimatedSprite _animatedSprite;

        public override void _Ready()
        {
            _animatedSprite = GetNode<AnimatedSprite>("AnimatedSprite");
        }

        public override _Process(float _delta)
        {
            if (Input.IsActionPressed("ui_right"))
            {
                _animatedSprite.Play("run");
            }
            else
            {
                _animatedSprite.Stop();
            }
        }
    }


Sprite sheet with AnimatedSprite
--------------------------------

You can also easily animate from a sprite sheet with the class ``AnimatedSprite``. We will use this public domain sprite sheet:

.. image:: img/2d_animation_frog_spritesheet.png

Right-click the image and choose "Save Image As" to download it, and then copy the image into your project folder.

Set up your scene tree the same way you did previously when using individual images. Select the ``AnimatedSprite`` and in its *SpriteFrames* property, select
"New SpriteFrames".

Click on the new SpriteFrames resource. This time, when the bottom panel appears, select "Add frames from a Sprite Sheet".

.. image:: img/2d_animation_add_from_spritesheet.png

You will be prompted to open a file. Select your sprite sheet.

A new window will open, showing your sprite sheet. The first thing you will need to do is to change the number of vertical and horizontal images in your sprite sheet. In this sprite sheet, we have four images horizontally and two images vertically.

.. image:: img/2d_animation_spritesheet_select_rows.png

Next, select the frames from the sprite sheet that you want to include in your animation. We will select the top four, then click "Add 4 frames" to create the animation.

.. image:: img/2d_animation_spritesheet_selectframes.png

You will now see your animation under the list of animations in the bottom panel. Double click on default to change the name of the animation to jump.

.. image:: img/2d_animation_spritesheet_animation.png

Finally, check Playing on the AnimatedSprite in the inspector to see your frog jump!

.. image:: img/2d_animation_play_spritesheet_animation.png


Sprite sheet with AnimationPlayer
---------------------------------

Another way that you can animate when using a sprite sheet is to use a standard
:ref:`Sprite <class_Sprite>` node to display the texture, and then animating the
change from texture to texture with :ref:`AnimationPlayer <class_AnimationPlayer>`.

Consider this sprite sheet, which contains 6 frames of animation:

.. image:: img/2d_animation_player-run.png

Right-click the image and choose "Save Image As" to download, then copy the
image into your project folder.

Our goal is to display these images one after another in a loop. Start by
setting up your scene tree:

.. image:: img/2d_animation_tree2.png

.. note:: The root node could also be :ref:`Area2D <class_Area2D>` or
          :ref:`RigidBody2D <class_RigidBody2D>`. The animation will still be
          made in the same way. Once the animation is completed, you can
          assign a shape to the CollisionShape2D. See
          :ref:`Physics Introduction <doc_physics_introduction>` for more
          information.

Drag the spritesheet into the Sprite's *Texture* property, and you'll see the
whole sheet displayed on the screen. To slice it up into individual frames,
expand the *Animation* section in the Inspector and set the *Hframes* to ``6``.
*Hframes* and *Vframes* are the number of horizontal and vertical frames in
your sprite sheet.

.. image:: img/2d_animation_setframes.png

Now try changing the value of the *Frame* property. You'll see that it ranges
from ``0`` to ``5`` and the image displayed by the Sprite changes accordingly.
This is the property we'll be animating.

Select the ``AnimationPlayer`` and click the "Animation" button followed by
"New". Name the new animation "walk". Set the animation length to ``0.6`` and
click the "Loop" button so that our animation will repeat.

.. image:: img/2d_animation_new_animation.png

Now select the ``Sprite`` node and click the key icon to add a new track.

.. image:: img/2d_animation_new_track.png

Continue adding frames at each point in the timeline (``0.1`` seconds by
default), until you have all the frames from 0 to 5. You'll see the frames
actually appearing in the animation track:

.. image:: img/2d_animation_full_animation.png

Press "Play" on the animation to see how it looks.

.. image:: img/2d_animation_running.gif

Controlling an AnimationPlayer animation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Like with AnimatedSprite, you can control the animation via code using
the ``play()`` and ``stop()`` methods. Again, here is an example to play the
animation while the right arrow key is held, and stop it when the key is
released.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    onready var _animation_player = $AnimationPlayer

    func _process(_delta):
        if Input.is_action_pressed("ui_right"):
            _animation_player.play("walk")
        else:
            _animation_player.stop()

 .. code-tab:: csharp

    public class Character : KinematicBody2D
    {
        private AnimationPlayer _animationPlayer;

        public override void _Ready()
        {
            _animationPlayer = GetNode<AnimationPlayer>("AnimationPlayer");
        }

        public override void _Process(float _delta)
        {
            if (Input.IsActionPressed("ui_right"))
            {
                _animationPlayer.Play("walk");
            }
            else
            {
                _animationPlayer.Stop();
            }
        }
    }

.. note:: If updating both an animation and a separate property at once
          (for example, a platformer may update the sprite's ``h_flip``/``v_flip``
          properties when a character turns while starting a 'turning' animation),
          it's important to keep in mind that ``play()`` isn't applied instantly.
          Instead, it's applied the next time the :ref:`AnimationPlayer <class_AnimationPlayer>` is processed.
          This may end up being on the next frame, causing a 'glitch' frame,
          where the property change was applied but the animation was not.
          If this turns out to be a problem, after calling ``play()``, you can call ``advance(0)``
          to update the animation immediately.

Summary
-------

These examples illustrate the two classes you can use in Godot for
2D animation. ``AnimationPlayer`` is
a bit more complex than ``AnimatedSprite``, but it provides additional functionality, since you can also
animate other properties like position or scale. The class ``AnimationPlayer`` can also be used with an ``AnimatedSprite``. Experiment to see what works best for your needs.


===================================================
/. ./tutorials/3d/index.rst
===================================================

3D
==

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-3d

   introduction_to_3d
   using_transforms
   3d_rendering_limitations
   spatial_material
   lights_and_shadows
   reflection_probes
   gi_probes
   baked_lightmaps
   environment_and_post_processing
   high_dynamic_range
   using_gridmaps
   using_multi_mesh_instance
   csg_tools
   procedural_geometry/index
   occluders
   portals/index
   3d_text


===================================================
/. ./tutorials/3d/introduction_to_3d.rst
===================================================

.. _doc_introduction_to_3d:

Introduction to 3D
==================

Creating a 3D game can be challenging. That extra Z coordinate makes
many of the common techniques that helped to make 2D games simple no
longer work. To aid in this transition, it is worth mentioning that
Godot uses similar APIs for 2D and 3D. Most nodes are the same and
are present in both 2D and 3D versions. In fact, it is worth checking
the 3D platformer tutorial, or the 3D kinematic character tutorials,
which are almost identical to their 2D counterparts.

In 3D, math is a little more complex than in 2D, so also checking the
:ref:`doc_vector_math` entry in the wiki (which was especially created for game
developers, not mathematicians or engineers) will help pave the way for you
to develop 3D games efficiently.

Spatial node
~~~~~~~~~~~~

:ref:`Node2D <class_Node2D>` is the base node for 2D.
:ref:`Control <class_Control>` is the base node for everything GUI.
Following this reasoning, the 3D engine uses the :ref:`Spatial <class_Spatial>`
node for everything 3D.

.. image:: img/tuto_3d1.png

Spatial nodes have a local transform, which is relative to the parent
node (as long as the parent node is also of **or inherits from** the type
Spatial). This transform can be accessed as a 4×3
:ref:`Transform <class_Transform>`, or as 3 :ref:`Vector3 <class_Vector3>`
members representing location, Euler rotation (X, Y and Z angles) and
scale.

.. image:: img/tuto_3d2.png

3D content
~~~~~~~~~~

Unlike 2D, where loading image content and drawing is straightforward,
3D is a little more difficult. The content needs to be created with
special 3D tools (usually referred to as Digital Content Creation tools, or
DCCs) and exported to an exchange file format to be imported in
Godot. This is required since 3D formats are not as standardized as images.

DCC-created models
------------------

.. FIXME: Needs update to properly description Godot 3.x workflow
   (used to reference a non existing doc_importing_3d_meshes importer).

There are two pipelines to import 3D models in Godot. The first and most
common one is by :ref:`doc_importing_3d_scenes`, which allows you to import
entire scenes (just as they look in the DCC), including animation,
skeletal rigs, blend shapes, etc.

The second pipeline is by importing simple .OBJ files as mesh resources,
which can be then put inside a :ref:`MeshInstance <class_MeshInstance>`
node for display.

Generated geometry
------------------

It is possible to create custom geometry by using the
:ref:`ArrayMesh <class_ArrayMesh>` resource directly. Simply create your arrays
and use the :ref:`ArrayMesh.add_surface_from_arrays() <class_ArrayMesh_method_add_surface_from_arrays>`
function. A helper class is also available, :ref:`SurfaceTool <class_SurfaceTool>`,
which provides a more straightforward API and helpers for indexing,
generating normals, tangents, etc.

In any case, this method is meant for generating static geometry (models
that will not be updated often), as creating vertex arrays and
submitting them to the 3D API has a significant performance cost.

Immediate geometry
------------------

If, instead, there is a requirement to generate simple geometry that
will be updated often, Godot provides a special node,
:ref:`ImmediateGeometry <class_ImmediateGeometry>`,
which provides an OpenGL 1.x style immediate-mode API to create points,
lines, triangles, etc.

2D in 3D
--------

While Godot packs a powerful 2D engine, many types of games use 2D in a
3D environment. By using a fixed camera (either orthogonal or
perspective) that does not rotate, nodes such as
:ref:`Sprite3D <class_Sprite3D>` and
:ref:`AnimatedSprite3D <class_AnimatedSprite3D>`
can be used to create 2D games that take advantage of mixing with 3D
backgrounds, more realistic parallax, lighting/shadow effects, etc.

The disadvantage is, of course, that added complexity and reduced
performance in comparison to plain 2D, as well as the lack of reference
of working in pixels.

Environment
~~~~~~~~~~~

Besides editing a scene, it is often common to edit the environment.
Godot provides a :ref:`WorldEnvironment <class_WorldEnvironment>`
node that allows changing the background color, mode (as in, put a
skybox), and applying several types of built-in post-processing effects.
Environments can also be overridden in the Camera.

3D viewport
~~~~~~~~~~~

Editing 3D scenes is done in the 3D tab. This tab can be selected
manually, but it will be automatically enabled when a Spatial node is
selected.

.. image:: img/tuto_3d3.png

Default 3D scene navigation controls are similar to Blender (aiming to
have some sort of consistency in the free software pipeline..), but
options are included to customize mouse buttons and behavior to be
similar to other tools in the Editor Settings:

.. image:: img/tuto_3d4.png

Coordinate system
-----------------

Godot uses the `metric <https://en.wikipedia.org/wiki/Metric_system>`__
system for everything in 3D, with 1 unit being equal to 1 meter.
Physics and other areas are tuned for this scale. Therefore, attempting to use a
different scale is usually a bad idea (unless you know what you are doing).

When working with 3D assets, it's always best to work in the correct
scale (set your DCC to metric). Godot allows scaling post-import and,
while this works in most cases, in rare situations it may introduce
floating-point precision issues (and thus, glitches or artifacts) in
delicate areas such as rendering or physics. Make sure your artists
always work in the right scale!

The Y coordinate is used for "up", though for most objects that need
alignment (like lights, cameras, capsule collider, vehicle, etc.), the Z
axis is used as a "pointing towards" direction. This convention roughly
means that:

-  **X** is sides
-  **Y** is up/down
-  **Z** is front/back

Space and manipulation gizmos
-----------------------------

Moving objects in the 3D view is done through the manipulator gizmos.
Each axis is represented by a color: Red, Green, Blue represent X, Y, Z
respectively. This convention applies to the grid and other gizmos too
(and also to the shader language, ordering of components for
Vector3, Color, etc.).

.. image:: img/tuto_3d5.png

Some useful keybindings:

-  To snap placement or rotation, press :kbd:`Ctrl` while moving, scaling
   or rotating.
-  To center the view on the selected object, press :kbd:`F`.

View menu
---------

The view options are controlled by the "View" menu in the viewport's toolbar.

.. image:: img/tuto_3d6.png

You can hide the gizmos in the 3D view of the editor through this menu:

.. image:: img/tuto_3d6_1.png

To hide a specific type of gizmos, you can toggle them off in the "View" menu.

.. image:: img/tuto_3d6_2.png

Default environment
-------------------

When created from the Project Manager, the 3D environment has a default sky.

.. image:: img/tuto_3d8.png

Given how physically based rendering works, it is advised to always try to
work with a default environment in order to provide indirect and reflected
light to your objects.

Cameras
-------

No matter how many objects are placed in the 3D space, nothing will be
displayed unless a :ref:`Camera <class_Camera>` is
also added to the scene. Cameras can work in either orthogonal or
perspective projections:

.. image:: img/tuto_3d10.png

Cameras are associated with (and only display to) a parent or grandparent
viewport. Since the root of the scene tree is a viewport, cameras will
display on it by default, but if sub-viewports (either as render target
or picture-in-picture) are desired, they need their own children cameras
to display.

.. image:: img/tuto_3d11.png

When dealing with multiple cameras, the following rules are enforced for
each viewport:

-  If no cameras are present in the scene tree, the first one that
   enters it will become the active camera. Further cameras entering the
   scene will be ignored (unless they are set as *current*).
-  If a camera has the "*current*" property set, it will be used
   regardless of any other camera in the scene. If the property is set,
   it will become active, replacing the previous camera.
-  If an active camera leaves the scene tree, the first camera in
   tree-order will take its place.

Lights
------

Godot has a limit of up to 8 lights per mesh. Aside from that, there
is no limitation on the number of lights, nor of types of lights, in
Godot. As many as desired can be added, as long as performance allows,
and no more than 8 lights shine on a single mesh.


===================================================
/. ./tutorials/3d/using_transforms.rst
===================================================

.. _doc_using_transforms:

Using 3D transforms
~~~~~~~~~~~~~~~~~~~

Introduction
------------

If you have never made 3D games before, working with rotations in three dimensions can be confusing at first.
Coming from 2D, the natural way of thinking is along the lines of *"Oh, it's just like rotating in 2D, except now rotations happen in X, Y and Z"*.

At first, this seems easy. For simple games, this way of thinking may even be enough. Unfortunately, it's often incorrect.

Angles in three dimensions are most commonly referred to as "Euler Angles".

.. image:: img/transforms_euler.png

Euler angles were introduced by mathematician Leonhard Euler in the early 1700s.

.. image:: img/transforms_euler_himself.png

This way of representing 3D rotations was groundbreaking at the time, but it has several shortcomings when used in game development (which is to be expected from a guy with a funny
hat).
The idea of this document is to explain why, as well as outlining best practices for dealing with transforms when programming 3D games.


Problems of Euler angles
------------------------

While it may seem intuitive that each axis has a rotation, the truth is that it's just not practical.

Axis order
==========

The main reason for this is that there isn't a *unique* way to construct an orientation from the angles. There isn't a standard mathematical function that
takes all the angles together and produces an actual 3D rotation. The only way an orientation can be produced from angles is to rotate the object angle
by angle, in an *arbitrary order*.

This could be done by first rotating in *X*, then *Y* and then in *Z*. Alternatively, you could first rotate in *Y*, then in *Z* and finally in *X*. Anything works,
but depending on the order, the final orientation of the object will *not necessarily be the same*. Indeed, this means that there are several ways to construct an orientation
from 3 different angles, depending on *the order of the rotations*.

Following is a visualization of rotation axes (in X, Y, Z order) in a gimbal (from Wikipedia). As you can see, the orientation of each axis depends on the rotation of the previous one:

.. image:: img/transforms_gimbal.gif

You may be wondering how this affects you. Let's look at a practical example:

Imagine you are working on a first-person controller (e.g. an FPS game). Moving the mouse left and right controls your view angle parallel to the ground, while moving it up and down moves the player's view up and down.

In this case to achieve the desired effect, rotation must be applied first in the *Y* axis ("up" in this case, since Godot uses a "Y-Up" orientation), followed by rotation in the *X* axis.

.. image:: img/transforms_rotate1.gif

If we were to apply rotation in the *X* axis first, and then in *Y*, the effect would be undesired:

.. image:: img/transforms_rotate2.gif

Depending on the type of game or effect desired, the order in which you want axis rotations to be applied may differ. Therefore, applying rotations in X, Y, and Z is not enough: you also need a *rotation order*.

Interpolation
=============

Another problem with using Euler angles is interpolation. Imagine you want to transition between two different camera or enemy positions (including rotations). One logical way to approach this is to interpolate the angles from one position to the next. One would expect it to look like this:

.. image:: img/transforms_interpolate1.gif

But this does not always have the expected effect when using angles:

.. image:: img/transforms_interpolate2.gif

The camera actually rotated the opposite direction!

There are a few reasons this may happen:

* Rotations don't map linearly to orientation, so interpolating them does not always result in the shortest path (i.e., to go from ``270`` to ``0`` degrees is not the same as going from ``270`` to ``360``, even though the angles are equivalent).
* Gimbal lock is at play (first and last rotated axis align, so a degree of freedom is lost). See `Wikipedia's page on Gimbal Lock <https://en.wikipedia.org/wiki/Gimbal_lock>`_ for a detailed explanation of this problem.

Say no to Euler angles
======================

The result of all this is that you should **not use** the ``rotation`` property of :ref:`class_Spatial` nodes in Godot for games. It's there to be used mainly in the editor, for coherence with the 2D engine, and for simple rotations (generally just one axis, or even two in limited cases). As much as you may be tempted, don't use it.

Instead, there is a better way to solve your rotation problems.

Introducing transforms
----------------------

Godot uses the :ref:`class_Transform` datatype for orientations. Each :ref:`class_Spatial` node contains a ``transform`` property which is relative to the parent's transform, if the parent is a Spatial-derived type.

It is also possible to access the world coordinate transform via the ``global_transform`` property.

A transform has a :ref:`class_Basis` (transform.basis sub-property), which consists of three :ref:`class_Vector3` vectors. These are accessed via the ``transform.basis`` property and can be accessed directly by ``transform.basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Each vector points in the direction its axis has been rotated, so they effectively describe the node's total rotation. The scale (as long as it's uniform) can also be inferred from the length of the axes. A *basis* can also be interpreted as a 3x3 matrix and used as ``transform.basis[x][y]``.

A default basis (unmodified) is akin to:

.. tabs::
 .. code-tab:: gdscript GDScript

    var basis = Basis()
    # Contains the following default values:
    basis.x = Vector3(1, 0, 0) # Vector pointing along the X axis
    basis.y = Vector3(0, 1, 0) # Vector pointing along the Y axis
    basis.z = Vector3(0, 0, 1) # Vector pointing along the Z axis

 .. code-tab:: csharp

    // Due to technical limitations on structs in C# the default
    // constructor will contain zero values for all fields.
    var defaultBasis = new Basis();
    GD.Print(defaultBasis); // prints: ((0, 0, 0), (0, 0, 0), (0, 0, 0))

    // Instead we can use the Identity property.
    var identityBasis = Basis.Identity;
    GD.Print(identityBasis.x); // prints: (1, 0, 0)
    GD.Print(identityBasis.y); // prints: (0, 1, 0)
    GD.Print(identityBasis.z); // prints: (0, 0, 1)

    // The Identity basis is equivalent to:
    var basis = new Basis(Vector3.Right, Vector3.Up, Vector3.Back);
    GD.Print(basis); // prints: ((1, 0, 0), (0, 1, 0), (0, 0, 1))

This is also an analog of a 3x3 identity matrix.

Following the OpenGL convention, ``X`` is the *Right* axis, ``Y`` is the *Up* axis and ``Z`` is the *Forward* axis.

Together with the *basis*, a transform also has an *origin*. This is a *Vector3* specifying how far away from the actual origin ``(0, 0, 0)`` this transform is. Combining the *basis* with the *origin*, a *transform* efficiently represents a unique translation, rotation, and scale in space.

.. image:: img/transforms_camera.png


One way to visualize a transform is to look at an object's 3D gizmo while in "local space" mode.

.. image:: img/transforms_local_space.png

The gizmo's arrows show the ``X``, ``Y``, and ``Z`` axes (in red, green, and blue respectively) of the basis, while the gizmo's center is at the object's origin.

.. image:: img/transforms_gizmo.png

For more information on the mathematics of vectors and transforms, please read the :ref:`doc_vector_math` tutorials.

Manipulating transforms
=======================

Of course, transforms are not as straightforward to manipulate as angles and have problems of their own.

It is possible to rotate a transform, either by multiplying its basis by another (this is called accumulation), or by using the rotation methods.

.. tabs::
 .. code-tab:: gdscript GDScript

    var axis = Vector3(1, 0, 0) # Or Vector3.RIGHT
    var rotation_amount = 0.1
    # Rotate the transform around the X axis by 0.1 radians.
    transform.basis = Basis(axis, rotation_amount) * transform.basis
    # shortened
    transform.basis = transform.basis.rotated(axis, rotation_amount)

 .. code-tab:: csharp

    Vector3 axis = new Vector3(1, 0, 0); // Or Vector3.Right
    float rotationAmount = 0.1f;
    // Rotate the transform around the X axis by 0.1 radians.
    transform.basis = new Basis(axis, rotationAmount) * transform.basis;
    // shortened
    transform.basis = transform.basis.Rotated(axis, rotationAmount);

A method in Spatial simplifies this:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Rotate the transform around the X axis by 0.1 radians.
    rotate(Vector3(1, 0, 0), 0.1)
    # shortened
    rotate_x(0.1)

 .. code-tab:: csharp

    // Rotate the transform around the X axis by 0.1 radians.
    Rotate(new Vector3(1, 0, 0), 0.1f);
    // shortened
    RotateX(0.1f);

This rotates the node relative to the parent node.

To rotate relative to object space (the node's own transform), use the following:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Rotate around the object's local X axis by 0.1 radians.
    rotate_object_local(Vector3(1, 0, 0), 0.1)

 .. code-tab:: csharp

    // Rotate around the object's local X axis by 0.1 radians.
    RotateObjectLocal(new Vector3(1, 0, 0), 0.1f);

Precision errors
================

Doing successive operations on transforms will result in a loss of precision due to floating-point error. This means the scale of each axis may no longer be exactly ``1.0``, and they may not be exactly ``90`` degrees from each other.

If a transform is rotated every frame, it will eventually start deforming over time. This is unavoidable.

There are two different ways to handle this. The first is to *orthonormalize* the transform after some time (maybe once per frame if you modify it every frame):

.. tabs::
 .. code-tab:: gdscript GDScript

    transform = transform.orthonormalized()

 .. code-tab:: csharp

    transform = transform.Orthonormalized();

This will make all axes have ``1.0`` length again and be ``90`` degrees from each other. However, any scale applied to the transform will be lost.

It is recommended you not scale nodes that are going to be manipulated; scale their children nodes instead (such as MeshInstance). If you absolutely must scale the node, then re-apply it at the end:

.. tabs::
 .. code-tab:: gdscript GDScript

    transform = transform.orthonormalized()
    transform = transform.scaled(scale)

 .. code-tab:: csharp

    transform = transform.Orthonormalized();
    transform = transform.Scaled(scale);

Obtaining information
=====================

You might be thinking at this point: **"Ok, but how do I get angles from a transform?"**. The answer again is: you don't. You must do your best to stop thinking in angles.

Imagine you need to shoot a bullet in the direction your player is facing. Just use the forward axis (commonly ``Z`` or ``-Z``).

.. tabs::
 .. code-tab:: gdscript GDScript

    bullet.transform = transform
    bullet.speed = transform.basis.z * BULLET_SPEED

 .. code-tab:: csharp

    bullet.Transform = transform;
    bullet.LinearVelocity = transform.basis.z * BulletSpeed;

Is the enemy looking at the player? Use the dot product for this (see the :ref:`doc_vector_math` tutorial for an explanation of the dot product):

.. tabs::
 .. code-tab:: gdscript GDScript

    # Get the direction vector from player to enemy
    var direction = enemy.transform.origin - player.transform.origin
    if direction.dot(enemy.transform.basis.z) > 0:
        enemy.im_watching_you(player)

 .. code-tab:: csharp

    // Get the direction vector from player to enemy
    Vector3 direction = enemy.Transform.origin - player.Transform.origin;
    if (direction.Dot(enemy.Transform.basis.z) > 0)
    {
        enemy.ImWatchingYou(player);
    }

Strafe left:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Remember that +X is right
    if Input.is_action_pressed("strafe_left"):
        translate_object_local(-transform.basis.x)

 .. code-tab:: csharp

    // Remember that +X is right
    if (Input.IsActionPressed("strafe_left"))
    {
        TranslateObjectLocal(-Transform.basis.x);
    }

Jump:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Keep in mind Y is up-axis
    if Input.is_action_just_pressed("jump"):
        velocity.y = JUMP_SPEED

    velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    // Keep in mind Y is up-axis
    if (Input.IsActionJustPressed("jump"))
        velocity.y = JumpSpeed;

    velocity = MoveAndSlide(velocity);

All common behaviors and logic can be done with just vectors.

Setting information
===================

There are, of course, cases where you want to set information to a transform. Imagine a first person controller or orbiting camera. Those are definitely done using angles, because you *do want* the transforms to happen in a specific order.

For such cases, keep the angles and rotations *outside* the transform and set them every frame. Don't try to retrieve and reuse them because the transform is not meant to be used this way.

Example of looking around, FPS style:

.. tabs::
 .. code-tab:: gdscript GDScript

    # accumulators
    var rot_x = 0
    var rot_y = 0

    func _input(event):
        if event is InputEventMouseMotion and event.button_mask & 1:
            # modify accumulated mouse rotation
            rot_x += event.relative.x * LOOKAROUND_SPEED
            rot_y += event.relative.y * LOOKAROUND_SPEED
            transform.basis = Basis() # reset rotation
            rotate_object_local(Vector3(0, 1, 0), rot_x) # first rotate in Y
            rotate_object_local(Vector3(1, 0, 0), rot_y) # then rotate in X

 .. code-tab:: csharp

    // accumulators
    private float _rotationX = 0f;
    private float _rotationY = 0f;

    public override void _Input(InputEvent @event)
    {
        if (@event is InputEventMouseMotion mouseMotion)
        {
            // modify accumulated mouse rotation
            _rotationX += mouseMotion.Relative.x * LookAroundSpeed;
            _rotationY += mouseMotion.Relative.y * LookAroundSpeed;

            // reset rotation
            Transform transform = Transform;
            transform.basis = Basis.Identity;
            Transform = transform;

            RotateObjectLocal(Vector3.Up, _rotationX); // first rotate about Y
            RotateObjectLocal(Vector3.Right, _rotationY); // then rotate about X
        }
    }

As you can see, in such cases it's even simpler to keep the rotation outside, then use the transform as the *final* orientation.

Interpolating with quaternions
==============================

Interpolating between two transforms can efficiently be done with quaternions. More information about how quaternions work can be found in other places around the Internet. For practical use, it's enough to understand that pretty much their main use is doing a closest path interpolation. As in, if you have two rotations, a quaternion will smoothly allow interpolation between them using the closest axis.

Converting a rotation to quaternion is straightforward.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Convert basis to quaternion, keep in mind scale is lost
    var a = Quat(transform.basis)
    var b = Quat(transform2.basis)
    # Interpolate using spherical-linear interpolation (SLERP).
    var c = a.slerp(b,0.5) # find halfway point between a and b
    # Apply back
    transform.basis = Basis(c)

 .. code-tab:: csharp

    // Convert basis to quaternion, keep in mind scale is lost
    var a = transform.basis.Quat();
    var b = transform2.basis.Quat();
    // Interpolate using spherical-linear interpolation (SLERP).
    var c = a.Slerp(b, 0.5f); // find halfway point between a and b
    // Apply back
    transform.basis = new Basis(c);

The :ref:`class_Quat` type reference has more information on the datatype (it
can also do transform accumulation, transform points, etc., though this is used
less often). If you interpolate or apply operations to quaternions many times,
keep in mind they need to be eventually normalized. Otherwise, they will also
suffer from numerical precision errors.

Quaternions are useful when doing camera/path/etc. interpolations, as the result will always be correct and smooth.

Transforms are your friend
--------------------------

For most beginners, getting used to working with transforms can take some time. However, once you get used to them, you will appreciate their simplicity and power.

Don't hesitate to ask for help on this topic in any of Godot's `online communities <https://godotengine.org/community>`_ and, once you become confident enough, please help others!


===================================================
/. ./tutorials/3d/3d_rendering_limitations.rst
===================================================

.. _doc_3d_rendering_limitations:

3D rendering limitations
========================

.. seealso::

    In addition to the limitations below, mobile platforms have even more
    limitations on 3D rendering compared to desktop platforms.
    See :ref:`doc_mobile_rendering_limitations` for more information.

Introduction
------------

Due to their focus on performance, real-time rendering engines have many
limitations. Godot's renderer is no exception. To work effectively with those
limitations, you need to understand them.

Texture size limits
-------------------

On desktops and laptops, textures larger than 8192×8192 may not be supported on
older devices. You can check your target GPU's limitations on
`GPUinfo.org <https://www.gpuinfo.org/>`__.

Mobile GPUs are typically limited to 4096×4096 textures. Also, some mobile GPUs
don't support repeating non-power-of-two-sized textures. Therefore, if you want
your texture to display correctly on all platforms, you should avoid using
textures larger than 4096×4096 and use a power of two size if the texture needs
to repeat.

Color banding
-------------

When using the GLES3 or Vulkan renderers, Godot's 3D engine renders internally
in HDR. However, the rendering output will be tonemapped to a low dynamic range
so it can be displayed on the screen. This can result in visible banding,
especially when using untextured materials. This can also be seen in 2D projects
when using smooth gradient textures.

There are two main ways to alleviate banding:

- Enable **Use Debanding** in the Project Settings. This applies a
  fullscreen debanding shader as a post-processing effect and is very cheap.
  Fullscreen debanding is only supported when using the GLES3 or Vulkan renderers.
  It also requires HDR to be enabled in the Project Settings (which is the default).
- Alternatively, bake some noise into your textures. This is mainly effective in 2D,
  e.g. for vignetting effects. In 3D, you can also use a
  `custom debanding shader <https://github.com/fractilegames/godot-gles2-debanding-material>`__
  to be applied on your *materials*. This technique works even if your project is
  rendered in LDR, which means it will work when using the GLES2 renderer.

.. seealso::

    See `Banding in Games: A Noisy Rant <http://loopit.dk/banding_in_games.pdf>`__
    for more details about banding and ways to combat it.

Depth buffer precision
----------------------

To sort objects in 3D space, rendering engines rely on a *depth buffer* (also
called *Z-buffer*). This buffer has a finite precision: 24-bit on desktop
platforms, sometimes 16-bit on mobile platforms (for performance reasons). If
two different objects end up on the same buffer value, then Z-fighting will
occur. This will materialize as textures flickering back and forth as the camera
moves or rotates.

To make the depth buffer more precise over the rendered area, you should
*increase* the Camera node's **Near** property. However, be careful: if you set
it too high, players will be able to see through nearby geometry. You should
also *decrease* the Camera node's **Far** property to the lowest permissible value
for your use case, though keep in mind it won't impact precision as much as the
**Near** property.

If you only need high precision when the player can see far away, you could
change it dynamically based on the game conditions. For instance, if the player
enters an airplane, the **Near** property can be temporarily increased to avoid
Z-fighting in the distance. It can then be decreased once the player leaves the
airplane.

Depending on the scene and viewing conditions, you may also be able to move the
Z-fighting objects further apart without the difference being visible to the
player.

.. _doc_3d_rendering_limitations_transparency_sorting:

Transparency sorting
--------------------

In Godot, transparent materials are drawn after opaque materials. Transparent
objects are sorted back to front before being drawn based on the Spatial's
position, not the vertex position in world space. Due to this, overlapping
objects may often be sorted out of order. To fix improperly sorted objects, tweak
the material's :ref:`Render Priority <class_Material_property_render_priority>`
property. This will force specific materials to appear in front or behind of
other transparent materials. Even then, this may not always be sufficient.

Some rendering engines feature *order-independent transparency* techniques to
alleviate this, but this is costly on the GPU. Godot currently doesn't provide
this feature. There are still several ways to avoid this problem:

- Only make materials transparent if you actually need it. If a material only
  has a small transparent part, consider splitting it into a separate material.
  This will allow the opaque part to cast shadows and may also improve
  performance.

- If your texture mostly has fully opaque and fully transparent areas, you can
  use alpha testing instead of alpha blending. This transparency mode is faster
  to render and doesn't suffer from transparency issues. Enable
  **Parameters > Use Alpha Scissor** in SpatialMaterial, and adjust
  **Alpha Scissor Threshold** accordingly if needed. Note that MSAA will not
  anti-alias the texture's edges, but FXAA will.

- If you need to render semi-transparent areas of the texture, alpha scissor
  isn't suitable. Instead, setting the SpatialMaterial's
  **Parameters > Depth Draw Mode** property to **Opaque Pre-Pass** can sometimes
  work (at a performance cost).

- If you want a material to fade with distance, use the SpatialMaterial
  distance fade mode **Pixel Dither** or **Object Dither** instead of
  **PixelAlpha**. This will make the material opaque. This way, it can also
  cast shadows.

Multi-sample antialiasing
-------------------------

Multi-sample antialiasing (MSAA) takes multiple *coverage* samples at the edges
of polygons when rendering objects. It does not increase the number of *color*
samples used to render a scene. Here's what this means in practice:

- Edges of meshes will be smoothed out nicely (as well as supersampling would).
- Transparent materials that use *alpha testing* (1-bit transparency) won't be smoothed out.
- Specular aliasing ("sparkles" that appear on reflective surfaces) won't be reduced.

There are several ways to work around this limitation depending on your performance budget:

- To make specular aliasing less noticeable, open the Project Settings and enable
  **Rendering > Quality > Screen Space Filters > Screen Space Roughness Limiter**.
  This filter has a moderate cost on performance. It should be enabled only if
  you actually need it.

- Enable FXAA in addition to (or instead of) MSAA. Since FXAA is a screen-space
  antialiasing method, it will smooth out anything. As a downside, it will also
  make the scene appear blurrier, especially at resolutions below 1440p.

- Render the scene at a higher resolution, then display it in a ViewportTexture
  that matches the window size. Make sure to enable **Filter** on the
  ViewportTexture flags. This technique is called *supersampling* and is very
  slow. Its use is generally only recommended for offline rendering.


===================================================
/. ./tutorials/3d/spatial_material.rst
===================================================

.. _doc_spatial_material:

Spatial Material
================

Introduction
------------

``SpatialMaterial`` is a default 3D material that aims to provide most of the features
artists look for in a material, without the need for writing shader code. However,
it can be converted to shader code if additional functionality is needed.

This tutorial explains most parameters present in ``SpatialMaterial``.

There are 4 ways to add a ``SpatialMaterial`` to an object. It can be added in
the *Material* property of the mesh. It can be added in the *Material* property of
the node using the mesh (such as a MeshInstance node), the *Material Override* property
of the node using the mesh, and the *Material Overlay*.

.. image:: img/add_material.png

If you add a material to the mesh itself, every time that mesh is used it will have that
material. If you add a material to the node using the mesh, the material will only be used
by that node, it will also override the material property of the mesh. If a material is
added in the *Material Override* property of the node, it will only be used by that node.
It will also override the regular material property of the node and the material property of
the mesh.

The *Material Overlay* property will render a material **over** the current one being used by the
mesh. As an example, this can be used to put a transparent shield effect on a mesh.

Flags
-----

Spatial materials have many flags determining the general usage of a material.

.. image:: img/spatial_material1.png

Transparent
~~~~~~~~~~~

In Godot, materials are not transparent unless specifically configured to be.
The main reason behind this is that transparent materials are rendered
using a different technique (sorted from back to front and rendered in order).

This technique is less efficient (many state changes happen) and makes
the materials unusable with many mid- and post-processing effects
(such as SSAO, SSR, etc.) that require perfectly opaque geometry.

For this reason, materials in Godot are assumed opaque unless
specified otherwise. The main settings that enable transparency are:

* Transparent flag (this one)
* Blend mode set to other than "Mix"
* Enabling distance or proximity fade

Use Shadow to Opacity
~~~~~~~~~~~~~~~~~~~~~

Lighting modifies the alpha so shadowed areas are opaque and non-shadowed
areas are transparent. Useful for overlaying shadows onto a camera feed in AR.

Unshaded
~~~~~~~~

In most cases it is common for materials to be affected by lighting (shaded).

However, in some cases you might want to show just the albedo (color) and
ignore the rest. Toggling this flag on will remove all shading and display
pure, unlit color.

.. image:: img/spatial_material26.png

Vertex Lighting
~~~~~~~~~~~~~~~

Godot has a more or less uniform cost per pixel thanks to depth pre-pass. All
lighting calculations are made by running the lighting shader on every pixel.

As these calculations are costly, performance can be brought down considerably
in some corner cases such as drawing several layers of transparency (which is
common in particle systems). Switching to per-vertex lighting may help in these
cases.

Additionally, on low-end or mobile devices, switching to vertex lighting
can considerably increase rendering performance.

.. image:: img/spatial_material2.png

Keep in mind that when vertex lighting is enabled, only directional lighting
can produce shadows (for performance reasons).

No Depth Test
~~~~~~~~~~~~~

In order for close objects to appear over far away objects, depth testing
is performed. Disabling it has the result of objects appearing over
(or under) everything else.

Disabling this makes the most sense for drawing indicators in world space,
and works very well with the *Render Priority* property of Material
(see the bottom of this page).

.. image:: img/spatial_material3.png

Use Point Size
~~~~~~~~~~~~~~~

This option is only effective when the geometry rendered is made of points
(generally it's made of triangles when imported from 3D DCCs). If so, then
those points can be resized (see below).

World Triplanar
~~~~~~~~~~~~~~~

When using triplanar mapping (see below, in the UV1 and UV2 settings),
triplanar is computed in object local space. This option makes triplanar work
in world space.

Fixed Size
~~~~~~~~~~

This causes the object to be rendered at the same size no matter the distance.
This is useful mostly for indicators (no depth test and high render priority)
and some types of billboards.

Do Not Receive Shadows
~~~~~~~~~~~~~~~~~~~~~~

Makes the object not receive any kind of shadow that would otherwise
be cast onto it.

Disable Ambient Light
~~~~~~~~~~~~~~~~~~~~~

Makes the object not receive any kind of ambient lighting that would
otherwise light it.

Ensure Correct Normals
~~~~~~~~~~~~~~~~~~~~~~

Fixes normals when non-uniform scaling is used.

Vertex Color
------------

This setting allows choosing what is done by default to vertex colors that come
from your 3D modelling application. By default, they are ignored.

.. image:: img/spatial_material4.png

Use as Albedo
~~~~~~~~~~~~~

Choosing this option means vertex color is used as albedo color.

Is sRGB
~~~~~~~

Most 3D DCCs will likely export vertex colors as sRGB, so toggling this
option on will help them look correct.

Parameters
-----------

``SpatialMaterial`` also has several configurable parameters to tweak
many aspects of the rendering:

.. image:: img/spatial_material5.png

Diffuse Mode
~~~~~~~~~~~~

Specifies the algorithm used by diffuse scattering of light when hitting
the object. The default is *Burley*. Other modes are also available:

* **Burley:** Default mode, the original Disney Principled PBS diffuse algorithm.
* **Lambert:** Is not affected by roughness.
* **Lambert Wrap:** Extends Lambert to cover more than 90 degrees when
  roughness increases. Works great for hair and simulating cheap
  subsurface scattering. This implementation is energy conserving.
* **Oren Nayar:** This implementation aims to take microsurfacing into account
  (via roughness). Works well for clay-like materials and some types of cloth.
* **Toon:** Provides a hard cut for lighting, with smoothing affected by roughness.
  It is recommended you disable sky contribution from your environment's
  ambient light settings or disable ambient light in the spatial material
  to achieve a better effect.

.. image:: img/spatial_material6.png

Specular Mode
~~~~~~~~~~~~~

Specifies how the specular blob will be rendered. The specular blob
represents the shape of a light source reflected in the object.

* **ShlickGGX:** The most common blob used by PBR 3D engines nowadays.
* **Blinn:** Common in previous-generation engines.
  Not worth using nowadays, but left here for the sake of compatibility.
* **Phong:** Same as above.
* **Toon:** Creates a toon blob, which changes size depending on roughness.
* **Disabled:** Sometimes the blob gets in the way. Begone!

.. image:: img/spatial_material7.png

Blend Mode
~~~~~~~~~~

Controls the blend mode for the material. Keep in mind that any mode
other than *Mix* forces the object to go through the transparent pipeline.

* **Mix:** Default blend mode, alpha controls how much the object is visible.
* **Add:** Object is blended additively, nice for flares or some
  fire-like effects.
* **Sub:** Object is subtracted.
* **Mul:** Object is multiplied.

.. image:: img/spatial_material8.png

Cull Mode
~~~~~~~~~

Determines which side of the object is not drawn when backfaces are rendered:

* **Back:** The back of the object is culled when not visible (default).
* **Front:** The front of the object is culled when not visible.
* **Disabled:** Used for objects that are double-sided (no culling is performed).

.. note::

    By default, Blender has backface culling disabled on materials and will
    export materials to match how they render in Blender. This means that
    materials in Godot will have their cull mode set to **Disabled**. This can
    decrease performance since backfaces will be rendered, even when they are
    being culled by other faces. To resolve this, enable **Backface Culling** in
    Blender's Materials tab, then export the scene to glTF again.

Depth Draw Mode
~~~~~~~~~~~~~~~

Specifies when depth rendering must take place.

* **Opaque Only (default):** Depth is only drawn for opaque objects.
* **Always:** Depth draw is drawn for both opaque and transparent objects.
* **Never:** No depth draw takes place
  (do not confuse this with the No Depth Test option above).
* **Depth Pre-Pass:** For transparent objects, an opaque pass is made first
  with the opaque parts, then transparency is drawn above.
  Use this option with transparent grass or tree foliage.

.. image:: img/material_depth_draw.png

Line Width
~~~~~~~~~~

When drawing lines, specify the width of the lines being drawn.
This option is not available on most modern hardware.

Point Size
~~~~~~~~~~

When drawing points, specify the point size in pixels.

Billboard Mode
~~~~~~~~~~~~~~

Enables billboard mode for drawing materials. This controls how the object
faces the camera:

* **Disabled:** Billboard mode is disabled.
* **Enabled:** Billboard mode is enabled, the object's -Z axis will always
  face the camera.
* **Y-Billboard:** The object's X axis will always be aligned with the camera.
* **Particles:** Most suited for particle systems, because it allows
  specifying animation options.

.. image:: img/spatial_material9.png

The above options are only enabled for Particle Billboard.

Billboard Keep Scale
~~~~~~~~~~~~~~~~~~~~

Enables scaling a mesh in billboard mode.

Grow
~~~~

Grows the object vertices in the direction pointed by their normals:

.. image:: img/spatial_material10.png

This is commonly used to create cheap outlines. Add a second material pass,
make it black and unshaded, reverse culling (Cull Front), and add some grow:

.. image:: img/spatial_material11.png


Use Alpha Scissor
~~~~~~~~~~~~~~~~~

When transparency other than ``0`` or ``1`` is not needed, it's possible to
set a threshold to prevent the object from rendering semi-transparent pixels.

.. image:: img/spatial_material12.png

This renders the object via the opaque pipeline, which is faster and allows it
to use mid- and post-process effects such as SSAO, SSR, etc.

Material colors, maps and channels
----------------------------------

Besides the parameters, what defines materials themselves are the colors,
textures, and channels. Godot supports an extensive list of them. They are
described in detail below:

Albedo
~~~~~~

*Albedo* is the base color for the material, on which all the other settings
operate. When set to *Unshaded*, this is the only color that is visible. In
previous versions of Godot, this channel was named *Diffuse*. The change
of name mainly happened because, in PBR (Physically Based Rendering), this color affects many
more calculations than just the diffuse lighting path.

Albedo color and texture can be used together as they are multiplied.

*Alpha channel* in albedo color and texture is also used for the
object transparency. If you use a color or texture with *alpha channel*,
make sure to either enable transparency or *alpha scissoring* for it to work.

Metallic
~~~~~~~~

Godot uses a metallic model over competing models due to its simplicity.
This parameter defines how reflective the material is. The more reflective, the
less diffuse/ambient light affects the material and the more light is reflected.
This model is called "energy-conserving".

The *Specular* parameter is a general amount for the reflectivity (unlike
*Metallic*, this is not energy-conserving, so leave it at ``0.5`` and don't touch
it unless you need to).

The minimum internal reflectivity is ``0.04``, so it's impossible to make a
material completely unreflective, just like in real life.

.. image:: img/spatial_material13.png

Roughness
~~~~~~~~~

*Roughness* affects the way reflection happens. A value of ``0`` makes it a
perfect mirror while a value of ``1`` completely blurs the reflection (simulating
natural microsurfacing). Most common types of materials can be achieved with
the right combination of *Metallic* and *Roughness*.

.. image:: img/spatial_material14.png

Emission
~~~~~~~~

*Emission* specifies how much light is emitted by the material (keep in mind this
does not include light surrounding geometry unless :ref:`doc_gi_probes` are used).
This value is added to the resulting final image and is not affected by other
lighting in the scene.

.. image:: img/spatial_material15.png

Normal map
~~~~~~~~~~

Normal mapping allows you to set a texture that represents finer shape detail.
This does not modify geometry, only the incident angle for light. In Godot,
only the red and green channels of normal maps are used for better compression
and wider compatibility.

.. image:: img/spatial_material16.png

.. note::

  Godot requires the normal map to use the X+, Y+ and Z+ coordinates, this is
  known as OpenGL style. If you've imported a material made to be used with
  another engine it may be DirectX style, in which case the normal map needs to
  be converted so its Y axis is flipped.

  More information about normal maps (including a coordinate order table for
  popular engines) can be found
  `here <http://wiki.polycount.com/wiki/Normal_Map_Technical_Details>`__.

Rim
~~~

Some fabrics have small micro-fur that causes light to scatter around it. Godot
emulates this with the *Rim* parameter. Unlike other rim lighting implementations,
which just use the emission channel, this one actually takes light into account
(no light means no rim). This makes the effect considerably more believable.

.. image:: img/spatial_material17.png

Rim size depends on roughness, and there is a special parameter to specify how
it must be colored. If *Tint* is ``0``, the color of the light is used for the
rim. If *Tint* is ``1``, then the albedo of the material is used. Using
intermediate values generally works best.

Clearcoat
~~~~~~~~~

*This feature is only available when using the GLES3 backend.*

The *Clearcoat* parameter is used to add a secondary pass of transparent coat
to the material. This is common in car paint and toys. In practice, it's a
smaller specular blob added on top of the existing material.

The effect is extremely subtle in Godot 3 releases, and may require specific
lighting or looking at a material a specific way to notice a difference.
This can be seen in the image below where clearcoat is turned on in the
right.

.. image:: img/clearcoat_comparison.png

.. note:: The effect will be more noticeable in Godot 4.

Anisotropy
~~~~~~~~~~

*This feature is only available when using the GLES3 backend.*

This changes the shape of the specular blob and aligns it to tangent space.
Anisotropy is commonly used with hair, or to make materials such as brushed
aluminum more realistic. It works especially well when combined with flowmaps.

.. image:: img/spatial_material18.png

Ambient Occlusion
~~~~~~~~~~~~~~~~~~

It is possible to specify a baked ambient occlusion map. This map affects how
much ambient light reaches each surface of the object (it does not affect direct
light by default). While it is possible to use Screen-Space Ambient Occlusion
(SSAO) to generate ambient occlusion, nothing beats the quality of a well-baked
AO map. It is recommended to bake ambient occlusion whenever possible.

.. image:: img/spatial_material19.png

Depth
~~~~~

*This feature is only available when using the GLES3 backend.*

Setting a depth map on a material produces a ray-marched search to emulate the
proper displacement of cavities along the view direction. This is not real
added geometry, but an illusion of depth. It may not work for complex objects,
but it produces a realistic depth effect for textures. For best results,
*Depth* should be used together with normal mapping.

.. image:: img/spatial_material20.png

Subsurface Scattering
~~~~~~~~~~~~~~~~~~~~~

*This feature is only available when using the GLES3 backend.*

This effect emulates light that penetrates an object's surface, is scattered,
and then comes out. It is useful to create realistic skin, marble, colored
liquids, etc.

.. image:: img/spatial_material21.png

Transmission
~~~~~~~~~~~~

This controls how much light from the lit side (visible to light) is transferred
to the dark side (opposite from the light). This works well for thin objects
such as plant leaves, grass, human ears, etc.

.. image:: img/spatial_material22.png

Refraction
~~~~~~~~~~~

*This feature is only available when using the GLES3 backend.*

When refraction is enabled, it supersedes alpha blending, and Godot attempts to
fetch information from behind the object being rendered instead. This allows
distorting the transparency in a way similar to refraction in real life.

Remember to use a transparent albedo texture (or reduce the albedo color's alpha
channel) to make refraction visible, as refraction relies on transparency to
have a visible effect.

A normal map can optionally be specified in the **Refraction Texture** property
to allow distorting the refraction's direction on a per-pixel basis.

.. image:: img/spatial_material23.png

.. note::

    Refraction is implemented as a screen-space effect and forces the material
    to be transparent. This makes the effect relatively fast, but this results
    in some limitations:

    - :ref:`Transparency sorting <doc_3d_rendering_limitations_transparency_sorting>`
      issues may occur.
    - The refractive material cannot refract onto itself, or onto other
      transparent materials. A refractive material behind another transparent
      material will be invisible.
    - Off-screen objects cannot appear in the refraction. This is most
      noticeable with high refraction strength values.
    - Opaque materials in front of the refractive material will appear to have
      "refracted" edges, even though they shouldn't.

Detail
~~~~~~

Godot allows using secondary albedo and normal maps to generate a detail
texture, which can be blended in many ways. By combining this with secondary
UV or triplanar modes, many interesting textures can be achieved.

.. image:: img/spatial_material24.png

There are several settings that control how detail is used.

Mask: The detail mask is a black and white image used to control where the
blending takes place on a texture. White is for the detail textures, Black
is for the regular material textures, different shades of gray are for
partial blending of the material textures and detail textures.

Blend Mode: These four modes control how the textures are blended together.

- Mix: Combines pixel values of both textures. At black, only show the material texture,
  at white, only show the detail texture. Values of gray create a smooth blend between
  the two.

- Add: Adds pixel values of one Texture with the other. Unlike mix mode
  both textures are completely mixed at white parts of a mask and not at gray
  parts. The original texture is mostly unchanged at black

- Sub: Subtracts pixel values of one texture with the other. The second
  texture is completely subtracted at white parts of a mask with only a little
  subtraction in black parts, gray parts being different levels of subtraction
  based on the exact texture.

- Mul: Multiplies the RGB channel numbers for each pixel from the top texture
  with the values for the corresponding pixel from the bottom texture.

Albedo: This is where you put an albedo texture you want to blend. If nothing
is in this slot it will be interpreted as white by default.

Normal: This is where you put a normal texture you want to blend. If nothing is
in this slot it will be interpreted as a flat normal map. This can still be used
even if the material does not have normal map enabled.

UV1 and UV2
~~~~~~~~~~~~

Godot supports two UV channels per material. Secondary UV is often useful for
ambient occlusion or emission (baked light). UVs can be scaled and offset,
which is useful when using repeating textures.

Triplanar Mapping
~~~~~~~~~~~~~~~~~

Triplanar mapping is supported for both UV1 and UV2. This is an alternative way
to obtain texture coordinates, sometimes called "Autotexture". Textures are
sampled in X, Y and Z and blended by the normal. Triplanar mapping can be
performed in either world space or object space.

In the image below, you can see how all primitives share the same material with
world triplanar, so the brick texture continues smoothly between them.

.. image:: img/spatial_material25.png

Proximity and distance fade
----------------------------

Godot allows materials to fade by proximity to each other as well as depending
on the distance from the viewer. Proximity fade is useful for effects such as
soft particles or a mass of water with a smooth blending to the shores. Distance
fade is useful for light shafts or indicators that are only present after a
given distance.

Keep in mind enabling these enables alpha blending, so abusing them for an
entire scene is usually not a good idea.

.. image:: img/spatial_material_proxfade.gif

Render priority
---------------

The rendering order of objects can be changed, although this is mostly
useful for transparent objects (or opaque objects that perform depth draw
but no color draw, such as cracks on the floor).


===================================================
/. ./tutorials/3d/lights_and_shadows.rst
===================================================

.. _doc_lights_and_shadows:

3D lights and shadows
=====================

Introduction
------------

Light sources emit light that mixes with the materials and produces a visible
result. Light can come from several types of sources in a scene:

-  From the Material itself in the form of the emission color (though
   it does not affect nearby objects unless baked).
-  Light Nodes: Directional, Omni and Spot.
-  Ambient Light in the
   :ref:`Environment <class_Environment>`.
-  Baked Light (read :ref:`doc_baked_lightmaps`).

The emission color is a material property. You can read more about it
in the :ref:`doc_spatial_material` tutorial.

Light nodes
-----------

There are three types of light nodes: `Directional light`_,
`Omni light`_ and `Spot light`_. Let's take a look at the common
parameters for lights:

.. image:: img/light_params.png

Each one has a specific function:

-  **Color**: Base color for emitted light.
-  **Energy**: Energy multiplier. This is useful for saturating lights or working with :ref:`doc_high_dynamic_range`.
-  **Indirect Energy**: Secondary multiplier used with indirect light (light bounces). This works in baked light or GIProbe.
-  **Negative**: Light becomes subtractive instead of additive. It's sometimes useful to manually compensate some dark corners.
-  **Specular**: Affects the intensity of the specular blob in objects affected by this light. At zero, this light becomes a pure diffuse light.
-  **Bake Mode**: Sets the bake mode for the light. For more information see :ref:`doc_baked_lightmaps`
-  **Cull Mask**: Objects that are in the selected layers below will be affected by this light.
   Note that objects disabled via this cull mask will still cast shadows.
   If you don't want disabled objects to cast shadows, adjust the ``cast_shadow`` property on the
   GeometryInstance to the desired value.

Shadow mapping
^^^^^^^^^^^^^^

Lights can optionally cast shadows. This gives them greater realism (light does
not reach occluded areas), but it can incur a bigger performance cost.
There is a list of generic shadow parameters, each also has a specific function:

-  **Enabled**: Check to enable shadow mapping in this light.
-  **Color**: Areas occluded are multiplied by this color. It is black by default, but it can be changed to tint shadows.
-  **Bias**: When this parameter is too small, self shadowing occurs. When too large, shadows separate from the casters. Tweak to what works best for you.
-  **Contact**: Performs a short screen-space raycast to reduce the gap generated by the bias. Contact shadows are only available when using the GLES3 backend.
-  **Reverse Cull Face**: Some scenes work better when shadow mapping is rendered with face-culling inverted.

Below is an image of what tweaking bias looks like. Default values work for most
cases, but in general it depends on the size and complexity of geometry.

.. image:: img/shadow_bias.png

Finally, if gaps can't be solved, the **Contact** option can help (at a performance cost):

.. image:: img/shadow_contact.png

Any sort of bias issues can always be fixed by increasing the shadow map resolution,
although that may lead to decreased performance.

.. tip::

    If shadow biasing is a problem in your scene, the following settings are a good starting point:

    - Enable **Reverse Cull Face**. This reduces shadow peter-panning significantly
      and prevents lights from exhibiting shadow acne at grazing angles.
      The main downside is that it may cause lighting to leak in some corners.
      The other downside is that materials that have their cull mode set to
      **Disabled** or MeshInstances with Cast Shadow set to **Double-Sided**
      may exhibit shadow acne.
    - Set **Bias** to ``-0.01``. The bias should be a negative value when
      **Reverse Cull Face** is enabled, but it should be a positive value when it's disabled.
    - For DirectionalLight, set the directional shadow **Normal Bias** to ``0.0``
      and **Bias Split Scale** to ``0.0``. Depending on your scene, you may also
      want to further decrease **Bias** to a value between ``-0.05`` and ``-0.1``.

    Following the above tips should make it possible to avoid gaps in shadows without
    resorting to contact shadows (which have many issues of their own).
    If shadow acne is still visible after performing the above tweaks,
    try subdividing your meshes further in your 3D modeling software.

Directional light
~~~~~~~~~~~~~~~~~

This is the most common type of light and represents a light source
very far away (such as the sun). It is also the cheapest light to compute and should be used whenever possible
(although it's not the cheapest shadow-map to compute, but more on that later).

Directional light models an infinite number of parallel light rays
covering the whole scene. The directional light node is represented by a big arrow which
indicates the direction of the light rays. However, the position of the node
does not affect the lighting at all and can be anywhere.

.. image:: img/light_directional.png

Every face whose front-side is hit by the light rays is lit, while the others stay dark. Most light types
have specific parameters, but directional lights are pretty simple in nature, so they don't.

Directional shadow mapping
^^^^^^^^^^^^^^^^^^^^^^^^^^

To compute shadow maps, the scene is rendered (only depth) from an orthogonal point of view that covers
the whole scene (or up to the max distance). There is, however, a problem with this approach because objects
closer to the camera receive blocky shadows.

.. image:: img/shadow_blocky.png

To fix this, a technique named "Parallel Split Shadow Maps" (or PSSM) is used. This splits the view frustum in 2 or 4 areas. Each
area gets its own shadow map. This allows small areas close to the viewer to have the same shadow resolution as a huge, far-away area.

.. image:: img/pssm_explained.png

With this, shadows become more detailed:

.. image:: img/shadow_pssm.png

To control PSSM, a number of parameters are exposed:

.. image:: img/directional_shadow_params.png

Each split distance is controlled relative to the camera far (or shadow
**Max Distance** if greater than zero), so *0.0* is the eye position and *1.0*
is where the shadow ends at a distance. Splits are in-between. Default values
generally work well, but tweaking the first split a bit is common to give more
detail to close objects (like a character in a third person game).

Always make sure to set a shadow *Max Distance* according to what the scene needs.
A lower maximum distance will result in better-looking shadows.

Sometimes, the transition between a split and the next can look bad. To fix this,
the **"Blend Splits"** option can be turned on, which sacrifices detail in exchange
for smoother transitions:

.. image:: img/blend_splits.png

The **"Normal Bias"** parameter can be used to fix special cases of self shadowing
when objects are perpendicular to the light. The only downside is that it makes
the shadow a bit thinner.

.. image:: img/normal_bias.png

The **"Bias Split Scale"** parameter can control extra bias for the splits that
are far away. If self shadowing occurs only on the splits far away, this value can fix them.

Finally, the **"Depth Range"** has two settings:

- **Stable**: Keeps the shadow stable while the camera moves, and the blocks that appear in the outline when close to the shadow edges remain in-place. This is the default and generally desired, but it reduces the effective shadow resolution.
- **Optimized**: Tries to achieve the maximum resolution available at any given time. This may result in a "moving saw" effect on shadow edges, but at the same time the shadow looks more detailed (so this effect may be subtle enough to be forgiven).

Just experiment which setting works better for your scene.

Shadowmap size for directional lights can be changed in Project Settings -> Rendering -> Quality:

.. image:: img/project_setting_shadow.png

Increasing it can solve bias problems, but decrease performance. Shadow mapping is an art of tweaking.

Omni light
~~~~~~~~~~

Omni light is a point source that emits light spherically in all directions up to a given
radius.

.. image:: img/light_omni.png

In real life, light attenuation is an inverse function, which means omni lights don't have a radius.
This is a problem because it means computing several omni lights would become demanding.

To solve this, a *Range* is introduced together with an attenuation function.

.. image:: img/light_omni_params.png

These two parameters allow tweaking how this works visually in order to find aesthetically pleasing results.

.. image:: img/light_attenuation.png


Omni shadow mapping
^^^^^^^^^^^^^^^^^^^

Omni light shadow mapping is relatively straightforward. The main issue that needs to be
considered is the algorithm used to render it.

Omni Shadows can be rendered as either **"Dual Paraboloid" or "Cube Mapped"**.
The former renders quickly, but can cause deformations,
while the later is more correct, but costlier.

.. image:: img/shadow_omni_dp_cm.png

If the objects being rendered are mostly irregular, Dual Paraboloid is usually
enough. In any case, as these shadows are cached in a shadow atlas (more on that at the end), it
may not make a difference in performance for most scenes.

Spot light
~~~~~~~~~~

Spot lights are similar to omni lights, except they emit light only into a cone
(or "cutoff"). They are useful to simulate flashlights,
car lights, reflectors, spots, etc. This type of light is also attenuated towards the
opposite direction it points to.

.. image:: img/light_spot.png

Spot lights share the same **Range** and **Attenuation** as **OmniLight**, and add two extra parameters:

- **Angle**: The aperture angle of the light
- **Angle Attenuation**: The cone attenuation, which helps soften the cone borders.

Spot shadow mapping
^^^^^^^^^^^^^^^^^^^

Spots don't need any parameters for shadow mapping. Keep in mind that, at more than 89 degrees of aperture, shadows
stop functioning for spots, and you should consider using an Omni light instead.

Shadow atlas
~~~~~~~~~~~~

Unlike Directional lights, which have their own shadow texture, Omni and Spot lights are assigned to slots of a shadow atlas.
This atlas can be configured in Project Settings -> Rendering -> Quality -> Shadow Atlas.

.. image:: img/shadow_atlas.png

The resolution applies to the whole Shadow Atlas. This atlas is divided into four quadrants:

.. image:: img/shadow_quadrants.png

Each quadrant can be subdivided to allocate any number of shadow maps; the following is the default subdivision:

.. image:: img/shadow_quadrants2.png

The allocation logic is simple. The biggest shadow map size (when no subdivision is used)
represents a light the size of the screen (or bigger).
Subdivisions (smaller maps) represent shadows for lights that are further away
from view and proportionally smaller.

Every frame, the following procedure is performed for all lights:

1. Check if the light is on a slot of the right size. If not, re-render it and move it to a larger/smaller slot.
2. Check if any object affecting the shadow map has changed. If it did, re-render the light.
3. If neither of the above has happened, nothing is done, and the shadow is left untouched.

If the slots in a quadrant are full, lights are pushed back to smaller slots, depending on size and distance.

This allocation strategy works for most games, but you may want to use a separate one in some cases (for example, a top-down game where
all lights are around the same size and quadrants may all have the same subdivision).

Shadow filter quality
~~~~~~~~~~~~~~~~~~~~~

The filter quality of shadows can be tweaked. This can be found in
Project Settings -> Rendering -> Quality -> Shadows.
Godot supports no filter, PCF5 and PCF13.

.. image:: img/shadow_pcf1.png

It affects the blockyness of the shadow outline:

.. image:: img/shadow_pcf2.png


===================================================
/. ./tutorials/3d/reflection_probes.rst
===================================================

.. _doc_reflection_probes:

Reflection probes
=================

Introduction
------------

As stated in the :ref:`doc_spatial_material`, objects can show reflected or diffuse light.
Reflection probes are used as a source of reflected and ambient light for objects inside their area of influence.

A probe of this type captures the surroundings (as a sort of 360 degrees image), and stores versions
of it with increasing levels of *blur*. This is used to simulate roughness in materials, as well as ambient lighting.

While these probes are an efficient way of storing reflections, they have a few shortcomings:

* They are efficient to render, but expensive to compute. This leads to a default behavior where they only capture on scene load.
* They work best for rectangular shaped rooms or places, otherwise the reflections shown are not as faithful (especially when roughness is 0).

Setting up
----------

Create a ReflectionProbe node and wrap it around the area where you want to have reflections:

.. image:: img/refprobe_setup.png

This should result in immediate local reflections. If you are using a Sky texture,
reflections are by default blended with it.

By default, on interiors, reflections may appear not to have much consistence.
In this scenario, make sure to tick the *"Box Correct"* property.

.. image:: img/refprobe_box_property.png


This setting changes the reflection from an infinite skybox to reflecting
a box the size of the probe:

.. image:: img/refprobe_boxcorrect.png

Adjusting the box walls may help improve the reflection a bit, but it will
always look best in box shaped rooms.

The probe captures the surrounding from the center of the gizmo. If, for some
reason, the room shape or contents occlude the center, it
can be displaced to an empty place by moving the handles in the center:

.. image:: img/refprobe_center_gizmo.png

By default, shadow mapping is disabled when rendering probes (only in the
rendered image inside the probe, not the actual scene). This is
a simple way to save on performance and memory. If you want shadows in the probe,
they can be toggled on/off with the *Enable Shadow* setting:

.. image:: img/refprobe_shadows.png

Finally, keep in mind that you may not want the Reflection Probe to render some
objects. A typical scenario is an enemy inside the room which will
move around. To keep objects from being rendered in the reflections,
use the *Cull Mask* setting:

.. image:: img/refprobe_cullmask.png

Interior vs exterior
--------------------

If you are using reflection probes in an interior setting, it is recommended
that the **Interior** property be enabled. This stops
the probe from rendering the sky and also allows custom ambient lighting settings.

.. image:: img/refprobe_ambient.png

When probes are set to **Interior**, custom constant ambient lighting can be
specified per probe. Just choose a color and an energy.

Optionally, you can blend this ambient light with the probe diffuse capture by
tweaking the **Ambient Contribution** property (0.0 means pure ambient color,
while 1.0 means pure diffuse capture).

Blending
--------

Multiple reflection probes can be used, and Godot will blend them where they overlap using a smart algorithm:

.. image:: img/refprobe_blending.png

As you can see, this blending is never perfect (after all, these are
box reflections, not real reflections), but these artifacts
are only visible when using perfectly mirrored reflections.
Normally, scenes have normal mapping and varying levels of roughness, which
can hide this.

Alternatively, Reflection Probes work well blended together with Screen Space
Reflections to solve these problems. Combining them makes local reflections appear
more faithful, while probes are only used as a fallback when no screen-space information is found:

.. image:: img/refprobe_ssr.png

Finally, blending interior and exterior probes is the recommended approach when making
levels that combine both interiors and exteriors. Near the door, a probe can
be marked as *exterior* (so it will get sky reflections) while on the inside, it can be interior.

Reflection atlas
----------------

In the current renderer implementation, all probes are the same size and
are fit into a Reflection Atlas. The size and amount of probes can be
customized in Project Settings -> Quality -> Reflections

The default setting of Atlas Subdiv: 8 will allow up to 16 reflection probes in a scene. This value needs to be increased if you need more reflection probes.

.. image:: img/refprobe_atlas.png


===================================================
/. ./tutorials/3d/gi_probes.rst
===================================================

.. _doc_gi_probes:

Using GIProbe
=============

Introduction
------------

.. note:: This feature is only available when using the GLES3 backend.
          :ref:`doc_baked_lightmaps` can be used as an alternative
          when using the GLES2 renderer.

Just like with :ref:`doc_reflection_probes`, and as stated in
the :ref:`doc_spatial_material`, objects can show reflected or diffuse light.
GI Probes are similar to Reflection Probes, but they use a different and more
complex technique to produce indirect light and reflections.

The strength of GI Probes is real-time, high quality, indirect light. While the
scene needs a quick pre-bake for the static objects that
will be used, lights can be added, changed or removed, and this will be updated
in real-time. Dynamic objects that move within one of these
probes will also receive indirect lighting from the scene automatically.

Just like with ``ReflectionProbe``, ``GIProbe`` can be blended (in a bit more limited
way), so it is possible to provide full real-time lighting
for a stage without having to resort to lightmaps.

The main downsides of ``GIProbe`` are:

- A small amount of light leaking can occur if the level is not carefully designed. This must be artist-tweaked.
- Performance requirements are higher than for lightmaps, so it may not run properly in low-end integrated GPUs (may need to reduce resolution).
- Reflections are voxelized, so they don't look as sharp as with ``ReflectionProbe``. However, in exchange they are volumetric, so any room size or shape works for them. Mixing them with Screen Space Reflection also works well.
- They consume considerably more video memory than Reflection Probes, so they must be used with care in the right subdivision sizes.

Setting up
----------

Just like a ``ReflectionProbe``, simply set up the ``GIProbe`` by wrapping it around
the geometry that will be affected.

.. image:: img/giprobe_wrap.png

Afterwards, make sure to enable the **Use In Baked Light** property on the geometry instances
in the inspector. This is required for ``GIProbe`` to recognize objects,
otherwise they will be ignored:

.. image:: img/giprobe_bake_property.png

Once the geometry is set up, push the Bake button that appears on the 3D editor
toolbar to begin the pre-baking process:

.. image:: img/giprobe_bake.png

.. warning::

    Meshes should have sufficiently thick walls to avoid light leaks (avoid
    one-sided walls). For interior levels, enclose your level geometry in a
    sufficiently large box and bridge the loops to close the mesh.

Adding lights
-------------

Unless there are materials with emission, ``GIProbe`` does nothing by default.
Lights need to be added to the scene to have an effect.

The effect of indirect light can be viewed quickly (it is recommended you turn
off all ambient/sky lighting to tweak this, though, as shown below):

.. image:: img/giprobe_indirect.png

In some situations, though, indirect light may be too weak. Lights have an
indirect multiplier to tweak this:

.. image:: img/giprobe_light_indirect.png

And, as ``GIProbe`` lighting updates in real-time, this effect is immediate:

.. image:: img/giprobe_indirect_energy_result.png

Reflections
-----------

For very metallic materials with low roughness, it's possible to appreciate
voxel reflections. Keep in mind that these have far less detail than Reflection
Probes or Screen Space Reflections, but fully reflect volumetrically.

.. image:: img/giprobe_voxel_reflections.png

``GIProbe``\ s can be easily mixed with Reflection Probes and Screen Space Reflections,
as a full 3-stage fallback-chain. This allows to have precise reflections where needed:

.. image:: img/giprobe_ref_blending.png

Interior vs exterior
--------------------

GI Probes normally allow mixing with lighting from the sky. This can be disabled
when turning on the *Interior* setting.

.. image:: img/giprobe_interior_setting.png

The difference becomes clear in the image below, where light from the sky goes
from spreading inside to being ignored.

.. image:: img/giprobe_interior.png

As complex buildings may mix interiors with exteriors, combining GIProbes
for both parts works well.

Tweaking
--------

GI Probes support a few parameters for tweaking:

.. image:: img/giprobe_tweaking.png

- **Subdiv** Subdivision used for the probe. The default (128) is generally good for small- to medium-sized areas. Bigger subdivisions use more memory.
- **Extents** Size of the probe. Can be tweaked from the gizmo.
- **Dynamic Range** Maximum light energy the probe can absorb. Higher values allow brighter light, but with less color detail.
- **Energy** Multiplier for all the probe. Can be used to make the indirect light brighter (although it's better to tweak this from the light itself).
- **Propagation** How much light propagates through the probe internally.
- **Bias** Value used to avoid self-occlusion when doing voxel cone tracing, should generally be above 1.0 (1==voxel size).
- **Normal Bias** Alternative type of bias useful for some scenes. Experiment with this one if regular bias does not work.
- **Interior** Allows mixing with lighting from the sky.
- **Compress** Currently broken. Do not use.
- **Data** Contains the light baked data after baking. If you are saving the data it should be saved as a .res file.

Quality
-------

``GIProbe``\ s are quite demanding. It is possible to use lower quality voxel cone
tracing in exchange for more performance.

.. image:: img/giprobe_quality.png


===================================================
/. ./tutorials/3d/baked_lightmaps.rst
===================================================

.. _doc_baked_lightmaps:

Baked lightmaps
===============

Introduction
------------

Baked lightmaps are an alternative workflow for adding indirect (or fully baked)
lighting to a scene. Unlike the :ref:`doc_gi_probes` approach, baked lightmaps
work fine on low-end PCs and mobile devices, as they consume almost no resources
at run-time. Also unlike GIProbe, baked lightmaps can optionally be used to
store direct lighting, which provides even further performance gains.

Unlike GIProbes, Baked Lightmaps are completely static. Once baked, they
can't be modified at all. They also don't provide the scene with reflections, so
using :ref:`doc_reflection_probes` together with it on interiors (or using a Sky
on exteriors) is a requirement to get good quality.

As they are baked, they have fewer problems than ``GIProbe`` regarding light
bleeding, and indirect light will often look better. The downside is that baking
lightmaps takes much longer than baking a GIProbe. While baking a GIProbe can be
done in a matter of seconds, baking lightmaps will take several minutes if not
more. This can slow down iteration speed significantly, so it is recommended to
bake lightmaps only when you actually need to see changes in lighting.

Baking lightmaps will also reserve baked materials' UV2 slot, which means you can
no longer use it for other purposes in materials (either in the built-in
:ref:`doc_spatial_material` or in custom shaders).

In the end, deciding which indirect lighting approach is better depends on your
use case. In general, GIProbe is easier to set up and works better with dynamic
objects. For mobile or low-end compatibility, though, baked lightmaps are your
only choice.

Visual comparison
-----------------

Here are some comparisons of how BakedLightmap vs. GIProbe look. Notice that
lightmaps are more accurate, but also suffer from the fact
that lighting is on an unwrapped texture, so transitions and resolution may not
be that good. GIProbe looks less accurate (as it's an approximation), but
smoother overall.

.. image:: img/baked_light_comparison.png

Setting up
----------

First of all, before the lightmapper can do anything, the objects to be baked need
an UV2 layer and a texture size. An UV2 layer is a set of secondary texture coordinates
that ensures any face in the object has its own place in the UV map. Faces must
not share pixels in the texture.

There are a few ways to ensure your object has a unique UV2 layer and texture size:

Unwrap on scene import
~~~~~~~~~~~~~~~~~~~~~~

This is probably the best approach overall. The only downside is that, on large
models, unwrapping can take a while on import. Nonetheless, Godot will cache the UV2
across reimports, so it will only be regenerated when needed.

Select the imported scene in the filesystem dock, then go to the **Import** dock.
There, the following option can be modified:

.. image:: img/baked_light_import.png

The **Light Baking** mode needs to be set to **Gen Lightmaps**. A texel size
in world units must also be provided, as this will determine the
final size of the lightmap texture (and, in consequence, the UV padding in the map).

The effect of setting this option is that all meshes within the scene will have
their UV2 maps properly generated.

.. warning::

    When reusing a mesh within a scene, keep in mind that UVs will be generated
    for the first instance found. If the mesh is re-used with different scales
    (and the scales are wildly different, more than half or twice), this will
    result in inefficient lightmaps. Don't reuse a source mesh at significantly
    different scales if you are planning to use lightmapping.

    Also, the ``*.unwrap_cache`` files should *not* be ignored in version control
    as these files guarantee that UV2 reimports are consistent across platforms
    and engine versions.

Unwrap from within Godot
~~~~~~~~~~~~~~~~~~~~~~~~

Godot has an option to unwrap meshes and visualize the UV channels.
It can be found in the Mesh menu:

.. image:: img/baked_light_mesh_menu.png

This will generate a second set of UV2 coordinates which can be used for baking,
and it will also set the texture size automatically.

Unwrap from your 3D DCC
~~~~~~~~~~~~~~~~~~~~~~~

The last option is to do it from your favorite 3D app. This approach is generally
not recommended, but it's explained first so that you know it exists.
The main advantage is that, on complex objects that you may want to re-import a
lot, the texture generation process can be quite costly within Godot,
so having it unwrapped before import can be faster.

Simply do an unwrap on the second UV2 layer.

.. image:: img/baked_light_blender.png

Then import the 3D scene normally. Remember you will need to set the texture
size on the mesh after import.

.. image:: img/baked_light_lmsize.png

If you use external meshes on import, the size will be kept.
Be wary that most unwrappers in 3D DCCs are not quality oriented, as they are
meant to work quickly. You will mostly need to use seams or other techniques to
create better unwrapping.

Checking UV2
~~~~~~~~~~~~

In the mesh menu mentioned before, the UV2 texture coordinates can be visualized.
Make sure, if something is failing, to check that the meshes have these UV2 coordinates:

.. image:: img/baked_light_uvchannel.png

Setting up the scene
--------------------

Before anything is done, a **BakedLightmap** node needs to be added to a scene.
This will enable light baking on all nodes (and sub-nodes) in that scene, even
on instanced scenes.

.. image:: img/baked_light_scene.png

A sub-scene can be instanced several times, as this is supported by the baker, and
each will be assigned a lightmap of its own (just make sure to respect the rule
about scaling mentioned before):

Configure bounds
~~~~~~~~~~~~~~~~

Lightmap needs an approximate volume of the area affected because it uses it to
transfer light to dynamic objects inside it (more on that later). Just
cover the scene with the volume as you do with ``GIProbe``:

.. image:: img/baked_light_bounds.png

Setting up meshes
~~~~~~~~~~~~~~~~~

For a **MeshInstance** node to take part in the baking process, it needs to have
the **Use in Baked Light** property enabled.

.. image:: img/baked_light_use.png

When auto-generating lightmaps on scene import, this is enabled automatically.

Setting up lights
~~~~~~~~~~~~~~~~~

Lights are baked with indirect light by default. This means that shadowmapping
and lighting are still dynamic and affect moving objects, but light bounces from
that light will be baked.

Lights can be disabled (no bake) or be fully baked (direct and indirect). This
can be controlled from the **Bake Mode** menu in lights:

.. image:: img/baked_light_bake_mode.png

The modes are:

Disabled
^^^^^^^^

The light is ignored when baking lightmaps. Keep in mind hiding a light will have
no effect for baking, so this must be used instead of hiding the Light node.

This is the mode to use for dynamic lighting effects such as explosions and weapon effects.

Indirect
^^^^^^^^

This is the default mode, and is a compromise between performance and real-time
friendliness. Only indirect lighting will be baked. Direct light and shadows are
still real-time, as they would be without BakedLightmap.

This mode allows performing *subtle* changes to a light's color, energy and
position while still looking fairly correct. For example, you can use this
to create flickering static torches that have their indirect light baked.

All
^^^

Both indirect and direct lighting will be baked. Since static surfaces can skip
lighting and shadow computations entirely, this mode provides the best
performance along with smooth shadows that never fade based on distance. The
real-time light will not affect baked surfaces anymore, but it will still affect
dynamic objects. When using the **All** bake mode on a light, dynamic objects
will not cast real-time shadows onto baked surfaces, so you need to use a
different approach such as blob shadows instead. Blob shadows can be implemented
with a Sprite3D + RayCast setup, or a negative SpotLight pointing down with its
bake mode set to **Disabled**.

The light will not be adjustable at all during gameplay. Moving
the light and changing its color or energy will not have any effect on static surfaces.

Since bake modes can be adjusted on a per-light basis, it is possible to create
hybrid baked light setups. One popular option is to use a real-time
DirectionalLight with its bake mode set to **Indirect**, and use the **All**
bake mode for OmniLights and SpotLights. This provides good performance while
still allowing dynamic objects to cast real-time shadows in outdoor areas.

After selecting the **All** bake mode on a light, you can optionally
specify a **Size** greater than 0 for the light in the inspector.
This size is used to provide softer shadows depending on the distance between
the shadow caster and the object receiving the shadow. This mimics real life
shadow appearance:

.. image:: img/baked_light_omnilight_size.png

The light's **Size** property is ignored for real-time shadows; it will only affect baked
shadows. When the **Size** property is changed, lightmaps must be baked again to
make changes visible.

Baking
------

To begin the bake process, just push the **Bake Lightmaps** button on top
when selecting the BakedLightmap node:

.. image:: img/baked_light_bake.png

This can take from seconds to minutes (or hours) depending on scene size, bake
method and quality selected.

Balancing bake times with quality
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since high-quality bakes can take very long (up to several hours for large complex scenes),
it is recommended to use lower quality settings at first. Then, once you are confident
with your scene's lighting setup, raise the quality settings and perform a "final"
bake before exporting your project.

.. note::

    By default, the lightmap baker will use all the system's logical CPU cores
    to speed up baking. This can reduce system responsiveness. To preserve system
    responsiveness while lightmaps are baking, you can reduce the number of CPU threads
    used to bake lightmaps. Keeping 1 or 2 CPU threads free will help improve
    system responsiveness, which is useful when multi-tasking while lightmaps are
    baking at the cost of slowing down lightmap baking slightly.

    To do so, open **Editor > Editor Settings** and adjust
    **Editors > 3d > Lightmap Baking Number Of Cpu Threads**.
    The default value (``0``) uses all of the system's logical CPU cores.
    Positive values will specify a number of threads to use, while negative
    values will subtract from the total number of logical CPU cores in the system.
    For example, on a system with 8 logical CPU cores, adjusting the setting to
    ``-1`` will use 7 CPU threads for lightmap baking.

Configuring bake
~~~~~~~~~~~~~~~~

Several more options are present for baking:

- **Bake Extents**: The size of the area affected. This can be edited in the 3D
  editor viewport using the handles. Any object that can have lightmaps baked and
  is *touching* the bake extents will have lightmaps baked for it, but dynamic
  object capture will only work within the extents.

Tweaks
^^^^^^

- **Quality:** Four bake quality modes are provided: Low, Medium, High, and Ultra.
  Higher quality takes more time, but result in a better-looking lightmap with
  less noise. The difference is especially noticeable with emissive materials or
  areas that get little to no direct lighting.
- **Bounces:** The number of bounces to use for indirect lighting. The default value (3)
  is a good compromise between bake times and quality. Higher values will make
  light bounce around more times before it stops, which makes indirect lighting
  look smoother (but also brighter). During the initial lighting iteration work,
  it is recommended to decrease the number of bounces to 1 to speed up baking.
  Remember that your scene will be darker when decreasing the number of bounces.
- **Use Denoiser:** If enabled, uses OpenImageDenoise to make the lightmap
  significantly less noisy. This increases bake times and can occasionally
  introduce artifacts, but the result is often worth it.
- **Use Hdr:** If disabled, lightmaps are smaller on disk, but they won't be
  able to capture any light over white (1.0). This will result in visible clipping
  if you have bright lights in your scene. When HDR is disabled, banding may also
  be visible in the lightmap.
- **Use Color:** If disabled, lightmaps are smaller on disk, but the lightmap
  won't be able to store colored lighting. When baking indirect light only, the
  difference may be barely visible since indirect light is generally not highly
  saturated. However, when baking both direct and indirect lighting using the
  **All** bake mode on a light, this will turn colored lighting into grayscale
  lighting. This can be disabled together with HDR to get the smallest possible
  lightmap file at a given resolution.
- **Bias:** The offset value to use for shadows in 3D units. You generally don't
  need to change this value, except if you run into issues with light bleeding or
  dark spots in your lightmap after baking. This setting does not affect real-time
  shadows casted on baked surfaces.
- **Default Texels Per Unit:** For meshes that do not specify their own lightmap
  texel density, this will be used as the value. Higher values result in
  *lower-resolution* lightmaps, which result in faster bake times and lower file
  sizes at the cost of blurrier indirect lighting and shadows.

Atlas
^^^^^

- **Generate:** If enabled, a texture atlas will be generated for the lightmap.
  This results in more efficient rendering, but is only compatible with the
  GLES3 rendering backend. Disable this setting if your project is allowed to
  fall back to GLES2. (This is not the case by default and must be enabled in
  the Project Settings.) *This setting is ignored when the project is configured
  to use GLES2 by default.*
- **Max Size:** The maximum size of the atlas in pixels. Higher values result
  in a more efficient atlas, but are less compatible with old/low-end hardware.
  If in doubt, leave this setting on its default value (4096).

Capture
^^^^^^^

- **Enabled:** This enables probe capture so that dynamic objects can *receive* indirect lighting.
  Regardless of this setting's value, dynamic objects will not be able to
  *contribute* indirect lighting to the scene. This is a limitation of lightmaps.
- **Cell Size:** The distance between lightmap probes in 3D units. Higher values
  result in more sparse probe placement, which decreases bake times and file
  size at the cost of lower lighting accuracy for dynamic objects.
- **Quality:** The lightmap probe generation quality. Higher values result in
  more accurate lighting, but take longer to bake. This setting does not affect
  the *density* of the lightmap probes, only their quality.
- **Propagation:** Similar to :ref:`GIProbe <doc_gi_probes>`'s Propagation property.
  Higher values result in brighter and more diffuse indirect lighting for
  dynamic objects. Adjust this value depending on your scene to make dynamic
  objects better fit with static baked lighting.

Data
^^^^

- **Light Data**: Contains the light baked data after baking. Textures are saved
  to disk, but this also contains the capture data for dynamic objects, which can
  be heavy. If you are using a scene in ``.tscn`` format, you should save this
  resource to an external binary ``.lmbake`` file to avoid bloating the ``.tscn``
  scene with binary data encoded in Base64.

The Light Data resource can be edited to adjust two additional properties:

- **Energy:** Adjusts the lightmap's brightness. Higher values result in brighter lightmaps.
  This can be adjusted at run-time for short-lived dynamic effects such as thunderstorms.
  However, keep in mind that it will affect *all* baked lights.
- **Interior:** If enabled, dynamic objects will not make use of environment lighting
  and will use light probes for ambient lighting exclusively. If disabled, both
  environment lighting and light probes are used to light up dynamic objects.

.. tip::

    The generated EXR file can be viewed and even edited using an image editor
    to perform post-processing if needed. However, keep in mind that changes to
    the EXR file will be lost when baking lightmaps again.

Dynamic objects
---------------

In other engines or lightmapper implementations, you are generally required to
manually place small objects called "lightprobes" all around the level to
generate *capture* data. This is then used to transfer the light to dynamic
objects that move around the scene.

However, this implementation of lightmapping uses a different method. The process is
automatic, so you don't have to do anything. Just move your objects around, and
they will be lit accordingly. Of course, you have to make sure you set up your
scene bounds accordingly or it won't work.

.. image:: img/baked_light_indirect.gif


===================================================
/. ./tutorials/3d/environment_and_post_processing.rst
===================================================

.. _doc_environment_and_post_processing:

Environment and post-processing
===============================

Godot 3 provides a redesigned Environment resource, as well as a new
post-processing system with many available effects right out of the box.

Environment
-----------

The Environment resource stores all the information required for controlling
rendering environment. This includes sky, ambient lighting, tone mapping,
effects, and adjustments. By itself it does nothing, but it becomes enabled once
used in one of the following locations in order of priority:

Camera node
^^^^^^^^^^^

An Environment can be set to a camera. It will have priority over any other setting.

.. image:: img/environment_camera.png

This is mostly useful when wanting to override an existing environment,
but in general it's a better idea to use the option below.

WorldEnvironment node
^^^^^^^^^^^^^^^^^^^^^

The WorldEnvironment node can be added to any scene, but only one can exist per
active scene tree. Adding more than one will result in a warning.

.. image:: img/environment_world.png

Any Environment added has higher priority than the default Environment
(explained below). This means it can be overridden on a per-scene basis,
which makes it quite useful.

Default environment
^^^^^^^^^^^^^^^^^^^

A default environment can be set, which acts as a fallback when no Environment
was set to a Camera or WorldEnvironment.
Just head to Project Settings -> Rendering -> Environment:

.. image:: img/environment_default.png

New projects created from the Project Manager come with a default environment
(``default_env.tres``). If one needs to be created, save it to disk before
referencing it here.

Environment options
-------------------

Following is a detailed description of all environment options and how they
are intended to be used.

Background
^^^^^^^^^^

The Background section contains settings on how to fill the background (parts of
the screen where objects were not drawn). In Godot 3.0, the background not only
serves the purpose of displaying an image or color, it can also change how objects
are affected by ambient and reflected light.

.. image:: img/environment_background1.png

There are many ways to set the background:

- **Clear Color** uses the default clear color defined by the project. The background will be a constant color.
- **Custom Color** is like Clear Color, but with a custom color value.
- **Sky** lets you define a panorama sky (a 360 degree sphere texture) or a procedural sky (a simple sky featuring a gradient and an optional sun). Objects will reflect it and absorb ambient light from it.
- **Color+Sky** lets you define a sky (as above), but uses a constant color value for drawing the background. The sky will only be used for reflection and ambient light.

Ambient Light
^^^^^^^^^^^^^

Ambient (as defined here) is a type of light that affects every piece of geometry
with the same intensity. It is global and independent of lights that might be
added to the scene.

There are two types of ambient light: the *Ambient Color* (which is a constant
color multiplied by the material albedo) and then one obtained from the *Sky*
(as described before, but a sky needs to be set as background for this to be
enabled).

.. image:: img/environment_ambient.png

When a *Sky* is set as background, it's possible to blend between ambient color
and sky using the **Sky Contribution** setting (this value is 1.0 by default for
convenience, so only the sky affects objects).

Here is a comparison of how different ambient light affects a scene:

.. image:: img/environment_ambient2.png

Finally, there is an **Energy** setting, which is a multiplier. It's useful when
working with HDR.

In general, ambient light should only be used for simple scenes, large exteriors,
or for performance reasons (ambient light is cheap), as it does not provide the
best lighting quality. It's better to generate
ambient light from ReflectionProbe or GIProbe, which will more faithfully simulate
how indirect light propagates. Below is a comparison, in terms of quality, between using a
flat ambient color and a GIProbe:

.. image:: img/environment_ambient_comparison.png

Using one of the methods described above, objects get constant ambient lighting
replaced by ambient light from the probes.

Fog
^^^

Fog, as in real life, makes distant objects fade away into an uniform color. The
physical effect is actually pretty complex, but Godot provides a good approximation.
There are two kinds of fog in Godot:

- **Depth Fog:** This one is applied based on the distance from the camera.
- **Height Fog:** This one is applied to any objects below (or above) a certain height, regardless of the distance from the camera.

.. image:: img/environment_fog_depth_height.png

Both of these fog types can have their curve tweaked, making their transition more or less sharp.

Two properties can be tweaked to make the fog effect more interesting:

The first is **Sun Amount**, which makes use of the Sun Color property of the fog.
When looking towards a directional light (usually a sun), the color of the fog
will be changed, simulating the sunlight passing through the fog.

The second is **Transmit Enabled** which simulates more realistic light transmittance.
In practice, it makes light stand out more across the fog.

.. image:: img/environment_fog_transmission.png

Tonemap
^^^^^^^

*This feature is only available when using the GLES3 backend.*

Selects the tonemapping curve that will be applied to the scene, from a
list of standard curves used in the film and game industry. Tonemapping operators
other than Linear are used to make light and dark areas more homogeneous,
while also avoiding clipping of bright highlights.

The tone mapping options are:

- **Mode:** The tone mapping mode to use.

  - **Linear:** The default tonemapping mode. This is the fastest and simplest
    tonemapping operator, but it causes bright lighting to look blown out, with
    noticeable clipping in the output colors.
  - **Reinhardt:** Performs a variation on rendered pixels' colors by this
    formula: ``color = color / (1 + color)``. This avoids clipping bright
    highlights, but the resulting image can look a bit dull.
  - **Filmic:** This avoids clipping bright highlights, with a resulting image
    that usually looks more vivid than Reinhardt.
  - **ACES Fitted:** Academy Color Encoding System tonemapper.
    ACES Fitted is slightly more expensive than other options, but it handles
    bright lighting in a more realistic fashion by desaturating it as it becomes brighter.
    ACES typically has a more contrasted output compared to Reinhardt and Filmic.
    ACES is the recommended option when aiming for photorealistic visuals.
  - **ACES:** *Deprecated (will be removed in Godot 4.0).* Behaves like ACES,
    but doesn't desaturate lighting as it becomes brighter (which is less realistic).
    It's recommended to use ACES Fitted instead of ACES.

- **Exposure:** Tone mapping exposure which simulates amount of light received
  over time (default: ``1.0``). Higher values result in an overall brighter appearance.
  If the scene appears too dark as a result of a tonemapping operator or whitepoint
  change, try increasing this value slightly.

- **White:** Tone mapping whitepoint, which simulates where in the scale white is
  located (default: ``1.0``). For photorealistic lighting, recommended values are
  between ``6.0`` and ``8.0``. Higher values result in less blown out highlights,
  but make the scene appear slightly darker as a whole.

Auto Exposure (HDR)
^^^^^^^^^^^^^^^^^^^

*This feature is only available when using the GLES3 backend.*

Even though, in most cases, lighting and texturing are heavily artist controlled,
Godot supports a simple high dynamic range implementation with the auto exposure
mechanism. This is generally used for the sake of realism when combining
interior areas with low light and outdoors. Auto exposure simulates the camera
(or eye) in an effort to adapt between light and dark locations and their
different amounts of light.

.. image:: img/environment_hdr_autoexp.gif

The simplest way to use auto exposure is to make sure outdoor lights (or other
strong lights) have energy beyond 1.0. This is done by tweaking their **Energy**
multiplier (on the Light itself). To make it consistent, the **Sky** usually
needs to use the energy multiplier too, to match with the directional light.
Normally, values between 3.0 and 6.0 are enough to simulate indoor-outdoor conditions.

By combining Auto Exposure with *Glow* post processing (more on that below),
pixels that go over the tonemap **White** will bleed to the glow buffer,
creating the typical bloom effect in photography.

.. image:: img/environment_hdr_bloom.png

The user-controllable values in the Auto Exposure section come with sensible
defaults, but you can still tweak them:

.. image:: img/environment_hdr.png

- **Scale:** Value to scale the lighting. Brighter values produce brighter images, smaller ones produce darker ones.
- **Min Luma:** Minimum luminance that auto exposure will aim to adjust for. Luminance is the average of the light in all the pixels of the screen.
- **Max Luma:** Maximum luminance that auto exposure will aim to adjust for.
- **Speed:** Speed at which luminance corrects itself. The higher the value, the faster correction happens.

Mid- and post-processing effects
--------------------------------

A large amount of widely-used mid- and post-processing effects are supported
in the Environment.

Screen-Space Reflections (SSR)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*This feature is only available when using the GLES3 backend.*

While Godot supports three sources of reflection data (Sky, ReflectionProbe, and
GIProbe), they may not provide enough detail for all situations. Scenarios
where Screen Space Reflections make the most sense are when objects are in
contact with each other (object over floor, over a table, floating on water, etc).

.. image:: img/environment_ssr.png

The other advantage (even if only enabled to a minimum), is that it works in real-time
(while the other types of reflections are pre-computed). This can be used to
make characters, cars, etc. reflect on surrounding surfaces when moving around.

A few user-controlled parameters are available to better tweak the technique:

- **Max Steps** determines the length of the reflection. The bigger this number, the more costly it is to compute.
- **Fade In** allows adjusting the fade-in curve, which is useful to make the contact area softer.
- **Fade Out** allows adjusting the fade-out curve, so the step limit fades out softly.
- **Depth Tolerance** can be used for screen-space-ray hit tolerance to gaps. The bigger the value, the more gaps will be ignored.
- **Roughness** will apply a screen-space blur to approximate roughness in objects with this material characteristic.

Keep in mind that screen-space-reflections only work for reflecting opaque
geometry. Transparent materials won't be reflected, as they don't write to the depth buffer.
This also applies to shaders that use ``SCREEN_TEXTURE`` or ``DEPTH_TEXTURE``.

Screen-Space Ambient Occlusion (SSAO)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*This feature is only available when using the GLES3 backend.*

As mentioned in the **Ambient** section, areas where light from light nodes
does not reach (either because it's outside the radius or shadowed) are lit
with ambient light. Godot can simulate this using GIProbe, ReflectionProbe,
the Sky, or a constant ambient color. The problem, however, is that all the
methods proposed previously act more on a larger scale (large regions) than at the
smaller geometry level.

Constant ambient color and Sky are the same everywhere, while GI and
Reflection probes have more local detail, but not enough to simulate situations
where light is not able to fill inside hollow or concave features.

This can be simulated with Screen Space Ambient Occlusion. As you can see in the
image below, its purpose is to make sure concave areas are darker, simulating
a narrower path for the light to enter:

.. image:: img/environment_ssao.png

It is a common mistake to enable this effect, turn on a light, and not be able to
appreciate it. This is because SSAO only acts on *ambient* light, not direct light.

This is why, in the image above, the effect is less noticeable under the direct
light (on the left). If you want to force SSAO to work with direct light too, use
the **Light Affect** parameter (even though this is not correct, some artists like how it looks).

SSAO looks best when combined with a real source of indirect light, like GIProbe:

.. image:: img/environment_ssao2.png

Tweaking SSAO is possible with several parameters:

.. image:: img/environment_ssao_parameters.png

- **Radius/Intensity:** To control the radius or intensity of the occlusion, these two parameters are available. Radius is in world (Metric) units.
- **Radius2/Intensity2:** A Secondary radius/intensity can be used. Combining a large and a small radius AO generally works well.
- **Bias:** This can be tweaked to solve self occlusion, though the default generally works well enough.
- **Light Affect:** SSAO only affects ambient light, but increasing this slider can make it also affect direct light. Some artists prefer this effect.
- **Ao Channel Affect:** If a value of zero is used, only the material's AO texture will be used for ambient occlusion; SSAO will not be applied. Values greater than 0 multiply the AO texture by the SSAO effect to varying degrees. This does not affect materials without an AO texture.
- **Quality:** Depending on quality, SSAO will take more samples over a sphere for every pixel. High quality only works well on modern GPUs.
- **Blur:** Type of blur kernel used. The 1x1 kernel is a simple blur that preserves local detail better, but is not as efficient (generally works better with the high quality setting above), while 3x3 will soften the image better (with a bit of dithering-like effect), but does not preserve local detail as well.
- **Edge Sharpness**: This can be used to preserve the sharpness of edges (avoids areas without AO on creases).

Depth of Field / Far Blur
^^^^^^^^^^^^^^^^^^^^^^^^^

This effect simulates focal distance on high end cameras. It blurs objects behind
a given range. It has an initial **Distance** with a **Transition** region
(in world units):

.. image:: img/environment_dof_far.png

The **Amount** parameter controls the amount of blur. For larger blurs, tweaking
the **Quality** may be needed in order to avoid artifacts.

Depth of Field / Near Blur
^^^^^^^^^^^^^^^^^^^^^^^^^^

This effect simulates focal distance on high end cameras. It blurs objects close
to the camera (acts in the opposite direction as far blur).
It has an initial **Distance** with a **Transition** region (in world units):

.. image:: img/environment_dof_near.png

The **Amount** parameter controls the amount of blur. For larger blurs, tweaking
the **Quality** may be needed in order to avoid artifacts.

It is common to use both blurs together to focus the viewer's attention on a
given object:

.. image:: img/environment_mixed_blur.png

Glow
^^^^

In photography and film, when light amount exceeds the maximum supported by the
media (be it analog or digital), it generally bleeds outwards to darker regions
of the image. This is simulated in Godot with the **Glow** effect.

.. image:: img/environment_glow1.png

By default, even if the effect is enabled, it will be weak or invisible. One of
two conditions need to happen for it to actually show:

- 1) The light in a pixel surpasses the **HDR Threshold** (where 0 is all light surpasses it, and 1.0 is light over the tonemapper **White** value). Normally, this value is expected to be at 1.0, but it can be lowered to allow more light to bleed. There is also an extra parameter, **HDR Scale**, that allows scaling (making brighter or darker) the light surpassing the threshold.

.. image:: img/environment_glow_threshold.png

- 2) The Bloom effect has a value set greater than 0. As it increases, it sends the whole screen to the glow processor at higher amounts.

.. image:: img/environment_glow_bloom.png

Both will cause the light to start bleeding out of the brighter areas.

Once glow is visible, it can be controlled with a few extra parameters:

- **Intensity** is an overall scale for the effect, it can be made stronger or weaker (0.0 removes it).
- **Strength** is how strong the gaussian filter kernel is processed. Greater values make the filter saturate and expand outwards. In general, changing this is not needed, as the size can be more efficiently adjusted with the **Levels**.

The **Blend Mode** of the effect can also be changed:

- **Additive** is the strongest one, as it only adds the glow effect over the image with no blending involved. In general, it's too strong to be used, but can look good with low intensity Bloom (produces a dream-like effect).
- **Screen** ensures glow never brightens more than itself and it works great as an all around.
- **Softlight** is the default and weakest one, producing only a subtle color disturbance around the objects. This mode works best on dark scenes.
- **Replace** can be used to blur the whole screen or debug the effect. It only shows the glow effect without the image below.

To change the glow effect size and shape, Godot provides **Levels**. Smaller
levels are strong glows that appear around objects, while large levels are hazy
glows covering the whole screen:

.. image:: img/environment_glow_layers.png

The real strength of this system, though, is to combine levels to create more
interesting glow patterns:

.. image:: img/environment_glow_layers2.png

Finally, as the highest layers are created by stretching small blurred images,
it is possible that some blockiness may be visible. Enabling **Bicubic Upscaling**
gets rids of it, at a minimal performance cost.
*Note that this is effective only when using the GLES3 backend.*

.. image:: img/environment_glow_bicubic.png

Adjustments
^^^^^^^^^^^

At the end of processing, Godot offers the possibility to do some standard
image adjustments.

.. image:: img/environment_adjustments.png

The first one is being able to change the typical Brightness, Contrast,
and Saturation:

.. image:: img/environment_adjustments_bcs.png

The second is by supplying a color correction gradient. A regular black to
white gradient like the following one will produce no effect:

.. image:: img/environment_adjusments_default_gradient.png

But creating custom ones will allow to map each channel to a different color:

.. image:: img/environment_adjusments_custom_gradient.png


===================================================
/. ./tutorials/3d/high_dynamic_range.rst
===================================================

.. _doc_high_dynamic_range:

High dynamic range lighting
===========================

Introduction
------------

Normally, an artist does all the 3D modelling, then all the texturing,
looks at their awesome looking model in the 3D DCC and says "looks
fantastic, ready for integration!" then goes into the game, lighting is
setup and the game runs.

So at what point does all this "HDR" business come into play? To understand
the answer, we need to look at how displays behave.

Your display outputs linear light ratios from some maximum to some minimum
intensity. Modern game engines perform complex math on linear light values in
their respective scenes. So what's the problem?

The display has a limited range of intensity, depending on the display type.
The game engine renders to an unlimited range of intensity values, however.
While "maximum intensity" means something to an sRGB display, it has no bearing
in the game engine; there is only a potentially infinitely wide range
of intensity values generated per frame of rendering.

This means that some transformation of the scene light intensity, also known
as *scene-referred* light ratios, need to be transformed and mapped to fit
within the particular output range of the chosen display. This can be most
easily understood if we consider virtually photographing our game engine scene
through a virtual camera. Here, our virtual camera would apply a particular
camera rendering transform to the scene data, and the output would be ready
for display on a particular display type.

.. note::

    Godot does not support high dynamic range *output* yet. It can only perform
    lighting in HDR and tonemap the result to a low dynamic range image.

    For advanced users, it is still possible to get a non-tonemapped image
    of the viewport with full HDR data, which can then be saved to an OpenEXR file.

Computer displays
-----------------

Almost all displays require a nonlinear encoding for the code values sent
to them. The display in turn, using its unique transfer characteristic,
"decodes" the code value into linear light ratios of output, and projects
the ratios out of the uniquely colored lights at each reddish, greenish,
and blueish emission site.

For a majority of computer displays, the specifications of the display are
outlined in accordance with IEC 61966-2-1, also known as the
1996 sRGB specification. This specification outlines how an sRGB display
is to behave, including the color of the lights in the LED pixels as well as
the transfer characteristics of the input (OETF) and output (EOTF).

Not all displays use the same OETF and EOTF as a computer display.
For example, television broadcast displays use the BT.1886 EOTF.
However, Godot currently only supports sRGB displays.

The sRGB standard is based around the nonlinear relationship between the current
to light output of common desktop computing CRT displays.

.. image:: img/hdr_gamma.png

The mathematics of a scene-referred model require that we multiply the scene by
different values to adjust the intensities and exposure to different
light ranges. The transfer function of the display can't appropriately render
the wider dynamic range of the game engine's scene output using the simple
transfer function of the display. A more complex approach to encoding
is required.

Scene linear & asset pipelines
------------------------------

Working in scene-linear sRGB is not as simple as just pressing a switch. First,
imported image assets must be converted to linear light ratios on import. Even
when linearized, those assets may not be perfectly well-suited for use
as textures, depending on how they were generated.

There are two ways to do this:

sRGB transfer function to display linear ratios on image import
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is the easiest method of using sRGB assets, but it's not the most ideal.
One issue with this is loss of quality. Using 8 bits per channel to represent
linear light ratios is not sufficient to quantize the values correctly.
These textures may also be compressed later, which can exacerbate the problem.

Hardware sRGB transfer function to display linear conversion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The GPU will do the conversion after reading the texel using floating-point.
This works fine on PC and consoles, but most mobile devices don't support it,
or they don't support it on compressed texture formats (iOS for example).

Scene linear to display-referred nonlinear
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After all the rendering is done, the scene linear render requires transforming
to a suitable output such as an sRGB display. To do this, enable sRGB conversion
in the current :ref:`Environment <class_Environment>` (more on that below).

Keep in mind that the **sRGB -> Display Linear** and **Display Linear -> sRGB**
conversions must always be **both** enabled. Failing to enable one of them will
result in horrible visuals suitable only for avant-garde experimental
indie games.

Parameters of HDR
-----------------

HDR settings can be found in the :ref:`Environment <class_Environment>`
resource. Most of the time, these are found inside a
:ref:`WorldEnvironment <class_WorldEnvironment>`
node or set in a Camera node. For more information, see
:ref:`doc_environment_and_post_processing`.


===================================================
/. ./tutorials/3d/using_gridmaps.rst
===================================================

.. _doc_using_gridmaps:

Using GridMaps
~~~~~~~~~~~~~~

Introduction
------------

:ref:`Gridmaps <class_GridMap>` are a tool for creating 3D
game levels, similar to the way :ref:`TileMap <doc_using_tilemaps>`
works in 2D. You start with a predefined collection of 3D meshes (a
:ref:`class_MeshLibrary`) that can be placed on a grid,
as if you were building a level with an unlimited amount of Lego blocks.

Collisions and navigation can also be added to the meshes, just like you
would do with the tiles of a tilemap.

Example project
---------------

To learn how GridMaps work, start by downloading the sample project:
:download:`gridmap_demo.zip <files/gridmap_demo.zip>`.

Unzip this project and add it to the Project Manager using the "Import"
button.

Creating a MeshLibrary
----------------------

To begin, you need a :ref:`class_MeshLibrary`, which is a collection
of individual meshes that can be used in the gridmap. Open the "MeshLibrary_Source.tscn"
scene to see an example of how to set up the mesh library.

.. image:: img/gridmap_meshlibrary1.png

As you can see, this scene has a :ref:`class_Spatial` node as its root, and
a number of :ref:`class_MeshInstance` node children.

If you don't need any physics in your scene, then you're done. However, in most
cases you'll want to assign collision bodies to the meshes.

Collisions
----------

You can manually assign a :ref:`class_StaticBody` and
:ref:`class_CollisionShape` to each mesh. Alternatively, you can use the "Mesh" menu
to automatically create the collision body based on the mesh data.

.. image:: img/gridmap_create_body.png

Note that a "Convex" collision body will work better for simple meshes. For more
complex shapes, select "Create Trimesh Static Body". Once each mesh has
a physics body and collision shape assigned, your mesh library is ready to
be used.

.. image:: img/gridmap_mesh_scene.png


Materials
---------

Only the materials from within the meshes are used when generating the mesh
library. Materials set on the node will be ignored.

NavigationMeshes
----------------

Like all mesh instances, MeshLibrary items can be assigned a :ref:`class_NavigationMesh`
resource, which can be created manually, or baked as described below.

To create the NavigationMesh from a MeshLibrary scene export, place a
:ref:`class_NavigationMeshInstance` child node below the main MeshInstance for the GridMap
item. Add a valid NavigationMesh resource to the NavigationMeshInstance and some source
geometry nodes below and bake the NavigationMesh.

.. note::

    With small grid cells it is often necessary to reduce the NavigationMesh properties
    for agent radius and region minimum size.

.. image:: img/meshlibrary_scene.png

Nodes below the NavigationMeshInstance are ignored for the MeshLibrary scene export, so
additional nodes can be added as source geometry just for baking the navmesh.

.. warning::

    The baked cell size of the NavigationMesh must match the NavigationServer map cell
    size to properly merge the navigation meshes of different grid cells.

Exporting the MeshLibrary
-------------------------

To export the library, click on Scene -> Convert To.. -> MeshLibrary.., and save it
as a resource.

.. image:: img/gridmap_export.png

You can find an already exported MeshLibrary in the project named "MeshLibrary.tres".

Using GridMap
-------------

Create a new scene and add a GridMap node. Add the mesh library by dragging
the resource file from the FileSystem dock and dropping it in the "Theme" property
in the Inspector.

.. image:: img/gridmap_main.png

The "Cell/Size" property should be set to the size of your meshes. You can leave
it at the default value for the demo. Set the "Center Y" property to "Off".

Now you can start designing the level by choosing a tile from the palette and
placing it with Left-Click in the editor window. To remove a tile, hold :kbd:`Shift`
and use Right-click.

Click on the "GridMap" menu to see options and shortcuts. For example, pressing
:kbd:`S` rotates a tile around the y-axis.

.. image:: img/gridmap_menu.png

Holding :kbd:`Shift` and dragging with the left mouse button will draw a selection
box. You can duplicate or clear the selected area using the respective menu
options.

.. image:: img/gridmap_select.png

In the menu, you can also change the axis you're drawing on, as well as shift
the drawing plane higher or lower on its axis.

.. image:: img/gridmap_shift_axis.png

Using GridMap in code
---------------------

See :ref:`class_GridMap` for details on the node's methods and member variables.


===================================================
/. ./tutorials/3d/using_multi_mesh_instance.rst
===================================================

.. _doc_using_multi_mesh_instance:

Using MultiMeshInstance
-----------------------

Introduction
~~~~~~~~~~~~

In a normal scenario, you would use a :ref:`MeshInstance <class_MeshInstance>`
node to display a 3D mesh like a human model for the main character, but in some
cases, you would like to create multiple instances of the same mesh in a scene.
You *could* duplicate the same node multiple times and adjust the transforms
manually. This may be a tedious process and the result may look mechanical.
Also, this method is not conducive to rapid iterations.
:ref:`MultiMeshInstance <class_MultiMeshInstance>` is one of the possible
solutions to this problem.

MultiMeshInstance, as the name suggests, creates multiple copies of a
MeshInstance over a surface of a specific mesh. An example would be having a
tree mesh populate a landscape mesh with trees of random scales and orientations.

Setting up the nodes
~~~~~~~~~~~~~~~~~~~~

The basic setup requires three nodes: the MultiMeshInstance node
and two MeshInstance nodes.

One node is used as the target, the mesh that you want to place multiple meshes
on. In the tree example, this would be the landscape.

The other node is used as the source, the mesh that you want to have duplicated.
In the tree case, this would be the tree itself.

In our example, we would use a :ref:`Spatial <class_Spatial>` node as the root node of
the scene. Your scene tree would look like this:

.. image:: img/multimesh_scene_tree.png

.. note:: For simplicity's sake, this tutorial uses built-in primitives.

Now you have everything ready. Select the MultiMeshInstance node and look at the
toolbar, you should see an extra button called ``MultiMesh`` next to ``View``.
Click it and select *Populate surface* in the dropdown menu. A new window titled
*Populate MultiMesh* will pop up.

.. image:: img/multimesh_toolbar.png

.. image:: img/multimesh_settings.png

MultiMesh settings
~~~~~~~~~~~~~~~~~~

Below are descriptions of the options.

Target Surface
++++++++++++++

The mesh used as the target surface on which to place copies of your
source mesh.

Source Mesh
+++++++++++

The mesh you want duplicated on the target surface.

Mesh Up Axis
++++++++++++

The axis used as the up axis of the source mesh.

Random Rotation
+++++++++++++++

Randomizing the rotation around the up axis of the source mesh.

Random Tilt
+++++++++++

Randomizing the overall rotation of the source mesh.

Random Scale
++++++++++++

Randomizing the scale of the source mesh.

Scale
+++++

The scale of the source mesh that will be placed over the target surface.

Amount
++++++

The amount of mesh instances placed over the target surface.

Select the target surface. In the tree case, this should be the landscape node.
The source mesh should be the tree node. Adjust the other parameters
according to your preference. Press ``Populate`` and multiple copies of the
source mesh will be placed over the target mesh. If you are satisfied with the
result, you can delete the mesh instance used as the source mesh.

The end result should look like this:

.. image:: img/multimesh_result.png

To change the result, repeat the previous steps with different parameters.


===================================================
/. ./tutorials/3d/csg_tools.rst
===================================================

.. _doc_csg_tools:

Prototyping levels with CSG
===========================

CSG stands for **Constructive Solid Geometry**, and is a tool to combine basic
shapes or custom meshes to create more complex shapes. In 3D modelling software,
CSG is mostly known as "Boolean Operators".

Level prototyping is one of the main uses of CSG in Godot. This technique allows
users to create simple versions of most common shapes by combining primitives.
Interior environments can be created by using inverted primitives.

.. note:: The CSG nodes in Godot are mainly intended for prototyping. There is
          no built-in support for UV mapping or editing 3D polygons (though
          extruded 2D polygons can be used with the CSGPolygon node).

          If you're looking for an easy to use level design tool for a project,
          you may want to use `Qodot <https://github.com/Shfty/qodot-plugin>`__
          instead. It lets you design levels using
          `TrenchBroom <https://kristianduske.com/trenchbroom/>`__ and import
          them in Godot.

.. image:: img/csg.gif

Introduction to CSG nodes
-------------------------

Like other features of Godot, CSG is supported in the form of nodes. These are
the CSG nodes:

- :ref:`CSGBox <class_CSGBox>`
- :ref:`CSGCylinder <class_CSGCylinder>` (also supports cone)
- :ref:`CSGSphere <class_CSGSphere>`
- :ref:`CSGTorus <class_CSGTorus>`
- :ref:`CSGPolygon <class_CSGPolygon>`
- :ref:`CSGMesh <class_CSGMesh>`
- :ref:`CSGCombiner <class_CSGcombiner>`

.. image:: img/csg_nodes.png

.. image:: img/csg_mesh.png

CSG tools features
~~~~~~~~~~~~~~~~~~

Every CSG node supports 3 kinds of boolean operations:

- **Union:** Geometry of both primitives is merged, intersecting geometry
  is removed.
- **Intersection:** Only intersecting geometry remains, the rest is removed.
- **Subtraction:** The second shape is subtracted from the first, leaving a dent
  with its shape.

.. image:: img/csg_operation_menu.png

.. image:: img/csg_operation.png

CSGPolygon
~~~~~~~~~~

The :ref:`CSGPolygon <class_CSGPolygon>` node extrude along a Polygon drawn in
2D (in X, Y coordinates) in the following ways:

- **Depth:** Extruded back a given amount.
- **Spin:** Extruded while spinning around its origin.
- **Path:** Extruded along a Path node. This operation is commonly called
  lofting.

.. image:: img/csg_poly_mode.png

.. image:: img/csg_poly.png

.. note:: The **Path** mode must be provided with a :ref:`Path <class_Path>`
          node to work. In the Path node, draw the path and the polygon in
          CSGPolygon will extrude along the given path.


Custom meshes
~~~~~~~~~~~~~

Any mesh can be used for :ref:`CSGMesh <class_CSGMesh>`; the mesh can be
modelled in other software and imported into Godot. Multiple materials are
supported. There are some restrictions for geometry:

- it must be closed,
- it must not self-intersect,
- it must not contain internal faces,
- every edge must connect to only two other faces.

.. image:: img/csg_custom_mesh.png

CSGCombiner
~~~~~~~~~~~

The :ref:`CSGCombiner <class_CSGCombiner>` node is an empty shape used for
organization. It will only combine children nodes.

Processing order
~~~~~~~~~~~~~~~~

Every CSG node will first process its children nodes and their operations:
union, intersection or subtraction, in tree order, and apply them to itself one
after the other.

.. note:: In the interest of performance, make sure CSG geometry remains
          relatively simple, as complex meshes can take a while to process.
          If adding objects together (such as table and room objects), create
          them as separate CSG trees. Forcing too many objects in a single tree
          will eventually start affecting performance.
          Only use binary operations where you actually need them.

Prototyping a level
-------------------

We will prototype a room to practice the use of CSG tools.

.. tip:: Working in **Orthogonal** projection gives a better view when combining
         the CSG shapes.

Our level will contain these objects:

- a room,
- a bed,
- a lamp,
- a desk,
- a bookshelf.

Create a scene with a Spatial node as root node.

.. tip:: The default lighting of the environment doesn't provide clear shading
         at some angles. Change the display mode using **Display Overdraw** in
         the 3D viewport menu, or add a DirectionalLight node to help you see
         clearly.

.. image:: img/csg_overdraw.png

Create a CSGBox and name it ``room``, enable **Invert Faces** and change the
dimensions of your room.

.. image:: img/csg_room.png

.. image:: img/csg_room_invert.png

Next, create a CSGCombiner and name it ``desk``.

A desk has one surface and 4 legs:

- Create 1 CSGBox children node in **Union** mode for the surface
  and adjust the dimensions.
- Create 4 CSGBox children nodes in **Union** mode for the legs
  and adjust the dimensions.

Adjust their placement to resemble a desk.

.. image:: img/csg_desk.png

.. note:: CSG nodes inside a CSGCombiner will only process their operation
          within the combiner. Therefore, CSGCombiners are used to organize
          CSG nodes.

Create a CSGCombiner and name it ``bed``.

Our bed consists of 3 parts: the bed, the mattress and a pillow. Create a CSGBox
and adjust its dimension for the bed. Create another CSGBox and adjust its
dimension for the mattress.

.. image:: img/csg_bed_mat.png

We will create another CSGCombiner named ``pillow`` as the child of  ``bed``.
The scene tree should look like this:

.. image:: img/csg_bed_tree.png

We will combine 3 CSGSphere nodes in **Union** mode to form a pillow. Scale the
Y axis of the spheres and enable **Smooth Faces**.

.. image:: img/csg_pillow_smooth.png

Select the ``pillow`` node and switch the mode to **Subtraction**; the combined
spheres will cut a hole into the mattress.

.. image:: img/csg_pillow_hole.png

Try to re-parent the ``pillow`` node to the root ``Spatial`` node; the hole will
disappear.

.. note:: This is to illustrate the effect of CSG processing order.
          Since the root node is not a CSG node, the CSGCombiner nodes are
          the end of the operations; this shows the use of CSGCombiner to
          organize the CSG scene.

Undo the re-parent after observing the effect. The bed you've built should look
like this:

.. image:: img/csg_bed.png

Create a CSGCombiner and name it ``lamp``.

A lamp consists of 3 parts: the stand, the pole and the lampshade.
Create a CSGCylinder, enable the **Cone** option and make it the stand. Create
another CSGCylinder and adjust the dimensions to use it as a pole.

.. image:: img/csg_lamp_pole_stand.png

We will use a CSGPolygon for the lampshade. Use the **Spin** mode for the
CSGPolygon and draw a `trapezoid <https://en.wikipedia.org/wiki/Trapezoid>`_
while in **Front View** (numeric keypad 1); this shape will extrude around the
origin and form the lampshade.

.. image:: img/csg_lamp_spin.png

.. image:: img/csg_lamp_polygon.png

.. image:: img/csg_lamp_extrude.png

Adjust the placement of the 3 parts to make it look like a lamp.

.. image:: img/csg_lamp.png

Create a CSGCombiner and name it ``bookshelf``.

We will use 3 CSGBox nodes for the bookshelf. Create a CSGBox and adjust its
dimensions; this will be the size of the bookshelf.

.. image:: img/csg_shelf_big.png

Duplicate the CSGBox and shorten the dimensions of each axis and change the mode
to **Subtraction**.

.. image:: img/csg_shelf_subtract.png

.. image:: img/csg_shelf_subtract_menu.png

You've almost built a shelf. Create one more CSGBox for dividing the shelf into
two levels.

.. image:: img/csg_shelf.png

Position your furniture in your room as you like and your scene should look
this:

.. image:: img/csg_room_result.png

You've successfully prototyped a room level with the CSG tools in Godot.
CSG tools can be used for designing all kinds of levels, such as a maze
or a city; explore its limitations when designing your game.

Using prototype textures
------------------------

Godot's :ref:`doc_spatial_material` supports *triplanar mapping*, which can be
used to automatically apply a texture to arbitrary objects without distortion.
This is handy when using CSG as Godot doesn't support editing UV maps on CSG
nodes yet. Triplanar mapping is relatively slow, which usually restricts its
usage to organic surfaces like terrain. Still, when prototyping, it can be used
to quickly apply textures to CSG-based levels.

.. note:: If you need some textures for prototyping, Kenney made a
          `set of CC0-licensed prototype textures <https://kenney.nl/assets/prototype-textures>`__.

There are two ways to apply a material to a CSG node:

- Applying it to a CSGCombiner node as a material override
  (**Geometry > Material Override** in the Inspector). This will affect its
  children automatically, but will make it impossible to change the material in
  individual children.
- Applying a material to individual nodes (**Material** in the Inspector). This
  way, each CSG node can have its own appearance. Subtractive CSG nodes will
  apply their material to the nodes they're "digging" into.

To apply triplanar mapping to a CSG node, select it, go to the Inspector, click
the **[empty]** text next to **Material Override** (or **Material** for
individual CSG nodes). Choose **New SpatialMaterial**. Click the newly created
material's icon to edit it. Unfold the **Albedo** section and load a texture
into the **Texture** property. Now, unfold the **Uv1** section and check
**Triplanar**. You can change the texture offset and scale on each axis by
playing with the **Scale** and **Offset** properties just above. Higher values
in the **Scale** property will cause the texture to repeat more often.

.. tip:: You can copy a SpatialMaterial to reuse it across CSG nodes. To do so,
         click the dropdown arrow next to a material property in the Inspector
         and choose **Copy**. To paste it, select the node you'd like to apply
         the material onto, click the dropdown arrow next to its material
         property then choose **Paste**.


===================================================
/. ./tutorials/3d/procedural_geometry/index.rst
===================================================

.. _doc_procedural_geometry:

Procedural geometry
===================

There are many ways to procedurally generate geometry in Godot. In this tutorial series
we will explore a few of them. Each technique has its own benefits and drawbacks, so
it is best to understand each one and how it can be useful in a given situation.

.. toctree::
   :maxdepth: 1
   :name: toc-procedural_geometry

   arraymesh
   meshdatatool
   surfacetool
   immediategeometry

What is geometry?
-----------------

Geometry is a fancy way of saying shape. In computer graphics, geometry is typically represented
by an array of positions called "vertices". In Godot, geometry is represented by Meshes.

What is a Mesh?
---------------

Many things in Godot have mesh in their name: the :ref:`Mesh <class_Mesh>`, the :ref:`ArrayMesh <class_ArrayMesh>`,
the :ref:`MeshInstance <class_MeshInstance>`, the :ref:`MultiMesh <class_MultiMesh>`, and
the :ref:`MultiMeshInstance <class_MultiMeshInstance>`. While they are all related, they have slightly different uses.

Meshes and ArrayMeshes are resources that are drawn using a MeshInstance node. Resources like
Meshes and ArrayMeshes cannot be added to the scene directly. A MeshInstance represents one
instance of a mesh in your scene. You can reuse a single mesh in multiple MeshInstances
to draw it in different parts of your scene with different materials or transformations (scale,
rotation, position etc.).

If you are going to draw the same object many times, it can be helpful to use a MultiMesh with
a MultiMeshInstance. MultiMeshInstances draw meshes thousands of times very
cheaply by taking advantage of hardware instancing. The drawback with
using a MultiMeshInstance is that each of your mesh's surfaces are limited to one material for
all instances. It uses an instance array to store different colors and transformations for each
instance, but all the instances of each surface use the same material.

What a Mesh is
--------------

A Mesh is composed of one or more surfaces. A surface is an array composed of multiple sub-arrays
containing vertices, normals, UVs, etc. Normally the process of constructing surfaces and meshes is
hidden from the user in the :ref:`VisualServer <class_VisualServer>`, but with ArrayMeshes, the user can construct a Mesh
manually by passing in an array containing the surface information.

Surfaces
^^^^^^^^

Each surface has its own material. Alternatively, you can override the material for all surfaces
in the Mesh when you use a MeshInstance using the :ref:`material_override <class_GeometryInstance_property_material_override>` property.

Surface array
^^^^^^^^^^^^^

The surface array is an array of length ``ArrayMesh.ARRAY_MAX``. Each position in the array is
filled with a sub-array containing per-vertex information. For example, the array located at
``ArrayMesh.ARRAY_NORMAL`` is a :ref:`PoolVector3Array <class_PoolVector3Array>` of vertex normals.
See :ref:`Mesh.ArrayType <enum_Mesh_ArrayType>` for more information.

The surface array can be indexed or non-indexed. Creating a non-indexed array is as easy as not assigning
an array at the index ``ArrayMesh.ARRAY_INDEX``. A non-indexed array stores unique vertex information for
every triangle, meaning that when two triangles share a vertex, the vertex is duplicated in the array. An
indexed surface array only stores vertex information for each unique vertex and then also stores an array
of indices which maps out how to construct the triangles from the vertex array. In general, using an indexed
array is faster, but it means you have to share vertex data between triangles, which is not always desired
(e.g. when you want per-face normals).

Tools
-----

Godot provides different ways of accessing and working with geometry. More information on each will
be provided in the following tutorials.

ArrayMesh
^^^^^^^^^

The ArrayMesh resource extends Mesh to add a few different quality of life functions and, most
importantly, the ability to construct a Mesh surface through scripting.

For more information about the ArrayMesh, please see the :ref:`ArrayMesh tutorial <doc_arraymesh>`.

MeshDataTool
^^^^^^^^^^^^

The MeshDataTool is a resource that converts Mesh data into arrays of vertices, faces, and edges that can
be modified at runtime.

For more information about the MeshDataTool, please see the :ref:`MeshDataTool tutorial <doc_meshdatatool>`.

SurfaceTool
^^^^^^^^^^^

The SurfaceTool allows the creation of Meshes using an OpenGL 1.x immediate mode style interface.

For more information about the SurfaceTool, please see the :ref:`SurfaceTool tutorial <doc_surfacetool>`.

ImmediateGeometry
^^^^^^^^^^^^^^^^^

ImmediateGeometry is a node that uses an immediate mode style interface (like SurfaceTool) to draw objects. The
difference between ImmediateGeometry and the SurfaceTool is that ImmediateGeometry is a node itself that can be
added to the scene tree and is drawn directly from the code, while the SurfaceTool generates a Mesh that needs to be added
to a MeshInstance to be seen.

ImmediateGeometry is useful for prototyping because of its straightforward API, but it is slow because the geometry
is rebuilt every frame. It is most useful for adding simple geometry for visual debugging (e.g. by drawing lines to
visualize physics raycasts etc.).

For more information about ImmediateGeometry, please see the :ref:`ImmediateGeometry tutorial <doc_immediategeometry>`.

Which one should I use?
-----------------------

Which approach you use depends on what you are trying to do and what kind of procedure you are comfortable with.

Both SurfaceTool and ArrayMesh are excellent for generating static geometry (meshes) that don't change over time.

Using an ArrayMesh is slightly faster than using a SurfaceTool, but the API is a little more challenging.
Additionally, SurfaceTool has a few quality of life methods such as ``generate_normals()`` and ``index()``.

ImmediateGeometry regenerates the mesh every frame, so it is much slower than ArrayMesh or SurfaceTool. However, if you
need the geometry to change every frame anyway, it provides a much easier interface that may even be a little faster than generating
an ArrayMesh every frame.

The MeshDataTool is not fast, but it gives you access to all kinds of properties of the mesh that you don't get with the others
(edges, faces, etc.). It is incredibly useful when you need that sort of data to transform the mesh, but it is not a good idea
to use it if that extra information is not needed. The MeshDataTool is best used if you are going to be using an algorithm that requires
access to the face or edge array.


===================================================
/. ./tutorials/3d/procedural_geometry/arraymesh.rst
===================================================

.. _doc_arraymesh:

Using the ArrayMesh
===================

This tutorial will present the basics of using an :ref:`ArrayMesh <class_arraymesh>`.

To do so, we will use the function :ref:`add_surface_from_arrays() <class_ArrayMesh_method_add_surface_from_arrays>`,
which takes up to four parameters. The first two are required, while the second two are optional.

The first parameter is the ``PrimitiveType``, an OpenGL concept that instructs the GPU
how to arrange the primitive based on the vertices given, i.e. whether they represent triangles,
lines, points, etc. See :ref:`Mesh.PrimitiveType <enum_Mesh_PrimitiveType>` for the options available.

The second parameter, ``arrays``, is the actual Array that stores the mesh information. The array is a
normal Godot array that is constructed with empty brackets ``[]``. It stores a ``Pool**Array``
(e.g. PoolVector3Array, PoolIntArray, etc.) for each type of information that will be used to build the surface.

The possible elements of ``arrays`` are listed below, together with the position they must have within ``arrays``.
See also :ref:`Mesh.ArrayType <enum_Mesh_ArrayType>`.


.. list-table::
    :class: wrap-normal
    :width: 100%
    :widths: auto
    :header-rows: 1

    * - Index
      - Mesh.ArrayType Enum
      - Array type

    * - 0
      - ``ARRAY_VERTEX``
      - :ref:`PoolVector3Array <class_PoolVector3Array>` or :ref:`PoolVector2Array <class_PoolVector2Array>`

    * - 1
      - ``ARRAY_NORMAL``
      - :ref:`PoolVector3Array <class_PoolVector3Array>`

    * - 2
      - ``ARRAY_TANGENT``
      - :ref:`PoolRealArray <class_PoolRealArray>` of groups of 4 floats. First 3 floats determine the tangent, and
        the last the binormal direction as -1 or 1.

    * - 3
      - ``ARRAY_COLOR``
      - :ref:`PoolColorArray <class_PoolColorArray>`

    * - 4
      - ``ARRAY_TEX_UV``
      - :ref:`PoolVector2Array <class_PoolVector2Array>` or :ref:`PoolVector3Array <class_PoolVector3Array>`

    * - 5
      - ``ARRAY_TEX_UV2``
      - :ref:`PoolVector2Array <class_PoolVector2Array>` or :ref:`PoolVector3Array <class_PoolVector3Array>`

    * - 6
      - ``ARRAY_BONES``
      - :ref:`PoolRealArray <class_PoolRealArray>` of groups of 4 floats or :ref:`PoolIntArray <class_PoolIntArray>` of groups of 4 ints. Each group lists indexes of 4 bones that affects a given vertex.

    * - 7
      - ``ARRAY_WEIGHTS``
      - :ref:`PoolRealArray <class_PoolRealArray>` of groups of 4 floats. Each float lists the amount of weight an determined bone on ``ARRAY_BONES`` has on a given vertex.

    * - 8
      - ``ARRAY_INDEX``
      - :ref:`PoolIntArray <class_PoolIntArray>`

The array of vertices (at index 0) is always required. The index array is optional and will only be used if included. We won't use it in this tutorial.

All the other arrays carry information about the vertices. They are also optional and will only be used if included. Some of these arrays (e.g. ``ARRAY_COLOR``)
use one entry per vertex to provide extra information about vertices. They must have the same size as the vertex array. Other arrays (e.g. ``ARRAY_TANGENT``) use
four entries to describe a single vertex. These must be exactly four times larger than the vertex array.

For normal usage, the last two parameters in :ref:`add_surface_from_arrays() <class_arraymesh_method_add_surface_from_arrays>` are typically left empty.

ArrayMesh
---------

In the editor, create a :ref:`MeshInstance <class_meshinstance>` and add an :ref:`ArrayMesh <class_arraymesh>` to it in the Inspector.
Normally, adding an ArrayMesh in the editor is not useful, but in this case it allows us to access the ArrayMesh
from code without creating one.

Next, add a script to the MeshInstance.

Under ``_ready()``, create a new Array.

.. tabs::
  .. code-tab:: gdscript GDScript

    var surface_array = []

This will be the array that we keep our surface information in - it will hold
all the arrays of data that the surface needs. Godot will expect it to be of
size ``Mesh.ARRAY_MAX``, so resize it accordingly.

.. tabs::
 .. code-tab:: gdscript GDScript

    var surface_array = []
    surface_array.resize(Mesh.ARRAY_MAX)

Next create the arrays for each data type you will use.

.. tabs::
 .. code-tab:: gdscript GDScript

    var verts = PoolVector3Array()
    var uvs = PoolVector2Array()
    var normals = PoolVector3Array()
    var indices = PoolIntArray()

Once you have filled your data arrays with your geometry you can create a mesh
by adding each array to ``surface_array`` and then committing to the mesh.

.. tabs::
 .. code-tab:: gdscript GDScript

    surface_array[Mesh.ARRAY_VERTEX] = verts
    surface_array[Mesh.ARRAY_TEX_UV] = uvs
    surface_array[Mesh.ARRAY_NORMAL] = normals
    surface_array[Mesh.ARRAY_INDEX] = indices

    mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array) # No blendshapes or compression used.

.. note:: In this example, we used ``Mesh.PRIMITIVE_TRIANGLES``, but you can use any primitive type
          available from mesh.

Put together, the full code looks like:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends MeshInstance

    func _ready():
        var surface_array= []
        surface_array.resize(Mesh.ARRAY_MAX)

        # PoolVector**Arrays for mesh construction.
        var verts = PoolVector3Array()
        var uvs = PoolVector2Array()
        var normals = PoolVector3Array()
        var indices = PoolIntArray()

        #######################################
        ## Insert code here to generate mesh ##
        #######################################

        # Assign arrays to mesh array.
        surface_array[Mesh.ARRAY_VERTEX] = verts
        surface_array[Mesh.ARRAY_TEX_UV] = uvs
        surface_array[Mesh.ARRAY_NORMAL] = normals
        surface_array[Mesh.ARRAY_INDEX] = indices

        # Create mesh surface from mesh array.
        mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array) # No blendshapes or compression used.


The code that goes in the middle can be whatever you want. Below we will present some example code
for generating a sphere.

Generating geometry
-------------------

Here is sample code for generating a sphere. Although the code is presented in
GDScript, there is nothing Godot specific about the approach to generating it.
This implementation has nothing in particular to do with ArrayMeshes and is just a
generic approach to generating a sphere. If you are having trouble understanding it
or want to learn more about procedural geometry in general, you can use any tutorial
that you find online.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends MeshInstance

    var rings = 50
    var radial_segments = 50
    var height = 1
    var radius = 1

    func _ready():

        # Insert setting up the PoolVector**Arrays here.

        # Vertex indices.
        var thisrow = 0
        var prevrow = 0
        var point = 0

        # Loop over rings.
        for i in range(rings + 1):
            var v = float(i) / rings
            var w = sin(PI * v)
            var y = cos(PI * v)

            # Loop over segments in ring.
            for j in range(radial_segments):
                var u = float(j) / radial_segments
                var x = sin(u * PI * 2.0)
                var z = cos(u * PI * 2.0)
                var vert = Vector3(x * radius * w, y, z * radius * w)
                verts.append(vert)
                normals.append(vert.normalized())
                uvs.append(Vector2(u, v))
                point += 1

                # Create triangles in ring using indices.
                if i > 0 and j > 0:
                    indices.append(prevrow + j - 1)
                    indices.append(prevrow + j)
                    indices.append(thisrow + j - 1)

                    indices.append(prevrow + j)
                    indices.append(thisrow + j)
                    indices.append(thisrow + j - 1)

            if i > 0:
                indices.append(prevrow + radial_segments - 1)
                indices.append(prevrow)
                indices.append(thisrow + radial_segments - 1)

                indices.append(prevrow)
                indices.append(prevrow + radial_segments)
                indices.append(thisrow + radial_segments - 1)

            prevrow = thisrow
            thisrow = point

      # Insert committing to the ArrayMesh here.

Saving
------

Finally, we can use the :ref:`ResourceSaver <class_resourcesaver>` class to save the ArrayMesh.
This is useful when you want to generate a mesh and then use it later without having to re-generate it.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Saves mesh to a .tres file with compression enabled.
    ResourceSaver.save("res://sphere.tres", mesh, ResourceSaver.FLAG_COMPRESS)


===================================================
/. ./tutorials/3d/procedural_geometry/meshdatatool.rst
===================================================

.. _doc_meshdatatool:

Using the MeshDataTool
======================

The :ref:`MeshDataTool <class_meshdatatool>` is not used to generate geometry. But it is helpful for dynamically altering geometry, for example
if you want to write a script to tessellate, simplify, or deform meshes.

The MeshDataTool is not as fast as altering arrays directly using ArrayMesh. However, it provides more information
and tools to work with meshes than the ArrayMesh does. When the MeshDataTool
is used, it calculates mesh data that is not available in ArrayMeshes such as faces and edges, which are necessary
for certain mesh algorithms. If you do not need this extra information then it may be better to use an ArrayMesh.

.. note:: MeshDataTool can only be used on Meshes that use the PrimitiveType ``Mesh.PRIMITIVE_TRIANGLES``.

We initialize the MeshDataTool from an ArrayMesh by calling ``create_from_surface()``. If there is already data initialized in the MeshDataTool,
calling ``create_from_surface()`` will clear it for you. Alternatively, you can call ``clear()`` yourself before re-using the MeshDataTool.

In the examples below, assume an ArrayMesh called ``mesh`` has already been created. See :ref:`ArrayMesh tutorial <doc_arraymesh>` for an example of mesh generation.

.. tabs::
 .. code-tab:: gdscript GDScript

    var mdt = MeshDataTool.new()
    mdt.create_from_surface(mesh, 0)

``create_from_surface()`` uses the vertex arrays from the ArrayMesh to calculate two additional arrays,
one for edges and one for faces, for a total of three arrays.

An edge is a connection between any two vertices. Each edge in the edge array contains a reference to
the two vertices it is composed of, and up to two faces that it is contained within.

A face is a triangle made up of three vertices and three corresponding edges. Each face in the face array contains
a reference to the three vertices and three edges it is composed of.

The vertex array contains edge, face, normal, color, tangent, uv, uv2, bone, and weight information connected
with each vertex.

To access information from these arrays you use a function of the form ``get_****()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    mdt.get_vertex_count() # Returns number of vertices in vertex array.
    mdt.get_vertex_faces(0) # Returns array of faces that contain vertex[0].
    mdt.get_face_normal(1) # Calculates and returns face normal of the second face.
    mdt.get_edge_vertex(10, 1) # Returns the second vertex comprising the edge at index 10.

What you choose to do with these functions is up to you. A common use case is to iterate over all vertices
and transform them in some way:

.. tabs::
 .. code-tab:: gdscript GDScript

    for i in range(get_vertex_count):
        var vert = mdt.get_vertex(i)
        vert *= 2.0 # Scales the vertex by doubling size.
        mdt.set_vertex(i, vert)

These modifications are not done in place on the ArrayMesh. If you are dynamically updating an existing ArrayMesh,
first delete the existing surface before adding a new one using :ref:`commit_to_surface() <class_meshdatatool_method_commit_to_surface>`:

.. tabs::
 .. code-tab:: gdscript GDScript

    mesh.surface_remove(0) # Deletes the first surface of the mesh.
    mdt.commit_to_surface(mesh)

Below is a complete example that turns a spherical mesh called ``mesh`` into a randomly deformed blob complete with updated normals and vertex colors.
See :ref:`ArrayMesh tutorial <doc_arraymesh>` for how to generate the base mesh.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends MeshInstance

    var sn = OpenSimplexNoise.new()
    var mdt = MeshDataTool.new()

    func _ready():
        sn.period = 0.7

        mdt.create_from_surface(mesh, 0)

        for i in range(mdt.get_vertex_count()):
            var vertex = mdt.get_vertex(i).normalized()
            # Push out vertex by noise.
            vertex = vertex * (sn.get_noise_3dv(vertex) * 0.5 + 0.75)
            mdt.set_vertex(i, vertex)

        # Calculate vertex normals, face-by-face.
        for i in range(mdt.get_face_count()):
            # Get the index in the vertex array.
            var a = mdt.get_face_vertex(i, 0)
            var b = mdt.get_face_vertex(i, 1)
            var c = mdt.get_face_vertex(i, 2)
            # Get vertex position using vertex index.
            var ap = mdt.get_vertex(a)
            var bp = mdt.get_vertex(b)
            var cp = mdt.get_vertex(c)
            # Calculate face normal.
            var n = (bp - cp).cross(ap - bp).normalized()
            # Add face normal to current vertex normal.
            # This will not result in perfect normals, but it will be close.
            mdt.set_vertex_normal(a, n + mdt.get_vertex_normal(a))
            mdt.set_vertex_normal(b, n + mdt.get_vertex_normal(b))
            mdt.set_vertex_normal(c, n + mdt.get_vertex_normal(c))

        # Run through vertices one last time to normalize normals and
        # set color to normal.
        for i in range(mdt.get_vertex_count()):
            var v = mdt.get_vertex_normal(i).normalized()
            mdt.set_vertex_normal(i, v)
            mdt.set_vertex_color(i, Color(v.x, v.y, v.z))

        mesh.surface_remove(0)
        mdt.commit_to_surface(mesh)


===================================================
/. ./tutorials/3d/procedural_geometry/surfacetool.rst
===================================================

.. _doc_surfacetool:

Using the SurfaceTool
=====================

The :ref:`SurfaceTool <class_surfacetool>` provides a useful interface for constructing geometry.
The interface is similar to the :ref:`ImmediateGeometry <class_immediategeometry>` node. You
set each per-vertex attribute (e.g. normal, uv, color) and then when you add a vertex it
captures the attributes.

The SurfaceTool also provides some useful helper functions like ``index()`` and ``generate_normals()``.

Attributes are added before each vertex is added:

.. tabs::
 .. code-tab:: gdscript GDScript

    st.add_normal() # Overwritten by normal below.
    st.add_normal() # Added to next vertex.
    st.add_color() # Added to next vertex.
    st.add_vertex() # Captures normal and color above.
    st.add_normal() # Normal never added to a vertex.

When finished generating your geometry with the :ref:`SurfaceTool <class_surfacetool>`
call ``commit()`` to finish generating the mesh. If an :ref:`ArrayMesh <class_ArrayMesh>` is passed
to ``commit()`` then it appends a new surface to the end of the ArrayMesh. While if nothing is passed
in, ``commit()`` returns an ArrayMesh.

.. tabs::
 .. code-tab:: gdscript GDScript

    st.commit(mesh)
    # Or:
    var mesh = st.commit()

Code creates a triangle with indices

.. tabs::
 .. code-tab:: gdscript GDScript

    var st = SurfaceTool.new()

    st.begin(Mesh.PRIMITIVE_TRIANGLES)

    # Prepare attributes for add_vertex.
    st.add_normal(Vector3(0, 0, 1))
    st.add_uv(Vector2(0, 0))
    # Call last for each vertex, adds the above attributes.
    st.add_vertex(Vector3(-1, -1, 0))

    st.add_normal(Vector3(0, 0, 1))
    st.add_uv(Vector2(0, 1))
    st.add_vertex(Vector3(-1, 1, 0))

    st.add_normal(Vector3(0, 0, 1))
    st.add_uv(Vector2(1, 1))
    st.add_vertex(Vector3(1, 1, 0))

    # Commit to a mesh.
    var mesh = st.commit()

You can optionally add an index array, either by calling ``add_index()`` and adding
vertices to the index array or by calling ``index()`` which shrinks the vertex array
to remove duplicate vertices.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Creates a quad from four corner vertices.
    # Add_index does not need to be called before add_vertex.
    st.add_index(0)
    st.add_index(1)
    st.add_index(2)

    st.add_index(1)
    st.add_index(3)
    st.add_index(2)

    # Alternatively:
    st.index()

Similarly, if you have an index array, but you want each vertex to be unique (e.g. because
you want to use unique normals or colors per face instead of per-vertex), you can call ``deindex()``.

.. tabs::
 .. code-tab:: gdscript GDScript

    st.deindex()

If you don't add custom normals yourself, you can add them using ``generate_normals()``, which should
be called after generating geometry and before committing the mesh using ``commit()`` or
``commit_to_arrays()``. Calling ``generate_normals(true)`` will flip the resulting normals. As a side
note, ``generate_normals()`` only works if the primitive type is set to ``Mesh.PRIMITIVE_TRIANGLES``.

You may notice that normal mapping or other material properties look broken on
the generated mesh. This is because normal mapping **requires** the mesh to
feature *tangents*, which are separate from *normals*. You can either add custom
tangents manually, or generate them automatically with with
``generate_tangents()``. This method requires that each vertex have UVs and
normals set already.

.. tabs::
 .. code-tab:: gdscript GDScript

    st.generate_normals()
    st.generate_tangents()

By default, when generating normals, they will be calculated on a per-face basis. If you want
smooth vertex normals, when adding vertices, call ``add_smooth_group()``. ``add_smooth_group()``
needs to be called while building the geometry, e.g. before the call to ``add_vertex()``
(if non-indexed) or ``add_index()`` (if indexed).


===================================================
/. ./tutorials/3d/procedural_geometry/immediategeometry.rst
===================================================

.. _doc_immediategeometry:

Using ImmediateGeometry
=======================

Unlike the SurfaceTool or ArrayMesh, :ref:`ImmediateGeometry <class_ImmediateGeometry>` is an actual
node. Being a node makes it quick to add to a scene and get visual output. It uses an OpenGL 1.x-style
API like SurfaceTool, but it's actually designed to create meshes on the fly.

Generating complex geometry (several thousand vertices) with this node is inefficient, even if it's
done only once. Instead, it is designed to generate simple geometry that changes every frame.

Before starting, you should clear the geometry by calling ``clear()``. This ensures that
you are not building upon the geometry from the previous frame. If you want to keep geometry between frames, do
not call ``clear()``.

To begin generating geometry you must call ``begin()``. ``begin()`` takes a ``PrimitiveType`` as an argument.
``PrimitiveType`` is an OpenGL concept that instructs the GPU how to arrange the primitive based on the
vertices given whether it is triangles, lines, points, etc. A complete list can be found under
the :ref:`Mesh <class_mesh>` class reference page.

Once you have called ``begin()`` you are ready to start adding vertices. You add vertices one at a time.
First you add vertex specific attributes such as normals or UVs using ``set_****()`` (e.g. ``set_normal()``).
Then you call ``add_vertex()`` to add a vertex with those attributes. For example:

.. tabs::
  .. code-tab:: gdscript GDScript

    # Add a vertex with normal and uv.
    set_normal(Vector3(0, 1, 0))
    set_uv(Vector2(1, 1))
    add_vertex(Vector3(0, 0, 1))

Only attributes added before the call to ``add_vertex()`` will be included in that vertex.

Finally, once you have added all your vertices call ``end()`` to signal that you have finished generating the mesh.

The example code below draws a single triangle.

.. tabs::
  .. code-tab:: gdscript GDScript

    extends ImmediateGeometry

    func _process(_delta):
        # Clean up before drawing.
        clear()

        # Begin draw.
        begin(Mesh.PRIMITIVE_TRIANGLES)

        # Prepare attributes for add_vertex.
        set_normal(Vector3(0, 0, 1))
        set_uv(Vector2(0, 0))
        # Call last for each vertex, adds the above attributes.
        add_vertex(Vector3(-1, -1, 0))

        set_normal(Vector3(0, 0, 1))
        set_uv(Vector2(0, 1))
        add_vertex(Vector3(-1, 1, 0))

        set_normal(Vector3(0, 0, 1))
        set_uv(Vector2(1, 1))
        add_vertex(Vector3(1, 1, 0))

        # End drawing.
        end()


===================================================
/. ./tutorials/3d/occluders.rst
===================================================

.. _doc_occluders:

Occluder Nodes
==============

In addition to occlusion via :ref:`doc_rooms_and_portals`, Godot also has the ability to provide basic occlusion using simple geometric ``Occluder`` nodes. These are geometric shapes that are shown in the editor using gizmos, but are invisible at runtime.

Any object that is fully occluded by the shape (behind or in some cases inside) will be culled at runtime. They are designed to be simple to use and inexpensive at runtime, but the trade off is they may not be as effective at culling as :ref:`doc_rooms_and_portals`. Nevertheless they can still significantly boost performance in some situations.

.. note:: It is important to understand that geometric occluders work by testing the axis aligned bounding box (``AABB``) of the occludee against the occluder. The AABB must be *fully occluded* to be culled. The consequence of this is that smaller objects are more likely to be effectively culled than larger objects, and larger occluders tend to be much more effective than smaller ones.

A major advantage to Occluder nodes is that they are fully dynamic. For example if you place an occluder node as a child of a spaceship, it will move as you move the parent object.

The reason that Occluder nodes are so cheap in performance terms is that the engine dynamically chooses the most relevant occluders at runtime, based on the current viewpoint of the Camera. This means you can often have hundreds of occluders present in the scene. Only the most relevant will be active at any one time.

The Occluder node itself is a holder for an OccluderShape resource, which determines the functionality. To get started, add an Occluder node to your scene tree.

.. tip:: You will see a yellow warning triangle that lets you know that you must set an OccluderShape from the inspector before the ``Occluder`` becomes functional.

OccluderShapeSphere
-------------------

The sphere is one of the simplest and fastest occluders, and is easy to setup and position. The downside is that the sphere only tends to make sense in certain game level designs, and is more suited to terrain or organic background geometry.

Once you have added an OccluderNode and chosen to add a new ``OccluderShapeSphere`` in the inspector, click the OccluderShapeSphere in the inspector to bring up the parameters.

.. image:: img/occluder_shape_sphere_inspector.png

Unlike many Nodes, the ``OccluderShapeSphere`` can store multiple spheres in the same object. This is more efficient in the engine, and keeps your SceneTree clearer. You don't have to store all your spheres in one Occluder as it could become tricky to manage, but it is perfectly reasonable to add 10 or so spheres or more. They are very cheap, and often the more you place, the better the match you will get to your geometry.

In order to store multiple spheres, they are stored as an Array. If you click on the Array in the inspector, you can increase the size of the Array to add one.

.. image:: img/occluder_shape_sphere_terrain.png

The sphere will appear as a small pink spherical object in the editor window. There are two handles on each sphere. The larger middle handle enables you to move the sphere around in the local space of the Occluder, and the small handle enables you to adjust the radius.

Although you can change the position of the sphere using the Occluder Node transform in the inspector, this moves *the entire array* of spheres. When you want to use multiple spheres in one occluder, the handles do this job. In order to allow positioning in 3D, the gizmo will only move the 3D position in the two principal axes depending on the viewpoint in the editor. This is easier for you to get the hang of by trying it out than by explanation.

.. tip:: There is one more handy function in the editor when using multiple spheres. If you click the `Center Node` toolbar button it will recalculate the local positions of the spheres relative to the average of the entire node, and change the transform of the Occluder Node. This is a handy convenience function to make it easier to place them.

At runtime the spheres can be switched on and off changing the Occluder node visibility, and the Node can be moved and scaled and rotated etc.

A common use case for occluder spheres is providing occlusion on mountainous / hilly terrain. By placing spheres inside mountains you can prevent trees, plants, building and objects rendering behind mountains. With some creativity they can also be used for moving objects such as large spacecraft, planets etc.

OccluderShapePolygon
--------------------

The polygon is a generalist occluder. It can be made to work well in almost all situations, and can quickly provide a degree of occlusion culling to most scenes.

As with all geometric occluders, the key to success is to make them large. They do not have to match rendered geometry, and in many cases they will work better if you extend them past rendered geometry to make them as big as possible (without blocking legitimate lines of sight). The reason why they need to be large is that in general, they will only cull objects whose ``AABB`` is completely hidden by the polygon. For large objects to be culled, you will need large occluders.

.. note:: Like all occluders, polygons **can** overlap, and in many cases they will work better if you overlap them (they are more likely to cull objects on boundaries).

Editing and details
~~~~~~~~~~~~~~~~~~~

Occluder polygons are edited as a list of points which define a *convex* polygon, on a single plane. In order to confine the polygon to a single plane, the points are defined in 2D space rather than 3D. The orientation, position and scale of the polygon is taken instead from the transform of the ``Occluder`` Node.

.. image:: img/occluder_shape_polygon_inspector.png

If you create an Occluder and add to it a ``OccluderShapePolygon`` resource, by default it will create 4 starting points forming a rectangle. If you move the position and rotation of the Occluder Node you will see how the rectangle follows the node. When the Occluder is selected in the editor, handles will appear for each of the points. You can actually click and drag these handles, to match your polygon to the environment of your scene.

.. image:: img/occluder_shape_polygon.png

You are not restricted to 4 points, you can add and remove points in the Inspector, but note that:

-  The editor will automatically sanitize your points to form a convex polygon. If you drag a point into a position that would form a concave polygon, it will be ignored.
-  In general, the less edges (and thus points), the faster the polygon will work at runtime. A polygon with 6 edges will have to make twice the calculations of a polygon with 3 edges. In most cases 4 is a good number.

.. image:: img/occluder_shape_polygon2.png

Holes
~~~~~

Real world game levels don't always have large continuous areas that should be occluded. Often walls will have a door or windows, caves will have an entrance, etc. In some cases we have to make do by placing several OccluderShapePolygons around such an opening, but Occluder polygons have one more trick up their sleeve - they can have "holes".

In the inspector you will notice that as well as a set of points for the polygon, the polygon has a set of points for a single "hole". If you add 3 or 4 to your polygon, you will see they appear in the editor as smaller handles. You can drag these around just like the polygon handles, to form a convex hole.

.. image:: img/occluder_shape_polygon_hole.png

The hole can be totally within the polygon (such as a window), abutting the edge (like a door) or crossing the edge of the polygon completely, to make the occluder concave. The way the hole works is that the culling follows a simple rule:

-  If the object to be culled is totally hidden by the polygon, it then looks to see whether it can be seen *through* the hole. If the object touches the hole, it is not culled, but if hidden by the polygon and not seen through the hole it is culled.

.. note:: Placing holes is usually far more convenient, and works faster and better at runtime, than creating lots of smaller OccluderShapePolygons.

Hole Limits
^^^^^^^^^^^

The main limitation of holes is that there can only be one per polygon. If you have a situation which requires two or more holes, you have a choice:

-  Combine the area of the two holes into one bigger hole (if they are close together).
-  Use two or more OccluderPolygons.

.. tip:: Remember that if you are using more than one polygon, they can overlap, and you should use this to your advantage.

How many Occluder polys are needed?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This very much depends on your scene, but generally you can start getting a good benefit from 3 or 4 well placed polygons. After that it is totally up to you how much time you want to spend.
Placing occluders is a bit of an art form, and you will get better at it and learn new tricks the more you work with them.

Some ideas:
^^^^^^^^^^^

-  Build your levels to take advantage of occlusion.

This is one of the secrets of the pros. A good level design is not just about what the gameplay demands, it should also be built with occlusion in mind.

-  When in a building with multiple floors, try placing an occluder polygon between each floor, with a hole for where the staircase transitions between them. This can potentially cull out entire floors and greatly improve performance.
-  Don't be afraid to extend your occluder polygons far past the edges of visible geometry to cull more objects - for instance far into the ground or sky.

Using polygons dynamically
~~~~~~~~~~~~~~~~~~~~~~~~~~

Like all geometric occluders, polygons are not confined to static (non-moving) geometry. You can place them on moving objects. You can even change the relative position of the points in realtime.

Some guidelines:

-  There is a slight cost to moving polygons, the points of the polygons must be transformed on the CPU each time their transform changes.

This is not something to worry excessively about, even CPUs are reasonably fast at transforming points, and generally polygons have very few points compared to rendered geometry. But it is something to consider, if you wanted to create e.g. 10,000 simultaneous spaceships all with occluder polys.

-  Changing the transform of the polygon Node (e.g. by moving the parent object) is cheaper than changing the points themselves. Use the former rather than the latter wherever possible.


===================================================
/. ./tutorials/3d/portals/index.rst
===================================================

.. _doc_rooms_and_portals:

Rooms and Portals
=================

.. toctree::
   :maxdepth: 1
   :name: toc-portals

   introduction_to_rooms_and_portals
   first_steps_with_rooms_and_portals
   using_objects_in_rooms_and_portals
   advanced_room_and_portal_usage
   editing_rooms_and_portals
   rooms_and_portals_example


===================================================
/. ./tutorials/3d/portals/introduction_to_rooms_and_portals.rst
===================================================

.. _doc_portals_introduction:

Introduction to Rooms and Portals
=================================

The rooms and portals system is an optional component of Godot that allows you to partition your 3D game levels into a series of :ref:`Room<class_Room>` s (*aka cells*), and :ref:`Portal<class_Portal>` s. Portals are openings between the rooms that the :ref:`Camera<class_Camera>` (and lights) can see through.
 
This allows several features:

- **Portal occlusion culling**, which can increase performance by reducing the number of objects that are drawn, both to cameras and to shadow maps.

- **Gameplay callbacks**, which allow turning off activity outside the gameplay area - AI, physics, animation, processing etc.

The trade off for these features is that we have to manually partition our level into rooms, and add portals between them.

.. note:: Godot portals should not be confused with those in the `game of the same name <https://en.wikipedia.org/wiki/Portal_(video_game)>`__. They do not warp space, they simply represent a window that the camera (or lights) can see through.

Minimizing manual labour
^^^^^^^^^^^^^^^^^^^^^^^^

Although the effort involved in creating rooms for a large level may seem daunting, there are several factors which can make this much easier:

- If you are "kit bashing" and reusing rooms or areas already, this is an ideal way to save effort. Your level tiles can be rooms, with portals already placed.
- If you are creating procedural levels, you can create rooms and portals as part of the procedural generation algorithm you're writing.
- Finally, if you are manually creating freeform levels, bear in mind there are absolutely no rules as to how far you go with portalling. Even if you separate a large game level into only two rooms, with a single portal between them, this can still result in relatively large performance gains.

The performance benefits (especially in terms of occlusion) follow an L-shaped curve, with the lion's share occurring when you have created just a few rooms. So do not be afraid to be lazy - **\*work smart\***.

In general, when it comes to medium and large-sized levels, it is better to do a little portalling than none at all.

Some caveats
^^^^^^^^^^^^

.. note:: The portal system should be considered an **advanced feature** of Godot. You should not attempt to use rooms and portals until you are familiar with the Godot editor, and have successfully made at least a couple of test games.

It gives you great power as a game designer, but the trade off is that it requires a very technical approach to level design. It is aimed at producing professional-grade results, and assumes the user is prepared to put in the work for this. It is not intended to be used for all 3D games. Not all games will significantly benefit from portals, and it may require more time than a short game jam allows.


===================================================
/. ./tutorials/3d/portals/first_steps_with_rooms_and_portals.rst
===================================================

First steps with Rooms and Portals
==================================

The RoomManager
~~~~~~~~~~~~~~~

Anytime you want to use the portal system, you need to include a special node in your scene tree, called the :ref:`RoomManager<class_RoomManager>`. The RoomManager is responsible for the runtime maintenance of the system, especially converting the objects in your rooms into a *room graph* which is used at runtime to perform occlusion culling and other tasks.

Room Conversion
^^^^^^^^^^^^^^^

This conversion must take place every time you want to activate the system. It does not store the *room graph* in your project (for flexibility and to save memory). You can either trigger it by pressing the **Convert Rooms** button in the editor toolbar (which also has a keyboard shortcut) or by calling the ``rooms_convert()`` method in the RoomManager. The latter method will be what you use in-game. Note that for safety, best practice is to call ``rooms_clear()`` before unloading or changing levels.

.. image:: img/convert_rooms_button.png

If you convert the level while the editor is running, the portal culling system will take over from the normal Godot frustum culling, potentially interfering with editor features. To get around this, you can turn portal culling on and off using either the **View Portal Culling** toggle in the **View** menu on the editor toolbar (which also has a keyboard shortcut) or the **Active** setting in the RoomManager node.

.. note:: To use the RoomManager, you have to tell it where the rooms are in your scene tree, or, more specifically, where the RoomList node is. This RoomList is the parent of your rooms - see below. If the RoomList is not set, conversion will fail, and you will see a warning dialog box.

.. image:: img/room_manager.png

The RoomList
^^^^^^^^^^^^

Before we create any rooms, we must first create a node to be the parent of all the static objects, rooms, roomgroups, and so on in our level. This node is referred to as the the ``RoomList``.

.. image:: img/roomlist_node.png

.. note:: The roomlist is **not** a special node type – it can just be a regular Spatial.

You will need to assign the roomlist node in the RoomManager so that it knows where to find the rooms.

Why do we use a specific branch of the scene tree and not the scene root? The answer is that there are many internal details of the system which are easier to manage if the rooms are placed on their own branch.

Often you will end up completely replacing the roomlist branch at runtime in your game as you load and unload levels.

Rooms
~~~~~

What is a room?
^^^^^^^^^^^^^^^

:ref:`Room<class_Room>`\ s are a way of spatially partitioning your level into areas that make sense in terms of level design. Rooms often quite literally *are* rooms (like in a building). Ultimately though, as far as the engine is concerned, a room represents a **non-overlapping** convex volume in which you typically place most of your objects that fall within that area.

A room doesn't need to correspond to a literal room. It could, for example, also be a canyon in an outdoor area or a smaller part of a concave room. With a little imagination, you can use the system in almost any scenario.

Why convex?
^^^^^^^^^^^

Rooms are defined as convex volumes (or *convex hulls*) because it's trivial to mathematically determine whether a point is within a convex hull. A simple plane check will tell you the distance of a point from a plane. If a point is behind all the planes bounding the convex hull, then by definition it is inside the room. This makes all kinds of things easier in the internals of the system, such as checking which room a camera is within.

*A convex hull. The hull is defined as a series of planes facing outward. If a point is behind all the planes, it is within the hull.*

.. image:: img/convex_hull.png

Why non-overlapping?
^^^^^^^^^^^^^^^^^^^^

If two rooms overlap, and a camera or player is in this overlapping zone, then there is no way to tell which room the object should be in (and hence render from), or be rendered in. This requirement for non-overlapping rooms does have implications for level design.

If you accidentally create overlapping rooms, the editor will warn you when you convert the rooms, indicating any overlapping zones in red.

.. image:: img/room_overlap.png

The system does attempt to cope with overlapping rooms as best as possible by making the current room *"sticky"*. Each object remembers which room it was in during the previous frame and stays within it as long as it does not move outside the convex hull room bound. This can result in some hysteresis in these overlapping zones.

There is one exception, however, for :ref:`internal rooms<doc_rooms_and_portals_internal_rooms>`. You do not have to worry about these to start with.

How do I create a room?
^^^^^^^^^^^^^^^^^^^^^^^

A :ref:`Room<class_Room>` is a node type that can be added to the scene tree like any other. You can place objects within the room by making them children and grand-children of the Room node.

How do I define the shape and position of my room convex hull?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Because defining the room bound is the most important aspect of the system, there are THREE methods available to define the shape of a room in Godot:

1. Use the geometry of the objects contained within the room to automatically create an approximate bound.
2. Manually edit the points that define the convex hull in the room inspector or drag the points around using the editor gizmo (see :ref:`doc_room_point_editing`).
3. Provide a manual bound. This is a MeshInstance in the room that has geometry in the shape of the desired bound, with a name with the postfix ``-bound``. This is something you might choose to do if you create your levels in Blender or similar (see :ref:`doc_rooms_and_portals_blender`).

While the first option can be all that is required, particularly with simple rooms or for pre-production, using manual bounds gives you ultimate control at the expense of a small amount of editing. You can also combine the two approaches, perhaps using automatic bounds for most rooms but manually editing problem areas.

The automatic method is used whenever a manual bound is not supplied.

*A simple pair of rooms. The portal margin is shown with translucent red, and the room hulls are shown with green wireframe.*

.. image:: img/simple_room.png

Portals
~~~~~~~

If you create some rooms, place objects within them, then convert the level in the editor, you will see the objects in the rooms appearing and showing as you move between rooms. There is one problem, however! Although you can see the objects within the room that the camera is in, you can't see to any neighbouring rooms! For that we need portals.

:ref:`Portal<class_Portal>`\ s are special convex polygons that you position over the openings between rooms in order to allow the system to see between them. You can create a portal node directly in the editor. The default portal has 4 points and behaves much like a ``plane`` :ref:`MeshInstance<class_MeshInstance>`. You can add or remove points using the inspector. A portal requires at least 3 points to work - this is because it needs to form a polygon rather than a point or line.

To save editing effort, **only one Portal is required between each pair of Rooms**. You *do not need* to (and indeed should not) create two Portals that overlap in opposite directions. Portals default to being two-way, but you can make them one-way in the Portal inspector.

You should therefore place a portal in only one of each pair of neighbouring rooms - this is the portal's *"source room"*. Generally it doesn't matter which you choose as the source room. The portal normal (the arrow in the gizmo) should face *outward* from the source room.

.. image:: img/portal_inspector.png

Do not be confused by the arrow. Although the arrow shows which direction the portal faces, most portals will be *two-way*, and can be seen through from both directions. The arrow is more important for ensuring that the portal links to the correct neighbouring room.

Portal linking
^^^^^^^^^^^^^^

There are two ways to specify which room the portal should link to:

- Leave the **Linked Room** in the inspector blank. The system will attempt to *autolink* the portal to the nearest neighbour room during conversion. This works fine in most cases.
- Explicitly specify the room by setting the **Linked Room** in the inspector.

.. note:: Portals are defined as a set of 2D points. This ensures that the polygon formed is in a single plane. The transform determines the portal orientation. The points must also form a *convex* polygon. This is enforced by validating the points you specify, ignoring any that do not form a convex shape. This makes editing easier while making it difficult to break the system.

Trying it out
~~~~~~~~~~~~~

By now you should be able to create a couple of rooms, add some nodes such as MeshInstances within the rooms, and add a portal between the rooms. Try converting the rooms in the editor and see if you can now view the objects in neighbouring rooms through the portal.

.. image:: img/simple_scenetree.png

You have now mastered the basic principles of the system.

The next step is to look at the different types of objects that can be managed by the system.


===================================================
/. ./tutorials/3d/portals/using_objects_in_rooms_and_portals.rst
===================================================

Using objects in Rooms and Portals
==================================

Normally, when you use Godot, all objects that you can see (:ref:`VisualInstance<class_VisualInstance>`\ s) are treated in the same way by the engine. The portal renderer is slightly different, in that it makes a distinction between the different roles objects will have in your game. It makes this distinction to define the :ref:`Room<class_Room>`\ s, and to render and process everything in the most efficient way.

Portal mode
~~~~~~~~~~~

If you look in the inspector, every VisualInstance in Godot is derived from a :ref:`CullInstance<class_CullInstance>`, where you can set a ``PortalMode``. This determines how objects will behave in the portal system.

.. image:: img/cull_instance.png

STATIC
^^^^^^

The default mode for objects is ``STATIC``. Static objects are objects within rooms that will not move throughout the lifecycle of the level. Things like floors, walls, ceilings are good candidates for ``STATIC`` objects.

DYNAMIC
^^^^^^^

Dynamic mode is for objects that are expected to move during the game. But there is a limitation - **they must not move outside of their original room**. These objects are handled very efficiently by the system. Examples might include moving platforms, and elevators.

ROAMING
^^^^^^^

Roaming mode is for objects that can move between rooms. Things like players and enemies should be marked as roaming. These are more expensive to calculate than ``STATIC`` or ``DYNAMIC`` modes, because the system has to keep track of which room a roaming object is within.

GLOBAL
^^^^^^

Global mode is for objects that you don't want occlusion culled at all. Things like a main player's weapon, bullets and some particle effects are good candidates for ``GLOBAL`` mode.

IGNORE
^^^^^^

Ignore is a special mode for objects that will be essentially free in the system. Manual bounds (``-bound``) get converted to ignore portal mode automatically. They don't need to show up during the game, but are kept in the scene tree in case you need to convert the level multiple times (e.g. in the Editor). You might also choose to use this for objects that you *only* want to show up in the editor (when RoomManager is inactive).

Should you place objects within rooms (in the scene tree) or not?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``STATIC`` and ``DYNAMIC`` objects are ideally placed within rooms in the scene tree. The system needs to know which room they are in during conversion as it assumes they will never change room. Placing them within rooms in the scene tree allows you to explicitly tell the system where you want them.

Autoplace
^^^^^^^^^

However, for ease of use, it is also possible to place ``STATIC`` and ``DYNAMIC`` objects *outside* the rooms in the scene tree, but within the RoomList branch. The system will attempt to **autoplace** the objects into the appropriate room. This works in most cases but if in doubt, use the explicit approach. The explicit approach is especially needed when dealing with internal rooms, which have some restrictions for sprawling objects.

.. image:: img/freeform.png

Note that if you place ``STATIC`` and ``DYNAMIC`` objects outside of rooms, they will not contribute to the room bound. If you are using the room geometry to derive the bound, tables and chairs can be placed outside the room. However, walls and floors should be explicitly within the Room's branch of the scene tree to ensure the bound is correct.

``ROAMING`` and ``GLOBAL`` objects are recommended to be kept in a branch of the scene tree outside of any rooms or the RoomList. They *can* be placed inside the rooms, but to save confusion, they are normally better kept on their own branch. There are no restrictions on the placement of ``IGNORE`` objects.

Object Lifetimes
^^^^^^^^^^^^^^^^

It is important to note that the lifetime of ``STATIC`` and ``DYNAMIC`` objects is tied to the lifetime of the level, between when you call ``rooms_convert()`` to activate the portal system, and calling ``rooms_clear()`` to unload the system. This is because quite a bit of pre-processing goes on during the conversion phase in order to render them efficiently.

You should therefore not try to create or delete ``STATIC`` or ``DYNAMIC`` objects while the portal system is active. Doing so will cause the system to automatically unload because it is in an invalid state. You can however, freely ``show()`` and ``hide()`` these objects.

The sequence should be therefore:

- Load your level.
- Place any ``STATIC`` or ``DYNAMIC`` objects.
- Then run ``rooms_convert()`` *after* all the ``STATIC`` and ``DYNAMIC`` objects were added to the scene tree.

Objects that are ``ROAMING``, ``GLOBAL`` or ``IGNORE`` can be freely created and deleted as required.

Sprawling
~~~~~~~~~

Although users can usually ignore the internals of the portal system, they should be aware that it is capable of handling objects that are so big they end up in more than one room. Each object has a central room, but using the AABB or geometry the system can detect when an object extends across a portal into a neighbouring room (or several rooms). This is referred to as **sprawling**.

This means that if the corner of an object extends into a neighbouring room, but the object's main room is not showing (e.g. a train where the end is in a different room), the object will not be culled, and will still be shown. The object will only be culled if it is not present in any of the rooms that are visible.

Portal Margins
^^^^^^^^^^^^^^

It is hard to place objects exactly at the edges of rooms, and if we chose to sprawl objects to the adjacent room the moment a portal was crossed (even by a very small amount), there would be an unnecessary amount of sprawling, and objects would end up being rendered when not really required. To counter this, portals have an adjustable ``margin`` over which an object can cross without being considered in the next room. The margin is shown in the editor gizmo as a red translucent area.

You can set the margin globally in the RoomManager. You can also override this margin value in any portal if you need to finetune things. As you edit the margin values in the inspector, you should see the margins update in the 3D editor viewport.

Include in Bound
^^^^^^^^^^^^^^^^

The support for objects that are larger than a single room has one side effect. You may not want to include some objects in the calculation of the automatic room bound. You can turn this on and off in the inspector for each object. See **Cull Instance > Include In Bound**.

While sprawling works great for large moving objects, it also gives you a lot more leeway in level design. You can for instance create a large terrain section and have it present in multiple rooms, without having to split up the mesh.

Lighting
~~~~~~~~

In general lights are handled like any other visual instance. They can be placed in rooms, and they will sprawl to affect neighbouring rooms, following the dimensions and direction of the light. The exception to this is :ref:`DirectionalLight<class_DirectionalLight>`\ s. DirectionalLights have no source room as they affect *everywhere*. They should therefore not be placed in a room. As DirectionalLights can be expensive, it is a good idea to turn them off when inside, see the later :ref:`doc_rooms_and_portals_roomgroups` section for details on how to do this.

Congratulations! You have now mastered the intermediate techniques required to use rooms and portals. You can use these to make games already, but there are many more features.


===================================================
/. ./tutorials/3d/portals/advanced_room_and_portal_usage.rst
===================================================

Advanced Room and Portal usage
==============================

Gameplay callbacks
~~~~~~~~~~~~~~~~~~

Although occlusion culling greatly reduces the number of objects that need to be rendered, there are other costs to maintaining objects in a game besides the final rendering. For instance, in Godot, animated objects will still be animated whether they appear on screen or not. This can take up a lot of processing power, especially for objects that use software skinning (where skinning is calculated on the CPU).

Fear not, rooms and portals can solve these problems, and more.

By building our system of rooms for our game level, not only do we have the information needed for occlusion culling, we also have handily created the information required to know which rooms are in the local "gameplay area" of the player (or camera). If you think about it, in a lot of cases, there is no need to do a lot of simulation on objects that have nothing to do with gameplay.

The gameplay area is not confined to just the objects you can see in front of you. AI monsters behind you still need to attack you when your back is turned! In Godot the gameplay area is defined as the *potentially visible set* (PVS) of rooms, from the room you are currently within. That is, if there is any part of a room that can possibly be viewed from any part of the room you are in (even from a corner), it is considered within the PVS, and hence the gameplay area.

This works because if a monster is in an area that is completely out of view for yourself or the monster, you are less likely to care what it is doing.

How does a monster know whether it is within the gameplay area?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This problem is solved because the portal system contains a subsystem called the **Gameplay Monitor** that can be turned on and off from the :ref:`RoomManager<class_RoomManager>`. When switched on, any roaming objects that move inside or outside the gameplay area (whether by moving themselves, or the camera moving) will receive callbacks to let them know of this change.

You can choose to either receive these callbacks as ``signals``, or as ``notifications``.

Notifications can be handled in GDScript or other scripting languages:

.. code-block:: none

	func _notification(what):
		match what:
			NOTIFICATION_ENTER_GAMEPLAY:
				print("notification enter gameplay")
			NOTIFICATION_EXIT_GAMEPLAY:
				print("notification exit gameplay")

Signals are sent just as any other signal. They can be attached to functions using the editor inspector. The signals are called ``gameplay_entered`` and ``gameplay_exited``.

In fact, you don't just receive these callbacks for ``ROAMING`` objects. In addition Rooms and RoomGroups (which can be used to form groups of rooms) can also receive callbacks. For example, you can use this to trigger AI behaviour when the player reaches certain points in a level.

VisbilityNotifiers / VisibilityEnablers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Gameplay callbacks have one more useful function. By default in Godot, animation and physics are still processed regardless of whether an object is within view. This can sap performance, especially when using software skinning.

The engine's solution to this problem is the :ref:`VisibilityNotifier<class_VisibilityNotifier>` node, and its slightly easier to use variation, the :ref:`VisibilityEnabler<class_VisibilityEnabler>` node. VisibilityEnabler can be used to switch off animation and sleep physics when an object is outside the view frustum. You do this by simply placing a VisibilityEnabler node in your subscene (for e.g. a monster). It will do the rest. Consult the :ref:`VisibilityEnabler<class_VisibilityEnabler>` documentation for full details.

.. image:: img/visibility_enabler.png

What if the VisibilityEnabler could turn off objects when they were occlusion culled? Well it turns out VisibilityEnabler can. All you have to do is enable the **Gameplay Monitor** in the RoomManager and the rest happens automatically.

.. _doc_rooms_and_portals_roomgroups:

RoomGroups
~~~~~~~~~~

A :ref:`RoomGroup<class_RoomGroup>` is a special node which allows you to deal with a group of rooms at once, instead of having write code for them individually. This is especially useful in conjunction with gameplay callbacks. The most important use for RoomGroups is to delineate between "inside" and "outside" areas.

.. image:: img/roomgroups.png

For instance, when outside you may wish to use a :ref:`DirectionalLight<class_DirectionalLight>` to represent the sun. When the outside RoomGroup receives an ``enter gameplay`` callback, you can turn the light on, and you can turn it off when the RoomGroup exits gameplay. With the light off, performance will increase as there is no need to render it indoors.

This is an example of a simple RoomGroup script to turn on and off a DirectionalLight. Note that you can also use signals for callbacks (the choice is up to you):

.. image:: img/roomgroup_notification.png

.. tip:: You can apply the same technique for switching on and off weather effects, skyboxes and much more.

.. _doc_rooms_and_portals_internal_rooms:

Internal Rooms
~~~~~~~~~~~~~~

There is one more trick that RoomGroups have up their sleeve. A very common desire is to have a game level with a mixed outdoor and indoor environment. We have already mentioned that rooms can be used to represent both rooms in a building, and areas of landscape, such as a canyon.

What happens if you wish to have a house in a terrain 'room'?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

With the functionality described so far you *can* do it - you would need to place portals around the exterior of the house though, forming needless rooms above the house. This has been done in many games. But what if there was a simpler way?

It turns out there is a simpler way of handling this scenario. Godot supports *rooms **within** rooms* (we will call them **"internal rooms"**). That is, you can place a house within a terrain room, or even a building, or set of buildings, and even have exit portals in different terrain rooms!

To create internal rooms, you don't need to place a room within another room in the scene tree - in fact you will get a warning if you try this. Instead, create them as regular rooms. The internal rooms should be grouped together with a RoomGroup as parent. If you look in the inspector for the RoomGroup, there is a **Room Group Priority** which defaults to ``0``.

If you want a room or set of rooms to be internal, set the priority to a higher value than the outer (enclosing) room, using the RoomGroup.

The system uses the priority setting to give priority to the internal room when deciding which room a camera or object is within. Higher priority *always* wins. Everything else works in a mostly similar way.

The only differences:

- Portals between internal rooms and outer rooms should always *be placed in the inner (internal) room*.
- Portals of internal rooms are not considered as part of the bound of outer rooms.
- ``STATIC`` and ``DYNAMIC`` objects from outer rooms will not sprawl into internal rooms. If you want objects to cross these portals, place them in the internal room. This is to prevent large objects like terrain sections sprawling into entire buildings, and rendering when not necessary.

Internal room example
^^^^^^^^^^^^^^^^^^^^^

The tent is a simple room inside a terrain room (which contains the ground, the trees etc).

.. image:: img/tent.png

.. note:: To use internal rooms for buildings, it is usually a good idea to split the *interior* mesh of the building from the *exterior*. The exterior can be placed in the outer room (so it can be seen from outside, but not from the inside), and the interior should be placed in the interior room (so it only visible inside, or through the portal).

.. image:: img/tent_terrain.png

This is perfect for improving performance in open world games. Often your buildings can be scenes (including the rooms and portals) that can be reused. When viewed from the outside, interiors will mostly be culled, and when viewing from the inside other buildings and most of the outside will be culled. The same goes for other players and objects that are inside and outside the buildings.

*Scene is 'Diorama Eco scene' by Odo, with slight changes for illustration purposes.* `CC Attribution <https://creativecommons.org/licenses/by/4.0/>`_

Internal room scenes
^^^^^^^^^^^^^^^^^^^^

Let us look in detail at another practical example for an open world. We want to place houses (as internal rooms) on an island, but have each house as a self-contained scene containing both the interior *and* the external mesh of the house.

.. image:: img/house_scene.png

We have created a Room node (which will become the internal room) into which we have placed the interior meshes. We have also created a Portal with no links (so autolinking will be used). The exterior mesh is *not* within the room. It will be autoplaced, and we are intending for it to be placed within the outer room.

However there is a problem. The naive autoplace algorithm will look at the center of the exterior mesh, and attempt to place it *within* the internal room. We want to avoid this somehow, as the idea of the exterior mesh is to have something rendered from the outside, so it must be in the outer room for everything to work.

To get around this problem, there is a special setting to enable you to express a preference for autoplacing in an outer room. Each object has an **Autoplace Priority** setting. When set to ``0``, there is no preference (the object will be placed in the highest priority room).

However, if we set this autoplace priority to ``-1`` for example, the autoplace will always choose a ``-1`` priority room (if one is present at that location). So if we set the outer room priority to ``-1``, it will always place our exterior into our "outside" room.

.. image:: img/autoplace_priority.png

This gives us a helpful extra bit of control for these kinds of situations, and makes the entire system much more flexible.

.. note:: As the default autoplace priority is ``0``, you can't effectively force objects into RoomGroups with priority ``0``. However there are plenty of priority values available so this should not be a problem in practice.

The final scene looks something like this, with houses instanced wherever you want them on a giant outer room.

.. image:: img/island.png

The house exteriors will be placed in the outer room, and therefore can always be seen when looking from the outside. The interiors will only be rendered when a view into the entry portals is visible.


===================================================
/. ./tutorials/3d/portals/editing_rooms_and_portals.rst
===================================================

Editing Rooms and Portals
=========================

Example SceneTree
~~~~~~~~~~~~~~~~~

Putting all the ideas together, here is an example scene tree:

.. image:: img/example_scenetree.png

- We have used a :ref:`RoomGroup<class_RoomGroup>` to denote an outside area.
- The :ref:`MeshInstance<class_MeshInstance>`\ s inside the :ref:`Room<class_Room>`\ s are either ``STATIC`` or ``DYNAMIC``.
- We have created a :ref:`Spatial<class_Spatial>` (I decided to call it 'Freeform', but you could use any name) under which to place ``STATIC`` and ``DYNAMIC`` objects that will be autoplaced in rooms
  (Freeform is inside the ``roomlist``, but *not* inside a room.)
- The player and the monsters are on branches *OUTSIDE* the ``roomlist``.
- The player and monster meshes have portal mode ``ROAMING`` so they can be in any room.
- The camera is outside the ``roomlist``.

.. _doc_rooms_and_portals_blender:

Creating room systems in Blender (or other modeling tools)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Although you can create your room system entirely within the editor, you can also build rooms and portals within your modeling tool. There is one small snag - modeling tools such as Blender have no knowledge of Room, RoomGroup and Portal nodes. In order to work around this we use a series of naming conventions. The first time Godot encounters these specially named nodes, it will convert them into Rooms, RoomGroups and Portals.

Postfix convention
^^^^^^^^^^^^^^^^^^

- ``-room`` becomes a :ref:`Room<class_Room>`.
- ``-roomgroup`` becomes a :ref:`RoomGroup<class_RoomGroup>`.
- ``-portal`` becomes a :ref:`Portal<class_Portal>`.
- ``-bound`` becomes a manual bound.

Rooms and RoomGroups should be created as Empties within Blender. Any mesh children of the ``-room`` Empty will thus be placed in the Room during conversion in Godot.

For example:

- ``kitchen-room`` - create a Room called "kitchen".
- ``outside-roomgroup`` - create a RoomGroup called "outside".
- ``kitchen-portal`` - create a Portal leading to the "kitchen" Room.

Portals
^^^^^^^

Portals are different from Rooms. In Portals, we need to specify the geometry of the Portal in our modelling tool, in addition to just the name. To do this your "portal-to-be" should be created as a Mesh.

Portal meshes have some restrictions to work properly. They must be convex, and the polygon points should be in the same plane. The accuracy to the plane does not have to be exact, as Godot will automatically average the direction of the portal plane. Once converted to a :ref:`Portal<class_Portal>` node, the snapping to the portal plane is enforced, and the vertices are specified (and editable) as 2D coordinates in the inspector, rather than 3D points.

The portal's naming is quite important. You can either name the portal ``-portal`` which will attempt to autolink the Portal in Godot, or you can use the name of the Room you wish to link the Portal to as a prefix.

Wildcard
^^^^^^^^

In most cases, this can be done using a name such as ``kitchen-portal``. However, there is one problem. Blender and Godot do not deal well when you have multiple objects with the same name. What happens when we want more than one Portal to lead to the kitchen?

The workaround is the use of a *wildcard* character, ``*``. When Godot reads the wildcard, it will ignore anything placed after it in the name.

This means we can use the following portal names:

- ``kitchen*1-portal`` - creates a Portal leading to the "kitchen".
- ``kitchen*2-portal`` - also creates a Portal leading to the "kitchen".
- ``kitchen*anything_you_want_here-portal`` - also works.

Wildcards work on all of the nodes which use these naming conventions.

Manual bounds
^^^^^^^^^^^^^

Manual bounds are a way of explicitly setting the convex hull for a room, and are used if they are present as children of a room in the scene tree. Aside from the postfix, the naming is unimportant. They should be meshes (i.e. MeshInstance in Godot). Bear in mind they will be converted to convex hulls during the conversion process, so they don't have to be perfect.

.. tip:: Once used during conversion, they will be converted to the ``IGNORE`` **Portal Mode** and won't be shown. You can alternatively use **Generate Points** within the editor to convert these to a set of points stored in the room, and delete the original ``-bound`` MeshInstance.

Portal point editing
~~~~~~~~~~~~~~~~~~~~

Portals are defined by a combination of the transform of the portal node, and by a set of points which form the corners.

The default portal has 4 corners as shown in the inspector:

.. image:: img/portal_point_editing.png

You can edit these points in the gizmo or inspector to make a better match to the opening in your game level. It's generally better to keep the number of points as low as possible for the efficiency of the system. For example, it's better to risk rendering a little too much than to spend the time culling objects at 20 different edges.

.. _doc_room_point_editing:

Room point editing
~~~~~~~~~~~~~~~~~~

You also have the option to manually edit the points used to define the convex hull of a room. These points are not present by default. You would typically create them by pressing the **Generate Points** button in the editor toolbar when a room is selected. This will transfer the auto bound from the geometry (or manual ``-bound`` mesh) into the inspector. Once there are points in the inspector, they will be used and override any other method. So if you wish to revert your manual editing, delete all the room's points.

.. image:: img/room_point_editing.png

Manually editing points can be useful in some situations, especially where the auto-bound doesn't *quite* get the right result you want. It is usually a good idea to use a lot of **Simplification** in the inspector for the Room before generating the points. Be aware though that by default, the **Simplification** value will be inherited from the RoomManager.

RoomManager
~~~~~~~~~~~

Show Debug
^^^^^^^^^^

This can be used to control the amount of logging, especially the room conversion logs. Debug will always be set to ``false`` on exported projects.

Debug Sprawl
^^^^^^^^^^^^

This mode will only display meshes that are sprawling through portals from the current camera room. Large statics that cross portals are usually the ones you want to sprawl. Typical examples might be terrain mesh areas, or large floor or ceiling meshes. You usually don't want things like door frames to sprawl to the adjacent room - that is what fine tuning the **Portal Margin** is for.

Merge Meshes
^^^^^^^^^^^^

To keep drawcalls to a minimum, the system offers the option to automatically merge similar ``STATIC`` meshes within a room (also known as *static batching*). This can increase performance in many cases. The culling accuracy is reduced, but as a room is a fairly logical unit for culling, this trade off usually works in your favor.

Plane Simplification
^^^^^^^^^^^^^^^^^^^^

In some cases, the convex hulls automatically generated for rooms may contain a very large number of planes, particularly if you use curved surfaces. This is not ideal because it slows down the system. This option can optionally simplify hulls. The degree of simplification can be selected by the user, between ``0`` (no simplification) and ``1`` (maximum simplification). You can also override this value in individual rooms.

Portals
~~~~~~~

Portal Active
^^^^^^^^^^^^^

Portals can be turned on and off at runtime. This is especially useful if you have doors that can open and close.

Two Way
^^^^^^^

Portals can either be two-way or one-way. The default two-way portals are quicker to set up in most circumstances, but one-way portals can be useful in some cases. For example, you can use one-way portals to create windows that can be seen out of, but not seen into. This can help performance when viewing buildings from outdoors.

Particle Systems
~~~~~~~~~~~~~~~~

Be aware that when placing ``STATIC`` particle systems, the AABB on conversion may have zero size. This means the particle system may be unexpectedly culled early. To prevent this, either set the particle system ``portal mode`` to ``DYNAMIC``, or alternatively, add an **Extra Cull Margin** to the particle system in the Geometry Inspector.

Multimeshes
~~~~~~~~~~~

Note that multimeshes will be culled as a group, rather than individually. You should therefore attempt to keep them localised to the same area wherever possible.


===================================================
/. ./tutorials/3d/portals/rooms_and_portals_example.rst
===================================================

Rooms and Portals example
=========================

Download this tutorial project:
`Simple Portals Example <https://github.com/lawnjelly/godot-demo-projects/tree/portals_simple_demo/3d/portals/room_and_portals_simple_example>`_
.

Introduction
~~~~~~~~~~~~

This tutorial will introduce you to building a "Hello World" room system with two rooms, and a portal in between.

Step 1
~~~~~~

.. image:: tutorial_simple/img/tutorial_simple_1.png

- Create a new project.
- Add a :ref:`Spatial<class_Spatial>` as the scene root (on the screenshot, it's called "Root").
- Next add a :ref:`RoomManager<class_RoomManager>` node. We will need this later to process the room system.
- Next we need to start defining our rooms. We create all our rooms under another Spatial we have called 'RoomList'.
- Add a new :ref:`Room<class_Room>` node as a child of the roomlist.
- We have named the room ``Kitchen``.
- We will now create the geometry of our room. The names you give to the geometry is up to you.
- Create a :ref:`MeshInstance<class_MeshInstance>` for the floor. Create a box by adding a CubeMesh resource to the MeshInstance. Scale and position it to form a floor.
- Create MeshInstances for the walls. Create more box meshes for this, then scale and position them. Be sure to leave an opening on one side. You will need to create two wall segments to do this on that side.

Step 2
~~~~~~

.. image:: tutorial_simple/img/tutorial_simple_2.png

- Now we need to create the other room.
- You can do this simply by duplicating the first room (select the ``Kitchen`` node, right click and choose **Duplicate**).
- Rotate and position the second room so that the openings line up.
- Rename the second room to ``Lounge``.

Step 3
~~~~~~

.. image:: tutorial_simple/img/tutorial_simple_3.png

- Next, we will add a portal between the two rooms.
- Create a new :ref:`Portal<class_Portal>` in the kitchen.
- Scale and position the portal using the node ``Transform`` in the inspector, so it fits within the opening between the two rooms.
- The portal plane should face *outward* from the source room, i.e. towards the lounge. This direction is indicated by the arrow in the editor gizmo, and portal gizmo's color.

Step 4
~~~~~~

.. image:: tutorial_simple/img/tutorial_simple_4.png

- To make things more exciting, we want to add a few more boxes to the rooms.
- Placing these boxes as children or grandchildren of the room nodes explicitly tells the system which room the objects should be in. However, we can also create these objects *outside* the rooms. Provided they are in the RoomList branch, the system will attempt to automatically place them in the correct room at runtime.
- On the screenshot, the boxes were places as children of a Spatial I have called ``Freeform`` to keep things tidy.
- Boxes also have a green SpatialMaterial assigned to them to make them stand out more from the rest of the room.
- Let's also create an :ref:`OmniLight<class_OmniLight>` so it will be autoplaced in one of the rooms.

Step 5
~~~~~~

.. image:: tutorial_simple/img/tutorial_simple_5.png

- Next comes a crucial stage. We must let the RoomManager know where the rooms are!
- Select the RoomManager and look in the Inspector window in the **Paths** section.
- You need to assign the **Room List** to point to the RoomList node we created earlier (which is the parent of all the rooms).

Step 6
~~~~~~

.. image:: tutorial_simple/img/tutorial_simple_6.png

- Make sure you have saved your project before this next step. It is always a good idea to save and make a backup before converting.
- Select the RoomManager, and you will see a button in the toolbar at the top of the 3d editor viewport called **Convert Rooms**. Press this button.
- If all goes well, the RoomManager will have created the runtime data (the *room graph*) to perform occlusion culling at runtime.
- You can see a log of the conversion process in the output window. This is helpful for finding problems.
- If you now move the editor camera inside the rooms, you should see the meshes in the opposite room being culled depending on what you can see through the portal.

Conclusion
~~~~~~~~~~

This concludes this simple tutorial. Don't be afraid to experiment with the new room system you have created.

Some things to try
^^^^^^^^^^^^^^^^^^

- Create different types of geometry. CSG nodes, Particle systems, and Multimeshes are all supported by the portal system.
- Try creating a Camera and adding it to the scene. If you run the scene you will notice that the portal culling is not active. This is because the ``room graph`` must be created each time you load a level, by converting the rooms. Instead of using a button in the editor, in real games you call a function in the RoomManager to convert the level, called ``rooms_convert()``. Try this out with a script, perhaps running within a ``_ready()`` function.
- The geometry you created so far is all ``STATIC`` (non-moving). If you look in the inspector for geometry nodes, you will see they derive from ``CullInstance``. Here you can set the **Portal Mode** for objects in the portal system. This determines how the node is processed.
- If you now write a script to move one of your objects within a room and view it through a Camera as the scene runs, you may notice that the object gets culled incorrectly. This is because ``STATIC`` objects are assumed not to move in the system. If you instead change the object to ``DYNAMIC``, it should now update the culling correctly.
- There are several ``portal_modes``, these are described in the main documentation.
- Try turning the portal on and off at runtime from your script. You can call ``set_portal_active()`` to open and close the portal.
- If you select the portal, you should see 4 handles appear. Try dragging the portal points with the mouse, and see how it affects the objects that are culled.
- If you select a room and click the **Generate Points** button in the toolbar, it will store the points of the room hull in the room inspector. You can now edit these with the gizmo handles.


===================================================
/. ./tutorials/3d/3d_text.rst
===================================================

.. _doc_3d_text:

3D text
=======

Introduction
------------

In a project, there may be times when text needs to be created as
part of a 3D scene and not just in the HUD. Godot provides two
methods to do this. The Label3D node and the text mesh for a
MeshInstance node.

This page does **not** cover how to display a GUI scene in a 3D
environment. For information on how to do that see `this <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/2d_in_3d>`__
demo project.

Label3D
-------

.. image:: img/label_3d.png

Label3D behaves like a label node but in a 3D space. Unlike label
node this can not inherit properties of a GUI theme. However its
look remains customizable and uses the same DynamicFont and BitmapFont
subresources control nodes use.

Label3D has minimal interaction with a 3D environment, it can be lit
up and shaded by light sources if the shaded flag is enabled, but it
will not cast a shadow, even with cast shadow turned on under the nodes
GeometryInstance3D settings. This is because the node is a quad mesh
(one glyph per quad) with transparent textures and has the same limitations
as Sprite3D. See :ref:`this page <doc_3d_rendering_limitations_transparency_sorting>`
for more information.

Text mesh
---------

.. image:: img/text_mesh.png

Text meshes have similarities to Label3D. They display text in a 3D
scene, and will use the same DynamicFont subresource. However text is 3D and
has the properties of a mesh. A text mesh cast shadows onto the environment
and can have a material applied to it. Here is an example of a texture and
how it's applied to the mesh.

.. image:: img/text_mesh_texture.png

.. image:: img/text_mesh_textured.png

There are two limitations to text mesh. It can't use bitmap fonts, or fonts
with self intersection.


===================================================
/. ./tutorials/animation/index.rst
===================================================

Animation
=========

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-animation

   introduction
   cutout_animation
   2d_skeletons
   animation_tree
   playing_videos


===================================================
/. ./tutorials/animation/introduction.rst
===================================================

.. _doc_introduction_animation:

Introduction to the animation features
======================================

The :ref:`class_AnimationPlayer` node allows you to create anything
from simple to complex animations.

In this guide you learn to:

-  Work with the Animation Panel
-  Animate any property of any node
-  Create a simple animation
-  Call functions with the powerful Call Function Tracks

In Godot, you can animate anything available in the Inspector, such as
Node transforms, sprites, UI elements, particles, visibility and color
of materials, and so on. You can also modify values of script variables
and call any function.

Create an AnimationPlayer node
------------------------------

To use the animation tools we first have to create an
:ref:`class_AnimationPlayer` node.

The AnimationPlayer node type is the data container for your animations.
One AnimationPlayer node can hold multiple animations, that can
automatically transition to one another.

.. figure:: img/animation_create_animationplayer.png
   :alt: The AnimationPlayer node

   The AnimationPlayer node

After creating one click on the AnimationPlayer node in the Node tab to
open the Animation Panel at the bottom of the viewport.

.. figure:: img/animation_animation_panel.png
   :alt: The animation panel position

   The animation panel position

It consists of four parts:

.. figure:: img/animation_animation_panel_overview.png
   :alt: The animation panel

   The animation panel

-  Animation controls (i.e. add, load, save, and delete animations)
-  The tracks listing
-  The timeline with keyframes
-  The timeline and track controls, where you can zoom the timeline and
   edit tracks for example.

Computer animation relies on keyframes
--------------------------------------

A keyframe defines the value of a property at a certain point in time.

Diamond shapes represent keyframes in the timeline. A line between two
keyframes indicates that the value hasn't changed.

.. figure:: img/animation_keyframes.png
   :alt: Keyframes in Godot

   Keyframes in Godot

The engine interpolates values between keyframes, resulting in a gradual
change in values over time.

.. figure:: img/animation_illustration.png
   :alt: Two keyframes are all it takes to obtain a smooth motion

   Two keyframes are all it takes to obtain a smooth motion

The timeline lets you insert keyframes and change their timing. It also
defines how long the animation is.

.. figure:: img/animation_timeline.png
   :alt: The timeline in the animation panel

   The timeline in the animation panel

Each line of the Animation Panel is an animation track. Normal and
Transform tracks reference node properties. Their name or id is a path
to the node and the affected property.

.. figure:: img/animation_normal_track.png
   :alt: Example of Normal animation tracks

   Example of Normal animation tracks

.. tip::

   If you animate the wrong property, you can edit a track's path anytime.
   Double click on it and type the new path. Play the animation using the
   "Play from beginning" button |Play from beginning| (or pressing
   :kbd:`Shift + D` on keyboard) to see the changes instantly.

Tutorial: Creating a simple animation
-------------------------------------

Scene setup
~~~~~~~~~~~

For this tutorial, we'll create a Sprite node with an AnimationPlayer as
its child. We will animate the sprite to move between two points on the screen.

.. figure:: img/animation_animation_player_tree.png
   :alt: Our scene setup

   Our scene setup

.. warning::

   AnimationPlayer inherits from Node instead of Node2D or Spatial, which means
   that the child nodes will not inherit the transform from the parent nodes
   due to a bare Node being present in the hierarchy.

   Therefore, it is not recommended to add nodes that have a 2D/3D transform
   as a child of an AnimationPlayer node.

The sprite holds an image texture. We animate that sprite to move
between two points on the screen. For this tutorial, use the default Godot
icon as the sprite's texture. As a starting point, move the sprite
to a left position on the screen.

Select the AnimationPlayer node, then click the "Animation" button in the
animation editor. From the list select "New" (|Add
Animation|) to add a new animation. And Enter a name for the animation in the
dialog box.

.. figure:: img/animation_create_new_animation.png
   :alt: Add a new animation

   Add a new animation

Adding a track
~~~~~~~~~~~~~~

To add a new track for our sprite, select it and take a look in the
toolbar:

.. figure:: img/animation_convenience_buttons.png
   :alt: Convenience buttons

   Convenience buttons

These switches and buttons allow you to add keyframes for the selected
node's location, rotation, and scale respectively.

Deselect rotation, because we are only interested in the location of our
sprite for this tutorial and click on the key button.

As we don't have a track already set up for the transform/location
property, Godot asks whether it should set it up for us. Click **Create**.

This creates a new track and our first keyframe at the beginning of
the timeline:

.. figure:: img/animation_track.png
   :alt: The sprite track

   The sprite track

The second keyframe
~~~~~~~~~~~~~~~~~~~

Now we need to set the destination where our sprite should be headed and
how much time it takes to get there.

Let's say, we want it to take 2 seconds to go to the other point. By
default the animation is set to last only 1 second, so change this in
the timeline controls in animation panel's lower panel to 2.

.. figure:: img/animation_set_length.png
   :alt: Animation length

   Animation length

Click on the timeline header near the 2-second mark and move the sprite
to the target destination on the right side.

Again, click the key button in the toolbar. This creates our second
keyframe.

Run the animation
~~~~~~~~~~~~~~~~~

Click on the "Play from beginning" (|Play from beginning|) button.

Yay! Our animation runs:

.. figure:: img/animation_simple.gif
   :alt: The animation

   The animation

Back and forth
~~~~~~~~~~~~~~

Godot has an additional feature here. Like said before,
Godot always calculates the frames between two keyframes. In a loop, the
first keyframe is also the last keyframe, if no keyframe is specified at
the end.

.. figure:: img/animation_loop.png
   :alt: Animation loop

   Animation loop

If you set the animation length to 4 seconds now, the animation moves
back and forth. You can change this behavior if you change the track's
loop mode. This is covered in the next chapter.

Track settings
~~~~~~~~~~~~~~

Each track has a settings panel at the end, where you can set the update
mode, the track interpolation, and the loop mode.

.. figure:: img/animation_track_settings.png
   :alt: Track settings

   Track settings

The update mode of a track tells Godot when to update the property
values. This can be:

-  **Continuous:** Update the property on each frame.
-  **Discrete:** Only update the property on keyframes.
-  **Trigger:** Only update the property on keyframes or triggers.
   Triggers are a type of keyframe used by the
   ``current_animation`` property of a :ref:`class_AnimationPlayer`,
   and Animation Playback tracks.
-  **Capture:** If the first keyframe's time is greater than ``0.0``, the
   current value of the property will be remembered and
   will be blended with the first animation key. For example, you
   could use the Capture mode to move a node that's located anywhere
   to a specific location.

.. figure:: img/animation_track_rate.png
   :alt: Track mode

   Track mode

In normal animations, you usually use "Continuous". The other types are
used to script complex animations.

The interpolation tells Godot how to calculate the frame values between
the keyframes. These interpolation modes are supported:

-  Nearest: Set the nearest keyframe value
-  Linear: Set the value based on a linear function calculation between
   the two keyframes
-  Cubic: Set the value based on a cubic function calculation between
   the two keyframes

.. figure:: img/animation_track_interpolation.png
   :alt: Track interpolation

   Track interpolation

Cubic interpolation leads to a more natural movement, where the
animation is slower at a keyframe and faster between keyframes. This is
usually used for character animation. Linear interpolation creates more
of a robotic movement.

Godot supports two loop modes, which affect the animation if it's set to
loop:

.. figure:: img/animation_track_loop_modes.png
   :alt: Loop modes

   Loop modes

-  Clamp loop interpolation: When this is selected, the animation stops
   after the last keyframe for this track. When the first keyframe is
   reached again, the animation will reset to its values.
-  Wrap loop interpolation: When this is selected, Godot calculates the
   animation after the last keyframe to reach the values of the first
   keyframe again.

Keyframes for other properties
------------------------------

Godot doesn't restrict you to only edit transform properties. Every
property can be used as a track where you can set keyframes.

If you select your sprite while the animation panel is visible, you get
a small keyframe button for all the sprite's properties. Click on
this button and Godot automatically adds a track and keyframe to the
current animation.

.. figure:: img/animation_properties_keyframe.png
   :alt: Keyframes for other properties

   Keyframes for other properties

Edit keyframes
--------------

For advanced use and to edit keyframes in detail, You can click on them
to bring up the keyframe editor in the inspector. You can use this to
directly edit its values.

.. figure:: img/animation_keyframe_editor_key.png
   :alt: Keyframe editor editing a key

   Keyframe editor editing a key

Additionally, you can also edit the easing value for this keyframe by
clicking and dragging the easing setting. This tells Godot, how to change
the property values when it reaches this keyframe.

You usually tweak your animations this way, when the movement doesn't
"look right".

Advanced: Call Method tracks
----------------------------

Godot's animation engine doesn't stop here. If you're already
comfortable with Godot's scripting language
:ref:`doc_gdscript` and :doc:`/classes/index` you
know that each node type is a class and has a bunch of callable
methods.

For example, the :ref:`class_AudioStreamPlayer` node type has a
method to play an audio stream.

Wouldn't it be great to use a method at a specific keyframe in an
animation? This is where "Call Method Tracks" come in handy. These tracks
reference a node again, this time without a reference to a property.
Instead, a keyframe holds the name and arguments of a method, that
Godot should call when it reaches this keyframe.

To demonstrate, we're going to use a call method track to play audio at a
specific keyframe. Normally to play audio you should use an audio track,
but for the sake of demonstrating methods we're going to do it this way.

Add a :ref:`class_AudioStreamPlayer` to the Scene Tree and setup a
stream using an audio file you put in your project.

Click on "Add track" (|Add track|) on the animation panel's track
controls.

Select "Add Call Method Track" from the list of possible track types.

.. figure:: img/animation_add_call_method_track.png
   :alt: Add Call Method Track

   Add Call Method Track

Select the :ref:`class_AudioStreamPlayer` node in the selection
window. Godot adds the track with the reference to the node.

.. figure:: img/animation_select_audiostreamplayer.png
   :alt: Select AudioStreamPlayer

   Select AudioStreamPlayer

Right click the timeline where Godot should play the sample and
click the "Insert Key" option. This will bring up a list of methods
that can be called for the AudioStreamPlayer node. Select the first
one.

.. image:: img/animation_method_options.png

When Godot reaches the keyframe, Godot calls the
:ref:`class_AudioStreamPlayer` node's "play" function and the stream
plays.

You can change its position by dragging it on the timeline, you can also
click on the keyframe and use the keyframe settings in the inspector.

.. image:: img/animation_call_method_keyframe.png

.. |Play from beginning| image:: img/animation_play_from_beginning.png
.. |Add Animation| image:: img/animation_add.png
.. |Add track| image:: img/animation_add_track.png

Using RESET tracks
------------------

You can set up a special *RESET* animation to contain the "default pose".
This is used to ensure that the default pose is restored when you save
the scene and open it again in the editor.

For existing tracks, you can add an animation called "RESET" (case-sensitive),
then add tracks for each property that you want to reset.
The only keyframe should be at time 0, and give it the desired default value
for each track.

If AnimationPlayer's **Reset On Save** property is set to ``true``,
the scene will be saved with the effects of the reset animation applied
(as if it had been seeked to time ``0.0``).
This only affects the saved file – the property tracks in the editor stay
where they were.

If you want to reset the tracks in the editor, select the AnimationPlayer node,
open the **Animation** bottom panel then choose **Apply Reset** in the
animation editor's **Animation** dropdown menu.

When adding tracks on new animations, the editor will ask you to automatically
create a RESET track when using the keyframe icon next to a property in the inspector.
This does not apply on tracks created with Godot versions prior to 3.4,
as the animation reset track feature was added in 3.4.


===================================================
/. ./tutorials/animation/cutout_animation.rst
===================================================

.. _doc_cutout_animation:

Cutout animation
================

What is it?
~~~~~~~~~~~

Traditionally, `cutout animation <https://en.wikipedia.org/wiki/Cutout_animation>`__
is a type of `stop motion animation <https://en.wikipedia.org/wiki/Stop_motion>`__
in which pieces of paper (or other thin material) are cut into special shapes
and arranged in two-dimensional representations of characters and objects.
Characters' bodies are usually made out of several pieces. The pieces are
arranged and photographed once for each frame of the film. The animator moves
and rotates the parts in small increments between each shot to create the
illusion of movement when the images are played back quickly in sequence.

Simulations of cutout animation can now be created using software as seen in
`South Park <https://en.wikipedia.org/wiki/South_Park>`__ and `Jake and the Never
Land Pirates <https://en.wikipedia.org/wiki/Jake_and_the_Never_Land_Pirates>`__.

In video games, this technique has also become popular. Examples of
this are `Paper Mario <https://en.wikipedia.org/wiki/Super_Paper_Mario>`__ or
`Rayman Origins <https://en.wikipedia.org/wiki/Rayman_Origins>`__ .

Cutout animation in Godot
~~~~~~~~~~~~~~~~~~~~~~~~~

Godot provides tools for working with cutout rigs, and is ideal for the workflow:

-  **The animation system is fully integrated with the engine**: This
   means animations can control much more than just motion of objects. Textures,
   sprite sizes, pivots, opacity, color modulation, and more, can all be animated
   and blended.
-  **Combine animation styles**: AnimatedSprite allows traditional cel animation
   to be used alongside cutout animation. In cel animation different animation
   frames use entirely different drawings rather than the same pieces positioned
   differently. In an otherwise cutout-based animation, cel animation can be used
   selectively for complex parts such as hands, feet, changing facial expressions,
   etc.
-  **Custom Shaped Elements**: Custom shapes can be created with
   :ref:`Polygon2D <class_Polygon2D>`
   allowing UV animation, deformations, etc.
-  **Particle Systems**: A cutout animation rig can be combined with particle
   systems. This can be useful for magic effects, jetpacks, etc.
-  **Custom Colliders**: Set colliders and influence areas in different
   parts of the skeletons, great for bosses and fighting games.
-  **Animation Tree**: Allows complex combinations and blending between
   several animations, the same way it works in 3D.

And much more!

Making of GBot
~~~~~~~~~~~~~~

For this tutorial, we will use as demo content the pieces of the
`GBot <https://www.youtube.com/watch?v=S13FrWuBMx4&list=UUckpus81gNin1aV8WSffRKw>`__
character, created by Andreas Esau.

.. image:: img/tuto_cutout_walk.gif

Get your assets: :download:`gbot_resources.zip <files/gbot_resources.zip>`.

Setting up the rig
~~~~~~~~~~~~~~~~~~

Create an empty Node2D as root of the scene, we will work under it:

.. image:: img/tuto_cutout1.png

The first node of the model is the hip.
Generally, both in 2D and 3D, the hip is the root of the skeleton. This
makes it easier to animate:

.. image:: img/tuto_cutout2.png

Next will be the torso. The torso needs to be a child of the hip, so
create a child sprite and load the torso texture, later accommodate it properly:

.. image:: img/tuto_cutout3.png

This looks good. Let's see if our hierarchy works as a skeleton by
rotating the torso. We can do this be pressing :kbd:`E` to enter rotate mode,
and dragging with the left mouse button. To exit rotate mode hit :kbd:`ESC`.

.. image:: img/tutovec_torso1.gif

The rotation pivot is wrong and needs to be adjusted.

This small cross in the middle of the :ref:`Sprite <class_Sprite>` is
the rotation pivot:

.. image:: img/tuto_cutout4.png

Adjusting the pivot
~~~~~~~~~~~~~~~~~~~

The pivot can be adjusted by changing the *offset* property in the
Sprite:

.. image:: img/tuto_cutout5.png

The pivot can also be adjusted *visually*. While hovering over the
desired pivot point,  press :kbd:`V` to move the pivot there for the
selected Sprite. There is also a tool in the tool bar that has a
similar function.

.. image:: img/tutovec_torso2.gif

Continue adding body pieces, starting with the
right arm. Make sure to put each sprite in its correct place in the hierarchy,
so its rotations and translations are relative to its parent:

.. image:: img/tuto_cutout6.png

With the left arm there's a problem. In 2D, child nodes appear in front of
their parents:

.. image:: img/tuto_cutout7.png

We want the left arm to appear *behind*
the hip and the torso. We could move the left arm nodes behind the hip (above
the hip node in the scene hierarchy), but then the left arm is no longer in its
proper place in the hierarchy. This means it wouldn't be affected by the movement
of the torso. We'll fix this problem with ``RemoteTransform2D`` nodes.

.. note:: You can also fix depth ordering problems by adjusting the Z property
   of any node inheriting from Node2D.

RemoteTransform2D node
~~~~~~~~~~~~~~~~~~~~~~

The :ref:`RemoteTransform2D <class_RemoteTransform2D>` node transforms nodes
somewhere else in the hierarchy. This node applies its own transform (including
any transformation it inherits from its parents) to the remote node it targets.

This allows us to correct the visibility order of our elements, independently of
the locations of those parts in the cutout hierarchy.

Create a ``RemoteTransform2D`` node as a child of the torso. Call it ``remote_arm_l``.
Create another RemoteTransform2D node inside the first and call it ``remote_hand_l``.
Use the ``Remote Path`` property of the two new nodes to target the ``arm_l`` and
``hand_l`` sprites respectively:

.. image:: img/tuto_cutout9.png

Moving the ``RemoteTransform2D`` nodes now moves the sprites. So we can create
animations by adjusting the ``RemoteTransform2D`` transforms:

.. image:: img/tutovec_torso4.gif

Completing the skeleton
~~~~~~~~~~~~~~~~~~~~~~~

Complete the skeleton by following the same steps for the rest of the
parts. The resulting scene should look similar to this:

.. image:: img/tuto_cutout10.png

The resulting rig will be easy to animate. By selecting the nodes and
rotating them you can animate forward kinematics (FK) efficiently.

For simple objects and rigs this is fine, but there are limitations:

-  Selecting sprites in the main viewport can become difficult in complex rigs.
   The scene tree ends up being used to select parts instead, which can be slower.
-  Inverse Kinematics (IK) is useful for animating extremities like hands and
   feet, and can't be used with our rig in its current state.

To solve these problems we'll use Godot's skeletons.

Skeletons
~~~~~~~~~

In Godot there is a helper to create "bones" between nodes. The bone-linked
nodes are called skeletons.

As an example, let's turn the right arm into a skeleton. To create
a skeleton, a chain of nodes must be selected from top to bottom:

.. image:: img/tuto_cutout11.png

Then, click on the Skeleton menu and select ``Make Bones``.

.. image:: img/tuto_cutout12.png

This will add bones covering the arm, but the result may be surprising.

.. image:: img/tuto_cutout13.png

Why does the hand lack a bone? In Godot, a bone connects a
node with its parent. And there's currently no child of the hand node.
With this knowledge let's try again.

The first step is creating an endpoint node. Any kind of node will do,
but :ref:`Position2D <class_Position2D>` is preferred because it's
visible in the editor. The endpoint node will ensure that the last bone
has orientation.

.. image:: img/tuto_cutout14.png

Now select the whole chain, from the endpoint to the arm and create
bones:

.. image:: img/tuto_cutout15.png

The result resembles a skeleton a lot more, and now the arm and forearm
can be selected and animated.

Create endpoints for all important extremities. Generate bones for all
articulable parts of the cutout, with the hip as the ultimate connection
between all of them.

You may notice that an extra bone is created when connecting the hip and torso.
Godot has connected the hip node to the scene root with a bone, and we don't
want that. To fix this, select the root and hip node, open the Skeleton menu,
click ``clear bones``.

.. image:: img/tuto_cutout15_2.png

Your final skeleton should look something like this:

.. image:: img/tuto_cutout16.png

You might have noticed a second set of endpoints in the hands. This will make
sense soon.

Now that the whole figure is rigged, the next step is setting up the IK
chains. IK chains allow for more natural control of extremities.

IK chains
~~~~~~~~~

IK stands for inverse kinematics. It's a convenient technique for animating the
position of hands, feet and other extremities of rigs like the one we've made.
Imagine you want to pose a character's foot in a specific position on the ground.
Without IK chains, each motion of the foot would require rotating and positioning
several other bones (the shin and the thigh at least). This would be quite
complex and lead to imprecise results.

IK allows us to move directly the foot while the shin and thigh self-adjust.

To create an IK chain, select a chain of bones from endpoint to
the base for the chain. For example, to create an IK chain for the right
leg, select the following:

.. image:: img/tuto_cutout17.png

Then enable this chain for IK. Go to Edit > Make IK Chain.

.. image:: img/tuto_cutout18.png

As a result, the base of the chain will turn *Yellow*.

.. image:: img/tuto_cutout19.png

Once the IK chain is set-up grab any child or grand-child of the base of the
chain (e.g. a foot) and move it. You'll see the rest of the chain adjust as you
adjust its position.

.. image:: img/tutovec_torso5.gif

Animation tips
~~~~~~~~~~~~~~

The following section will be a collection of tips for creating animation for
your cutout rigs. For more information on how the animation system in Godot
works, see :ref:`doc_introduction_animation`.

Setting keyframes and excluding properties
------------------------------------------

Special contextual elements appear in the top toolbar when the animation editor
window is open:

.. image:: img/tuto_cutout20.png

The key button inserts location, rotation, and scale keyframes for the
selected objects or bones at the current playhead position.

The "loc", "rot", and "scl" toggle buttons to the left of the key button modify
its function, allowing you to specify which of the three properties keyframes
will be created for.

Here's an illustration of how this can be useful: Imagine you have a node which
already has two keyframes animating its scale only. You want to add an
overlapping rotation movement to the same node. The rotation movement should
begin and end at different times from the scale change that's already set up.
You can use the toggle buttons to have only rotation information added when you
add a new keyframe. This way, you can avoid adding unwanted scale keyframes
which would disrupt the existing scale animation.

Creating a rest pose
~~~~~~~~~~~~~~~~~~~~

Think of a rest pose as a default pose that your cutout rig should be set to
when no other pose is active in your game. Create a rest pose as follows:

1. Make sure the rig parts are positioned in what looks like a "resting"
arrangement.

2. Create a new animation, rename it "rest".

3. Select all nodes in your rig (box selection should work fine).

4. Make sure the "loc", "rot", and "scl" toggle buttons are all active in the
toolbar.

5. Press the key button. Keys will be inserted for all selected parts storing
their current arrangement. This pose can now be recalled when necessary in
your game by playing the "rest" animation you've created.

.. image:: img/tuto_cutout21.png

Modifying rotation only
~~~~~~~~~~~~~~~~~~~~~~~

When animating a cutout rig, often it's only the rotation of the nodes that
needs to change.
Location and scale are rarely used.

So when inserting keys, you might find it convenient to have only the "rot"
toggle active most of the time:

.. image:: img/tuto_cutout22.png

This will avoid the creation of unwanted animation tracks for position
and scale.

Keyframing IK chains
~~~~~~~~~~~~~~~~~~~~

When editing IK chains, it's not necessary to select the whole chain to
add keyframes. Selecting the endpoint of the chain and inserting a
keyframe will automatically insert keyframes for all other parts of the chain too.

Visually move a sprite behind its parent
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes it is necessary to have a node change its visual depth relative to
its parent node during an animation. Think of a character facing the camera,
who pulls something out from behind his back and holds it out in front of him.
During this animation the whole arm and the object in his hand would need to
change their visual depth relative to the body of the character.

To help with this there's a keyframable "Behind Parent" property on all
Node2D-inheriting nodes. When planning your rig, think about the movements it
will need to perform and give some thought to how you'll use "Behind Parent"
and/or RemoteTransform2D nodes. They provide overlapping functionality.

.. image:: img/tuto_cutout23.png

Setting easing curves for multiple keys
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To apply the same easing curve to multiple keyframes at once:

1. Select the relevant keys.
2. Click on the pencil icon in the bottom right of the animation panel. This
   will open the transition editor.
3. In the transition editor, click on the desired curve to apply it.

.. image:: img/tuto_cutout24.png

2D Skeletal deform
~~~~~~~~~~~~~~~~~~

Skeletal deform can be used to augment a cutout rig, allowing single pieces to
deform organically (e.g. antennae that wobble as an insect character walks).

This process is described in a :ref:`separate tutorial <doc_2d_skeletons>`.


===================================================
/. ./tutorials/animation/2d_skeletons.rst
===================================================

.. _doc_2d_skeletons:

2D skeletons
============

Introduction
------------

When working with 3D, skeletal deforms are common for characters and creatures
and most 3D modelling applications support it. For 2D, as this function is not
used as often, it's difficult to find mainstream software aimed for this.

One option is to create animations in third-party software such as Spine or
Dragonbones. From Godot 3.1 onwards, though, this functionality is supported
built-in.

Why would you want to do skeletal animations directly in Godot? The answer is
that there are many advantages to it:

* Better integration with the engine, so less hassle importing and editing from
  an external tool.
* Ability to control particle systems, shaders, sounds, call scripts, colors,
  transparency, etc. in animations.
* The built-in skeletal system in Godot is very efficient and designed for
  performance.

The following tutorial will, then, explain 2D skeletal deformations.

Setup
-----

.. seealso::

   Before starting, we recommend you to go through the
   :ref:`doc_cutout_animation` tutorial to gain a general understanding of
   animating within Godot.

For this tutorial, we will be using a single image to construct our character.
Download it from :download:`gBot_pieces.png <img/gBot_pieces.png>` or save the
image below.

.. image:: img/gBot_pieces.png

It is also advised to download the final character image
:download:`gBot_complete.png <img/gBot_complete.png>` to have a good reference
for putting the different pieces together.

.. image:: img/gBot_complete.png

Creating the polygons
---------------------

Create a new scene for your model (if it's going to be an animated character,
you may want to use a ``KinematicBody2D``). For ease of use, an empty 2D node is
created as a root for the polygons.

Begin with a ``Polygon2D`` node. There is no need to place it anywhere in the
scene for now, so simply create it like this:

.. image:: img/skel2d1.png

Select it and assign the texture with the character pieces you have downloaded
before:

.. image:: img/skel2d2.png

Drawing a polygon directly is not advised. Instead, open the "UV" dialog for the
polygon:

.. image:: img/skel2d3.png

Head over to the *Points* mode, select the pencil and draw a polygon around the
desired piece:

.. image:: img/skel2d4.png

Duplicate the polygon node and give it a proper name. Then, enter the "UV"
dialog again and replace the old polygon with another one in the new desired
piece.

When you duplicate nodes and the next piece has a similar shape, you can edit
the previous polygon instead of drawing a new one.

After moving the polygon, remember to update the UV by selecting Edit -> "Polygon
-> UV" in the Polygon 2D UV Editor.

.. image:: img/skel2d5.png

Keep doing this until you mapped all pieces.

.. image:: img/skel2d6.png

You will notice that pieces for nodes appear in the same layout as they do in
the original texture. This is because by default, when you draw a polygon, the
UV and points are the same.

Rearrange the pieces and build the character. This should be pretty quick. There
is no need to change pivots, so don't bother making sure rotation pivots for
each piece are right; you can leave them be for now.

.. image:: img/skel2d7.png

Ah, the visual order of the pieces is not correct yet, as some are covering
wrong pieces. Rearrange the order of the nodes to fix this:

.. image:: img/skel2d8.png

And there you go! It was definitely much easier than in the cutout tutorial.

Creating the skeleton
---------------------

Create a ``Skeleton2D`` node as a child of the root node. This will be the base
of our skeleton:

.. image:: img/skel2d9.png

Create a ``Bone2D`` node as a child of the skeleton. Put it on the hip (usually
skeletons start here). The bone will be pointing to the right, but you can
ignore this for now.

.. image:: img/skel2d10.png

Keep creating bones in hierarchy and naming them accordingly.

.. image:: img/skel2d11.png

At the end of this chain, there will be a *jaw* node. It is, again, very short
and pointing to the right. This is normal for bones without children. The length
of *tip* bones can be changed with a property in the inspector:

.. image:: img/skel2d12.png

In this case, we don't need to rotate the bone (coincidentally the jaw points
right in the sprite), but in case you need to, feel free to do it. Again, this
is only really needed for tip bones as nodes with children don't usually need a
length or a specific rotation.

Keep going and build the whole skeleton:

.. image:: img/skel2d13.png

You will notice that all bones raise an annoying warning about a missing rest
pose. This means that it's time to set one. Go to the *skeleton* node and create
a rest pose. This pose is the default one, you can come back to it anytime you
want (which is very handy for animating):

.. image:: img/skel2d14.png

The warnings will go away. If you modify the skeleton (add/remove bones) you
will need to set the rest pose again.

Deforming the polygons
----------------------

Select the previously created polygons and assign the skeleton node to their
``Skeleton`` property. This will ensure that they can eventually be deformed by
it.

.. image:: img/skel2d15.png

Click the property highlighted above and select the skeleton node:

.. image:: img/skel2d16.png

Again, open the UV editor for the polygon and go to the *Bones* section.

.. image:: img/skel2d17.png

You will not be able to paint weights yet. For this you need to synchronize the
list of bones from the skeleton with the polygon. This step is done only once
and manually (unless you modify the skeleton by adding/removing/renaming bones).
It ensures that your rigging information is kept in the polygon, even if a
skeleton node is accidentally lost or the skeleton modified. Push the "Sync
Bones to Polygon" button to sync the list.

.. image:: img/skel2d18.png

The list of bones will automatically appear. By default, your polygon has no
weight assigned to any of them. Select the bones you want to assign weight to
and paint them:

.. image:: img/skel2d19.png

Points in white have a full weight assigned, while points in black are not
influenced by the bone. If the same point is painted white for multiple bones,
the influence will be distributed amongst them (so usually there is not that
much need to use shades in-between unless you want to polish the bending
effect).

.. image:: img/skel2d20.gif

After painting the weights, animating the bones (NOT the polygons!) will have
the desired effect of modifying and bending the polygons accordingly. As you
only need to animate bones in this approach, work becomes much easier!

But it's not all roses. Trying to animate bones that bend the polygon will often
yield unexpected results:

.. image:: img/skel2d21.gif

This happens because Godot generates internal triangles that connect the points
when drawing the polygon. They don't always bend the way you would expect. To
solve this, you need to set hints in the geometry to clarify how you expect it
to deform.

Internal vertices
-----------------

Open the UV menu for each bone again and go to the *Points* section. Add some
internal vertices in the regions where you expect the geometry to bend:

.. image:: img/skel2d22.png

Now, go to the *Polygon* section and redraw your own polygons with more detail.
Imagine that, as your polygons bend, you need to make sure they deform the least
possible, so experiment a bit to find the right setup.

.. image:: img/skel2d23.png

Once you start drawing, the original polygon will disappear and you will be free
to create your own:

.. image:: img/skel2d24.png

This amount of detail is usually fine, though you may want to have more
fine-grained control over where triangles go. Experiment by yourself until you
get the results you like.

**Note:** Don't forget that your newly added internal vertices also need weight
painting! Go to the *Bones* section again to assign them to the right bones.

Once you are all set, you will get much better results:

.. image:: img/skel2d25.gif


===================================================
/. ./tutorials/animation/animation_tree.rst
===================================================

.. _doc_animation_tree:

Using AnimationTree
===================

Introduction
------------

With :ref:`AnimationPlayer <class_AnimationPlayer>`, Godot has one of the most flexible animation systems that you can find in any game engine.
The ability to animate almost any property in any node or resource, as well as having dedicated transform, bezier,
function calling, audio and sub-animation tracks, is pretty much unique.

However, the support for blending those animations via ``AnimationPlayer`` is relatively limited, as only a fixed cross-fade transition time can be set.

:ref:`AnimationTree <class_AnimationTree>` is a new node introduced in Godot 3.1 to deal with advanced transitions.
It supersedes the ancient ``AnimationTreePlayer``, while adding a huge amount of features and flexibility.

Creating an AnimationTree
-------------------------

Before starting, it must be made clear that an ``AnimationTree`` node does not contain its own animations.
Instead, it uses animations contained in an ``AnimationPlayer`` node. This way, you can edit your animations (or import them from a 3D scene)
as usual and then use this extra node to control the playback.

The most common way to use ``AnimationTree`` is in a 3D scene. When importing your scenes from a 3D exchange format, they will usually come
with animations built-in (either multiple ones or split from a large one on import).
At the end, the imported Godot scene will contain the animations in a ``AnimationPlayer`` node.

As you rarely use imported scenes directly in Godot (they are either instantiated or inherited from), you can place the ``AnimationTree`` node in your
new scene which contains the imported one. Afterwards, point the ``AnimationTree`` node to the ``AnimationPlayer`` that was created in the imported scene.

This is how it's done in the `Third Person Shooter demo <https://github.com/godotengine/tps-demo>`_, for reference:

.. image:: img/animtree1.png

A new scene was created for the player with a ``KinematicBody`` as root. Inside this scene, the original ``.dae`` (Collada) file was instantiated
and an ``AnimationTree`` node was created.

Creating a tree
---------------

There are three main types of nodes that can be used in ``AnimationTree``:

1. Animation nodes, which reference an animation from the linked ``AnimationTree``.
2. Animation Root nodes, which are used to blend sub-nodes.
3. Animation Blend nodes, which are used within ``AnimationNodeBlendTree`` as single-graph blending via multiple input ports.

To set a root node in ``AnimationTree``, a few types are available:

.. image:: img/animtree2.png

* ``AnimationNodeAnimation``: Selects an animation from the list and plays it. This is the simplest root node, and generally not used directly as root.
* ``AnimationNodeBlendTree``: Contains many *blend* type nodes, such as mix, blend2, blend3, one shot, etc. This is one of the most commonly used roots.
* ``AnimationNodeStateMachine``: Contains multiple root nodes as children in a graph. Each node is used as a *state*, and provides multiple functions to alternate between states.
* ``AnimationNodeBlendSpace2D``: Allows placing root nodes in a 2D blend space. Control the blend position in 2D to mix between multiple animations.
* ``AnimationNodeBlendSpace1D``: Simplified version of the above (1D).

Blend tree
----------

An ``AnimationNodeBlendTree`` can contain both root and regular nodes used for blending. Nodes are added to the graph from a menu:

.. image:: img/animtree3.png

All blend trees contain an ``Output`` node by default, and something has to be connected to it in order for animations to play.

The easiest way to test this functionality is to connect an ``Animation`` node to it directly:

.. image:: img/animtree4.png

This will simply play back the animation. Make sure that the ``AnimationTree`` is active for something to actually happen.

Following is a short description of available nodes:

Blend2 / Blend3
^^^^^^^^^^^^^^^

These nodes will blend between two or three inputs by a user-specified blend value:

.. image:: img/animtree5.gif

For more complex blending, it is advised to use blend spaces instead.

Blending can also use filters, i.e. you can control individually which tracks go through the blend function.
This is very useful for layering animations on top of each other.

.. image:: img/animtree6.png

OneShot
^^^^^^^

This node will execute a sub-animation and return once it finishes. Blend times for fading in and out can be customized, as well as filters.

.. image:: img/animtree6b.gif

Seek
^^^^

This node can be used to cause a seek command to happen to any sub-children of the animation graph. Use this node type to play an ``Animation`` from the start or a certain playback position inside the ``AnimationNodeBlendTree``.

After setting the time and changing the animation playback, the seek node automatically goes into sleep mode on the next process frame by setting its ``seek_position`` value to ``-1.0``.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Play child animation from the start.
    anim_tree.set("parameters/Seek/seek_position", 0.0)
    # Alternative syntax (same result as above).
    anim_tree["parameters/Seek/seek_position"] = 0.0

    # Play child animation from 12 second timestamp.
    anim_tree.set("parameters/Seek/seek_position", 12.0)
    # Alternative syntax (same result as above).
    anim_tree["parameters/Seek/seek_position"] = 12.0

 .. code-tab:: csharp

    // Play child animation from the start.
    animTree.Set("parameters/Seek/seek_position", 0.0);

    // Play child animation from 12 second timestamp.
    animTree.Set("parameters/Seek/seek_position", 12.0);

TimeScale
^^^^^^^^^

Allows scaling the speed of the animation (or reverse it) in any children nodes. Setting it to 0 will pause the animation.

Transition
^^^^^^^^^^

Very simple state machine (when you don't want to cope with a ``StateMachine`` node). Animations can be connected to the outputs and transition times can be specified.

BlendSpace2D
^^^^^^^^^^^^

``BlendSpace2D`` is a node to do advanced blending in two dimensions. Points are added to a two-dimensional space and then a position
can be controlled to determine blending:

.. image:: img/animtree7.gif

The ranges in X and Y can be controlled (and labeled for convenience). By default, points can be placed anywhere (just right-click on
the coordinate system or use the *add point* button) and triangles will be generated automatically using Delaunay.

.. image:: img/animtree8.gif

It is also possible to draw the triangles manually by disabling the *auto triangle* option, though this is rarely necessary:

.. image:: img/animtree9.png

Finally, it is possible to change the blend mode. By default, blending happens by interpolating points inside the closest triangle.
When dealing with 2D animations (frame by frame), you may want to switch to *Discrete* mode.
Alternatively, if you want to keep the current play position when switching between discrete animations, there is a *Carry* mode.
This mode can be changed in the *Blend* menu:

.. image:: img/animtree10.png

BlendSpace1D
^^^^^^^^^^^^

This is similar to 2D blend spaces, but in one dimension (so triangles are not needed).

StateMachine
^^^^^^^^^^^^

This node acts as a state machine with root nodes as states. Root nodes can be created and connected via lines. States are connected via *Transitions*,
which are connections with special properties. Transitions are uni-directional, but two can be used to connect in both directions.

.. image:: img/animtree11.gif

There are many types of transition:

.. image:: img/animtree12.png

* *Immediate*: Will switch to the next state immediately. The current state will end and blend into the beginning of the new one.
* *Sync*: Will switch to the next state immediately, but will seek the new state to the playback position of the old state.
* *At End*: Will wait for the current state playback to end, then switch to the beginning of the next state animation.

Transitions also have a few properties. Click any transition and it will be displayed in the inspector dock:

.. image:: img/animtree13.png

* *Switch Mode* is the transition type (see above), it can be modified after creation here.
* *Auto Advance* will turn on the transition automatically when this state is reached. This works best with the *At End* switch mode.
* *Advance Condition* will turn on auto advance when this condition is set. This is a custom text field that can be filled with a variable name.
  The variable can be modified from code (more on this later).
* *Xfade Time* is the time to cross-fade between this state and the next.
* *Priority* is used together with the ``travel()`` function from code (more on this later). Lower priority transitions are preferred when travelling through the tree.
* *Disabled* toggles disabling this transition (when disabled, it will not be used during travel or auto advance).


Root motion
-----------

When working with 3D animations, a popular technique is for animators to use the root skeleton bone to give motion to the rest of the skeleton.
This allows animating characters in a way where steps actually match the floor below. It also allows precise interaction with objects during cinematics.

When playing back the animation in Godot, it is possible to select this bone as the *root motion track*. Doing so will cancel the bone
transformation visually (the animation will stay in place).

.. image:: img/animtree14.png

Afterwards, the actual motion can be retrieved via the :ref:`AnimationTree <class_AnimationTree>` API as a transform:

.. tabs::
 .. code-tab:: gdscript GDScript

    anim_tree.get_root_motion_transform()

 .. code-tab:: csharp

    animTree.GetRootMotionTransform();

This can be fed to functions such as :ref:`KinematicBody.move_and_slide <class_KinematicBody_method_move_and_slide>` to control the character movement.

There is also a tool node, ``RootMotionView``, that can be placed in a scene and will act as a custom floor for your
character and animations (this node is disabled by default during the game).

.. image:: img/animtree15.gif


Controlling from code
---------------------

After building the tree and previewing it, the only question remaining is "How is all this controlled from code?".

Keep in mind that the animation nodes are just resources and, as such, they are shared between all instances using them.
Setting values in the nodes directly will affect all instances of the scene that uses this ``AnimationTree``.
This is generally undesirable, but does have some cool use cases, e.g. you can copy and paste parts of your animation tree,
or reuse nodes with a complex layout (such as a state machine or blend space) in different animation trees.

The actual animation data is contained in the ``AnimationTree`` node and is accessed via properties.
Check the "Parameters" section of the ``AnimationTree`` node to see all the parameters that can be modified in real-time:

.. image:: img/animtree16.png

This is handy because it makes it possible to animate them from an ``AnimationPlayer``, or even the ``AnimationTree`` itself,
allowing the realization of very complex animation logic.

To modify these values from code, the property path must be obtained. This is done easily by hovering the mouse over any of the parameters:

.. image:: img/animtree17.png

Which allows setting them or reading them:

.. tabs::
 .. code-tab:: gdscript GDScript

    anim_tree.set("parameters/eye_blend/blend_amount", 1.0)
    # Simpler alternative form:
    anim_tree["parameters/eye_blend/blend_amount"] = 1.0

 .. code-tab:: csharp

    animTree.Set("parameters/eye_blend/blend_amount", 1.0);


State machine travel
--------------------

One of the nice features in Godot's ``StateMachine`` implementation is the ability to travel. The graph can be instructed to go from the
current state to another one, while visiting all the intermediate ones. This is done via the A\* algorithm.
In the absence of any viable set of transitions starting at the current state and finishing at the destination state, the graph teleports
to the destination state.

To use the travel ability, you should first retrieve the :ref:`AnimationNodeStateMachinePlayback <class_AnimationNodeStateMachinePlayback>`
object from the ``AnimationTree`` node (it is exported as a property).


.. tabs::
 .. code-tab:: gdscript GDScript

    var state_machine = anim_tree["parameters/playback"]

 .. code-tab:: csharp

    AnimationNodeStateMachinePlayback stateMachine = (AnimationNodeStateMachinePlayback)animTree.Get("parameters/playback");

Once retrieved, it can be used by calling one of the many functions it offers:

.. tabs::
 .. code-tab:: gdscript GDScript

    state_machine.travel("SomeState")

 .. code-tab:: csharp

    stateMachine.Travel("SomeState");

The state machine must be running before you can travel. Make sure to either call ``start()`` or choose a node to **Autoplay on Load**.

.. image:: img/animtree18.png


===================================================
/. ./tutorials/animation/playing_videos.rst
===================================================

.. _doc_playing_videos:

Playing videos
==============

Godot supports video playback with the :ref:`class_VideoPlayer` node.

Supported playback formats
--------------------------

The only supported format in core is **Ogg Theora** (not to be confused with Ogg
Vorbis audio). It's possible for extensions to bring support for additional
formats, but no such extensions exist yet as of July 2022.

H.264 and H.265 cannot be supported in core Godot, as they are both encumbered
by software patents. AV1 is royalty-free, but it remains slow to decode on the
CPU and hardware decoding support isn't readily available on all GPUs in use
yet.

WebM is supported in core in Godot 3.x, but support for it will be removed in 4.0
as it proved to be too buggy and difficult to maintain.
Therefore, **using WebM is not recommended**.

.. note::

    You may find videos with an ``.ogg`` or ``.ogx`` extensions, which are generic
    extensions for data within an Ogg container.

    Renaming these file extensions to ``.ogv`` *may* allow the videos to be
    imported in Godot. However, not all files with ``.ogg`` or ``.ogx``
    extensions are videos - some of them may only contain audio.

Setting up VideoPlayer
----------------------------

1. Create a VideoPlayer node using the Create New Node dialog.
2. Select the VideoPlayer node in the scene tree dock, go to the inspector
   and load an ``.ogv`` file in the Stream property.

   - If you don't have your video in Ogg Theora format yet, jump to
     :ref:`doc_playing_videos_recommended_theora_encoding_settings`.

3. If you want the video to play as soon as the scene is loaded, check
   **Autoplay** in the inspector. If not, leave **Autoplay** disabled and call
   ``play()`` on the VideoPlayer node in a script to start playback when
   desired.

Handling resizing and different aspect ratios
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

By default in Godot 4.0, the VideoPlayer will automatically be resized to match
the video's resolution. You can make it follow usual :ref:`class_Control` sizing
by enabling **Expand** on the VideoPlayer node.

To adjust how the VideoPlayer node resizes depending on window size,
adjust the anchors using the **Layout** menu at the top of the 2D editor
viewport. However, this setup may not be powerful enough to handle all use
cases, such as playing fullscreen videos without distorting the video (but with
empty space on the edges instead). For more control, you can use an
:ref:`class_AspectRatioContainer` node, which is designed to handle this kind of
use case:

Add an AspectRatioContainer node. Make sure it is not a child of any other
container node. Select the AspectRatioContainer node, then set its **Layout** at
the top of the 2D editor to **Full Rect**. Set **Ratio** in the
AspectRatioContainer node to match your video's aspect ratio. You can use math
formulas in the inspector to help yourself. Remember to make one of the operands
a float. Otherwise, the division's result will always be an integer.

.. figure:: img/playing_videos_aspect_ratio_container.png
   :figclass: figure-w480
   :align: center
   :alt: AspectRatioContainer's Ratio property being modified in the editor inspector

   This will evaluate to (approximately) 1.777778

Once you've configured the AspectRatioContainer, reparent your VideoPlayer
node to be a child of the AspectRatioContainer node. Make sure **Expand** is
disabled on the VideoPlayer. Your video should now scale automatically
to fit the whole screen while avoiding distortion.

.. seealso::

    See :ref:`doc_multiple_resolutions` for more tips on supporting multiple
    aspect ratios in your project.

Displaying a video on a 3D surface
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Using a VideoPlayer node as a child of a :ref:`class_Viewport` node,
it's possible to display any 2D node on a 3D surface. For example, this can be
used to display animated billboards when frame-by-frame animation would require
too much memory.

This can be done with the following steps:

1. Create a :ref:`class_Viewport` node. Set its size to match your video's size
   in pixels.
2. Create a VideoPlayer node *as a child of the Viewport node* and specify
   a video path in it. Make sure **Expand** is disabled, and enable **Autoplay** if needed.
3. Create a MeshInstance node with a PlaneMesh or QuadMesh resource in its Mesh property.
   Resize the mesh to match the video's aspect ratio (otherwise, it will appear distorted).
4. Create a new SpatialMaterial resource in the **Material Override** property
   in the GeometryInstance section.
5. Enable **Local To Scene** in the SpatialMaterial's Resource section (at the bottom).
   This is *required* before you can use a ViewportTexture in its Albedo Texture property.
6. In the SpatialMaterial, set the **Albedo > Texture** property to **New ViewportTexture**.
   Edit the new resource by clicking it, then specify the path to the Viewport node
   in the **Viewport Path** property.
7. Enable **Albedo Tex Force sRGB** in the SpatialMaterial to prevent colors
   from being washed out.
8. If the billboard is supposed to emit its own light, enable
   **Flags > Unshaded** to improve rendering performance.

See :ref:`doc_viewports` and the
`GUI in 3D demo <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`__
for more information on setting this up.

Video decoding conditions and recommended resolutions
-----------------------------------------------------

Video decoding is performed on the CPU, as GPUs don't have hardware acceleration
for decoding Theora videos. Modern desktop CPUs can decode Ogg Theora videos at
1440p @ 60 FPS or more, but low-end mobile CPUs will likely struggle with
high-resolution videos.

To ensure your videos decode smoothly on varied hardware:

- When developing games for desktop platforms, it's recommended to encode in
  1080p at most (preferably at 30 FPS). Most people are still using 1080p or
  lower resolution displays, so encoding higher-resolution videos may not be
  worth the increased file size and CPU requirements.
- When developing games for mobile or web platforms, it's recommended to encode
  in 720p at most (preferably at 30 FPS or even lower). The visual difference
  between 720p and 1080p videos on a mobile device is usually not that
  noticeable.

Playback limitations
--------------------

There are several limitations with the current implementation of video playback in Godot:

- Seeking a video to a certain point is not supported.
- Changing playback speed is not supported. VideoPlayer also won't follow
  :ref:`Engine.time_scale<class_Engine_property_time_scale>`.
- Looping is not supported, but you can connect a VideoPlayer's
  :ref:`finished <class_VideoPlayer_signal_finished>` signal to a function
  that plays the video again. However, this will cause a black frame to be
  visible when the video restarts. This can be worked around by adding a fade to
  black in the video file before the video ends, or by hiding the video for one
  frame and displaying a TextureRect with a screenshot of the first frame of the
  video until the video is restarted.
- Streaming a video from a URL is not supported.

.. _doc_playing_videos_recommended_theora_encoding_settings:

Recommended Theora encoding settings
------------------------------------

A word of advice is to **avoid relying on built-in Ogg Theora exporters** (most of the time).
There are 2 reasons you may want to favor using an external program to encode your video:

- Some programs such as Blender can render to Ogg Theora. However, the default
  quality presets are usually very low by today's standards. You may be able to
  increase the quality options in the software you're using, but you may find
  the output quality to remain less than ideal (given the increased file size).
  This usually means that the software only supports encoding to constant bit
  rate (CBR), instead of variable bit rate (VBR). VBR encoding should be
  preferred in most scenarios as it provides a better quality to file size
  ratio.
- Some other programs can't render to Ogg Theora at all.

In this case, you can **render the video to an intermediate high-quality format**
(such as a high-bitrate H.264 video) then re-encode it to Ogg Theora. Ideally,
you should use a lossless or uncompressed format as an intermediate format to
maximize the quality of the output Ogg Theora video, but this can require a lot
of disk space.

`HandBrake <https://handbrake.fr/>`__
(GUI) and `FFmpeg <https://ffmpeg.org/>`__ (CLI) are popular open source tools
for this purpose. FFmpeg has a steeper learning curve, but it's more powerful.

Here are example FFmpeg commands to convert a MP4 video to Ogg Theora. Since
FFmpeg supports a lot of input formats, you should be able to use the commands
below with almost any input video format (AVI, MOV, WebM, …).

.. note::

   Make sure your copy of FFmpeg is compiled with libtheora and libvorbis support.
   You can check this by running ``ffmpeg`` without any arguments, then looking
   at the ``configuration:`` line in the command output.

Balancing quality and file size
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The **video quality** level (``-q:v``) must be between ``1`` and ``10``. Quality
``6`` is a good compromise between quality and file size. If encoding at a high
resolution (such as 1440p or 4K), you will probably want to decrease ``-q:v`` to
``5`` to keep file sizes reasonable. Since pixel density is higher on a 1440p or
4K video, lower quality presets at higher resolutions will look as good or
better compared to low-resolution videos.

The **audio quality** level (``-q:a``) must be between ``-1`` and ``10``. Quality
``6`` provides a good compromise between quality and file size. In contrast to
video quality, increasing audio quality doesn't increase the output file size
nearly as much. Therefore, if you want the cleanest audio possible, you can
increase this to ``9`` to get *perceptually lossless* audio. This is especially
valuable if your input file already uses lossy audio compression. See
`this page <https://wiki.hydrogenaud.io/index.php?title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__
for a table listing Ogg Vorbis audio quality presets and their respective
variable bitrates.

FFmpeg: Convert while preserving original video resolution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following command converts the video while keeping its original resolution.
The video and audio's bitrate will be variable to maximize quality while saving
space in parts of the video/audio that don't require a high bitrate (such as
static scenes).

::

    ffmpeg -i input.mp4 -q:v 6 -q:a 6 output.ogv

FFmpeg: Resize the video then convert it
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following command resizes a video to be 720 pixels tall (720p), while
preserving its existing aspect ratio. This helps decrease the file size
significantly if the source is recorded at a higher resolution than 720p:

::

    ffmpeg -i input.mp4 -vf "scale=-1:720" -q:v 6 -q:a 6 output.ogv


===================================================
/. ./tutorials/assets_pipeline/index.rst
===================================================

Assets pipeline
===============

.. toctree::
   :maxdepth: 1
   :name: toc-learn-workflow-assets

   import_process
   importing_images
   importing_audio_samples
   importing_translations
   importing_scenes
   exporting_3d_scenes
   escn_exporter/index


===================================================
/. ./tutorials/assets_pipeline/import_process.rst
===================================================

.. _doc_import_process:

Import process
==============

Importing assets in Godot 3.0+
------------------------------

Previously, importing assets in Godot 2.x required manual maintenance
of a separate directory with source assets. Without doing this, it was
impossible to specify how to convert and change import flags for
textures, audio files, scenes, etc.

In Godot 3.0+, we use a more modern approach to importing: Simply drop
your assets (image files, scenes, audio files, fonts, etc) directly in the
project folder (copy them manually with your OS file explorer).
Godot will automatically import these files internally
and keep the imported resources hidden in a ``res://.import`` folder.

This means that when trying to access imported assets through code you
need to use the :ref:`Resource Loader<class_ResourceLoader>` as it will
automatically take into account where the internal files are saved. If you
try and access an imported asset using the :ref:`File <class_File>` class
it will work in the editor, but break in the exported project.

However, the :ref:`Resource Loader<class_ResourceLoader>` cannot access
non imported files, only the :ref:`File <class_File>` class can.

Changing import parameters
--------------------------

To change the import parameters of an asset in Godot (again, keep in mind
import parameters are only present in non-native Godot resource types)
select the relevant resource in the filesystem dock:

.. image:: img/asset_workflow1.png

Then, after adjusting the parameters, press "Reimport". These parameters
will only be used for this asset and on future reimports.

Changing the import parameters of several assets at the same time is also
possible. Simply select all of them together in the resources dock and the
exposed parameters will apply to all of them when reimporting.

Reimporting multiple assets
---------------------------

While working on a project you may find that several assets need to have
the same parameters changed, such as enabling mipmaps, but you only want
those specific parameters changed. To do this, select every asset you want
to reimport in the file system. In the import tab there will now be a
checkbox to the left of every import parameter.

.. image:: img/reimport_multiple.png

Select the checkbox of the parameters you want to change on your imported
assets, then change the parameters normally. Finally, click the reimport
button and every selected asset will be reimported with only those
parameters changed.

Automatic reimport
------------------

When the MD5 checksum of the source asset changes, Godot will perform an
automatic reimport of it, applying the preset configured for that specific
asset.

Files generated
-----------------

Importing will add an extra ``<asset>.import`` file, containing the import
configuration. Make sure to commit these to your version control system!

.. image:: img/asset_workflow4.png

Additionally, extra assets will be preset in the hidden ``res://.import`` folder:

.. image:: img/asset_workflow5.png

If any of the files present in this folder is erased (or the whole folder), the
asset or assets will be reimported automatically. As such, committing this folder
to the version control system is optional. It can shorten
reimporting time when checking out on another computer, but it takes considerably
more space and transfer time. Pick your poison!

Changing import resource type
-----------------------------

Some source assets can be imported as different types of resources.
For this, select the relevant type of resource desired and
press "Reimport":

.. image:: img/asset_workflow2.png


Changing default import parameters
-----------------------------------

Different types of games might require different defaults.
Changing the defaults per project can be achieved by using the
"Preset.." Menu. Besides some resource types offering presets,
the default setting can be saved and cleared too:

.. image:: img/asset_workflow3.png

Simplicity is key!
------------------

This is a very simple workflow which should take very little time to get used to. It also enforces a more
correct way to deal with resources.

There are many types of assets available for import, so please continue reading to understand how to work
with all of them!


===================================================
/. ./tutorials/assets_pipeline/importing_images.rst
===================================================

.. _doc_import_images:

Importing images
================

Supported image formats
-----------------------

Godot can import the following image formats:

- BMP (``.bmp``)
  - No support for 16-bit per pixel images. Only 1-bit, 4-bit, 8-bit, 24-bit, and 32-bit per pixel images are supported.
- DirectDraw Surface (``.dds``)
  - If mipmaps are present in the texture, they will be loaded directly.
  This can be used to achieve effects using custom mipmaps.
- OpenEXR (``.exr``)
  - Supports HDR (highly recommended for panorama skies).
- Radiance HDR (``.hdr``)
  - Supports HDR (highly recommended for panorama skies).
- JPEG (``.jpg``, ``.jpeg``)
  - Doesn't support transparency per the format's limitations.
- PNG (``.png``)
  - Precision is limited to 8 bits per channel upon importing (no HDR images).
- Truevision Targa (``.tga``)
- SVG (``.svg``, ``.svgz``)
  - SVGs are rasterized using `NanoSVG <https://github.com/memononen/nanosvg>`__
  when importing them. Support is limited; complex vectors may not render correctly.
  For complex vectors, rendering them to PNGs using Inkscape is often a better solution.
  This can be automated thanks to its `command-line interface <https://wiki.inkscape.org/wiki/index.php/Using_the_Command_Line#Export_files>`__.
- WebP (``.webp``)
  - WebP files support transparency and can be compressed lossily or losslessly.
  The precision is limited to 8 bits per channel.

.. note::

    If you've compiled the Godot editor from source with specific modules disabled,
    some formats may not be available.

Importing textures
------------------

The default action in Godot is to import images as textures. Textures are stored
in video memory and can't be accessed directly. This is what makes drawing them
efficient.

Import options are vast:

.. image:: img/image_import1.png

Detect 3D
~~~~~~~~~

This option makes Godot be aware of when a texture (which is imported for 2D as default) is used in 3D. If this happens, setting are changed so the texture flags
are friendlier to 3D (mipmaps, filter and repeat become enabled and compression is changed to VRAM). Texture is also reimported automatically.

Compression
-----------

Images are one of the largest assets in a game. To handle them efficiently, they need to be compressed.
Godot offers several compression methods, depending on the use case.

Compress Mode
~~~~~~~~~~~~~

- **VRAM Compression:** This is the most common compression mode for 3D assets.
  Size on disk is reduced and video memory usage is also decreased considerably
  (usually by a factor between 4 and 6). This mode should be avoided for 2D as it
  exhibits noticeable artifacts.
- **Lossless Compression:** This is the most common compression mode for 2D assets.
  It shows assets without any kind of artifacting, and disk compression is
  decent. It will use considerably more amount of video memory than
  VRAM Compression, though. This is also the recommended setting for pixel art.
- **Lossy Compression:** This is a good choice for large 2D assets. It has some
  artifacts, but less than VRAM and the file size is several times lower
  compared to Lossless or Uncompressed. Video memory usage isn't decreased by
  this mode; it's the same as with Lossless Compression or Uncompressed.
- **Uncompressed:** Only useful for formats that can't be compressed (such as
  raw float images).

In this table, each of the four options are described together with their
advantages and disadvantages (|good| = best, |bad| = worst):

+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+
|                | Uncompressed           | Compress Lossless             | Compress Lossy          | Compress VRAM                                        |
+================+========================+===============================+=========================+======================================================+
| Description    | Stored as raw pixels   | Stored as Lossless WebP / PNG | Stored as Lossy WebP    | Stored as S3TC/BC or PVRTC/ETC depending on platform |
+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+
| Size on Disk   | |bad| Large            | |regular| Small               | |good| Very Small       | |regular| Small                                      |
+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+
| Memory Usage   | |bad| Large            | |bad| Large                   | |bad| Large             | |good| Small                                         |
+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+
| Performance    | |regular| Normal       | |regular| Normal              | |regular| Normal        | |good| Fast                                          |
+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+
| Quality Loss   | |good| None            | |good| None                   | |regular| Slight        | |bad| Moderate                                       |
+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+
| Load Time      | |regular| Normal       | |bad| Slow                    | |bad| Slow              | |good| Fast                                          |
+----------------+------------------------+-------------------------------+-------------------------+------------------------------------------------------+

.. |bad| image:: img/bad.png

.. |good| image:: img/good.png

.. |regular| image:: img/regular.png

HDR Mode
~~~~~~~~

Godot supports high dynamic range textures (as .HDR or .EXR). These are mostly useful as high dynamic range equirectangular panorama skies (the internet
has plenty if you search for them), which replace Cubemaps in Godot 2.x. Modern PCs support the BC6H VRAM format, but there are still plenty that do not.

If you want Godot to ensure full compatibility in terms of the kind of textures, enable the "Force RGBE" option.

Normal Map
~~~~~~~~~~

When using a texture as normal map, only the red and green channels are required. Given regular texture compression algorithms produce artifacts that don't
look that nice in normal maps, the RGTC compression format is the best fit for this data. Forcing this option to "Enabled" will make Godot import the
image as RGTC compressed. By default, it's set to "Detect", which means that if the texture is ever used as a normal map, it will be changed to "Enabled" and
reimported automatically.

Note that RGTC compression affects the resulting normal map image. You will have to adjust custom shaders that use the normal map to take this into account.

.. note::

  Godot requires the normal map to use the X+, Y+ and Z+ coordinates, this is
  known as OpenGL style. If you've imported a material made to be used with
  another engine it may be DirectX style, in which case the normal map needs to
  be converted so its Y axis is flipped.

  More information about normal maps (including a coordinate order table for
  popular engines) can be found
  `here <http://wiki.polycount.com/wiki/Normal_Map_Technical_Details>`__.

Flags
-----

There are plenty of settings that can be toggled when importing an image as a texture, depending on the use case.

Repeat
~~~~~~

This setting is most commonly used in 3D, and is therefore generally disabled in 2D. It sets UV coordinates going beyond the 0,0 - 1,1 range to "loop".

Repeating can optionally be set to mirrored mode.

Filter
~~~~~~

When pixels become larger than the screen pixels, this option enables linear interpolation for them. The result is a smoother (less blocky) texture. This setting can be commonly used in 2D and 3D, but it's usually disabled when making pixel perfect games.

Mipmaps
~~~~~~~

When pixels become smaller than the screen, mipmaps kick in. This helps reduce the grainy effect when shrinking the textures. Keep in mind that, in older hardware
(GLES2, mainly mobile), there are some requirements to use mipmaps:

* Texture width and height must be powers of 2
* Repeat must be enabled

Keep in mind the above when making phone games and applications, want to aim for full compatibility, and need mipmaps.

When doing 3D, mipmap should be turned on, as this also improves performance (smaller versions of the texture are used for objects further away).

Anisotropic
~~~~~~~~~~~

When textures are near parallel to the view (like floors), this option makes them have more detail by reducing blurriness.

sRGB
~~~~

Godot uses Linear colorspace when rendering 3D. Textures mapped to albedo or detail channels need to have this option turned on in order for colors to look correct.
When set to **Detect** mode, the texture will be marked as sRGB when used in albedo channels.

.. warning::

    Since the texture will have its data modified when sRGB is enabled, this
    means using the same texture in both 2D and 3D will make the texture
    display with incorrect colors in either 2D or 3D.

    To work around this, make a copy of the texture on the filesystem and enable
    sRGB on one of the copies only. Use the copy with sRGB enabled in 3D, and
    the copy with sRGB disabled in 2D.

Process
-------

Some special processes can be applied to images when imported as textures.

Fix Alpha Border
~~~~~~~~~~~~~~~~

This puts pixels of the same surrounding color in transition from transparency to non transparency. It helps mitigate the outline effect when exporting images
from Photoshop and the like.

.. image:: img/fixedborder.png

It's a good idea to leave it on by default, unless specific values are needed.

Premultiplied Alpha
~~~~~~~~~~~~~~~~~~~

An alternative to fix darkened borders is to use premultiplied alpha. By enabling this option, the texture will be converted to this format.
Keep in mind that a material will need to be created that uses the PREMULT ALPHA blend mode on canvas items that need it.

HDR as sRGB
~~~~~~~~~~~

A few HDR files are broken and contain sRGB color data. It is advised not to use them, but, in the worst-case scenario, toggling this option on will make them look right.

Invert Color
~~~~~~~~~~~~

Reverses the image's color. This is useful, for example, to convert a height map generated by external programs to depth map to use with :ref:`doc_spatial_material`.

Svg
---

Scale
~~~~~

This option only applies to SVG files. It controls the scale of the SVG image. The default scale (1.0) will make the imported SVG match its original design scale.


===================================================
/. ./tutorials/assets_pipeline/importing_audio_samples.rst
===================================================

.. _doc_importing_audio_samples:

Importing audio samples
=======================

Supported files
---------------

Godot provides three options to import your audio data: WAV, Ogg Vorbis
and MP3.

Each has different advantages.

* WAV files use raw data or light compression (IMA-ADPCM). They are lightweight
  on the CPU to play back (hundreds of simultaneous voices in this format are
  fine). The downside is that they take up a lot of disk space.
* Ogg Vorbis files use a stronger compression that results in much
  smaller file size, but require significantly more processing power to
  play back.
* MP3 files use better compression than WAV with IMA-ADPCM, but worse than
  Ogg Vorbis. This means that a MP3 file with roughly equal quality to
  Ogg Vorbis will be significantly larger. On the bright side, MP3 requires
  less CPU usage to play back compared to Ogg Vorbis. This makes MP3 useful
  for mobile and HTML5 projects where CPU resources are limited, especially
  when playing multiple compressed sounds at the same time (such as long
  ambient sounds).

Here is a comparative chart.

+-----------------------------+-------------------+
| Format                      | 1 second of audio |
+=============================+===================+
| WAV 24-bit, 96 kHz, stereo  | 576 KB            |
+-----------------------------+-------------------+
| WAV 16-bit, 44 kHz, mono    | 88 KB             |
+-----------------------------+-------------------+
| WAV 16-bit, IMA-ADPCM, mono | 22 KB             |
+-----------------------------+-------------------+
| MP3 192 Kb/s, stereo        | 24 KB             |
+-----------------------------+-------------------+
| Ogg Vorbis 128 Kb/s, stereo | 16 KB             |
+-----------------------------+-------------------+
| Ogg Vorbis 96 Kb/s, stereo  | 12 KB             |
+-----------------------------+-------------------+

Consider using WAV for short and repetitive sound effects, and Ogg Vorbis
for music, speech, and long sound effects.

Best practices
--------------

Godot has an :ref:`extensive bus system <doc_audio_buses>` with built-in effects.
This saves SFX artists the need to add reverb to the sound effects,
reducing their size greatly and ensuring correct trimming. Say no to SFX
with baked reverb!

.. image:: img/reverb.png

As you can see above, sound effects become huge with reverb added.

Trimming
~~~~~~~~

One issue that happens often is that the waveform is exported with long
silences at the beginning and at the end. These are inserted by
DAWs when saving to a waveform, increase their size unnecessarily and
add latency to the moment they are played back.

Importing as WAV with the **Trimming** option enabled solves
this.

Looping
~~~~~~~

Godot supports looping in the samples (tools such as Sound Forge or
Audition can add loop points to WAV files). This is useful for sound
effects, such as engines, machine guns etc. Ping-pong looping is also
supported.

As an alternative, the Import dock has a **Loop** option that enables
looping for the entire sample when importing.


===================================================
/. ./tutorials/assets_pipeline/importing_translations.rst
===================================================

.. _doc_importing_translations:

Importing translations
======================

Games and internationalization
------------------------------

The world is full of different languages and cultures, so nowadays games
are released in several languages. To handle this, internationalized text
must be supported in any modern game engine.

In regular desktop or mobile applications, internationalized text is
usually located in resource files (or .po files for GNU stuff). Games,
however, can use several orders of magnitude more text than
applications, so they must support efficient methods for dealing with
loads of multilingual text.

There are two approaches to generate multilingual language games and
applications. Both are based on a key:value system. The first is to use
one of the languages as the key (usually English), the second is to use a
specific identifier. The first approach is probably easier for
development if a game is released first in English, later in other
languages, but a complete nightmare if working with many languages at
the same time.

In general, games use the second approach and a unique ID is used for
each string. This allows you to revise the text while it is being
translated to other languages. The unique ID can be a number, a string,
or a string with a number (it's just a unique string anyway).

.. note:: If you need a more powerful file format, Godot also supports
          loading translations written in the gettext ``.po`` format. See
          :ref:`doc_localization_using_gettext` for details.

Translation format
------------------

To complete the picture and allow efficient support for translations,
Godot has a special importer that can read CSV files. Most spreadsheet
editors can export to this format, so the only requirement is that the files
have a special arrangement. The CSV files **must** be saved with UTF-8 encoding
without a `byte order mark <https://en.wikipedia.org/wiki/Byte_order_mark>`__.

.. warning::

    By default, Microsoft Excel will always save CSV files with ANSI encoding
    rather than UTF-8. There is no built-in way to do this, but there are
    workarounds as described
    `here <https://stackoverflow.com/questions/4221176/excel-to-csv-with-utf8-encoding>`__.

    We recommend using `LibreOffice <https://www.libreoffice.org/>`__ or Google Sheets instead.

CSV files must be formatted as follows:

+--------+----------+----------+----------+
| keys   | <lang1>  | <lang2>  | <langN>  |
+========+==========+==========+==========+
| KEY1   | string   | string   | string   |
+--------+----------+----------+----------+
| KEY2   | string   | string   | string   |
+--------+----------+----------+----------+
| KEYN   | string   | string   | string   |
+--------+----------+----------+----------+

The "lang" tags must represent a language, which must be one of the :ref:`valid
locales <doc_locales>` supported by the engine. The "KEY" tags must be
unique and represent a string universally (they are usually in
uppercase, to differentiate from other strings). These keys will be replaced at
runtime by the matching translated string. Note that the case is important,
"KEY1" and "Key1" will be different keys.
The top-left cell is ignored and can be left empty or having any content.
Here's an example:

+-------+-----------------------+------------------------+------------------------------+
| keys  | en                    | es                     | ja                           |
+=======+=======================+========================+==============================+
| GREET | Hello, friend!        | Hola, amigo!           | こんにちは                   |
+-------+-----------------------+------------------------+------------------------------+
| ASK   | How are you?          | Cómo está?             | 元気ですか                   |
+-------+-----------------------+------------------------+------------------------------+
| BYE   | Goodbye               | Adiós                  | さようなら                   |
+-------+-----------------------+------------------------+------------------------------+
| QUOTE | "Hello" said the man. | "Hola" dijo el hombre. | 「こんにちは」男は言いました |
+-------+-----------------------+------------------------+------------------------------+

The same example is shown below as a comma-separated plain text file,
which should be the result of editing the above in a spreadsheet.
When editing the plain text version, be sure to enclose with double
quotes any message that contains commas, line breaks or double quotes,
so that commas are not parsed as delimiters, line breaks don't create new
entries and double quotes are not parsed as enclosing characters. Be sure
to escape any double quotes a message may contain by preceding them with
another double quote. Alternatively, you can select another delimiter than
comma in the import options.

.. code-block:: none

    keys,en,es,ja
    GREET,"Hello, friend!","Hola, amigo!",こんにちは
    ASK,How are you?,Cómo está?,元気ですか
    BYE,Goodbye,Adiós,さようなら
    QUOTE,"""Hello"" said the man.","""Hola"" dijo el hombre.",「こんにちは」男は言いました

CSV importer
------------

Godot will treat CSV files as translations by default. It will import them
and generate one or more compressed translation resource files next to it.

Importing will also add the translation to the list of
translations to load when the game runs, specified in project.godot (or the
project settings). Godot allows loading and removing translations at
runtime as well.

Select the ``.csv`` file and access the **Import** dock to define import
options. You can toggle the compression of the imported translations, and
select the delimiter to use when parsing the CSV file.

.. image:: img/import_csv.png

Be sure to click **Reimport** after any change to these options.


===================================================
/. ./tutorials/assets_pipeline/importing_scenes.rst
===================================================

.. _doc_importing_3d_scenes:

Importing 3D scenes
===================

Godot scene importer
--------------------

When dealing with 3D assets, Godot has a flexible and configurable importer.

Godot works with *scenes*. This means that the entire scene being worked on in your favorite 3D DCC will be
transferred as close as possible.

Godot supports the following 3D *scene file formats*:

* glTF 2.0 **(recommended)**. Godot has full support for both text (``.gltf``) and binary (``.glb``) formats.
* DAE (COLLADA), an older format that is fully supported.
* OBJ (Wavefront) format + their MTL material files. This is also fully supported, but pretty limited (no support for pivots, skeletons, animations, PBR materials, ...).
* ESCN, a Godot-specific format that Blender can export with a plugin.
* FBX, supported via the Open Asset Import library. However, FBX is proprietary, so we recommend using other formats
  listed above, if suitable for your workflow.

Just copy the scene file together with the texture to the project repository, and Godot will do a full import.

It is important that the mesh is not deformed by bones when exporting. Make sure that the skeleton is reset to its T-pose
or default rest pose before exporting with your favorite 3D editor.

Exporting DAE files from Maya and 3DS Max
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Autodesk added built-in COLLADA support to Maya and 3DS Max, but it's
broken by default and should not be used. The best way to export this format
is by using the
`OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/OpenCOLLADA-Tools>`__
plugins. They work well, although they are not always up-to date
with the latest version of the software.

Exporting glTF 2.0 files from Blender
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are three ways to export glTF files from Blender. As a glTF binary (``.glb`` file), glTF embedded (``.gltf`` file),
and with textures (``gltf`` + ``.bin`` + textures).

glTF binary files are the smallest of the three options. They include the mesh and textures set up in Blender.
When brought into Godot the textures are part of the object's material file.

glTF embedded files function the same way as binary files. They don't provide extra functionality in Godot,
and shouldn't be used since they have a larger file size.

There are two reasons to use glTF with the textures separate. One is to have the scene description in a
text based format and the binary data in a separate binary file. This can be useful for version control if you want to review
changes in a text based format. The second is you need the texture files separate from the material file. If you don't need
either of those glTF binary files are fine.

.. warning::

    Blend shape animations cannot be imported - they require manual animation within Godot.

.. note::

    Blender versions older than 3.2 do not export emissive textures with the
    glTF file. If your model uses one and you're using an older version of
    Blender, it must be brought in separately.

    By default, Blender has backface culling disabled on materials and will
    export materials to match how they render in Blender. This means that
    materials in Godot will have their cull mode set to **Disabled**. This can
    decrease performance since backfaces will be rendered, even when they are
    being culled by other faces. To resolve this, enable **Backface Culling** in
    Blender's Materials tab, then export the scene to glTF again.

Exporting DAE files from Blender
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Blender has built-in COLLADA support, but it does not work properly for the needs of game engines
and should not be used as is.

Godot provides a `Blender plugin <https://github.com/godotengine/collada-exporter>`_
that will correctly export COLLADA scenes for use in Godot. It does not work in Blender 2.8 or
newer, but there are plans to update it in the future.

Exporting ESCN files from Blender
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The most powerful one, called `godot-blender-exporter
<https://github.com/godotengine/godot-blender-exporter>`__.
It uses a .escn file, which is kind of another name for a .tscn file (Godot scene file);
it keeps as much information as possible from a Blender scene. However, it is considered
experimental.

The ESCN exporter has a detailed `document <escn_exporter/index.html>`__ describing
its functionality and usage.

Exporting textures separately
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While textures can be exported with a model in certain file formats, such as glTF 2.0, you can also export them
separately. Godot uses PBR (physically based rendering) for its materials, so if a texturing program can export PBR
textures, they can work in Godot. This includes the `Substance suite <https://www.substance3d.com/>`__,
`ArmorPaint (open source) <https://armorpaint.org/>`__, and `Material Maker (open source) <https://github.com/RodZill4/material-maker>`__.

.. note:: For more information on Godot's materials, see :ref:`doc_spatial_material`.

Exporting considerations
~~~~~~~~~~~~~~~~~~~~~~~~

Since GPUs can only render triangles, meshes that contain quads or N-gons have
to be *triangulated* before they can be rendered. Godot can triangulate meshes
on import, but results may be unpredictable or incorrect, especially with
N-gons. Regardless of the target application, triangulating *before* exporting
the scene will lead to more consistent results and should be done whenever
possible.

To avoid issues with incorrect triangulation after importing in Godot, it is
recommended to make the 3D DCC triangulate objects on its own. In Blender, this
can be done by adding a Triangulate modifier to your objects and making sure
**Apply Modifiers** is checked in the export dialog. Alternatively, depending on
the exporter, you may be able to find and enable a **Triangulate Faces** option
in the export dialog.

To avoid issues with 3D selection in the editor, it is recommended to apply the
object transform in the 3D DCC before exporting the scene.

Import workflows
----------------

Godot scene importer allows different workflows regarding how data is imported. Depending on many options, it is possible to
import a scene with:

* External materials (default): Where each material is saved to a file resource. Modifications to them are kept.
* External meshes: Where each mesh is saved to a different file. Many users prefer to deal with meshes directly.
* External animations: Allowing saved animations to be modified and merged when sources change.
* External scenes: Save each of the root nodes of the imported scenes as a separate scene.
* Single scene: A single scene file with everything built in.

.. image:: img/scene_import1.png

As different developers have different needs, this import process is highly customizable.

Import options
--------------

The importer has several options, which will be discussed below:

.. image:: img/scene_import2.png

Nodes
~~~~~

Root Type
^^^^^^^^^

By default, the type of the root node in imported scenes is "Spatial", but this can be modified.

Root Name
^^^^^^^^^

Allows setting a specific name to the generated root node.

Root Scale
^^^^^^^^^^

The scale of the root node.

Custom Script
^^^^^^^^^^^^^

A special script to process the whole scene after import can be provided.
This is great for post processing, changing materials, doing funny stuff
with the geometry etc.

Create a script like this:

::

    tool # Needed so it runs in the editor.
    extends EditorScenePostImport


    func post_import(scene):
        # Do your stuff here.
        return scene # remember to return the imported scene

The ``post_import`` function takes the imported scene as argument (the
parameter is actually the root node of the scene). The scene that
will finally be used must be returned. It can be a different one.

Storage
^^^^^^^

By default, Godot imports a single scene. This option allows specifying
that nodes below the root will each be a separate scene and instanced
into the imported one.

Of course, instancing such imported scenes in other places manually works, too.


Materials
~~~~~~~~~

Location
^^^^^^^^

Godot supports materials in meshes or nodes. By default, materials will be put
on each node.

Storage
^^^^^^^

Materials can be stored within the scene or in external files. By default,
they are stored in external files so editing them is possible. This is because
most 3D DCCs don't have the same material options as those present in Godot.

When materials are built-in, they will be lost each time the source scene
is modified and re-imported.

.. note::

    Godot will not reimport materials that are stored in external files unless
    you remove the associated ``.material`` file before reimporting.

    To force reimporting materials every time the 3D scene is reimported, change
    the material storage mode in the 3D scene by selecting it in the FileSystem
    dock, going to the Import dock then setting **Material > Storage** to
    **Built-In** instead of **Files**.

Keep On Reimport
^^^^^^^^^^^^^^^^

Once materials are edited to use Godot features, the importer will keep the
edited ones and ignore the ones coming from the source scene. This option
is only present if materials are saved as files.

Meshes
~~~~~~

Compress
^^^^^^^^

Makes meshes use less precise numbers for multiple aspects of the mesh in order
to save space.

These are:
 * Transform Matrix (Location, rotation, and scale)             : 32-bit float to 16-bit signed integer.
 * Vertices                                                     : 32-bit float to 16-bit signed integer.
 * Normals                                                      : 32-bit float to 32-bit unsigned integer.
 * Tangents                                                     : 32-bit float to 32-bit unsigned integer.
 * Vertex Colors                                                : 32-bit float to 32-bit unsigned integer.
 * UV                                                           : 32-bit float to 32-bit unsigned integer.
 * UV2                                                          : 32-bit float to 32-bit unsigned integer.
 * Vertex weights                                               : 32-bit float to 16-bit unsigned integer.
 * Armature bones                                               : 32-bit float to 16-bit unsigned integer.
 * Array index                                                  : 32-bit or 16-bit unsigned integer based on how many elements there are.

Additional info:
 * UV2 = The second UV channel for detail textures and baked lightmap textures.
 * Array index = An array of numbers that number each element of the arrays above; i.e. they number the vertices and normals.

In some cases, this might lead to loss of precision, so disabling this option
may be needed. For instance, if a mesh is very big or there are multiple meshes
being imported that cover a large area, compressing the import of this mesh(es)
may lead to gaps in geometry or vertices not being exactly where they should be.

Ensure Tangents
^^^^^^^^^^^^^^^

If textures with normal mapping are to be used, meshes need to have tangent arrays.
This option ensures that these are generated if not present in the source scene.
Godot uses `Mikktspace <http://www.mikktspace.com/>`__ for this,
but it's always better to have them generated in the exporter.

Storage
^^^^^^^

Meshes can be stored in separate files (resources) instead of built-in. This does
not have much practical use unless one wants to build objects with them directly.

This option is provided to help those who prefer working directly with meshes
instead of scenes.

Light Baking
^^^^^^^^^^^^

Whether or not the mesh is used in baked lightmaps.

- **Disabled:** The mesh is not used in baked lightmaps.
- **Enable:** The mesh is used in baked lightmaps.
- **Gen Lightmaps:** The mesh is used in baked lightmaps, and unwraps a second UV layer for lightmaps.

.. note:: For more information on light baking see :ref:`doc_baked_lightmaps`.

External Files
~~~~~~~~~~~~~~

Generated meshes and materials can be optionally stored in a subdirectory with the
name of the scene.

Animation options
-----------------

Godot provides many options regarding how animation data is dealt with. Some exporters
(such as Blender) can generate many animations in a single file. Others, such as
3DS Max or Maya, need many animations put into the same timeline or, at worst, put
each animation in a separate file.

.. image:: img/scene_import3.png

Import of animations is enabled by default.

.. attention::

    To modify animations from an imported 3D scene, you need to change the animation
    storage option from **Built-In** to **Files** in the Import dock. Otherwise,
    changes made to animations from Godot will be lost when the project is run.

FPS
~~~

Most 3D export formats store animation timeline in seconds instead of frames. To ensure
animations are imported as faithfully as possible, please specify the frames per second
used to edit them. Failing to do this may result in shaky animations.

Filter Script
~~~~~~~~~~~~~

It is possible to specify a filter script in a special syntax to decide which tracks from which
animations should be kept.

The filter script is executed against each imported animation. The syntax consists of two types of
statements, the first for choosing which animations to filter, and the second for filtering
individual tracks within the matched animation. All name patterns are performed using a case
insensitive expression match, using ``?`` and ``*`` wildcards (using ``String.matchn()`` under the
hood).

The script must start with an animation filter statement (as denoted by the line beginning with an
``@``). For example, if we would like to apply filters to all imported animations which have a name
ending in ``"_Loop"``::

    @+*_Loop

Similarly, additional patterns can be added to the same line, separated by commas. Here is a
modified example to additionally *include* all animations with names that begin with ``"Arm_Left"``,
but also *exclude* all animations which have names ending in ``"Attack"``::

    @+*_Loop, +Arm_Left*, -*Attack

Following the animation selection filter statement, we add track filtering patterns to indicate
which animation tracks should be kept or discarded. If no track filter patterns are specified, then
all tracks within the matched animations will be discarded!

It's important to note that track filter statements are applied in order for each track within the
animation, this means that one line may include a track, a later rule can still discard it.
Similarly, a track excluded by an early rule may then be re-included once again by a filter rule
further down in the filter script.

For example: include all tracks in animations with names ending in ``"_Loop"``, but discard any
tracks affecting a ``"Skeleton"`` which end in ``"Control"``, unless they have ``"Arm"`` in their
name::

    @+*_Loop
    +*
    -Skeleton:*Control
    +*Arm*

In the above example, tracks like ``"Skeleton:Leg_Control"`` would be discarded, while tracks such
as ``"Skeleton:Head"`` or ``"Skeleton:Arm_Left_Control"`` would be retained.

Any track filter lines that do not begin with a ``+`` or ``-`` are ignored.

Storage
~~~~~~~

By default, animations are saved as built-in. It is possible to save them to a file instead. This
allows adding custom tracks to the animations and keeping them after a reimport.

Optimizer
~~~~~~~~~

When animations are imported, an optimizer is run, which reduces the size of the animation considerably.
In general, this should always be turned on unless you suspect that an animation might be broken due to it being enabled.

Clips
~~~~~

It is possible to specify multiple animations from a single timeline as clips. For this to work, the model
must have only one animation that is named ``default``. To create clips, change the clip amount to something
greater than zero. You can then name a clip, specify which frames it starts and stops on, and choose whether
the animation loops or not.

.. If this PR (https://github.com/godotengine/godot/pull/36709) is merged for Godot 4.0 this section must
   be updated to reflect that for the 4.0 documentation.

Scene inheritance
-----------------

In many cases, it may be desired to make modifications to the imported scene. By default, this is not possible because
if the source asset changes (source ``.dae``, ``.gltf``, ``.obj`` file re-exported from 3D modelling app), Godot will re-import the whole scene.

It is possible, however, to make local modifications by using *Scene Inheritance*. Try to open the imported scene and the
following dialog will appear:

.. image:: img/scene_import4.png

In inherited scenes, the only limitations for modifications are:

* Nodes can't be removed (but can be added anywhere).
* Sub-Resources can't be edited (save them externally as described above for this)

Other than that, everything is allowed!

.. _doc_importing_scenes_import_hints:

Import hints
------------

Many times, when editing a scene, there are common tasks that need to be done after exporting:

- Adding collision detection to objects.
- Setting objects as navigation meshes.
- Deleting nodes that are not used in the game engine (like specific lights used for modelling).

To simplify this workflow, Godot offers several suffixes that can be added to
the names of the objects in your 3D modelling software. When imported, Godot
will detect suffixes in object names and will perform actions automatically.

.. note::

    All the suffixes described below are *case-sensitive*.

Remove nodes (-noimp)
~~~~~~~~~~~~~~~~~~~~~

Objects that have the ``-noimp`` suffix will be removed at import-time no matter
what their type is. They will not appear in the imported scene.

Create collisions (-col, -convcol, -colonly, -convcolonly)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The option ``-col`` will work only for Mesh objects. If it is detected, a child
static collision node will be added, using the same geometry as the mesh. This
will create a triangle mesh collision shape, which is a slow, but accurate
option for collision detection. This option is usually what you want for level
geometry (but see also ``-colonly`` below).

The option ``-convcol`` will create a :ref:`class_convexpolygonshape` instead of
a :ref:`class_concavepolygonshape`. Unlike triangle meshes which can be concave,
a convex shape can only accurately represent a shape that doesn't have any
concave angles (a pyramid is convex, but a hollow box is concave). Due to this,
convex collision shapes are generally not suited for level geometry. When
representing simple enough meshes, convex collision shapes can result in better
performance compared to a triangle collision shape. This option is ideal for
simple or dynamic objects that require mostly-accurate collision detection.

However, in both cases, the visual geometry may be too complex or not smooth
enough for collisions. This can create physics glitches and slow down the engine
unnecessarily.

To solve this, the ``-colonly`` modifier exists. It will remove the mesh upon
importing and will create a :ref:`class_staticbody` collision instead.
This helps the visual mesh and actual collision to be separated.

The option ``-convcolonly`` works in a similar way, but will create a :ref:`class_convexpolygonshape` instead.

The option ``-colonly`` can also be used with Blender's empty objects.
On import, it will create a :ref:`class_staticbody` with
a collision node as a child. The collision node will have one of a number of predefined shapes,
depending on Blender's empty draw type:

.. image:: img/3dimp_BlenderEmptyDrawTypes.png

-  Single arrow will create a :ref:`class_rayshape`.
-  Cube will create a :ref:`class_boxshape`.
-  Image will create a :ref:`class_planeshape`.
-  Sphere (and the others not listed) will create a :ref:`class_sphereshape`.

When possible, **try to use a few primitive collision shapes** instead of triangle
mesh or convex shapes. Primitive shapes often have the best performance and
reliability.

.. note::

    For better visibility in Blender's editor, you can set the "X-Ray" option
    on collision empties and set some distinct color for them in Blender's
    **User Preferences > Themes > 3D View > Empty**.

.. seealso::

    See :ref:`doc_collision_shapes_3d` for a comprehensive overview of collision
    shapes.

Create navigation (-navmesh)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A mesh node with the ``-navmesh`` suffix will be converted to a navigation mesh.
The original Mesh object will be removed at import-time.

Create a VehicleBody (-vehicle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A mesh node with the ``-vehicle`` suffix will be imported as a child to a
:ref:`class_VehicleBody` node.

Create a VehicleWheel (-wheel)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A mesh node with the ``-wheel`` suffix will be imported as a child to a
:ref:`class_VehicleWheel` node.

Rigid Body (-rigid)
~~~~~~~~~~~~~~~~~~~

A mesh node with the ``-rigid`` suffix will be imported as a :ref:`class_RigidBody`.

Animation loop (-loop, -cycle)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Animation clips in the COLLADA document that start or end with the token ``loop`` or ``cycle``
will be imported as a Godot Animation with the loop flag set.
**Unlike the other suffixes described above, this does not require a hyphen.**

In Blender, this requires using the NLA Editor and naming the Action with the ``loop`` or
``cycle`` prefix or suffix.


===================================================
/. ./tutorials/assets_pipeline/exporting_3d_scenes.rst
===================================================

.. _doc_exporting_3d_scenes:

Exporting 3D scenes
===================

Overview
--------

In Godot it is possible to export 3D scenes as a glTF 2.0 file. You can
export as a glTF binary (``.glb`` file) or glTF embedded with textures
(``gltf`` + ``.bin`` + textures). This allows you to create scenes in Godot,
such as a CSG mesh blockout for a level, export it to clean it up in a
program such as Blender, and then bring it back into Godot.

.. note:: 

    Only Blender 2.83 and newer can import glTF files exported by Godot.

To export a scene in the editor go to **Project > Tools > Export GLTF...**

.. image:: img/gltf_godot_export.png

Limitations
-----------

There are several limitations with glTF export.

* No support for exporting particles since their implementation varies across engines.
* ShaderMaterials cannot be exported.
* No support for exporting 2D scenes.
* Only supported in editor builds (``tools=yes``).


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/index.rst
===================================================

Blender ESCN exporter
=====================

.. note:: This chapter relates to the Blender plugin called "Godot Blender Exporter",
          which can be downloaded here: https://github.com/godotengine/godot-blender-exporter

This plugin can be used to export Blender scenes in a Godot-specific scene format
called ESCN, which is similar to TSCN (text format) but will be imported as binary
SCN for performance.

Details on exporting
--------------------

.. toctree::
   :maxdepth: 1
   :name: toc-learn-workflow-assets-escn_exporter

   material
   physics
   lights
   mesh
   skeleton
   animation


Disabling specific objects
--------------------------

Sometimes you don't want some objects exported (e.g. high-res models used for
baking). An object will not be exported if it is not rendered in the scene.
This can be set in the outliner:

.. image:: img/hide.jpg

Objects hidden in the viewport will be exported, but will be hidden in the
Godot scene.


Build pipeline integration
--------------------------

If you have hundreds of model files, you don't want your artists to waste time
manually exporting their blend files. To combat this, the exporter provides a
python function ``io_scene_godot.export(out_file_path)`` that can be called to
export a file. This allows easy integration with other build systems. An
example Makefile and python script that exports all the blends in a directory
are present in the Godot-Blender-exporter repository.


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/material.rst
===================================================

Materials
=========

Using existing Godot materials
------------------------------

One way in which the exporter can handle materials is to attempt to match
the Blender material with an existing Godot material. This has the advantage of
being able to use all of the features of Godot's material system, but it means
that you cannot see your model with the material applied inside Blender.

To do this, the exporter attempts to find Godot materials with names that match
those of the material name in Blender. So if you export an object in Blender
with the material name ``PurpleDots`` then the exporter will search for the
file ``PurpleDots.tres`` and assign it to the object. If this file is not a
``SpatialMaterial`` or ``ShaderMaterial`` or if it cannot be found, then the
exporter will fall back to exporting the material from Blender.


Where the exporter searches for the ``.tres`` file is determined by the "Material
Search Paths" option:

.. image:: img/material_search.jpg

This can take the value of:
 - Project Directory - Attempts to find the ``project.Godot`` and recursively
   searches through subdirectories. If ``project.Godot`` cannot be found it
   will throw an error. This is useful for most projects where naming conflicts
   are unlikely.
 - Export Directory - Look for materials in subdirectories of the export
   location. This is useful for projects where you may have duplicate
   material names and need more control over what material gets assigned.
 - None - Do not search for materials. Export them from the Blender file.


Export of Cycles/EEVEE materials
--------------------------------

The exporter has a primitive support for converting Cycles/EEVEE material node tree
to Godot Shader Material. Note that some of the Shader Node are not supported yet due to
difficulties in implementation, which are:

- all the ``noisy textures``
- ``generated texture coordinates``
- ``group node``
- shader nodes except ``PrincipledBSDF``, ``Diffuse``, ``Glossy``, ``Glass``, ``add shader`` and ``mix shader``

.. warning::

    If possible, try to use PrincipledBSDF node with GGX distribution as the output shader
    node, it is the only one guaranteed to be exactly correct. Others are just based on approximation.

Sometimes materials may not be valid for exporting (e.g. has some unsupported node) or it
is using Blender Internal Engine, only the diffuse color and a few flags (e.g. unshaded) are
exported and form a Spatial Material.


Generate external materials
---------------------------

The default configuration of material exporting would keep all the materials internal to
the ``escn`` file. There is an option which could enable generating external ``.material``
file when the ``escn`` file opens in Godot.

.. image:: img/external_mat_option.jpg

``.material`` file can be assigned to any material slot to be a external resource.

.. image:: img/gd_dot_material.jpg


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/physics.rst
===================================================

Physics properties
==================

Exporting physics properties is done by enabling "Rigid Body" in Blender's
physics tab:

.. image:: img/enable_physics.png

.. important::
    By default, a single Blender object with rigid body enabled will export as
    three nodes: a PhysicsBody, a CollisionShape, and a MeshInstance.

Body type
---------

Blender only has the concept of "Active" and "Passive" rigid bodies. These
turn into Static and RigidBody nodes. To create a kinematic body, enable the
"animated" checkbox on an "Active" body:

.. image:: img/body_type.jpg

Collision shapes
----------------

Many of the parameters for collision shapes are missing from Blender, and many
of the collision shapes are also not present. However, almost all of the
options in Blender's rigid body collision and rigid body dynamics interfaces
are supported:

.. image:: img/collision_shapes.jpg

There are the following caveats:
 - Not all of the collision shapes are supported. Only ``Mesh``, ``Convex
   Hull``, ``Capsule``, ``Sphere`` and ``Box`` are supported in both Blender and
   Godot
 - In Godot, you can have different collision groups and collision masks. In
   Blender you only have collision groups. As a result, the exported object's
   collision mask is equal to its collision group. Most of the time, this is
   what you want.

.. important::
    To build compound physics shapes, parent together multiple objects with
    rigid body enabled. The physics properties are taken from the parent-most
    rigid body, and the rest are used as collision shapes.

Collision geometry only
-----------------------

Frequently you want different geometry for your collision meshes and your
graphical meshes, but by default, the exporter will export a mesh along with the
collision shape. To only export the collision shape, set the object's maximum
draw type to Wire:

.. image:: img/col_only.png

This will also influence how the object is shown in Blender's viewport.
Most of the time, you want your collision geometry to be shown see-through when
working on the models, so this works out fairly nicely.


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/lights.rst
===================================================

Lights
======
.. warning::
    By default, lamps in Blender have shadows enabled. This can cause
    performance issues in Godot.

.. warning::
    Lamps are exported using their "Blender Render" settings. When Blender 2.8
    is released, this will be removed and this part of the exporter will change.

Sun, point and spot lamps are all exported from Blender along with many of their
properties:

.. image:: img/light_properties.jpg

There are some things to note:

 - In Blender, a light casts light all the way to infinity. In Godot, it is
   clamped by the attenuation distance. To most closely match between the
   viewport and Godot, enable the "Sphere" checkbox. (Highlighted green)
 - Light attenuation models differ between Godot and Blender. The exporter
   attempts to make them match, but it isn't always very good.
 - Spotlight angular attenuation models also differ between Godot and Blender.
   The exporter attempts to make them similar, but it doesn't always look the
   same.
 - There is no difference between buffer shadow and ray shadow in the export.


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/mesh.rst
===================================================

Mesh
====

Modifiers
---------
There is an exporting option :code:`Apply Modifiers` to
control whether mesh modifiers are applied to the exported mesh.


Shape Key
---------
Exporting mesh shape key is supported, however exporting each shape key
is almost like exporting the mesh again, so don't be surprised
it takes a relatively long time.

.. warning::
    A lot of modifiers are not compatible with shape keys
    (e.g. subsurface modifier), so if you found you have
    incorrect shape keys exported, try to disable :code:`Apply Modifiers`
    and do the exporting again. Besides, it is worthwhile to report the
    incompatible modifier to the `issue list
    <https://github.com/godotengine/godot-blender-exporter/issues>`__,
    which helps to develop the exporter to have a more precise check of modifiers.


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/skeleton.rst
===================================================

Skeleton
========

.. image:: img/armature.jpg

Rest Bone
---------

Armature object in Blender is exported as a Skeleton node along with
rest position (transform in Godot) of bones.

.. warning::
    The three check boxes :code:`Inherit Rotation`, :code:`Inherit Scale`,
    :code:`Local Location` (colored in red) must be ticked when building
    armature in Blender, so that the exported bone transform be
    consistent between Blender and Godot

It is important that the mesh is not deformed by bones when exporting in Blender. Make sure
that the skeleton is reset to its T-pose or default rest pose.

Bone Weights
------------

Blender put rigged mesh vertices which has no bone weights at its original
position, but these vertices would be placed at (0, 0, 0) in Godot, making the mesh
deformed. Therefore, the exporter would raise an error for any vertex with no bone weights
detected in a rigged mesh.

Non-Deform Bone
---------------

Note that the non-deform bone can be configured as not exported
by enabling the :code:`Exclude Control Bones`; the deform bone
checkbox is shown in the picture.


Bone Attachment
---------------
A bone can be the parent of an object in Blender; this relation is exported
as a BoneAttachment node in the Godot scene.


===================================================
/. ./tutorials/assets_pipeline/escn_exporter/animation.rst
===================================================

Animation
=========
Animation supported:
 - transform animation of all types of objects
 - transform animation of pose bones
 - shape key animation
 - light animation
 - camera animation

Multiple Actions For Single Object
----------------------------------
In most games, one object would have several animations to switch between.
This add-on has support for exporting multiple actions all at once into
a single AnimationPlayer and makes it easy to switch actions.

This workflow makes use of blender nla_tracks. Here is a brief guide on how
to use this feature:

**1. Stash active action**

New created action is always an active action bound to object. There are
several ways to place an active action into NLA track,
one is of course doing it in ``NLA Editor``

.. image:: img/nla_editor.jpg
.. image:: img/nla_pushdown.jpg

Or it can be done stashing the action in ``Dope Sheet``

.. image:: img/dope_sheet.jpg
.. image:: img/stash_action.jpg

**2. Check mute status of NLA tracks**

An NLA track can be ``mute`` or ``unmute``, the exporter will export all
the ``mute`` NLA track as a separate action, while blends all the ``unmute``
NLA tracks into every action (including the action action) being exported.

.. image:: img/nla_strip.jpg

**3. Export the scene**

Make sure the ``Export Stashed Actions`` option has been turned on.

.. image:: img/stash_action_option.jpg

Then all the stashed actions, as well as the active action, are exported
to an AnimationPlayer.

.. image:: img/in_godot.jpg


Constraints
-----------
Sometimes complicated animation is built with object constraint; a usual
example is inverse kinematics. The add-on would automatically check if an
object has some constraint; if it does, all the constraints are baked into
actions and then exported along with the object.


Animation Mode
---------------------------
Godot and Blender have different structure to store animation data.
In Godot animation data is stored in an AnimationPlayer node, instead
of in each animated node. In order to fix this inconsistence and still
make the animation play versatile, this add-on has three animation exporting
modes.


**Mode 'Animation as Actions'**

Treat all the animations as object actions, so in the exported scene, every
object would have its own AnimationPlayer and hold its actions.


**Mode 'Scene Animation'**

If you want your animation to generate the same result as playing at Blender's
timeline, this is what you want. In this mode, all the animations in the scene
are placed in just one AnimationPlayer in the scene root.

**Mode 'Animation as Action with Squash'**

This mode has very similar behavior of mode 'Animation as Action', but it
can generate fewer AnimationPlayers; objects in parent-children relationship would
share their AnimationPlayer. It is useful when you have several rigs, and each
Skeleton and Mesh has actions; then one rig would have just one AnimationPlayer.


===================================================
/. ./tutorials/audio/index.rst
===================================================

Audio
=====

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-audio

   audio_buses
   audio_streams
   sync_with_audio
   recording_with_microphone


===================================================
/. ./tutorials/audio/audio_buses.rst
===================================================

.. _doc_audio_buses:

Audio buses
===========

Introduction
------------

Godot's audio processing code has been written with games in mind, with the aim
of achieving an optimal balance between performance and sound quality.

Godot's audio engine allows any number of audio buses to be created and any
number of effect processors can be added to each bus. Only the hardware of the
device running your game will limit the number of buses and effects that can be
used before performance starts to suffer.

Decibel scale
-------------

Godot's sound interface is designed to meet the expectations of sound design
professionals. To this end, it primarily uses the decibel scale.

For those unfamiliar with it, it can be explained with a few facts:

- The decibel (dB) scale is a relative scale. It represents the ratio of
  sound power by using 20 times the base 10 logarithm of the ratio
  (20 × log\ :sub:`10`\ (P/P\ :sub:`0`\ )).
- For every 6 dB, sound amplitude doubles or halves. 12 dB represents a factor
  of 4, 18 dB a factor of 8, 20 dB a factor of 10, 40 dB a factor of 100, etc.
- Since the scale is logarithmic, true zero (no audio) can't be represented.
- 0 dB is the maximum amplitude possible in a digital audio system.
  This limit is not the human limit, but a limit from the sound hardware.
  Audio with amplitudes that are too high to be represented properly below 0 dB
  create a kind of distortion called *clipping*.
- To avoid clipping, your sound mix should be arranged so that the output of the
  *master bus* (more on that later) never exceeds 0 dB.
- Every 6 dB below the 0 dB limit, sound energy is *halved*.
  It means the sound volume at -6 dB is half as loud as 0dB.
  -12 dB is half as loud as -6 dB and so on.
- When working with decibels, sound is considered no longer audible
  between -60 dB and -80 dB. This makes your working range generally
  between -60 dB and 0 dB.

This can take a bit getting used to, but it's friendlier in the end
and will allow you to communicate better with audio professionals.

Audio buses
-----------

Audio buses can be found in the bottom panel of the Godot editor:

.. image:: img/audio_buses1.png

An *audio bus* (also called an *audio channel*) can be considered a place that
audio is channeled through on the way to playback through a device's speakers.
Audio data can be *modified* and *re-routed* by an audio bus. An audio bus
has a VU meter (the bars that light up when sound is played) which indicates the
amplitude of the signal passing through.

The leftmost bus is the *master bus*. This bus outputs the mix to your speakers
so, as mentioned in the *Decibel scale* section above, make sure that your mix
level doesn't reach 0 dB in this bus. The rest of the audio buses can be
flexibly routed. After modifying the sound, they send it to another bus to
the left. The destination bus can be specified for each of the non-master audio
buses. Routing always passes audio from buses on the right to buses further
to the left. This avoids infinite routing loops.

.. image:: img/audio_buses2.png

In the above image, the output of *Bus 2* has been routed to the *Master* bus.

Playback of audio through a bus
-------------------------------

To test passing audio to a bus, create an AudioStreamPlayer node, load an
AudioStream and select a target bus for playback:

.. image:: img/audio_buses3.png

Finally, toggle the **Playing** property to **On** and sound will flow.

.. seealso::

    You may also be interested in reading about :ref:`doc_audio_streams` now.

Adding effects
--------------

Audio buses can contain all sorts of effects. These effects modify the sound in
one way or another and are applied in order.

.. image:: img/audio_buses4.png

Try them all out to get a sense of how they alter sound. Here follows a short
description of the available effects:

Amplify
~~~~~~~

Amplify changes the amplitude of the signal. Some care needs to be taken.
Setting the level too high can make the sound clip, which is usually
undesirable.

BandLimit and BandPass
~~~~~~~~~~~~~~~~~~~~~~

These are resonant filters which block frequencies around the *Cutoff* point.
BandPass can be used to simulate sound passing through an old telephone line or
megaphone. Modulating the BandPass frequency can simulate the sound of a wah-wah
guitar pedal, think of the guitar in Jimi Hendrix's *Voodoo Child (Slight
Return)*.

Capture
~~~~~~~

The Capture effect copies the audio frames of the audio bus that it is on into
an internal buffer. This can be used to capture data from the microphone
or to transmit audio over the network in real-time.

Chorus
~~~~~~

The Chorus effect duplicates the incoming audio, delays the duplicate slightly
and uses an LFO to continuously modulate the pitch of the duplicated signal
before mixing the duplicated signal(s) and the original together again. This
creates a shimmering effect and adds stereo width to the sound.

Compressor
~~~~~~~~~~

A dynamic range compressor automatically attenuates the level of the incoming
signal when its amplitude exceeds a certain threshold. The level of attenuation
applied is proportional to how far the incoming audio exceeds the threshold.
The compressor's Ratio parameter controls the degree of attenuation.
One of the main uses of a compressor is to reduce the dynamic range of signals
with very loud and quiet parts. Reducing the dynamic range of a signal
can make it easier to mix.

The compressor has many uses. For example:

- It can be used in the Master bus to compress the whole output.
- It can be used in voice channels to ensure they sound as even as possible.
- It can be *sidechained*. This means it can reduce the sound level
  of one signal using the level of another audio bus for threshold detection.
  This technique is very common in video game mixing to "duck" the level of
  music or sound effects when voices need to be heard.
- It can accentuate transients by using a slower attack.
  This can make sound effects more punchy.

.. note::

    If your goal is to prevent a signal from exceeding a given amplitude
    altogether, rather than to reduce the dynamic range of the signal,
    a :ref:`limiter <doc_audio_buses_limiter>` is likely a better choice
    than a compressor.


Delay
~~~~~

Adds an "echo" effect with a feedback loop. It can be used together
with *Reverb* to simulate wide rooms, canyons, etc. where sound bounces
are far apart.

Distortion
~~~~~~~~~~

Makes the sound distorted. Godot offers several types of distortion: *overdrive*,
*tan* and *bit crushing*. Distortion can be used to simulate sound coming through
a low-quality speaker or device.

EQ
~~

EQ is what all other equalizers inherit from. It can be extended with with Custom
scripts to create an equalizer with a custom number of bands.

EQ6, EQ10, EQ21
~~~~~~~~~~~~~~~

Godot provides three equalizers with different numbers of bands. An equalizer on
the Master bus can be useful to cut frequencies that the device's speakers can't
reproduce well (e.g. a mobile phone's speakers won't reproduce bass content
well). The equalizer effect can be disabled when headphones are plugged in.

Filter
~~~~~~

Filter is what all other filters inherit from and should not be used directly.

HighPassFilter
~~~~~~~~~~~~~~

Cuts frequencies below a specific *Cutoff* frequency.
HighPassFilter is used to reduce the bass content of a
signal.

HighShelfFilter
~~~~~~~~~~~~~~~

Reduces all frequencies above a specific *Cutoff* frequency.

.. _doc_audio_buses_limiter:

Limiter
~~~~~~~

A limiter is similar to a compressor, but it's less flexible and designed to
prevent a signal's amplitude exceeding a given dB threshold. Adding a limiter to
the Master bus is a safeguard against clipping.

LowPassFilter
~~~~~~~~~~~~~

Cuts frequencies above a specific *Cutoff* frequency and can also resonate
(boost frequencies close to the *Cutoff* frequency). Low pass filters can be
used to simulate "muffled" sound. For instance, underwater sounds, sounds
blocked by walls, or distant sounds.

LowShelfFilter
~~~~~~~~~~~~~~

Reduces all frequencies below a specific *Cutoff* frequency.

NotchFilter
~~~~~~~~~~~

The opposite of the BandPassFilter, it removes a band of sound from the
frequency spectrum at a given *Cutoff* frequency.

Panner
~~~~~~

The Panner allows the stereo balance of a signal to be adjusted between
the left and right channels (wear headphones to audition this effect).

Phaser
~~~~~~

It probably does not make much sense to explain that this effect is formed by
two signals being dephased and cancelling each other out. You can make a Darth
Vader voice with it, or jet-like sounds.

PitchShift
~~~~~~~~~~

This effect allows the adjustment of the signal's pitch independently of its
speed. All frequencies can be increased/decreased with minimal effect on
transients. PitchShift can be useful to create unusually high or deep voices.

Record
~~~~~~

The Record effect allows the user to record sound from a microphone.

Reverb
~~~~~~

Reverb simulates rooms of different sizes. It has adjustable parameters that can
be tweaked to obtain the sound of a specific room. Reverb is commonly outputted
from :ref:`Areas <class_Area>`
(see :ref:`Reverb buses <doc_audio_streams_reverb_buses>`), or to apply
a "chamber" feel to all sounds.

SpectrumAnalyzer
~~~~~~~~~~~~~~~~

This effect doesn't alter audio, instead, you add this effect to buses you want
a spectrum analysis of. This would typically be used for audio visualization. A
demo project using this can be found `here <https://github.com/godotengine/godot-demo-projects/tree/master/audio/spectrum>`__.

StereoEnhance
~~~~~~~~~~~~~

This effect uses a few algorithms to enhance a signal's stereo spectrum.

Automatic bus disabling
-----------------------

There is no need to disable buses manually when not in use. Godot detects
that the bus has been silent for a few seconds and disables it (including
all effects).

.. figure:: img/audio_buses5.png

   Disabled buses have a blue VU meter instead of a red-green one.

Bus rearrangement
-----------------

Stream Players use bus names to identify a bus, which allows adding, removing
and moving buses around while the reference to them is kept. However, if a bus
is renamed, the reference will be lost and the Stream Player will output
to Master. This system was chosen because rearranging buses is a more common
process than renaming them.

Default bus layout
------------------

The default bus layout is automatically saved to the
``res://default_bus_layout.tres`` file. Custom bus arrangements can be saved
and loaded from disk.


===================================================
/. ./tutorials/audio/audio_streams.rst
===================================================

.. _doc_audio_streams:

Audio streams
=============

Introduction
------------

As you might have already read in :ref:`doc_audio_buses`, sound is sent to
each bus via an AudioStreamPlayer node. There are different kinds
of AudioStreamPlayers. Each one loads an AudioStream and plays it back.

AudioStream
-----------

An audio stream is an abstract object that emits sound. The sound can come from
many places, but is most commonly loaded from the filesystem. Audio files can be
loaded as AudioStreams and placed inside an AudioStreamPlayer. You can find
information on supported formats and differences in :ref:`doc_importing_audio_samples`.

There are other types of AudioStreams, such as AudioStreamRandomPitch.
This one makes a random adjustment to the sound's pitch every time it's
played back. This can be helpful for adding variation to sounds that are
played back often.

AudioStreamPlayer
-----------------

.. image:: img/audio_stream_player.png

This is the standard, non-positional stream player. It can play to any bus.
In 5.1 sound setups, it can send audio to stereo mix or front speakers.

AudioStreamPlayer2D
-------------------

.. image:: img/audio_stream_2d.png

This is a variant of AudioStreamPlayer, but emits sound in a 2D positional
environment. When close to the left of the screen, the panning will go left.
When close to the right side, it will go right.

.. note::

    Area2Ds can be used to divert sound from any AudioStreamPlayer2Ds they
    contain to specific buses. This makes it possible to create buses with
    different reverb or sound qualities to handle action happening in a
    particular parts of your game world.

.. image:: img/audio_stream_2d_area.png

AudioStreamPlayer3D
-------------------

.. image:: img/audio_stream_3d.png

This is a variant of AudioStreamPlayer, but emits sound in a 3D positional
environment. Depending on the location of the player relative to the screen,
it can position sound in stereo, 5.1 or 7.1 depending on the chosen audio setup.

Similar to AudioStreamPlayer2D, an Area can divert the sound to an audio bus.

.. image:: img/audio_stream_3d_area.png

Unlike for 2D, the 3D version of AudioStreamPlayer has a few more advanced options:

.. _doc_audio_streams_reverb_buses:

Reverb buses
~~~~~~~~~~~~

Godot allows for 3D audio streams that enter a specific Area node to send dry
and wet audio to separate buses. This is useful when you have several reverb
configurations for different types of rooms. This is done by enabling this type
of reverb in the **Reverb Bus** section of the Area's properties:

.. image:: img/audio_stream_reverb_bus.png

At the same time, a special bus layout is created where each area receives the
reverb info from each area. A Reverb effect needs to be created and configured
in each reverb bus to complete the setup for the desired effect:

.. image:: img/audio_stream_reverb_bus2.png

The Area's **Reverb Bus** section also has a parameter named **Uniformity**.
Some types of rooms bounce sounds more than others (like a warehouse), so
reverberation can be heard almost uniformly across the room even though the
source may be far away. Playing around with this parameter can simulate
that effect.

Doppler
~~~~~~~

When the relative velocity between an emitter and listener changes, this is
perceived as an increase or decrease in the pitch of the emitted sound.
Godot can track velocity changes in the AudioStreamPlayer3D and Camera nodes.
Both nodes have this property, which must be enabled manually:

.. image:: img/audio_stream_doppler.png

Enable it by setting it depending on how objects will be moved:
use **Idle** for objects moved using ``_process``, or **Physics**
for objects moved using ``_physics_process``. The tracking will
happen automatically.


===================================================
/. ./tutorials/audio/sync_with_audio.rst
===================================================

.. _doc_sync_with_audio:

Sync the gameplay with audio and music
=======================================

Introduction
------------

In any application or game, sound and music playback will have a slight delay. For games, this delay is often so small that it is negligible. Sound effects will come out a few milliseconds after any play() function is called. For music this does not matter as in most games it does not interact with the gameplay.

Still, for some games (mainly, rhythm games), it may be required to synchronize player actions with something happening in a song (usually in sync with the BPM). For this, having more precise timing information for an exact playback position is useful.

Achieving very low playback timing precision is difficult. This is because many factors are at play during audio playback:

* Audio is mixed in chunks (not continuously), depending on the size of audio buffers used (check latency in project settings).
* Mixed chunks of audio are not played immediately.
* Graphics APIs display two or three frames late.
* When playing on TVs, some delay may be added due to image processing.

The most common way to reduce latency is to shrink the audio buffers (again, by editing the latency setting in the project settings). The problem is that when latency is too small, sound mixing will require considerably more CPU. This increases the risk of skipping (a crack in sound because a mix callback was lost).

This is a common tradeoff, so Godot ships with sensible defaults that should not need to be altered.

The problem, in the end, is not this slight delay but synchronizing graphics and audio for games that require it. Beginning with Godot 3.2, some helpers were added to obtain more precise playback timing.

Using the system clock to sync
------------------------------

As mentioned before, If you call :ref:`AudioStreamPlayer.play()<class_AudioStreamPlayer_method_play>`, sound will not begin immediately, but when the audio thread processes the next chunk.

This delay can't be avoided but it can be estimated by calling :ref:`AudioServer.get_time_to_next_mix()<class_AudioServer_method_get_time_to_next_mix>`.

The output latency (what happens after the mix) can also be estimated by calling :ref:`AudioServer.get_output_latency()<class_AudioServer_method_get_output_latency>`.

Add these two and it's possible to guess almost exactly when sound or music will begin playing in the speakers during *_process()*:

.. tabs::
 .. code-tab:: gdscript GDScript

    var time_begin
    var time_delay


    func _ready():
        time_begin = OS.get_ticks_usec()
        time_delay = AudioServer.get_time_to_next_mix() + AudioServer.get_output_latency()
        $Player.play()


    func _process(delta):
        # Obtain from ticks.
        var time = (OS.get_ticks_usec() - time_begin) / 1000000.0
        # Compensate for latency.
        time -= time_delay
        # May be below 0 (did not begin yet).
        time = max(0, time)
        print("Time is: ", time)

 .. code-tab:: csharp

    private double _timeBegin;
    private double _timeDelay;

    public override void _Ready()
    {
        _timeBegin = OS.GetTicksUsec();
        _timeDelay = AudioServer.GetTimeToNextMix() + AudioServer.GetOutputLatency();
        GetNode<AudioStreamPlayer>("Player").Play();
    }

    public override void _Process(float _delta)
    {
        double time = (OS.GetTicksUsec() - _timeBegin) / 1000000.0d;
        time = Math.Max(0.0d, time - _timeDelay);
        GD.Print(string.Format("Time is: {0}", time));
    }


In the long run, though, as the sound hardware clock is never exactly in sync with the system clock, the timing information will slowly drift away.

For a rhythm game where a song begins and ends after a few minutes, this approach is fine (and it's the recommended approach). For a game where playback can last a much longer time, the game will eventually go out of sync and a different approach is needed.

Using the sound hardware clock to sync
--------------------------------------

Using :ref:`AudioStreamPlayer.get_playback_position()<class_AudioStreamPlayer_method_get_playback_position>` to obtain the current position for the song sounds ideal, but it's not that useful as-is. This value will increment in chunks (every time the audio callback mixed a block of sound), so many calls can return the same value. Added to this, the value will be out of sync with the speakers too because of the previously mentioned reasons.

To compensate for the "chunked" output, there is a function that can help: :ref:`AudioServer.get_time_since_last_mix()<class_AudioServer_method_get_time_since_last_mix>`.


Adding the return value from this function to *get_playback_position()* increases precision:

.. tabs::
 .. code-tab:: gdscript GDScript

    var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix()

 .. code-tab:: csharp
    
    double time = GetNode<AudioStreamPlayer>("Player").GetPlaybackPosition() + AudioServer.GetTimeSinceLastMix();


To increase precision, subtract the latency information (how much it takes for the audio to be heard after it was mixed):

.. tabs::
 .. code-tab:: gdscript GDScript

    var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix() - AudioServer.get_output_latency()

 .. code-tab:: csharp

    double time = GetNode<AudioStreamPlayer>("Player").GetPlaybackPosition() + AudioServer.GetTimeSinceLastMix() - AudioServer.GetOutputLatency();

The result may be a bit jittery due how multiple threads work. Just check that the value is not less than in the previous frame (discard it if so). This is also a less precise approach than the one before, but it will work for songs of any length, or synchronizing anything (sound effects, as an example) to music.

Here is the same code as before using this approach:

.. tabs::
 .. code-tab:: gdscript GDScript


    func _ready():
        $Player.play()


    func _process(delta):
        var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix()
        # Compensate for output latency.
        time -= AudioServer.get_output_latency()
        print("Time is: ", time)

 .. code-tab:: csharp

    public override void _Ready()
    {
        GetNode<AudioStreamPlayer>("Player").Play();
    }

    public override void _Process(float _delta)
    {
        double time = GetNode<AudioStreamPlayer>("Player").GetPlaybackPosition() + AudioServer.GetTimeSinceLastMix();
        // Compensate for output latency.
        time -= AudioServer.GetOutputLatency();
        GD.Print(string.Format("Time is: {0}", time));
    }


===================================================
/. ./tutorials/audio/recording_with_microphone.rst
===================================================

.. _doc_recording_with_microphone:

Recording with microphone
=========================

Godot supports in-game audio recording for Windows, macOS, Linux, Android and
iOS.

A simple demo is included in the official demo projects and will be used as
support for this tutorial:
`<https://github.com/godotengine/godot-demo-projects/tree/master/audio/mic_record>`_.

You will need to enable audio input in the project settings, or you'll just get empty audio files.

The structure of the demo
-------------------------

The demo consists of a single scene. This scene includes two major parts: the
GUI and the audio.

We will focus on the audio part. In this demo, a bus named ``Record`` with the
effect ``Record`` is created to handle the audio recording.
An ``AudioStreamPlayer`` named ``AudioStreamRecord`` is used for recording.

.. image:: img/record_bus.png

.. image:: img/record_stream_player.png

.. tabs::
 .. code-tab:: gdscript GDScript

    var effect
    var recording


    func _ready():
        # We get the index of the "Record" bus.
        var idx = AudioServer.get_bus_index("Record")
        # And use it to retrieve its first effect, which has been defined
        # as an "AudioEffectRecord" resource.
        effect = AudioServer.get_bus_effect(idx, 0)

 .. code-tab:: csharp

    private AudioEffectRecord _effect;
    private AudioStreamSample _recording;

    public override void _Ready()
    {
        // We get the index of the "Record" bus.
        int idx = AudioServer.GetBusIndex("Record");
        // And use it to retrieve its first effect, which has been defined
        // as an "AudioEffectRecord" resource.
        _effect = (AudioEffectRecord)AudioServer.GetBusEffect(idx, 0);
    }

The audio recording is handled by the :ref:`class_AudioEffectRecord` resource
which has three methods:
:ref:`get_recording() <class_AudioEffectRecord_method_get_recording>`,
:ref:`is_recording_active() <class_AudioEffectRecord_method_is_recording_active>`,
and :ref:`set_recording_active() <class_AudioEffectRecord_method_set_recording_active>`.

.. tabs::
  .. code-tab:: gdscript GDScript

    func _on_RecordButton_pressed():
        if effect.is_recording_active():
            recording = effect.get_recording()
            $PlayButton.disabled = false
            $SaveButton.disabled = false
            effect.set_recording_active(false)
            $RecordButton.text = "Record"
            $Status.text = ""
        else:
            $PlayButton.disabled = true
            $SaveButton.disabled = true
            effect.set_recording_active(true)
            $RecordButton.text = "Stop"
            $Status.text = "Recording..."

  .. code-tab:: csharp

    public void OnRecordButtonPressed()
    {
        if (_effect.IsRecordingActive())
        {
            _recording = _effect.GetRecording();
            GetNode<Button>("PlayButton").Disabled = false;
            GetNode<Button>("SaveButton").Disabled = false;
            _effect.SetRecordingActive(false);
            GetNode<Button>("RecordButton").Text = "Record";
            GetNode<Label>("Status").Text = "";
        }
        else
        {
            GetNode<Button>("PlayButton").Disabled = true;
            GetNode<Button>("SaveButton").Disabled = true;
            _effect.SetRecordingActive(true);
            GetNode<Button>("RecordButton").Text = "Stop";
            GetNode<Label>("Status").Text = "Recording...";
        }
    }

At the start of the demo, the recording effect is not active. When the user
presses the ``RecordButton``, the effect is enabled with
``set_recording_active(true)``.

On the next button press, as ``effect.is_recording_active()`` is ``true``,
the recorded stream can be stored into the ``recording`` variable by calling
``effect.get_recording()``.

.. tabs::
  .. code-tab:: gdscript GDScript

    func _on_PlayButton_pressed():
        print(recording)
        print(recording.format)
        print(recording.mix_rate)
        print(recording.stereo)
        var data = recording.get_data()
        print(data.size())
        $AudioStreamPlayer.stream = recording
        $AudioStreamPlayer.play()

  .. code-tab:: csharp

    public void OnPlayButtonPressed()
    {
        GD.Print(_recording);
        GD.Print(_recording.Format);
        GD.Print(_recording.MixRate);
        GD.Print(_recording.Stereo);
        byte[] data = _recording.Data;
        GD.Print(data.Length);
        var audioStreamPlayer = GetNode<AudioStreamPlayer>("AudioStreamPlayer");
        audioStreamPlayer.Stream = _recording;
        audioStreamPlayer.Play();
    }

To playback the recording, you assign the recording as the stream of the
``AudioStreamPlayer`` and call ``play()``.

.. tabs::
  .. code-tab:: gdscript GDScript

    func _on_SaveButton_pressed():
        var save_path = $SaveButton/Filename.text
        recording.save_to_wav(save_path)
        $Status.text = "Saved WAV file to: %s\n(%s)" % [save_path, ProjectSettings.globalize_path(save_path)]

  .. code-tab:: csharp

    public void OnSavebuttonPressed()
    {
        string savePath = GetNode<LineEdit>("SaveButton/Filename").Text;
        _recording.SaveToWav(savePath);
        GetNode<Label>("Status").Text = string.Format("Saved WAV file to: {0}\n({1})", savePath, ProjectSettings.GlobalizePath(savePath));
    }

To save the recording, you call ``save_to_wav()`` with the path to a file.
In this demo, the path is defined by the user via a ``LineEdit`` input box.


===================================================
/. ./tutorials/export/index.rst
===================================================

Export
======

.. toctree::
   :maxdepth: 1
   :name: toc-learn-workflow-export

   exporting_basics
   exporting_projects
   exporting_pcks
   feature_tags
   exporting_for_linux
   exporting_for_macos
   running_on_macos
   exporting_for_windows
   changing_application_icon_for_windows
   exporting_for_uwp
   exporting_for_ios
   exporting_for_android
   android_custom_build
   exporting_for_web
   exporting_for_dedicated_servers
   one-click_deploy


===================================================
/. ./tutorials/export/exporting_basics.rst
===================================================

.. _doc_exporting_basics:

Exporting
=========

Overview
--------

Now that you have a working game, you probably want to share your success with
others. However, it's not practical to ask your friends to download Godot
just so they can open your project. Instead, you can *export* your project,
converting it into a "package" that can be run by anyone.

The way you export your game depends on what platform you are targeting. In
this tutorial, you'll learn how to export the *Dodge the Creeps* game for a
variety of platforms. First, however, we need to make some changes to the
way the game works.

.. note:: If you haven't made "Dodge the Creeps" yourself yet, please read
          :ref:`doc_your_first_2d_game` before continuing with this tutorial.

Preparing the project
---------------------

In *Dodge the Creeps*, we used keyboard controls to move the player's character.
This is fine if your game is being played on a PC platform, but on a phone
or tablet, you need to support touchscreen input. Because a click event can
be treated the same as a touch event, we'll convert the game to a click-and-move
input style.

By default, Godot emulates mouse input from touch input. That means that if
anything is coded to happen on a mouse event, touch will trigger it as well.
Godot can also emulate touch input from mouse clicks, which we will need to be
able to keep playing our game on our computer after we switch to touch input.

In **Project > Project Settings**, under **Input Devices > Pointing**, enable
**Emulate Touch From Mouse**.

.. image:: img/export_touchsettings.png

We also want to ensure that the game scales consistently on different-sized screens,
so in the project settings go to **Display**, then click on **Window**. In the **Stretch**
options, set **Mode** to ``2d`` and **Aspect** to ``keep``.

Since we are already in the **Window** settings, we should also set under **Handheld**
the **Orientation** to ``portrait``.

.. image:: img/export_handheld_stretchsettings.png

Next, we need to modify the ``Player.gd`` script to change the input method.
We'll remove the key inputs and make the player move towards a "target" that's
set by the touch (or click) event.

Here is the full script for the player, with comments noting what we've
changed:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Area2D

    signal hit

    export var speed = 400
    var screen_size
    # Add this variable to hold the clicked position.
    var target = Vector2()

    func _ready():
        hide()
        screen_size = get_viewport_rect().size

    func start(pos):
        position = pos
        # Initial target is the start position.
        target = pos
        show()
        $CollisionShape2D.disabled = false

    # Change the target whenever a touch event happens.
    func _input(event):
        if event is InputEventScreenTouch and event.pressed:
            target = event.position

    func _process(delta):
        var velocity = Vector2()
        # Move towards the target and stop when close.
        if position.distance_to(target) > 10:
            velocity = target - position

    # Remove keyboard controls.
    #    if Input.is_action_pressed("ui_right"):
    #       velocity.x += 1
    #    if Input.is_action_pressed("ui_left"):
    #        velocity.x -= 1
    #    if Input.is_action_pressed("ui_down"):
    #        velocity.y += 1
    #    if Input.is_action_pressed("ui_up"):
    #        velocity.y -= 1

        if velocity.length() > 0:
            velocity = velocity.normalized() * speed
            $AnimatedSprite.play()
        else:
            $AnimatedSprite.stop()

        position += velocity * delta
        # We still need to clamp the player's position here because on devices that don't
        # match your game's aspect ratio, Godot will try to maintain it as much as possible
        # by creating black borders, if necessary.
        # Without clamp(), the player would be able to move under those borders.
        position.x = clamp(position.x, 0, screen_size.x)
        position.y = clamp(position.y, 0, screen_size.y)

        if velocity.x != 0:
            $AnimatedSprite.animation = "walk"
            $AnimatedSprite.flip_v = false
            $AnimatedSprite.flip_h = velocity.x < 0
        elif velocity.y != 0:
            $AnimatedSprite.animation = "up"
            $AnimatedSprite.flip_v = velocity.y > 0

    func _on_Player_body_entered( body ):
        hide()
        emit_signal("hit")
        $CollisionShape2D.set_deferred("disabled", true)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Player : Area2D
    {
        [Signal]
        public delegate void Hit();

        [Export]
        public int Speed = 400;

        private Vector2 _screenSize;
        // Add this variable to hold the clicked position.
        private Vector2 _target;

        public override void _Ready()
        {
            Hide();
            _screenSize = GetViewport().Size;
        }

        public void Start(Vector2 pos)
        {
            Position = pos;
            // Initial target us the start position.
            _target = pos;
            Show();
            GetNode<CollisionShape2D>("CollisionShape2D").Disabled = false;
        }

        // Change the target whenever a touch event happens.
        public override void _Input(InputEvent @event)
        {
            if (@event is InputEventScreenTouch eventMouseButton && eventMouseButton.Pressed)
            {
                _target = (@event as InputEventScreenTouch).Position;
            }
        }

        public override void _Process(float delta)
        {
            var velocity = new Vector2();
            // Move towards the target and stop when close.
            if (Position.DistanceTo(_target) > 10)
            {
                velocity = _target - Position;
            }

            // Remove keyboard controls.
            //if (Input.IsActionPressed("ui_right"))
            //{
            //    velocity.x += 1;
            //}

            //if (Input.IsActionPressed("ui_left"))
            //{
            //    velocity.x -= 1;
            //}

            //if (Input.IsActionPressed("ui_down"))
            //{
            //    velocity.y += 1;
            //}

            //if (Input.IsActionPressed("ui_up"))
            //{
            //    velocity.y -= 1;
            //}

            var animatedSprite = GetNode<AnimatedSprite>("AnimatedSprite");

            if (velocity.Length() > 0)
            {
                velocity = velocity.Normalized() * Speed;
                animatedSprite.Play();
            }
            else
            {
                animatedSprite.Stop();
            }

            Position += velocity * delta;
            // We still need to clamp the player's position here because on devices that don't
            // match your game's aspect ratio, Godot will try to maintain it as much as possible
            // by creating black borders, if necessary.
            // Without clamp(), the player would be able to move under those borders.
            Position = new Vector2(
                x: Mathf.Clamp(Position.x, 0, _screenSize.x),
                y: Mathf.Clamp(Position.y, 0, _screenSize.y)
            );

            if (velocity.x != 0)
            {
                animatedSprite.Animation = "walk";
                animatedSprite.FlipV = false;
                animatedSprite.FlipH = velocity.x < 0;
            }
            else if(velocity.y != 0)
            {
                animatedSprite.Animation = "up";
                animatedSprite.FlipV = velocity.y > 0;
            }
        }
        public void OnPlayerBodyEntered(PhysicsBody2D body)
        {
            Hide(); // Player disappears after being hit.
            EmitSignal("Hit");
            GetNode<CollisionShape2D>("CollisionShape2D").SetDeferred("disabled", true);
        }
    }

Setting a main scene
--------------------

The main scene is the one that your game will start in. For this
*Dodge the Creeps* example, in
**Project -> Project Settings -> Application -> Run**, set **Main Scene**
to ``Main.tscn`` by clicking the folder icon and selecting it.

Export templates
----------------

To export the project, you need to download the *export templates* from the
http://godotengine.org/download. These templates are optimized versions of the engine
without the editor pre-compiled for each platform. You can also
download them in Godot by clicking on **Editor -> Manage Export Templates**:

.. image:: img/export_template_menu.png

.. note::

    If you've downloaded Godot from
    `Steam <https://store.steampowered.com/app/404790/Godot_Engine/>`__,
    export templates are already included. Therefore, you don't need to download
    them using the **Manage Export Templates** dialog.

In the window that appears, you can click **Download** to get the template
version that matches your version of Godot.

.. image:: img/export_template_manager.png

.. note::

    Export templates are bound to a specific Godot version. If you upgrade
    Godot, you must download templates that match the new version.

Export presets
--------------

Next, you can configure the export settings by clicking on **Project -> Export**.

Create a new export preset by clicking **Add...** and selecting a platform. You
can make as many presets as you like with different settings.

.. image:: img/export_presets_window.png

At the bottom of the window are two buttons. **Export PCK/ZIP** only creates
a packed version of your project's data. This doesn't include an executable
so the project can't be run on its own.

The second button, **Export Project**, creates a complete executable version
of your game, such as an ``.apk`` for Android or an ``.exe`` for Windows.

In the **Resources** and **Features** tabs, you can customize how the game is
exported for each platform. We can leave those settings alone for now.

Exporting by platform
---------------------

In this section, we'll walk through the process for each platform,
including any additional software or requirements you'll need.

PC (Linux/macOS/Windows)
~~~~~~~~~~~~~~~~~~~~~~~~

Exporting PC platforms works the same across the three supported operating
systems. Open the export window and click **Add...** to create the preset(s) you
want to make. Then click **Export Project** and choose a name and destination
folder. Choose a location *outside* of your project folder.

Click **Save** and the engine will build the export files.

.. note::

    When exporting for macOS, if you export from a macOS computer, you'll end up
    with a ``.dmg`` file, while using Linux or Windows produces a ``.zip``. In
    either case, the compressed file contains a macOS ``.app`` that you can
    double-click and run.

.. note::

    On Windows, if you want your exported executable to have a different icon
    than the default one, you need to change it manually. See
    :ref:`doc_changing_application_icon_for_windows`.

Android
~~~~~~~

.. tip::

    Mobile devices come with a wide variety of capabilities. In most cases,
    Godot's default settings will work, but mobile development is sometimes more
    art than science, and you may need to do some experimenting and searching
    for help in order to get everything working.

Before you can export your project for Android, you must download the following
software:

* Android SDK: https://developer.android.com/studio/
* Open JDK (**version 8 is required**, more recent versions won't work): https://adoptopenjdk.net/index.html

When you run Android Studio for the first time, click on **Configure -> SDK Manager**
and install **Android SDK Platform Tools**. This installs the ``adb``
command-line tool that Godot uses to communicate with your device.

Next, create a debug keystore by running the following command on your
system's command line:

.. code-block:: shell

    keytool -keyalg RSA -genkeypair -alias androiddebugkey -keypass android -keystore debug.keystore -storepass android -dname "CN=Android Debug,O=Android,C=US" -validity 9999

Click on *Editor -> Editor Settings* in Godot and select the *Export/Android*
section. Here, you need to set the paths to the Android SDK applications on
your system and the location of the keystore you just created.

.. image:: img/export_editor_android_settings.png

Now you're ready to export. Click on **Project -> Export** and add a preset
for Android (see above). Select the newly added Android preset. Under **Options**,
go to **Screen** and set **Orientation** to **Portrait**. If your game is in
landscape mode (i.e. the window width in pixels is greater than the window height),
leave this on **Landscape**.

Click the **Export Project** button and Godot will build an APK you can download
on your device. To do this on the command line, use the following:

.. code-block:: shell

    adb install dodge.apk

.. note:: Your device may need to be in *developer mode*. Consult your
          device's documentation for details.

If your system supports it, connecting a compatible Android device will cause
a **One-click Deploy** button to appear in Godot's playtest button area:

.. image:: img/export_android_oneclick.png

Clicking this button builds the APK and copies it onto your device in one step.

iOS
~~~

.. note::

    To build your game for iOS, you must have a computer running macOS with
    Xcode installed.

Before exporting, there are some settings that you *must* complete for the project
to export successfully. First, the **App Store Team Id**, which you can find by
logging in to your Apple developer account and looking in the **Membership** section.

You must also provide icons and splash screen images as shown below:

.. image:: img/export_ios_settings.png

Click **Export Project** and select a destination folder.

Once you have successfully exported the project, you'll find the following
folders and files have been created in your selected location:

.. image:: img/export_xcode_project_folders.png

You can now open the project in Xcode and build the project for iOS.
The Xcode build procedure is beyond the scope of this tutorial.
See https://help.apple.com/xcode/mac/current/#/devc8c2a6be1
for more information.

HTML5 (web)
~~~~~~~~~~~

Click **Export Project** on the HTML5 preset. We don't need to change any
of the default settings.

When the export is complete, you'll have a folder containing the following
files:

.. image:: img/export_web_files.png

Viewing the ``.html`` file in your browser lets you play the game. However, you
can't open the file directly. Instead, it needs to be served by a web server. If
you don't have one set up on your computer, you can search online to find
suggestions for your specific OS.

Point your browser at the URL where you've placed the HTML file. You may have
to wait a few moments while the game loads before you see the start screen.

.. image:: img/export_web_example.png

The console window beneath the game tells you if anything goes wrong. You can
disable it by disabling **Export With Debug** in the final file dialog that appears
when you export the project.

.. image:: img/export_web_export_with_debug_disabled.png

.. note::

    While WebAssembly is supported in all major browsers, it is still an
    emerging technology and you may find some things that don't work. Make sure
    you have updated your browser to the most recent version, and report any
    bugs you find on the
    `Godot GitHub repository <https://github.com/godotengine/godot/issues>`_.


===================================================
/. ./tutorials/export/exporting_projects.rst
===================================================

.. _doc_exporting_projects:

Exporting projects
==================

.. highlight:: none

Why export?
-----------

Originally, Godot did not have any means to export projects. The
developers would compile the proper binaries and build the packages for
each platform manually.

When more developers (and even non-programmers) started using it, and
when our company started taking more projects at the same time, it
became evident that this was a bottleneck.

On PC
~~~~~

Distributing a game project on PC with Godot is rather easy. Drop
the Godot binary in the same directory as the ``project.godot`` file,
then compress the project directory and you are done.

It sounds simple, but there are probably a few reasons why the developer
may not want to do this. The first one is that it may not be desirable
to distribute loads of files. Some developers may not like curious users
peeking at how the game was made, others may find it inelegant, and so on.
Another reason is that the developer might prefer a specially-compiled
binary, which is smaller in size, more optimized and does not include
tools like the editor and debugger.

Finally, Godot has a simple but efficient system for
:ref:`creating DLCs as extra package files <doc_exporting_pcks>`.

On mobile
~~~~~~~~~

The same scenario on mobile platforms is a little worse.
To distribute a project on those devices, a binary for each of
those platforms is built, then added to a native project together
with the game data.

This can be troublesome because it means that the developer must be
familiarized with the SDK of each platform before even being able to
export. While learning each SDK is always encouraged, it can be
frustrating to be forced to do it at an undesired time.

There is also another problem with this approach: different devices
prefer some data in different formats to run. The main example of this
is texture compression. All PC hardware uses S3TC (BC) compression and
that has been standardized for more than a decade, but mobile devices
use different formats for texture compression, such as PVRTC (iOS) or
ETC (Android).

Export menu
-----------

After many attempts at different export workflows, the current one has
proven to work the best. At the time of this writing, not all platforms are
supported yet, but the supported platforms continue to grow.

To open the export menu, click the **Export** button:

.. image:: img/export.png

The export menu will open. However, it will be completely empty.
This is because we need to add an export preset.

.. image:: img/export_dialog.png

To create an export preset, click the **Add…** button at the top
of the export menu. This will open a drop-down list of platforms
to choose from for an export preset.

.. image:: img/export_preset.png

The default options are often enough to export, so tweaking them is
usually not necessary. However, many platforms require additional
tools (SDKs) to be installed to be able to export. Additionally, Godot
needs export templates installed to create packages. The export menu
will complain when something is missing and will not allow the user to
export for that platform until they resolve it:

.. image:: img/export_error.png

At that time, the user is expected to come back to the documentation and follow
instructions on how to properly set up that platform.

Export templates
~~~~~~~~~~~~~~~~

Apart from setting up the platform, the export templates must be
installed to be able to export projects. They can be obtained as a
TPZ file (which is a renamed ZIP archive) from the
`download page of the website <https://www.godotengine.org/download>`_.

Once downloaded, they can be installed using the **Install Export Templates**
option in the editor:

.. image:: img/exptemp.png

.. _doc_exporting_projects_export_mode:

Resource options
~~~~~~~~~~~~~~~~

When exporting, Godot makes a list of all the files to export and then
creates the package. There are 3 different modes for exporting:

-  Export all resources in the project
-  Export selected scenes (and dependencies)
-  Export selected resources (and dependencies)

.. image:: img/expres.png

**Export all resources in the project** will export every resource in the
project. **Export selected scenes** and **Export selected resources** gives
you a list of the scenes or resources in the project, and you have to
select every scene or resource you want to export.

.. image:: img/expselected.png

.. note::

    Files and folders whose name begin with a period will never be included in
    the exported project. This is done to prevent version control folders like
    ``.git`` from being included in the exported PCK file.

Below the list of resources are two filters that can be setup. The first allows
non resource files such as ``.txt``,``.json`` and ``.csv`` to be exported with
the project. The second filter can be used to exclude every file of a certain
type without manually deselecting every one. For example, ``.png`` files.

Exporting from the command line
-------------------------------

In production, it is useful to automate builds, and Godot supports this
with the ``--export`` and ``--export-debug`` command line parameters.
Exporting from the command line still requires an export preset to define
the export parameters. A basic invocation of the command would be:

.. code-block:: shell

    godot --export "Windows Desktop" some_name.exe

This will export to ``some_name.exe``, assuming there is a preset
called "Windows Desktop" and the template can be found. (The export preset name
must be written within quotes if it contains spaces or special characters.)
The output path is *relative to the project path* or *absolute*;
**it does not respect the directory the command was invoked from**.

The output file extension should match the one used by the Godot export process:

- Windows: ``.exe``
- macOS: ``.zip`` (from all platforms) or ``.dmg`` (only when exporting *from* macOS).
  ``.app`` is not supported directly, although the generated ZIP archive contains an ``.app`` bundle.
- Linux: Any extension (including none). ``.x86_64`` is typically used for 64-bit x86 binaries.
- HTML5: ``.zip``
- Android: ``.apk``
- iOS: ``.zip``

You can also configure it to export *only* the PCK or ZIP file, allowing
a single exported main pack file to be used with multiple Godot executables.
When doing so, the export preset name must still be specified on the command line:

.. code-block:: shell

    godot --export-pack "Windows Desktop" some_name.pck

It is often useful to combine the ``--export`` flag with the ``--path``
flag, so that you do not need to ``cd`` to the project folder before running
the command:

.. code-block:: shell

    godot --path /path/to/project --export "Windows Desktop" some_name.exe

.. seealso::

    See :ref:`doc_command_line_tutorial` for more information about using Godot
    from the command line.

PCK versus ZIP pack file formats
--------------------------------

Each format has its upsides and downsides. PCK is the default and recommended
format for most use cases, but you may want to use a ZIP archive instead
depending on your needs.

**PCK format:**

- Uncompressed format. Larger file size, but faster to read/write.
- Not readable and writable using tools normally present on the user's
  operating system, even though there are
  `third-party tools <https://github.com/hhyyrylainen/GodotPckTool>`__
  to extract and create PCK files.

**ZIP format:**

- Compressed format. Smaller file size, but slower to read/write.
- Readable and writable using tools normally present on the user's operating system.
  This can be useful to make modding easier (see also :ref:`doc_exporting_pcks`).

.. warning::

    Due to a `known bug <https://github.com/godotengine/godot/pull/42123>`__,
    when using a ZIP file as a pack file, the exported binary will not try to use
    it automatically. Therefore, you have to create a *launcher script* that
    the player can double-click or run from a terminal to launch the project::

        :: launch.bat (Windows)
        @echo off
        my_project.exe --main-pack my_project.zip

        # launch.sh (Linux)
        ./my_project.x86_64 --main-pack my_project.zip

    Save the launcher script and place it in the same folder as the exported binary.
    On Linux, make sure to give executable permissions to the launcher script using
    the command ``chmod +x launch.sh``.


===================================================
/. ./tutorials/export/exporting_pcks.rst
===================================================

.. _doc_exporting_pcks:

Exporting packs, patches, and mods
==================================

Use cases
---------

Oftentimes one would like to add functionality to one's game after it has been
deployed.

Examples of this include...

- Downloadable Content: the ability to add features and content to one's game.
- Patches: the ability to fix a bug that is present in a shipped product.
- Mods: grant other people the ability to create content for one's game.

These tools help developers to extend their development beyond the initial
release.

Overview of PCK files
---------------------

Godot enables this via a feature called **resource packs** (PCK files,
with extension ``.pck``).

**Advantages:**

- incremental updates/patches
- offer DLCs
- offer mod support
- no source code disclosure needed for mods
- more modular project structure
- users don't have to replace the entire game

The first part of using them involves exporting and delivering the project to
players. Then, when one wants to add functionality or content later on, they
just deliver the updates via PCK files to the users.

PCK files usually contain, but are not limited to:

- scripts
- scenes
- shaders
- models
- textures
- sound effects
- music
- any other asset suitable for import into the game

The PCK files can even be an entirely different Godot project, which the
original game loads in at runtime.

Generating PCK files
--------------------

In order to pack all resources of a project into a PCK file open the project
and go to Project/Export and click on “Export PCK/Zip”. Also make sure to have
an export template selected while doing so.

.. image:: img/export_pck.png

Another method would be to :ref:`export from the command line <doc_command_line_tutorial_exporting>`.
If the output file ends with a PCK or ZIP file extension, then the export
process will build that type of file for the chosen platform.

.. note::

    If one wishes to support mods for their game, they will need their users to
    create similarly exported files. Assuming the original game expects a
    certain structure for the PCK's resources and/or a certain interface for
    its scripts, then either...

    1. The developer must publicize documentation of these expected structures/
       interfaces, expect modders to install Godot Engine, and then also expect
       those modders to conform to the documentation's defined API when building
       mod content for the game (so that it will work). Users would then use
       Godot's built in exporting tools to create a PCK file, as detailed
       above.
    2. The developer uses Godot to build a GUI tool for adding their exact API
       content to a project. This Godot tool must either run on a tools-enabled
       build of the engine or have access to one (distributed alongside or
       perhaps in the original game's files). The tool can then use the Godot
       executable to export a PCK file from the command line with
       :ref:`OS.execute() <class_OS_method_execute>`. The game itself shouldn't
       use a tool-build of the engine (for security), so it's best to keep
       the modding tool and game separate.

Opening PCK files at runtime
----------------------------

To import a PCK file, one uses the ProjectSettings singleton. The following
example expects a “mod.pck” file in the directory of the games executable.
The PCK file contains a “mod_scene.tscn” test scene in its root.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _your_function():
        # This could fail if, for example, mod.pck cannot be found.
        var success = ProjectSettings.load_resource_pack("res://mod.pck")

        if success:
            # Now one can use the assets as if they had them in the project from the start.
            var imported_scene = load("res://mod_scene.tscn")

 .. code-tab:: csharp

    private void YourFunction()
    {
        // This could fail if, for example, mod.pck cannot be found.
        var success = ProjectSettings.LoadResourcePack("res://mod.pck");

        if (success)
        {
            // Now one can use the assets as if they had them in the project from the start.
            var importedScene = (PackedScene)ResourceLoader.Load("res://mod_scene.tscn");
        }
    }

.. warning::

    By default, if you import a file with the same file path/name as one you already have in your
    project, the imported one will replace it. This is something to watch out for when
    creating DLC or mods (solved easily with a tool isolating mods to a specific mods
    subfolder). However, it is also a way of creating patches for one's own game. A
    PCK file of this kind can fix the content of a previously loaded PCK.

    To opt out of this behavior, pass ``false`` as the second argument to
    :ref:`ProjectSettings.load_resource_pack() <class_ProjectSettings_method_load_resource_pack>`.

.. note::
    For a C# project, you need to build the DLL and place it in the project directory first.
    Then, before loading the resource pack, you need to load its DLL as follows:
    ``Assembly.LoadFile("mod.dll")``

Summary
-------

This tutorial should illustrate how easy adding mods, patches or DLC to a game
is. The most important thing is to identify how one plans to distribute future
content for their game and develop a workflow that is customized for that
purpose. Godot should make that process smooth regardless of which route a
developer pursues.


===================================================
/. ./tutorials/export/feature_tags.rst
===================================================

.. _doc_feature_tags:

Feature tags
============

Introduction
------------

Godot has a special system to tag availability of features.
Each *feature* is represented as a string, which can refer to many of the following:

* Platform name.
* Platform architecture (64-bit or 32-bit, x86 or ARM).
* Platform type (desktop, mobile, Web).
* Supported texture compression algorithms on the platform.
* Whether a build is ``debug`` or ``release`` (``debug`` includes the editor).
* Whether the project is running from the editor or a "standalone" binary.
* Many more things.

Features can be queried at run-time from the singleton API by calling:

::

    OS.has_feature(name)


Default features
----------------

Here is a list of most feature tags in Godot. Keep in mind they are **case-sensitive**:

+-----------------+--------------------------------------------------------+
| **Feature tag** | **Description**                                        |
+=================+========================================================+
| **Android**     | Running on Android                                     |
+-----------------+--------------------------------------------------------+
| **HTML5**       | Running on HTML5                                       |
+-----------------+--------------------------------------------------------+
| **JavaScript**  | :ref:`JavaScript singleton <doc_javascript_eval>` is   |
|                 | available                                              |
+-----------------+--------------------------------------------------------+
| **OSX**         | Running on macOS                                       |
+-----------------+--------------------------------------------------------+
| **iOS**         | Running on iOS                                         |
+-----------------+--------------------------------------------------------+
| **UWP**         | Running on UWP                                         |
+-----------------+--------------------------------------------------------+
| **Windows**     | Running on Windows                                     |
+-----------------+--------------------------------------------------------+
| **X11**         | Running on X11 (Linux/BSD desktop)                     |
+-----------------+--------------------------------------------------------+
| **Server**      | Running on the headless server platform                |
+-----------------+--------------------------------------------------------+
| **debug**       | Running on a debug build (including the editor)        |
+-----------------+--------------------------------------------------------+
| **release**     | Running on a release build                             |
+-----------------+--------------------------------------------------------+
| **editor**      | Running on an editor build                             |
+-----------------+--------------------------------------------------------+
| **standalone**  | Running on a non-editor build                          |
+-----------------+--------------------------------------------------------+
| **64**          | Running on a 64-bit build (any architecture)           |
+-----------------+--------------------------------------------------------+
| **32**          | Running on a 32-bit build (any architecture)           |
+-----------------+--------------------------------------------------------+
| **x86_64**      | Running on a 64-bit x86 build                          |
+-----------------+--------------------------------------------------------+
| **x86**         | Running on a 32-bit x86 build                          |
+-----------------+--------------------------------------------------------+
| **arm64**       | Running on a 64-bit ARM build                          |
+-----------------+--------------------------------------------------------+
| **arm**         | Running on a 32-bit ARM build                          |
+-----------------+--------------------------------------------------------+
| **mobile**      | Host OS is a mobile platform                           |
+-----------------+--------------------------------------------------------+
| **pc**          | Host OS is a PC platform (desktop/laptop)              |
+-----------------+--------------------------------------------------------+
| **web**         | Host OS is a Web browser                               |
+-----------------+--------------------------------------------------------+
| **etc**         | Textures using ETC1 compression are supported          |
+-----------------+--------------------------------------------------------+
| **etc2**        | Textures using ETC2 compression are supported          |
+-----------------+--------------------------------------------------------+
| **s3tc**        | Textures using S3TC (DXT/BC) compression are supported |
+-----------------+--------------------------------------------------------+
| **pvrtc**       | Textures using PVRTC compression are supported         |
+-----------------+--------------------------------------------------------+

.. warning::

    With the exception of texture compression feature tags, default feature tags
    are **immutable**. This means that they will *not* change depending on
    run-time conditions. For example, ``OS.has_feature("mobile")`` will return
    ``false`` when running a project exported to HTML5 on a mobile device.

    To check whether a project exported to HTML5 is running on a mobile device,
    :ref:`call JavaScript code <doc_javascript_eval>` that reads the browser's
    user agent.

Custom features
---------------

It is possible to add custom features to a build; use the relevant
field in the *export preset* used to generate it:

.. image:: img/feature_tags1.png

.. note::

    Custom feature tags are only used when running the exported project
    (including with :ref:`doc_one-click_deploy`). They are **not used** when
    running the project from the editor, even if the export preset marked as
    **Runnable** for your current platform has custom feature tags defined.

Overriding project settings
---------------------------

Features can be used to override specific configuration values in the *Project Settings*.
This allows you to better customize any configuration when doing a build.

In the following example, a different icon is added for the demo build of the game (which was
customized in a special export preset, which, in turn, includes only demo levels).

.. image:: img/feature_tags2.png

After overriding, a new field is added for this specific configuration:

.. image:: img/feature_tags3.png

.. note::

    When using the
    :ref:`project settings "override.cfg" functionality <class_ProjectSettings>`
    (which is unrelated to feature tags), remember that feature tags still apply.
    Therefore, make sure to *also* override the setting with the desired feature
    tag(s) if you want them to override base project settings on all platforms
    and configurations.

Default overrides
-----------------

There are already a lot of settings that come with overrides by default; they can be found
in many sections of the project settings.

.. image:: img/feature_tags4.png

Customizing the build
---------------------

Feature tags can be used to customize a build process too, by writing a custom **ExportPlugin**.
They are also used to specify which shared library is loaded and exported in **GDNative**.


===================================================
/. ./tutorials/export/exporting_for_linux.rst
===================================================

.. _doc_exporting_for_linux:

Exporting for Linux
===================

.. seealso::

    This page describes how to export a Godot project to Linux.
    If you're looking to compile editor or export template binaries from source instead,
    read :ref:`doc_compiling_for_x11`.

The simplest way to distribute a game for PC is to copy the executable
(``godot``), compress the folder and send it to someone else. However, this is
often not desired.

Godot offers a more elegant approach for PC distribution when using the export
system. When exporting for Linux, the exporter takes all the project files and
creates a ``data.pck`` file. This file is bundled with a specially optimized
binary that is smaller, faster and does not contain the editor and debugger.


===================================================
/. ./tutorials/export/exporting_for_macos.rst
===================================================

.. _doc_exporting_for_macos:

Exporting for macOS
===================

.. seealso::

    This page describes how to export a Godot project to macOS.
    If you're looking to compile editor or export template binaries from source instead,
    read :ref:`doc_compiling_for_osx`.

macOS apps are exported as an ``.app`` bundle, a folder with a specific structure which stores the executable, libraries and all the project files.
This bundle can be exported as is, packed in a ZIP archive or DMG disk image (only supported when exporting from a computer running macOS).

Requirements
------------

-  To enable code signing with Apple Developer ID and notarization, you must export from a computer running macOS with Xcode command line tools installed.
-  Ad-hoc code signing is supported on all platforms, without additional tools.
-  Download the Godot export templates. Use the Godot menu: ``Editor > Manage Export Templates``.
-  A valid and unique ``Bundle identifier`` should be set in the ``Application`` section of the export options.

.. warning::

    Projects exported without code signing and notarization will be blocked by Gatekeeper if they are downloaded from unknown sources, see the :ref:`Running Godot apps on macOS <doc_running_on_macos>` page for more information.

Code signing and notarization
-----------------------------

By default, macOS will run only applications that are signed and notarized. If you use any other signing configuration, see :ref:`Running Godot apps on macOS <doc_running_on_macos>` for workarounds.

To notarize an app, you **must** have a valid `Apple Developer ID Certificate <https://developer.apple.com/>`__.

If you have an Apple Developer ID Certificate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Export your project from a computer running macOS with Xcode command line tools installed.
- Enable ``Code Signing``, ``Notarization``, ``Hardened Runtime`` and ``Timestamp`` and disable the ``Debug`` entitlement.
- Provide valid Apple ID credentials and certificate identity.

If ``Notarization`` is enabled, Godot will automatically upload the exported project for notarization.

You can use the ``xcrun notarytool history`` command to check notarization status and use the ``xcrun notarytool log {ID}`` command to download the notarization log.

If you encounter notarization issues, see `Resolving common notarization issues <https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/resolving_common_notarization_issues>`__ for more info.

After notarization is completed, `staple the ticket <https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/customizing_the_notarization_workflow>`__ to the exported project.

If you do not have an Apple Developer ID Certificate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Keep ``Code Signing`` enabled and leave the ``Identity`` option empty (when exporting from a computer running macOS, on other platforms this option is hidden).
In this case Godot will use a ad-hoc signature, which will make running an exported app easier for the end users, see the :ref:`Running Godot apps on macOS <doc_running_on_macos>` page for more information.

Signing Options
~~~~~~~~~~~~~~~

+------------------------------+---------------------------------------------------------------------------------------------------+
| Option                       | Description                                                                                       |
+==============================+===================================================================================================+
| Enable                       | Enables code signing.                                                                             |
+------------------------------+---------------------------------------------------------------------------------------------------+
| Identity                     | The "Full Name" or "Common Name" of the signing identity, store in the macOS keychain. [1]_ [2]_  |
+------------------------------+---------------------------------------------------------------------------------------------------+
| Timestamp                    | Requests a timestamp server to authenticate the time of signing. Required for notarization. [2]_  |
+------------------------------+---------------------------------------------------------------------------------------------------+
| Hardened Runtime             | Enables "Hardened Runtime". Required for notarization. [2]_                                       |
+------------------------------+---------------------------------------------------------------------------------------------------+
| Replace Existing Signature   | Replaces existing signatures of the GDNative libraries and embedded helper executables.           |
+------------------------------+---------------------------------------------------------------------------------------------------+

.. note::

    To notarize an app, you must enable the ``Hardened Runtime`` and ``Timestamp``.

    The ``Hardened Runtime`` and ``Timestamp`` options are incompatible with ad-hoc signing and will be ignored.

.. [1] Leave ``Identity`` option empty to use ad-hoc signature.
.. [2] This option is visible only when exporting from a computer running macOS.

Notarization Options
~~~~~~~~~~~~~~~~~~~~

+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Option             | Description                                                                                                                                                                  |
+====================+==============================================================================================================================================================================+
| Enable             | Enables automatic upload for notarization.                                                                                                                                   |
+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Apple ID Name      | Apple ID account name (email address)                                                                                                                                        |
+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Apple ID Password  | Apple ID app-specific password. See `Using app-specific passwords <https://support.apple.com/en-us/HT204397>`__ to enable two-factor authentication and create app password. |
+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Apple Team ID      | Team ID, if your Apple ID belongs to multiple teams                                                                                                                          |
+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

See `Notarizing macOS Software Before Distribution <https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution?language=objc>`__ for more info.

.. note::

    Notarization is supported when exporting from a computer running macOS, these options are hidden on other platforms.

Entitlements
------------

Hardened Runtime Entitlements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hardened Runtime entitlements manage security options and resource access policy.
See `Hardened Runtime <https://developer.apple.com/documentation/security/hardened_runtime?language=objc>`__ for more info.

+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Entitlement                           | Description                                                                                                                                                                                      |
+=======================================+==================================================================================================================================================================================================+
| Allow JIT Code Execution [3]_         | Allows creating writable and executable memory for JIT code. If you are using add-ons with dynamic or self-modifying native code, enable them according to the add-on documentation.             |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Allow Unsigned Executable Memory [3]_ | Allows creating writable and executable memory without JIT restrictions. If you are using add-ons with dynamic or self-modifying native code, enable them according to the add-on documentation. |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Allow DYLD Environment Variables [3]_ | Allows app to uss dynamic linker environment variables to inject code.  f you are using add-ons with dynamic or self-modifying native code, enable them according to the add-on documentation.   |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Disable Library Validation            | Allows app to load arbitrary libraries and frameworks. Enabled it if you are using GDNative add-ons and ad-hoc signature, or want to support user-provided external add-ons.                     |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Audio Input                           | Enable if you need to use the microphone or other audio input sources, if it's enabled you should also provide usage message in the `privacy/microphone_usage_description` option.               |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Camera                                | Enable if you need to use the camera, if it's enabled you should also provide usage message in the `privacy/camera_usage_description` option.                                                    |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Location                              | Enable if you need to use location information from Location Services, if it's enabled you should also provide usage message in the `privacy/location_usage_description` option.                 |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Address Book                          | [4]_ Enable to allow access contacts in the user's address book, if it's enabled you should also provide usage message in the `privacy/address_book_usage_description` option.                   |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Calendars                             | [4]_ Enable to allow access to the user's calendar, if it's enabled you should also provide usage message in the `privacy/calendar_usage_description` option.                                    |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Photo Library                         | [4]_ Enable to allow access to the user's Photos library, if it's enabled you should also provide usage message in the `privacy/photos_library_usage_description` option.                        |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Apple Events                          | [4]_ Enable to allow app to send Apple events to other apps.                                                                                                                                     |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Debugging                             | [5]_ You can temporarily enable this entitlement to use native debugger (GDB, LLDB) with the exported app. This entitlement should be disabled for production export.                            |
+---------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. [3] The ``Allow JIT Code Execution``, ``Allow Unsigned Executable Memory`` and ``Allow DYLD Environment Variables`` entitlements are always enabled for the Godot Mono exports, and are not visible in the export options.
.. [4] These features aren't supported by Godot out of the box, enable them only if you are using add-ons which require them.
.. [5] To notarize an app, you must disable the ``Debugging`` entitlement.

App Sandbox Entitlement
~~~~~~~~~~~~~~~~~~~~~~~

The App Sandbox restricts access to user data, networking and devices.
Sandboxed apps can't access most of the file system, can't use custom file dialogs and execute binaries (using ``OS.execute`` and ``OS.create_process``) outside the ``.app`` bundle.
See `App Sandbox <https://developer.apple.com/documentation/security/app_sandbox?language=objc>`__ for more info.

.. note::

    To distribute an app through the App Store, you must enable the App Sandbox.

+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Entitlement                       | Description                                                                                                                          |
+===================================+======================================================================================================================================+
| Enabled                           | Enables App Sandbox.                                                                                                                 |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Network Server                    | Enable to allow app to listen for incoming network connections.                                                                      |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Network Client                    | Enable to allow app to establish outgoing network connections.                                                                       |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Device USB                        | Enable to allow app to interact with USB devices. This entitlement is required to use wired controllers.                             |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Device Bluetooth                  | Enable to allow app to interact with Bluetooth devices. This entitlement is required to use wireless controllers.                    |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Files Downloads [6]_              | Allows read or write access to the user's "Downloads" folder.                                                                        |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Files Pictures [6]_               | Allows read or write access to the user's "Pictures" folder.                                                                         |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Files Music [6]_                  | Allows read or write access to the user's "Music" folder.                                                                            |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Files Movies [6]_                 | Allows read or write access to the user's "Movies" folder.                                                                           |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Files User Selected [6]_          | Allows read or write access to arbitrary folder. To gain access, a folder must be selected from the native file dialog by the user.  |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Helper Executable                 | List of helper executables to embedded to the app bundle. Sandboxed app are limited to execute only these executable.                |
+-----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+

.. [6] You can optionally provide usage messages for various folders in the `privacy/*_folder_usage_description` options.

You can override default entitlements by selecting custom entitlements file, in this case all other entitlement are ignored.


===================================================
/. ./tutorials/export/running_on_macos.rst
===================================================

.. _doc_running_on_macos:

Running Godot apps on macOS
===========================

.. seealso::

    This page covers running Godot projects on macOS.
    If you haven't exported your project yet, read :ref:`doc_exporting_for_macos` first.

By default, macOS will run only applications that are signed and notarized.

Depending on the way a macOS app is signed and distributed, the following scenarios are possible:

App is signed, notarized and distributed via App Store
------------------------------------------------------

.. note::

    App developers need to join the Apple Developer Program, and configure signing and notarization options during export, then upload the app to the App Store.

The app should run out of the box, without extra user interaction required.

App is signed, notarized and distributed outside App Store
----------------------------------------------------------

.. note::

    App developers need to join the Apple Developer Program, and configure signing and notarization options during export, then distribute the app as ".DMG" or ".ZIP" archive.

When you run the app for the first time, the following dialog is displayed:

.. image:: img/signed_and_notarized_0.png

Click ``Open`` to start the app.

If you see the following warning dialog, your Mac is set up to allow apps only from the App Store.

.. image:: img/signed_and_notarized_1.png

To allow third-party apps, open ``System Preferences``, click ``Security & Privacy``, then click ``General``, unlock settings, and select ``App Store and identified developers``.

.. image:: img/sys_pref_0.png

App is signed (including ad-hoc signatures) but not notarized
-------------------------------------------------------------

.. note::

    App developer used self-signed certificate or ad-hoc signing (default Godot behavior for exported project).

When you run the app for the first time, the following dialog is displayed:

.. image:: img/signed_0.png

To run this app, you can temporarily override Gatekeeper:

* Either open ``System Preferences``, click ``Security & Privacy``, then click ``General``, and click ``Open Anyway``.

  .. image:: img/sys_pref_1.png

* Or, right-click (Control-click) on the app icon in the Finder window and select ``Open`` from the menu.

  .. image:: img/signed_1.png

* Then click ``Open`` in the confirmation dialog.

  .. image:: img/signed_2.png

* Enter your password if you're prompted.

App is not-signed, executable is linker-signed
----------------------------------------------

.. note::

    App is built using official export templates, but it is not signed.

When you run the app for the first time, the following dialog is displayed:

.. image:: img/linker_signed_1.png

To run this app, you should remove the quarantine extended file attribute manually:

* Open ``Terminal.app`` (press ``Cmd + Space``, and enter ``Terminal``).

* Navigate to the folder containing the target application.

  Use the ``cd path_to_the_app_folder`` command, e.g. ``cd ~/Downloads/`` if it's in the ``Downloads`` folder.

* Run the command ``xattr -dr com.apple.quarantine "Unsigned Game.app"`` (including quotation marks and ``.app`` extension).

Neither app nor executable is signed (relevant for Apple Silicon macs only)
---------------------------------------------------------------------------

.. note::

    App is built using custom export templates, compiled using OSXCross, and it is not signed at all.

When you run the app for the first time, the following dialog is displayed:

.. image:: img/unsigned_1.png

To run this app, you can ad-hoc sign it yourself:

* Install ``Xcode`` for the App Store, start it and confirm command line tools installation.

* Open ``Terminal.app`` (press ``Cmd + Space``, and enter ``Terminal``).

* Navigate to the folder containing the target application.

  Use the ``cd path_to_the_app_folder`` command, e.g. ``cd ~/Downloads/`` if it's in the ``Downloads`` folder.

* Run the following commands:

  ``xattr -dr com.apple.quarantine "Unsigned Game.app"`` (including quotation marks and ".app" extension).

  ``codesign -s - --force --deep "Unsigned Game.app"`` (including quotation marks and ".app" extension).


===================================================
/. ./tutorials/export/exporting_for_windows.rst
===================================================

.. _doc_exporting_for_windows:

Exporting for Windows
=====================

.. seealso::

    This page describes how to export a Godot project to Windows.
    If you're looking to compile editor or export template binaries from source instead,
    read :ref:`doc_compiling_for_windows`.

The simplest way to distribute a game for PC is to copy the executable
(``godot.exe``), compress the folder and send it to someone else. However, this
is often not desired.

Godot offers a more elegant approach for PC distribution when using the export
system. When exporting for Windows, the exporter takes all the project files and
creates a ``data.pck`` file. This file is bundled with a specially optimized
binary that is smaller, faster and does not contain the editor and debugger.

Requirements
------------

-  To enable code signing, you must have the ``Windows 10 SDK`` (on Windows) or `osslsigncode <https://github.com/mtrojnar/osslsigncode>`__ (on any other OS) installed.
-  Download the Godot export templates. Use the Godot menu: ``Editor > Manage Export Templates``.

.. warning::

    If you export for Windows with embedded PCK files, you will not be able to
    sign the program as it will break.

    On Windows, PCK embedding is also known to cause false positives in
    antivirus programs. Therefore, it's recommended to avoid using it unless
    you're distributing your project via Steam as it bypasses code signing and
    antivirus checks.


===================================================
/. ./tutorials/export/changing_application_icon_for_windows.rst
===================================================

.. _doc_changing_application_icon_for_windows:

Changing application icon for Windows
=====================================

By default, the exported project's icon will be the Godot icon.
You will most likely want to change that for your project. There are two types
of icons that can be changed on Windows: the file icon and the taskbar icon.

Creating an ICO file
--------------------

Windows does not use formats such as png or jpg for application icons. Instead,
it uses a Windows-only format called ICO. You can create your application icon
in any program but you will have to convert it to an ICO file using a program such
as GIMP.

`This video tutorial <https://www.youtube.com/watch?v=uqV3UfM-n5Y>`_ goes over how to
export an ICO file with GIMP.

It is also possible to convert a PNG image to an hiDPI-friendly ICO file
using this `ImageMagick <https://www.imagemagick.org/>`_ command:

.. code-block:: none

    magick convert icon.png -define icon:auto-resize=256,128,64,48,32,16 icon.ico

Depending on which version of ImageMagick you installed, you might need to leave out the ``magick`` and run this command instead:

.. code-block:: none

    convert icon.png -define icon:auto-resize=256,128,64,48,32,16 icon.ico

.. warning::

    For the ICO file to effectively replace the default Godot icon, it must
    contain *all* the sizes included in the default Godot icon: 16×16, 32×32,
    48×48, 64×64, 128×128, 256×256. If the ICO file does not contain all the sizes,
    the default Godot icon will be kept for the sizes that weren't overridden.

    The above ImageMagick command takes this into account.

Changing the taskbar icon
-------------------------

The taskbar icon is the icon that shows up on the taskbar when your project
is running.

.. image:: img/icon_taskbar_icon.png

To change the taskbar icon, go to
**Project → Project Settings → Application → Config → Windows Native Icon**.
Click on the folder icon and select your ICO file.

.. image:: img/icon_project_settings.png

This setting only changes the icon for your exported game on Windows.
To set the icon for macOS, use ``Macos Native Icon``. And for any other platform,
use the ``Icon`` setting.

Changing the file icon
----------------------

In Godot 3.5 and later, you can change the file icon without
external tools using `godoticon <https://github.com/pkowal1982/godoticon>`__.
Changing the file icon this way should work for executables containing
an embedded PCK.

.. warning::

    There are `known issues <https://github.com/godotengine/godot/issues/33466>`__
    when changing the application icon in executables that embed a PCK file.
    It's recommended to avoid using rcedit for now if you choose to enable the
    **Embed Pck** option for your Windows export preset in the Export dialog.

The file icon is the icon of the executable that you click on to start
the project.

.. image:: img/icon_file_icon.png

Before selecting it in the export options, you will need to install
an extra tool called **rcedit**.
You can download it `here <https://github.com/electron/rcedit/releases>`_.

After downloading, you need to tell Godot the path to the rcedit executable
on your computer.
Go to **Editor → Editor Settings → Export → Windows**.
Click on the folder icon for the **rcedit** entry.
Navigate to and select the rcedit executable.

.. note::

    Linux and macOS users will also need to install
    `WINE <https://www.winehq.org/>`_ to use rcedit.

.. image:: img/icon_rcedit.png

You should now have everything in place to change the file icon.
To do that, you will need to specify the icon when exporting.
Go to **Project → Export**. Assuming you have already created
a Windows Desktop preset, select your icon in ICO format in
the **Application → Icon** field.

.. image:: img/icon_export_settings.png

.. note::

    If rcedit fails to change the icon, you can instead
    :ref:`compile your own Windows export templates <doc_compiling_for_windows>`
    with the icon changed. To do so, replace
    `platform/windows/godot.ico <https://github.com/godotengine/godot/blob/master/platform/windows/godot.ico>`__
    with your own ICO file *before* compiling export templates.

    Once this is done, you can specify your export templates as custom export
    templates in your project's Windows export preset.

Testing the result
------------------

You can now export the project. If it worked correctly, you should see this:

.. image:: img/icon_result.png

.. note::

    If your icon isn't showing up properly, on Windows 10, try clearing the icon
    cache. To do so, open the **Run** dialog and enter ``ie4uinit.exe
    -ClearIconCache`` or ``ie4uinit.exe -show``.


===================================================
/. ./tutorials/export/exporting_for_uwp.rst
===================================================

.. _doc_exporting_for_uwp:

Exporting for Universal Windows Platform
========================================

.. seealso::

    This page describes how to export a Godot project to UWP.
    If you're looking to compile export template binaries from source instead,
    read :ref:`doc_compiling_for_uwp`.

There's no extra requirement to export an ``.appx`` package that can be
installed as a Windows App or submitted to the Windows Store. Exporting UWP
packages also works from any platform, not only from Windows.

However, if you want to install and run the app, you need to sign it with a
trusted signature. Godot supports automatic signing of packages with
external tools.

Also, make sure the Publisher Name you set when exporting the package matches
the name used on the certificate.

Limitations on Xbox One
-----------------------

As described in the `UWP documentation <https://docs.microsoft.com/en-us/windows/uwp/xbox-apps/system-resource-allocation>`__:

- Submitted as an "App"
    - available memory is 1GB
    - share of 2-4 CPU cores
    - shared access of GPU power (45%)

- Submitted as a "Game" (through `Xbox Live Creators Program <https://www.xbox.com/en-US/developers/creators-program>`__)
    - available memory is 5GB
    - 4 exclusive CPU cores and 2 shared CPU cores
    - exclusive access to GPU power (100%)

- Exceeding these memory limitations will cause allocation failures and the application will crash.

Creating a signing certificate
------------------------------

This requires the ``MakeCert.exe`` and ``Pvk2Pfx.exe`` tools, which come with
the Windows SDK. If you use Visual Studio, you can open one of its Developer
Prompts, since it comes with these tools and they can be located in the path.

You can get more detailed instructions from `Microsoft's documentation
<https://msdn.microsoft.com/en-us/library/windows/desktop/jj835832(v=vs.85).aspx>`__.

First, run ``MakeCert`` to create a private key::

    MakeCert /n publisherName /r /h 0 /eku "1.3.6.1.5.5.7.3.3,1.3.6.1.4.1.311.10.3.13" /e expirationDate /sv MyKey.pvk MyKey.cer

Where ``publisherName`` matches the Publisher Name of your package and
``expirationDate`` is in the ``mm/dd/yyyy`` format.

Next, create a Personal Information Exchange (.pfx) file using ``Pvk2Pfx.exe``::

    Pvk2Pfx /pvk MyKey.pvk /pi pvkPassword /spc MyKey.cer /pfx MyKey.pfx [/po pfxPassword]

If you don't specify a password with ``/po`` argument, the PFX will have the
same password as the private key.

You will also need to trust this certificate in order to be able to install your
app. Open the Command Prompt as Administrator and run the following command::

    Certutil -addStore TrustedPeople MyKey.cer

Setting up automatic signing
----------------------------

To setup automatic signing on export you need to go to Editor Settings > Export > Uwp.
From there you need to click on the folder for ``Signtool``, and navigate to
the ``SignTool.exe`` file on your computer.

.. image:: img/UWP_sign_tool.png

After setting that up close the editor settings, go to Project > Export,
and select the UWP preset. Under the ``Signing`` options click on the folder
next to ``Certificate`` and go to the certificate file. Then enter the
pfxPassword in the password field.

.. image:: img/UWP_export_signing.png

Your project will now be automatically signed on export.

If you want to sign an exported app manually run ``SignTool.exe`` and use the
following command.

    SignTool sign /fd SHA256 /a /f MyKey.pfx /p pfxPassword package.appx

Installing the package
----------------------

As of the Windows 10 Anniversary Update, you are able to install packages simply by
double clicking the ``.appx`` file from Windows Explorer.

It's also possible to install by using the ``Add-AppxPackage`` PowerShell cmdlet.

.. note:: If you want to update your already installed app, you must
          update the version number on the new package or first uninstall
          the previous package.


===================================================
/. ./tutorials/export/exporting_for_ios.rst
===================================================

.. _doc_exporting_for_ios:

Exporting for iOS
=================

.. seealso::

    This page describes how to export a Godot project to iOS.
    If you're looking to compile export template binaries from source instead,
    read :ref:`doc_compiling_for_ios`.

These are the steps to load a Godot project in Xcode. This allows you to
build and deploy to an iOS device, build a release for the App Store, and
do everything else you can normally do with Xcode.

Requirements
------------

-  You must export for iOS from a computer running macOS with Xcode installed.
-  Download the Godot export templates. Use the Godot menu: Editor > Manage Export Templates

Export a Godot project to Xcode
-------------------------------

In the Godot editor, open the **Export** window from the **Project** menu. When the
Export window opens, click **Add..** and select **iOS**.

The **App Store Team ID** and (Bundle) **Identifier** options in the **Application** category
are required. Leaving them blank will cause the exporter to throw an error.

After you click **Export Project**, there are still two important options left:

  * **Path** is an empty folder that will contain the exported Xcode project files.
  * **File** will be the name of the Xcode project and several project specific files and directories.

.. image:: img/ios_export_file.png

.. note:: This tutorial uses **exported_xcode_project_name**, but you will use your
          project's name. When you see **exported_xcode_project_name**
          in the following steps, replace it with the name you used instead.

.. note:: Avoid using spaces when you choose your **exported_xcode_project_name** as
          this can lead to corruption in your XCode project file.

When the export completes, the output folder should look like this:

.. image:: img/ios_export_output.png

Opening **exported_xcode_project_name.xcodeproj** lets you build and deploy
like any other iOS app.

Active development considerations
---------------------------------

The above method creates an exported project that you can build for
release, but you have to re-export every time you make a change in Godot.

While developing, you can speed this process up by linking your
Godot project files directly into your app.

In the following example:

  * **exported_xcode_project_name** is the name of the exported iOS application (as above).
  * **godot_project_to_export** is the name of the Godot project.

.. note:: **godot_project_to_export** must not be the same as **exported_xcode_project_name**
          to prevent signing issues in Xcode.

Steps to link a Godot project folder to Xcode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Start from an exported iOS project (follow the steps above).
2. In Finder, drag the Godot project folder into the Xcode file browser.

.. image:: img/ios_export_add_dir.png

3. In the dialog, make sure **Create folder references** is selected. This means
you will be able to continue to edit your Godot project in its current location.

.. image:: img/ios_export_file_ref.png

4. See the **godot_project_to_export** folder in the Xcode file browser.
5. Delete **exported_xcode_project_name.pck** from the Xcode project.

.. image:: img/ios_export_delete_pck.png

6. Open **exported_xcode_project_name-Info.plist** and add a string property named
**godot_path** (this is the real key name) with a value **godot_project_to_export**
(this is the name of your project)

.. image:: img/ios_export_set_path.png

That's it! You can now edit your project in the Godot editor and build it
in Xcode when you want to run it on a device.

Plugins for iOS
---------------

Special iOS plugins can be used in Godot. Check out the
:ref:`doc_plugins_for_ios` page.

Troubleshooting rendering issues
--------------------------------

To improve out-of-the-box performance on mobile devices, Godot automatically
uses low-end-friendly settings by default on both Android and iOS.

This can cause rendering issues that do not occur when running the project on a
desktop platform. See :ref:`doc_mobile_rendering_limitations` for more information.


===================================================
/. ./tutorials/export/exporting_for_android.rst
===================================================

.. _doc_exporting_for_android:

Exporting for Android
=====================


.. seealso::

    This page describes how to export a Godot project to Android.
    If you're looking to compile export template binaries from source instead,
    read :ref:`doc_compiling_for_android`.

Exporting for Android has fewer requirements than compiling Godot for Android.
The following steps detail what is needed to set up the Android SDK and the engine.

Install OpenJDK 11
------------------

Download and install  `OpenJDK 11 <https://adoptium.net/?variant=openjdk11>`__.

Download the Android SDK
------------------------

Download and install the Android SDK.

- You can install it using `Android Studio version 4.1 or later <https://developer.android.com/studio/>`__.

  - Run it once to complete the SDK setup using these `instructions <https://developer.android.com/studio/intro/update#sdk-manager>`__.
  - Ensure that the `required packages <https://developer.android.com/studio/intro/update#recommended>`__ are installed as well.

    - Android SDK Platform-Tools version 30.0.5 or later
    - Android SDK Build-Tools version 30.0.3
    - Android SDK Platform 31
    - Android SDK Command-line Tools (latest)
    - CMake version 3.10.2.4988404
    - NDK version r23c (23.2.8568313)

- You can install it using the `command line tools <https://developer.android.com/studio/#command-tools>`__.

  - Once the command line tools are installed, run the `sdkmanager <https://developer.android.com/studio/command-line/sdkmanager>`__ command to complete the setup process:

::

    sdkmanager --sdk_root=<android_sdk_path> "platform-tools" "build-tools;30.0.3" "platforms;android-31" "cmdline-tools;latest" "cmake;3.10.2.4988404" "ndk;21.4.7075529"

.. note::

    If you are using Linux,
    **do not use an Android SDK provided by your distribution's repositories as it will often be outdated**.


Create a debug.keystore
-----------------------

Android needs a debug keystore file to install to devices and distribute
non-release APKs. If you have used the SDK before and have built
projects, ant or eclipse probably generated one for you (in the ``~/.android`` directory on Linux and
macOS, in the ``C:\Users\<user>\.android\`` directory on Windows).

If you can't find it or need to generate one, the keytool command from
the JDK can be used for this purpose::

    keytool -keyalg RSA -genkeypair -alias androiddebugkey -keypass android -keystore debug.keystore -storepass android -dname "CN=Android Debug,O=Android,C=US" -validity 9999 -deststoretype pkcs12

This will create a ``debug.keystore`` file in your current directory. You should move it to a memorable location such as ``%USERPROFILE%\.android\``, because you will need its location in a later step. For more information on ``keytool`` usage, see `this Q&A article <https://godotengine.org/qa/21349/jdk-android-file-missing>`__.

Setting it up in Godot
----------------------

Enter the Editor Settings screen. This screen contains the editor
settings for the user account in the computer (it's independent of the
project).

.. image:: img/editorsettings.png

Scroll down to the section where the Android settings are located:

.. image:: img/androidsdk.png

In that screen, 2 paths need to be set:

- The ``Android Sdk Path`` should be the location where the Android SDK was installed.
  - For example ``%LOCALAPPDATA%\Android\Sdk\`` on Windows or ``/Users/$USER/Library/Android/sdk/`` on macOS.

- The debug ``.keystore`` file
  - It can be found in the folder where you put the ``debug.keystore`` file you created above.

Once that is configured, everything is ready to export to Android!

.. note::

    If you get an error saying *"Could not install to device."*, make sure
    you do not have an application with the same Android package name already
    installed on the device (but signed with a different key).

    If you have an application with the same Android package name but a
    different signing key already installed on the device, you **must** remove
    the application in question from the Android device before exporting to
    Android again.

Providing launcher icons
------------------------

Launcher icons are used by Android launcher apps to represent your application to users. Godot only requires high-resolution icons (for ``xxxhdpi`` density screens) and will automatically generate lower-resolution variants.

There are two types of icons required by Godot:

- **Main Icon:** The "classic" icon. This will be used on all Android versions up to Android 8 (Oreo), exclusive. Must be at least 192×192 px.
- **Adaptive Icons:** Starting from Android 8 (inclusive), `Adaptive Icons <https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive>`_ were introduced. Applications will need to include separate background and foreground icons to have a native look. The user's launcher application will control the icon's animation and masking. Must be at least 432×432 px.

.. seealso:: It's important to adhere to some rules when designing adaptive icons. `Google Design has provided a nice article <https://medium.com/google-design/designing-adaptive-icons-515af294c783>`_ that helps to understand those rules and some of the capabilities of adaptive icons.

.. caution:: The most important adaptive icon design rule is to have your icon critical elements inside the safe zone: a centered circle with a diameter of 66dp (264 pixels on ``xxxhdpi``) to avoid being clipped by the launcher.

If you don't provide some of the requested icons, Godot will replace them using a fallback chain, trying the next in line when the current one fails:

- **Main Icon:** Provided main icon -> Project icon -> Default Godot main icon.
- **Adaptive Icon Foreground:** Provided foreground icon -> Provided main icon -> Project icon -> Default Godot foreground icon.
- **Adaptive Icon Background:** Provided background icon -> Default Godot background icon.

It's highly recommended to provide all the requested icons with their specified resolutions.
This way, your application will look great on all Android devices and versions.

Exporting for Google Play Store
-------------------------------

Uploading an APK to Google's Play Store requires you to sign using a non-debug
keystore file; such file can be generated like this:

.. code-block:: shell

    keytool -v -genkey -keystore mygame.keystore -alias mygame -keyalg RSA -validity 10000

This keystore and key are used to verify your developer identity, remember the password and keep it in a safe place!
Use Google's Android Developer guides to learn more about `APK signing <https://developer.android.com/studio/publish/app-signing>`__.

Now fill in the following forms in your Android Export Presets:

.. image:: img/editor-export-presets-android.png

- **Release:** Enter the path to the keystore file you just generated.
- **Release User:** Replace with the key alias.
- **Release Password:** Key password. Note that the keystore password and the key password currently have to be the same.

**Your export_presets.cfg file now contains sensitive information.** If you use
a version control system, you should remove it from public repositories and add
it to your ``.gitignore`` file or equivalent.

Don't forget to uncheck the **Export With Debug** checkbox while exporting.

.. image:: img/export-with-debug-button.png

Optimizing the APK size
-----------------------

By default, the APK will contain native libraries for both ARMv7 and ARMv8
architectures. This increases its size significantly. To create a smaller APK,
uncheck either **Armeabi-v 7a** or **Arm 64 -v 8a** in your project's Android
export preset. This will create an APK that only contains a library for
a single architecture. Note that applications targeting ARMv7 can also run on
ARMv8 devices, but the opposite is not true.

Since August 2019, Google Play requires all applications to be available in
64-bit form. This means you cannot upload an APK that contains *just* an ARMv7
library. To solve this, you can upload several APKs to Google Play using its
`Multiple APK support <https://developer.android.com/google/play/publishing/multiple-apks>`__.
Each APK should target a single architecture; creating an APK for ARMv7
and ARMv8 is usually sufficient to cover most devices in use today.

You can optimize the size further by compiling an Android export template with
only the features you need. See :ref:`doc_optimizing_for_size` for more
information.

Troubleshooting rendering issues
--------------------------------

To improve out-of-the-box performance on mobile devices, Godot automatically
uses low-end-friendly settings by default on both Android and iOS.

This can cause rendering issues that do not occur when running the project on a
desktop platform. See :ref:`doc_mobile_rendering_limitations` for more information.


===================================================
/. ./tutorials/export/android_custom_build.rst
===================================================

.. _doc_android_custom_build:

Custom builds for Android
=========================

Godot provides the option to use custom build Android templates. Instead of
using the already pre-built template that ships with Godot, an actual Android
Java project gets installed into your project folder. Godot will then build it
and use it as an export template every time you export the project.

There are some reasons why you may want to do this:

* Modify the project before it's built.
* Add external SDKs that build with your project.

Configuring the custom build is a fairly straightforward process. But first
you need to follow the steps in :ref:`exporting for android<doc_exporting_for_android>`
up to **Setting it up in Godot**. After doing that, follow the steps below.

Set up the custom build environment
-----------------------------------

Go to the Project menu, and install the *Custom Build* template:

.. image:: img/custom_build_install_template.png

Make sure export templates are downloaded. If not, this menu will help you
download them.

A Gradle-based Android project will be created under ``res://android/build``.
Editing these files is not needed unless you want to :ref:`create
your own add-ons<doc_android_plugin>`, or you really need to modify the project.


Enabling the custom build and exporting
---------------------------------------

When setting up the Android project in the **Project > Export** dialog,
**Custom Build** needs to be enabled:

.. image:: img/custom_build_enable.png

From now on, attempting to export the project or one-click deploy will call the
`Gradle <https://gradle.org/>`__ build system to generate fresh templates (this
window will appear every time):

.. image:: img/custom_build_gradle.png

The templates built will be used automatically afterwards, so no further
configuration is needed.


===================================================
/. ./tutorials/export/exporting_for_web.rst
===================================================

.. _doc_exporting_for_web:

Exporting for the Web
=====================

.. seealso::

    This page describes how to export a Godot project to HTML5.
    If you're looking to compile editor or export template binaries from source instead,
    read :ref:`doc_compiling_for_web`.

HTML5 export allows publishing games made in Godot Engine to the browser.
This requires support for `WebAssembly
<https://webassembly.org/>`__ and `WebGL <https://www.khronos.org/webgl/>`__
in the user's browser.

.. important:: Use the browser-integrated developer console, usually opened
               with :kbd:`F12`, to view **debug information** like JavaScript,
               engine, and WebGL errors.

.. attention:: `There are significant bugs when running HTML5 projects on iOS
               <https://github.com/godotengine/godot/issues?q=is:issue+is:open+label:platform:html5+ios>`__
               (regardless of the browser). We recommend using
               :ref:`iOS' native export functionality <doc_exporting_for_ios>`
               instead, as it will also result in better performance.

WebGL version
-------------

Depending on your choice of renderer, Godot can target WebGL 1.0 (*GLES2*) or
WebGL 2.0 (*GLES3*).

WebGL 1.0 is the recommended option if you want your project to be supported
on all browsers with the best performance.

Godot's GLES3 renderer targets high end devices, and the performance using
WebGL 2.0 can be subpar. Some features are also not supported in WebGL 2.0
specifically.

Additionally, while most browsers support WebGL 2.0, this is not yet the case
for **Safari**. WebGL 2.0 support is coming in Safari 15 for macOS, and is not
available yet for any **iOS** browser (all WebKit-based like Safari).
See `Can I use WebGL 2.0 <https://caniuse.com/webgl2>`__ for details.

.. _doc_javascript_export_options:

Export options
--------------

If a runnable web export template is available, a button appears between the
*Stop scene* and *Play edited Scene* buttons in the editor to quickly open the
game in the default browser for testing.

You can choose the **Export Type** to select which features will be available:

- *Regular*: is the most compatible across browsers, will not support threads,
  nor GDNative.
- *Threads*: will require the browser to support `SharedArrayBuffer
  <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer>`__.
  See `Can I use SharedArrayBuffer <https://caniuse.com/sharedarraybuffer>`__
  for details.
- *GDNative*: enables GDNative support but makes the binary bigger and slower
  to load.

If you plan to use :ref:`VRAM compression <doc_import_images>` make sure that
**Vram Texture Compression** is enabled for the targeted platforms (enabling
both **For Desktop** and **For Mobile** will result in a bigger, but more
compatible export).

If a path to a **Custom HTML shell** file is given, it will be used instead of
the default HTML page. See :ref:`doc_customizing_html5_shell`.

**Head Include** is appended into the ``<head>`` element of the generated
HTML page. This allows to, for example, load webfonts and third-party
JavaScript APIs, include CSS, or run JavaScript code.

.. important:: Each project must generate their own HTML file. On export,
               several text placeholders are replaced in the generated HTML
               file specifically for the given export options. Any direct
               modifications to that HTML file will be lost in future exports.
               To customize the generated file, use the **Custom HTML shell**
               option.

.. warning:: **Export types** other than *Regular* are not yet supported by the
             C# version.

Limitations
-----------

For security and privacy reasons, many features that work effortlessly on
native platforms are more complicated on the web platform. Following is a list
of limitations you should be aware of when porting a Godot game to the web.

.. _doc_javascript_secure_contexts:

.. important:: Browser vendors are making more and more functionalities only
               available in `secure contexts <https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts>`_,
               this means that such features are only be available if the web
               page is served via a secure HTTPS connection (localhost is
               usually exempt from such requirement).

.. tip:: Check the `list of open HTML5 issues on GitHub
         <https://github.com/godotengine/godot/issues?q=is:open+is:issue+label:platform:html5>`__
         to see if the functionality you're interested in has an issue yet. If
         not, open one to communicate your interest.

Using cookies for data persistence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Users must **allow cookies** (specifically IndexedDB) if persistence of the
``user://`` file system is desired. When playing a game presented in an
``iframe``, **third-party** cookies must also be enabled. Incognito/private
browsing mode also prevents persistence.

The method ``OS.is_userfs_persistent()`` can be used to check if the
``user://`` file system is persistent, but can give false positives in some
cases.

Background processing
~~~~~~~~~~~~~~~~~~~~~

The project will be paused by the browser when the tab is no longer the active
tab in the user's browser. This means functions such as ``_process()`` and
``_physics_process()`` will no longer run until the tab is made active again by
the user (by switching back to the tab). This can cause networked games to
disconnect if the user switches tabs for a long duration.

This limitation does not apply to unfocused browser *windows*. Therefore, on the
user's side, this can be worked around by running the project in a separate
*window* instead of a separate tab.

Threads
~~~~~~~

As mentioned :ref:`above <doc_javascript_export_options>` multi-threading is
only available if the appropriate **Export Type** is set and support for it
across browsers is still limited.

.. warning:: Requires a :ref:`secure context <doc_javascript_secure_contexts>`.
             Browsers also require that the web page is served with specific
             `cross-origin isolation headers <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy>`__.

GDNative
~~~~~~~~

As mentioned :ref:`above <doc_javascript_export_options>` GDNative is only
available if the appropriate **Export Type** is set.

The export will also copy the required GDNative ``.wasm`` files to the output
folder (and must be uploaded to your server along with your game).

Full screen and mouse capture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsers do not allow arbitrarily **entering full screen**. The same goes for
**capturing the cursor**. Instead, these actions have to occur as a response to
a JavaScript input event. In Godot, this means entering full screen from within
a pressed input event callback such as ``_input`` or ``_unhandled_input``.
Querying the :ref:`class_Input` singleton is not sufficient, the relevant
input event must currently be active.

For the same reason, the full screen project setting doesn't work unless the
engine is started from within a valid input event handler. This requires
:ref:`customization of the HTML page <doc_customizing_html5_shell>`.

Audio
~~~~~

Chrome restricts how websites may play audio. It may be necessary for the
player to click or tap or press a key to enable audio.

.. seealso:: Google offers additional information about their `Web Audio autoplay
             policies <https://sites.google.com/a/chromium.org/dev/audio-video/autoplay>`__.

.. warning:: Access to microphone requires a
             :ref:`secure context <doc_javascript_secure_contexts>`.

Networking
~~~~~~~~~~

Low level networking is not implemented due to lacking support in browsers.

Currently, only :ref:`HTTP client <doc_http_client_class>`,
:ref:`HTTP requests <doc_http_request_class>`,
:ref:`WebSocket (client) <doc_websocket>` and :ref:`WebRTC <doc_webrtc>` are
supported.

The HTTP classes also have several restrictions on the HTML5 platform:

 -  Accessing or changing the ``StreamPeer`` is not possible
 -  Threaded/Blocking mode is not available
 -  Cannot progress more than once per frame, so polling in a loop will freeze
 -  No chunked responses
 -  Host verification cannot be disabled
 -  Subject to `same-origin policy <https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy>`__

Clipboard
~~~~~~~~~

Clipboard synchronization between engine and the operating system requires a
browser supporting the `Clipboard API <https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API>`__,
additionally, due to the API asynchronous nature might not be reliable when
accessed from GDScript.

.. warning:: Requires a :ref:`secure context <doc_javascript_secure_contexts>`.

Gamepads
~~~~~~~~

Gamepads will not be detected until one of their button is pressed. Gamepads
might have the wrong mapping depending on the browser/OS/gamepad combination,
sadly the `Gamepad API <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API>`__
does not provide a reliable way to detect the gamepad information necessary
to remap them based on model/vendor/OS due to privacy considerations.

.. warning:: Requires a :ref:`secure context <doc_javascript_secure_contexts>`.

Boot splash is not displayed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The default HTML page does not display the boot splash while loading. However,
the image is exported as a PNG file, so :ref:`custom HTML pages <doc_customizing_html5_shell>`
can display it.

Shader language limitations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

When exporting a GLES2 project to HTML5, WebGL 1.0 will be used. WebGL 1.0
doesn't support dynamic loops, so shaders using those won't work there.

Serving the files
-----------------

Exporting for the web generates several files to be served from a web server,
including a default HTML page for presentation. A custom HTML file can be
used, see :ref:`doc_customizing_html5_shell`.

The generated ``.html`` file can be used as ``DirectoryIndex`` in Apache
servers and can be renamed to e.g. ``index.html`` at any time, its name is
never depended on by default.

The HTML page draws the game at maximum size within the browser window.
This way it can be inserted into an ``<iframe>`` with the game's size, as is
common on most web game hosting sites.

The other exported files are served as they are, next to the ``.html`` file,
names unchanged. The ``.wasm`` file is a binary WebAssembly module implementing
the engine. The ``.pck`` file is the Godot main pack containing your game. The
``.js`` file contains start-up code and is used by the ``.html`` file to access
the engine. The ``.png`` file contains the boot splash image. It is not used in
the default HTML page, but is included for
:ref:`custom HTML pages <doc_customizing_html5_shell>`.

The ``.pck`` file is binary, usually delivered with the MIME-type
:mimetype:`application/octet-stream`. The ``.wasm`` file is delivered as
:mimetype:`application/wasm`.

.. caution:: Delivering the WebAssembly module (``.wasm``) with a MIME-type
             other than :mimetype:`application/wasm` can prevent some start-up
             optimizations.

Delivering the files with server-side compression is recommended especially for
the ``.pck`` and ``.wasm`` files, which are usually large in size.
The WebAssembly module compresses particularly well, down to around a quarter
of its original size with gzip compression.

**Hosts that provide on-the-fly compression:** GitHub Pages (gzip)

**Hosts that don't provide on-the-fly compression:** itch.io, GitLab Pages
(`supports manual gzip precompression <https://webd97.de/post/gitlab-pages-compression/>`__)

.. _doc_javascript_eval:

Calling JavaScript from script
------------------------------

In web builds, the ``JavaScript`` singleton is implemented. It offers a single
method called ``eval`` that works similarly to the JavaScript function of the
same name. It takes a string as an argument and executes it as JavaScript code.
This allows interacting with the browser in ways not possible with script
languages integrated into Godot.

::

    func my_func():
        JavaScript.eval("alert('Calling JavaScript per GDScript!');")

The value of the last JavaScript statement is converted to a GDScript value and
returned by ``eval()`` under certain circumstances:

 * JavaScript ``number`` is returned as GDScript :ref:`class_float`
 * JavaScript ``boolean`` is returned as GDScript :ref:`class_bool`
 * JavaScript ``string`` is returned as GDScript :ref:`class_String`
 * JavaScript ``ArrayBuffer``, ``TypedArray`` and ``DataView`` are returned as
   GDScript :ref:`class_PoolByteArray`

::

    func my_func2():
        var js_return = JavaScript.eval("var myNumber = 1; myNumber + 2;")
        print(js_return) # prints '3.0'

Any other JavaScript value is returned as ``null``.

HTML5 export templates may be :ref:`built <doc_compiling_for_web>` without
support for the singleton to improve security. With such templates, and on
platforms other than HTML5, calling ``JavaScript.eval`` will also return
``null``. The availability of the singleton can be checked with the
``JavaScript`` :ref:`feature tag <doc_feature_tags>`::

    func my_func3():
        if OS.has_feature('JavaScript'):
            JavaScript.eval("""
                console.log('The JavaScript singleton is available')
            """)
        else:
            print("The JavaScript singleton is NOT available")

.. tip:: GDScript's multi-line strings, surrounded by 3 quotes ``"""`` as in
         ``my_func3()`` above, are useful to keep JavaScript code readable.

The ``eval`` method also accepts a second, optional Boolean argument, which
specifies whether to execute the code in the global execution context,
defaulting to ``false`` to prevent polluting the global namespace::

    func my_func4():
        # execute in global execution context,
        # thus adding a new JavaScript global variable `SomeGlobal`
        JavaScript.eval("var SomeGlobal = {};", true)


===================================================
/. ./tutorials/export/exporting_for_dedicated_servers.rst
===================================================

.. _doc_exporting_for_dedicated_servers:

Exporting for dedicated servers
===============================

If you want to run a dedicated server for your project on a machine that doesn't
have a GPU or display server available, you'll need to use a server build of Godot.

Platform support
----------------

- **Linux:** `Download an official Linux server binary <https://godotengine.org/download/3.x/server>`__.
  To compile a server binary from source, follow instructions in
  :ref:`doc_compiling_for_x11`.
- **macOS:** :ref:`Compile a server binary from source for macOS <doc_compiling_for_osx>`.
- **Windows:** There is no dedicated server build for Windows yet. As an alternative,
  you can use the ``--no-window`` command-line argument to prevent Godot from
  spawning a window. Note that even with the ``--no-window`` command-line argument,
  you'll need to have OpenGL support available on the Windows machine.

If your project uses C#, you'll have to use a Mono-enabled server binary.

"Headless" versus "server" binaries
-----------------------------------

The `server download page <https://godotengine.org/download/3.x/server>`__
offers two kinds of binaries with several differences.

- **Server:** Use this one for running dedicated servers. It does not contain
  editor functionality, and is therefore smaller and more
  optimized.
- **Headless:** This binary contains editor functionality and is intended to be
  used for exporting projects. This binary *can* be used to run dedicated
  servers, but it's not recommended as it's larger and less optimized.

Exporting a PCK file
--------------------

There are two ways to export a project for a server:

- Create a Linux/X11 export preset, define a custom Release export template
  that points to the server binary then export the project as usual.
- Export a PCK file only, preferably from a Linux/X11 export preset.

Both methods should result in identical output. The text below describes the PCK
file approach.

Once you've downloaded a server binary, you should export a PCK file containing
your project data. After creating the export preset, click **Export PCK/ZIP** at
the bottom of the Export dialog then choose a destination path.
The **Export With Debug** checkbox in the file dialog has no bearing on the
final PCK file, so you can leave it as-is.

See :ref:`doc_exporting_projects` for more information.

.. note::

    If you're exporting the project from a headless editor, call the headless
    editor with the `--export-pack` option while in the project folder to export
    only a PCK file.

.. note::

    The PCK file will include resources not normally needed by the server, such
    as textures and sounds. This means the PCK file will be larger than it could
    possibly be. Support for stripping unneeded resources from a PCK for server
    usage is planned in a future Godot release.

    On the bright side, this allows the same PCK file to be used both by a
    client and dedicated server build. This can be useful if you want to ship a
    single archive that can be used both as a client and dedicated server.

Preparing the server distribution
---------------------------------

After downloading or compiling a server binary, you should now place it in the
same folder as the PCK file you've exported. The server binary should have the
same name as the PCK (excluding the extension). This lets Godot detect and use
the PCK file automatically. If you want to start a server with a PCK that has a
different name, you can specify the path to the PCK file using the
``--main-pack`` command-line argument::

    ./godot-server --main-pack my_project.pck

Starting the dedicated server
-----------------------------

If both your client and server are part of the same Godot project, you will have
to add a way to start the server directly using a command-line argument. This
can be done by adding the following code snippet in your main scene (or a
singleton)'s ``_ready()`` method::

    if "--server" in OS.get_cmdline_args():
        # Run your server startup code here...
        # Using this check, you can start a dedicated server by running
        # a Godot binary (headless or not) with the `--server` command-line argument.
        pass

Alternatively, you can make the dedicated server always start up if a headless
or server binary is detected::

    # Note: Feature tags are case-sensitive! It's "Server", not "server".
    if OS.has_feature("Server"):
        # Run your server startup code here...
        # Note that using this check may break unit testing scripts when
        # running them with headless or server binaries.
        pass

If your client and server are separate Godot projects, your server should most
likely be configured in a way where running the main scene starts a server
automatically.

Next steps
----------

On Linux, to make your dedicated server restart after a crash or system reboot,
you can
`create a systemd service <https://medium.com/@benmorel/creating-a-linux-service-with-systemd-611b5c8b91d6>`__.
This also lets you view server logs in a more convenient fashion, with automatic
log rotation provided by systemd.

If you have experience with containers, you could also look into wrapping your
dedicated server in a `Docker <https://www.docker.com/>`__ container. This way,
it can be used more easily in an automatic scaling setup (which is outside the
scope of this tutorial).


===================================================
/. ./tutorials/export/one-click_deploy.rst
===================================================

.. _doc_one-click_deploy:

One-click deploy
================

What is one-click deploy?
-------------------------

One-click deploy is a feature that is available once a platform is properly
configured and a supported device is connected to the computer. Since things can
go wrong at many levels (platform may not be configured correctly, SDK may be
incorrectly installed, device may be improperly configured, etc.), it's good to
let the user know that it exists.

After adding an Android export preset marked as Runnable, Godot can detect when
a USB device is connected to the computer and offer the user to automatically
export, install and run the project (in debug mode) on the device. This feature
is called *one-click deploy*.

.. note::

   One-click deploy is only available once you've added an export template
   marked as **Runnable** in the Export dialog. You can mark several export
   presets as runnable, but only one preset per platform may be marked as
   runnable. If you mark a second preset in a given platform as runnable, the
   other preset will no longer be marked as runnable.

Supported platforms
-------------------

- **Android:** Exports the project with debugging enabled and runs it on the
  connected device.

   - Make sure to follow the steps described in :ref:`doc_exporting_for_android`.
     Otherwise, the one-click deploy button won't appear.

   - If you have more than one device connected, Godot will ask you which device
     the project should be exported to.

- **HTML5:** Starts a local web server and runs the exported project by opening
  the default web browser.

Support for more platforms such as iOS is planned.

Using one-click deploy
----------------------

- If deploying to Android, enable developer mode on your mobile device
  then enable USB debugging in the device's settings.
- After enabling USB debugging, connect the device to your PC using an USB cable.

   - For advanced users, it should also be possible to use wireless ADB.

- Make sure there is an export preset marked as **Runnable** for the target
  platform (Android or HTML5).
- If everything is configured correctly and with no errors, platform-specific
  icons will appear in the top-right corner of the editor.
- Click the button to export to the desired platform in one click.

.. image:: img/oneclick.png

Troubleshooting
---------------

Android
^^^^^^^

If you can't see the device in the list of devices when running the
``adb devices`` command in a terminal, it will not be visible by Godot either.
To resolve this:

- Check if USB debugging is enabled *and authorized on the device*.
  Try unlocking your device and accepting the authorization prompt if you see any.
  If you can't see this prompt, running ``adb devices`` on your PC should make
  the authorization prompt appear on the device.
- Try `revoking the debugging authorization <https://stackoverflow.com/questions/23081263/adb-android-device-unauthorized>`__
  in the device's developer settings, then follow the steps again.
- Try using USB debugging instead of wireless debugging or vice versa.
  Sometimes, one of those can work better than the other.
- On Linux, you may be missing the required
  `udev rules <https://github.com/M0Rf30/android-udev-rules>`__
  for your device to be recognized.


===================================================
/. ./tutorials/i18n/index.rst
===================================================

Internationalization
====================

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-i18n

   internationalizing_games
   localization_using_gettext
   locales


===================================================
/. ./tutorials/i18n/internationalizing_games.rst
===================================================

.. _doc_internationalizing_games:

Internationalizing games
========================

Introduction
------------

Sería excelente que el mundo hablara solo un idioma (It would be great if the
world spoke only one language). Unfortunately for
us developers, that is not the case. While indie or niche games usually
do not need localization, games targeting a more massive market
often require localization. Godot offers many tools to make this process
more straightforward, so this tutorial is more like a collection of
tips and tricks.

Localization is usually done by specific studios hired for the job and,
despite the huge amount of software and file formats available for this,
the most common way to do localization to this day is still with
spreadsheets. The process of creating the spreadsheets and importing
them is already covered in the :ref:`doc_importing_translations` tutorial,
so this one could be seen more like a follow-up to that one.


.. note:: We will be using the official demo as an example; you can
          `download it from the Asset Library <https://godotengine.org/asset-library/asset/134>`_.

Configuring the imported translation
------------------------------------

Translations can get updated and re-imported when they change, but
they still have to be added to the project. This is done in
**Project → Project Settings → Localization**:

.. image:: img/localization_dialog.png

The above dialog is used to add or remove translations project-wide.

Localizing resources
--------------------

It is also possible to instruct Godot to use alternate versions of
assets (resources) depending on the current language. The **Remaps** tab
can be used for this:

.. image:: img/localization_remaps.png

Select the resource to be remapped, then add some alternatives for each
locale.

Converting keys to text
-----------------------

Some controls, such as :ref:`Button <class_Button>` and :ref:`Label <class_Label>`,
will automatically fetch a translation if their text matches a translation key.
For example, if a label's text is "MAIN_SCREEN_GREETING1" and that key exists
in the current translation, then the text will automatically be translated.

This automatic translation behavior may be undesirable in certain cases. For
instance, when using a Label to display a player's name, you most likely don't
want the player's name to be translated if it matches a translation key. To
disable automatic translation on a specific node, use
:ref:`Object.set_message_translation<class_Object_method_set_message_translation>`
and send a :ref:`Object.notification<class_Object_method_notification>` to update the
translation::

    func _ready():
        # This assumes you have a node called "Label" as a child of the node
        # that has the script attached.
        var label = get_node("Label")
        label.set_message_translation(false)
        label.notification(NOTIFICATION_TRANSLATION_CHANGED)

For more complex UI nodes such as OptionButtons, you may have to use this instead::

    func _ready():
        var option_button = get_node("OptionButton")
        option_button.set_message_translation(false)
        option_button.notification(NOTIFICATION_TRANSLATION_CHANGED)
        option_button.get_popup().set_message_translation(false)
        option_button.get_popup().notification(NOTIFICATION_TRANSLATION_CHANGED)

In code, the :ref:`Object.tr() <class_Object_method_tr>`
function can be used. This will just look up the text in the
translations and convert it if found:

::

    level.set_text(tr("LEVEL_5_NAME"))
    status.set_text(tr("GAME_STATUS_" + str(status_index)))

Making controls resizable
--------------------------

The same text in different languages can vary greatly in length. For
this, make sure to read the tutorial on :ref:`doc_size_and_anchors`, as
dynamically adjusting control sizes may help.
:ref:`Container <class_Container>` can be useful, as well as the text wrapping
options available in :ref:`Label <class_Label>`.

TranslationServer
-----------------

Godot has a server handling low-level translation management
called the :ref:`TranslationServer <class_TranslationServer>`.
Translations can be added or removed during run-time;
the current language can also be changed at run-time.

Testing translations
--------------------

You may want to test a project's translation before releasing it. Godot provides two ways
to do this.

First, in the Project Settings, under **Input Devices > Locale**, there is a **Test**
property. Set this property to the locale code of the language you want to test. Godot will
run the project with that locale when the project is run (either from the editor or when
exported).

.. image:: img/locale_test.png

Keep in mind that since this is a project setting, it will show up in version control when
it is set to a non-empty value. Therefore, it should be set back to an empty value before
committing changes to version control.

Translations can also be tested when running Godot from the command line.
For example, to test a game in French, the following argument can be
supplied:

.. code-block:: shell

   godot --language fr

Translating the project name
----------------------------

The project name becomes the app name when exporting to different
operating systems and platforms. To specify the project name in more
than one language, create a new setting ``application/name`` in the **Project
Settings** and append the locale identifier to it.
For instance, for Spanish, this would be ``application/name_es``:

.. image:: img/localized_name.png

If you are unsure about the language code to use, refer to the
:ref:`list of locale codes <doc_locales>`.


===================================================
/. ./tutorials/i18n/localization_using_gettext.rst
===================================================

.. _doc_localization_using_gettext:

Localization using gettext
==========================

In addition to :ref:`doc_importing_translations` in CSV format, Godot
also supports loading translation files written in the GNU gettext
format (text-based ``.po`` and compiled ``.mo`` since Godot 3.5).

.. note:: For an introduction to gettext, check out
          `A Quick Gettext Tutorial <https://www.labri.fr/perso/fleury/posts/programming/a-quick-gettext-tutorial.html>`_.
          It's written with C projects in mind, but much of the advice
          also applies to Godot (with the exception of ``xgettext``).

Advantages
----------

- gettext is a standard format, which can be edited using any text editor
  or GUI editors such as `Poedit <https://poedit.net/>`_.
- gettext is supported by translation platforms such as
  `Transifex <https://www.transifex.com/>`_ and `Weblate <https://weblate.org/>`_,
  which makes it easier for people to collaborate to localization.
- Compared to CSV, gettext works better with version control systems like Git,
  as each locale has its own messages file.
- Multiline strings are more convenient to edit in gettext files compared
  to CSV files.

Disadvantages
-------------

- gettext is a more complex format than CSV and can be harder to grasp for
  people new to software localization.
- People who maintain localization files will have to install gettext tools
  on their system. However, as Godot supports using text-based message files
  (``.po``), translators can test their work without having to install gettext tools.

Caveats
-------

- As Godot uses its own PO file parser behind the scenes
  (which is more limited than the reference GNU gettext implementation),
  some features such as pluralization aren't supported.

Installing gettext tools
------------------------

The command line gettext tools are required to perform maintenance operations,
such as updating message files. Therefore, it's strongly recommended to
install them.

- **Windows:** Download an installer from
  `this page <https://mlocati.github.io/articles/gettext-iconv-windows.html>`_.
  Any architecture and binary type (shared or static) works;
  if in doubt, choose the 64-bit static installer.
- **macOS:** Install gettext either using `Homebrew <https://brew.sh/>`_
  with the ``brew install gettext`` command, or using
  `MacPorts <https://www.macports.org/>`_ with the
  ``sudo port install gettext`` command.
- **Linux:** On most distributions, install the ``gettext`` package from
  your distribution's package manager.

Creating the PO template (POT) manually
---------------------------------------

Godot currently doesn't support extracting source strings using ``xgettext``,
so the ``.pot`` file must be created manually. This file can be placed anywhere
in the project directory, but it's recommended to keep it in a subdirectory, as
each locale will be defined in its own file.

Create a directory named `locale` in the project directory. In this directory,
save a file named ``messages.pot`` with the following contents:

::

    # Don't remove the two lines below, they're required for gettext to work correctly.
    msgid ""
    msgstr ""

    msgid "Hello world!"
    msgstr ""

Messages in gettext are made of ``msgid`` and ``msgstr`` pairs.
``msgid`` is the source string (usually in English), ``msgstr`` will be
the translated string.

The ``msgstr`` value in PO template files (``.pot``) should **always** be empty.
Localization will be done in the generated ``.po`` files instead.

Creating the PO template (POT) using pybabel
--------------------------------------------

The Python tool pybabel has support for Godot and can be used to automatically
create and update the POT file from your scene files and scripts.

After installing ``babel`` and ``babel-godot``, for example using pip:

.. code-block:: shell

    pip3 install babel babel-godot

Write a mapping file (for example ``babelrc``) which will indicate which files
pybabel needs to process (note that we process GDScript as Python, which is
generally sufficient):

.. code-block:: none

    [python: **.gd]
    encoding = utf-8

    [godot_scene: **.tscn]
    encoding = utf-8

You can then run pybabel like so:

.. code-block:: shell

    pybabel extract -F babelrc -k text -k LineEdit/placeholder_text -k tr -o godot-l10n.pot .

Use the ``-k`` option to specify what needs to be extracted. In this case,
arguments to :ref:`tr() <class_Object_method_tr>` will be translated, as well
as properties named "text" (commonly used by Control nodes) and LineEdit's
"placeholder_text" property.

Creating a messages file from a PO template
-------------------------------------------

The ``msginit`` command is used to turn a PO template into a messages file.
For instance, to create a French localization file, use the following command
while in the ``locale`` directory:

.. code-block:: shell

    msginit --no-translator --input=messages.pot --locale=fr

The command above will create a file named ``fr.po`` in the same directory
as the PO template.

Alternatively, you can do that graphically using Poedit, or by uploading the
POT file to your web platform of choice.

Loading a messages file in Godot
--------------------------------

To register a messages file as a translation in a project, open the
**Project Settings**, then go to the **Localization** tab.
In **Translations**, click **Add…** then choose the ``.po`` or ``.mo`` file
in the file dialog. The locale will be inferred from the
``"Language: <code>\n"`` property in the messages file.

.. note:: See :ref:`doc_internationalizing_games` for more information on
          importing and testing translations in Godot.

Updating message files to follow the PO template
------------------------------------------------

After updating the PO template, you will have to update message files so
that they contain new strings, while removing strings that are no longer
present in the PO template. This can be done automatically using the
``msgmerge`` tool:

.. code-block:: shell

    # The order matters: specify the message file *then* the PO template!
    msgmerge --update --backup=none fr.po messages.pot

If you want to keep a backup of the original message file (which would be
saved as ``fr.po~`` in this example), remove the ``--backup=none`` argument.

.. note::

    After running ``msgmerge``, strings which were modified in the source language
    will have a "fuzzy" comment added before them in the ``.po`` file. This comment
    denotes that the translation should be updated to match the new source string,
    as the translation will most likely be inaccurate until it's updated.

    Strings with "fuzzy" comments will **not** be read by Godot until the
    translation is updated and the "fuzzy" comment is removed.

Checking the validity of a PO file or template
----------------------------------------------

It is possible to check whether a gettext file's syntax is valid by running
the command below:

.. code-block:: shell

    msgfmt fr.po --check

If there are syntax errors or warnings, they will be displayed in the console.
Otherwise, ``msgfmt`` won't output anything.

Using binary MO files (useful for large projects only)
------------------------------------------------------

For large projects with several thousands of strings to translate or more,
it can be worth it to use binary (compiled) MO message files instead of text-based
PO files. Binary MO files are smaller and faster to read than the equivalent
PO files.

You can generate a MO file with the command below:

.. code-block:: shell

    msgfmt fr.po --no-hash -o fr.mo

If the PO file is valid, this command will create a ``fr.mo`` file besides
the PO file. This MO file can then be loaded in Godot as described below.

The original PO file should be kept in version control so you can update
your translation in the future. In case you lose the original PO file and
wish to decompile a MO file into a text-based PO file, you can do so with:

.. code-block:: shell

    msgunfmt fr.mo > fr.po

The decompiled file will not include comments or fuzzy strings, as these are
never compiled in the MO file in the first place.


===================================================
/. ./tutorials/i18n/locales.rst
===================================================

.. _doc_locales:

Locales
=======

.. Note: This list is synced with core/translation.cpp in the engine.

This is the list of supported locales and variants in the engine. It's
based on the Unix standard locale strings:

+--------------+------------------------------------+
| Locale       | Language and Variant               |
+==============+====================================+
| aa           | Afar                               |
+--------------+------------------------------------+
| aa_DJ        | Afar (Djibouti)                    |
+--------------+------------------------------------+
| aa_ER        | Afar (Eritrea)                     |
+--------------+------------------------------------+
| aa_ET        | Afar (Ethiopia)                    |
+--------------+------------------------------------+
| af           | Afrikaans                          |
+--------------+------------------------------------+
| af_ZA        | Afrikaans (South Africa)           |
+--------------+------------------------------------+
| agr_PE       | Aguaruna (Peru)                    |
+--------------+------------------------------------+
| ak_GH        | Akan (Ghana)                       |
+--------------+------------------------------------+
| am_ET        | Amharic (Ethiopia)                 |
+--------------+------------------------------------+
| an_ES        | Aragonese (Spain)                  |
+--------------+------------------------------------+
| anp_IN       | Angika (India)                     |
+--------------+------------------------------------+
| ar           | Arabic                             |
+--------------+------------------------------------+
| ar_AE        | Arabic (United Arab Emirates)      |
+--------------+------------------------------------+
| ar_BH        | Arabic (Bahrain)                   |
+--------------+------------------------------------+
| ar_DZ        | Arabic (Algeria)                   |
+--------------+------------------------------------+
| ar_EG        | Arabic (Egypt)                     |
+--------------+------------------------------------+
| ar_IQ        | Arabic (Iraq)                      |
+--------------+------------------------------------+
| ar_JO        | Arabic (Jordan)                    |
+--------------+------------------------------------+
| ar_KW        | Arabic (Kuwait)                    |
+--------------+------------------------------------+
| ar_LB        | Arabic (Lebanon)                   |
+--------------+------------------------------------+
| ar_LY        | Arabic (Libya)                     |
+--------------+------------------------------------+
| ar_MA        | Arabic (Morocco)                   |
+--------------+------------------------------------+
| ar_OM        | Arabic (Oman)                      |
+--------------+------------------------------------+
| ar_QA        | Arabic (Qatar)                     |
+--------------+------------------------------------+
| ar_SA        | Arabic (Saudi Arabia)              |
+--------------+------------------------------------+
| ar_SD        | Arabic (Sudan)                     |
+--------------+------------------------------------+
| ar_SS        | Arabic (South Sudan)               |
+--------------+------------------------------------+
| ar_SY        | Arabic (Syria)                     |
+--------------+------------------------------------+
| ar_TN        | Arabic (Tunisia)                   |
+--------------+------------------------------------+
| ar_YE        | Arabic (Yemen)                     |
+--------------+------------------------------------+
| as_IN        | Assamese (India)                   |
+--------------+------------------------------------+
| ast_ES       | Asturian (Spain)                   |
+--------------+------------------------------------+
| ayc_PE       | Southern Aymara (Peru)             |
+--------------+------------------------------------+
| ay_PE        | Aymara (Peru)                      |
+--------------+------------------------------------+
| az_AZ        | Azerbaijani (Azerbaijan)           |
+--------------+------------------------------------+
| be           | Belarusian                         |
+--------------+------------------------------------+
| be_BY        | Belarusian (Belarus)               |
+--------------+------------------------------------+
| bem_ZM       | Bemba (Zambia)                     |
+--------------+------------------------------------+
| ber_DZ       | Berber languages (Algeria)         |
+--------------+------------------------------------+
| ber_MA       | Berber languages (Morocco)         |
+--------------+------------------------------------+
| bg           | Bulgarian                          |
+--------------+------------------------------------+
| bg_BG        | Bulgarian (Bulgaria)               |
+--------------+------------------------------------+
| bhb_IN       | Bhili (India)                      |
+--------------+------------------------------------+
| bho_IN       | Bhojpuri (India)                   |
+--------------+------------------------------------+
| bi_TV        | Bislama (Tuvalu)                   |
+--------------+------------------------------------+
| bn           | Bengali                            |
+--------------+------------------------------------+
| bn_BD        | Bengali (Bangladesh)               |
+--------------+------------------------------------+
| bn_IN        | Bengali (India)                    |
+--------------+------------------------------------+
| bo           | Tibetan                            |
+--------------+------------------------------------+
| bo_CN        | Tibetan (China)                    |
+--------------+------------------------------------+
| bo_IN        | Tibetan (India)                    |
+--------------+------------------------------------+
| br_FR        | Breton (France)                    |
+--------------+------------------------------------+
| brx_IN       | Bodo (India)                       |
+--------------+------------------------------------+
| bs_BA        | Bosnian (Bosnia and Herzegovina)   |
+--------------+------------------------------------+
| byn_ER       | Bilin (Eritrea)                    |
+--------------+------------------------------------+
| ca           | Catalan                            |
+--------------+------------------------------------+
| ca_AD        | Catalan (Andorra)                  |
+--------------+------------------------------------+
| ca_ES        | Catalan (Spain)                    |
+--------------+------------------------------------+
| ca_FR        | Catalan (France)                   |
+--------------+------------------------------------+
| ca_IT        | Catalan (Italy)                    |
+--------------+------------------------------------+
| ce_RU        | Chechen (Russia)                   |
+--------------+------------------------------------+
| chr_US       | Cherokee (United States)           |
+--------------+------------------------------------+
| cmn_TW       | Mandarin Chinese (Taiwan)          |
+--------------+------------------------------------+
| crh_UA       | Crimean Tatar (Ukraine)            |
+--------------+------------------------------------+
| csb_PL       | Kashubian (Poland)                 |
+--------------+------------------------------------+
| cs           | Czech                              |
+--------------+------------------------------------+
| cs_CZ        | Czech (Czech Republic)             |
+--------------+------------------------------------+
| cv_RU        | Chuvash (Russia)                   |
+--------------+------------------------------------+
| cy_GB        | Welsh (United Kingdom)             |
+--------------+------------------------------------+
| da           | Danish                             |
+--------------+------------------------------------+
| da_DK        | Danish (Denmark)                   |
+--------------+------------------------------------+
| de           | German                             |
+--------------+------------------------------------+
| de_AT        | German (Austria)                   |
+--------------+------------------------------------+
| de_BE        | German (Belgium)                   |
+--------------+------------------------------------+
| de_CH        | German (Switzerland)               |
+--------------+------------------------------------+
| de_DE        | German (Germany)                   |
+--------------+------------------------------------+
| de_IT        | German (Italy)                     |
+--------------+------------------------------------+
| de_LU        | German (Luxembourg)                |
+--------------+------------------------------------+
| doi_IN       | Dogri (India)                      |
+--------------+------------------------------------+
| dv_MV        | Dhivehi (Maldives)                 |
+--------------+------------------------------------+
| dz_BT        | Dzongkha (Bhutan)                  |
+--------------+------------------------------------+
| el           | Greek                              |
+--------------+------------------------------------+
| el_CY        | Greek (Cyprus)                     |
+--------------+------------------------------------+
| el_GR        | Greek (Greece)                     |
+--------------+------------------------------------+
| en           | English                            |
+--------------+------------------------------------+
| en_AG        | English (Antigua and Barbuda)      |
+--------------+------------------------------------+
| en_AU        | English (Australia)                |
+--------------+------------------------------------+
| en_BW        | English (Botswana)                 |
+--------------+------------------------------------+
| en_CA        | English (Canada)                   |
+--------------+------------------------------------+
| en_DK        | English (Denmark)                  |
+--------------+------------------------------------+
| en_GB        | English (United Kingdom)           |
+--------------+------------------------------------+
| en_HK        | English (Hong Kong)                |
+--------------+------------------------------------+
| en_IE        | English (Ireland)                  |
+--------------+------------------------------------+
| en_IL        | English (Israel)                   |
+--------------+------------------------------------+
| en_IN        | English (India)                    |
+--------------+------------------------------------+
| en_NG        | English (Nigeria)                  |
+--------------+------------------------------------+
| en_NZ        | English (New Zealand)              |
+--------------+------------------------------------+
| en_PH        | English (Philippines)              |
+--------------+------------------------------------+
| en_SG        | English (Singapore)                |
+--------------+------------------------------------+
| en_US        | English (United States)            |
+--------------+------------------------------------+
| en_ZA        | English (South Africa)             |
+--------------+------------------------------------+
| en_ZM        | English (Zambia)                   |
+--------------+------------------------------------+
| en_ZW        | English (Zimbabwe)                 |
+--------------+------------------------------------+
| eo           | Esperanto                          |
+--------------+------------------------------------+
| es           | Spanish                            |
+--------------+------------------------------------+
| es_AR        | Spanish (Argentina)                |
+--------------+------------------------------------+
| es_BO        | Spanish (Bolivia)                  |
+--------------+------------------------------------+
| es_CL        | Spanish (Chile)                    |
+--------------+------------------------------------+
| es_CO        | Spanish (Colombia)                 |
+--------------+------------------------------------+
| es_CR        | Spanish (Costa Rica)               |
+--------------+------------------------------------+
| es_CU        | Spanish (Cuba)                     |
+--------------+------------------------------------+
| es_DO        | Spanish (Dominican Republic)       |
+--------------+------------------------------------+
| es_EC        | Spanish (Ecuador)                  |
+--------------+------------------------------------+
| es_ES        | Spanish (Spain)                    |
+--------------+------------------------------------+
| es_GT        | Spanish (Guatemala)                |
+--------------+------------------------------------+
| es_HN        | Spanish (Honduras)                 |
+--------------+------------------------------------+
| es_MX        | Spanish (Mexico)                   |
+--------------+------------------------------------+
| es_NI        | Spanish (Nicaragua)                |
+--------------+------------------------------------+
| es_PA        | Spanish (Panama)                   |
+--------------+------------------------------------+
| es_PE        | Spanish (Peru)                     |
+--------------+------------------------------------+
| es_PR        | Spanish (Puerto Rico)              |
+--------------+------------------------------------+
| es_PY        | Spanish (Paraguay)                 |
+--------------+------------------------------------+
| es_SV        | Spanish (El Salvador)              |
+--------------+------------------------------------+
| es_US        | Spanish (United States)            |
+--------------+------------------------------------+
| es_UY        | Spanish (Uruguay)                  |
+--------------+------------------------------------+
| es_VE        | Spanish (Venezuela)                |
+--------------+------------------------------------+
| et           | Estonian                           |
+--------------+------------------------------------+
| et_EE        | Estonian (Estonia)                 |
+--------------+------------------------------------+
| eu           | Basque                             |
+--------------+------------------------------------+
| eu_ES        | Basque (Spain)                     |
+--------------+------------------------------------+
| fa           | Persian                            |
+--------------+------------------------------------+
| fa_IR        | Persian (Iran)                     |
+--------------+------------------------------------+
| ff_SN        | Fulah (Senegal)                    |
+--------------+------------------------------------+
| fi           | Finnish                            |
+--------------+------------------------------------+
| fi_FI        | Finnish (Finland)                  |
+--------------+------------------------------------+
| fil          | Filipino                           |
+--------------+------------------------------------+
| fil_PH       | Filipino (Philippines)             |
+--------------+------------------------------------+
| fo_FO        | Faroese (Faroe Islands)            |
+--------------+------------------------------------+
| fr           | French                             |
+--------------+------------------------------------+
| fr_BE        | French (Belgium)                   |
+--------------+------------------------------------+
| fr_CA        | French (Canada)                    |
+--------------+------------------------------------+
| fr_CH        | French (Switzerland)               |
+--------------+------------------------------------+
| fr_FR        | French (France)                    |
+--------------+------------------------------------+
| fr_LU        | French (Luxembourg)                |
+--------------+------------------------------------+
| fur_IT       | Friulian (Italy)                   |
+--------------+------------------------------------+
| fy_DE        | Western Frisian (Germany)          |
+--------------+------------------------------------+
| fy_NL        | Western Frisian (Netherlands)      |
+--------------+------------------------------------+
| ga           | Irish                              |
+--------------+------------------------------------+
| ga_IE        | Irish (Ireland)                    |
+--------------+------------------------------------+
| gd_GB        | Scottish Gaelic (United Kingdom)   |
+--------------+------------------------------------+
| gez_ER       | Geez (Eritrea)                     |
+--------------+------------------------------------+
| gez_ET       | Geez (Ethiopia)                    |
+--------------+------------------------------------+
| gl_ES        | Galician (Spain)                   |
+--------------+------------------------------------+
| gu_IN        | Gujarati (India)                   |
+--------------+------------------------------------+
| gv_GB        | Manx (United Kingdom)              |
+--------------+------------------------------------+
| hak_TW       | Hakka Chinese (Taiwan)             |
+--------------+------------------------------------+
| ha_NG        | Hausa (Nigeria)                    |
+--------------+------------------------------------+
| he           | Hebrew                             |
+--------------+------------------------------------+
| he_IL        | Hebrew (Israel)                    |
+--------------+------------------------------------+
| hi           | Hindi                              |
+--------------+------------------------------------+
| hi_IN        | Hindi (India)                      |
+--------------+------------------------------------+
| hne_IN       | Chhattisgarhi (India)              |
+--------------+------------------------------------+
| hr           | Croatian                           |
+--------------+------------------------------------+
| hr_HR        | Croatian (Croatia)                 |
+--------------+------------------------------------+
| hsb_DE       | Upper Sorbian (Germany)            |
+--------------+------------------------------------+
| ht_HT        | Haitian (Haiti)                    |
+--------------+------------------------------------+
| hu           | Hungarian                          |
+--------------+------------------------------------+
| hu_HU        | Hungarian (Hungary)                |
+--------------+------------------------------------+
| hus_MX       | Huastec (Mexico)                   |
+--------------+------------------------------------+
| hy_AM        | Armenian (Armenia)                 |
+--------------+------------------------------------+
| ia_FR        | Interlingua (France)               |
+--------------+------------------------------------+
| id           | Indonesian                         |
+--------------+------------------------------------+
| id_ID        | Indonesian (Indonesia)             |
+--------------+------------------------------------+
| ig_NG        | Igbo (Nigeria)                     |
+--------------+------------------------------------+
| ik_CA        | Inupiaq (Canada)                   |
+--------------+------------------------------------+
| is           | Icelandic                          |
+--------------+------------------------------------+
| is_IS        | Icelandic (Iceland)                |
+--------------+------------------------------------+
| it           | Italian                            |
+--------------+------------------------------------+
| it_CH        | Italian (Switzerland)              |
+--------------+------------------------------------+
| it_IT        | Italian (Italy)                    |
+--------------+------------------------------------+
| iu_CA        | Inuktitut (Canada)                 |
+--------------+------------------------------------+
| ja           | Japanese                           |
+--------------+------------------------------------+
| ja_JP        | Japanese (Japan)                   |
+--------------+------------------------------------+
| kab_DZ       | Kabyle (Algeria)                   |
+--------------+------------------------------------+
| ka           | Georgian                           |
+--------------+------------------------------------+
| ka_GE        | Georgian (Georgia)                 |
+--------------+------------------------------------+
| kk_KZ        | Kazakh (Kazakhstan)                |
+--------------+------------------------------------+
| kl_GL        | Kalaallisut (Greenland)            |
+--------------+------------------------------------+
| km_KH        | Central Khmer (Cambodia)           |
+--------------+------------------------------------+
| kn_IN        | Kannada (India)                    |
+--------------+------------------------------------+
| kok_IN       | Konkani (India)                    |
+--------------+------------------------------------+
| ko           | Korean                             |
+--------------+------------------------------------+
| ko_KR        | Korean (South Korea)               |
+--------------+------------------------------------+
| ks_IN        | Kashmiri (India)                   |
+--------------+------------------------------------+
| ku           | Kurdish                            |
+--------------+------------------------------------+
| ku_TR        | Kurdish (Turkey)                   |
+--------------+------------------------------------+
| kw_GB        | Cornish (United Kingdom)           |
+--------------+------------------------------------+
| ky_KG        | Kirghiz (Kyrgyzstan)               |
+--------------+------------------------------------+
| lb_LU        | Luxembourgish (Luxembourg)         |
+--------------+------------------------------------+
| lg_UG        | Ganda (Uganda)                     |
+--------------+------------------------------------+
| li_BE        | Limburgan (Belgium)                |
+--------------+------------------------------------+
| li_NL        | Limburgan (Netherlands)            |
+--------------+------------------------------------+
| lij_IT       | Ligurian (Italy)                   |
+--------------+------------------------------------+
| ln_CD        | Lingala (Congo)                    |
+--------------+------------------------------------+
| lo_LA        | Lao (Laos)                         |
+--------------+------------------------------------+
| lt           | Lithuanian                         |
+--------------+------------------------------------+
| lt_LT        | Lithuanian (Lithuania)             |
+--------------+------------------------------------+
| lv           | Latvian                            |
+--------------+------------------------------------+
| lv_LV        | Latvian (Latvia)                   |
+--------------+------------------------------------+
| lzh_TW       | Literary Chinese (Taiwan)          |
+--------------+------------------------------------+
| mag_IN       | Magahi (India)                     |
+--------------+------------------------------------+
| mai_IN       | Maithili (India)                   |
+--------------+------------------------------------+
| mg_MG        | Malagasy (Madagascar)              |
+--------------+------------------------------------+
| mh_MH        | Marshallese (Marshall Islands)     |
+--------------+------------------------------------+
| mhr_RU       | Eastern Mari (Russia)              |
+--------------+------------------------------------+
| mi           | Maori                              |
+--------------+------------------------------------+
| mi_NZ        | Maori (New Zealand)                |
+--------------+------------------------------------+
| miq_NI       | Mískito (Nicaragua)                |
+--------------+------------------------------------+
| mk           | Macedonian                         |
+--------------+------------------------------------+
| mk_MK        | Macedonian (Macedonia)             |
+--------------+------------------------------------+
| ml           | Malayalam                          |
+--------------+------------------------------------+
| ml_IN        | Malayalam (India)                  |
+--------------+------------------------------------+
| mni_IN       | Manipuri (India)                   |
+--------------+------------------------------------+
| mn_MN        | Mongolian (Mongolia)               |
+--------------+------------------------------------+
| mr_IN        | Marathi (India)                    |
+--------------+------------------------------------+
| ms           | Malay                              |
+--------------+------------------------------------+
| ms_MY        | Malay (Malaysia)                   |
+--------------+------------------------------------+
| mt           | Maltese                            |
+--------------+------------------------------------+
| mt_MT        | Maltese (Malta)                    |
+--------------+------------------------------------+
| my_MM        | Burmese (Myanmar)                  |
+--------------+------------------------------------+
| myv_RU       | Erzya (Russia)                     |
+--------------+------------------------------------+
| nah_MX       | Nahuatl languages (Mexico)         |
+--------------+------------------------------------+
| nan_TW       | Min Nan Chinese (Taiwan)           |
+--------------+------------------------------------+
| nb           | Norwegian Bokmål                   |
+--------------+------------------------------------+
| nb_NO        | Norwegian Bokmål (Norway)          |
+--------------+------------------------------------+
| nds_DE       | Low German (Germany)               |
+--------------+------------------------------------+
| nds_NL       | Low German (Netherlands)           |
+--------------+------------------------------------+
| ne_NP        | Nepali (Nepal)                     |
+--------------+------------------------------------+
| nhn_MX       | Central Nahuatl (Mexico)           |
+--------------+------------------------------------+
| niu_NU       | Niuean (Niue)                      |
+--------------+------------------------------------+
| niu_NZ       | Niuean (New Zealand)               |
+--------------+------------------------------------+
| nl           | Dutch                              |
+--------------+------------------------------------+
| nl_AW        | Dutch (Aruba)                      |
+--------------+------------------------------------+
| nl_BE        | Dutch (Belgium)                    |
+--------------+------------------------------------+
| nl_NL        | Dutch (Netherlands)                |
+--------------+------------------------------------+
| nn           | Norwegian Nynorsk                  |
+--------------+------------------------------------+
| nn_NO        | Norwegian Nynorsk (Norway)         |
+--------------+------------------------------------+
| nr_ZA        | South Ndebele (South Africa)       |
+--------------+------------------------------------+
| nso_ZA       | Pedi (South Africa)                |
+--------------+------------------------------------+
| oc_FR        | Occitan (France)                   |
+--------------+------------------------------------+
| om           | Oromo                              |
+--------------+------------------------------------+
| om_ET        | Oromo (Ethiopia)                   |
+--------------+------------------------------------+
| om_KE        | Oromo (Kenya)                      |
+--------------+------------------------------------+
| or_IN        | Oriya (India)                      |
+--------------+------------------------------------+
| os_RU        | Ossetian (Russia)                  |
+--------------+------------------------------------+
| pa_IN        | Panjabi (India)                    |
+--------------+------------------------------------+
| pa_PK        | Panjabi (Pakistan)                 |
+--------------+------------------------------------+
| pap          | Papiamento                         |
+--------------+------------------------------------+
| pap_AN       | Papiamento (Netherlands Antilles)  |
+--------------+------------------------------------+
| pap_AW       | Papiamento (Aruba)                 |
+--------------+------------------------------------+
| pap_CW       | Papiamento (Curaçao)               |
+--------------+------------------------------------+
| pl           | Polish                             |
+--------------+------------------------------------+
| pl_PL        | Polish (Poland)                    |
+--------------+------------------------------------+
| pr           | Pirate                             |
+--------------+------------------------------------+
| ps_AF        | Pushto (Afghanistan)               |
+--------------+------------------------------------+
| pt           | Portuguese                         |
+--------------+------------------------------------+
| pt_BR        | Portuguese (Brazil)                |
+--------------+------------------------------------+
| pt_PT        | Portuguese (Portugal)              |
+--------------+------------------------------------+
| quy_PE       | Ayacucho Quechua (Peru)            |
+--------------+------------------------------------+
| quz_PE       | Cusco Quechua (Peru)               |
+--------------+------------------------------------+
| raj_IN       | Rajasthani (India)                 |
+--------------+------------------------------------+
| ro           | Romanian                           |
+--------------+------------------------------------+
| ro_RO        | Romanian (Romania)                 |
+--------------+------------------------------------+
| ru           | Russian                            |
+--------------+------------------------------------+
| ru_RU        | Russian (Russia)                   |
+--------------+------------------------------------+
| ru_UA        | Russian (Ukraine)                  |
+--------------+------------------------------------+
| rw_RW        | Kinyarwanda (Rwanda)               |
+--------------+------------------------------------+
| sa_IN        | Sanskrit (India)                   |
+--------------+------------------------------------+
| sat_IN       | Santali (India)                    |
+--------------+------------------------------------+
| sc_IT        | Sardinian (Italy)                  |
+--------------+------------------------------------+
| sco          | Scots                              |
+--------------+------------------------------------+
| sd_IN        | Sindhi (India)                     |
+--------------+------------------------------------+
| se_NO        | Northern Sami (Norway)             |
+--------------+------------------------------------+
| sgs_LT       | Samogitian (Lithuania)             |
+--------------+------------------------------------+
| shs_CA       | Shuswap (Canada)                   |
+--------------+------------------------------------+
| sid_ET       | Sidamo (Ethiopia)                  |
+--------------+------------------------------------+
| si           | Sinhala                            |
+--------------+------------------------------------+
| si_LK        | Sinhala (Sri Lanka)                |
+--------------+------------------------------------+
| sk           | Slovak                             |
+--------------+------------------------------------+
| sk_SK        | Slovak (Slovakia)                  |
+--------------+------------------------------------+
| sl           | Slovenian                          |
+--------------+------------------------------------+
| sl_SI        | Slovenian (Slovenia)               |
+--------------+------------------------------------+
| so           | Somali                             |
+--------------+------------------------------------+
| so_DJ        | Somali (Djibouti)                  |
+--------------+------------------------------------+
| so_ET        | Somali (Ethiopia)                  |
+--------------+------------------------------------+
| so_KE        | Somali (Kenya)                     |
+--------------+------------------------------------+
| so_SO        | Somali (Somalia)                   |
+--------------+------------------------------------+
| son_ML       | Songhai languages (Mali)           |
+--------------+------------------------------------+
| sq           | Albanian                           |
+--------------+------------------------------------+
| sq_AL        | Albanian (Albania)                 |
+--------------+------------------------------------+
| sq_KV        | Albanian (Kosovo)                  |
+--------------+------------------------------------+
| sq_MK        | Albanian (Macedonia)               |
+--------------+------------------------------------+
| sr           | Serbian                            |
+--------------+------------------------------------+
| sr_Cyrl      | Serbian (Cyrillic)                 |
+--------------+------------------------------------+
| sr_Latn      | Serbian (Latin)                    |
+--------------+------------------------------------+
| sr_ME        | Serbian (Montenegro)               |
+--------------+------------------------------------+
| sr_RS        | Serbian (Serbia)                   |
+--------------+------------------------------------+
| ss_ZA        | Swati (South Africa)               |
+--------------+------------------------------------+
| st_ZA        | Southern Sotho (South Africa)      |
+--------------+------------------------------------+
| sv           | Swedish                            |
+--------------+------------------------------------+
| sv_FI        | Swedish (Finland)                  |
+--------------+------------------------------------+
| sv_SE        | Swedish (Sweden)                   |
+--------------+------------------------------------+
| sw_KE        | Swahili (Kenya)                    |
+--------------+------------------------------------+
| sw_TZ        | Swahili (Tanzania)                 |
+--------------+------------------------------------+
| szl_PL       | Silesian (Poland)                  |
+--------------+------------------------------------+
| ta           | Tamil                              |
+--------------+------------------------------------+
| ta_IN        | Tamil (India)                      |
+--------------+------------------------------------+
| ta_LK        | Tamil (Sri Lanka)                  |
+--------------+------------------------------------+
| tcy_IN       | Tulu (India)                       |
+--------------+------------------------------------+
| te           | Telugu                             |
+--------------+------------------------------------+
| te_IN        | Telugu (India)                     |
+--------------+------------------------------------+
| tg_TJ        | Tajik (Tajikistan)                 |
+--------------+------------------------------------+
| the_NP       | Chitwania Tharu (Nepal)            |
+--------------+------------------------------------+
| th           | Thai                               |
+--------------+------------------------------------+
| th_TH        | Thai (Thailand)                    |
+--------------+------------------------------------+
| ti           | Tigrinya                           |
+--------------+------------------------------------+
| ti_ER        | Tigrinya (Eritrea)                 |
+--------------+------------------------------------+
| ti_ET        | Tigrinya (Ethiopia)                |
+--------------+------------------------------------+
| tig_ER       | Tigre (Eritrea)                    |
+--------------+------------------------------------+
| tk_TM        | Turkmen (Turkmenistan)             |
+--------------+------------------------------------+
| tl_PH        | Tagalog (Philippines)              |
+--------------+------------------------------------+
| tn_ZA        | Tswana (South Africa)              |
+--------------+------------------------------------+
| tr           | Turkish                            |
+--------------+------------------------------------+
| tr_CY        | Turkish (Cyprus)                   |
+--------------+------------------------------------+
| tr_TR        | Turkish (Turkey)                   |
+--------------+------------------------------------+
| ts_ZA        | Tsonga (South Africa)              |
+--------------+------------------------------------+
| tt_RU        | Tatar (Russia)                     |
+--------------+------------------------------------+
| ug_CN        | Uighur (China)                     |
+--------------+------------------------------------+
| uk           | Ukrainian                          |
+--------------+------------------------------------+
| uk_UA        | Ukrainian (Ukraine)                |
+--------------+------------------------------------+
| unm_US       | Unami (United States)              |
+--------------+------------------------------------+
| ur           | Urdu                               |
+--------------+------------------------------------+
| ur_IN        | Urdu (India)                       |
+--------------+------------------------------------+
| ur_PK        | Urdu (Pakistan)                    |
+--------------+------------------------------------+
| uz           | Uzbek                              |
+--------------+------------------------------------+
| uz_UZ        | Uzbek (Uzbekistan)                 |
+--------------+------------------------------------+
| ve_ZA        | Venda (South Africa)               |
+--------------+------------------------------------+
| vi           | Vietnamese                         |
+--------------+------------------------------------+
| vi_VN        | Vietnamese (Vietnam)               |
+--------------+------------------------------------+
| wa_BE        | Walloon (Belgium)                  |
+--------------+------------------------------------+
| wae_CH       | Walser (Switzerland)               |
+--------------+------------------------------------+
| wal_ET       | Wolaytta (Ethiopia)                |
+--------------+------------------------------------+
| wo_SN        | Wolof (Senegal)                    |
+--------------+------------------------------------+
| xh_ZA        | Xhosa (South Africa)               |
+--------------+------------------------------------+
| yi_US        | Yiddish (United States)            |
+--------------+------------------------------------+
| yo_NG        | Yoruba (Nigeria)                   |
+--------------+------------------------------------+
| yue_HK       | Yue Chinese (Hong Kong)            |
+--------------+------------------------------------+
| zh           | Chinese                            |
+--------------+------------------------------------+
| zh_CN        | Chinese (China)                    |
+--------------+------------------------------------+
| zh_HK        | Chinese (Hong Kong)                |
+--------------+------------------------------------+
| zh_SG        | Chinese (Singapore)                |
+--------------+------------------------------------+
| zh_TW        | Chinese (Taiwan)                   |
+--------------+------------------------------------+
| zu_ZA        | Zulu (South Africa)                |
+--------------+------------------------------------+


===================================================
/. ./tutorials/inputs/index.rst
===================================================

Inputs
======

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-inputs

   inputevent
   input_examples
   mouse_and_input_coordinates
   custom_mouse_cursor
   handling_quit_requests
   controllers_gamepads_joysticks


===================================================
/. ./tutorials/inputs/inputevent.rst
===================================================

.. _doc_inputevent:

Using InputEvent
================

What is it?
-----------

Managing input is usually complex, no matter the OS or platform. To ease
this a little, a special built-in type is provided, :ref:`InputEvent <class_InputEvent>`.
This datatype can be configured to contain several types of input
events. Input events travel through the engine and can be received in
multiple locations, depending on the purpose.

Here is a quick example, closing your game if the escape key is hit:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _unhandled_input(event):
        if event is InputEventKey:
            if event.pressed and event.scancode == KEY_ESCAPE:
                get_tree().quit()

 .. code-tab:: csharp

    public override void _UnhandledInput(InputEvent @event)
    {
        if (@event is InputEventKey eventKey)
            if (eventKey.Pressed && eventKey.Scancode == (int)KeyList.Escape)
                GetTree().Quit();
    }

However, it is cleaner and more flexible to use the provided :ref:`InputMap <class_InputMap>` feature,
which allows you to define input actions and assign them different keys. This way,
you can define multiple keys for the same action (e.g. the keyboard escape key and the start button on a gamepad).
You can then more easily change this mapping in the project settings without updating your code,
and even build a key mapping feature on top of it to allow your game to change the key mapping at runtime!

You can set up your InputMap under **Project > Project Settings > Input Map** and then use those actions like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        if Input.is_action_pressed("ui_right"):
            # Move right.

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        if (Input.IsActionPressed("ui_right"))
        {
            // Move right.
        }
    }

How does it work?
-----------------

Every input event is originated from the user/player (though it's
possible to generate an InputEvent and feed them back to the engine,
which is useful for gestures). The OS object for each platform will read
events from the device, then feed them to MainLoop. As :ref:`SceneTree <class_SceneTree>`
is the default MainLoop implementation, events are fed to it. Godot
provides a function to get the current SceneTree object :
**get_tree()**.

But SceneTree does not know what to do with the event, so it will give
it to the viewports, starting by the "root" :ref:`Viewport <class_Viewport>` (the first
node of the scene tree). Viewport does quite a lot of stuff with the
received input, in order:

.. image:: img/input_event_flow.png

1. First of all, the standard :ref:`Node._input() <class_Node_method__input>` function
   will be called in any node that overrides it (and hasn't disabled input processing with :ref:`Node.set_process_input() <class_Node_method_set_process_input>`).
   If any function consumes the event, it can call :ref:`SceneTree.set_input_as_handled() <class_SceneTree_method_set_input_as_handled>`, and the event will
   not spread any more. This ensures that you can filter all events of interest, even before the GUI.
   For gameplay input, :ref:`Node._unhandled_input() <class_Node_method__unhandled_input>` is generally a better fit, because it allows the GUI to intercept the events.
2. Second, it will try to feed the input to the GUI, and see if any
   control can receive it. If so, the :ref:`Control <class_Control>` will be called via the
   virtual function :ref:`Control._gui_input() <class_Control_method__gui_input>` and the signal
   "gui_input" will be emitted (this function is re-implementable by
   script by inheriting from it). If the control wants to "consume" the
   event, it will call :ref:`Control.accept_event() <class_Control_method_accept_event>` and the event will
   not spread any more. Use the :ref:`Control.mouse_filter <class_Control_property_mouse_filter>`
   property to control whether a :ref:`Control <class_Control>` is notified
   of mouse events via :ref:`Control._gui_input() <class_Control_method__gui_input>`
   callback, and whether these events are propagated further.
3. If so far no one consumed the event, the unhandled input callback
   will be called if overridden (and not disabled with
   :ref:`Node.set_process_unhandled_input() <class_Node_method_set_process_unhandled_input>`).
   If any function consumes the event, it can call :ref:`SceneTree.set_input_as_handled() <class_SceneTree_method_set_input_as_handled>`, and the
   event will not spread any more. The unhandled input callback is ideal for full-screen gameplay events, so they are not received when a GUI is active.
4. If no one wanted the event so far, and a :ref:`Camera <class_Camera>` is assigned
   to the Viewport with :ref:`Object Picking <class_viewport_property_physics_object_picking>` turned on, a ray to the physics world (in the ray direction from
   the click) will be cast. (For the root viewport, this can also be enabled in :ref:`Project Settings <class_ProjectSettings_property_physics/common/enable_object_picking>`) If this ray hits an object, it will call the
   :ref:`CollisionObject._input_event() <class_CollisionObject_method__input_event>` function in the relevant
   physics object (bodies receive this callback by default, but areas do
   not. This can be configured through :ref:`Area <class_Area>` properties).
5. Finally, if the event was unhandled, it will be passed to the next
   Viewport in the tree, otherwise it will be ignored.

When sending events to all listening nodes within a scene, the viewport
will do so in a reverse depth-first order: Starting with the node at
the bottom of the scene tree, and ending at the root node:

.. image:: img/input_event_scene_flow.png

GUI events also travel up the scene tree but, since these events target
specific Controls, only direct ancestors of the targeted Control node receive the event.

In accordance with Godot's node-based design, this enables
specialized child nodes to handle and consume particular events, while
their ancestors, and ultimately the scene root, can provide more
generalized behavior if needed.

Anatomy of an InputEvent
------------------------

:ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does not represent
anything and only contains some basic information, such as event ID
(which is increased for each event), device index, etc.

There are several specialized types of InputEvent, described in the table below:

+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| Event                                                             | Type Index         | Description                             |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEvent <class_InputEvent>`                              | NONE               | Empty Input Event.                      |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventKey <class_InputEventKey>`                        | KEY                | Contains a scancode and Unicode value,  |
|                                                                   |                    | as well as modifiers.                   |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventMouseButton <class_InputEventMouseButton>`        | MOUSE_BUTTON       | Contains click information, such as     |
|                                                                   |                    | button, modifiers, etc.                 |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventMouseMotion <class_InputEventMouseMotion>`        | MOUSE_MOTION       | Contains motion information, such as    |
|                                                                   |                    | relative, absolute positions and speed. |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`      | JOYSTICK_MOTION    | Contains Joystick/Joypad analog axis    |
|                                                                   |                    | information.                            |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventJoypadButton <class_InputEventJoypadButton>`      | JOYSTICK_BUTTON    | Contains Joystick/Joypad button         |
|                                                                   |                    | information.                            |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventScreenTouch <class_InputEventScreenTouch>`        | SCREEN_TOUCH       | Contains multi-touch press/release      |
|                                                                   |                    | information. (only available on mobile  |
|                                                                   |                    | devices)                                |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventScreenDrag <class_InputEventScreenDrag>`          | SCREEN_DRAG        | Contains multi-touch drag information.  |
|                                                                   |                    | (only available on mobile devices)      |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+
| :ref:`InputEventAction <class_InputEventAction>`                  | SCREEN_ACTION      | Contains a generic action. These events |
|                                                                   |                    | are often generated by the programmer   |
|                                                                   |                    | as feedback. (more on this below)       |
+-------------------------------------------------------------------+--------------------+-----------------------------------------+

Actions
-------

An InputEvent may or may not represent a pre-defined action. Actions are
useful because they abstract the input device when programming the game
logic. This allows for:

-  The same code to work on different devices with different inputs (e.g.,
   keyboard on PC, Joypad on console).
-  Input to be reconfigured at run-time.

Actions can be created from the Project Settings menu in the Actions
tab.

Any event has the methods :ref:`InputEvent.is_action() <class_InputEvent_method_is_action>`,
:ref:`InputEvent.is_pressed() <class_InputEvent_method_is_pressed>` and :ref:`InputEvent <class_InputEvent>`.

Alternatively, it may be desired to supply the game back with an action
from the game code (a good example of this is detecting gestures).
The Input singleton has a method for this:
:ref:`Input.parse_input_event() <class_input_method_parse_input_event>`. You would normally use it like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    var ev = InputEventAction.new()
    # Set as move_left, pressed.
    ev.action = "move_left"
    ev.pressed = true
    # Feedback.
    Input.parse_input_event(ev)

 .. code-tab:: csharp

    var ev = new InputEventAction();
    // Set as move_left, pressed.
    ev.SetAction("move_left");
    ev.SetPressed(true);
    // Feedback.
    Input.ParseInputEvent(ev);

InputMap
--------

Customizing and re-mapping input from code is often desired. If your
whole workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton is
ideal for reassigning or creating different actions at run-time. This
singleton is not saved (must be modified manually) and its state is run
from the project settings (project.godot). So any dynamic system of this
type needs to store settings in the way the programmer best sees fit.


===================================================
/. ./tutorials/inputs/input_examples.rst
===================================================

.. _doc_input_examples:

Input examples
==============

Introduction
------------

In this tutorial, you'll learn how to use Godot's :ref:`InputEvent <class_InputEvent>`
system to capture player input. There are many different types of input your
game may use - keyboard, gamepad, mouse, etc. - and many different ways to
turn those inputs into actions in your game. This document will show you some
of the most common scenarios, which you can use as starting points for your
own projects.

.. note:: For a detailed overview of how Godot's input event system works,
          see :ref:`doc_inputevent`.

Events versus polling
---------------------

Sometimes you want your game to respond to a certain input event - pressing
the "jump" button, for example. For other situations, you might want something
to happen as long as a key is pressed, such as movement. In the first case,
you can use the ``_input()`` function, which will be called whenever an input
event occurs. In the second case, Godot provides the :ref:`Input <class_Input>`
singleton, which you can use to query the state of an input.

Examples:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
        if event.is_action_pressed("jump"):
            jump()


    func _physics_process(delta):
        if Input.is_action_pressed("move_right"):
            # Move as long as the key/button is pressed.
            position.x += speed * delta

 .. code-tab:: csharp

    public override void _Input(InputEvent inputEvent)
    {
        if (inputEvent.IsActionPressed("jump"))
        {
            Jump();
        }
    }

    public override void _PhysicsProcess(float delta)
    {
        if (Input.IsActionPressed("move_right"))
        {
            // Move as long as the key/button is pressed.
            position.x += speed * delta;
        }
    }

This gives you the flexibility to mix-and-match the type of input processing
you do.

For the remainder of this tutorial, we'll focus on capturing individual
events in ``_input()``.

Input events
------------

Input events are objects that inherit from :ref:`InputEvent <class_InputEvent>`.
Depending on the event type, the object will contain specific properties
related to that event. To see what events actually look like, add a Node and
attach the following script:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node


    func _input(event):
        print(event.as_text())

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Node : Godot.Node
    {
        public override void _Input(InputEvent inputEvent)
        {
            GD.Print(inputEvent.AsText());
        }
    }

As you press keys, move the mouse, and perform other inputs, you'll see each
event scroll by in the output window. Here's an example of the output:

::

    A
    InputEventMouseMotion : button_mask=0, position=(108, 108), relative=(26, 1), speed=(164.152496, 159.119843), pressure=(0), tilt=(0, 0)
    InputEventMouseButton : button_index=BUTTON_LEFT, pressed=true, position=(108, 107), button_mask=1, doubleclick=false
    InputEventMouseButton : button_index=BUTTON_LEFT, pressed=false, position=(108, 107), button_mask=0, doubleclick=false
    S
    F
    Alt
    InputEventMouseMotion : button_mask=0, position=(108, 107), relative=(0, -1), speed=(164.152496, 159.119843), pressure=(0), tilt=(0, 0)

As you can see, the results are very different for the different types of
input. Key events are even printed as their key symbols. For example, let's
consider :ref:`InputEventMouseButton <class_InputEventMouseButton>`.
It inherits from the following classes:

- :ref:`InputEvent <class_InputEvent>` - the base class for all input events
- :ref:`InputEventWithModifiers <class_InputEventWithModifiers>` - adds the ability to check if modifiers are pressed, such as :kbd:`Shift` or :kbd:`Alt`.
- :ref:`InputEventMouse <class_InputEventMouse>` - adds mouse event properties, such as ``position``
- :ref:`InputEventMouseButton <class_InputEventMouseButton>` - contains the index of the button that was pressed, whether it was a double-click, etc.

.. tip:: It's a good idea to keep the class reference open while you're working
        with events so you can check the event type's available properties and
        methods.

You can encounter errors if you try to access a property on an input type that
doesn't contain it - calling ``position`` on ``InputEventKey`` for example. To
avoid this, make sure to test the event type first:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
        if event is InputEventMouseButton:
            print("mouse button event at ", event.position)

 .. code-tab:: csharp

    public override void _Input(InputEvent inputEvent)
    {
        if (inputEvent is InputEventMouseButton mouseEvent)
        {
            GD.Print("mouse button event at ", mouseEvent.Position);
        }
    }

InputMap
--------

The :ref:`InputMap <class_InputMap>` is the most flexible way to handle a
variety of inputs. You use this by creating named input *actions*, to which
you can assign any number of input events, such as keypresses or mouse clicks.
A new Godot project includes a number of default actions already defined. To
see them, and to add your own, open Project -> Project Settings and select
the InputMap tab:

.. image:: img/inputs_inputmap.png

Capturing actions
~~~~~~~~~~~~~~~~~

Once you've defined your actions, you can process them in your scripts using
``is_action_pressed()`` and ``is_action_released()`` by passing the name of
the action you're looking for:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
        if event.is_action_pressed("my_action"):
            print("my_action occurred!")

 .. code-tab:: csharp

    public override void _Input(InputEvent inputEvent)
    {
        if (inputEvent.IsActionPressed("my_action"))
        {
            GD.Print("my_action occurred!");
        }
    }

Keyboard events
---------------

Keyboard events are captured in :ref:`InputEventKey <class_InputEventKey>`.
While it's recommended to use input actions instead, there may be cases where
you want to specifically look at key events. For this example, let's check for
the :kbd:`T`:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
        if event is InputEventKey and event.pressed:
            if event.scancode == KEY_T:
                print("T was pressed")

 .. code-tab:: csharp

    public override void _Input(InputEvent inputEvent)
    {
        if (inputEvent is InputEventKey keyEvent && keyEvent.Pressed)
        {
            if ((KeyList)keyEvent.Keycode == KeyList.T)
            {
                GD.Print("T was pressed");
            }
        }
    }

.. tip:: See :ref:`@GlobalScope_KeyList <enum_@GlobalScope_KeyList>` for a list of scancode
        constants.

.. warning::

    Due to *keyboard ghosting*, not all key inputs may be registered at a given time
    if you press too many keys at once. Due to their location on the keyboard,
    certain keys are more prone to ghosting than others. Some keyboards feature
    antighosting at a hardware level, but this feature is generally
    not present on low-end keyboards and laptop keyboards.

    As a result, it's recommended to use a default keyboard layout that is designed to work well
    on a keyboard without antighosting. See
    `this Gamedev Stack Exchange question <https://gamedev.stackexchange.com/a/109002>`__
    for more information.

Keyboard modifiers
~~~~~~~~~~~~~~~~~~

Modifier properties are inherited from
:ref:`InputEventWithModifiers <class_InputEventWithModifiers>`. This allows
you to check for modifier combinations using boolean properties. Let's imagine
you want one thing to happen when the :kbd:`T` is pressed, but something
different when it's :kbd:`Shift + T`:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
        if event is InputEventKey and event.pressed:
            if event.scancode == KEY_T:
                if event.shift:
                    print("Shift+T was pressed")
                else:
                    print("T was pressed")

 .. code-tab:: csharp

    public override void _Input(InputEvent inputEvent)
    {
        if (inputEvent is InputEventKey keyEvent && keyEvent.Pressed)
        {
            switch ((KeyList)keyEvent.Scancode)
            {
                case KeyList.T:
                    GD.Print(keyEvent.Shift ? "Shift+T was pressed" : "T was pressed");
                    break;
            }
        }
    }

.. tip:: See :ref:`@GlobalScope_KeyList <enum_@GlobalScope_KeyList>` for a list of scancode
        constants.

Mouse events
------------

Mouse events stem from the :ref:`InputEventMouse <class_InputEventMouse>` class, and
are separated into two types: :ref:`InputEventMouseButton <class_InputEventMouseButton>`
and :ref:`InputEventMouseMotion <class_InputEventMouseMotion>`. Note that this
means that all mouse events will contain a ``position`` property.

Mouse buttons
~~~~~~~~~~~~~

Capturing mouse buttons is very similar to handling key events. :ref:`@GlobalScope_ButtonList <enum_@GlobalScope_ButtonList>`
contains a list of ``BUTTON_*`` constants for each possible button, which will
be reported in the event's ``button_index`` property. Note that the scrollwheel
also counts as a button - two buttons, to be precise, with both
``BUTTON_WHEEL_UP`` and ``BUTTON_WHEEL_DOWN`` being separate events.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
        if event is InputEventMouseButton:
            if event.button_index == BUTTON_LEFT and event.pressed:
                print("Left button was clicked at ", event.position)
            if event.button_index == BUTTON_WHEEL_UP and event.pressed:
                print("Wheel up")

 .. code-tab:: csharp

    public override void _Input(InputEvent inputEvent)
    {
        if (inputEvent is InputEventMouseButton mouseEvent && mouseEvent.Pressed)
        {
            switch ((ButtonList)mouseEvent.ButtonIndex)
            {
                case ButtonList.Left:
                    GD.Print("Left button was clicked at ", {mouseEvent.Position});
                    break;
                case ButtonList.WheelUp:
                    GD.Print("Wheel up");
                    break;
            }
        }
    }

Mouse motion
~~~~~~~~~~~~

:ref:`InputEventMouseMotion <class_InputEventMouseMotion>` events occur whenever
the mouse moves. You can find the move's distance with the ``relative``
property.

Here's an example using mouse events to drag-and-drop a :ref:`Sprite <class_Sprite>`
node:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node


    var dragging = false
    var click_radius = 32 # Size of the sprite.


    func _input(event):
        if event is InputEventMouseButton and event.button_index == BUTTON_LEFT:
            if (event.position - $Sprite.position).length() < click_radius:
                # Start dragging if the click is on the sprite.
                if not dragging and event.pressed:
                    dragging = true
            # Stop dragging if the button is released.
            if dragging and not event.pressed:
                dragging = false

        if event is InputEventMouseMotion and dragging:
            # While dragging, move the sprite with the mouse.
            $Sprite.position = event.position

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Node2D : Godot.Node2D
    {
        private bool dragging = false;
        private int clickRadius = 32; // Size of the sprite.

        public override void _Input(InputEvent inputEvent)
        {
            Sprite sprite = GetNodeOrNull<Sprite>("Sprite");
            if (sprite == null)
            {
                return; // No suitable node was found.
            }

            if (inputEvent is InputEventMouseButton mouseEvent && (ButtonList)mouseEvent.ButtonIndex == ButtonList.Left)
            {
                if ((mouseEvent.Position - sprite.Position).Length() < clickRadius)
                {
                    // Start dragging if the click is on the sprite.
                    if (!dragging && mouseEvent.Pressed)
                    {
                        dragging = true;
                    }
                }
                // Stop dragging if the button is released.
                if (dragging && !mouseEvent.Pressed)
                {
                    dragging = false;
                }
            }
            else
            {
                if (inputEvent is InputEventMouseMotion motionEvent && dragging)
                {
                    // While dragging, move the sprite with the mouse.
                    sprite.Position = motionEvent.Position;
                }
            }
        }
    }

Touch events
------------

If you are using a touchscreen device, you can generate touch events.
:ref:`InputEventScreenTouch <class_InputEventScreenTouch>` is equivalent to
a mouse click event, and :ref:`InputEventScreenDrag <class_InputEventScreenDrag>`
works much the same as mouse motion.

.. tip:: To test your touch events on a non-touchscreen device, open Project
        Settings and go to the "Input Devices/Pointing" section. Enable "Emulate
        Touch From Mouse" and your project will interpret mouse clicks and
        motion as touch events.


===================================================
/. ./tutorials/inputs/mouse_and_input_coordinates.rst
===================================================

.. _doc_mouse_and_input_coordinates:

Mouse and input coordinates
===========================

About
-----

The reason for this small tutorial is to clear up many common mistakes
about input coordinates, obtaining mouse position and screen resolution,
etc.

Hardware display coordinates
----------------------------

Using hardware coordinates makes sense in the case of writing complex
UIs meant to run on PC, such as editors, MMOs, tools, etc. However, it does
not make as much sense outside of that scope.

Viewport display coordinates
----------------------------

Godot uses viewports to display content, and viewports can be scaled by
several options (see :ref:`doc_multiple_resolutions` tutorial). Use, then, the
functions in nodes to obtain the mouse coordinates and viewport size,
for example:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _input(event):
       # Mouse in viewport coordinates.
       if event is InputEventMouseButton:
           print("Mouse Click/Unclick at: ", event.position)
       elif event is InputEventMouseMotion:
           print("Mouse Motion at: ", event.position)

       # Print the size of the viewport.
       print("Viewport Resolution is: ", get_viewport_rect().size)

 .. code-tab:: csharp

    public override void _Input(InputEvent @event)
    {
        // Mouse in viewport coordinates.
        if (@event is InputEventMouseButton eventMouseButton)
            GD.Print("Mouse Click/Unclick at: ", eventMouseButton.Position);
        else if (@event is InputEventMouseMotion eventMouseMotion)
            GD.Print("Mouse Motion at: ", eventMouseMotion.Position);

        // Print the size of the viewport.
        GD.Print("Viewport Resolution is: ", GetViewportRect().Size);
    }

Alternatively, it's possible to ask the viewport for the mouse position:

.. tabs::
 .. code-tab:: gdscript GDScript

    get_viewport().get_mouse_position()

 .. code-tab:: csharp

    GetViewport().GetMousePosition();

.. note:: When the mouse mode is set to ``Input.MOUSE_MODE_CAPTURED``, the ``event.position`` value from ``InputEventMouseMotion`` is the center of the screen. Use ``event.relative`` instead of ``event.position`` and ``event.speed`` to process mouse movement and position changes.


===================================================
/. ./tutorials/inputs/custom_mouse_cursor.rst
===================================================

.. _doc_custom_mouse_cursor:

Customizing the mouse cursor
============================

You might want to change the appearance of the mouse cursor in your game in order to suit the overall design. There are two ways to customize the mouse cursor:

1. Using project settings
2. Using a script

Using project settings is a simpler (but more limited) way to customize the mouse cursor. The second way is more customizable, but involves scripting.

.. note::

    You could display a "software" mouse cursor by hiding the mouse cursor and
    moving a Sprite to the cursor position in a ``_process`` method, but this
    will add at least one frame of latency compared to an "hardware" mouse
    cursor. Therefore, it's recommended to use the approach described here
    whenever possible.

    If you have to use the "software" approach, consider adding an extrapolation step
    to better display the actual mouse input.

Using project settings
----------------------

Open project settings, go to Display>Mouse Cursor. You will see Custom Image and Custom Image Hotspot.

.. image:: img/cursor_project_settings.png

Custom Image is the desired image that you would like to set as the mouse cursor.
Custom Hotspot is the point in the image that you would like to use as the cursor's detection point.

.. note:: The custom image **must** be less than 256x256.

Using a script
--------------

Create a Node and attach the following script.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node


    # Load the custom images for the mouse cursor.
    var arrow = load("res://arrow.png")
    var beam = load("res://beam.png")


    func _ready():
        # Changes only the arrow shape of the cursor.
        # This is similar to changing it in the project settings.
        Input.set_custom_mouse_cursor(arrow)

        # Changes a specific shape of the cursor (here, the I-beam shape).
        Input.set_custom_mouse_cursor(beam, Input.CURSOR_IBEAM)

 .. code-tab:: csharp

    public override void _Ready()
    {
        // Load the custom images for the mouse cursor.
        var arrow = ResourceLoader.Load("res://arrow.png");
        var beam = ResourceLoader.Load("res://beam.png");

        // Changes only the arrow shape of the cursor.
        // This is similar to changing it in the project settings.
        Input.SetCustomMouseCursor(arrow);

        // Changes a specific shape of the cursor (here, the I-beam shape).
        Input.SetCustomMouseCursor(beam, Input.CursorShape.Ibeam);
    }

.. note::
    Check :ref:`Input.set_custom_mouse_cursor() <class_Input_method_set_custom_mouse_cursor>`.


Demo project
------------

Find out more by studying this demo project:
https://github.com/guilhermefelipecgs/custom_hardware_cursor

Cursor list
-----------

As documented in the :ref:`Input <class_Input>` class (see the **CursorShape** enum), there are multiple mouse cursors you can define. Which ones you want to use depends on your use case.


===================================================
/. ./tutorials/inputs/handling_quit_requests.rst
===================================================

.. _doc_handling_quit_requests:

Handling quit requests
======================

Quitting
--------

Most platforms have the option to request the application to quit. On
desktops, this is usually done with the "x" icon on the window title bar.
On Android, the back button is used to quit when on the main screen (and
to go back otherwise).

Handling the notification
-------------------------

On desktop platforms, the :ref:`MainLoop <class_MainLoop>`
has a special ``MainLoop.NOTIFICATION_WM_QUIT_REQUEST`` notification that is
sent to all nodes when quitting is requested.

On Android, ``MainLoop.NOTIFICATION_WM_GO_BACK_REQUEST`` is sent instead.
Pressing the Back button will exit the application if
**Application > Config > Quit On Go Back** is checked in the Project Settings
(which is the default).

.. note::

    ``MainLoop.NOTIFICATION_WM_GO_BACK_REQUEST`` isn't supported on iOS, as
    iOS devices don't have a physical Back button.

Handling the notification is done as follows (on any node):

.. tabs::
 .. code-tab:: gdscript GDScript

    func _notification(what):
        if what == MainLoop.NOTIFICATION_WM_QUIT_REQUEST:
            get_tree().quit() # default behavior

 .. code-tab:: csharp

    public override void _Notification(int what)
    {
        if (what == MainLoop.NotificationWmQuitRequest)
            GetTree().Quit(); // default behavior
    }

When developing mobile apps, quitting is not desired unless the user is
on the main screen, so the behavior can be changed.

It is important to note that by default, Godot apps have the built-in
behavior to quit when quit is requested, this can be changed:

.. tabs::
 .. code-tab:: gdscript GDScript

    get_tree().set_auto_accept_quit(false)

 .. code-tab:: csharp

    GetTree().SetAutoAcceptQuit(false);

Sending your own quit notification
----------------------------------

While forcing the application to close can be done by calling :ref:`SceneTree.quit <class_SceneTree_method_quit>`,
doing so will not send the quit *notification*. This means the function
described above won't be called. Quitting by calling
:ref:`SceneTree.quit <class_SceneTree_method_quit>` will not allow custom actions
to complete (such as saving, confirming the quit, or debugging), even if you try
to delay the line that forces the quit. 

Instead, you should send a quit request:

.. tabs::
 .. code-tab:: gdscript GDScript

    get_tree().notification(MainLoop.NOTIFICATION_WM_QUIT_REQUEST)

 .. code-tab:: csharp

    GetTree().Notification(MainLoop.NotificationWmQuitRequest)


===================================================
/. ./tutorials/inputs/controllers_gamepads_joysticks.rst
===================================================

.. _doc_controllers_gamepads_joysticks:

Controllers, gamepads, and joysticks
====================================

Godot supports hundreds of controller models thanks to the community-sourced
`SDL game controller database <https://github.com/gabomdq/SDL_GameControllerDB>`__.

Controllers are supported on Windows, macOS, Linux, Android, iOS, and HTML5.

Note that more specialized devices such as steering wheels, rudder pedals and
`HOTAS <https://en.wikipedia.org/wiki/HOTAS>`__ are less tested and may not
always work as expected. Overriding force feedback for those devices is also not
implemented yet. If you have access to one of those devices, don't hesitate to
`report bugs on GitHub
<https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-bugs>`__.

In this guide, you will learn:

- **How to write your input logic to support both keyboard and controller inputs.**
- **How controllers can behave differently from keyboard/mouse input.**
- **Troubleshooting issues with controllers in Godot.**

Supporting universal input
--------------------------

Thanks to Godot's input action system, Godot makes it possible to support both
keyboard and controller input without having to write separate code paths.
Instead of hardcoding keys or controller buttons in your scripts, you should
create *input actions* in the Project Settings which will then refer to
specified key and controller inputs.

Input actions are explained in detail on the :ref:`doc_inputevent` page.

.. note::

    Unlike keyboard input, supporting both mouse and controller input for an
    action (such as looking around in a first-person game) will require
    different code paths since these have to be handled separately.

Which Input singleton method should I use?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are 3 ways to get input in an analog-aware way:

- When you have two axes (such as joystick or WASD movement) and want both
  axes to behave as a single input, use ``Input.get_vector()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
    # This handles deadzone in a correct way for most use cases.
    # The resulting deadzone will have a circular shape as it generally should.
    var velocity = Input.get_vector("move_left", "move_right", "move_forward", "move_back")

    # The line below is similar to `get_vector()`, except that it handles
    # the deadzone in a less optimal way. The resulting deadzone will have
    # a square-ish shape when it should ideally have a circular shape.
    var velocity = Vector2(
         Input.get_action_strength("move_right") - Input.get_action_strength("move_left"),
         Input.get_action_strength("move_back") - Input.get_action_strength("move_forward")
   ).clamped(1.0)

 .. code-tab:: csharp

    // `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
    // This handles deadzone in a correct way for most use cases.
    // The resulting deadzone will have a circular shape as it generally should.
    Vector2 velocity = Input.GetVector("move_left", "move_right", "move_forward", "move_back");

    // The line below is similar to `get_vector()`, except that it handles
    // the deadzone in a less optimal way. The resulting deadzone will have
    // a square-ish shape when it should ideally have a circular shape.
    Vector2 velocity = new Vector2(
         Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left"),
         Input.GetActionStrength("move_back") - Input.GetActionStrength("move_forward")
   ).Clamped(1.0);

- When you have one axis that can go both ways (such as a throttle on a
  flight stick), or when you want to handle separate axes individually,
  use ``Input.get_axis()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # `walk` will be a floating-point number between `-1.0` and `1.0`.
    var walk = Input.get_axis("move_left", "move_right")

    # The line above is a shorter form of:
    var walk = Input.get_action_strength("move_right") - Input.get_action_strength("move_left")

 .. code-tab:: csharp

    // `walk` will be a floating-point number between `-1.0` and `1.0`.
    float walk = Input.GetAxis("move_left", "move_right");

    // The line above is a shorter form of:
    float walk = Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left");

- For other types of analog input, such as handling a trigger or handling
  one direction at a time, use ``Input.get_action_strength()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # `strength` will be a floating-point number between `0.0` and `1.0`.
    var strength = Input.get_action_strength("accelerate")

 .. code-tab:: csharp

    // `strength` will be a floating-point number between `0.0` and `1.0`.
    float strength = Input.GetActionStrength("accelerate");

For non-analog digital/boolean input (only "pressed" or "not pressed" values),
such as controller buttons, mouse buttons or keyboard keys,
use ``Input.is_action_pressed()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # `jumping` will be a boolean with a value of `true` or `false`.
    var jumping = Input.is_action_pressed("jump")

.. tabs::
 .. code-tab:: csharp

    // `jumping` will be a boolean with a value of `true` or `false`.
    bool jumping = Input.IsActionPressed("jump");

In Godot versions before 3.4, such as 3.3, ``Input.get_vector()`` and
``Input.get_axis()`` aren't available. Only ``Input.get_action_strength()``
and ``Input.is_action_pressed()`` are available in Godot 3.3.

Differences between keyboard/mouse and controller input
-------------------------------------------------------

If you're used to handling keyboard and mouse input, you may be surprised by how
controllers handle specific situations.

Dead zone
^^^^^^^^^

Unlike keyboards and mice, controllers offer axes with *analog* inputs. The
upside of analog inputs is that they offer additional flexibility for actions.
Unlike digital inputs which can only provide strengths of ``0.0`` and ``1.0``,
an analog input can provide *any* strength between ``0.0`` and ``1.0``. The
downside is that without a deadzone system, an analog axis' strength will never
be equal to ``0.0`` due to how the controller is physically built. Instead, it
will linger at a low value such as ``0.062``. This phenomenon is known as
*drifting* and can be more noticeable on old or faulty controllers.

Let's take a racing game as a real-world example. Thanks to analog inputs, we
can steer the car slowly in one direction or another. However, without a
deadzone system, the car would slowly steer by itself even if the player isn't
touching the joystick. This is because the directional axis strength won't be
equal to ``0.0`` when we expect it to. Since we don't want our car to steer by
itself in this case, we define a "dead zone" value of ``0.2`` which will ignore
all input whose strength is lower than ``0.2``. An ideal dead zone value is high
enough to ignore the input caused by joystick drifting, but is low enough to not
ignore actual input from the player.

Godot features a built-in dead zone system to tackle this problem. The default
value is ``0.2``, but you can increase it or decrease it on a per-action basis
in the Project Settings' Input Map tab.
For ``Input.get_vector()``, the deadzone can be specified, or otherwise it
will calculate the average deadzone value from all of the actions in the vector.

"Echo" events
^^^^^^^^^^^^^

Unlike keyboard input, holding down a controller button such as a D-pad
direction will **not** generate repeated input events at fixed intervals (also
known as "echo" events). This is because the operating system never sends "echo"
events for controller input in the first place.

If you want controller buttons to send echo events, you will have to generate
:ref:`class_InputEvent` objects by code and parse them using
:ref:`Input.parse_input_event() <class_Input_method_parse_input_event>`
at regular intervals. This can be accomplished
with the help of a :ref:`class_Timer` node.

Window focus
^^^^^^^^^^^^

Unlike keyboard input, controller inputs can be seen by **all** windows on the
operating system, including unfocused windows.

While this is useful for
`third-party split screen functionality <https://nucleus-coop.github.io/>`__,
it can also have adverse effects. Players may accidentally send controller inputs
to the running project while interacting with another window.

If you wish to ignore events when the project window isn't focused, you will
need to create an :ref:`autoload <doc_singletons_autoload>` called ``Focus``
with the following script and use it to check all your inputs:

::

    # Focus.gd
    extends Node

    var focused := true

    func _notification(what: int) -> void:
        match what:
            NOTIFICATION_WM_FOCUS_OUT:
                focused = false
            NOTIFICATION_WM_FOCUS_IN:
                focused = true


    func input_is_action_pressed(action: String) -> bool:
        if focused:
            return Input.is_action_pressed(action)

        return false


    func event_is_action_pressed(event: InputEvent, action: String) -> bool:
        if focused:
            return Input.is_action_pressed(action)

        return false

Then, instead of using ``Input.is_action_pressed(action)``, use
``Focus.input_is_action_pressed(action)`` where ``action`` is the name of
the input action. Also, instead of using ``event.is_action_pressed(action)``,
use ``Focus.event_is_action_pressed(event, action)`` where ``event`` is an
InputEvent reference and ``action`` is the name of the input action.

Power saving prevention
^^^^^^^^^^^^^^^^^^^^^^^

Unlike keyboard and mouse input, controller inputs do **not** inhibit sleep and
power saving measures (such as turning off the screen after a certain amount of
time has passed).

To combat this, Godot enables power saving prevention by default when a project
is running. If you notice the system is turning off its display when playing
with a gamepad, check the value of **Display > Window > Energy Saving > Keep Screen On**
in the Project Settings.

Power saving prevention is **not** supported on Linux in Godot 3.x, but it is
supported in Godot 4.x. As a workaround, increase the screensaver's timeout
period to make it less likely to occur during gameplay.

Troubleshooting
---------------

.. seealso::

    You can view a list of
    `known issues with controller support <https://github.com/godotengine/godot/issues?q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__
    on GitHub.

My controller isn't recognized by Godot.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, check that your controller is recognized by other applications. You can
use the `Gamepad Tester <https://gamepad-tester.com/>`__ website to confirm that
your controller is recognized.

My controller has incorrectly mapped buttons or axes.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If buttons are incorrectly mapped, this may be due to an erroneous mapping from
the `SDL game controller database <https://github.com/gabomdq/SDL_GameControllerDB>`__.
You can contribute an updated mapping to be included in the next Godot version
by opening a pull request on the linked repository.

There are many ways to create mappings. One option is to use the mapping wizard
in the `official Joypads demo <https://godotengine.org/asset-library/asset/140>`__.
Once you have a working mapping for your controller, you can test it by defining
the ``SDL_GAMECONTROLLERCONFIG`` environment variable before running Godot:

.. tabs::
 .. code-tab:: bash Linux/macOS

    export SDL_GAMECONTROLLERCONFIG="your:mapping:here"
    ./path/to/godot.x86_64

 .. code-tab:: bat Windows (cmd)

    set SDL_GAMECONTROLLERCONFIG=your:mapping:here
    path\to\godot.exe

 .. code-tab:: powershell Windows (powershell)

    $env:SDL_GAMECONTROLLERCONFIG="your:mapping:here"
    path\to\godot.exe

To test mappings on non-desktop platforms or to distribute your project with
additional controller mappings, you can add them by calling
:ref:`Input.add_joy_mapping() <class_Input_method_add_joy_mapping>`
as early as possible in a script's ``_ready()`` function.

My controller works on a given platform, but not on another platform.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Linux
~~~~~

Prior to Godot 3.3, official Godot binaries were compiled with udev support
but self-compiled binaries were compiled *without* udev support unless
``udev=yes`` was passed on the SCons command line. This made controller
hotplugging support unavailable in self-compiled binaries.

HTML5
~~~~~

HTML5 controller support is often less reliable compared to "native" platforms.
The quality of controller support tends to vary wildly across browsers. As a
result, you may have to instruct your players to use a different browser if they
can't get their controller to work.

Also, note that
`controller support was significantly improved <https://github.com/godotengine/godot/pull/45078>`__
in Godot 3.3 and later.


===================================================
/. ./tutorials/io/index.rst
===================================================

Input and Output (I/O)
======================

.. toctree::
    :maxdepth: 1
    :name: toc-learn-features-io

    background_loading
    data_paths
    saving_games
    binary_serialization_api


===================================================
/. ./tutorials/io/background_loading.rst
===================================================

.. _doc_background_loading:

Background loading
==================

When switching the main scene of your game (e.g. going to a new
level), you might want to show a loading screen with some indication
that progress is being made. The main load method
(``ResourceLoader::load`` or just ``load`` from GDScript) blocks your
thread, making your game appear frozen and unresponsive while the resource is being loaded. This
document discusses the alternative of using the ``ResourceInteractiveLoader`` class for smoother
load screens.

ResourceInteractiveLoader
-------------------------

The ``ResourceInteractiveLoader`` class allows you to load a resource in
stages. Every time the method ``poll`` is called, a new stage is loaded,
and control is returned to the caller. Each stage is generally a
sub-resource that is loaded by the main resource. For example, if you're
loading a scene that loads 10 images, each image will be one stage.

Usage
-----

Usage is generally as follows

Obtaining a ResourceInteractiveLoader
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

    Ref<ResourceInteractiveLoader> ResourceLoader::load_interactive(String p_path);

This method will give you a ResourceInteractiveLoader that you will use
to manage the load operation.

Polling
~~~~~~~

.. code-block:: cpp

    Error ResourceInteractiveLoader::poll();

Use this method to advance the progress of the load. Each call to
``poll`` will load the next stage of your resource. Keep in mind that
each stage is one entire "atomic" resource, such as an image, or a mesh,
so it will take several frames to load.

Returns ``OK`` on no errors, ``ERR_FILE_EOF`` when loading is finished.
Any other return value means there was an error and loading has stopped.

Load progress (optional)
~~~~~~~~~~~~~~~~~~~~~~~~

To query the progress of the load, use the following methods:

.. code-block:: cpp

    int ResourceInteractiveLoader::get_stage_count() const;
    int ResourceInteractiveLoader::get_stage() const;

``get_stage_count`` returns the total number of stages to load.
``get_stage`` returns the current stage being loaded.

Forcing completion (optional)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

    Error ResourceInteractiveLoader::wait();

Use this method if you need to load the entire resource in the current
frame, without any more steps.

Obtaining the resource
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

    Ref<Resource> ResourceInteractiveLoader::get_resource();

If everything goes well, use this method to retrieve your loaded
resource.

Example
-------

This example demonstrates how to load a new scene. Consider it in the
context of the :ref:`doc_singletons_autoload` example.

First, we set up some variables and initialize the ``current_scene``
with the main scene of the game:

::

    var loader
    var wait_frames
    var time_max = 100 # msec
    var current_scene


    func _ready():
        var root = get_tree().get_root()
        current_scene = root.get_child(root.get_child_count() -1)

The function ``goto_scene`` is called from the game when the scene
needs to be switched. It requests an interactive loader, and calls
``set_process(true)`` to start polling the loader in the ``_process``
callback. It also starts a "loading" animation, which could show a
progress bar or loading screen.

::

    func goto_scene(path): # Game requests to switch to this scene.
        loader = ResourceLoader.load_interactive(path)
        if loader == null: # Check for errors.
            show_error()
            return
        set_process(true)

        current_scene.queue_free() # Get rid of the old scene.

        # Start your "loading..." animation.
        get_node("animation").play("loading")

        wait_frames = 1

``_process`` is where the loader is polled. ``poll`` is called, and then
we deal with the return value from that call. ``OK`` means keep polling,
``ERR_FILE_EOF`` means loading is done, anything else means there was an
error. Also note we skip one frame (via ``wait_frames``, set on the
``goto_scene`` function) to allow the loading screen to show up.

Note how we use ``OS.get_ticks_msec`` to control how long we block the
thread. Some stages might load fast, which means we might be able
to cram more than one call to ``poll`` in one frame; some might take way
more than your value for ``time_max``, so keep in mind we won't have
precise control over the timings.

::

    func _process(time):
        if loader == null:
            # no need to process anymore
            set_process(false)
            return

        # Wait for frames to let the "loading" animation show up.
        if wait_frames > 0:
            wait_frames -= 1
            return

        var t = OS.get_ticks_msec()
        # Use "time_max" to control for how long we block this thread.
        while OS.get_ticks_msec() < t + time_max:
            # Poll your loader.
            var err = loader.poll()

            if err == ERR_FILE_EOF: # Finished loading.
                var resource = loader.get_resource()
                loader = null
                set_new_scene(resource)
                break
            elif err == OK:
                update_progress()
            else: # Error during loading.
                show_error()
                loader = null
                break

Some extra helper functions. ``update_progress`` updates a progress bar,
or can also update a paused animation (the animation represents the
entire load process from beginning to end). ``set_new_scene`` puts the
newly loaded scene on the tree. Because it's a scene being loaded,
``instance()`` needs to be called on the resource obtained from the
loader.

::

    func update_progress():
        var progress = float(loader.get_stage()) / loader.get_stage_count()
        # Update your progress bar?
        get_node("progress").set_progress(progress)

        # ...or update a progress animation?
        var length = get_node("animation").get_current_animation_length()

        # Call this on a paused animation. Use "true" as the second argument to
        # force the animation to update.
        get_node("animation").seek(progress * length, true)


    func set_new_scene(scene_resource):
        current_scene = scene_resource.instance()
        get_node("/root").add_child(current_scene)

Using multiple threads
----------------------

ResourceInteractiveLoader can be used from multiple threads. A couple of
things to keep in mind if you attempt it:

Use a semaphore
~~~~~~~~~~~~~~~

While your thread waits for the main thread to request a new resource,
use a ``Semaphore`` to sleep (instead of a busy loop or anything similar).

Not blocking main thread during the polling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have a mutex to allow calls from the main thread to your loader
class, don't lock the main thread while you call ``poll`` on your loader class. When a
resource is done loading, it might require some resources from the
low-level APIs (VisualServer, etc), which might need to lock the main
thread to acquire them. This might cause a deadlock if the main thread
is waiting for your mutex while your thread is waiting to load a
resource.

Example class
-------------

You can find an example class for loading resources in threads here:
:download:`resource_queue.gd <files/resource_queue.gd>`. Usage is as follows:

::

    func start()

Call after you instance the class to start the thread.

::

    func queue_resource(path, p_in_front = false)

Queue a resource. Use optional argument "p_in_front" to put it in
front of the queue.

::

    func cancel_resource(path)

Remove a resource from the queue, discarding any loading done.

::

    func is_ready(path)

Returns ``true`` if a resource is fully loaded and ready to be retrieved.

::

    func get_progress(path)

Get the progress of a resource. Returns -1 if there was an error (for example if the
resource is not in the queue), or a number between 0.0 and 1.0 with the
progress of the load. Use mostly for cosmetic purposes (updating
progress bars, etc), use ``is_ready`` to find out if a resource is
actually ready.

::

    func get_resource(path)

Returns the fully loaded resource, or ``null`` on error. If the resource is
not fully loaded (``is_ready`` returns ``false``), it will block your thread
and finish the load. If the resource is not on the queue, it will call
``ResourceLoader::load`` to load it normally and return it.

Example:
~~~~~~~~

::

    # Initialize.
    queue = preload("res://resource_queue.gd").new()
    queue.start()

    # Suppose your game starts with a 10 second cutscene, during which the user
    # can't interact with the game.
    # For that time, we know they won't use the pause menu, so we can queue it
    # to load during the cutscene:
    queue.queue_resource("res://pause_menu.tres")
    start_cutscene()

    # Later, when the user presses the pause button for the first time:
    pause_menu = queue.get_resource("res://pause_menu.tres").instance()
    pause_menu.show()

    # When you need a new scene:
    queue.queue_resource("res://level_1.tscn", true)
    # Use "true" as the second argument to put it at the front of the queue,
    # pausing the load of any other resource.

    # To check progress.
    if queue.is_ready("res://level_1.tscn"):
        show_new_level(queue.get_resource("res://level_1.tscn"))
    else:
        update_progress(queue.get_progress("res://level_1.tscn"))

    # When the user walks away from the trigger zone in your Metroidvania game:
    queue.cancel_resource("res://zone_2.tscn")

**Note**: this code, in its current form, is not tested in real world
scenarios. If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./tutorials/io/data_paths.rst
===================================================

.. _doc_data_paths:

File paths in Godot projects
============================

This page explains how file paths work inside Godot projects. You will learn how
to access paths in your projects using the ``res://`` and ``user://`` notations,
and where Godot stores project and editor files on your and your users' systems.

Path separators
---------------

To make supporting multiple platforms easier, Godot uses **UNIX-style path
separators** (forward slash ``/``). These work on all platforms, **including
Windows**.

Instead of writing paths like ``C:\Projects\Game``, in Godot, you should write
``C:/Projects/Game``.

Windows-style path separators (backward slash ``\``) are also supported in some
path-related methods, but they need to be doubled (``\\``), as ``\`` is normally
used as an escape for characters with a special meaning.

This makes it possible to work with paths returned by other Windows
applications. We still recommend using only forward slashes in your own code to
guarantee that everything will work as intended.

Accessing files in the project folder (``res://``)
--------------------------------------------------

Godot considers that a project exists in any folder that contains a
``project.godot`` text file, even if the file is empty. The folder that contains
this file is your project's root folder.

You can access any file relative to it by writing paths starting with
``res://``, which stands for resources. For example, you can access an image
file ``character.png`` located in the project's root folder in code with the
following path: ``res://character.png``.

Accessing persistent user data (``user://``)
--------------------------------------------

To store persistent data files, like the player's save or settings, you want to
use ``user://`` instead of ``res://`` as your path's prefix. This is because
when the game is running, the project's file system will likely be read-only.

The ``user://`` prefix points to a different directory on the user's device.
Unlike ``res://``, the directory pointed at by ``user://`` is created
automatically and *guaranteed* to be writable to, even in an exported project.

The location of the ``user://`` folder depends on what is configured in the
Project Settings:

- By default, the ``user://`` folder is created within Godot's
  :ref:`editor data path <doc_data_paths_editor_data_paths>` in the
  ``app_userdata/[project_name]`` folder. This is the default so that prototypes
  and test projects stay self-contained within Godot's data folder.
- If :ref:`application/config/use_custom_user_dir <class_ProjectSettings_property_application/config/use_custom_user_dir>`
  is enabled in the Project Settings, the ``user://`` folder is created **next
  to** Godot's editor data path, i.e. in the standard location for applications
  data.

  * By default, the folder name will be inferred from the project name, but it
    can be further customized with
    :ref:`application/config/custom_user_dir_name <class_ProjectSettings_property_application/config/custom_user_dir_name>`.
    This path can contain path separators, so you can use it e.g. to group
    projects of a given studio with a ``Studio Name/Game Name`` structure.

On desktop platforms, the actual directory paths for ``user://`` are:

+---------------------+------------------------------------------------------------------------------+
| Type                | Location                                                                     |
+=====================+==============================================================================+
| Default             | | Windows: ``%APPDATA%\Godot\app_userdata\[project_name]``                   |
|                     | | macOS: ``~/Library/Application Support/Godot/app_userdata/[project_name]`` |
|                     | | Linux: ``~/.local/share/godot/app_userdata/[project_name]``                |
+---------------------+------------------------------------------------------------------------------+
| Custom dir          | | Windows: ``%APPDATA%\[project_name]``                                      |
|                     | | macOS: ``~/Library/Application Support/[project_name]``                    |
|                     | | Linux: ``~/.local/share/[project_name]``                                   |
+---------------------+------------------------------------------------------------------------------+
| Custom dir and name | | Windows: ``%APPDATA%\[custom_user_dir_name]``                              |
|                     | | macOS: ``~/Library/Application Support/[custom_user_dir_name]``            |
|                     | | Linux: ``~/.local/share/[custom_user_dir_name]``                           |
+---------------------+------------------------------------------------------------------------------+

``[project_name]`` is based on the application name defined in the Project Settings, but
you can override it on a per-platform basis using :ref:`feature tags <doc_feature_tags>`.

On mobile platforms, this path is unique to the project and is not accessible
by other applications for security reasons.

On HTML5 exports, ``user://`` will refer to a virtual filesystem stored on the
device via IndexedDB. (Interaction with the main filesystem can still be performed
through the :ref:`JavaScript <class_JavaScript>` singleton.)

Converting paths to absolute paths or "local" paths
---------------------------------------------------

You can use :ref:`ProjectSettings.globalize_path() <class_ProjectSettings_method_globalize_path>`
to convert a "local" path like ``res://path/to/file.txt`` to an absolute OS path.
For example, :ref:`ProjectSettings.globalize_path() <class_ProjectSettings_method_globalize_path>`
can be used to open "local" paths in the OS file manager
using :ref:`OS.shell_open() <class_OS_method_shell_open>` since it only accepts
native OS paths.

To convert an absolute OS path to a "local" path starting with ``res://``
or ``user://``, use :ref:`ProjectSettings.localize_path() <class_ProjectSettings_method_localize_path>`.
This only works for absolute paths that point to files or folders in your
project's root or ``user://`` folders.

.. _doc_data_paths_editor_data_paths:

Editor data paths
-----------------

The editor uses different paths for editor data, editor settings, and cache,
depending on the platform. By default, these paths are:

+-----------------+---------------------------------------------------+
| Type            | Location                                          |
+=================+===================================================+
| Editor data     | | Windows: ``%APPDATA%\Godot\``                   |
|                 | | macOS: ``~/Library/Application Support/Godot/`` |
|                 | | Linux: ``~/.local/share/godot/``                |
+-----------------+---------------------------------------------------+
| Editor settings | | Windows: ``%APPDATA%\Godot\``                   |
|                 | | macOS: ``~/Library/Application Support/Godot/`` |
|                 | | Linux: ``~/.config/godot/``                     |
+-----------------+---------------------------------------------------+
| Cache           | | Windows: ``%TEMP%\Godot\``                      |
|                 | | macOS: ``~/Library/Caches/Godot/``              |
|                 | | Linux: ``~/.cache/godot/``                      |
+-----------------+---------------------------------------------------+

- **Editor data** contains export templates and project-specific data.
- **Editor settings** contains the main editor settings configuration file as
  well as various other user-specific customizations (editor layouts, feature
  profiles, script templates, etc.).
- **Cache** contains data generated by the editor, or stored temporarily.
  It can safely be removed when Godot is closed.

Godot complies with the `XDG Base Directory Specification
<https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html>`__
on all platforms. You can override environment variables following the
specification to change the editor and project data paths.

.. note:: If you use `Godot packaged as a Flatpak
          <https://flathub.org/apps/details/org.godotengine.Godot>`__, the
          editor data paths will be located in subfolders in
          ``~/.var/app/org.godotengine.Godot/``.

.. _doc_data_paths_self_contained_mode:

Self-contained mode
~~~~~~~~~~~~~~~~~~~

If you create a file called ``._sc_`` or ``_sc_`` in the same directory as the
editor binary (or in `MacOS/Contents/` for a macOS editor .app bundle), Godot
will enable *self-contained mode*.
This mode makes Godot write all editor data, settings, and cache to a directory
named ``editor_data/`` in the same directory as the editor binary.
You can use it to create a portable installation of the editor.

The `Steam release of Godot <https://store.steampowered.com/app/404790/>`__ uses
self-contained mode by default.

.. note::

    Self-contained mode is not supported in exported projects yet.
    To read and write files relative to the executable path, use
    :ref:`OS.get_executable_path() <class_OS_method_get_executable_path>`.
    Note that writing files in the executable path only works if the executable
    is placed in a writable location (i.e. **not** Program Files or another
    directory that is read-only for regular users).


===================================================
/. ./tutorials/io/saving_games.rst
===================================================

.. _doc_saving_games:

Saving games
============

Introduction
------------

Save games can be complicated. For example, it may be desirable
to store information from multiple objects across multiple levels.
Advanced save game systems should allow for additional information about
an arbitrary number of objects. This will allow the save function to
scale as the game grows more complex.

.. note::

    If you're looking to save user configuration, you can use the
    :ref:`class_ConfigFile` class for this purpose.

Identify persistent objects
---------------------------

Firstly, we should identify what objects we want to keep between game
sessions and what information we want to keep from those objects. For
this tutorial, we will use groups to mark and handle objects to be saved,
but other methods are certainly possible.

We will start by adding objects we wish to save to the "Persist" group. We can
do this through either the GUI or script. Let's add the relevant nodes using the
GUI:

.. image:: img/groups.png

Once this is done, when we need to save the game, we can get all objects
to save them and then tell them all to save with this script:

.. tabs::
 .. code-tab:: gdscript GDScript

    var save_nodes = get_tree().get_nodes_in_group("Persist")
    for i in save_nodes:
        # Now, we can call our save function on each node.

 .. code-tab:: csharp

    var saveNodes = GetTree().GetNodesInGroup("Persist");
    foreach (Node saveNode in saveNodes)
    {
        // Now, we can call our save function on each node.
    }


Serializing
-----------

The next step is to serialize the data. This makes it much easier to
read from and store to disk. In this case, we're assuming each member of
group Persist is an instanced node and thus has a path. GDScript
has helper functions for this, such as :ref:`to_json()
<class_@GDScript_method_to_json>` and :ref:`parse_json()
<class_@GDScript_method_parse_json>`, so we will use a dictionary. Our node needs to
contain a save function that returns this data. The save function will look
like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    func save():
        var save_dict = {
            "filename" : get_filename(),
            "parent" : get_parent().get_path(),
            "pos_x" : position.x, # Vector2 is not supported by JSON
            "pos_y" : position.y,
            "attack" : attack,
            "defense" : defense,
            "current_health" : current_health,
            "max_health" : max_health,
            "damage" : damage,
            "regen" : regen,
            "experience" : experience,
            "tnl" : tnl,
            "level" : level,
            "attack_growth" : attack_growth,
            "defense_growth" : defense_growth,
            "health_growth" : health_growth,
            "is_alive" : is_alive,
            "last_attack" : last_attack
        }
        return save_dict

 .. code-tab:: csharp

    public Godot.Collections.Dictionary<string, object> Save()
    {
        return new Godot.Collections.Dictionary<string, object>()
        {
            { "Filename", GetFilename() },
            { "Parent", GetParent().GetPath() },
            { "PosX", Position.x }, // Vector2 is not supported by JSON
            { "PosY", Position.y },
            { "Attack", Attack },
            { "Defense", Defense },
            { "CurrentHealth", CurrentHealth },
            { "MaxHealth", MaxHealth },
            { "Damage", Damage },
            { "Regen", Regen },
            { "Experience", Experience },
            { "Tnl", Tnl },
            { "Level", Level },
            { "AttackGrowth", AttackGrowth },
            { "DefenseGrowth", DefenseGrowth },
            { "HealthGrowth", HealthGrowth },
            { "IsAlive", IsAlive },
            { "LastAttack", LastAttack }
        };
    }


This gives us a dictionary with the style
``{ "variable_name":value_of_variable }``, which will be useful when
loading.

Saving and reading data
-----------------------

As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file
so we can write to it or read from it. Now that we have a way to
call our groups and get their relevant data, let's use :ref:`to_json()
<class_@GDScript_method_to_json>` to
convert it into an easily stored string and store them in a file. Doing
it this way ensures that each line is its own object, so we have an easy
way to pull the data out of the file as well.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Note: This can be called from anywhere inside the tree. This function is
    # path independent.
    # Go through everything in the persist category and ask them to return a
    # dict of relevant variables.
    func save_game():
        var save_game = File.new()
        save_game.open("user://savegame.save", File.WRITE)
        var save_nodes = get_tree().get_nodes_in_group("Persist")
        for node in save_nodes:
            # Check the node is an instanced scene so it can be instanced again during load.
            if node.filename.empty():
                print("persistent node '%s' is not an instanced scene, skipped" % node.name)
                continue

            # Check the node has a save function.
            if !node.has_method("save"):
                print("persistent node '%s' is missing a save() function, skipped" % node.name)
                continue

            # Call the node's save function.
            var node_data = node.call("save")

            # Store the save dictionary as a new line in the save file.
            save_game.store_line(to_json(node_data))
        save_game.close()

 .. code-tab:: csharp

    // Note: This can be called from anywhere inside the tree. This function is
    // path independent.
    // Go through everything in the persist category and ask them to return a
    // dict of relevant variables.
    public void SaveGame()
    {
        var saveGame = new File();
        saveGame.Open("user://savegame.save", (int)File.ModeFlags.Write);

        var saveNodes = GetTree().GetNodesInGroup("Persist");
        foreach (Node saveNode in saveNodes)
        {
            // Check the node is an instanced scene so it can be instanced again during load.
            if (saveNode.Filename.Empty())
            {
                GD.Print(String.Format("persistent node '{0}' is not an instanced scene, skipped", saveNode.Name));
                continue;
            }

            // Check the node has a save function.
            if (!saveNode.HasMethod("Save"))
            {
                GD.Print(String.Format("persistent node '{0}' is missing a Save() function, skipped", saveNode.Name));
                continue;
            }

            // Call the node's save function.
            var nodeData = saveNode.Call("Save");

            // Store the save dictionary as a new line in the save file.
            saveGame.StoreLine(JSON.Print(nodeData));
        }

        saveGame.Close();
    }


Game saved! Loading is fairly simple as well. For that, we'll read each
line, use parse_json() to read it back to a dict, and then iterate over
the dict to read our values. But we'll need to first create the object
and we can use the filename and parent values to achieve that. Here is our
load function:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Note: This can be called from anywhere inside the tree. This function
    # is path independent.
    func load_game():
        var save_game = File.new()
        if not save_game.file_exists("user://savegame.save"):
            return # Error! We don't have a save to load.

        # We need to revert the game state so we're not cloning objects
        # during loading. This will vary wildly depending on the needs of a
        # project, so take care with this step.
        # For our example, we will accomplish this by deleting saveable objects.
        var save_nodes = get_tree().get_nodes_in_group("Persist")
        for i in save_nodes:
            i.queue_free()

        # Load the file line by line and process that dictionary to restore
        # the object it represents.
        save_game.open("user://savegame.save", File.READ)
        while save_game.get_position() < save_game.get_len():
            # Get the saved dictionary from the next line in the save file
            var node_data = parse_json(save_game.get_line())

            # Firstly, we need to create the object and add it to the tree and set its position.
            var new_object = load(node_data["filename"]).instance()
            get_node(node_data["parent"]).add_child(new_object)
            new_object.position = Vector2(node_data["pos_x"], node_data["pos_y"])

            # Now we set the remaining variables.
            for i in node_data.keys():
                if i == "filename" or i == "parent" or i == "pos_x" or i == "pos_y":
                    continue
                new_object.set(i, node_data[i])

        save_game.close()

 .. code-tab:: csharp

    // Note: This can be called from anywhere inside the tree. This function is
    // path independent.
    public void LoadGame()
    {
        var saveGame = new File();
        if (!saveGame.FileExists("user://savegame.save"))
            return; // Error! We don't have a save to load.

        // We need to revert the game state so we're not cloning objects during loading.
        // This will vary wildly depending on the needs of a project, so take care with
        // this step.
        // For our example, we will accomplish this by deleting saveable objects.
        var saveNodes = GetTree().GetNodesInGroup("Persist");
        foreach (Node saveNode in saveNodes)
            saveNode.QueueFree();

        // Load the file line by line and process that dictionary to restore the object
        // it represents.
        saveGame.Open("user://savegame.save", (int)File.ModeFlags.Read);

        while (saveGame.GetPosition() < saveGame.GetLen())
        {
            // Get the saved dictionary from the next line in the save file
            var nodeData = new Godot.Collections.Dictionary<string, object>((Godot.Collections.Dictionary)JSON.Parse(saveGame.GetLine()).Result);

            // Firstly, we need to create the object and add it to the tree and set its position.
            var newObjectScene = (PackedScene)ResourceLoader.Load(nodeData["Filename"].ToString());
            var newObject = (Node)newObjectScene.Instance();
            GetNode(nodeData["Parent"].ToString()).AddChild(newObject);
            newObject.Set("Position", new Vector2((float)nodeData["PosX"], (float)nodeData["PosY"]));

            // Now we set the remaining variables.
            foreach (KeyValuePair<string, object> entry in nodeData)
            {
                string key = entry.Key.ToString();
                if (key == "Filename" || key == "Parent" || key == "PosX" || key == "PosY")
                    continue;
                newObject.Set(key, entry.Value);
            }
        }

        saveGame.Close();
    }


Now we can save and load an arbitrary number of objects laid out
almost anywhere across the scene tree! Each object can store different
data depending on what it needs to save.

Some notes
----------

We have glossed over setting up the game state for loading. It's ultimately up
to the project creator where much of this logic goes.
This is often complicated and will need to be heavily
customized based on the needs of the individual project.

Additionally, our implementation assumes no Persist objects are children of other
Persist objects. Otherwise, invalid paths would be created. To
accommodate nested Persist objects, consider saving objects in stages.
Load parent objects first so they are available for the :ref:`add_child()
<class_node_method_add_child>`
call when child objects are loaded. You will also need a way to link
children to parents as the :ref:`NodePath
<class_nodepath>` will likely be invalid.


===================================================
/. ./tutorials/io/binary_serialization_api.rst
===================================================

.. _doc_binary_serialization_api:

Binary serialization API
========================

Introduction
------------

Godot has a simple serialization API based on Variant. It's used for
converting data types to an array of bytes efficiently. This API is used
in the functions ``get_var`` and ``store_var`` of :ref:`class_File`
as well as the packet APIs for :ref:`class_PacketPeer`. This format
is *not* used for binary scenes and resources.

Packet specification
--------------------

The packet is designed to be always padded to 4 bytes. All values are
little-endian-encoded. All packets have a 4-byte header representing an
integer, specifying the type of data.

The lowest value two bytes are used to determine the type, while the highest value
two bytes contain flags::

    base_type = val & 0xFFFF;
    flags = val >> 16;

+--------+--------------------------+
| Type   | Value                    |
+========+==========================+
| 0      | null                     |
+--------+--------------------------+
| 1      | bool                     |
+--------+--------------------------+
| 2      | integer                  |
+--------+--------------------------+
| 3      | float                    |
+--------+--------------------------+
| 4      | string                   |
+--------+--------------------------+
| 5      | vector2                  |
+--------+--------------------------+
| 6      | rect2                    |
+--------+--------------------------+
| 7      | vector3                  |
+--------+--------------------------+
| 8      | transform2d              |
+--------+--------------------------+
| 9      | plane                    |
+--------+--------------------------+
| 10     | quat                     |
+--------+--------------------------+
| 11     | aabb                     |
+--------+--------------------------+
| 12     | basis                    |
+--------+--------------------------+
| 13     | transform                |
+--------+--------------------------+
| 14     | color                    |
+--------+--------------------------+
| 15     | node path                |
+--------+--------------------------+
| 16     | rid                      |
+--------+--------------------------+
| 17     | object                   |
+--------+--------------------------+
| 18     | dictionary               |
+--------+--------------------------+
| 19     | array                    |
+--------+--------------------------+
| 20     | raw array                |
+--------+--------------------------+
| 21     | int array                |
+--------+--------------------------+
| 22     | real array               |
+--------+--------------------------+
| 23     | string array             |
+--------+--------------------------+
| 24     | vector2 array            |
+--------+--------------------------+
| 25     | vector3 array            |
+--------+--------------------------+
| 26     | color array              |
+--------+--------------------------+
| 27     | max                      |
+--------+--------------------------+

Following this is the actual packet contents, which varies for each type of
packet. Note that this assumes Godot is compiled with single-precision floats,
which is the default. If Godot was compiled with double-precision floats, the
length of "Float" fields within data structures should be 8, and the offset
should be ``(offset - 4) * 2 + 4``. The "float" type itself always uses double
precision.

0: null
~~~~~~~

1: :ref:`bool<class_bool>`
~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+-----------+---------------------------+
| Offset   | Len   | Type      | Description               |
+==========+=======+===========+===========================+
| 4        | 4     | Integer   | 0 for False, 1 for True   |
+----------+-------+-----------+---------------------------+

2: :ref:`int<class_int>`
~~~~~~~~~~~~~~~~~~~~~~~~

If no flags are set (flags == 0), the integer is sent as a 32 bit integer:

+----------+-------+-----------+--------------------------+
| Offset   | Len   | Type      | Description              |
+==========+=======+===========+==========================+
| 4        | 4     | Integer   | 32-bit signed integer    |
+----------+-------+-----------+--------------------------+

If flag ``ENCODE_FLAG_64`` is set (``flags & 1 == 1``), the integer is sent as
a 64-bit integer:

+----------+-------+-----------+--------------------------+
| Offset   | Len   | Type      | Description              |
+==========+=======+===========+==========================+
| 4        | 8     | Integer   | 64-bit signed integer    |
+----------+-------+-----------+--------------------------+

3: :ref:`float<class_float>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If no flags are set (flags == 0), the float is sent as a 32 bit single precision:

+----------+-------+---------+-----------------------------------+
| Offset   | Len   | Type    | Description                       |
+==========+=======+=========+===================================+
| 4        | 4     | Float   | IEEE 754 single-precision float   |
+----------+-------+---------+-----------------------------------+

If flag ``ENCODE_FLAG_64`` is set (``flags & 1 == 1``), the float is sent as
a 64-bit double precision number:

+----------+-------+---------+-----------------------------------+
| Offset   | Len   | Type    | Description                       |
+==========+=======+=========+===================================+
| 4        | 8     | Float   | IEEE 754 double-precision float   |
+----------+-------+---------+-----------------------------------+

4: :ref:`String<class_string>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+-----------+----------------------------+
| Offset   | Len   | Type      | Description                |
+==========+=======+===========+============================+
| 4        | 4     | Integer   | String length (in bytes)   |
+----------+-------+-----------+----------------------------+
| 8        | X     | Bytes     | UTF-8 encoded string       |
+----------+-------+-----------+----------------------------+

This field is padded to 4 bytes.

5: :ref:`Vector2<class_vector2>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+----------------+
| Offset   | Len   | Type    | Description    |
+==========+=======+=========+================+
| 4        | 4     | Float   | X coordinate   |
+----------+-------+---------+----------------+
| 8        | 4     | Float   | Y coordinate   |
+----------+-------+---------+----------------+

6: :ref:`Rect2<class_rect2>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+----------------+
| Offset   | Len   | Type    | Description    |
+==========+=======+=========+================+
| 4        | 4     | Float   | X coordinate   |
+----------+-------+---------+----------------+
| 8        | 4     | Float   | Y coordinate   |
+----------+-------+---------+----------------+
| 12       | 4     | Float   | X size         |
+----------+-------+---------+----------------+
| 16       | 4     | Float   | Y size         |
+----------+-------+---------+----------------+

7: :ref:`Vector3<class_vector3>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+----------------+
| Offset   | Len   | Type    | Description    |
+==========+=======+=========+================+
| 4        | 4     | Float   | X coordinate   |
+----------+-------+---------+----------------+
| 8        | 4     | Float   | Y coordinate   |
+----------+-------+---------+----------------+
| 12       | 4     | Float   | Z coordinate   |
+----------+-------+---------+----------------+

8: :ref:`Transform2D<class_transform2d>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+---------------------------------------------------------------+
| Offset   | Len   | Type    | Description                                                   |
+==========+=======+=========+===============================================================+
| 4        | 4     | Float   | The X component of the X column vector, accessed via [0][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 8        | 4     | Float   | The Y component of the X column vector, accessed via [0][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 12       | 4     | Float   | The X component of the Y column vector, accessed via [1][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 16       | 4     | Float   | The Y component of the Y column vector, accessed via [1][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 20       | 4     | Float   | The X component of the origin vector, accessed via [2][0]     |
+----------+-------+---------+---------------------------------------------------------------+
| 24       | 4     | Float   | The Y component of the origin vector, accessed via [2][1]     |
+----------+-------+---------+---------------------------------------------------------------+

9: :ref:`Plane<class_plane>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+---------------+
| Offset   | Len   | Type    | Description   |
+==========+=======+=========+===============+
| 4        | 4     | Float   | Normal X      |
+----------+-------+---------+---------------+
| 8        | 4     | Float   | Normal Y      |
+----------+-------+---------+---------------+
| 12       | 4     | Float   | Normal Z      |
+----------+-------+---------+---------------+
| 16       | 4     | Float   | Distance      |
+----------+-------+---------+---------------+

10: :ref:`Quat<class_quat>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+---------------+
| Offset   | Len   | Type    | Description   |
+==========+=======+=========+===============+
| 4        | 4     | Float   | Imaginary X   |
+----------+-------+---------+---------------+
| 8        | 4     | Float   | Imaginary Y   |
+----------+-------+---------+---------------+
| 12       | 4     | Float   | Imaginary Z   |
+----------+-------+---------+---------------+
| 16       | 4     | Float   | Real W        |
+----------+-------+---------+---------------+

11: :ref:`AABB<class_aabb>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+----------------+
| Offset   | Len   | Type    | Description    |
+==========+=======+=========+================+
| 4        | 4     | Float   | X coordinate   |
+----------+-------+---------+----------------+
| 8        | 4     | Float   | Y coordinate   |
+----------+-------+---------+----------------+
| 12       | 4     | Float   | Z coordinate   |
+----------+-------+---------+----------------+
| 16       | 4     | Float   | X size         |
+----------+-------+---------+----------------+
| 20       | 4     | Float   | Y size         |
+----------+-------+---------+----------------+
| 24       | 4     | Float   | Z size         |
+----------+-------+---------+----------------+

12: :ref:`Basis<class_basis>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+---------------------------------------------------------------+
| Offset   | Len   | Type    | Description                                                   |
+==========+=======+=========+===============================================================+
| 4        | 4     | Float   | The X component of the X column vector, accessed via [0][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 8        | 4     | Float   | The Y component of the X column vector, accessed via [0][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 12       | 4     | Float   | The Z component of the X column vector, accessed via [0][2]   |
+----------+-------+---------+---------------------------------------------------------------+
| 16       | 4     | Float   | The X component of the Y column vector, accessed via [1][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 20       | 4     | Float   | The Y component of the Y column vector, accessed via [1][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 24       | 4     | Float   | The Z component of the Y column vector, accessed via [1][2]   |
+----------+-------+---------+---------------------------------------------------------------+
| 28       | 4     | Float   | The X component of the Z column vector, accessed via [2][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 32       | 4     | Float   | The Y component of the Z column vector, accessed via [2][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 36       | 4     | Float   | The Z component of the Z column vector, accessed via [2][2]   |
+----------+-------+---------+---------------------------------------------------------------+

13: :ref:`Transform<class_transform>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+---------------------------------------------------------------+
| Offset   | Len   | Type    | Description                                                   |
+==========+=======+=========+===============================================================+
| 4        | 4     | Float   | The X component of the X column vector, accessed via [0][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 8        | 4     | Float   | The Y component of the X column vector, accessed via [0][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 12       | 4     | Float   | The Z component of the X column vector, accessed via [0][2]   |
+----------+-------+---------+---------------------------------------------------------------+
| 16       | 4     | Float   | The X component of the Y column vector, accessed via [1][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 20       | 4     | Float   | The Y component of the Y column vector, accessed via [1][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 24       | 4     | Float   | The Z component of the Y column vector, accessed via [1][2]   |
+----------+-------+---------+---------------------------------------------------------------+
| 28       | 4     | Float   | The X component of the Z column vector, accessed via [2][0]   |
+----------+-------+---------+---------------------------------------------------------------+
| 32       | 4     | Float   | The Y component of the Z column vector, accessed via [2][1]   |
+----------+-------+---------+---------------------------------------------------------------+
| 36       | 4     | Float   | The Z component of the Z column vector, accessed via [2][2]   |
+----------+-------+---------+---------------------------------------------------------------+
| 40       | 4     | Float   | The X component of the origin vector, accessed via [3][0]     |
+----------+-------+---------+---------------------------------------------------------------+
| 44       | 4     | Float   | The Y component of the origin vector, accessed via [3][1]     |
+----------+-------+---------+---------------------------------------------------------------+
| 48       | 4     | Float   | The Z component of the origin vector, accessed via [3][2]     |
+----------+-------+---------+---------------------------------------------------------------+

14: :ref:`Color<class_color>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+---------+--------------------------------------------------------------+
| Offset   | Len   | Type    | Description                                                  |
+==========+=======+=========+==============================================================+
| 4        | 4     | Float   | Red (typically 0..1, can be above 1 for overbright colors)   |
+----------+-------+---------+--------------------------------------------------------------+
| 8        | 4     | Float   | Green (typically 0..1, can be above 1 for overbright colors) |
+----------+-------+---------+--------------------------------------------------------------+
| 12       | 4     | Float   | Blue (typically 0..1, can be above 1 for overbright colors)  |
+----------+-------+---------+--------------------------------------------------------------+
| 16       | 4     | Float   | Alpha (0..1)                                                 |
+----------+-------+---------+--------------------------------------------------------------+

15: :ref:`NodePath<class_nodepath>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+-----------+-----------------------------------------------------------------------------------------+
| Offset   | Len   | Type      | Description                                                                             |
+==========+=======+===========+=========================================================================================+
| 4        | 4     | Integer   | String length, or new format (val&0x80000000!=0 and NameCount=val&0x7FFFFFFF)           |
+----------+-------+-----------+-----------------------------------------------------------------------------------------+

For old format:
^^^^^^^^^^^^^^^

+----------+-------+---------+------------------------+
| Offset   | Len   | Type    | Description            |
+==========+=======+=========+========================+
| 8        | X     | Bytes   | UTF-8 encoded string   |
+----------+-------+---------+------------------------+

Padded to 4 bytes.

For new format:
^^^^^^^^^^^^^^^

+----------+-------+-----------+-------------------------------------+
| Offset   | Len   | Type      | Description                         |
+==========+=======+===========+=====================================+
| 4        | 4     | Integer   | Sub-name count                      |
+----------+-------+-----------+-------------------------------------+
| 8        | 4     | Integer   | Flags (absolute: val&1 != 0 )       |
+----------+-------+-----------+-------------------------------------+

For each Name and Sub-Name

+----------+-------+-----------+------------------------+
| Offset   | Len   | Type      | Description            |
+==========+=======+===========+========================+
| X+0      | 4     | Integer   | String length          |
+----------+-------+-----------+------------------------+
| X+4      | X     | Bytes     | UTF-8 encoded string   |
+----------+-------+-----------+------------------------+

Every name string is padded to 4 bytes.

16: :ref:`RID<class_rid>` (unsupported)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

17: :ref:`Object<class_object>` (unsupported)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

18: :ref:`Dictionary<class_dictionary>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+-----------+---------------------------------------------------------------------+
| Offset   | Len   | Type      | Description                                                         |
+==========+=======+===========+=====================================================================+
| 4        | 4     | Integer   | val&0x7FFFFFFF = elements, val&0x80000000 = shared (bool)           |
+----------+-------+-----------+---------------------------------------------------------------------+

Then what follows is, for amount of "elements", pairs of key and value,
one after the other, using this same format.

19: :ref:`Array<class_array>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+-----------+---------------------------------------------------------------------+
| Offset   | Len   | Type      | Description                                                         |
+==========+=======+===========+=====================================================================+
| 4        | 4     | Integer   | val&0x7FFFFFFF = elements, val&0x80000000 = shared (bool)           |
+----------+-------+-----------+---------------------------------------------------------------------+

Then what follows is, for amount of "elements", values one after the
other, using this same format.

20: :ref:`PoolByteArray<class_poolbytearray>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+---------------+-------+-----------+------------------------+
| Offset        | Len   | Type      | Description            |
+===============+=======+===========+========================+
| 4             | 4     | Integer   | Array length (Bytes)   |
+---------------+-------+-----------+------------------------+
| 8..8+length   | 1     | Byte      | Byte (0..255)          |
+---------------+-------+-----------+------------------------+

The array data is padded to 4 bytes.

21: :ref:`PoolIntArray<class_poolintarray>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+------------------+-------+-----------+---------------------------+
| Offset           | Len   | Type      | Description               |
+==================+=======+===========+===========================+
| 4                | 4     | Integer   | Array length (Integers)   |
+------------------+-------+-----------+---------------------------+
| 8..8+length\*4   | 4     | Integer   | 32-bit signed integer     |
+------------------+-------+-----------+---------------------------+

22: :ref:`PoolRealArray<class_poolrealarray>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+------------------+-------+-----------+---------------------------+
| Offset           | Len   | Type      | Description               |
+==================+=======+===========+===========================+
| 4                | 4     | Integer   | Array length (Floats)     |
+------------------+-------+-----------+---------------------------+
| 8..8+length\*4   | 4     | Integer   | 32-bits IEEE 754 float    |
+------------------+-------+-----------+---------------------------+

23: :ref:`PoolStringArray<class_poolstringarray>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+-------+-----------+--------------------------+
| Offset   | Len   | Type      | Description              |
+==========+=======+===========+==========================+
| 4        | 4     | Integer   | Array length (Strings)   |
+----------+-------+-----------+--------------------------+

For each String:

+----------+-------+-----------+------------------------+
| Offset   | Len   | Type      | Description            |
+==========+=======+===========+========================+
| X+0      | 4     | Integer   | String length          |
+----------+-------+-----------+------------------------+
| X+4      | X     | Bytes     | UTF-8 encoded string   |
+----------+-------+-----------+------------------------+

Every string is padded to 4 bytes.

24: :ref:`PoolVector2Array<class_poolvector2array>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-------------------+-------+-----------+----------------+
| Offset            | Len   | Type      | Description    |
+===================+=======+===========+================+
| 4                 | 4     | Integer   | Array length   |
+-------------------+-------+-----------+----------------+
| 8..8+length\*8    | 4     | Float     | X coordinate   |
+-------------------+-------+-----------+----------------+
| 8..12+length\*8   | 4     | Float     | Y coordinate   |
+-------------------+-------+-----------+----------------+

25: :ref:`PoolVector3Array<class_poolvector3array>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+--------------------+-------+-----------+----------------+
| Offset             | Len   | Type      | Description    |
+====================+=======+===========+================+
| 4                  | 4     | Integer   | Array length   |
+--------------------+-------+-----------+----------------+
| 8..8+length\*12    | 4     | Float     | X coordinate   |
+--------------------+-------+-----------+----------------+
| 8..12+length\*12   | 4     | Float     | Y coordinate   |
+--------------------+-------+-----------+----------------+
| 8..16+length\*12   | 4     | Float     | Z coordinate   |
+--------------------+-------+-----------+----------------+

26: :ref:`PoolColorArray<class_poolcolorarray>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+--------------------+-------+-----------+--------------------------------------------------------------+
| Offset             | Len   | Type      | Description                                                  |
+====================+=======+===========+==============================================================+
| 4                  | 4     | Integer   | Array length                                                 |
+--------------------+-------+-----------+--------------------------------------------------------------+
| 8..8+length\*16    | 4     | Float     | Red (typically 0..1, can be above 1 for overbright colors)   |
+--------------------+-------+-----------+--------------------------------------------------------------+
| 8..12+length\*16   | 4     | Float     | Green (typically 0..1, can be above 1 for overbright colors) |
+--------------------+-------+-----------+--------------------------------------------------------------+
| 8..16+length\*16   | 4     | Float     | Blue (typically 0..1, can be above 1 for overbright colors)  |
+--------------------+-------+-----------+--------------------------------------------------------------+
| 8..20+length\*16   | 4     | Float     | Alpha (0..1)                                                 |
+--------------------+-------+-----------+--------------------------------------------------------------+


===================================================
/. ./tutorials/math/index.rst
===================================================

Math
====

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-math

   vector_math
   vectors_advanced
   matrices_and_transforms
   interpolation
   beziers_and_curves
   random_number_generation


===================================================
/. ./tutorials/math/vector_math.rst
===================================================

.. _doc_vector_math:

Vector math
===========

Introduction
~~~~~~~~~~~~

This tutorial is a short and practical introduction to linear algebra as
it applies to game development. Linear algebra is the study of vectors and
their uses. Vectors have many applications in both 2D and 3D development
and Godot uses them extensively. Developing a good understanding of vector
math is essential to becoming a strong game developer.

.. note:: This tutorial is **not** a formal textbook on linear algebra. We
          will only be looking at how it is applied to game development.
          For a broader look at the mathematics,
          see https://www.khanacademy.org/math/linear-algebra

Coordinate systems (2D)
~~~~~~~~~~~~~~~~~~~~~~~

In 2D space, coordinates are defined using a horizontal axis (``x``) and
a vertical axis (``y``). A particular position in 2D space is written
as a pair of values such as ``(4, 3)``.

.. image:: img/vector_axis1.png

.. note:: If you're new to computer graphics, it might seem odd that the
          positive ``y`` axis points **downwards** instead of upwards,
          as you probably learned in math class. However, this is common
          in most computer graphics applications.

Any position in the 2D plane can be identified by a pair of numbers in this
way. However, we can also think of the position ``(4, 3)`` as an **offset**
from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from
the origin to the point:

.. image:: img/vector_xy1.png

This is a **vector**. A vector represents a lot of useful information. As
well as telling us that the point is at ``(4, 3)``, we can also think of
it as an angle ``θ`` and a length (or magnitude) ``m``. In this case, the
arrow is a **position vector** - it denotes a position in space, relative
to the origin.

A very important point to consider about vectors is that they only
represent **relative** direction and magnitude. There is no concept of
a vector's position. The following two vectors are identical:

.. image:: img/vector_xy2.png

Both vectors represent a point 4 units to the right and 3 units below some
starting point. It does not matter where on the plane you draw the vector,
it always represents a relative direction and magnitude.

Vector operations
~~~~~~~~~~~~~~~~~

You can use either method (x and y coordinates or angle and magnitude) to
refer to a vector, but for convenience, programmers typically use the
coordinate notation. For example, in Godot, the origin is the top-left
corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to the right and
300 pixels down, use the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    $Node2D.position = Vector2(400, 300)

 .. code-tab:: csharp

    var node2D = GetNode<Node2D>("Node2D");
    node2D.Position = new Vector2(400, 300);

Godot supports both :ref:`Vector2 <class_Vector2>` and
:ref:`Vector3 <class_Vector3>` for 2D and 3D usage, respectively. The same
mathematical rules discussed in this article apply to both types.

Member access
-------------

The individual components of the vector can be accessed directly by name.

.. tabs::
 .. code-tab:: gdscript GDScript

    # create a vector with coordinates (2, 5)
    var a = Vector2(2, 5)
    # create a vector and assign x and y manually
    var b = Vector2()
    b.x = 3
    b.y = 1

 .. code-tab:: csharp

    // create a vector with coordinates (2, 5)
    var a = new Vector2(2, 5);
    // create a vector and assign x and y manually
    var b = new Vector2();
    b.x = 3;
    b.y = 1;

Adding vectors
--------------

When adding or subtracting two vectors, the corresponding components are added:

.. tabs::
 .. code-tab:: gdscript GDScript

    var c = a + b  # (2, 5) + (3, 1) = (5, 6)

 .. code-tab:: csharp

    var c = a + b;  // (2, 5) + (3, 1) = (5, 6)

We can also see this visually by adding the second vector at the end of
the first:

.. image:: img/vector_add1.png

Note that adding ``a + b`` gives the same result as ``b + a``.

Scalar multiplication
---------------------

.. note:: Vectors represent both direction and magnitude. A value
          representing only magnitude is called a **scalar**.

A vector can be multiplied by a **scalar**:

.. tabs::
 .. code-tab:: gdscript GDScript

    var c = a * 2  # (2, 5) * 2 = (4, 10)
    var d = b / 3  # (3, 6) / 3 = (1, 2)

 .. code-tab:: csharp

    var c = a * 2;  // (2, 5) * 2 = (4, 10)
    var d = b / 3;  // (3, 6) / 3 = (1, 2)

.. image:: img/vector_mult1.png

.. note:: Multiplying a vector by a scalar does not change its direction,
          only its magnitude. This is how you **scale** a vector.

Practical applications
~~~~~~~~~~~~~~~~~~~~~~

Let's look at two common uses for vector addition and subtraction.

Movement
--------

A vector can represent **any** quantity with a magnitude and direction. Typical examples are: position, velocity, acceleration, and force. In
this image, the spaceship at step 1 has a position vector of ``(1,3)`` and
a velocity vector of ``(2,1)``. The velocity vector represents how far the
ship moves each step. We can find the position for step 2 by adding
the velocity to the current position.

.. image:: img/vector_movement1.png

.. tip:: Velocity measures the **change** in position per unit of time. The
         new position is found by adding velocity to the previous position.

Pointing toward a target
------------------------

In this scenario, you have a tank that wishes to point its turret at a
robot. Subtracting the tank's position from the robot's position gives the
vector pointing from the tank to the robot.

.. image:: img/vector_subtract2.png

.. tip:: To find a vector pointing from ``A`` to ``B`` use ``B - A``.

Unit vectors
~~~~~~~~~~~~

A vector with **magnitude** of ``1`` is called a **unit vector**. They are
also sometimes referred to as **direction vectors** or **normals**. Unit
vectors are helpful when you need to keep track of a direction.

Normalization
-------------

**Normalizing** a vector means reducing its length to ``1`` while
preserving its direction. This is done by dividing each of its components
by its magnitude. Because this is such a common operation,
``Vector2`` and ``Vector3`` provide a method for normalizing:

.. tabs::
 .. code-tab:: gdscript GDScript

    a = a.normalized()

 .. code-tab:: csharp

    a = a.Normalized();


.. warning:: Because normalization involves dividing by the vector's length,
             you cannot normalize a vector of length ``0``. Attempting to
             do so will result in an error.

Reflection
----------

A common use of unit vectors is to indicate **normals**. Normal
vectors are unit vectors aligned perpendicularly to a surface, defining
its direction. They are commonly used for lighting, collisions, and other
operations involving surfaces.

For example, imagine we have a moving ball that we want to bounce off a
wall or other object:

.. image:: img/vector_reflect1.png

The surface normal has a value of ``(0, -1)`` because this is a horizontal
surface. When the ball collides, we take its remaining motion (the amount
left over when it hits the surface) and reflect it using the normal. In
Godot, the :ref:`Vector2 <class_Vector2>` class has a ``bounce()`` method
to handle this. Here is a GDScript example of the diagram above using a
:ref:`KinematicBody2D <class_KinematicBody2D>`:


.. tabs::
 .. code-tab:: gdscript GDScript

    # object "collision" contains information about the collision
    var collision = move_and_collide(velocity * delta)
    if collision:
        var reflect = collision.remainder.bounce(collision.normal)
        velocity = velocity.bounce(collision.normal)
        move_and_collide(reflect)

 .. code-tab:: csharp

    // KinematicCollision2D contains information about the collision
    KinematicCollision2D collision = MoveAndCollide(_velocity * delta);
    if (collision != null)
    {
        var reflect = collision.Remainder.Bounce(collision.Normal);
        _velocity = _velocity.Bounce(collision.Normal);
        MoveAndCollide(reflect);
    }

Dot product
~~~~~~~~~~~

The **dot product** is one of the most important concepts in vector math,
but is often misunderstood. Dot product is an operation on two vectors that
returns a **scalar**. Unlike a vector, which contains both magnitude and
direction, a scalar value has only magnitude.

The formula for dot product takes two common forms:

.. image:: img/vector_dot1.png

and

.. image:: img/vector_dot2.png

However, in most cases it is easiest to use the built-in method. Note that
the order of the two vectors does not matter:

.. tabs::
 .. code-tab:: gdscript GDScript

    var c = a.dot(b)
    var d = b.dot(a) # These are equivalent.

 .. code-tab:: csharp

    float c = a.Dot(b);
    float d = b.Dot(a); // These are equivalent.

The dot product is most useful when used with unit vectors, making the
first formula reduce to just ``cosθ``. This means we can use the dot
product to tell us something about the angle between two vectors:

.. image:: img/vector_dot3.png

When using unit vectors, the result will always be between ``-1`` (180°)
and ``1`` (0°).

Facing
------

We can use this fact to detect whether an object is facing toward another
object. In the diagram below, the player ``P`` is trying to avoid the
zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can they see the player?

.. image:: img/vector_facing2.png

The green arrows ``fA`` and ``fB`` are **unit vectors** representing the
zombies' facing directions and the blue semicircle represents its field of
view. For zombie ``A``, we find the direction vector ``AP`` pointing to
the player using ``P - A`` and normalize it, however, Godot has a helper
method to do this called ``direction_to``. If the angle between this
vector and the facing vector is less than 90°, then the zombie can see
the player.

In code it would look like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    var AP = A.direction_to(P)
    if AP.dot(fA) > 0:
        print("A sees P!")

 .. code-tab:: csharp

    var AP = A.DirectionTo(P);
    if (AP.Dot(fA) > 0)
    {
        GD.Print("A sees P!");
    }

Cross product
~~~~~~~~~~~~~

Like the dot product, the **cross product** is an operation on two vectors.
However, the result of the cross product is a vector with a direction
that is perpendicular to both. Its magnitude depends on their relative angle.
If two vectors are parallel, the result of their cross product will be a null vector.

.. image:: img/vector_cross1.png

.. image:: img/vector_cross2.png

The cross product is calculated like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    var c = Vector3()
    c.x = (a.y * b.z) - (a.z * b.y)
    c.y = (a.z * b.x) - (a.x * b.z)
    c.z = (a.x * b.y) - (a.y * b.x)

 .. code-tab:: csharp

    var c = new Vector3();
    c.x = (a.y * b.z) - (a.z * b.y);
    c.y = (a.z * b.x) - (a.x * b.z);
    c.z = (a.x * b.y) - (a.y * b.x);



With Godot, you can use the built-in method:

.. tabs::
 .. code-tab:: gdscript GDScript

    var c = a.cross(b)

 .. code-tab:: csharp

    var c = a.Cross(b);

.. note:: In the cross product, order matters. ``a.cross(b)`` does not
          give the same result as ``b.cross(a)``. The resulting vectors
          point in **opposite** directions.

Calculating normals
-------------------

One common use of cross products is to find the surface normal of a plane
or surface in 3D space. If we have the triangle ``ABC`` we can use vector
subtraction to find two edges ``AB`` and ``AC``. Using the cross product,
``AB x AC`` produces a vector perpendicular to both: the surface normal.

Here is a function to calculate a triangle's normal:

.. tabs::
 .. code-tab:: gdscript GDScript

    func get_triangle_normal(a, b, c):
        # find the surface normal given 3 vertices
        var side1 = b - a
        var side2 = c - a
        var normal = side1.cross(side2)
        return normal

 .. code-tab:: csharp

    Vector3 GetTriangleNormal(Vector3 a, Vector3 b, Vector3 c)
    {
        // find the surface normal given 3 vertices
        var side1 = b - a;
        var side2 = c - a;
        var normal = side1.Cross(side2);
        return normal;
    }

Pointing to a target
--------------------

In the dot product section above, we saw how it could be used to find the
angle between two vectors. However, in 3D, this is not enough information.
We also need to know what axis to rotate around. We can find that by
calculating the cross product of the current facing direction and the
target direction. The resulting perpendicular vector is the axis of
rotation.

More information
~~~~~~~~~~~~~~~~

For more information on using vector math in Godot, see the following articles:

- :ref:`doc_vectors_advanced`
- :ref:`doc_matrices_and_transforms`


===================================================
/. ./tutorials/math/vectors_advanced.rst
===================================================

.. _doc_vectors_advanced:

Advanced vector math
====================

Planes
~~~~~~

The dot product has another interesting property with unit vectors.
Imagine that perpendicular to that vector (and through the origin)
passes a plane. Planes divide the entire space into positive
(over the plane) and negative (under the plane), and (contrary to
popular belief) you can also use their math in 2D:

.. image:: img/tutovec10.png

Unit vectors that are perpendicular to a surface (so, they describe the
orientation of the surface) are called **unit normal vectors**. Though,
usually they are just abbreviated as *normals*. Normals appear in
planes, 3D geometry (to determine where each face or vertex is siding),
etc. A **normal** *is* a **unit vector**, but it's called *normal*
because of its usage. (Just like we call (0,0) the Origin!).

It's as simple as it looks. The plane passes by the origin and the
surface of it is perpendicular to the unit vector (or *normal*). The
side towards the vector points to is the positive half-space, while the
other side is the negative half-space. In 3D this is exactly the same,
except that the plane is an infinite surface (imagine an infinite, flat
sheet of paper that you can orient and is pinned to the origin) instead
of a line.

Distance to plane
-----------------

Now that it's clear what a plane is, let's go back to the dot product.
The dot product between a **unit vector** and any **point in space**
(yes, this time we do dot product between vector and position), returns
the **distance from the point to the plane**:

.. tabs::
 .. code-tab:: gdscript GDScript

    var distance = normal.dot(point)

 .. code-tab:: csharp

    var distance = normal.Dot(point);

But not just the absolute distance, if the point is in the negative half
space the distance will be negative, too:

.. image:: img/tutovec11.png

This allows us to tell which side of the plane a point is.

Away from the origin
--------------------

I know what you are thinking! So far this is nice, but *real* planes are
everywhere in space, not only passing through the origin. You want real
*plane* action and you want it *now*.

Remember that planes not only split space in two, but they also have
*polarity*. This means that it is possible to have perfectly overlapping
planes, but their negative and positive half-spaces are swapped.

With this in mind, let's describe a full plane as a **normal** *N* and a
**distance from the origin** scalar *D*. Thus, our plane is represented
by N and D. For example:

.. image:: img/tutovec12.png

For 3D math, Godot provides a :ref:`Plane <class_Plane>`
built-in type that handles this.

Basically, N and D can represent any plane in space, be it for 2D or 3D
(depending on the amount of dimensions of N) and the math is the same
for both. It's the same as before, but D is the distance from the origin
to the plane, travelling in N direction. As an example, imagine you want
to reach a point in the plane, you will just do:

.. tabs::
 .. code-tab:: gdscript GDScript

    var point_in_plane = N*D

 .. code-tab:: csharp

    var pointInPlane = N * D;

This will stretch (resize) the normal vector and make it touch the
plane. This math might seem confusing, but it's actually much simpler
than it seems. If we want to tell, again, the distance from the point to
the plane, we do the same but adjusting for distance:

.. tabs::
 .. code-tab:: gdscript GDScript

    var distance = N.dot(point) - D

 .. code-tab:: csharp

    var distance = N.Dot(point) - D;

The same thing, using a built-in function:

.. tabs::
 .. code-tab:: gdscript GDScript

    var distance = plane.distance_to(point)

 .. code-tab:: csharp

    var distance = plane.DistanceTo(point);

This will, again, return either a positive or negative distance.

Flipping the polarity of the plane can be done by negating both
N and D. This will result in a plane in the same position, but with
inverted negative and positive half spaces:

.. tabs::
 .. code-tab:: gdscript GDScript

    N = -N
    D = -D

 .. code-tab:: csharp

    N = -N;
    D = -D;

Of course, Godot also implements this operator in :ref:`Plane <class_Plane>`,
so doing:

.. tabs::
 .. code-tab:: gdscript GDScript

    var inverted_plane = -plane

 .. code-tab:: csharp

    var invertedPlane = -plane;

Will work as expected.

So, remember, a plane is just that and its main practical use is
calculating the distance to it. So, why is it useful to calculate the
distance from a point to a plane? It's extremely useful! Let's see some
simple examples..

Constructing a plane in 2D
--------------------------

Planes clearly don't come out of nowhere, so they must be built.
Constructing them in 2D is easy, this can be done from either a normal
(unit vector) and a point, or from two points in space.

In the case of a normal and a point, most of the work is done, as the
normal is already computed, so just calculate D from the dot product of
the normal and the point.

.. tabs::
 .. code-tab:: gdscript GDScript

    var N = normal
    var D = normal.dot(point)

 .. code-tab:: csharp

    var N = normal;
    var D = normal.Dot(point);

For two points in space, there are actually two planes that pass through
them, sharing the same space but with normal pointing to the opposite
directions. To compute the normal from the two points, the direction
vector must be obtained first, and then it needs to be rotated 90°
degrees to either side:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Calculate vector from `a` to `b`.
    var dvec = (point_b - point_a).normalized()
    # Rotate 90 degrees.
    var normal = Vector2(dvec.y, -dvec.x)
    # Alternatively (depending the desired side of the normal):
    # var normal = Vector2(-dvec.y, dvec.x)

 .. code-tab:: csharp

    // Calculate vector from `a` to `b`.
    var dvec = (pointB - pointA).Normalized();
    // Rotate 90 degrees.
    var normal = new Vector2(dvec.y, -dvec.x);
    // Alternatively (depending the desired side of the normal):
    // var normal = new Vector2(-dvec.y, dvec.x);

The rest is the same as the previous example, either point_a or
point_b will work since they are in the same plane:

.. tabs::
 .. code-tab:: gdscript GDScript

    var N = normal
    var D = normal.dot(point_a)
    # this works the same
    # var D = normal.dot(point_b)

 .. code-tab:: csharp

    var N = normal;
    var D = normal.Dot(pointA);
    // this works the same
    // var D = normal.Dot(pointB);

Doing the same in 3D is a little more complex and will be explained
further down.

Some examples of planes
-----------------------

Here is a simple example of what planes are useful for. Imagine you have
a `convex <https://www.mathsisfun.com/definitions/convex.html>`__
polygon. For example, a rectangle, a trapezoid, a triangle, or just any
polygon where no faces bend inwards.

For every segment of the polygon, we compute the plane that passes by
that segment. Once we have the list of planes, we can do neat things,
for example checking if a point is inside the polygon.

We go through all planes, if we can find a plane where the distance to
the point is positive, then the point is outside the polygon. If we
can't, then the point is inside.

.. image:: img/tutovec13.png

Code should be something like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    var inside = true
    for p in planes:
        # check if distance to plane is positive
        if (p.distance_to(point) > 0):
            inside = false
            break # with one that fails, it's enough

 .. code-tab:: csharp

    var inside = true;
    foreach (var p in planes)
    {
        // check if distance to plane is positive
        if (p.DistanceTo(point) > 0)
        {
            inside = false;
            break; // with one that fails, it's enough
        }
    }

Pretty cool, huh? But this gets much better! With a little more effort,
similar logic will let us know when two convex polygons are overlapping
too. This is called the Separating Axis Theorem (or SAT) and most
physics engines use this to detect collision.

With a point, just checking if a plane
returns a positive distance is enough to tell if the point is outside.
With another polygon, we must find a plane where *all* *the* *other*
*polygon* *points* return a positive distance to it. This check is
performed with the planes of A against the points of B, and then with
the planes of B against the points of A:

.. image:: img/tutovec14.png

Code should be something like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    var overlapping = true

    for p in planes_of_A:
        var all_out = true
        for v in points_of_B:
            if (p.distance_to(v) < 0):
                all_out = false
                break

        if (all_out):
            # a separating plane was found
            # do not continue testing
            overlapping = false
            break

    if (overlapping):
        # only do this check if no separating plane
        # was found in planes of A
        for p in planes_of_B:
            var all_out = true
            for v in points_of_A:
                if (p.distance_to(v) < 0):
                    all_out = false
                    break

            if (all_out):
                overlapping = false
                break

    if (overlapping):
        print("Polygons Collided!")

 .. code-tab:: csharp

        var overlapping = true;

        foreach (Plane plane in planesOfA)
        {
            var allOut = true;
            foreach (Vector3 point in pointsOfB)
            {
                if (plane.DistanceTo(point) < 0)
                {
                    allOut = false;
                    break;
                }
            }

            if (allOut)
            {
                // a separating plane was found
                // do not continue testing
                overlapping = false;
                break;
            }
        }

        if (overlapping)
        {
            // only do this check if no separating plane
            // was found in planes of A
            foreach (Plane plane in planesOfB)
            {
                var allOut = true;
                foreach (Vector3 point in pointsOfA)
                {
                    if (plane.DistanceTo(point) < 0)
                    {
                        allOut = false;
                        break;
                    }
                }

                if (allOut)
                {
                    overlapping = false;
                    break;
                }
            }
        }

        if (overlapping)
        {
            GD.Print("Polygons Collided!");
        }

As you can see, planes are quite useful, and this is the tip of the
iceberg. You might be wondering what happens with non convex polygons.
This is usually just handled by splitting the concave polygon into
smaller convex polygons, or using a technique such as BSP (which is not
used much nowadays).

Collision detection in 3D
~~~~~~~~~~~~~~~~~~~~~~~~~

This is another bonus bit, a reward for being patient and keeping up
with this long tutorial. Here is another piece of wisdom. This might
not be something with a direct use case (Godot already does collision
detection pretty well) but it's used by almost all physics engines and collision
detection libraries :)

Remember that converting a convex shape in 2D to an array of 2D planes
was useful for collision detection? You could detect if a point was
inside any convex shape, or if two 2D convex shapes were overlapping.

Well, this works in 3D too, if two 3D polyhedral shapes are colliding,
you won't be able to find a separating plane. If a separating plane is
found, then the shapes are definitely not colliding.

To refresh a bit a separating plane means that all vertices of polygon A
are in one side of the plane, and all vertices of polygon B are in the
other side. This plane is always one of the face-planes of either
polygon A or polygon B.

In 3D though, there is a problem to this approach, because it is
possible that, in some cases a separating plane can't be found. This is
an example of such situation:

.. image:: img/tutovec22.png

To avoid it, some extra planes need to be tested as separators, these
planes are the cross product between the edges of polygon A and the
edges of polygon B

.. image:: img/tutovec23.png

So the final algorithm is something like:

.. tabs::
 .. code-tab:: gdscript GDScript

    var overlapping = true

    for p in planes_of_A:
        var all_out = true
        for v in points_of_B:
            if (p.distance_to(v) < 0):
                all_out = false
                break

        if (all_out):
            # a separating plane was found
            # do not continue testing
            overlapping = false
            break

    if (overlapping):
        # only do this check if no separating plane
        # was found in planes of A
        for p in planes_of_B:
            var all_out = true
            for v in points_of_A:
                if (p.distance_to(v) < 0):
                    all_out = false
                    break

            if (all_out):
                overlapping = false
                break

    if (overlapping):
        for ea in edges_of_A:
            for eb in edges_of_B:
                var n = ea.cross(eb)
                if (n.length() == 0):
                    continue

                var max_A = -1e20 # tiny number
                var min_A = 1e20 # huge number

                # we are using the dot product directly
                # so we can map a maximum and minimum range
                # for each polygon, then check if they
                # overlap.

                for v in points_of_A:
                    var d = n.dot(v)
                    max_A = max(max_A, d)
                    min_A = min(min_A, d)

                var max_B = -1e20 # tiny number
                var min_B = 1e20 # huge number

                for v in points_of_B:
                    var d = n.dot(v)
                    max_B = max(max_B, d)
                    min_B = min(min_B, d)

                if (min_A > max_B or min_B > max_A):
                    # not overlapping!
                    overlapping = false
                    break

            if (not overlapping):
                break

    if (overlapping):
       print("Polygons collided!")

 .. code-tab:: csharp

    var overlapping = true;

    foreach (Plane plane in planesOfA)
    {
        var allOut = true;
        foreach (Vector3 point in pointsOfB)
        {
            if (plane.DistanceTo(point) < 0)
            {
                allOut = false;
                break;
            }
        }

        if (allOut)
        {
            // a separating plane was found
            // do not continue testing
            overlapping = false;
            break;
        }
    }

    if (overlapping)
    {
        // only do this check if no separating plane
        // was found in planes of A
        foreach (Plane plane in planesOfB)
        {
            var allOut = true;
            foreach (Vector3 point in pointsOfA)
            {
                if (plane.DistanceTo(point) < 0)
                {
                    allOut = false;
                    break;
                }
            }

            if (allOut)
            {
                overlapping = false;
                break;
            }
        }
    }

    if (overlapping)
    {
        foreach (Vector3 edgeA in edgesOfA)
        {
            foreach (Vector3 edgeB in edgesOfB)
            {
                var normal = edgeA.Cross(edgeB);
                if (normal.Length() == 0)
                {
                    continue;
                }

                var maxA = float.MinValue; // tiny number
                var minA = float.MaxValue; // huge number

                // we are using the dot product directly
                // so we can map a maximum and minimum range
                // for each polygon, then check if they
                // overlap.

                foreach (Vector3 point in pointsOfA)
                {
                    var distance = normal.Dot(point);
                    maxA = Mathf.Max(maxA, distance);
                    minA = Mathf.Min(minA, distance);
                }

                var maxB = float.MinValue; // tiny number
                var minB = float.MaxValue; // huge number

                foreach (Vector3 point in pointsOfB)
                {
                    var distance = normal.Dot(point);
                    maxB = Mathf.Max(maxB, distance);
                    minB = Mathf.Min(minB, distance);
                }

                if (minA > maxB || minB > maxA)
                {
                    // not overlapping!
                    overlapping = false;
                    break;
                }
            }

            if (!overlapping)
            {
                break;
            }

        }
    }

    if (overlapping)
    {
        GD.Print("Polygons Collided!");
    }

More information
~~~~~~~~~~~~~~~~

For more information on using vector math in Godot, see the following article:

- :ref:`doc_matrices_and_transforms`

If you would like additional explanation, you should check out
3Blue1Brown's excellent video series "Essence of Linear Algebra":
https://www.youtube.com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab


===================================================
/. ./tutorials/math/matrices_and_transforms.rst
===================================================

.. _doc_matrices_and_transforms:

Matrices and transforms
=======================

Introduction
------------

Before reading this tutorial, we recommend that you thoroughly read
and understand the :ref:`doc_vector_math` tutorial, as this tutorial
requires a knowledge of vectors.

This tutorial is about *transformations* and how we represent them
in Godot using matrices. It is not a full in-depth guide to matrices.
Transformations are most of the time applied as translation, rotation,
and scale, so we will focus on how to represent those with matrices.

Most of this guide focuses on 2D, using :ref:`class_Transform2D` and
:ref:`class_Vector2`, but the way things work in 3D is very similar.

.. note:: As mentioned in the previous tutorial, it is important to
          remember that in Godot, the Y axis points *down* in 2D.
          This is the opposite of how most schools teach linear
          algebra, with the Y axis pointing up.

.. note:: The convention is that the X axis is red, the Y axis is
          green, and the Z axis is blue. This tutorial is color-coded
          to match these conventions, but we will also represent
          the origin vector with a blue color.

Matrix components and the Identity matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The identity matrix represents a transform with no translation,
no rotation, and no scale. Let's start by looking at the identity
matrix and how its components relate to how it visually appears.

.. image:: img/matrices_and_transforms/identity.png

Matrices have rows and columns, and a transformation matrix has
specific conventions on what each does.

In the image above, we can see that the red X vector is represented
by the first column of the matrix, and the green Y vector is
likewise represented by the second column. A change to the columns
will change these vectors. We will see how they can be manipulated
in the next few examples.

You should not worry about manipulating rows directly, as we usually
work with columns. However, you can think of the rows of the matrix
as showing which vectors contribute to moving in a given direction.

When we refer to a value such as `t.x.y`, that's the Y component of
the X column vector. In other words, the bottom-left of the matrix.
Similarly, `t.x.x` is top-left, `t.y.x` is top-right, and `t.y.y`
is bottom-right, where `t` is the Transform2D.

Scaling the transformation matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Applying a scale is one of the easiest operations to understand.
Let's start by placing the Godot logo underneath our vectors
so that we can visually see the effects on an object:

.. image:: img/matrices_and_transforms/identity-godot.png

Now, to scale the matrix, all we need to do is multiply each
component by the scale we want. Let's scale it up by 2. 1 times 2
becomes 2, and 0 times 2 becomes 0, so we end up with this:

.. image:: img/matrices_and_transforms/scale.png

To do this in code, we can simply multiply each of the vectors:

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = Transform2D()
    # Scale
    t.x *= 2
    t.y *= 2
    transform = t # Change the node's transform to what we just calculated.

 .. code-tab:: csharp

    Transform2D t = Transform2D.Identity;
    // Scale
    t.x *= 2;
    t.y *= 2;
    Transform = t; // Change the node's transform to what we just calculated.

If we wanted to return it to its original scale, we can multiply
each component by 0.5. That's pretty much all there is to scaling
a transformation matrix.

To calculate the object's scale from an existing transformation
matrix, you can use `length()` on each of the column vectors.

.. note:: In actual projects, you can use the `scaled()`
          method to perform scaling.

Rotating the transformation matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We'll start the same way as earlier, with the Godot logo underneath
the identity matrix:

.. image:: img/matrices_and_transforms/identity-godot.png

As an example, let's say we want to rotate our Godot logo clockwise
by 90 degrees. Right now the X axis points right and the Y axis
points down. If we rotate these in our head, we would logically
see that the new X axis should point down and the new Y axis
should point left.

You can imagine that you grab both the Godot logo and its vectors,
and then spin it around the center. Wherever you finish spinning,
the orientation of the vectors determines what the matrix is.

We need to represent "down" and "left" in normal coordinates,
so means we'll set X to (0, 1) and Y to (-1, 0). These are
also the values of `Vector2.DOWN` and `Vector2.LEFT`.
When we do this, we get the desired result of rotating the object:

.. image:: img/matrices_and_transforms/rotate1.png

If you have trouble understanding the above, try this exercise:
Cut a square of paper, draw X and Y vectors on top of it, place
it on graph paper, then rotate it and note the endpoints.

To perform rotation in code, we need to be able to calculate
the values programmatically. This image shows the formulas needed
to calculate the transformation matrix from a rotation angle.
Don't worry if this part seems complicated, I promise it's the
hardest thing you need to know.

.. image:: img/matrices_and_transforms/rotate2.png

.. note:: Godot represents all rotations with radians, not degrees.
          A full turn is `TAU` or `PI*2` radians, and a quarter
          turn of 90 degrees is `TAU/4` or `PI/2` radians. Working
          with `TAU` usually results in more readable code.

.. note:: Fun fact: In addition to Y being *down* in Godot, rotation
          is represented clockwise. This means that all the math and
          trig functions behave the same as a Y-is-up CCW system,
          since these differences "cancel out". You can think of
          rotations in both systems being "from X to Y".

In order to perform a rotation of 0.5 radians (about 28.65 degrees),
we simply plug in a value of 0.5 to the formula above and evaluate
to find what the actual values should be:

.. image:: img/matrices_and_transforms/rotate3.png

Here's how that would be done in code (place the script on a Node2D):

.. tabs::
 .. code-tab:: gdscript GDScript

    var rot = 0.5 # The rotation to apply.
    var t = Transform2D()
    t.x.x = cos(rot)
    t.y.y = cos(rot)
    t.x.y = sin(rot)
    t.y.x = -sin(rot)
    transform = t # Change the node's transform to what we just calculated.

 .. code-tab:: csharp

    float rot = 0.5f; // The rotation to apply.
    Transform2D t = Transform2D.Identity;
    t.x.x = t.y.y = Mathf.Cos(rot);
    t.x.y = t.y.x = Mathf.Sin(rot);
    t.y.x *= -1;
    Transform = t; // Change the node's transform to what we just calculated.

To calculate the object's rotation from an existing transformation
matrix, you can use `atan2(t.x.y, t.x.x)`, where t is the Transform2D.

.. note:: In actual projects, you can use the `rotated()`
          method to perform rotations.

Basis of the transformation matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far we have only been working with the `x` and `y`, vectors, which
are in charge of representing rotation, scale, and/or shearing
(advanced, covered at the end). The X and Y vectors are together
called the *basis* of the transformation matrix. The terms "basis"
and "basis vectors" are important to know.

You might have noticed that :ref:`class_Transform2D` actually
has three :ref:`class_Vector2` values: `x`, `y`, and `origin`.
The `origin` value is not part of the basis, but it is part of the
transform, and we need it to represent position. From now on we'll
keep track of the origin vector in all examples. You can think of
origin as another column, but it's often better to think of it as
completely separate.

Note that in 3D, Godot has a separate :ref:`class_Basis` structure
for holding the three :ref:`class_Vector3` values of the basis,
since the code can get complex and it makes sense to separate
it from :ref:`class_Transform` (which is composed of one
:ref:`class_Basis` and one extra :ref:`class_Vector3` for the origin).

Translating the transformation matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Changing the `origin` vector is called a *translating* the transformation
matrix. Translating is basically a technical term for "moving" the
object, but it explicitly does not involve any rotation.

Let's work through an example to help understand this. We will start
with the identity transform like last time, except we will keep track
of the origin vector this time.

.. image:: img/matrices_and_transforms/identity-origin.png

If we want the object to move to a position of (1, 2), we simply need
to set its `origin` vector to (1, 2):

.. image:: img/matrices_and_transforms/translate.png

There is also a `translated()` method, which performs a different
operation to adding or changing `origin` directly. The `translated()`
method will translate the object *relative to its own rotation*.
For example, an object rotated 90 degrees clockwise will move to
the right when `translated()` with `Vector2.UP`.

.. note:: Godot's 2D uses coordinates based on pixels, so in actual
          projects you will want to translate by hundreds of units.

Putting it all together
~~~~~~~~~~~~~~~~~~~~~~~

We're going to apply everything we mentioned so far onto one transform.
To follow along, create a simple project with a Sprite node and use the
Godot logo for the texture resource.

Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3.
I've posted a screenshot, and the code to reproduce it, but I encourage
you to try and reproduce the screenshot without looking at the code!

.. image:: img/matrices_and_transforms/putting-all-together.png

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = Transform2D()
    # Translation
    t.origin = Vector2(350, 150)
    # Rotation
    var rot = -0.5 # The rotation to apply.
    t.x.x = cos(rot)
    t.y.y = cos(rot)
    t.x.y = sin(rot)
    t.y.x = -sin(rot)
    # Scale
    t.x *= 3
    t.y *= 3
    transform = t # Change the node's transform to what we just calculated.

 .. code-tab:: csharp

    Transform2D t = Transform2D.Identity;
    // Translation
    t.origin = new Vector2(350, 150);
    // Rotation
    float rot = -0.5f; // The rotation to apply.
    t.x.x = t.y.y = Mathf.Cos(rot);
    t.x.y = t.y.x = Mathf.Sin(rot);
    t.y.x *= -1;
    // Scale
    t.x *= 3;
    t.y *= 3;
    Transform = t; // Change the node's transform to what we just calculated.

Shearing the transformation matrix (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note:: If you are only looking for how to *use* transformation matrices,
          feel free to skip this section of the tutorial. This section
          explores an uncommonly used aspect of transformation matrices
          for the purpose of building an understanding of them.

You may have noticed that a transform has more degrees of freedom than
the combination of the above actions. The basis of a 2D transformation
matrix has four total numbers in two :ref:`class_Vector2` values, while
a rotation value and a Vector2 for scale only has 3 numbers. The high-level
concept for the missing degree of freedom is called *shearing*.

Normally, you will always have the basis vectors perpendicular to each
other. However, shearing can be useful in some situations, and
understanding shearing helps you understand how transforms work.

To show you visually how it will look, let's overlay a grid onto the Godot
logo:

.. image:: img/matrices_and_transforms/identity-grid.png

Each point on this grid is obtained by adding the basis vectors together.
The bottom-right corner is X + Y, while the top-right corner is X - Y.
If we change the basis vectors, the entire grid moves with it, as the
grid is composed of the basis vectors. All lines on the grid that are
currently parallel will remain parallel no matter what changes we make to
the basis vectors.

As an example, let's set Y to (1, 1):

.. image:: img/matrices_and_transforms/shear.png

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = Transform2D()
    # Shear by setting Y to (1, 1)
    t.y = Vector2.ONE
    transform = t # Change the node's transform to what we just calculated.

 .. code-tab:: csharp

    Transform2D t = Transform2D.Identity;
    // Shear by setting Y to (1, 1)
    t.y = Vector2.One;
    Transform = t; // Change the node's transform to what we just calculated.

.. note:: You can't set the raw values of a Transform2D in the editor,
          so you *must* use code if you want to shear the object.

Due to the vectors no longer being perpendicular, the object has been
sheared. The bottom-center of the grid, which is (0, 1) relative
to itself, is now located at a world position of (1, 1).

The intra-object coordinates are called UV coordinates in textures,
so let's borrow that terminology for here. To find the world position
from a relative position, the formula is U * X + V * Y, where U and V
are numbers and X and Y are the basis vectors.

The bottom-right corner of the grid, which is always at the UV position
of (1, 1), is at the world position of (2, 1), which is calculated from
X*1 + Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1).
This matches up with our observation of where the bottom-right corner
of the image is.

Similarly, the top-right corner of the grid, which is always at the UV
position of (1, -1), is at the world position of (0, -1), which is calculated
from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or (0, -1).
This matches up with our observation of where the top-right corner
of the image is.

Hopefully you now fully understand the how a transformation matrix affects
the object, and the relationship between the basis vectors and how the
object's "UV" or "intra-coordinates" have their world position changed.

.. note:: In Godot, all transform math is done relative to the parent node.
          When we refer to "world position", that would be relative to the
          node's parent instead, if the node had a parent.

If you would like additional explanation, you should check out
3Blue1Brown's excellent video about linear transformations:
https://www.youtube.com/watch?v=kYB8IZa5AuE

Practical applications of transforms
------------------------------------

In actual projects, you will usually be working with transforms inside
transforms by having multiple :ref:`class_Node2D` or :ref:`class_Spatial`
nodes parented to each other.

However, sometimes it's very useful to manually calculate the values we
need. We will go over how you could use :ref:`class_Transform2D` or
:ref:`class_Transform` to manually calculate transforms of nodes.

Converting positions between transforms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are many cases where you'd want to convert a position in and out of
a transform. For example, if you have a position relative to the player
and would like to find the world (parent-relative) position, or if you
have a world position and want to know where it is relative to the player.

We can find what a vector relative to the player would be defined in
world space as using the "xform" method:

.. tabs::
 .. code-tab:: gdscript GDScript

    # World space vector 100 units below the player.
    print(transform.xform(Vector2(0, 100)))

 .. code-tab:: csharp

    // World space vector 100 units below the player.
    GD.Print(Transform.Xform(new Vector2(0, 100)));

And we can use the "xform_inv" method to find a what world space position
would be if it was instead defined relative to the player:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Where is (0, 100) relative to the player?
    print(transform.xform_inv(Vector2(0, 100)))

 .. code-tab:: csharp

    // Where is (0, 100) relative to the player?
    GD.Print(Transform.XformInv(new Vector2(0, 100)));

.. note:: If you know in advance that the transform is positioned at
          (0, 0), you can use the "basis_xform" or "basis_xform_inv"
          methods instead, which skip dealing with translation.

Moving an object relative to itself
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A common operation, especially in 3D games, is to move an object relative
to itself. For example, in first-person shooter games, you would want the
character to move forward (-Z axis) when you press :kbd:`W`.

Since the basis vectors are the orientation relative to the parent,
and the origin vector is the position relative to the parent, we can simply
add multiples of the basis vectors to move an object relative to itself.

This code moves an object 100 units to its own right:

.. tabs::
 .. code-tab:: gdscript GDScript

    transform.origin += transform.x * 100

 .. code-tab:: csharp

    Transform2D t = Transform;
    t.origin += t.x * 100;
    Transform = t;

For moving in 3D, you would need to replace "x" with "basis.x".

.. note:: In actual projects, you can use `translate_object_local` in 3D
          or `move_local_x` and `move_local_y` in 2D to do this.

Applying transforms onto transforms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One of the most important things to know about transforms is how you
can use several of them together. A parent node's transform affects
all of its children. Let's dissect an example.

In this image, the child node has a "2" after the component names
to distinguish them from the parent node. It might look a bit
overwhelming with so many numbers, but remember that each number
is displayed twice (next to the arrows and also in the matrices),
and that almost half of the numbers are zero.

.. image:: img/matrices_and_transforms/apply.png

The only transformations going on here are that the parent node has
been given a scale of (2, 1), the child has been given a scale of
(0.5, 0.5), and both nodes have been given positions.

All child transformations are affected by the parent transformations.
The child has a scale of (0.5, 0.5), so you would expect it to be
a 1:1 ratio square, and it is, but only relative to the parent.
The child's X vector ends up being (1, 0) in world space, because
it is scaled by the parent's basis vectors.
Similarly, the child node's `origin` vector is set to (1, 1), but this
actually moves it (2, 1) in world space, due to the parent node's
basis vectors.

To calculate a child transform's world space transform manually, this is
the code we would use:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Set up transforms just like in the image, except make positions be 100 times bigger.
    var parent = Transform2D(Vector2(2, 0), Vector2(0, 1), Vector2(100, 200))
    var child = Transform2D(Vector2(0.5, 0), Vector2(0, 0.5), Vector2(100, 100))

    # Calculate the child's world space transform
    # origin = (2, 0) * 100 + (0, 1) * 100 + (100, 200)
    var origin = parent.x * child.origin.x + parent.y * child.origin.y + parent.origin
    # basis_x = (2, 0) * 0.5 + (0, 1) * 0
    var basis_x = parent.x * child.x.x + parent.y * child.x.y
    # basis_y = (2, 0) * 0 + (0, 1) * 0.5
    var basis_y = parent.x * child.y.x + parent.y * child.y.y

    # Change the node's transform to what we just calculated.
    transform = Transform2D(basis_x, basis_y, origin)

 .. code-tab:: csharp

    // Set up transforms just like in the image, except make positions be 100 times bigger.
    Transform2D parent = new Transform2D(2, 0, 0, 1, 100, 200);
    Transform2D child = new Transform2D(0.5f, 0, 0, 0.5f, 100, 100);

    // Calculate the child's world space transform
    // origin = (2, 0) * 100 + (0, 1) * 100 + (100, 200)
    Vector2 origin = parent.x * child.origin.x + parent.y * child.origin.y + parent.origin;
    // basisX = (2, 0) * 0.5 + (0, 1) * 0 = (0.5, 0)
    Vector2 basisX = parent.x * child.x.x + parent.y * child.x.y;
    // basisY = (2, 0) * 0 + (0, 1) * 0.5 = (0.5, 0)
    Vector2 basisY = parent.x * child.y.x + parent.y * child.y.y;

    // Change the node's transform to what we just calculated.
    Transform = new Transform2D(basisX, basisY, origin);

In actual projects, we can find the world transform of the child by
applying one transform onto another using the `*` operator:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Set up transforms just like in the image, except make positions be 100 times bigger.
    var parent = Transform2D(Vector2(2, 0), Vector2(0, 1), Vector2(100, 200))
    var child = Transform2D(Vector2(0.5, 0), Vector2(0, 0.5), Vector2(100, 100))

    # Change the node's transform to what would be the child's world transform.
    transform = parent * child

 .. code-tab:: csharp

    // Set up transforms just like in the image, except make positions be 100 times bigger.
    Transform2D parent = new Transform2D(2, 0, 0, 1, 100, 200);
    Transform2D child = new Transform2D(0.5f, 0, 0, 0.5f, 100, 100);

    // Change the node's transform to what would be the child's world transform.
    Transform = parent * child;

.. note:: When multiplying matrices, order matters! Don't mix them up.

Lastly, applying the identity transform will always do nothing.

If you would like additional explanation, you should check out
3Blue1Brown's excellent video about matrix composition:
https://www.youtube.com/watch?v=XkY2DOUCWMU

Inverting a transformation matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The "affine_inverse" function returns a transform that "undoes" the
previous transform. This can be useful in some situations, but it's
easier to just provide a few examples.

Multiplying an inverse transform by the normal transform undoes all
transformations:

.. tabs::
 .. code-tab:: gdscript GDScript

    var ti = transform.affine_inverse()
    var t = ti * transform
    # The transform is the identity transform.

 .. code-tab:: csharp

    Transform2D ti = Transform.AffineInverse();
    Transform2D t = ti * Transform;
    // The transform is the identity transform.

Transforming a position by a transform and its inverse results in the
same position (same for "xform_inv"):

.. tabs::
 .. code-tab:: gdscript GDScript

    var ti = transform.affine_inverse()
    position = transform.xform(position)
    position = ti.xform(position)
    # The position is the same as before.

 .. code-tab:: csharp

    Transform2D ti = Transform.AffineInverse();
    Position = Transform.Xform(Position);
    Position = ti.Xform(Position);
    // The position is the same as before.

How does it all work in 3D?
---------------------------

One of the great things about transformation matrices is that they
work very similarly between 2D and 3D transformations.
All the code and formulas used above for 2D work the same in 3D,
with 3 exceptions: the addition of a third axis, that each
axis is of type :ref:`class_Vector3`, and also that Godot stores
the :ref:`class_Basis` separately from the :ref:`class_Transform`,
since the math can get complex and it makes sense to separate it.

All of the concepts for how translation, rotation, scale, and shearing
work in 3D are all the same compared to 2D. To scale, we take each
component and multiply it; to rotate, we change where each basis vector
is pointing; to translate, we manipulate the origin; and to shear, we
change the basis vectors to be non-perpendicular.

.. image:: img/matrices_and_transforms/3d-identity.png

If you would like, it's a good idea to play around with transforms
to get an understanding of how they work. Godot allows you to edit
3D transform matrices directly from the inspector. You can download
this project which has colored lines and cubes to help visualize the
:ref:`class_Basis` vectors and the origin in both 2D and 3D:
https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform

.. note:: Spatial's "Matrix" section in Godot 3.2's inspector
          displays the matrix as transposed, with the columns
          horizontal and the rows vertical. This may be changed
          to be less confusing in a future release of Godot.

.. note:: You cannot edit Node2D's transform matrix directly in Godot 3.2's
          inspector. This may be changed in a future release of Godot.

If you would like additional explanation, you should check out
3Blue1Brown's excellent video about 3D linear transformations:
https://www.youtube.com/watch?v=rHLEWRxRGiM

Representing rotation in 3D (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The biggest difference between 2D and 3D transformation matrices is
how you represent rotation by itself without the basis vectors.

With 2D, we have an easy way (atan2) to switch between a transformation
matrix and an angle. In 3D, we can't simply represent rotation as one
number. There is something called Euler angles, which can represent
rotations as a set of 3 numbers, however, they are limited and not very
useful, except for trivial cases.

In 3D we do not typically use angles, we either use a transformation basis
(used pretty much everywhere in Godot), or we use quaternions. Godot can
represent quaternions using the :ref:`class_Quat` struct. My suggestion
to you is to completely ignore how they work under-the-hood, because
they are very complicated and unintuitive.

However, if you really must know how it works, here are some great
resources, which you can follow in order:

https://www.youtube.com/watch?v=mvmuCPvRoWQ

https://www.youtube.com/watch?v=d4EgbgTm0Bg

https://eater.net/quaternions


===================================================
/. ./tutorials/math/interpolation.rst
===================================================

.. _doc_interpolation:

Interpolation
=============

Interpolation is a very basic operation in graphics programming. It's good to become familiar with it in order to expand your horizons as a graphics developer.

The basic idea is that you want to transition from A to B. A value ``t``, represents the states in-between.

As an example if ``t`` is 0, then the state is A. If ``t`` is 1, then the state is B. Anything in-between is an *interpolation*.

Between two real (floating-point) numbers, a simple interpolation is usually described as:

::

    interpolation = A * (1 - t) + B * t

And often simplified to:

::

    interpolation = A + (B - A) * t

The name of this type of interpolation, which transforms a value into another at *constant speed* is *"linear"*. So, when you hear about *Linear Interpolation*, you know they are referring to this simple formula.

There are other types of interpolations, which will not be covered here. A recommended read afterwards is the :ref:`Bezier <doc_beziers_and_curves>` page.

Vector interpolation
--------------------

Vector types (:ref:`Vector2 <class_Vector2>` and :ref:`Vector3 <class_Vector3>`) can also be interpolated, they come with handy functions to do it
:ref:`Vector2.linear_interpolate() <class_Vector2_method_linear_interpolate>` and :ref:`Vector3.linear_interpolate() <class_Vector3_method_linear_interpolate>`.

For cubic interpolation, there are also :ref:`Vector2.cubic_interpolate() <class_Vector2_method_cubic_interpolate>` and :ref:`Vector3.cubic_interpolate() <class_Vector3_method_cubic_interpolate>`, which do a :ref:`Bezier <doc_beziers_and_curves>` style interpolation.

Here is simple pseudo-code for going from point A to B using interpolation:

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = 0.0

    func _physics_process(delta):
        t += delta * 0.4

        $Sprite.position = $A.position.linear_interpolate($B.position, t)

 .. code-tab:: csharp

    private float _t = 0.0f;

    public override void _PhysicsProcess(float delta)
    {
        _t += delta * 0.4f;

        Position2D a = GetNode<Position2D>("A");
        Position2D b = GetNode<Position2D>("B");
        Sprite sprite = GetNode<Sprite>("Sprite");

        sprite.Position = a.Position.LinearInterpolate(b.Position, _t);
    }

It will produce the following motion:

.. image:: img/interpolation_vector.gif

Transform interpolation
-----------------------

It is also possible to interpolate whole transforms (make sure they have either uniform scale or, at least, the same non-uniform scale).
For this, the function :ref:`Transform.interpolate_with() <class_Transform_method_interpolate_with>` can be used.

Here is an example of transforming a monkey from Position1 to Position2:

.. image:: img/interpolation_positions.png

Using the following pseudocode:

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = 0.0

    func _physics_process(delta):
        t += delta

        $Monkey.transform = $Position1.transform.interpolate_with($Position2.transform, t)

 .. code-tab:: csharp

    private float _t = 0.0f;

    public override void _PhysicsProcess(float delta)
    {
        _t += delta;

        Position3D p1 = GetNode<Position3D>("Position1");
        Position3D p2 = GetNode<Position3D>("Position2");
        CSGMesh monkey = GetNode<CSGMesh>("Monkey");

        monkey.Transform = p1.Transform.InterpolateWith(p2.Transform, _t);
    }

And again, it will produce the following motion:

.. image:: img/interpolation_monkey.gif


Smoothing motion
----------------

Interpolation can be used to smooth movement, rotation, etc. Here is an example of a circle following the mouse using smoothed motion:

.. tabs::
 .. code-tab:: gdscript GDScript

    const FOLLOW_SPEED = 4.0

    func _physics_process(delta):
        var mouse_pos = get_local_mouse_position()

        $Sprite.position = $Sprite.position.linear_interpolate(mouse_pos, delta * FOLLOW_SPEED)

 .. code-tab:: csharp

    private const float FollowSpeed = 4.0f;

    public override void _PhysicsProcess(float delta)
    {
        Vector2 mousePos = GetLocalMousePosition();

        Sprite sprite = GetNode<Sprite>("Sprite");

        sprite.Position = sprite.Position.LinearInterpolate(mousePos, delta * FollowSpeed);
    }

Here is how it looks:

.. image:: img/interpolation_follow.gif

This useful for smoothing camera movement, allies following you (ensuring they stay within a certain range), and many other common game patterns.


===================================================
/. ./tutorials/math/beziers_and_curves.rst
===================================================

.. _doc_beziers_and_curves:

Beziers, curves and paths
=========================

Bezier curves are a mathematical approximation of natural geometric shapes. We
use them to represent a curve with as little information as possible and with a
high level of flexibility.

Unlike more abstract mathematical concepts, Bezier curves were created for
industrial design. They are a popular tool in the graphics software industry.

They rely on :ref:`interpolation<doc_interpolation>`, which we saw in the
previous article, combining multiple steps to create smooth curves. To better
understand how Bezier curves work, let's start from its simplest form: Quadratic
Bezier.

Quadratic Bezier
----------------

Take three points, the minimum required for Quadratic Bezier to work:

.. image:: img/bezier_quadratic_points.png

To draw a curve between them, we first interpolate gradually over the two
vertices of each of the two segments formed by the three points, using values
ranging from 0 to 1. This gives us two points that move along the segments as we
change the value of ``t`` from 0 to 1.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _quadratic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, t: float):
        var q0 = p0.linear_interpolate(p1, t)
        var q1 = p1.linear_interpolate(p2, t)

 .. code-tab:: csharp

    private Vector2 QuadraticBezier(Vector2 p0, Vector2 p1, Vector2 p2, float t)
    {
        Vector2 q0 = p0.LinearInterpolate(p1, t);
        Vector2 q1 = p1.LinearInterpolate(p2, t);
    }

We then interpolate ``q0`` and ``q1`` to obtain a single point ``r`` that moves
along a curve.

.. tabs::
 .. code-tab:: gdscript GDScript

        var r = q0.linear_interpolate(q1, t)
        return r

 .. code-tab:: csharp

        Vector2 r = q0.LinearInterpolate(q1, t);
        return r;

This type of curve is called a *Quadratic Bezier* curve.

.. image:: img/bezier_quadratic_points2.gif

*(Image credit: Wikipedia)*

Cubic Bezier
------------

Building upon the previous example, we can get more control by interpolating
between four points.

.. image:: img/bezier_cubic_points.png

We first use a function with four parameters to take four points as an input,
``p0``, ``p1``, ``p2`` and ``p3``:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):

 .. code-tab:: csharp

    public Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
    {

    }

We apply a linear interpolation to each couple of points to reduce them to
three:

.. tabs::
 .. code-tab:: gdscript GDScript

        var q0 = p0.linear_interpolate(p1, t)
        var q1 = p1.linear_interpolate(p2, t)
        var q2 = p2.linear_interpolate(p3, t)

 .. code-tab:: csharp

        Vector2 q0 = p0.LinearInterpolate(p1, t);
        Vector2 q1 = p1.LinearInterpolate(p2, t);
        Vector2 q2 = p2.LinearInterpolate(p3, t);

We then take our three points and reduce them to two:

.. tabs::
 .. code-tab:: gdscript GDScript

        var r0 = q0.linear_interpolate(q1, t)
        var r1 = q1.linear_interpolate(q2, t)

 .. code-tab:: csharp

        Vector2 r0 = q0.LinearInterpolate(q1, t);
        Vector2 r1 = q1.LinearInterpolate(q2, t);

And to one:

.. tabs::
 .. code-tab:: gdscript GDScript

        var s = r0.linear_interpolate(r1, t)
        return s

 .. code-tab:: csharp

        Vector2 s = r0.LinearInterpolate(r1, t);
        return s;

Here is the full function:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):
        var q0 = p0.linear_interpolate(p1, t)
        var q1 = p1.linear_interpolate(p2, t)
        var q2 = p2.linear_interpolate(p3, t)

        var r0 = q0.linear_interpolate(q1, t)
        var r1 = q1.linear_interpolate(q2, t)

        var s = r0.linear_interpolate(r1, t)
        return s

 .. code-tab:: csharp

    private Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
    {
        Vector2 q0 = p0.LinearInterpolate(p1, t);
        Vector2 q1 = p1.LinearInterpolate(p2, t);
        Vector2 q2 = p2.LinearInterpolate(p3, t);

        Vector2 r0 = q0.LinearInterpolate(q1, t);
        Vector2 r1 = q1.LinearInterpolate(q2, t);

        Vector2 s = r0.LinearInterpolate(r1, t);
        return s;
    }

The result will be a smooth curve interpolating between all four points:

.. image:: img/bezier_cubic_points.gif

*(Image credit: Wikipedia)*

.. note:: Cubic Bezier interpolation works the same in 3D, just use ``Vector3``
          instead of ``Vector2``.

Adding control points
---------------------

Building upon Cubic Bezier, we can change the way two of the points work to
control the shape of our curve freely. Instead of having ``p0``, ``p1``, ``p2``
and ``p3``, we will store them as:

* ``point0 = p0``: Is the first point, the source
* ``control0 = p1 - p0``: Is a vector relative to the first control point
* ``control1 = p3 - p2``: Is a vector relative to the second control point
* ``point1 = p3``: Is the second point, the destination

This way, we have two points and two control points which are relative vectors
to the respective points. If you've used graphics or animation software before,
this might look familiar:

.. image:: img/bezier_cubic_handles.png

This is how graphics software presents Bezier curves to the users, and how they
work and look in Godot.

Curve2D, Curve3D, Path and Path2D
---------------------------------

There are two objects that contain curves: :ref:`Curve3D <class_Curve3D>` and :ref:`Curve2D <class_Curve2D>` (for 3D and 2D respectively).

They can contain several points, allowing for longer paths. It is also possible to set them to nodes: :ref:`Path <class_Path>` and :ref:`Path2D <class_Path2D>` (also for 3D and 2D respectively):

.. image:: img/bezier_path_2d.png

Using them, however, may not be completely obvious, so following is a description of the most common use cases for Bezier curves.

Evaluating
----------

Just evaluating them may be an option, but in most cases it's not very useful. The big drawback with Bezier curves is that if you traverse them at constant speed, from ``t = 0`` to ``t = 1``, the actual interpolation will *not* move at constant speed. The speed is also an interpolation between the distances between points ``p0``, ``p1``, ``p2`` and ``p3`` and there is not a mathematically simple way to traverse the curve at constant speed.

Let's do a simple example with the following pseudocode:

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = 0.0

    func _process(delta):
        t += delta
        position = _cubic_bezier(p0, p1, p2, p3, t)

 .. code-tab:: csharp

    private float _t = 0.0f;

    public override void _Process(float delta)
    {
        _t += delta;
        Position = CubicBezier(p0, p1, p2, p3, _t);
    }

.. image:: img/bezier_interpolation_speed.gif

As you can see, the speed (in pixels per second) of the circle varies, even though ``t`` is increased at constant speed. This makes beziers difficult to use for anything practical out of the box.

Drawing
-------

Drawing beziers (or objects based on the curve) is a very common use case, but it's also not easy. For pretty much any case, Bezier curves need to be converted to some sort of segments. This is normally difficult, however, without creating a very high amount of them.

The reason is that some sections of a curve (specifically, corners) may require considerable amounts of points, while other sections may not:

.. image:: img/bezier_point_amount.png

Additionally, if both control points were ``0, 0`` (remember they are relative vectors), the Bezier curve would just be a straight line (so drawing a high amount of points would be wasteful).

Before drawing Bezier curves, *tessellation* is required. This is often done with a recursive or divide and conquer function that splits the curve until the curvature amount becomes less than a certain threshold.

The *Curve* classes provide this via the
:ref:`Curve2D.tessellate() <class_Curve2D_method_tessellate>` function (which receives optional ``stages`` of recursion and angle ``tolerance`` arguments). This way, drawing something based on a curve is easier.

Traversal
---------

The last common use case for the curves is to traverse them. Because of what was mentioned before regarding constant speed, this is also difficult.

To make this easier, the curves need to be *baked* into equidistant points. This way, they can be approximated with regular interpolation (which can be improved further with a cubic option). To do this, just use the :ref:`Curve.interpolate_baked()<class_Curve_method_interpolate_baked>` method together with
:ref:`Curve2D.get_baked_length()<class_Curve2D_method_get_baked_length>`. The first call to either of them will bake the curve internally.

Traversal at constant speed, then, can be done with the following pseudo-code:

.. tabs::
 .. code-tab:: gdscript GDScript

    var t = 0.0

    func _process(delta):
        t += delta
        position = curve.interpolate_baked(t * curve.get_baked_length(), true)

 .. code-tab:: csharp

    private float _t = 0.0f;

    public override void _Process(float delta)
    {
        _t += delta;
        Position = curve.InterpolateBaked(_t * curve.GetBakedLength(), true);
    }

And the output will, then, move at constant speed:

.. image:: img/bezier_interpolation_baked.gif


===================================================
/. ./tutorials/math/random_number_generation.rst
===================================================

.. _doc_random_number_generation:

Random number generation
========================

Many games rely on randomness to implement core game mechanics. This page
guides you through common types of randomness and how to implement them in
Godot.

After giving you a brief overview of useful functions that generate random
numbers, you will learn how to get random elements from arrays, dictionaries,
and how to use a noise generator in GDScript.

.. note::

    Computers cannot generate "true" random numbers. Instead, they rely on
    `pseudorandom number generators
    <https://en.wikipedia.org/wiki/Pseudorandom_number_generator>`__ (PRNGs).

Global scope versus RandomNumberGenerator class
-----------------------------------------------

Godot exposes two ways to generate random numbers: via *global scope* methods or
using the :ref:`class_RandomNumberGenerator` class.

Global scope methods are easier to set up, but they don't offer as much control.

RandomNumberGenerator requires more code to use, but exposes many methods not
found in global scope such as :ref:`randi_range()
<class_RandomNumberGenerator_method_randi_range>` and :ref:`randfn()
<class_RandomNumberGenerator_method_randfn>`. On top of that, it allows creating
multiple instances each with their own seed.

This tutorial uses global scope methods, except when the method only exists in
the RandomNumberGenerator class.

The randomize() method
----------------------

In global scope, you can find a :ref:`randomize()
<class_@GDScript_method_randomize>` method. **This method should be called only
once when your project starts to initialize the random seed.** Calling it
multiple times is unnecessary and may impact performance negatively.

Putting it in your main scene script's ``_ready()`` method is a good choice:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        randomize()

 .. code-tab:: csharp

    public override void _Ready()
    {
        GD.Randomize();
    }

You can also set a fixed random seed instead using :ref:`seed()
<class_@GDScript_method_seed>`. Doing so will give you *deterministic* results
across runs:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        seed(12345)
        # To use a string as a seed, you can hash it to a number.
        seed("Hello world".hash())

 .. code-tab:: csharp

    public override void _Ready()
    {
        GD.Seed(12345);
        GD.Seed("Hello world".Hash());
    }

When using the RandomNumberGenerator class, you should call ``randomize()`` on
the instance since it has its own seed:

.. tabs::
 .. code-tab:: gdscript GDScript

    var random = RandomNumberGenerator.new()
    random.randomize()

 .. code-tab:: csharp

    var random = new RandomNumberGenerator();
    random.Randomize();

Getting a random number
-----------------------

Let's look at some of the most commonly used functions and methods to generate
random numbers in Godot.

The function :ref:`randi() <class_@GDScript_method_randi>` returns a random
number between 0 and 2^32-1. Since the maximum value is huge, you most likely
want to use the modulo operator (``%``) to bound the result between 0 and the
denominator:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Prints a random integer between 0 and 49.
    print(randi() % 50)

    # Prints a random integer between 10 and 60.
    print(randi() % 51 + 10)

 .. code-tab:: csharp

    // Prints a random integer between 0 and 49.
    GD.Print(GD.Randi() % 50);

    // Prints a random integer between 10 and 60.
    GD.Print(GD.Randi() % 51 + 10);

:ref:`randf() <class_@GDScript_method_randf>` returns a random floating-point
number between 0 and 1. This is useful to implement a
:ref:`doc_random_number_generation_weighted_random_probability` system, among
other things.

:ref:`randfn() <class_RandomNumberGenerator_method_randfn>` returns a random
floating-point number following a `normal distribution
<https://en.wikipedia.org/wiki/Normal_distribution>`__. This means the returned
value is more likely to be around the mean (0.0 by default),
varying by the deviation (1.0 by default):

.. tabs::
 .. code-tab:: gdscript GDScript

    # Prints a random floating-point number from a normal distribution with a mean 0.0 and deviation 1.0.
    var random = RandomNumberGenerator.new()
    random.randomize()
    print(random.randfn())

 .. code-tab:: csharp

    // Prints a normally distributed floating-point number between 0.0 and 1.0.
    var random = new RandomNumberGenerator();
    random.Randomize();
    GD.Print(random.Randfn());

:ref:`rand_range() <class_@GDScript_method_rand_range>` takes two arguments
``from`` and ``to``, and returns a random floating-point number between ``from``
and ``to``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Prints a random floating-point number between -4 and 6.5.
    print(rand_range(-4, 6.5))

 .. code-tab:: csharp

    // Prints a random floating-point number between -4 and 6.5.
    GD.Print(GD.RandRange(-4, 6.5));

:ref:`RandomNumberGenerator.randi_range()
<class_RandomNumberGenerator_method_randi_range>` takes two arguments ``from``
and ``to``, and returns a random integer between ``from`` and ``to``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Prints a random integer between -10 and 10.
    var random = RandomNumberGenerator.new()
    random.randomize()
    print(random.randi_range(-10, 10))

 .. code-tab:: csharp

    // Prints a random integer number between -10 and 10.
    random.Randomize();
    GD.Print(random.RandiRange(-10, 10));

Get a random array element
--------------------------

We can use random integer generation to get a random element from an array:

.. tabs::
 .. code-tab:: gdscript GDScript

    var _fruits = ["apple", "orange", "pear", "banana"]

    func _ready():
        randomize()

        for i in range(100):
            # Pick 100 fruits randomly.
            print(get_fruit())


    func get_fruit():
        var random_fruit = _fruits[randi() % _fruits.size()]
        # Returns "apple", "orange", "pear", or "banana" every time the code runs.
        # We may get the same fruit multiple times in a row.
        return random_fruit

 .. code-tab:: csharp

    private string[] _fruits = { "apple", "orange", "pear", "banana" };

    public override void _Ready()
    {
        GD.Randomize();

        for (int i = 0; i < 100; i++)
        {
            // Pick 100 fruits randomly.
            GD.Print(GetFruit());
        }
    }

    public string GetFruit()
    {
        string randomFruit = _fruits[GD.Randi() % _fruits.Length];
        // Returns "apple", "orange", "pear", or "banana" every time the code runs.
        // We may get the same fruit multiple times in a row.
        return randomFruit;
    }

To prevent the same fruit from being picked more than once in a row, we can add
more logic to this method:

.. tabs::
 .. code-tab:: gdscript GDScript

    var _fruits = ["apple", "orange", "pear", "banana"]
    var _last_fruit = ""


    func _ready():
        randomize()

        # Pick 100 fruits randomly.
        for i in range(100):
            print(get_fruit())


    func get_fruit():
        var random_fruit = _fruits[randi() % _fruits.size()]
        while random_fruit == _last_fruit:
            # The last fruit was picked, try again until we get a different fruit.
            random_fruit = _fruits[randi() % _fruits.size()]

        # Note: if the random element to pick is passed by reference,
        # such as an array or dictionary,
        # use `_last_fruit = random_fruit.duplicate()` instead.
        _last_fruit = random_fruit

        # Returns "apple", "orange", "pear", or "banana" every time the code runs.
        # The function will never return the same fruit more than once in a row.
        return random_fruit

 .. code-tab:: csharp

    private string[] _fruits = { "apple", "orange", "pear", "banana" };
    private string _lastFruit = "";

    public override void _Ready()
    {
        GD.Randomize();

        for (int i = 0; i < 100; i++)
        {
            // Pick 100 fruits randomly.
            GD.Print(GetFruit());
        }
    }

    public string GetFruit()
    {
        string randomFruit = _fruits[GD.Randi() % _fruits.Length];
        while (randomFruit == _lastFruit)
        {
            // The last fruit was picked, try again until we get a different fruit.
            randomFruit = _fruits[GD.Randi() % _fruits.Length];
        }

        _lastFruit = randomFruit;

        // Returns "apple", "orange", "pear", or "banana" every time the code runs.
        // The function will never return the same fruit more than once in a row.
        return randomFruit;
    }

This approach can be useful to make random number generation feel less
repetitive. Still, it doesn't prevent results from "ping-ponging" between a
limited set of values. To prevent this, use the :ref:`shuffle bag
<doc_random_number_generation_shuffle_bags>` pattern instead.

Get a random dictionary value
-----------------------------

We can apply similar logic from arrays to dictionaries as well:

.. tabs::
 .. code-tab:: gdscript GDScript

    var metals = {
        "copper": {"quantity": 50, "price": 50},
        "silver": {"quantity": 20, "price": 150},
        "gold": {"quantity": 3, "price": 500},
    }


    func _ready():
        randomize()

        for i in range(20):
            print(get_metal())


    func get_metal():
        var random_metal = metals.values()[randi() % metals.size()]
        # Returns a random metal value dictionary every time the code runs.
        # The same metal may be selected multiple times in succession.
        return random_metal

.. _doc_random_number_generation_weighted_random_probability:

Weighted random probability
---------------------------

The :ref:`randf() <class_@GDScript_method_randf>` method returns a
floating-point number between 0.0 and 1.0. We can use this to create a
"weighted" probability where different outcomes have different likelihoods:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        randomize()

        for i in range(100):
            print(get_item_rarity())


    func get_item_rarity():
        var random_float = randf()

        if random_float < 0.8:
            # 80% chance of being returned.
            return "Common"
        elif random_float < 0.95:
            # 15% chance of being returned.
            return "Uncommon"
        else:
            # 5% chance of being returned.
            return "Rare"

 .. code-tab:: csharp

    public override void _Ready()
    {
        GD.Randomize();

        for (int i = 0; i < 100; i++)
        {
            GD.Print(GetItemRarity());
        }
    }

    public string GetItemRarity()
    {
        float randomFloat = GD.Randf();

        if (randomFloat < 0.8f)
        {
            // 80% chance of being returned.
            return "Common";
        }
        else if (randomFloat < 0.95f)
        {
            // 15% chance of being returned
            return "Uncommon";
        }
        else
        {
            // 5% chance of being returned.
            return "Rare";
        }
    }

.. _doc_random_number_generation_shuffle_bags:

"Better" randomness using shuffle bags
--------------------------------------

Taking the same example as above, we would like to pick fruits at random.
However, relying on random number generation every time a fruit is selected can
lead to a less *uniform* distribution. If the player is lucky (or unlucky), they
could get the same fruit three or more times in a row.

You can accomplish this using the *shuffle bag* pattern. It works by removing an
element from the array after choosing it. After multiple selections, the array
ends up empty. When that happens, you reinitialize it to its default value::

    var _fruits = ["apple", "orange", "pear", "banana"]
    # A copy of the fruits array so we can restore the original value into `fruits`.
    var _fruits_full = []


    func _ready():
        randomize()
        _fruits_full = _fruits.duplicate()
        _fruits.shuffle()

        for i in 100:
            print(get_fruit())


    func get_fruit():
        if _fruits.empty():
            # Fill the fruits array again and shuffle it.
            _fruits = _fruits_full.duplicate()
            _fruits.shuffle()

        # Get a random fruit, since we shuffled the array,
        # and remove it from the `_fruits` array.
        var random_fruit = _fruits.pop_front()
        # Prints "apple", "orange", "pear", or "banana" every time the code runs.
        return random_fruit

When running the above code, there is a chance to get the same fruit twice in a
row. Once we picked a fruit, it will no longer be a possible return value unless
the array is now empty. When the array is empty, we reset it back to its default
value, making it possible to have the same fruit again, but only once.

Random noise
------------

The random number generation shown above can show its limits when you need a
value that *slowly* changes depending on the input. The input can be a position,
time, or anything else.

To achieve this, you can use random *noise* functions. Noise functions are
especially popular in procedural generation to generate realistic-looking
terrain. Godot provides :ref:`class_opensimplexnoise` for this, which supports
1D, 2D, 3D, and 4D noise. Here's an example with 1D noise:

.. tabs::
 .. code-tab:: gdscript GDScript

    var _noise = OpenSimplexNoise.new()

    func _ready():
        randomize()
        # Configure the OpenSimplexNoise instance.
        _noise.seed = randi()
        _noise.octaves = 4
        _noise.period = 20.0
        _noise.persistence = 0.8

        for i in 100:
            # Prints a slowly-changing series of floating-point numbers
            # between -1.0 and 1.0.
            print(_noise.get_noise_1d(i))

 .. code-tab:: csharp

    private OpenSimplexNoise _noise = new OpenSimplexNoise();

    public override void _Ready()
    {
        GD.Randomize();
        // Configure the OpenSimplexNoise instance.
        _noise.Seed = (int)GD.Randi();
        _noise.Octaves = 4;
        _noise.Period = 20.0f;
        _noise.Persistence = 0.8f;

        for (int i = 0; i < 100; i++)
        {
            GD.Print(_noise.GetNoise1d(i));
        }
    }


===================================================
/. ./tutorials/navigation/index.rst
===================================================

Navigation
==========

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-navigation

   real_time_navigation_3d


===================================================
/. ./tutorials/navigation/real_time_navigation_3d.rst
===================================================

.. _doc_real_time_navigation_3d:

Real Time Navigation (3D)
=========================

Introduction
------------

Pathfinding in a 3D environment is crucial for many games, it's commonly
how non directly controlled characters or entities find their way around
an environment. Godot provides several nodes for this purpose:

-  :ref:`Navigation<class_Navigation>` (deprecated)
-  :ref:`NavigationMeshInstance<class_NavigationMeshInstance>`
-  :ref:`NavigationAgent<class_NavigationAgent>`
-  :ref:`NavigationObstacle<class_NavigationObstacle>`

The map and navigation regions
------------------------------

The "map" is the entire world for navigation, it's similar to "space" for
the physics engine. It's comprised of navigation regions, these regions
define parts of the world that can be navigated around by navigation
agents.

To create a navigation region add the :ref:`NavigationMeshInstance<class_NavigationMeshInstance>`
node to a 3D scene. Next in the inspector for that mesh create or add a
:ref:`NavigationMesh<class_NavigationMesh>`. The navmesh contains options
for how it will be generated when it's baked. The geometry options control
which nodes, and types of nodes, are used to bake the mesh. A full
description of each setting and how it works can be found in the :ref:`NavigationMesh class reference<class_NavigationMesh>`.

Once the settings have been properly configured press the "Bake NavMesh"
button at the top of the inspector to generate it.

.. image:: img/bake_navmesh.png

.. note::

    It can also be generated at runtime using the `bake_navigation_region()`
    method of the navigation region node.

Once the mesh has finished generating you should see the transparent
navigation mesh above the areas in the scene that can be navigated to.

.. image:: img/baked_navmesh.png

Keep in mind that the navmesh shows where the center of an entity can
go. For example, if you set the agent radius to 0.5 then the
navigation mesh will have a distance of 0.5 from any ledges or walls
to prevent clipping into the wall or hanging off of the edge.

Navigation agents can moved from one region to another if they are next
to each other. Additionally a baked navmesh can be moved at runtime and
agents will still be able to navigate onto it from another region.
For example, navigating onto a moving platform that has stopped will work.

NavigationAgent
---------------

Navigation agent nodes are what actually does the pathfinding in a scene,
one can be attached to the root node of an entity that needs to navigate.

To have it pathfind use its `set_target_location` method. Once the target
has been set a path will be generated to the node using navigation regions,
with several points on the way to the final destination.

RVO processing
--------------

RVO stands for reciprocal velocity obstacle. RVO processing is a way to
pathfind while taking into account other agents and physics bodies that
are also moving.

To use it set a target like normal. Then an agent needs to fetch its next
nav path location, and compute its velocity to that location. Instead
of using that value to move use it to set the velocity on the agent
with `set_velocity`. Then a new velocity that takes into account other
agents and obstacles is generated and emitted with the signal `velocity_computed`.

However agents can only take into account a set number of other nearby
agents, this is the :ref:`max neighbors<class_NavigationAgent_property_max_neighbors>`
property of an agent and can be adjusted. This is **not** a limit for
how many agents can use a navigation region at the same time.

NavigationObstacle
------------------

This node is used to mark physics bodies that move around a navigation area
that agents need to avoid (this will only work if you use RVO processing).
For example, this node would be useful for pieces of debris in a destructible
environment. Add it as the child of a physics body and navigation agent
nodes will avoid it while pathfinding.

Generating a path (old method)
------------------------------

This is the old method for generating a navigation path, it will be
removed in Godot 4. First, add a navigation node to the scene, then
add a navigation mesh instance as it's child and set up a navigation
mesh. 

To get a path between two areas on a map you use the navigation node
method ``get_simple_path()``. The first argument is a Vector3 of the
starting location, the next is a Vector3 of the end location. And the
last argument is a boolean for whether or not agent properties of a
navmesh are considered when generating a path.

The method will return a :ref:`PoolVector3Array <class_PoolVector3Array>` consisting of
points that make a path. If there is no way to navigate to the end
location the method will return a blank :ref:`PoolVector3Array <class_PoolVector3Array>`.


===================================================
/. ./tutorials/networking/index.rst
===================================================

Networking
==========

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-networking

   high_level_multiplayer
   http_request_class
   http_client_class
   ssl_certificates
   websocket
   webrtc


===================================================
/. ./tutorials/networking/high_level_multiplayer.rst
===================================================

.. _doc_high_level_multiplayer:

High-level multiplayer
======================

High-level vs low-level API
---------------------------

The following explains the differences of high- and low-level networking in Godot as well as some fundamentals. If you want to jump in head-first and add networking to your first nodes, skip to `Initializing the network`_ below. But make sure to read the rest later on!

Godot always supported standard low-level networking via UDP, TCP and some higher level protocols such as SSL and HTTP.
These protocols are flexible and can be used for almost anything. However, using them to synchronize game state manually can be a large amount of work. Sometimes that work can't be avoided or is worth it, for example when working with a custom server implementation on the backend. But in most cases, it's worthwhile to consider Godot's high-level networking API, which sacrifices some of the fine-grained control of low-level networking for greater ease of use.

This is due to the inherent limitations of the low-level protocols:

- TCP ensures packets will always arrive reliably and in order, but latency is generally higher due to error correction.
  It's also quite a complex protocol because it understands what a "connection" is, and optimizes for goals that often don't suit applications like multiplayer games. Packets are buffered to be sent in larger batches, trading less per-packet overhead for higher latency. This can be useful for things like HTTP, but generally not for games. Some of this can be configured and disabled (e.g. by disabling "Nagle's algorithm" for the TCP connection).
- UDP is a simpler protocol, which only sends packets (and has no concept of a "connection"). No error correction
  makes it pretty quick (low latency), but packets may be lost along the way or received in the wrong order.
  Added to that, the MTU (maximum packet size) for UDP is generally low (only a few hundred bytes), so transmitting
  larger packets means splitting them, reorganizing them and retrying if a part fails.

In general, TCP can be thought of as reliable, ordered, and slow; UDP as unreliable, unordered and fast.
Because of the large difference in performance, it often makes sense to re-build the parts of TCP wanted for games (optional reliability and packet order), while avoiding the unwanted parts (congestion/traffic control features, Nagle's algorithm, etc). Due to this, most game engines come with such an implementation, and Godot is no exception.

In summary, you can use the low-level networking API for maximum control and implement everything on top of bare network protocols or use the high-level API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy lifting behind the scenes in a generally optimized way.

.. note:: Most of Godot's supported platforms offer all or most of the mentioned high- and low-level networking
          features. As networking is always largely hardware and operating system dependent, however,
          some features may change or not be available on some target platforms. Most notably,
          the HTML5 platform currently offers WebSockets and WebRTC support but lacks some of the higher-level features, as
          well as raw access to low-level protocols like TCP and UDP.

.. note:: More about TCP/IP, UDP, and networking:
          https://gafferongames.com/post/udp_vs_tcp/

          Gaffer On Games has a lot of useful articles about networking in Games
          (`here <https://gafferongames.com/categories/game-networking/>`__), including the comprehensive
          `introduction to networking models in games <https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/>`__.

          If you want to use your low-level networking library of choice instead of Godot's built-in networking,
          see here for an example:
          https://github.com/PerduGames/gdnet3

.. warning:: Adding networking to your game comes with some responsibility.
             It can make your application vulnerable if done wrong and may lead to cheats or exploits.
             It may even allow an attacker to compromise the machines your application runs on
             and use your servers to send spam, attack others or steal your users data if they play your game.

             This is always the case when networking is involved and has nothing to do with Godot.
             You can of course experiment, but when you release a networked application,
             always take care of any possible security concerns.

Mid level abstraction
---------------------

Before going into how we would like to synchronize a game across the network, it can be helpful to understand how the base network API for synchronization works.

Godot uses a mid-level object :ref:`NetworkedMultiplayerPeer <class_NetworkedMultiplayerPeer>`.
This object is not meant to be created directly, but is designed so that several C++ implementations can provide it.

This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it inherits all the useful methods for serializing, sending and receiving data. On top of that, it adds methods to set a peer, transfer mode, etc. It also includes signals that will let you know when peers connect or disconnect.

This class interface can abstract most types of network layers, topologies and libraries. By default, Godot
provides an implementation based on ENet (:ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`),
one based on WebRTC (:ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`), and one based on WebSocket
(:ref:`WebSocketMultiplayerPeer <class_WebSocketMultiplayerPeer>`), but this could be used to implement
mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific networking APIs.

For most common cases, using this object directly is discouraged, as Godot provides even higher level networking facilities.
Yet it is made available in case a game has specific needs for a lower level API.

Initializing the network
------------------------

The object that controls networking in Godot is the same one that controls everything tree-related: :ref:`SceneTree <class_SceneTree>`.

To initialize high-level networking, the SceneTree must be provided a NetworkedMultiplayerPeer object.

To create that object, it first has to be initialized as a server or client.

Initializing as a server, listening on the given port, with a given maximum number of peers:

::

    var peer = NetworkedMultiplayerENet.new()
    peer.create_server(SERVER_PORT, MAX_PLAYERS)
    get_tree().network_peer = peer

Initializing as a client, connecting to a given IP and port:

::

    var peer = NetworkedMultiplayerENet.new()
    peer.create_client(SERVER_IP, SERVER_PORT)
    get_tree().network_peer = peer

Get the previously set network peer:

::

    get_tree().get_network_peer()

Checking whether the tree is initialized as a server or client:

::

    get_tree().is_network_server()

Terminating the networking feature:

::

    get_tree().network_peer = null

(Although it may make sense to send a message first to let the other peers know you're going away instead of letting the connection close or timeout, depending on your game.)

.. warning::

    When exporting to Android, make sure to enable the ``INTERNET``
    permission in the Android export preset before exporting the project or
    using one-click deploy. Otherwise, network communication of any kind will be
    blocked by Android.

Managing connections
--------------------

Some games accept connections at any time, others during the lobby phase. Godot can be requested to no longer accept
connections at any point (see ``set_refuse_new_network_connections(bool)`` and related methods on :ref:`SceneTree <class_SceneTree>`). To manage who connects, Godot provides the following signals in SceneTree:

Server and Clients:

- ``network_peer_connected(int id)``
- ``network_peer_disconnected(int id)``

The above signals are called on every peer connected to the server (including on the server) when a new peer connects or disconnects.
Clients will connect with a unique ID greater than 1, while network peer ID 1 is always the server.
Anything below 1 should be handled as invalid.
You can retrieve the ID for the local system via :ref:`SceneTree.get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`.
These IDs will be useful mostly for lobby management and should generally be stored, as they identify connected peers and thus players. You can also use IDs to send messages only to certain peers.

Clients:

- ``connected_to_server``
- ``connection_failed``
- ``server_disconnected``

Again, all these functions are mainly useful for lobby management or for adding/removing players on the fly.
For these tasks, the server clearly has to work as a server and you have to perform tasks manually such as sending a newly connected
player information about other already connected players (e.g. their names, stats, etc).

Lobbies can be implemented any way you want, but the most common way is to use a node with the same name across scenes in all peers.
Generally, an autoloaded node/singleton is a great fit for this, to always have access to, e.g. "/root/lobby".

RPC
---

To communicate between peers, the easiest way is to use RPCs (remote procedure calls). This is implemented as a set of functions
in :ref:`Node <class_Node>`:

- ``rpc("function_name", <optional_args>)``
- ``rpc_id(<peer_id>,"function_name", <optional_args>)``
- ``rpc_unreliable("function_name", <optional_args>)``
- ``rpc_unreliable_id(<peer_id>, "function_name", <optional_args>)``

Synchronizing member variables is also possible:

- ``rset("variable", value)``
- ``rset_id(<peer_id>, "variable", value)``
- ``rset_unreliable("variable", value)``
- ``rset_unreliable_id(<peer_id>, "variable", value)``

Functions can be called in two fashions:

- Reliable: when the function call arrives, an acknowledgement will be sent back; if the acknowledgement isn't received after a certain amount of time, the function call will be re-transmitted.
- Unreliable: the function call is sent only once, without checking to see if it arrived or not, but also without any extra overhead.

In most cases, reliable is desired. Unreliable is mostly useful when synchronizing object positions (sync must happen constantly,
and if a packet is lost, it's not that bad because a new one will eventually arrive and it would likely be outdated because the object moved further in the meantime, even if it was resent reliably).

There is also :ref:`SceneTree.get_rpc_sender_id() <class_SceneTree_method_get_rpc_sender_id>`, which can be used to check which peer (or peer ID) sent an RPC.

Back to lobby
-------------

Let's get back to the lobby. Imagine that each player that connects to the server will tell everyone about it.

::

    # Typical lobby implementation; imagine this being in /root/lobby.

    extends Node

    # Connect all functions

    func _ready():
        get_tree().connect("network_peer_connected", self, "_player_connected")
        get_tree().connect("network_peer_disconnected", self, "_player_disconnected")
        get_tree().connect("connected_to_server", self, "_connected_ok")
        get_tree().connect("connection_failed", self, "_connected_fail")
        get_tree().connect("server_disconnected", self, "_server_disconnected")

    # Player info, associate ID to data
    var player_info = {}
    # Info we send to other players
    var my_info = { name = "Johnson Magenta", favorite_color = Color8(255, 0, 255) }

    func _player_connected(id):
        # Called on both clients and server when a peer connects. Send my info to it.
        rpc_id(id, "register_player", my_info)

    func _player_disconnected(id):
        player_info.erase(id) # Erase player from info.

    func _connected_ok():
        pass # Only called on clients, not server. Will go unused; not useful here.

    func _server_disconnected():
        pass # Server kicked us; show error and abort.

    func _connected_fail():
        pass # Could not even connect to server; abort.

    remote func register_player(info):
        # Get the id of the RPC sender.
        var id = get_tree().get_rpc_sender_id()
        # Store the info
        player_info[id] = info

        # Call function to update lobby UI here

You might have already noticed something different, which is the usage of the ``remote`` keyword on the ``register_player`` function:

::

    remote func register_player(info):

This keyword is one of many that allow a function to be called by a remote procedure call (RPC). There are six of them total:

- ``remote``
- ``remotesync``
- ``puppet``
- ``puppetsync``
- ``master``
- ``mastersync``

Each of them designate who can call the rpc, and optionally ``sync`` if the RPC can be called locally.

.. note:: If no rpc keywords are added, Godot will block any attempts to call functions remotely.
          This makes security work a lot easier (so a client can't call a function to delete a file on another client's system).

The ``remote`` keyword can be called by any peer, including the server and all clients.
The ``puppet`` keyword means a call can be made from the network master to any network puppet.
The ``master`` keyword means a call can be made from any network puppet to the network master.

If ``sync`` is included, the call can also be made locally. For example, to allow the network master to change the player's position on all peers:

::

    puppetsync func update_position(new_position):
        position = new_position

.. tip:: You can also use :ref:`SceneTree.get_rpc_sender_id() <class_SceneTree_method_get_rpc_sender_id>` to have more advanced rules on how an rpc can be called.

These keywords are further explained in :ref:`Synchronizing the game <doc_high_level_multiplayer_synchronizing>`.

With this, lobby management should be more or less explained. Once you have your game going, you will most likely want to add some
extra security to make sure clients don't do anything funny (just validate the info they send from time to time, or before
game start). For the sake of simplicity and because each game will share different information, this is not shown here.

Starting the game
-----------------

Once enough players have gathered in the lobby, the server should probably start the game. This is nothing
special in itself, but we'll explain a few nice tricks that can be done at this point to make your life much easier.

Player scenes
^^^^^^^^^^^^^

In most games, each player will likely have its own scene. Remember that this is a multiplayer game, so in every peer
you need to instance **one scene for each player connected to it**. For a 4 player game, each peer needs to instance 4 player nodes.

So, how to name such nodes? In Godot, nodes need to have a unique name. It must also be relatively easy for a player to tell which
node represents each player ID.

The solution is to simply name the *root nodes of the instanced player scenes as their network ID*. This way, they will be the same in
every peer and RPC will work great! Here is an example:

::

    remote func pre_configure_game():
        var selfPeerID = get_tree().get_network_unique_id()

        # Load world
        var world = load(which_level).instance()
        get_node("/root").add_child(world)

        # Load my player
        var my_player = preload("res://player.tscn").instance()
        my_player.set_name(str(selfPeerID))
        my_player.set_network_master(selfPeerID) # Will be explained later
        get_node("/root/world/players").add_child(my_player)

        # Load other players
        for p in player_info:
            var player = preload("res://player.tscn").instance()
            player.set_name(str(p))
            player.set_network_master(p) # Will be explained later
            get_node("/root/world/players").add_child(player)

        # Tell server (remember, server is always ID=1) that this peer is done pre-configuring.
        # The server can call get_tree().get_rpc_sender_id() to find out who said they were done.
        rpc_id(1, "done_preconfiguring")


.. note:: Depending on when you execute pre_configure_game(), you may need to change any calls to ``add_child()``
          to be deferred via ``call_deferred()``, as the SceneTree is locked while the scene is being created (e.g. when ``_ready()`` is being called).

Synchronizing game start
^^^^^^^^^^^^^^^^^^^^^^^^

Setting up players might take different amounts of time for every peer due to lag, different hardware, or other reasons.
To make sure the game will actually start when everyone is ready, pausing the game until all players are ready can be useful:

::

    remote func pre_configure_game():
        get_tree().set_pause(true) # Pre-pause
        # The rest is the same as in the code in the previous section (look above)

When the server gets the OK from all the peers, it can tell them to start, as for example:

::

    var players_done = []
    remote func done_preconfiguring():
        var who = get_tree().get_rpc_sender_id()
        # Here are some checks you can do, for example
        assert(get_tree().is_network_server())
        assert(who in player_info) # Exists
        assert(not who in players_done) # Was not added yet

        players_done.append(who)

        if players_done.size() == player_info.size():
            rpc("post_configure_game")

    remote func post_configure_game():
        # Only the server is allowed to tell a client to unpause
        if 1 == get_tree().get_rpc_sender_id():
            get_tree().set_pause(false)
            # Game starts now!

.. _doc_high_level_multiplayer_synchronizing:

Synchronizing the game
----------------------

In most games, the goal of multiplayer networking is that the game runs synchronized on all the peers playing it.
Besides supplying an RPC and remote member variable set implementation, Godot adds the concept of network masters.

Network master
^^^^^^^^^^^^^^

The network master of a node is the peer that has the ultimate authority over it.

When not explicitly set, the network master is inherited from the parent node, which if not changed, is always going to be the server (ID 1). Thus the server has authority over all nodes by default.

The network master can be set
with the function :ref:`Node.set_network_master(id, recursive) <class_Node_method_set_network_master>` (recursive is ``true`` by default and means the network master is recursively set on all child nodes of the node as well).

Checking that a specific node instance on a peer is the network master for this node for all connected peers is done by calling :ref:`Node.is_network_master() <class_Node_method_is_network_master>`. This will return ``true`` when executed on the server and ``false`` on all client peers.

If you have paid attention to the previous example, it's possible you noticed that each peer was set to have network master authority for their own player (Node) instead of the server:

::

        [...]
        # Load my player
        var my_player = preload("res://player.tscn").instance()
        my_player.set_name(str(selfPeerID))
        my_player.set_network_master(selfPeerID) # The player belongs to this peer; it has the authority.
        get_node("/root/world/players").add_child(my_player)

        # Load other players
        for p in player_info:
            var player = preload("res://player.tscn").instance()
            player.set_name(str(p))
            player.set_network_master(p) # Each other connected peer has authority over their own player.
            get_node("/root/world/players").add_child(player)
        [...]


Each time this piece of code is executed on each peer, the peer makes itself master on the node it controls, and all other nodes remain as puppets with the server being their network master.

To clarify, here is an example of how this looks in the
`bomber demo <https://github.com/godotengine/godot-demo-projects/tree/master/networking/multiplayer_bomber>`_:

.. image:: img/nmms.png


Master and puppet keywords
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. FIXME: Clarify the equivalents to the GDScript keywords in C# and Visual Script.

The real advantage of this model is when used with the ``master``/``puppet`` keywords in GDScript (or their equivalent in C# and Visual Script).
Similarly to the ``remote`` keyword, functions can also be tagged with them:

Example bomb code:

::

    for p in bodies_in_area:
        if p.has_method("exploded"):
            p.rpc("exploded", bomb_owner)

Example player code:

::

    puppet func stun():
        stunned = true

    master func exploded(by_who):
        if stunned:
            return # Already stunned

        rpc("stun")
        
        # Stun this player instance for myself as well; could instead have used
        # the remotesync keyword above (in place of puppet) to achieve this.
        stun()

In the above example, a bomb explodes somewhere (likely managed by whoever is the master of this bomb-node, e.g. the host).
The bomb knows the bodies (player nodes) in the area, so it checks that they contain an ``exploded`` method before calling it.

Recall that each peer has a complete set of instances of player nodes, one instance for each peer (including itself and the host).
Each peer has set itself as the master of the instance corresponding to itself, and it has set a different peer as the master for
each of the other instances.

Now, going back to the call to the ``exploded`` method, the bomb on the host has called it remotely on all bodies in the area
that have the method. However, this method is in a player node and has a ``master`` keyword.

The ``master`` keyword on the ``exploded`` method in the player node means two things for how this call is made.
Firstly, from the perspective of the calling peer (the host), the calling peer will only attempt to remotely call the
method on the peer that it has set as the network master of the player node in question.
Secondly, from the perspective of the peer the host is sending the call to, the peer will only accept the call if it
set itself as the network master of the player node with the method being called (which has the ``master`` keyword).
This works well as long as all peers agree on who is the master of what.

The above setup means that only the peer who owns the affected body will be responsible for telling all the other peers that its body
was stunned, after being remotely instructed to do so by the host's bomb.
The owning peer therefore (still in the ``exploded`` method) tells all the other peers that its player node was stunned.
The peer does this by remotely calling the ``stun`` method on all instances of that player node (on the other peers).
Because the ``stun`` method has the ``puppet`` keyword, only peers who did not set themselves as the network master of the node will
call it (in other words, those peers are set as puppets for that node by virtue of not being the network master of it).

The result of this call to ``stun`` is to make the player look stunned on the screen of all the peers, including the current
network master peer (due to the local call to ``stun`` after ``rpc("stun")``).

The master of the bomb (the host) repeats the above steps for each of the bodies in the area, such that all the instances of
any player in the bomb area get stunned on the screens of all the peers.

Note that you could also send the ``stun()`` message only to a specific player by using ``rpc_id(<id>, "exploded", bomb_owner)``.
This may not make much sense for an area-of-effect case like the bomb, but might in other cases, like single target damage.

::

    rpc_id(TARGET_PEER_ID, "stun") # Only stun the target peer

Exporting for dedicated servers
-------------------------------

Once you've made a multiplayer game, you may want to export it to run it on
a dedicated server with no GPU available. See
:ref:`doc_exporting_for_dedicated_servers` for more information.

.. note::

    The code samples on this page aren't designed to run on a dedicated
    server. You'll have to modify them so the server isn't considered to be a
    player. You'll also have to modify the game starting mechanism so that the
    first player who joins can start the game.

.. note::

    The bomberman example here is largely for illustrational purposes, and does not
    do anything on the host-side to handle the case where a peer uses a custom client
    to cheat by for example refusing to stun itself. In the current implementation
    such cheating is perfectly possible because each client is the network master of
    its own player, and the network master of a player is the one which decides whether
    to call the I-was-stunned method (``stun``) on all of the other peers and itself.


===================================================
/. ./tutorials/networking/http_request_class.rst
===================================================

.. _doc_http_request_class:

Making HTTP requests
====================

The :ref:`HTTPRequest <class_HTTPRequest>` node is the easiest way to make HTTP requests in Godot.
It is backed by the more low-level :ref:`HTTPClient <class_HTTPClient>`, for which a tutorial is available :ref:`here <doc_http_client_class>`.

For the sake of this example, we will create a simple UI with a button, that when pressed will start the HTTP request to the specified URL.

.. warning::

    When exporting to Android, make sure to enable the ``INTERNET``
    permission in the Android export preset before exporting the project or
    using one-click deploy. Otherwise, network communication of any kind will be
    blocked by Android.

Preparing scene
---------------

Create a new empty scene, add a CanvasLayer as the root node and add a script to it. Then add two child nodes to it: a Button and an HTTPRequest node. You will need to connect the following signals to the CanvasLayer script:

- Button.pressed: When the button is pressed, we will start the request.
- HTTPRequest.request_completed: When the request is completed, we will get the requested data as an argument.

.. image:: img/rest_api_scene.png

Scripting
---------

Below is all the code we need to make it work. The URL points to an online API mocker; it returns a pre-defined JSON string, which we will then parse to get access to the data.

.. tabs::

    .. code-tab:: gdscript GDScript

        extends CanvasLayer

        func _ready():
            $HTTPRequest.connect("request_completed", self, "_on_request_completed")

        func _on_Button_pressed():
            $HTTPRequest.request("http://www.mocky.io/v2/5185415ba171ea3a00704eed")

        func _on_request_completed(result, response_code, headers, body):
            var json = JSON.parse(body.get_string_from_utf8())
            print(json.result)

    .. code-tab:: csharp

        class HTTPRequestDemo : CanvasLayer
        {
            public override void _Ready()
            {
                GetNode("HTTPRequest").Connect("request_completed", this, "OnRequestCompleted");
                GetNode("Button").Connect("pressed", this, "OnButtonPressed");
            }

            public void OnButtonPressed()
            {
                HTTPRequest httpRequest = GetNode<HTTPRequest>("HTTPRequest");
                httpRequest.Request("http://www.mocky.io/v2/5185415ba171ea3a00704eed");
            }

            public void OnRequestCompleted(int result, int response_code, string[] headers, byte[] body)
            {
                JSONParseResult json = JSON.Parse(Encoding.UTF8.GetString(body));
                GD.Print(json.Result);
            }
        }

With this, you should see ``(hello:world)`` printed on the console; hello being a key, and world being a value, both of them strings.

For more information on parsing JSON, see the class references for :ref:`JSON <class_JSON>` and :ref:`JSONParseResult <class_JSONParseResult>`.

Note that you may want to check whether the ``result`` equals ``RESULT_SUCCESS`` and whether a JSON parsing error occurred, see the JSON class reference and :ref:`HTTPRequest <class_HTTPRequest>` for more.

Of course, you can also set custom HTTP headers. These are given as a string array, with each string containing a header in the format ``"header: value"``.
For example, to set a custom user agent (the HTTP ``user-agent`` header) you could use the following:

.. tabs::

    .. code-tab:: gdscript GDScript

        $HTTPRequest.request("http://www.mocky.io/v2/5185415ba171ea3a00704eed", ["user-agent: YourCustomUserAgent"])

    .. code-tab:: csharp

        HTTPRequest httpRequest = GetNode<HTTPRequest>("HTTPRequest");
        httpRequest.Request("http://www.mocky.io/v2/5185415ba171ea3a00704eed", new string[] { "user-agent: YourCustomUserAgent" });

Please note that, for SSL/TLS encryption and thus HTTPS URLs to work, you may need to take some steps as described :ref:`here <doc_ssl_certificates>`.

Also, when calling APIs using authorization, be aware that someone might analyse and decompile your released application and thus may gain access to any embedded authorization information like tokens, usernames or passwords.
That means it is usually not a good idea to embed things such as database access credentials inside your game. Avoid providing information useful to an attacker whenever possible.

Sending data to server
----------------------

Until now, we have limited ourselves to requesting data from a server. But what if you need to send data to the server? Here is a common way of doing it:

.. tabs::

    .. code-tab:: gdscript GDScript

        func _make_post_request(url, data_to_send, use_ssl):
            # Convert data to json string:
            var query = JSON.print(data_to_send)
            # Add 'Content-Type' header:
            var headers = ["Content-Type: application/json"]
            $HTTPRequest.request(url, headers, use_ssl, HTTPClient.METHOD_POST, query)

    .. code-tab:: csharp

            public void MakePostRequest(string url, object data_to_send, bool use_ssl)
            {
                string query = JSON.Print(data_to_send);
                HTTPRequest httpRequest = GetNode<HTTPRequest>("HTTPRequest");
                string[] headers = new string[] { "Content-Type: application/json" };
                httpRequest.Request(url, headers, use_ssl, HTTPClient.Method.Post, query);
            }

Keep in mind that you have to wait for a request to finish before sending another one. Making multiple request at once requires you to have one node per request.
A common strategy is to create and delete HTTPRequest nodes at runtime as necessary.


===================================================
/. ./tutorials/networking/http_client_class.rst
===================================================

.. _doc_http_client_class:

HTTP client class
=================

:ref:`HTTPClient <class_HTTPClient>` provides low-level access to HTTP communication.
For a higher-level interface, you may want to take a look at :ref:`HTTPRequest <class_HTTPRequest>` first,
which has a tutorial available :ref:`here <doc_http_request_class>`.

.. warning::

    When exporting to Android, make sure to enable the ``INTERNET``
    permission in the Android export preset before exporting the project or
    using one-click deploy. Otherwise, network communication of any kind will be
    blocked by Android.

Here's an example of using the :ref:`HTTPClient <class_HTTPClient>`
class. It's just a script, so it can be run by executing:

.. tabs::

 .. code-tab:: console GDScript

    c:\godot> godot -s http_test.gd

 .. code-tab:: console C#

    c:\godot> godot -s HTTPTest.cs

It will connect and fetch a website.

.. tabs::

 .. code-tab:: gdscript GDScript

    extends SceneTree

    # HTTPClient demo
    # This simple class can do HTTP requests; it will not block, but it needs to be polled.

    func _init():
        var err = 0
        var http = HTTPClient.new() # Create the Client.

        err = http.connect_to_host("www.php.net", 80) # Connect to host/port.
        assert(err == OK) # Make sure connection is OK.

        # Wait until resolved and connected.
        while http.get_status() == HTTPClient.STATUS_CONNECTING or http.get_status() == HTTPClient.STATUS_RESOLVING:
            http.poll()
            print("Connecting...")
            if not OS.has_feature("web"):
                OS.delay_msec(500)
            else:
                yield(Engine.get_main_loop(), "idle_frame")

        assert(http.get_status() == HTTPClient.STATUS_CONNECTED) # Check if the connection was made successfully.

        # Some headers
        var headers = [
            "User-Agent: Pirulo/1.0 (Godot)",
            "Accept: */*"
        ]

        err = http.request(HTTPClient.METHOD_GET, "/ChangeLog-5.php", headers) # Request a page from the site (this one was chunked..)
        assert(err == OK) # Make sure all is OK.

        while http.get_status() == HTTPClient.STATUS_REQUESTING:
            # Keep polling for as long as the request is being processed.
            http.poll()
            print("Requesting...")
            if OS.has_feature("web"):
                # Synchronous HTTP requests are not supported on the web,
                # so wait for the next main loop iteration.
                yield(Engine.get_main_loop(), "idle_frame")
            else:
                OS.delay_msec(500)

        assert(http.get_status() == HTTPClient.STATUS_BODY or http.get_status() == HTTPClient.STATUS_CONNECTED) # Make sure request finished well.

        print("response? ", http.has_response()) # Site might not have a response.

        if http.has_response():
            # If there is a response...

            headers = http.get_response_headers_as_dictionary() # Get response headers.
            print("code: ", http.get_response_code()) # Show response code.
            print("**headers:\\n", headers) # Show headers.

            # Getting the HTTP Body

            if http.is_response_chunked():
                # Does it use chunks?
                print("Response is Chunked!")
            else:
                # Or just plain Content-Length
                var bl = http.get_response_body_length()
                print("Response Length: ", bl)

            # This method works for both anyway

            var rb = PoolByteArray() # Array that will hold the data.

            while http.get_status() == HTTPClient.STATUS_BODY:
                # While there is body left to be read
                http.poll()
                # Get a chunk.
                var chunk = http.read_response_body_chunk()
                if chunk.size() == 0:
                    if not OS.has_feature("web"):
                        # Got nothing, wait for buffers to fill a bit.
                        OS.delay_usec(1000)
                    else:
                        yield(Engine.get_main_loop(), "idle_frame")
                else:
                    rb = rb + chunk # Append to read buffer.
            # Done!

            print("bytes got: ", rb.size())
            var text = rb.get_string_from_ascii()
            print("Text: ", text)

        quit()

 .. code-tab:: csharp

    class HTTPTest : SceneTree
    {
        // HTTPClient demo.
        // This simple class can make HTTP requests; it will not block, but it needs to be polled.
        public override async void _Initialize()
        {
            Error err;
            HTTPClient http = new HTTPClient(); // Create the client.

            err = http.ConnectToHost("www.php.net", 80); // Connect to host/port.
            Debug.Assert(err == Error.Ok); // Make sure the connection is OK.

            // Wait until resolved and connected.
            while (http.GetStatus() == HTTPClient.Status.Connecting || http.GetStatus() == HTTPClient.Status.Resolving)
            {
                http.Poll();
                GD.Print("Connecting...");
                OS.DelayMsec(500);
            }

            Debug.Assert(http.GetStatus() == HTTPClient.Status.Connected); // Check if the connection was made successfully.

            // Some headers.
            string[] headers = { "User-Agent: Pirulo/1.0 (Godot)", "Accept: */*" };

            err = http.Request(HTTPClient.Method.Get, "/ChangeLog-5.php", headers); // Request a page from the site.
            Debug.Assert(err == Error.Ok); // Make sure all is OK.

            // Keep polling for as long as the request is being processed.
            while (http.GetStatus() == HTTPClient.Status.Requesting)
            {
                http.Poll();
                GD.Print("Requesting...");
                if (OS.HasFeature("web"))
                {
                    // Synchronous HTTP requests are not supported on the web,
                    // so wait for the next main loop iteration.
                    await ToSignal(Engine.GetMainLoop(), "idle_frame");
                }
                else
                {
                    OS.DelayMsec(500);
                }
            }

            Debug.Assert(http.GetStatus() == HTTPClient.Status.Body || http.GetStatus() == HTTPClient.Status.Connected); // Make sure the request finished well.

            GD.Print("Response? ", http.HasResponse()); // The site might not have a response.

            // If there is a response...
            if (http.HasResponse())
            {
                headers = http.GetResponseHeaders(); // Get response headers.
                GD.Print("Code: ", http.GetResponseCode()); // Show response code.
                GD.Print("Headers:");
                foreach (string header in headers)
                {
                    // Show headers.
                    GD.Print(header);
                }

                if (http.IsResponseChunked())
                {
                    // Does it use chunks?
                    GD.Print("Response is Chunked!");
                }
                else
                {
                    // Or just Content-Length.
                    GD.Print("Response Length: ", http.GetResponseBodyLength());
                }

                // This method works for both anyways.
                List<byte> rb = new List<byte>(); // List that will hold the data.

                // While there is data left to be read...
                while (http.GetStatus() == HTTPClient.Status.Body)
                {
                    http.Poll();
                    byte[] chunk = http.ReadResponseBodyChunk(); // Read a chunk.
                    if (chunk.Length == 0)
                    {
                        // If nothing was read, wait for the buffer to fill.
                        OS.DelayMsec(500);
                    }
                    else
                    {
                        // Append the chunk to the read buffer.
                        rb.AddRange(chunk);
                    }
                }

                // Done!
                GD.Print("Bytes Downloaded: ", rb.Count);
                string text = Encoding.ASCII.GetString(rb.ToArray());
                GD.Print(text);
            }
            Quit();
        }
    }


===================================================
/. ./tutorials/networking/ssl_certificates.rst
===================================================

.. _doc_ssl_certificates:

SSL certificates
================

Introduction
------------

It is often desired to use SSL connections for communications to avoid
"man in the middle" attacks. Godot has a connection wrapper,
:ref:`StreamPeerSSL <class_StreamPeerSSL>`,
which can take a regular connection and add security around it. The
:ref:`HTTPClient <class_HTTPClient>`
class also supports HTTPS by using this same wrapper.

Godot includes SSL certificates from Mozilla, but you can provide your own
with a .crt file in the project settings:

.. image:: img/ssl_certs.png

This file should contain any number of public certificates in
`PEM format <https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail>`__.

Of course, remember to add .crt as filter so the exporter recognizes
this when exporting your project.

.. image:: img/add_crt.png

There are two ways to obtain certificates:

Approach 1: self signed cert
----------------------------

The first approach is the simplest: generate a private and public
key pair and add the public key (in PEM format) to the .crt file.
The private key should go to your server.

OpenSSL has `some
documentation <https://raw.githubusercontent.com/openssl/openssl/master/doc/HOWTO/keys.txt>`__ about
this. This approach also **does not require domain validation** nor
requires you to spend a considerable amount of money in purchasing
certificates from a CA.

Approach 2: CA cert
-------------------

The second approach consists of using a certificate authority (CA)
such as Verisign, Geotrust, etc. This is a more cumbersome process,
but it's more "official" and ensures your identity is clearly
represented.

Unless you are working with large companies or corporations, or need
to connect to someone else's servers (i.e., connecting to Google or some
other REST API provider via HTTPS), this method is not as useful.

Also, when using a CA issued cert, **you must enable domain
validation**, to ensure the domain you are connecting to is the one
intended, otherwise any website can issue any certificate in the same CA
and it will work.

If you are using Linux, you can use the supplied certs file, generally
located in:

.. code-block:: none

    /etc/ssl/certs/ca-certificates.crt

This file allows HTTPS connections to virtually any website (i.e.,
Google, Microsoft, etc.).

Or pick any of the more specific certificates there if you are
connecting to a specific one.


===================================================
/. ./tutorials/networking/websocket.rst
===================================================

.. _doc_websocket:

WebSocket
=========

HTML5 and WebSocket
-------------------

The WebSocket protocol was standardized in 2011 with the original goal of allowing browsers to create stable and bidirectional connections with a server.
Before that, browsers used to only support HTTPRequests, which is not well-suited for bidirectional communication.

The protocol is quite simple, message based, and a very powerful tool to send push notifications to browsers, and has been used to implement chats, turn-based games, etc. It still uses a TCP connection, which is good for reliability but not for latency, so not good for real-time applications like VoIP and fast-paced games (see :ref:`WebRTC <doc_webrtc>` for those use cases).

Due to its simplicity, its wide compatibility, and being easier to use than a raw TCP connection, WebSocket soon started to spread outside the browsers, in native applications as a mean to communicate with network servers.

Godot supports WebSocket in both native and HTML5 exports.

Using WebSocket in Godot
------------------------

WebSocket is implemented in Godot via three main classes :ref:`WebSocketClient <class_WebSocketClient>`, :ref:`WebSocketServer <class_WebSocketServer>`, and :ref:`WebSocketPeer <class_WebSocketPeer>`. The WebSocket implementation is compatible with the High Level Multiplayer. See section on :ref:`high-level multiplayer <doc_high_level_multiplayer>` for more details.

.. warning::

    When exporting to Android, make sure to enable the ``INTERNET``
    permission in the Android export preset before exporting the project or
    using one-click deploy. Otherwise, network communication of any kind will be
    blocked by Android.

Minimal client example
^^^^^^^^^^^^^^^^^^^^^^

This example will show you how to create a WebSocket connection to a remote server, and how to send and receive data.

::

    extends Node

    # The URL we will connect to
    export var websocket_url = "wss://libwebsockets.org"

    # Our WebSocketClient instance
    var _client = WebSocketClient.new()

    func _ready():
        # Connect base signals to get notified of connection open, close, and errors.
        _client.connect("connection_closed", self, "_closed")
        _client.connect("connection_error", self, "_closed")
        _client.connect("connection_established", self, "_connected")
        # This signal is emitted when not using the Multiplayer API every time
        # a full packet is received.
        # Alternatively, you could check get_peer(1).get_available_packets() in a loop.
        _client.connect("data_received", self, "_on_data")

        # Initiate connection to the given URL.
        var err = _client.connect_to_url(websocket_url, ["lws-mirror-protocol"])
        if err != OK:
            print("Unable to connect")
            set_process(false)

    func _closed(was_clean = false):
        # was_clean will tell you if the disconnection was correctly notified
        # by the remote peer before closing the socket.
        print("Closed, clean: ", was_clean)
        set_process(false)

    func _connected(proto = ""):
        # This is called on connection, "proto" will be the selected WebSocket
        # sub-protocol (which is optional)
        print("Connected with protocol: ", proto)
        # You MUST always use get_peer(1).put_packet to send data to server,
        # and not put_packet directly when not using the MultiplayerAPI.
        _client.get_peer(1).put_packet("Test packet".to_utf8())

    func _on_data():
        # Print the received packet, you MUST always use get_peer(1).get_packet
        # to receive data from server, and not get_packet directly when not
        # using the MultiplayerAPI.
        print("Got data from server: ", _client.get_peer(1).get_packet().get_string_from_utf8())

    func _process(delta):
        # Call this in _process or _physics_process. Data transfer, and signals
        # emission will only happen when calling this function.
        _client.poll()

This will print:

::

    Connected with protocol:
    Got data from server: Test packet

Minimal server example
^^^^^^^^^^^^^^^^^^^^^^

This example will show you how to create a WebSocket server that listens for remote connections, and how to send and receive data.

::

    extends Node

    # The port we will listen to
    const PORT = 9080
    # Our WebSocketServer instance
    var _server = WebSocketServer.new()

    func _ready():
        # Connect base signals to get notified of new client connections,
        # disconnections, and disconnect requests.
        _server.connect("client_connected", self, "_connected")
        _server.connect("client_disconnected", self, "_disconnected")
        _server.connect("client_close_request", self, "_close_request")
        # This signal is emitted when not using the Multiplayer API every time a
        # full packet is received.
        # Alternatively, you could check get_peer(PEER_ID).get_available_packets()
        # in a loop for each connected peer.
        _server.connect("data_received", self, "_on_data")
        # Start listening on the given port.
        var err = _server.listen(PORT)
        if err != OK:
            print("Unable to start server")
            set_process(false)

    func _connected(id, proto):
        # This is called when a new peer connects, "id" will be the assigned peer id,
        # "proto" will be the selected WebSocket sub-protocol (which is optional)
        print("Client %d connected with protocol: %s" % [id, proto])

    func _close_request(id, code, reason):
        # This is called when a client notifies that it wishes to close the connection,
        # providing a reason string and close code.
        print("Client %d disconnecting with code: %d, reason: %s" % [id, code, reason])

    func _disconnected(id, was_clean = false):
        # This is called when a client disconnects, "id" will be the one of the
        # disconnecting client, "was_clean" will tell you if the disconnection
        # was correctly notified by the remote peer before closing the socket.
        print("Client %d disconnected, clean: %s" % [id, str(was_clean)])

    func _on_data(id):
        # Print the received packet, you MUST always use get_peer(id).get_packet to receive data,
        # and not get_packet directly when not using the MultiplayerAPI.
        var pkt = _server.get_peer(id).get_packet()
        print("Got data from client %d: %s ... echoing" % [id, pkt.get_string_from_utf8()])
        _server.get_peer(id).put_packet(pkt)

    func _process(delta):
        # Call this in _process or _physics_process.
        # Data transfer, and signals emission will only happen when calling this function.
        _server.poll()

This will print (when a client connects) something similar to this:

::

    Client 1348090059 connected with protocol: selected-protocol
    Got data from client 1348090059: Test packet ... echoing

Advanced chat demo
^^^^^^^^^^^^^^^^^^

A more advanced chat demo which optionally uses the multiplayer mid-level abstraction and a high level multiplayer demo are available in the `godot demo projects <https://github.com/godotengine/godot-demo-projects>`_ under `networking/websocket_chat` and `networking/websocket_multiplayer`.


===================================================
/. ./tutorials/networking/webrtc.rst
===================================================

.. _doc_webrtc:

WebRTC
======

HTML5, WebSocket, WebRTC
------------------------

One of Godot's great features is its ability to export to the HTML5/WebAssembly platform, allowing your game to run directly in the browser when a user visit your webpage.

This is a great opportunity for both demos and full games, but used to come with some limitations. In the area of networking, browsers used to support only HTTPRequests until recently, when first WebSocket and then WebRTC were proposed as standards.

WebSocket
^^^^^^^^^

When the WebSocket protocol was standardized in December 2011, it allowed browsers to create stable and bidirectional connections to a WebSocket server. The protocol is quite simple, but a very powerful tool to send push notifications to browsers, and has been used to implement chats, turn-based games, etc.

WebSockets, though, still use a TCP connection, which is good for reliability but not for latency, so not good for real-time applications like VoIP and fast-paced games.

WebRTC
^^^^^^

For this reason, since 2010, Google started working on a new technology called WebRTC, which later on, in 2017, became a W3C candidate recommendation. WebRTC is a much more complex set of specifications, and relies on many other technologies behind the scenes (ICE, DTLS, SDP) to provide fast, real-time, and secure communication between two peers.

The idea is to find the fastest route between the two peers and establish whenever possible a direct communication (i.e. try to avoid a relaying server).

However, this comes at a price, which is that some media information must be exchanged between the two peers before the communication can start (in the form of Session Description Protocol - SDP strings). This usually takes the form of a so-called WebRTC Signaling Server.

.. image:: img/webrtc_signaling.png

Peers connect to a signaling server (for example a WebSocket server) and send their media information. The server then relays this information to other peers, allowing them to establish the desired direct communication. Once this step is done, peers can disconnect from the signaling server and keep the direct Peer-to-Peer (P2P) connection open.

Using WebRTC in Godot
---------------------

WebRTC is implemented in Godot via two main classes :ref:`WebRTCPeerConnection <class_WebRTCPeerConnection>` and :ref:`WebRTCDataChannel <class_WebRTCDataChannel>`, plus the multiplayer API implementation :ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`. See section on :ref:`high-level multiplayer <doc_high_level_multiplayer>` for more details.

.. note:: These classes are available automatically in HTML5, but **require an external GDNative plugin on native (non-HTML5) platforms**. Check out the `webrtc-native plugin repository <https://github.com/godotengine/webrtc-native>`__ for instructions and to get the latest `release <https://github.com/godotengine/webrtc-native/releases>`__.

.. warning::

    When exporting to Android, make sure to enable the ``INTERNET``
    permission in the Android export preset before exporting the project or
    using one-click deploy. Otherwise, network communication of any kind will be
    blocked by Android.

Minimal connection example
^^^^^^^^^^^^^^^^^^^^^^^^^^

This example will show you how to create a WebRTC connection between two peers in the same application.
This is not very useful in real life, but will give you a good overview of how a WebRTC connection is set up.

::

    extends Node

    # Create the two peers
    var p1 = WebRTCPeerConnection.new()
    var p2 = WebRTCPeerConnection.new()
    # And a negotiated channel for each each peer
    var ch1 = p1.create_data_channel("chat", {"id": 1, "negotiated": true})
    var ch2 = p2.create_data_channel("chat", {"id": 1, "negotiated": true})

    func _ready():
        # Connect P1 session created to itself to set local description
        p1.connect("session_description_created", p1, "set_local_description")
        # Connect P1 session and ICE created to p2 set remote description and candidates
        p1.connect("session_description_created", p2, "set_remote_description")
        p1.connect("ice_candidate_created", p2, "add_ice_candidate")

        # Same for P2
        p2.connect("session_description_created", p2, "set_local_description")
        p2.connect("session_description_created", p1, "set_remote_description")
        p2.connect("ice_candidate_created", p1, "add_ice_candidate")

        # Let P1 create the offer
        p1.create_offer()

        # Wait a second and send message from P1
        yield(get_tree().create_timer(1), "timeout")
        ch1.put_packet("Hi from P1".to_utf8())

        # Wait a second and send message from P2
        yield(get_tree().create_timer(1), "timeout")
        ch2.put_packet("Hi from P2".to_utf8())

    func _process(_delta):
        # Poll connections
        p1.poll()
        p2.poll()

        # Check for messages
        if ch1.get_ready_state() == ch1.STATE_OPEN and ch1.get_available_packet_count() > 0:
            print("P1 received: ", ch1.get_packet().get_string_from_utf8())
        if ch2.get_ready_state() == ch2.STATE_OPEN and ch2.get_available_packet_count() > 0:
            print("P2 received: ", ch2.get_packet().get_string_from_utf8())

This will print:

::

    P1 received: Hi from P1
    P2 received: Hi from P2

Local signaling example
^^^^^^^^^^^^^^^^^^^^^^^

This example expands on the previous one, separating the peers in two different scenes, and using a :ref:`singleton <doc_singletons_autoload>` as a signaling server.

::

    # An example P2P chat client (chat.gd)
    extends Node

    var peer = WebRTCPeerConnection.new()

    # Create negotiated data channel
    var channel = peer.create_data_channel("chat", {"negotiated": true, "id": 1})

    func _ready():
        # Connect all functions
        peer.connect("ice_candidate_created", self, "_on_ice_candidate")
        peer.connect("session_description_created", self, "_on_session")

        # Register to the local signaling server (see below for the implementation)
        Signaling.register(get_path())

    func _on_ice_candidate(mid, index, sdp):
        # Send the ICE candidate to the other peer via signaling server
        Signaling.send_candidate(get_path(), mid, index, sdp)

    func _on_session(type, sdp):
        # Send the session to other peer via signaling server
        Signaling.send_session(get_path(), type, sdp)
        # Set generated description as local
        peer.set_local_description(type, sdp)

    func _process(delta):
        # Always poll the connection frequently
        peer.poll()
        if channel.get_ready_state() == WebRTCDataChannel.STATE_OPEN:
            while channel.get_available_packet_count() > 0:
                print(get_path(), " received: ", channel.get_packet().get_string_from_utf8())

    func send_message(message):
        channel.put_packet(message.to_utf8())

And now for the local signaling server:

.. note:: This local signaling server is supposed to be used as a :ref:`singleton <doc_singletons_autoload>` to connect two peers in the same scene.

::

    # A local signaling server. Add this to autoloads with name "Signaling" (/root/Signaling)
    extends Node

    # We will store the two peers here
    var peers = []

    func register(path):
        assert(peers.size() < 2)
        peers.append(path)
        # If it's the second one, create an offer
        if peers.size() == 2:
            get_node(peers[0]).peer.create_offer()

    func _find_other(path):
        # Find the other registered peer.
        for p in peers:
            if p != path:
                return p
        return ""

    func send_session(path, type, sdp):
        var other = _find_other(path)
        assert(other != "")
        get_node(other).peer.set_remote_description(type, sdp)

    func send_candidate(path, mid, index, sdp):
        var other = _find_other(path)
        assert(other != "")
        get_node(other).peer.add_ice_candidate(mid, index, sdp)

Then you can use it like this:

::

    # Main scene (main.gd)
    extends Node

    const Chat = preload("res://chat.gd")

    func _ready():
        var p1 = Chat.new()
        var p2 = Chat.new()
        add_child(p1)
        add_child(p2)
        yield(get_tree().create_timer(1), "timeout")
        p1.send_message("Hi from %s" % p1.get_path())

        # Wait a second and send message from P2
        yield(get_tree().create_timer(1), "timeout")
        p2.send_message("Hi from %s" % p2.get_path())

This will print something similar to this:

::

    /root/main/@@3 received: Hi from /root/main/@@2
    /root/main/@@2 received: Hi from /root/main/@@3

Remote signaling with WebSocket
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A more advanced demo using WebSocket for signaling peers and :ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>` is available in the `godot demo projects <https://github.com/godotengine/godot-demo-projects>`_ under `networking/webrtc_signaling`.


===================================================
/. ./tutorials/performance/index.rst
===================================================

.. _doc_optimization:

Optimization
============

Introduction
------------

Godot follows a balanced performance philosophy. In the performance world,
there are always trade-offs, which consist of trading speed for usability
and flexibility. Some practical examples of this are:

-  Rendering large amounts of objects efficiently is easy, but when a
   large scene must be rendered, it can become inefficient. To solve this,
   visibility computation must be added to the rendering. This makes rendering
   less efficient, but at the same time, fewer objects are rendered. Therefore,
   the overall rendering efficiency is improved.

-  Configuring the properties of every material for every object that
   needs to be rendered is also slow. To solve this, objects are sorted by
   material to reduce the costs. At the same time, sorting has a cost.

-  In 3D physics, a similar situation happens. The best algorithms to
   handle large amounts of physics objects (such as SAP) are slow at
   insertion/removal of objects and raycasting. Algorithms that allow faster
   insertion and removal, as well as raycasting, will not be able to handle as
   many active objects.

And there are many more examples of this! Game engines strive to be
general-purpose in nature. Balanced algorithms are always favored over
algorithms that might be fast in some situations and slow in others, or
algorithms that are fast but are more difficult to use.

Godot is not an exception to this. While it is designed to have backends
swappable for different algorithms, the default backends prioritize balance and
flexibility over performance.

With this clear, the aim of this tutorial section is to explain how to get the
maximum performance out of Godot. While the tutorials can be read in any order,
it is a good idea to start from :ref:`doc_general_optimization`.

Common
------

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-general-optimization

   general_optimization
   using_servers

CPU
---

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-cpu-optimization

   cpu_optimization

GPU
---

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-gpu-optimization

   gpu_optimization
   using_multimesh

2D
--

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-2d-optimization

   batching

3D
--

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-3d-optimization

   optimizing_3d_performance
   vertex_animation/index

Multi-threading
---------------

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-threads

   threads/thread_safe_apis
   threads/using_multiple_threads


===================================================
/. ./tutorials/performance/general_optimization.rst
===================================================

.. _doc_general_optimization:

General optimization tips
=========================

Introduction
~~~~~~~~~~~~

In an ideal world, computers would run at infinite speed. The only limit to
what we could achieve would be our imagination. However, in the real world, it's
all too easy to produce software that will bring even the fastest computer to
its knees.

Thus, designing games and other software is a compromise between what we would
like to be possible, and what we can realistically achieve while maintaining
good performance.

To achieve the best results, we have two approaches:

- Work faster.
- Work smarter.

And preferably, we will use a blend of the two.

Smoke and mirrors
^^^^^^^^^^^^^^^^^

Part of working smarter is recognizing that, in games, we can often get the
player to believe they're in a world that is far more complex, interactive, and
graphically exciting than it really is. A good programmer is a magician, and
should strive to learn the tricks of the trade while trying to invent new ones.

The nature of slowness
^^^^^^^^^^^^^^^^^^^^^^

To the outside observer, performance problems are often lumped together.
But in reality, there are several different kinds of performance problems:

- A slow process that occurs every frame, leading to a continuously low frame
  rate.
- An intermittent process that causes "spikes" of slowness, leading to
  stalls.
- A slow process that occurs outside of normal gameplay, for instance,
  when loading a level.

Each of these are annoying to the user, but in different ways.

Measuring performance
=====================

Probably the most important tool for optimization is the ability to measure
performance - to identify where bottlenecks are, and to measure the success of
our attempts to speed them up.

There are several methods of measuring performance, including:

- Putting a start/stop timer around code of interest.
- Using the Godot profiler.
- Using external third-party CPU profilers.
- Using GPU profilers/debuggers such as
  `NVIDIA Nsight Graphics <https://developer.nvidia.com/nsight-graphics>`__
  or `apitrace <https://apitrace.github.io/>`__.
- Checking the frame rate (with V-Sync disabled).

Be very aware that the relative performance of different areas can vary on
different hardware. It's often a good idea to measure timings on more than one
device. This is especially the case if you're targeting mobile devices.

Limitations
~~~~~~~~~~~

CPU profilers are often the go-to method for measuring performance. However,
they don't always tell the whole story.

- Bottlenecks are often on the GPU, "as a result" of instructions given by the
  CPU.
- Spikes can occur in the operating system processes (outside of Godot) "as a
  result" of instructions used in Godot (for example, dynamic memory allocation).
- You may not always be able to profile specific devices like a mobile phone
  due to the initial setup required.
- You may have to solve performance problems that occur on hardware you don't
  have access to.

As a result of these limitations, you often need to use detective work to find
out where bottlenecks are.

Detective work
~~~~~~~~~~~~~~

Detective work is a crucial skill for developers (both in terms of performance,
and also in terms of bug fixing). This can include hypothesis testing, and
binary search.

Hypothesis testing
^^^^^^^^^^^^^^^^^^

Say, for example, that you believe sprites are slowing down your game.
You can test this hypothesis by:

- Measuring the performance when you add more sprites, or take some away.

This may lead to a further hypothesis: does the size of the sprite determine
the performance drop?

- You can test this by keeping everything the same, but changing the sprite
  size, and measuring performance.

Binary search
^^^^^^^^^^^^^

If you know that frames are taking much longer than they should, but you're
not sure where the bottleneck lies. You could begin by commenting out
approximately half the routines that occur on a normal frame. Has the
performance improved more or less than expected?

Once you know which of the two halves contains the bottleneck, you can
repeat this process until you've pinned down the problematic area.

Profilers
=========

Profilers allow you to time your program while running it. Profilers then
provide results telling you what percentage of time was spent in different
functions and areas, and how often functions were called.

This can be very useful both to identify bottlenecks and to measure the results
of your improvements. Sometimes, attempts to improve performance can backfire
and lead to slower performance.
**Always use profiling and timing to guide your efforts.**

For more info about using Godot's built-in profiler, see :ref:`doc_debugger_panel`.

Principles
==========

`Donald Knuth <https://en.wikipedia.org/wiki/Donald_Knuth>`__ said:

    *Programmers waste enormous amounts of time thinking about, or worrying
    about, the speed of noncritical parts of their programs, and these attempts
    at efficiency actually have a strong negative impact when debugging and
    maintenance are considered. We should forget about small efficiencies, say
    about 97% of the time: premature optimization is the root of all evil. Yet
    we should not pass up our opportunities in that critical 3%.*

The messages are very important:

- Developer time is limited. Instead of blindly trying to speed up
  all aspects of a program, we should concentrate our efforts on the aspects
  that really matter.
- Efforts at optimization often end up with code that is harder to read and
  debug than non-optimized code. It is in our interests to limit this to areas
  that will really benefit.

Just because we *can* optimize a particular bit of code, it doesn't necessarily
mean that we *should*. Knowing when and when not to optimize is a great skill to
develop.

One misleading aspect of the quote is that people tend to focus on the subquote
*"premature optimization is the root of all evil"*. While *premature*
optimization is (by definition) undesirable, performant software is the result
of performant design.

Performant design
~~~~~~~~~~~~~~~~~

The danger with encouraging people to ignore optimization until necessary, is
that it conveniently ignores that the most important time to consider
performance is at the design stage, before a key has even hit a keyboard. If the
design or algorithms of a program are inefficient, then no amount of polishing
the details later will make it run fast. It may run *faster*, but it will never
run as fast as a program designed for performance.

This tends to be far more important in game or graphics programming than in
general programming. A performant design, even without low-level optimization,
will often run many times faster than a mediocre design with low-level
optimization.

Incremental design
~~~~~~~~~~~~~~~~~~

Of course, in practice, unless you have prior knowledge, you are unlikely to
come up with the best design the first time. Instead, you'll often make a series
of versions of a particular area of code, each taking a different approach to
the problem, until you come to a satisfactory solution. It's important not to
spend too much time on the details at this stage until you have finalized the
overall design. Otherwise, much of your work will be thrown out.

It's difficult to give general guidelines for performant design because this is
so dependent on the problem. One point worth mentioning though, on the CPU side,
is that modern CPUs are nearly always limited by memory bandwidth. This has led
to a resurgence in data-oriented design, which involves designing data
structures and algorithms for *cache locality* of data and linear access, rather
than jumping around in memory.

The optimization process
~~~~~~~~~~~~~~~~~~~~~~~~

Assuming we have a reasonable design, and taking our lessons from Knuth, our
first step in optimization should be to identify the biggest bottlenecks - the
slowest functions, the low-hanging fruit.

Once we've successfully improved the speed of the slowest area, it may no
longer be the bottleneck. So we should test/profile again and find the next
bottleneck on which to focus.

The process is thus:

1. Profile / Identify bottleneck.
2. Optimize bottleneck.
3. Return to step 1.

Optimizing bottlenecks
~~~~~~~~~~~~~~~~~~~~~~

Some profilers will even tell you which part of a function (which data accesses,
calculations) are slowing things down.

As with design, you should concentrate your efforts first on making sure the
algorithms and data structures are the best they can be. Data access should be
local (to make best use of CPU cache), and it can often be better to use compact
storage of data (again, always profile to test results). Often, you precalculate
heavy computations ahead of time. This can be done by performing the computation
when loading a level, by loading a file containing precalculated data or simply
by storing the results of complex calculations into a script constant and
reading its value.

Once algorithms and data are good, you can often make small changes in routines
which improve performance. For instance, you can move some calculations outside
of loops or transform nested ``for`` loops into non-nested loops.
(This should be feasible if you know a 2D array's width or height in advance.)

Always retest your timing/bottlenecks after making each change. Some changes
will increase speed, others may have a negative effect. Sometimes, a small
positive effect will be outweighed by the negatives of more complex code, and
you may choose to leave out that optimization.

Appendix
========

Bottleneck math
~~~~~~~~~~~~~~~

The proverb *"a chain is only as strong as its weakest link"* applies directly to
performance optimization. If your project is spending 90% of the time in
function ``A``, then optimizing ``A`` can have a massive effect on performance.

.. code-block:: none

    A: 9 ms
    Everything else: 1 ms
    Total frame time: 10 ms

.. code-block:: none

    A: 1 ms
    Everything else: 1ms
    Total frame time: 2 ms

In this example, improving this bottleneck ``A`` by a factor of 9× decreases
overall frame time by 5× while increasing frames per second by 5×.

However, if something else is running slowly and also bottlenecking your
project, then the same improvement can lead to less dramatic gains:

.. code-block:: none

    A: 9 ms
    Everything else: 50 ms
    Total frame time: 59 ms

.. code-block:: none

    A: 1 ms
    Everything else: 50 ms
    Total frame time: 51 ms

In this example, even though we have hugely optimized function ``A``,
the actual gain in terms of frame rate is quite small.

In games, things become even more complicated because the CPU and GPU run
independently of one another. Your total frame time is determined by the slower
of the two.

.. code-block:: none

    CPU: 9 ms
    GPU: 50 ms
    Total frame time: 50 ms

.. code-block:: none

    CPU: 1 ms
    GPU: 50 ms
    Total frame time: 50 ms

In this example, we optimized the CPU hugely again, but the frame time didn't
improve because we are GPU-bottlenecked.


===================================================
/. ./tutorials/performance/using_servers.rst
===================================================

.. _doc_using_servers:

Optimization using Servers
==========================

Engines like Godot provide increased ease of use thanks to their high level constructs and features.
Most of them are accessed and used via the :ref:`Scene System<doc_scene_tree>`. Using nodes and
resources simplifies project organization and asset management in complex games.

There are, of course, always drawbacks:

* There is an extra layer of complexity
* Performance is lower than using simple APIs directly
* It is not possible to use multiple threads to control them
* More memory is needed.

In many cases, this is not really a problem (Godot is very optimized, and most operations are handled
with signals, so no polling is required). Still, sometimes it can be. For example, dealing with
tens of thousands of instances for something that needs to be processed every frame can be a bottleneck.

This type of situation makes programmers regret they are using a game engine and wish they could go
back to a more handcrafted, low level implementation of game code.

Still, Godot is designed to work around this problem.

Servers
-------

One of the most interesting design decisions for Godot is the fact that the whole scene system is
*optional*. While it is not currently possible to compile it out, it can be completely bypassed.

At the core, Godot uses the concept of Servers. They are very low-level APIs to control
rendering, physics, sound, etc. The scene system is built on top of them and uses them directly.
The most common servers are:

* :ref:`VisualServer <class_VisualServer>`: handles everything related to graphics.
* :ref:`PhysicsServer <class_PhysicsServer>`: handles everything related to 3D physics.
* :ref:`Physics2DServer <class_Physics2DServer>`: handles everything related to 2D physics.
* :ref:`AudioServer <class_AudioServer>`: handles everything related to audio.

Explore their APIs and you will realize that all the functions provided are low-level
implementations of everything Godot allows you to do.

RIDs
----

The key to using servers is understanding Resource ID (:ref:`RID <class_RID>`) objects. These are opaque
handles to the server implementation. They are allocated and freed manually. Almost every
function in the servers requires RIDs to access the actual resource.

Most Godot nodes and resources contain these RIDs from the servers internally, and they can
be obtained with different functions. In fact, anything that inherits :ref:`Resource <class_Resource>`
can be directly casted to an RID. Not all resources contain an RID, though: in such cases, the RID will be empty. The resource can then be passed to server APIs as an RID.

.. Warning::  Resources are reference-counted (see :ref:`Reference <class_Reference>`), and
              references to a resource's RID are *not* counted when determining whether
              the resource is still in use. Make sure to keep a reference to the resource
              outside the server, or else both it and its RID will be erased.

For nodes, there are many functions available:

* For CanvasItem, the :ref:`CanvasItem.get_canvas_item() <class_CanvasItem_method_get_canvas_item>`
  method will return the canvas item RID in the server.
* For CanvasLayer, the :ref:`CanvasLayer.get_canvas() <class_CanvasLayer_method_get_canvas>`
  method will return the canvas RID in the server.
* For Viewport, the :ref:`Viewport.get_viewport_rid() <class_Viewport_method_get_viewport_rid>`
  method will return the viewport RID in the server.
* For 3D, the :ref:`World <class_World>` resource (obtainable in the :ref:`Viewport <class_Viewport>`
  and :ref:`Spatial <class_Spatial>` nodes)
  contains functions to get the *VisualServer Scenario*, and the *PhysicsServer Space*. This
  allows creating 3D objects directly with the server API and using them.
* For 2D, the :ref:`World2D <class_World2D>` resource (obtainable in the :ref:`Viewport <class_Viewport>`
  and :ref:`CanvasItem <class_CanvasItem>` nodes)
  contains functions to get the *VisualServer Canvas*, and the *Physics2DServer Space*. This
  allows creating 2D objects directly with the server API and using them.
* The :ref:`VisualInstance<class_VisualInstance>` class, allows getting the scenario *instance* and
  *instance base* via the :ref:`VisualInstance.get_instance() <class_VisualInstance_method_get_instance>`
  and :ref:`VisualInstance.get_base() <class_VisualInstance_method_get_base>` respectively.

Try exploring the nodes and resources you are familiar with and find the functions to obtain the server *RIDs*.

It is not advised to control RIDs from objects that already have a node associated. Instead, server
functions should always be used for creating and controlling new ones and interacting with the existing ones.

Creating a sprite
-----------------

This is a simple example of how to create a sprite from code and move it using the low-level
:ref:`CanvasItem <class_CanvasItem>` API.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node2D


    # VisualServer expects references to be kept around.
    var texture


    func _ready():
        # Create a canvas item, child of this node.
        var ci_rid = VisualServer.canvas_item_create()
        # Make this node the parent.
        VisualServer.canvas_item_set_parent(ci_rid, get_canvas_item())
        # Draw a texture on it.
        # Remember, keep this reference.
        texture = load("res://my_texture.png")
        # Add it, centered.
        VisualServer.canvas_item_add_texture_rect(ci_rid, Rect2(texture.get_size() / 2, texture.get_size()), texture)
        # Add the item, rotated 45 degrees and translated.
        var xform = Transform2D().rotated(deg2rad(45)).translated(Vector2(20, 30))
        VisualServer.canvas_item_set_transform(ci_rid, xform)

The Canvas Item API in the server allows you to add draw primitives to it. Once added, they can't be modified.
The Item needs to be cleared and the primitives re-added (this is not the case for setting the transform,
which can be done as many times as desired).

Primitives are cleared this way:

.. tabs::
 .. code-tab:: gdscript GDScript

    VisualServer.canvas_item_clear(ci_rid)


Instantiating a Mesh into 3D space
----------------------------------

The 3D APIs are different from the 2D ones, so the instantiation API must be used.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Spatial


    # VisualServer expects references to be kept around.
    var mesh


    func _ready():
        # Create a visual instance (for 3D).
        var instance = VisualServer.instance_create()
        # Set the scenario from the world, this ensures it
        # appears with the same objects as the scene.
        var scenario = get_world().scenario
        VisualServer.instance_set_scenario(instance, scenario)
        # Add a mesh to it.
        # Remember, keep the reference.
        mesh = load("res://mymesh.obj")
        VisualServer.instance_set_base(instance, mesh)
        # Move the mesh around.
        var xform = Transform(Basis(), Vector3(20, 100, 0))
        VisualServer.instance_set_transform(instance, xform)

Creating a 2D RigidBody and moving a sprite with it
---------------------------------------------------

This creates a :ref:`RigidBody2D <class_RigidBody2D>` using the :ref:`Physics2DServer <class_Physics2DServer>` API,
and moves a :ref:`CanvasItem <class_CanvasItem>` when the body moves.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Physics2DServer expects references to be kept around.
    var body
    var shape


    func _body_moved(state, index):
        # Created your own canvas item, use it here.
        VisualServer.canvas_item_set_transform(canvas_item, state.transform)


    func _ready():
        # Create the body.
        body = Physics2DServer.body_create()
        Physics2DServer.body_set_mode(body, Physics2DServer.BODY_MODE_RIGID)
        # Add a shape.
        shape = Physics2DServer.rectangle_shape_create()
        # Set rectangle extents.
        Physics2DServer.shape_set_data(shape, Vector2(10, 10))
        # Make sure to keep the shape reference!
        Physics2DServer.body_add_shape(body, shape)
        # Set space, so it collides in the same space as current scene.
        Physics2DServer.body_set_space(body, get_world_2d().space)
        # Move initial position.
        Physics2DServer.body_set_state(body, Physics2DServer.BODY_STATE_TRANSFORM, Transform2D(0, Vector2(10, 20)))
        # Add the transform callback, when body moves
        # The last parameter is optional, can be used as index
        # if you have many bodies and a single callback.
        Physics2DServer.body_set_force_integration_callback(body, self, "_body_moved", 0)

The 3D version should be very similar, as 2D and 3D physics servers are identical (using
:ref:`RigidBody <class_RigidBody>` and :ref:`PhysicsServer <class_PhysicsServer>` respectively).

Getting data from the servers
-----------------------------

Try to **never** request any information from ``VisualServer``, ``PhysicsServer`` or ``Physics2DServer``
by calling functions unless you know what you are doing. These servers will often run asynchronously
for performance and calling any function that returns a value will stall them and force them to process
anything pending until the function is actually called. This will severely decrease performance if you
call them every frame (and it won't be obvious why).

Because of this, most APIs in such servers are designed so it's not even possible to request information
back, until it's actual data that can be saved.


===================================================
/. ./tutorials/performance/cpu_optimization.rst
===================================================

.. _doc_cpu_optimization:

CPU optimization
================

Measuring performance
=====================

We have to know where the "bottlenecks" are to know how to speed up our program.
Bottlenecks are the slowest parts of the program that limit the rate that
everything can progress. Focussing on bottlenecks allows us to concentrate our
efforts on optimizing the areas which will give us the greatest speed
improvement, instead of spending a lot of time optimizing functions that will
lead to small performance improvements.

For the CPU, the easiest way to identify bottlenecks is to use a profiler.

CPU profilers
=============

Profilers run alongside your program and take timing measurements to work out
what proportion of time is spent in each function.

The Godot IDE conveniently has a built-in profiler. It does not run every time
you start your project: it must be manually started and stopped. This is
because, like most profilers, recording these timing measurements can
slow down your project significantly.

After profiling, you can look back at the results for a frame.

.. figure:: img/godot_profiler.png
.. figure:: img/godot_profiler.png
   :alt: Screenshot of the Godot profiler

   Results of a profile of one of the demo projects.

.. note:: We can see the cost of built-in processes such as physics and audio,
          as well as seeing the cost of our own scripting functions at the
          bottom.

          Time spent waiting for various built-in servers may not be counted in
          the profilers. This is a known bug.

When a project is running slowly, you will often see an obvious function or
process taking a lot more time than others. This is your primary bottleneck, and
you can usually increase speed by optimizing this area.

For more info about using Godot's built-in profiler, see
:ref:`doc_debugger_panel`.

External profilers
~~~~~~~~~~~~~~~~~~

Although the Godot IDE profiler is very convenient and useful, sometimes you
need more power, and the ability to profile the Godot engine source code itself.

You can use a number of third party profilers to do this including
`Valgrind <https://www.valgrind.org/>`__,
`VerySleepy <http://www.codersnotes.com/sleepy/>`__,
`HotSpot <https://github.com/KDAB/hotspot>`__,
`Visual Studio <https://visualstudio.microsoft.com/>`__ and
`Intel VTune <https://software.intel.com/content/www/us/en/develop/tools/vtune-profiler.html>`__.

.. note:: You will need to compile Godot from source to use a third-party profiler.
          This is required to obtain debugging symbols. You can also use a debug
          build, however, note that the results of profiling a debug build will
          be different to a release build, because debug builds are less
          optimized. Bottlenecks are often in a different place in debug builds,
          so you should profile release builds whenever possible.

.. figure:: img/valgrind.png
   :alt: Screenshot of Callgrind

   Example results from Callgrind, which is part of Valgrind.

From the left, Callgrind is listing the percentage of time within a function and
its children (Inclusive), the percentage of time spent within the function
itself, excluding child functions (Self), the number of times the function is
called, the function name, and the file or module.

In this example, we can see nearly all time is spent under the
`Main::iteration()` function. This is the master function in the Godot source
code that is called repeatedly. It causes frames to be drawn, physics ticks to
be simulated, and nodes and scripts to be updated. A large proportion of the
time is spent in the functions to render a canvas (66%), because this example
uses a 2D benchmark. Below this, we see that almost 50% of the time is spent
outside Godot code in ``libglapi`` and ``i965_dri`` (the graphics driver).
This tells us the a large proportion of CPU time is being spent in the
graphics driver.

This is actually an excellent example because, in an ideal world, only a very
small proportion of time would be spent in the graphics driver. This is an
indication that there is a problem with too much communication and work being
done in the graphics API. This specific profiling led to the development of 2D
batching, which greatly speeds up 2D rendering by reducing bottlenecks in this
area.

Manually timing functions
=========================

Another handy technique, especially once you have identified the bottleneck
using a profiler, is to manually time the function or area under test.
The specifics vary depending on the language, but in GDScript, you would do
the following:

::

    var time_start = OS.get_ticks_usec()

    # Your function you want to time
    update_enemies()

    var time_end = OS.get_ticks_usec()
    print("update_enemies() took %d microseconds" % time_end - time_start)

When manually timing functions, it is usually a good idea to run the function
many times (1,000 or more times), instead of just once (unless it is a very slow
function). The reason for doing this is that timers often have limited accuracy.
Moreover, CPUs will schedule processes in a haphazard manner. Therefore, an
average over a series of runs is more accurate than a single measurement.

As you attempt to optimize functions, be sure to either repeatedly profile or
time them as you go. This will give you crucial feedback as to whether the
optimization is working (or not).

Caches
======

CPU caches are something else to be particularly aware of, especially when
comparing timing results of two different versions of a function. The results
can be highly dependent on whether the data is in the CPU cache or not. CPUs
don't load data directly from the system RAM, even though it's huge in
comparison to the CPU cache (several gigabytes instead of a few megabytes). This
is because system RAM is very slow to access. Instead, CPUs load data from a
smaller, faster bank of memory called cache. Loading data from cache is very
fast, but every time you try and load a memory address that is not stored in
cache, the cache must make a trip to main memory and slowly load in some data.
This delay can result in the CPU sitting around idle for a long time, and is
referred to as a "cache miss".

This means that the first time you run a function, it may run slowly because the
data is not in the CPU cache. The second and later times, it may run much faster
because the data is in the cache. Due to this, always use averages when timing,
and be aware of the effects of cache.

Understanding caching is also crucial to CPU optimization. If you have an
algorithm (routine) that loads small bits of data from randomly spread out areas
of main memory, this can result in a lot of cache misses, a lot of the time, the
CPU will be waiting around for data instead of doing any work. Instead, if you
can make your data accesses localised, or even better, access memory in a linear
fashion (like a continuous list), then the cache will work optimally and the CPU
will be able to work as fast as possible.

Godot usually takes care of such low-level details for you. For example, the
Server APIs make sure data is optimized for caching already for things like
rendering and physics. Still, you should be especially aware of caching when
using :ref:`GDNative <toc-tutorials-gdnative>`.

Languages
=========

Godot supports a number of different languages, and it is worth bearing in mind
that there are trade-offs involved. Some languages are designed for ease of use
at the cost of speed, and others are faster but more difficult to work with.

Built-in engine functions run at the same speed regardless of the scripting
language you choose. If your project is making a lot of calculations in its own
code, consider moving those calculations to a faster language.

GDScript
~~~~~~~~

:ref:`GDScript <toc-learn-scripting-gdscript>` is designed to be easy to use and iterate,
and is ideal for making many types of games. However, in this language, ease of
use is considered more important than performance. If you need to make heavy
calculations, consider moving some of your project to one of the other
languages.

C#
~~

:ref:`C# <toc-learn-scripting-C#>` is popular and has first-class support in Godot.It
offers a good compromise between speed and ease of use. Beware of possible
garbage collection pauses and leaks that can occur during gameplay, though. A
common approach to workaround issues with garbage collection is to use *object
pooling*, which is outside the scope of this guide.

Other languages
~~~~~~~~~~~~~~~

Third parties provide support for several other languages, including `Rust
<https://github.com/godot-rust/godot-rust>`_ and `Javascript
<https://github.com/GodotExplorer/ECMAScript>`_.

C++
~~~

Godot is written in C++. Using C++ will usually result in the fastest code.
However, on a practical level, it is the most difficult to deploy to end users'
machines on different platforms. Options for using C++ include
:ref:`GDNative <toc-tutorials-gdnative>` and
:ref:`custom modules <doc_custom_modules_in_c++>`.

Threads
=======

Consider using threads when making a lot of calculations that can run in
parallel to each other. Modern CPUs have multiple cores, each one capable of
doing a limited amount of work. By spreading work over multiple threads, you can
move further towards peak CPU efficiency.

The disadvantage of threads is that you have to be incredibly careful. As each
CPU core operates independently, they can end up trying to access the same
memory at the same time. One thread can be reading to a variable while another
is writing: this is called a *race condition*. Before you use threads, make sure
you understand the dangers and how to try and prevent these race conditions.

Threads can also make debugging considerably more difficult. The GDScript
debugger doesn't support setting up breakpoints in threads yet.

For more information on threads, see :ref:`doc_using_multiple_threads`.

SceneTree
=========

Although Nodes are an incredibly powerful and versatile concept, be aware that
every node has a cost. Built-in functions such as `_process()` and
`_physics_process()` propagate through the tree. This housekeeping can reduce
performance when you have very large numbers of nodes (usually in the thousands).

Each node is handled individually in the Godot renderer. Therefore, a smaller
number of nodes with more in each can lead to better performance.

One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can sometimes
get much better performance by removing nodes from the SceneTree, rather than by
pausing or hiding them. You don't have to delete a detached node. You can for
example, keep a reference to a node, detach it from the scene tree using
:ref:`Node.remove_child(node) <class_Node_method_remove_child>`, then reattach
it later using :ref:`Node.add_child(node) <class_Node_method_add_child>`.
This can be very useful for adding and removing areas from a game, for example.

You can avoid the SceneTree altogether by using Server APIs. For more
information, see :ref:`doc_using_servers`.

Physics
=======

In some situations, physics can end up becoming a bottleneck. This is
particularly the case with complex worlds and large numbers of physics objects.

Here are some techniques to speed up physics:

- Try using simplified versions of your rendered geometry for collision shapes.
  Often, this won't be noticeable for end users, but can greatly increase
  performance.
- Try removing objects from physics when they are out of view / outside the
  current area, or reusing physics objects (maybe you allow 8 monsters per area,
  for example, and reuse these).

Another crucial aspect to physics is the physics tick rate. In some games, you
can greatly reduce the tick rate, and instead of for example, updating physics
60 times per second, you may update them only 30 or even 20 times per second.
This can greatly reduce the CPU load.

The downside of changing physics tick rate is you can get jerky movement or
jitter when the physics update rate does not match the frames per second
rendered. Also, decreasing the physics tick rate will increase input lag.
It's recommended to stick to the default physics tick rate (60 Hz) in most games
that feature real-time player movement.

The solution to jitter is to use *fixed timestep interpolation*, which involves
smoothing the rendered positions and rotations over multiple frames to match the
physics. You can either implement this yourself or use a
`third-party addon <https://github.com/lawnjelly/smoothing-addon>`__.
Performance-wise, interpolation is a very cheap operation compared to running a
physics tick. It's orders of magnitude faster, so this can be a significant
performance win while also reducing jitter.


===================================================
/. ./tutorials/performance/gpu_optimization.rst
===================================================

.. _doc_gpu_optimization:

GPU optimization
================

Introduction
~~~~~~~~~~~~

The demand for new graphics features and progress almost guarantees that you
will encounter graphics bottlenecks. Some of these can be on the CPU side, for
instance in calculations inside the Godot engine to prepare objects for
rendering. Bottlenecks can also occur on the CPU in the graphics driver, which
sorts instructions to pass to the GPU, and in the transfer of these
instructions. And finally, bottlenecks also occur on the GPU itself.

Where bottlenecks occur in rendering is highly hardware-specific.
Mobile GPUs in particular may struggle with scenes that run easily on desktop.

Understanding and investigating GPU bottlenecks is slightly different to the
situation on the CPU. This is because, often, you can only change performance
indirectly by changing the instructions you give to the GPU. Also, it may be
more difficult to take measurements. In many cases, the only way of measuring
performance is by examining changes in the time spent rendering each frame.

Draw calls, state changes, and APIs
===================================

.. note:: The following section is not relevant to end-users, but is useful to
          provide background information that is relevant in later sections.

Godot sends instructions to the GPU via a graphics API (OpenGL, OpenGL ES or
Vulkan). The communication and driver activity involved can be quite costly,
especially in OpenGL and OpenGL ES. If we can provide these instructions in a
way that is preferred by the driver and GPU, we can greatly increase
performance.

Nearly every API command in OpenGL requires a certain amount of validation to
make sure the GPU is in the correct state. Even seemingly simple commands can
lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal is to
reduce these instructions to a bare minimum and group together similar objects
as much as possible so they can be rendered together, or with the minimum number
of these expensive state changes.

2D batching
~~~~~~~~~~~

In 2D, the costs of treating each item individually can be prohibitively high -
there can easily be thousands of them on the screen. This is why 2D *batching*
is used. Multiple similar items are grouped together and rendered in a batch,
via a single draw call, rather than making a separate draw call for each item.
In addition, this means state changes, material and texture changes can be kept
to a minimum.

For more information on 2D batching, see :ref:`doc_batching`.

3D batching
~~~~~~~~~~~

In 3D, we still aim to minimize draw calls and state changes. However, it can be
more difficult to batch together several objects into a single draw call. 3D
meshes tend to comprise hundreds or thousands of triangles, and combining large
meshes in real-time is prohibitively expensive. The costs of joining them quickly
exceeds any benefits as the number of triangles grows per mesh. A much better
alternative is to **join meshes ahead of time** (static meshes in relation to each
other). This can either be done by artists, or programmatically within Godot.

There is also a cost to batching together objects in 3D. Several objects
rendered as one cannot be individually culled. An entire city that is off-screen
will still be rendered if it is joined to a single blade of grass that is on
screen. Thus, you should always take objects' location and culling into account
when attempting to batch 3D objects together. Despite this, the benefits of
joining static objects often outweigh other considerations, especially for large
numbers of distant or low-poly objects.

For more information on 3D specific optimizations, see
:ref:`doc_optimizing_3d_performance`.

Reuse Shaders and Materials
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Godot renderer is a little different to what is out there. It's designed to
minimize GPU state changes as much as possible. :ref:`SpatialMaterial
<class_SpatialMaterial>` does a good job at reusing materials that need similar
shaders. If custom shaders are used, make sure to reuse them as much as
possible. Godot's priorities are:

-  **Reusing Materials:** The fewer different materials in the
   scene, the faster the rendering will be. If a scene has a huge amount
   of objects (in the hundreds or thousands), try reusing the materials.
   In the worst case, use atlases to decrease the amount of texture changes.
-  **Reusing Shaders:** If materials can't be reused, at least try to reuse
   shaders. Note: shaders are automatically reused between
   SpatialMaterials that share the same configuration (features
   that are enabled or disabled with a check box) even if they have different
   parameters.

If a scene has, for example, ``20,000`` objects with ``20,000`` different
materials each, rendering will be slow. If the same scene has ``20,000``
objects, but only uses ``100`` materials, rendering will be much faster.

Pixel cost versus vertex cost
=============================

You may have heard that the lower the number of polygons in a model, the faster
it will be rendered. This is *really* relative and depends on many factors.

On a modern PC and console, vertex cost is low. GPUs originally only rendered
triangles. This meant that every frame:

1. All vertices had to be transformed by the CPU (including clipping).
2. All vertices had to be sent to the GPU memory from the main RAM.

Nowadays, all this is handled inside the GPU, greatly increasing performance.
3D artists usually have the wrong feeling about polycount performance because 3D
DCCs (such as Blender, Max, etc.) need to keep geometry in CPU memory for it to
be edited, reducing actual performance. Game engines rely on the GPU more, so
they can render many triangles much more efficiently.

On mobile devices, the story is different. PC and console GPUs are
brute-force monsters that can pull as much electricity as they need from
the power grid. Mobile GPUs are limited to a tiny battery, so they need
to be a lot more power efficient.

To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw occurs
when the same pixel on the screen is being rendered more than once. Imagine a
town with several buildings. GPUs don't know what is visible and what is hidden
until they draw it. For example, a house might be drawn and then another house
in front of it (which means rendering happened twice for the same pixel). PC
GPUs normally don't care much about this and just throw more pixel processors to
the hardware to increase performance (which also increases power consumption).

Using more power is not an option on mobile so mobile devices use a technique
called *tile-based rendering* which divides the screen into a grid. Each cell
keeps the list of triangles drawn to it and sorts them by depth to minimize
*overdraw*. This technique improves performance and reduces power consumption,
but takes a toll on vertex performance. As a result, fewer vertices and
triangles can be processed for drawing.

Additionally, tile-based rendering struggles when there are small objects with a
lot of geometry within a small portion of the screen. This forces mobile GPUs to
put a lot of strain on a single screen tile, which considerably decreases
performance as all the other cells must wait for it to complete before
displaying the frame.

To summarize, don't worry about vertex count on mobile, but
**avoid concentration of vertices in small parts of the screen**.
If a character, NPC, vehicle, etc. is far away (which means it looks tiny), use
a smaller level of detail (LOD) model. Even on desktop GPUs, it's preferable to
avoid having triangles smaller than the size of a pixel on screen.

Pay attention to the additional vertex processing required when using:

-  Skinning (skeletal animation)
-  Morphs (shape keys)
-  Vertex-lit objects (common on mobile)

Pixel/fragment shaders and fill rate
====================================

In contrast to vertex processing, the costs of fragment (per-pixel) shading have
increased dramatically over the years. Screen resolutions have increased (the
area of a 4K screen is 8,294,400 pixels, versus 307,200 for an old 640×480 VGA
screen, that is 27x the area), but also the complexity of fragment shaders has
exploded. Physically-based rendering requires complex calculations for each
fragment.

You can test whether a project is fill rate-limited quite easily. Turn off
V-Sync to prevent capping the frames per second, then compare the frames per
second when running with a large window, to running with a very small window.
You may also benefit from similarly reducing your shadow map size if using
shadows. Usually, you will find the FPS increases quite a bit using a small
window, which indicates you are to some extent fill rate-limited. On the other
hand, if there is little to no increase in FPS, then your bottleneck lies
elsewhere.

You can increase performance in a fill rate-limited project by reducing the
amount of work the GPU has to do. You can do this by simplifying the shader
(perhaps turn off expensive options if you are using a :ref:`SpatialMaterial
<class_SpatialMaterial>`), or reducing the number and size of textures used.

**When targeting mobile devices, consider using the simplest possible shaders
you can reasonably afford to use.**

Reading textures
~~~~~~~~~~~~~~~~

The other factor in fragment shaders is the cost of reading textures. Reading
textures is an expensive operation, especially when reading from several
textures in a single fragment shader. Also, consider that filtering may slow it
down further (trilinear filtering between mipmaps, and averaging). Reading
textures is also expensive in terms of power usage, which is a big issue on
mobiles.

**If you use third-party shaders or write your own shaders, try to use
algorithms that require as few texture reads as possible.**

Texture compression
~~~~~~~~~~~~~~~~~~~

By default, Godot compresses textures of 3D models when imported using video RAM
(VRAM) compression. Video RAM compression isn't as efficient in size as PNG or
JPG when stored, but increases performance enormously when drawing large enough
textures.

This is because the main goal of texture compression is bandwidth reduction
between memory and the GPU.

In 3D, the shapes of objects depend more on the geometry than the texture, so
compression is generally not noticeable. In 2D, compression depends more on
shapes inside the textures, so the artifacts resulting from 2D compression are
more noticeable.

As a warning, most Android devices do not support texture compression of
textures with transparency (only opaque), so keep this in mind.

.. note::

   Even in 3D, "pixel art" textures should have VRAM compression disabled as it
   will negatively affect their appearance, without improving performance
   significantly due to their low resolution.


Post-processing and shadows
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Post-processing effects and shadows can also be expensive in terms of fragment
shading activity. Always test the impact of these on different hardware.

**Reducing the size of shadowmaps can increase performance**, both in terms of
writing and reading the shadowmaps. On top of that, the best way to improve
performance of shadows is to turn shadows off for as many lights and objects as
possible. Smaller or distant OmniLights/SpotLights can often have their shadows
disabled with only a small visual impact.

Transparency and blending
=========================

Transparent objects present particular problems for rendering efficiency. Opaque
objects (especially in 3D) can be essentially rendered in any order and the
Z-buffer will ensure that only the front most objects get shaded. Transparent or
blended objects are different. In most cases, they cannot rely on the Z-buffer
and must be rendered in "painter's order" (i.e. from back to front) to look
correct.

Transparent objects are also particularly bad for fill rate, because every item
has to be drawn even if other transparent objects will be drawn on top
later on.

Opaque objects don't have to do this. They can usually take advantage of the
Z-buffer by writing to the Z-buffer only first, then only performing the
fragment shader on the "winning" fragment, the object that is at the front at a
particular pixel.

Transparency is particularly expensive where multiple transparent objects
overlap. It is usually better to use transparent areas as small as possible to
minimize these fill rate requirements, especially on mobile, where fill rate is
very expensive. Indeed, in many situations, rendering more complex opaque
geometry can end up being faster than using transparency to "cheat".

Multi-platform advice
=====================

If you are aiming to release on multiple platforms, test *early* and test
*often* on all your platforms, especially mobile. Developing a game on desktop
but attempting to port it to mobile at the last minute is a recipe for disaster.

In general, you should design your game for the lowest common denominator, then
add optional enhancements for more powerful platforms. For example, you may want
to use the GLES2 backend for both desktop and mobile platforms where you target
both.

Mobile/tiled renderers
======================

As described above, GPUs on mobile devices work in dramatically different ways
from GPUs on desktop. Most mobile devices use tile renderers. Tile renderers
split up the screen into regular-sized tiles that fit into super fast cache
memory, which reduces the number of read/write operations to the main memory.

There are some downsides though. Tiled rendering can make certain techniques
much more complicated and expensive to perform. Tiles that rely on the results
of rendering in different tiles or on the results of earlier operations being
preserved can be very slow. Be very careful to test the performance of shaders,
viewport textures and post processing.


===================================================
/. ./tutorials/performance/using_multimesh.rst
===================================================

.. _doc_using_multimesh:

Optimization using MultiMeshes
==============================

For large amount of instances (in the thousands), that need to be constantly processed
(and certain amount of control needs to be retained),
:ref:`using servers directly <doc_using_servers>` is the recommended optimization.

When the amount of objects reach the hundreds of thousands or millions,
none of these approaches are efficient anymore. Still, depending on the requirements, there
is one more optimization possible.

MultiMeshes
-----------

A :ref:`MultiMesh<class_MultiMesh>` is a single draw primitive that can draw up to millions
of objects in one go. It's extremely efficient because it uses the GPU hardware to do this
(in OpenGL ES 2.0, it's less efficient because there is no hardware support for it, though).

The only drawback is that there is no *screen* or *frustum* culling possible for individual instances.
This means, that millions of objects will be *always* or *never* drawn, depending on the visibility
of the whole MultiMesh. It is possible to provide a custom visibility rect for them, but it will always
be *all-or-none* visibility.

If the objects are simple enough (just a couple of vertices), this is generally not much of a problem
as most modern GPUs are optimized for this use case. A workaround is to create several MultiMeshes
for different areas of the world.

It is also possible to execute some logic inside the vertex shader (using the ``INSTANCE_ID`` or
``INSTANCE_CUSTOM`` built-in constants). For an example of animating thousands of objects in a MultiMesh,
see the :ref:`Animating thousands of fish <doc_animating_thousands_of_fish>` tutorial. Information
to the shader can be provided via textures (there are floating-point :ref:`Image<class_Image>` formats
which are ideal for this).

Another alternative is to use GDNative and C++, which should be extremely efficient (it's possible
to set the entire state for all objects using linear memory via the
:ref:`VisualServer.multimesh_set_as_bulk_array() <class_VisualServer_method_multimesh_set_as_bulk_array>`
function). This way, the array can be created with multiple threads, then set in one call, providing
high cache efficiency.

Finally, it's not required to have all MultiMesh instances visible. The amount of visible ones can be
controlled with the :ref:`MultiMesh.visible_instance_count <class_MultiMesh_property_visible_instance_count>`
property. The typical workflow is to allocate the maximum amount of instances that will be used,
then change the amount visible depending on how many are currently needed.

Multimesh example
-----------------

Here is an example of using a MultiMesh from code. Languages other than GDScript may be more
efficient for millions of objects, but for a few thousands, GDScript should be fine.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends MultiMeshInstance


    func _ready():
        # Create the multimesh.
        multimesh = MultiMesh.new()
        # Set the format first.
        multimesh.transform_format = MultiMesh.TRANSFORM_3D
        multimesh.color_format = MultiMesh.COLOR_NONE
        multimesh.custom_data_format = MultiMesh.CUSTOM_DATA_NONE
        # Then resize (otherwise, changing the format is not allowed).
        multimesh.instance_count = 10000
        # Maybe not all of them should be visible at first.
        multimesh.visible_instance_count = 1000

        # Set the transform of the instances.
        for i in multimesh.visible_instance_count:
            multimesh.set_instance_transform(i, Transform(Basis(), Vector3(i * 20, 0, 0)))

 .. code-tab:: csharp C#
 
    using Godot;
    using System;

    public class YourClassName : MultiMeshInstance
    {
        public override void _Ready()
        {
            // Create the multimesh.
            Multimesh = new MultiMesh();
            // Set the format first.
            Multimesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3d;
            Multimesh.ColorFormat = MultiMesh.ColorFormatEnum.None;
            Multimesh.CustomDataFormat = MultiMesh.CustomDataFormatEnum.None;
            // Then resize (otherwise, changing the format is not allowed)
            Multimesh.InstanceCount = 1000;
            // Maybe not all of them should be visible at first.
            Multimesh.VisibleInstanceCount = 1000;

            // Set the transform of the instances.
            for (int i = 0; i < Multimesh.VisibleInstanceCount; i++)
            {
                Multimesh.SetInstanceTransform(i, new Transform(Basis.Identity, new Vector3(i * 20, 0, 0)));
            }
        }
    }


===================================================
/. ./tutorials/performance/batching.rst
===================================================

.. _doc_batching:

Optimization using batching
===========================

Introduction
~~~~~~~~~~~~

Game engines have to send a set of instructions to the GPU to tell the GPU what
and where to draw. These instructions are sent using common instructions called
:abbr:`APIs (Application Programming Interfaces)`. Examples of graphics APIs are
OpenGL, OpenGL ES, and Vulkan.

Different APIs incur different costs when drawing objects. OpenGL handles a lot
of work for the user in the GPU driver at the cost of more expensive draw calls.
As a result, applications can often be sped up by reducing the number of draw
calls.

Draw calls
^^^^^^^^^^

In 2D, we need to tell the GPU to render a series of primitives (rectangles,
lines, polygons etc). The most obvious technique is to tell the GPU to render
one primitive at a time, telling it some information such as the texture used,
the material, the position, size, etc. then saying "Draw!" (this is called a
draw call).

While this is conceptually simple from the engine side, GPUs operate very slowly
when used in this manner. GPUs work much more efficiently if you tell them to
draw a number of similar primitives all in one draw call, which we will call a
"batch".

It turns out that they don't just work a bit faster when used in this manner;
they work a *lot* faster.

As Godot is designed to be a general-purpose engine, the primitives coming into
the Godot renderer can be in any order, sometimes similar, and sometimes
dissimilar. To match Godot's general-purpose nature with the batching
preferences of GPUs, Godot features an intermediate layer which can
automatically group together primitives wherever possible and send these batches
on to the GPU. This can give an increase in rendering performance while
requiring few (if any) changes to your Godot project.

How it works
~~~~~~~~~~~~

Instructions come into the renderer from your game in the form of a series of
items, each of which can contain one or more commands. The items correspond to
Nodes in the scene tree, and the commands correspond to primitives such as
rectangles or polygons. Some items such as TileMaps and text can contain a
large number of commands (tiles and glyphs respectively). Others, such as
sprites, may only contain a single command (a rectangle).

The batcher uses two main techniques to group together primitives:

- Consecutive items can be joined together.
- Consecutive commands within an item can be joined to form a batch.

Breaking batching
^^^^^^^^^^^^^^^^^

Batching can only take place if the items or commands are similar enough to be
rendered in one draw call. Certain changes (or techniques), by necessity, prevent
the formation of a contiguous batch, this is referred to as "breaking batching".

Batching will be broken by (amongst other things):

- Change of texture.
- Change of material.
- Change of primitive type (say, going from rectangles to lines).

.. note::

    For example, if you draw a series of sprites each with a different texture,
    there is no way they can be batched.

Determining the rendering order
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The question arises, if only similar items can be drawn together in a batch, why
don't we look through all the items in a scene, group together all the similar
items, and draw them together?

In 3D, this is often exactly how engines work. However, in Godot's 2D renderer,
items are drawn in "painter's order", from back to front. This ensures that
items at the front are drawn on top of earlier items when they overlap.

This also means that if we try and draw objects on a per-texture basis, then
this painter's order may break and objects will be drawn in the wrong order.

In Godot, this back-to-front order is determined by:

- The order of objects in the scene tree.
- The Z index of objects.
- The canvas layer.
- :ref:`class_YSort` nodes.

.. note::

    You can group similar objects together for easier batching. While doing so
    is not a requirement on your part, think of it as an optional approach that
    can improve performance in some cases. See the
    :ref:`doc_batching_diagnostics` section to help you make this decision.

A trick
^^^^^^^

And now, a sleight of hand. Even though the idea of painter's order is that
objects are rendered from back to front, consider 3 objects ``A``, ``B`` and
``C``, that contain 2 different textures: grass and wood.

.. image:: img/overlap1.png

In painter's order they are ordered::

    A - wood
    B - grass
    C - wood

Because of the texture changes, they can't be batched and will be rendered in 3
draw calls.

However, painter's order is only needed on the assumption that they will be
drawn *on top* of each other. If we relax that assumption, i.e. if none of these
3 objects are overlapping, there is *no need* to preserve painter's order. The
rendered result will be the same. What if we could take advantage of this?

Item reordering
^^^^^^^^^^^^^^^

.. image:: img/overlap2.png

It turns out that we can reorder items. However, we can only do this if the
items satisfy the conditions of an overlap test, to ensure that the end result
will be the same as if they were not reordered. The overlap test is very cheap
in performance terms, but not absolutely free, so there is a slight cost to
looking ahead to decide whether items can be reordered. The number of items to
lookahead for reordering can be set in project settings (see below), in order to
balance the costs and benefits in your project.

::

    A - wood
    C - wood
    B - grass

Since the texture only changes once, we can render the above in only 2 draw
calls.

Lights
~~~~~~

Although the batching system's job is normally quite straightforward, it becomes
considerably more complex when 2D lights are used. This is because lights are
drawn using additional passes, one for each light affecting the primitive.
Consider 2 sprites ``A`` and ``B``, with identical texture and material. Without
lights, they would be batched together and drawn in one draw call. But with 3
lights, they would be drawn as follows, each line being a draw call:

.. image:: img/lights_overlap.png

::

    A
    A - light 1
    A - light 2
    A - light 3
    B
    B - light 1
    B - light 2
    B - light 3

That is a lot of draw calls: 8 for only 2 sprites. Now, consider we are drawing
1,000 sprites. The number of draw calls quickly becomes astronomical and
performance suffers. This is partly why lights have the potential to drastically
slow down 2D rendering.

However, if you remember our magician's trick from item reordering, it turns out
we can use the same trick to get around painter's order for lights!

If ``A`` and ``B`` are not overlapping, we can render them together in a batch,
so the drawing process is as follows:

.. image:: img/lights_separate.png

::

    AB
    AB - light 1
    AB - light 2
    AB - light 3


That is only 4 draw calls. Not bad, as that is a 2× reduction. However, consider
that in a real game, you might be drawing closer to 1,000 sprites.

- **Before:** 1000 × 4 = 4,000 draw calls.
- **After:** 1 × 4 = 4 draw calls.

That is a 1000× decrease in draw calls, and should give a huge increase in
performance.

Overlap test
^^^^^^^^^^^^

However, as with the item reordering, things are not that simple. We must first
perform the overlap test to determine whether we can join these primitives. This
overlap test has a small cost. Again, you can choose the number of primitives to
lookahead in the overlap test to balance the benefits against the cost. With
lights, the benefits usually far outweigh the costs.

Also consider that depending on the arrangement of primitives in the viewport,
the overlap test will sometimes fail (because the primitives overlap and
therefore shouldn't be joined). In practice, the decrease in draw calls may be
less dramatic than in a perfect situation with no overlapping at all. However,
performance is usually far higher than without this lighting optimization.

Light scissoring
~~~~~~~~~~~~~~~~

Batching can make it more difficult to cull out objects that are not affected or
partially affected by a light. This can increase the fill rate requirements
quite a bit and slow down rendering. *Fill rate* is the rate at which pixels are
colored. It is another potential bottleneck unrelated to draw calls.

In order to counter this problem (and speed up lighting in general), batching
introduces light scissoring. This enables the use of the OpenGL command
``glScissor()``, which identifies an area outside of which the GPU won't render
any pixels. We can greatly optimize fill rate by identifying the intersection
area between a light and a primitive, and limit rendering the light to
*that area only*.

Light scissoring is controlled with the :ref:`scissor_area_threshold
<class_ProjectSettings_property_rendering/batching/lights/scissor_area_threshold>`
project setting. This value is between 1.0 and 0.0, with 1.0 being off (no
scissoring), and 0.0 being scissoring in every circumstance. The reason for the
setting is that there may be some small cost to scissoring on some hardware.
That said, scissoring should usually result in performance gains when you're
using 2D lighting.

The relationship between the threshold and whether a scissor operation takes
place is not always straightforward. Generally, it represents the pixel area
that is potentially "saved" by a scissor operation (i.e. the fill rate saved).
At 1.0, the entire screen's pixels would need to be saved, which rarely (if
ever) happens, so it is switched off. In practice, the useful values are close
to 0.0, as only a small percentage of pixels need to be saved for the operation
to be useful.

The exact relationship is probably not necessary for users to worry about, but
is included in the appendix out of interest:
:ref:`doc_batching_light_scissoring_threshold_calculation`

.. figure:: img/scissoring.png
   :alt: Light scissoring example diagram

   Bottom right is a light, the red area is the pixels saved by the scissoring
   operation. Only the intersection needs to be rendered.

Vertex baking
~~~~~~~~~~~~~

The GPU shader receives instructions on what to draw in 2 main ways:

- Shader uniforms (e.g. modulate color, item transform).
- Vertex attributes (vertex color, local transform).

However, within a single draw call (batch), we cannot change uniforms. This
means that naively, we would not be able to batch together items or commands
that change ``final_modulate`` or an item's transform. Unfortunately, that
happens in an awful lot of cases. For instance, sprites are typically
individual nodes with their own item transform, and they may have their own
color modulate as well.

To get around this problem, the batching can "bake" some of the uniforms into
the vertex attributes.

- The item transform can be combined with the local transform and sent in a
  vertex attribute.
- The final modulate color can be combined with the vertex colors, and sent in a
  vertex attribute.

In most cases, this works fine, but this shortcut breaks down if a shader expects
these values to be available individually rather than combined. This can happen
in custom shaders.

Custom shaders
^^^^^^^^^^^^^^

As a result of the limitation described above, certain operations in custom
shaders will prevent vertex baking and therefore decrease the potential for
batching. While we are working to decrease these cases, the following caveats
currently apply:

- Reading or writing ``COLOR`` or ``MODULATE`` disables vertex color baking.
- Reading ``VERTEX``  disables vertex position baking.

Project Settings
~~~~~~~~~~~~~~~~

To fine-tune batching, a number of project settings are available. You can
usually leave these at default during development, but it's a good idea to
experiment to ensure you are getting maximum performance. Spending a little time
tweaking parameters can often give considerable performance gains for very
little effort. See the on-hover tooltips in the Project Settings for more
information.

rendering/batching/options
^^^^^^^^^^^^^^^^^^^^^^^^^^

- :ref:`use_batching
  <class_ProjectSettings_property_rendering/batching/options/use_batching>` -
  Turns batching on or off.

- :ref:`use_batching_in_editor
  <class_ProjectSettings_property_rendering/batching/options/use_batching_in_editor>`
  Turns batching on or off in the Godot editor.
  This setting doesn't affect the running project in any way.

- :ref:`single_rect_fallback
  <class_ProjectSettings_property_rendering/batching/options/single_rect_fallback>` -
  This is a faster way of drawing unbatchable rectangles. However, it may lead
  to flicker on some hardware so it's not recommended.

rendering/batching/parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- :ref:`max_join_item_commands <class_ProjectSettings_property_rendering/batching/parameters/max_join_item_commands>` -
  One of the most important ways of achieving batching is to join suitable
  adjacent items (nodes) together, however they can only be joined if the
  commands they contain are compatible. The system must therefore do a lookahead
  through the commands in an item to determine whether it can be joined. This
  has a small cost per command, and items with a large number of commands are
  not worth joining, so the best value may be project dependent.

- :ref:`colored_vertex_format_threshold
  <class_ProjectSettings_property_rendering/batching/parameters/colored_vertex_format_threshold>` -
  Baking colors into vertices results in a larger vertex format. This is not
  necessarily worth doing unless there are a lot of color changes going on
  within a joined item. This parameter represents the proportion of commands
  containing color changes / the total commands, above which it switches to
  baked colors.

- :ref:`batch_buffer_size
  <class_ProjectSettings_property_rendering/batching/parameters/batch_buffer_size>` -
  This determines the maximum size of a batch, it doesn't have a huge effect
  on performance but can be worth decreasing for mobile if RAM is at a premium.

- :ref:`item_reordering_lookahead
  <class_ProjectSettings_property_rendering/batching/parameters/item_reordering_lookahead>` -
  Item reordering can help especially with interleaved sprites using different
  textures. The lookahead for the overlap test has a small cost, so the best
  value may change per project.

rendering/batching/lights
^^^^^^^^^^^^^^^^^^^^^^^^^

- :ref:`scissor_area_threshold
  <class_ProjectSettings_property_rendering/batching/lights/scissor_area_threshold>` -
  See light scissoring.

- :ref:`max_join_items
  <class_ProjectSettings_property_rendering/batching/lights/max_join_items>` -
  Joining items before lighting can significantly increase
  performance. This requires an overlap test, which has a small cost, so the
  costs and benefits may be project dependent, and hence the best value to use
  here.

rendering/batching/debug
^^^^^^^^^^^^^^^^^^^^^^^^

- :ref:`flash_batching
  <class_ProjectSettings_property_rendering/batching/debug/flash_batching>` -
  This is purely a debugging feature to identify regressions between the
  batching and legacy renderer. When it is switched on, the batching and legacy
  renderer are used alternately on each frame. This will decrease performance,
  and should not be used for your final export, only for testing.

- :ref:`diagnose_frame
  <class_ProjectSettings_property_rendering/batching/debug/diagnose_frame>` -
  This will periodically print a diagnostic batching log to
  the Godot IDE / console.

rendering/batching/precision
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- :ref:`uv_contract
  <class_ProjectSettings_property_rendering/batching/precision/uv_contract>` -
  On some hardware (notably some Android devices) there have been reports of
  tilemap tiles drawing slightly outside their UV range, leading to edge
  artifacts such as lines around tiles. If you see this problem, try enabling uv
  contract. This makes a small contraction in the UV coordinates to compensate
  for precision errors on devices.

- :ref:`uv_contract_amount
  <class_ProjectSettings_property_rendering/batching/precision/uv_contract_amount>` -
  Hopefully, the default amount should cure artifacts on most devices,
  but this value remains adjustable just in case.

.. _doc_batching_diagnostics:

Diagnostics
~~~~~~~~~~~

Although you can change parameters and examine the effect on frame rate, this
can feel like working blindly, with no idea of what is going on under the hood.
To help with this, batching offers a diagnostic mode, which will periodically
print out (to the IDE or console) a list of the batches that are being
processed. This can help pinpoint situations where batching isn't occurring
as intended, and help you fix these situations to get the best possible performance.

Reading a diagnostic
^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

    canvas_begin FRAME 2604
    items
        joined_item 1 refs
                batch D 0-0
                batch D 0-2 n n
                batch R 0-1 [0 - 0] {255 255 255 255 }
        joined_item 1 refs
                batch D 0-0
                batch R 0-1 [0 - 146] {255 255 255 255 }
                batch D 0-0
                batch R 0-1 [0 - 146] {255 255 255 255 }
        joined_item 1 refs
                batch D 0-0
                batch R 0-2560 [0 - 144] {158 193 0 104 } MULTI
                batch D 0-0
                batch R 0-2560 [0 - 144] {158 193 0 104 } MULTI
                batch D 0-0
                batch R 0-2560 [0 - 144] {158 193 0 104 } MULTI
    canvas_end


This is a typical diagnostic.

- **joined_item:** A joined item can contain 1 or
  more references to items (nodes). Generally, joined_items containing many
  references is preferable to many joined_items containing a single reference.
  Whether items can be joined will be determined by their contents and
  compatibility with the previous item.
- **batch R:** A batch containing rectangles. The second number is the number of
  rects. The second number in square brackets is the Godot texture ID, and the
  numbers in curly braces is the color. If the batch contains more than one rect,
  ``MULTI`` is added to the line to make it easy to identify.
  Seeing ``MULTI`` is good as it indicates successful batching.
- **batch D:** A default batch, containing everything else that is not currently
  batched.

Default batches
^^^^^^^^^^^^^^^

The second number following default batches is the number of commands in the
batch, and it is followed by a brief summary of the contents::

    l - line
    PL - polyline
    r - rect
    n - ninepatch
    PR - primitive
    p - polygon
    m - mesh
    MM - multimesh
    PA - particles
    c - circle
    t - transform
    CI - clip_ignore

You may see "dummy" default batches containing no commands; you can ignore those.

Frequently asked questions
~~~~~~~~~~~~~~~~~~~~~~~~~~

I don't get a large performance increase when enabling batching.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Try the diagnostics, see how much batching is occurring, and whether it can be
  improved
- Try changing batching parameters in the Project Settings.
- Consider that batching may not be your bottleneck (see bottlenecks).

I get a decrease in performance with batching.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Try the steps described above to increase the number of batching opportunities.
- Try enabling :ref:`single_rect_fallback
  <class_ProjectSettings_property_rendering/batching/options/single_rect_fallback>`.
- The single rect fallback method is the default used without batching, and it
  is approximately twice as fast. However, it can result in flickering on some
  hardware, so its use is discouraged.
- After trying the above, if your scene is still performing worse, consider
  turning off batching.

I use custom shaders and the items are not batching.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Custom shaders can be problematic for batching, see the custom shaders section

I am seeing line artifacts appear on certain hardware.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- See the :ref:`uv_contract
  <class_ProjectSettings_property_rendering/batching/precision/uv_contract>`
  project setting which can be used to solve this problem.

I use a large number of textures, so few items are being batched.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Consider using texture atlases. As well as allowing batching, these
  reduce the need for state changes associated with changing textures.

Appendix
~~~~~~~~

Batched primitives
^^^^^^^^^^^^^^^^^^

Not all primitives can be batched. Batching is not guaranteed either,
especially with primitives using an antialiased border. The following
primitive types are currently available:

- RECT
- NINEPATCH (depending on wrapping mode)
- POLY
- LINE

With non-batched primitives, you may be able to get better performance by
drawing them manually with polys in a ``_draw()`` function.
See :ref:`doc_custom_drawing_in_2d` for more information.

.. _doc_batching_light_scissoring_threshold_calculation:

Light scissoring threshold calculation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The actual proportion of screen pixel area used as the threshold is the
:ref:`scissor_area_threshold
<class_ProjectSettings_property_rendering/batching/lights/scissor_area_threshold>`
value to the power of 4.

For example, on a screen size of 1920×1080, there are 2,073,600 pixels.

At a threshold of 1,000 pixels, the proportion would be::

    1000 / 2073600 = 0.00048225
    0.00048225 ^ (1/4) = 0.14819

So a :ref:`scissor_area_threshold
<class_ProjectSettings_property_rendering/batching/lights/scissor_area_threshold>`
of ``0.15`` would be a reasonable value to try.

Going the other way, for instance with a :ref:`scissor_area_threshold
<class_ProjectSettings_property_rendering/batching/lights/scissor_area_threshold>`
of ``0.5``::

    0.5 ^ 4 = 0.0625
    0.0625 * 2073600 = 129600 pixels

If the number of pixels saved is greater than this threshold, the scissor is
activated.


===================================================
/. ./tutorials/performance/optimizing_3d_performance.rst
===================================================

.. meta::
    :keywords: optimization

.. _doc_optimizing_3d_performance:

Optimizing 3D performance
=========================

Culling
=======

Godot will automatically perform view frustum culling in order to prevent
rendering objects that are outside the viewport. This works well for games that
take place in a small area, however things can quickly become problematic in
larger levels.

Occlusion culling
~~~~~~~~~~~~~~~~~

Walking around a town for example, you may only be able to see a few buildings
in the street you are in, as well as the sky and a few birds flying overhead. As
far as a naive renderer is concerned however, you can still see the entire town.
It won't just render the buildings in front of you, it will render the street
behind that, with the people on that street, the buildings behind that. You
quickly end up in situations where you are attempting to render 10× or 100× more
than what is visible.

Things aren't quite as bad as they seem, because the Z-buffer usually allows the
GPU to only fully shade the objects that are at the front. This is called *depth
prepass* and is enabled by default in Godot when using the GLES3 renderer.
However, unneeded objects are still reducing performance.

One way we can potentially reduce the amount to be rendered is to take advantage
of occlusion.

For instance, in our city street scenario, you may be able to work out in advance
that you can only see two other streets, ``B`` and ``C``, from street ``A``.
Streets ``D`` to ``Z`` are hidden. In order to take advantage of occlusion, all
you have to do is work out when your viewer is in street ``A`` (perhaps using
Godot Areas), then you can hide the other streets.

This example is a manual version of what is known as a *potentially visible set*.
It is a very powerful technique for speeding up rendering. You can also use it to
restrict physics or AI to the local area, and speed these up as well as
rendering.

Portal Rendering
~~~~~~~~~~~~~~~~

However, there is a much easier way to take advantage of occlusion. Godot features
an advanced portal rendering system, which can perform occlusion culling from cameras and
lights. See :ref:`doc_rooms_and_portals`.

This is not a fully automatic system and it requires some manual setup. However, it potentially
offers significant performance increases.

.. note::

    In some cases, you can adapt your level design to add more occlusion
    opportunities. For example, you can add more walls to prevent the player
    from seeing too far away, which would decrease performance due to the lost
    opportunities for occlusion culling.

Other occlusion techniques
~~~~~~~~~~~~~~~~~~~~~~~~~~

As well as the portal system and manual methods, there are various other occlusion
techniques such as raster-based occlusion culling. Some of these may be available
through add-ons or may be available in core Godot in the future.

Transparent objects
~~~~~~~~~~~~~~~~~~~

Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader
<class_Shader>` to improve performance. This, however, can not be done with
transparent objects. Transparent objects are rendered from back to front to make
blending with what is behind work. As a result,
**try to use as few transparent objects as possible**. If an object has a
small section with transparency, try to make that section a separate surface
with its own material.

For more information, see the :ref:`GPU optimizations <doc_gpu_optimization>`
doc.

Level of detail (LOD)
=====================

In some situations, particularly at a distance, it can be a good idea to
**replace complex geometry with simpler versions**. The end user will probably
not be able to see much difference. Consider looking at a large number of trees
in the far distance. There are several strategies for replacing models at
varying distance. You could use lower poly models, or use transparency to
simulate more complex geometry.

Billboards and imposters
~~~~~~~~~~~~~~~~~~~~~~~~

The simplest version of using transparency to deal with LOD is billboards. For
example, you can use a single transparent quad to represent a tree at distance.
This can be very cheap to render, unless of course, there are many trees in
front of each other. In which case transparency may start eating into fill rate
(for more information on fill rate, see :ref:`doc_gpu_optimization`).

An alternative is to render not just one tree, but a number of trees together as
a group. This can be especially effective if you can see an area but cannot
physically approach it in a game.

You can make imposters by pre-rendering views of an object at different angles.
Or you can even go one step further, and periodically re-render a view of an
object onto a texture to be used as an imposter. At a distance, you need to move
the viewer a considerable distance for the angle of view to change
significantly. This can be complex to get working, but may be worth it depending
on the type of project you are making.

Use instancing (MultiMesh)
~~~~~~~~~~~~~~~~~~~~~~~~~~

If several identical objects have to be drawn in the same place or nearby, try
using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the drawing
of many thousands of objects at very little performance cost, making it ideal
for flocks, grass, particles, and anything else where you have thousands of
identical objects.

Also see the :ref:`Using MultiMesh <doc_using_multimesh>` doc.

Bake lighting
=============

Lighting objects is one of the most costly rendering operations. Realtime
lighting, shadows (especially multiple lights), and GI are especially expensive.
They may simply be too much for lower power mobile devices to handle.

**Consider using baked lighting**, especially for mobile. This can look fantastic,
but has the downside that it will not be dynamic. Sometimes, this is a trade-off
worth making.

In general, if several lights need to affect a scene, it's best to use
:ref:`doc_baked_lightmaps`. Baking can also improve the scene quality by adding
indirect light bounces.

Animation and skinning
======================

Animation and vertex animation such as skinning and morphing can be very
expensive on some platforms. You may need to lower the polycount considerably
for animated models or limit the number of them on screen at any one time.

Large worlds
============

If you are making large worlds, there are different considerations than what you
may be familiar with from smaller games.

Large worlds may need to be built in tiles that can be loaded on demand as you
move around the world. This can prevent memory use from getting out of hand, and
also limit the processing needed to the local area.

There may also be rendering and physics glitches due to floating point error in
large worlds. You may be able to use techniques such as orienting the world
around the player (rather than the other way around), or shifting the origin
periodically to keep things centred around ``Vector3(0, 0, 0)``.


===================================================
/. ./tutorials/performance/vertex_animation/index.rst
===================================================

Animating thousands of objects
==============================

.. toctree::
   :maxdepth: 1
   :name: toc-vertex_animation

   animating_thousands_of_fish
   controlling_thousands_of_fish


===================================================
/. ./tutorials/performance/vertex_animation/animating_thousands_of_fish.rst
===================================================

.. _doc_animating_thousands_of_fish:

Animating thousands of fish with MultiMeshInstance
==================================================

This tutorial explores a technique used in the game `ABZU <https://www.gdcvault.com/play/1024409/Creating-the-Art-of-ABZ>`_
for rendering and animating thousands of fish using vertex animation and
static mesh instancing.

In Godot, this can be accomplished with a custom :ref:`Shader <class_Shader>` and
a :ref:`MultiMeshInstance <class_MultiMeshInstance>`. Using the following technique you
can render thousands of animated objects, even on low end hardware.

We will start by animating one fish. Then, we will see how to extend that animation to
thousands of fish.

Animating one Fish
------------------

We will start with a single fish. Load your fish model into a :ref:`MeshInstance <class_MeshInstance>`
and add a new :ref:`ShaderMaterial <class_ShaderMaterial>`.

Here is the fish we will be using for the example images, you can use any fish model you like.

.. image:: img/fish.png

.. note:: The fish model in this tutorial is made by `QuaterniusDev <http://quaternius.com>`_ and is
          shared with a creative commons license. CC0 1.0 Universal (CC0 1.0) Public Domain
          Dedication https://creativecommons.org/publicdomain/zero/1.0/

Typically, you would use bones and a :ref:`Skeleton <class_Skeleton>` to animate objects. However,
bones are animated on the CPU and so you end having to calculate thousands of operations every
frame and it becomes impossible to have thousands of objects. Using vertex animation in a vertex
shader, you avoid using bones and can instead calculate the full animation in a few lines of code
and completely on the GPU.

The animation will be made of four key motions:

  1. A side to side motion
  2. A pivot motion around the center of the fish
  3. A panning wave motion
  4. A panning twist motion

All the code for the animation will be in the vertex shader with uniforms controlling the amount of motion.
We use uniforms to control the strength of the motion so that you can tweak the animation in editor and see the
results in real time, without the shader having to recompile.

All the motions will be made using cosine waves applied to ``VERTEX`` in model space. We want the vertices to
be in model space so that the motion is always relative to the orientation of the fish. For example, side-to-side
will always move the fish back and forth in its left to right direction, instead of on the ``x`` axis in the
world orientation.

In order to control the speed of the animation, we will start by defining our own time variable using ``TIME``.

.. code-block:: glsl

  //time_scale is a uniform float
  float time = TIME * time_scale;

The first motion we will implement is the side to side motion. It can be made by offsetting ``VERTEX.x`` by
``cos`` of ``TIME``. Each time the mesh is rendered, all the vertices will move to the side by the amount
of ``cos(time)``.

.. code-block:: glsl

  //side_to_side is a uniform float
  VERTEX.x += cos(time) * side_to_side;

The resulting animation should look something like this:

.. image:: img/sidetoside.gif

Next, we add the pivot. Because the fish is centered at (0, 0), all we have to do is multiply ``VERTEX`` by a
rotation matrix for it to rotate around the center of the fish.

We construct a rotation matrix like so:

.. code-block:: glsl

  //angle is scaled by 0.1 so that the fish only pivots and doesn't rotate all the way around
  //pivot is a uniform float
  float pivot_angle = cos(time) * 0.1 * pivot;
  mat2 rotation_matrix = mat2(vec2(cos(pivot_angle), -sin(pivot_angle)), vec2(sin(pivot_angle), cos(pivot_angle)));

And then we apply it in the ``x`` and ``z`` axes by multiplying it by ``VERTEX.xz``.

.. code-block:: glsl

  VERTEX.xz = rotation_matrix * VERTEX.xz;

With only the pivot applied you should see something like this:

.. image:: img/pivot.gif

The next two motions need to pan down the spine of the fish. For that, we need a new variable, ``body``.
``body`` is a float that is ``0`` at the tail of the fish and ``1`` at its head.

.. code-block:: glsl

  float body = (VERTEX.z + 1.0) / 2.0; //for a fish centered at (0, 0) with a length of 2

The next motion is a cosine wave that moves down the length of the fish. To make
it move along the spine of the fish, we offset the input to ``cos`` by the position
along the spine, which is the variable we defined above, ``body``.

.. code-block:: glsl

  //wave is a uniform float
  VERTEX.x += cos(time + body) * wave;

This looks very similar to the side to side motion we defined above, but in this one, by
using ``body`` to offset ``cos`` each vertex along the spine has a different position in
the wave making it look like a wave is moving along the fish.

.. image:: img/wave.gif

The last motion is the twist, which is a panning roll along the spine. Similarly to the pivot,
we first construct a rotation matrix.

.. code-block:: glsl

  //twist is a uniform float
  float twist_angle = cos(time + body) * 0.3 * twist;
  mat2 twist_matrix = mat2(vec2(cos(twist_angle), -sin(twist_angle)), vec2(sin(twist_angle), cos(twist_angle)));

We apply the rotation in the ``xy`` axes so that the fish appears to roll around its spine. For
this to work, the fish's spine needs to be centered on the ``z`` axis.

.. code-block:: glsl

  VERTEX.xy = twist_matrix * VERTEX.xy;

Here is the fish with twist applied:

.. image:: img/twist.gif

If we apply all these motions one after another, we get a fluid jelly-like motion.

.. image:: img/all_motions.gif

Normal fish swim mostly with the back half of their body. Accordingly, we need to limit the
panning motions to the back half of the fish. To do this, we create a new variable, ``mask``.

``mask`` is a float that goes from ``0`` at the front of the fish to ``1`` at the end using
``smoothstep`` to control the point at which the transition from ``0`` to ``1`` happens.

.. code-block:: glsl

  //mask_black and mask_white are uniforms
  float mask = smoothstep(mask_black, mask_white, 1.0 - body);

Below is an image of the fish with ``mask`` used as ``COLOR``:

.. image:: img/mask.png

For the wave, we multiply the motion by ``mask`` which will limit it to the back half.

.. code-block:: glsl

  //wave motion with mask
  VERTEX.x += cos(time + body) * mask * wave;

In order to apply the mask to the twist, we use ``mix``. ``mix`` allows us to mix the
vertex position between a fully rotated vertex and one that is not rotated. We need to
use ``mix`` instead of multiplying ``mask`` by the rotated ``VERTEX`` because we are not
adding the motion to the ``VERTEX`` we are replacing the ``VERTEX`` with the rotated
version. If we multiplied that by ``mask``, we would shrink the fish.

.. code-block:: glsl

  //twist motion with mask
  VERTEX.xy = mix(VERTEX.xy, twist_matrix * VERTEX.xy, mask);

Putting the four motions together gives us the final animation.

.. image:: img/all_motions_mask.gif

Go ahead and play with the uniforms in order to alter the swim cycle of the fish. You will
find that you can create a wide variety of swim styles using these four motions.

Making a school of fish
-----------------------

Godot makes it easy to render thousands of the same object using a MultiMeshInstance node.

A MultiMeshInstance node is created and used the same way you would make a MeshInstance node.
For this tutorial, we will name the MultiMeshInstance node ``School``, because it will contain
a school of fish.

Once you have a MultiMeshInstance add a :ref:`MultiMesh <class_MultiMesh>`, and to that
MultiMesh add your :ref:`Mesh <class_Mesh>` with the shader from above.

MultiMeshes draw your Mesh with three additional per-instance properties: Transform (rotation,
translation, scale), Color, and Custom. Custom is used to pass in 4 multi-use variables using
a :ref:`Color <class_Color>`.

``instance_count`` specifies how many instances of the mesh you want to draw. For now, leave
``instance_count`` at ``0`` because you cannot change any of the other parameters while
``instance_count`` is larger than ``0``. We will set ``instance count`` in GDScript later.

``transform_format`` specifies whether the transforms used are 3D or 2D. For this tutorial, select 3D.

For both ``color_format`` and ``custom_data_format`` you can choose between ``None``, ``Byte``, and
``Float``. ``None`` means you won't be passing in that data (either a per-instance ``COLOR`` variable,
or ``INSTANCE_CUSTOM``) to the shader. ``Byte`` means each number making up the color you pass in will
be stored with 8 bits while ``Float`` means each number will be stored in a floating-point number
(32 bits). ``Float`` is slower but more precise, ``Byte`` will take less memory and be faster, but you
may see some visual artifacts.

Now, set ``instance_count`` to the number of fish you want to have.

Next we need to set the per-instance transforms.

There are two ways to set per-instance transforms for MultiMeshes. The first is entirely in editor
and is described in the :ref:`MultiMeshInstance tutorial <doc_using_multi_mesh_instance>`.

The second is to loop over all the instances and set their transforms in code. Below, we use GDScript
to loop over all the instances and set their transform to a random position.

::

  for i in range($School.multimesh.instance_count):
    var position = Transform()
    position = position.translated(Vector3(randf() * 100 - 50, randf() * 50 - 25, randf() * 50 - 25))
    $School.multimesh.set_instance_transform(i, position)

Running this script will place the fish in random positions in a box around the position of the
MultiMeshInstance.

.. note:: If performance is an issue for you, try running the scene with GLES2 or with fewer fish.

Notice how all the fish are all in the same position in their swim cycle? It makes them look very
robotic. The next step is to give each fish a different position in the swim cycle so the entire
school looks more organic.

Animating a school of fish
--------------------------

One of the benefits of animating the fish using ``cos`` functions is that they are animated with
one parameter, ``time``. In order to give each fish a unique position in the
swim cycle, we only need to offset ``time``.

We do that by adding the per-instance custom value ``INSTANCE_CUSTOM`` to ``time``.

.. code-block:: glsl

  float time = (TIME * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);

Next, we need to pass a value into ``INSTANCE_CUSTOM``. We do that by adding one line into
the ``for`` loop from above. In the ``for`` loop we assign each instance a set of four
random floats to use.

::

  $School.multimesh.set_instance_custom_data(i, Color(randf(), randf(), randf(), randf()))

Now the fish all have unique positions in the swim cycle. You can give them a little more
individuality by using ``INSTANCE_CUSTOM`` to make them swim faster or slower by multiplying
by ``TIME``.

.. code-block:: glsl

  //set speed from 50% - 150% of regular speed
  float time = (TIME * (0.5 + INSTANCE_CUSTOM.y) * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);

You can even experiment with changing the per-instance color the same way you changed the per-instance
custom value.

One problem that you will run into at this point is that the fish are animated, but they are not
moving. You can move them by updating the per-instance transform for each fish every frame. Although
doing so will be faster than moving thousands of MeshInstances per frame, it'll still likely be
slow.

In the next tutorial we will cover how to use :ref:`Particles <class_Particles>` to take advantage
of the GPU and move each fish around individually while still receiving the benefits of instancing.


===================================================
/. ./tutorials/performance/vertex_animation/controlling_thousands_of_fish.rst
===================================================

.. _doc_controlling_thousands_of_fish:

Controlling thousands of fish with Particles
============================================

The problem with :ref:`MeshInstances <class_MeshInstance>` is that it is expensive to
update their transform array. It is great for placing many static objects around the
scene. But it is still difficult to move the objects around the scene.

To make each instance move in an interesting way, we will use a
:ref:`Particles <class_Particles>` node. Particles take advantage of GPU acceleration
by computing and setting the per-instance information in a :ref:`Shader <class_Shader>`.

.. note:: Particles are not available in GLES2, instead use :ref:`CPUParticles <class_CPUParticles>`,
          which do the same thing as Particles, but do not benefit from GPU acceleration.

First create a Particles node. Then, under "Draw Passes" set the Particle's "Draw Pass 1" to your
:ref:`Mesh <class_Mesh>`. Then under "Process Material" create a new
:ref:`ShaderMaterial <class_ShaderMaterial>`.

Set the ``shader_type`` to ``particles``.

.. code-block:: glsl

  shader_type particles

Then add the following two functions:

.. code-block:: glsl

  float rand_from_seed(in uint seed) {
    int k;
    int s = int(seed);
    if (s == 0)
      s = 305420679;
    k = s / 127773;
    s = 16807 * (s - k * 127773) - 2836 * k;
    if (s < 0)
      s += 2147483647;
    seed = uint(s);
    return float(seed % uint(65536)) / 65535.0;
  }

  uint hash(uint x) {
    x = ((x >> uint(16)) ^ x) * uint(73244475);
    x = ((x >> uint(16)) ^ x) * uint(73244475);
    x = (x >> uint(16)) ^ x;
    return x;
  }

These functions come from the default :ref:`ParticlesMaterial <class_ParticlesMaterial>`.
They are used to generate a random number from each particle's ``RANDOM_SEED``.

A unique thing about particle shaders is that some built-in variables are saved across frames.
``TRANSFORM``, ``COLOR``, and ``CUSTOM`` can all be accessed in the Spatial shader of the mesh, and
also in the particle shader the next time it is run.

Next, setup your ``vertex`` function. Particles shaders only contain a vertex function
and no others.

First we will distinguish between code that needs to be run only when the particle system starts
and code that should always run. We want to give each fish a random position and a random animation
offset when the system is first run. To do so, we wrap that code in an ``if`` statement that checks the
built-in variable ``RESTART`` which becomes ``true`` for one frame when the particle system is restarted.

From a high level, this looks like:

.. code-block:: glsl

  void vertex() {
    if (RESTART) {
      //Initialization code goes here
    } else {
      //per-frame code goes here
    }
  }

Next, we need to generate 4 random numbers: 3 to create a random position and one for the random
offset of the swim cycle.

First, generate 4 seeds inside the ``RESTART`` block using the ``hash`` function provided above:

.. code-block:: glsl

  uint alt_seed1 = hash(NUMBER + uint(1) + RANDOM_SEED);
  uint alt_seed2 = hash(NUMBER + uint(27) + RANDOM_SEED);
  uint alt_seed3 = hash(NUMBER + uint(43) + RANDOM_SEED);
  uint alt_seed4 = hash(NUMBER + uint(111) + RANDOM_SEED);

Then, use those seeds to generate random numbers using ``rand_from_seed``:

.. code-block:: glsl

  CUSTOM.x = rand_from_seed(alt_seed1);
  vec3 position = vec3(rand_from_seed(alt_seed2) * 2.0 - 1.0,
                       rand_from_seed(alt_seed3) * 2.0 - 1.0,
                       rand_from_seed(alt_seed4) * 2.0 - 1.0);

Finally, assign ``position`` to ``TRANSFORM[3].xyz``, which is the part of the transform that holds
the position information.

.. code-block:: glsl

  TRANSFORM[3].xyz = position * 20.0;

Remember, all this code so far goes inside the ``RESTART`` block.

The vertex shader for your mesh can stay the exact same as it was in the previous tutorial.

Now you can move each fish individually each frame, either by adding to the ``TRANSFORM`` directly
or by writing to ``VELOCITY``.

Let's transform the fish by setting their ``VELOCITY``.

.. code-block:: glsl

  VELOCITY.z = 10.0;

This is the most basic way to set ``VELOCITY`` every particle (or fish) will have the same velocity.

Just by setting ``VELOCITY`` you can make the fish swim however you want. For example, try the code
below.

.. code-block:: glsl

  VELOCITY.z = cos(TIME + CUSTOM.x * 6.28) * 4.0 + 6.0;

This will give each fish a unique speed between ``2`` and ``10``.

If you used ``CUSTOM.y`` in the last tutorial, you can also set the speed of the swim animation based
on the ``VELOCITY``. Just use ``CUSTOM.y``.

.. code-block:: glsl

  CUSTOM.y = VELOCITY.z * 0.1;

This code gives you the following behavior:

.. image:: img/scene.gif

Using a ParticlesMaterial you can make the fish behavior as simple or complex as you like. In this
tutorial we only set Velocity, but in your own Shaders you can also set ``COLOR``, rotation, scale
(through ``TRANSFORM``). Please refer to the :ref:`Particles Shader Reference <doc_particle_shader>`
for more information on particle shaders.


===================================================
/. ./tutorials/performance/threads/thread_safe_apis.rst
===================================================

.. _doc_thread_safe_apis:

Thread-safe APIs
================

Threads
-------

Threads are used to balance processing power across CPUs and cores.
Godot supports multithreading, but not in the whole engine.

Below is a list of ways multithreading can be used in different areas of Godot.

Global scope
------------

:ref:`Global Scope<class_@GlobalScope>` singletons are all thread-safe. Accessing servers from threads is supported (for VisualServer and Physics servers, ensure threaded or thread-safe operation is enabled in the project settings!).

This makes them ideal for code that creates dozens of thousands of instances in servers and controls them from threads. Of course, it requires a bit more code, as this is used directly and not within the scene tree.

Scene tree
----------

Interacting with the active scene tree is **NOT** thread-safe. Make sure to use mutexes when sending data between threads. If you want to call functions from a thread, the *call_deferred* function may be used:

::

    # Unsafe:
    node.add_child(child_node)
    # Safe:
    node.call_deferred("add_child", child_node)

However, creating scene chunks (nodes in tree arrangement) outside the active tree is fine. This way, parts of a scene can be built or instantiated in a thread, then added in the main thread:

::

    var enemy_scene = load("res://enemy_scene.scn")
    var enemy = enemy_scene.instance()
    enemy.add_child(weapon) # Set a weapon.
    world.call_deferred("add_child", enemy)

Still, this is only really useful if you have **one** thread loading data.
Attempting to load or create scene chunks from multiple threads may work, but you risk
resources (which are only loaded once in Godot) tweaked by the multiple
threads, resulting in unexpected behaviors or crashes.

Only use more than one thread to generate scene data if you *really* know what
you are doing and you are sure that a single resource is not being used or
set in multiple ones. Otherwise, you are safer just using the servers API
(which is fully thread-safe) directly and not touching scene or resources.

Rendering
---------

Instancing nodes that render anything in 2D or 3D (such as Sprite) is *not* thread-safe by default.
To make rendering thread-safe, set the **Rendering > Threads > Thread Model** project setting to **Multi-Threaded**.

Note that the Multi-Threaded thread model has several known bugs, so it may not be usable
in all scenarios.

GDScript arrays, dictionaries
-----------------------------

In GDScript, reading and writing elements from multiple threads is OK, but anything that changes the container size (resizing, adding or removing elements) requires locking a mutex.

Resources
---------

Modifying a unique resource from multiple threads is not supported. However handling references on multiple threads is supported, hence loading resources on a thread is as well - scenes, textures, meshes, etc - can be loaded and manipulated on a thread and then added to the active scene on the main thread. The limitation here is as described above, one must be careful not to load the same resource from multiple threads at once, therefore it is easiest to use **one** thread for loading and modifying resources, and then the main thread for adding them.


===================================================
/. ./tutorials/performance/threads/using_multiple_threads.rst
===================================================

.. _doc_using_multiple_threads:

Using multiple threads
======================

Threads
-------

Threads allow simultaneous execution of code. It allows off-loading work
from the main thread.

Godot supports threads and provides many handy functions to use them.

.. note:: If using other languages (C#, C++), it may be easier to use the
          threading classes they support.

.. warning::

    Before using a built-in class in a thread, read :ref:`doc_thread_safe_apis`
    first to check whether it can be safely used in a thread.

Creating a Thread
-----------------

Creating a thread is very simple, just use the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    var thread

    # The thread will start here.
    func _ready():
        thread = Thread.new()
        # Third argument is optional userdata, it can be any variable.
        thread.start(self, "_thread_function", "Wafflecopter")


    # Run here and exit.
    # The argument is the userdata passed from start().
    # If no argument was passed, this one still needs to
    # be here and it will be null.
    func _thread_function(userdata):
        # Print the userdata ("Wafflecopter")
        print("I'm a thread! Userdata is: ", userdata)

    # Thread must be disposed (or "joined"), for portability.
    func _exit_tree():
        thread.wait_to_finish()

Your function will, then, run in a separate thread until it returns.
Even if the function has returned already, the thread must collect it, so call
:ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, which will
wait until the thread is done (if not done yet), then properly dispose of it.

Mutexes
-------

Accessing objects or data from multiple threads is not always supported (if you
do it, it will cause unexpected behaviors or crashes). Read the
:ref:`doc_thread_safe_apis` documentation to understand which engine APIs
support multiple thread access.

When processing your own data or calling your own functions, as a rule, try to
avoid accessing the same data directly from different threads. You may run into
synchronization problems, as the data is not always updated between CPU cores
when modified. Always use a :ref:`Mutex<class_Mutex>` when accessing
a piece of data from different threads.

When calling :ref:`Mutex.lock()<class_Mutex_method_lock>`, a thread ensures that
all other threads will be blocked (put on suspended state) if they try to *lock*
the same mutex. When the mutex is unlocked by calling
:ref:`Mutex.unlock()<class_Mutex_method_unlock>`, the other threads will be
allowed to proceed with the lock (but only one at a time).

Here is an example of using a Mutex:

.. tabs::
 .. code-tab:: gdscript GDScript

    var counter = 0
    var mutex
    var thread


    # The thread will start here.
    func _ready():
        mutex = Mutex.new()
        thread = Thread.new()
        thread.start(self, "_thread_function")

        # Increase value, protect it with Mutex.
        mutex.lock()
        counter += 1
        mutex.unlock()


    # Increment the value from the thread, too.
    func _thread_function(userdata):
        mutex.lock()
        counter += 1
        mutex.unlock()


    # Thread must be disposed (or "joined"), for portability.
    func _exit_tree():
        thread.wait_to_finish()
        print("Counter is: ", counter) # Should be 2.

Semaphores
----------

Sometimes you want your thread to work *"on demand"*. In other words, tell it
when to work and let it suspend when it isn't doing anything.
For this, :ref:`Semaphores<class_Semaphore>` are used. The function
:ref:`Semaphore.wait()<class_Semaphore_method_wait>` is used in the thread to
suspend it until some data arrives.

The main thread, instead, uses
:ref:`Semaphore.post()<class_Semaphore_method_post>` to signal that data is
ready to be processed:

.. tabs::
 .. code-tab:: gdscript GDScript

    var counter = 0
    var mutex
    var semaphore
    var thread
    var exit_thread = false


    # The thread will start here.
    func _ready():
        mutex = Mutex.new()
        semaphore = Semaphore.new()
        exit_thread = false

        thread = Thread.new()
        thread.start(self, "_thread_function")


    func _thread_function(userdata):
        while true:
            semaphore.wait() # Wait until posted.

            mutex.lock()
            var should_exit = exit_thread # Protect with Mutex.
            mutex.unlock()

            if should_exit:
                break

            mutex.lock()
            counter += 1 # Increment counter, protect with Mutex.
            mutex.unlock()


    func increment_counter():
        semaphore.post() # Make the thread process.


    func get_counter():
        mutex.lock()
        # Copy counter, protect with Mutex.
        var counter_value = counter
        mutex.unlock()
        return counter_value


    # Thread must be disposed (or "joined"), for portability.
    func _exit_tree():
        # Set exit condition to true.
        mutex.lock()
        exit_thread = true # Protect with Mutex.
        mutex.unlock()

        # Unblock by posting.
        semaphore.post()

        # Wait until it exits.
        thread.wait_to_finish()

        # Print the counter.
        print("Counter is: ", counter)


===================================================
/. ./tutorials/physics/index.rst
===================================================

Physics
=======

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-physics

   physics_introduction
   rigid_body
   using_area_2d
   using_kinematic_body_2d
   ray-casting
   ragdoll_system
   kinematic_character_2d
   soft_body
   collision_shapes_3d
   interpolation/index


===================================================
/. ./tutorials/physics/physics_introduction.rst
===================================================

.. _doc_physics_introduction:

Physics introduction
====================

In game development, you often need to know when two objects in the game
intersect or come into contact. This is known as **collision detection**.
When a collision is detected, you typically want something to happen. This
is known as **collision response**.

Godot offers a number of collision objects in 2D and 3D to provide both collision detection
and response. Trying to decide which one to use for your project can be confusing.
You can avoid problems and simplify development if you understand how each works
and what their pros and cons are.

In this guide, you will learn:

-   Godot's four collision object types
-   How each collision object works
-   When and why to choose one type over another

.. note:: This document's examples will use 2D objects. Every 2D physics object
          and collision shape has a direct equivalent in 3D and in most cases
          they work in much the same way.

Collision objects
-----------------

Godot offers four kinds of physics bodies, extending :ref:`CollisionObject2D <class_CollisionObject2D>`:

- :ref:`Area2D <class_Area2D>`
    ``Area2D`` nodes provide **detection** and **influence**. They can detect when
    objects overlap and can emit signals when bodies enter or exit. An ``Area2D``
    can also be used to override physics properties, such as gravity or damping,
    in a defined area.

The other three bodies extend :ref:`PhysicsBody2D <class_PhysicsBody2D>`:

- :ref:`StaticBody2D <class_StaticBody2D>`
    A static body is one that is not moved by the physics engine. It participates
    in collision detection, but does not move in response to the collision. They
    are most often used for objects that are part of the environment or that do
    not need to have any dynamic behavior.

- :ref:`RigidBody2D <class_RigidBody2D>`
    This is the node that implements simulated 2D physics. You do not control a
    ``RigidBody2D`` directly, but instead you apply forces to it (gravity, impulses,
    etc.) and the physics engine calculates the resulting movement. :ref:`Read more about using rigid bodies. <doc_rigid_body>`

- :ref:`KinematicBody2D <class_KinematicBody2D>`
    A body that provides collision detection, but no physics. All movement and
    collision response must be implemented in code.

Physics material
~~~~~~~~~~~~~~~~

Static bodies and rigid bodies can be configured to use a :ref:`physics material
<class_PhysicsMaterial>`. This allows adjusting the friction and bounce of an object,
and set if it's absorbent and/or rough.

Collision shapes
~~~~~~~~~~~~~~~~

A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects
as children. These shapes are used to define the object's collision bounds
and to detect contact with other objects.

.. note:: In order to detect collisions, at least one ``Shape2D`` must be
          assigned to the object.

The most common way to assign a shape is by adding a :ref:`CollisionShape2D <class_CollisionShape2D>`
or :ref:`CollisionPolygon2D <class_CollisionPolygon2D>` as a child of the object.
These nodes allow you to draw the shape directly in the editor workspace.

.. important:: Be careful to never scale your collision shapes in the editor.
                The "Scale" property in the Inspector should remain ``(1, 1)``. When changing
                the size of the collision shape, you should always use the size handles, **not**
                the ``Node2D`` scale handles. Scaling a shape can result in unexpected
                collision behavior.

.. image:: img/player_coll_shape.png

Physics process callback
~~~~~~~~~~~~~~~~~~~~~~~~

The physics engine may spawn multiple threads to improve performance, so
it can use up to a full frame to process physics. Because of this, the value
of a body's state variables such as ``position`` or ``linear velocity``
may not be accurate for the current frame.

In order to avoid this inaccuracy, any code that needs to access a body's properties should
be run in the :ref:`Node._physics_process() <class_Node_method__physics_process>`
callback, which is called before each physics step at a constant frame rate
(60 times per second by default). This method will be passed a ``delta``
parameter, which is a floating-point number equal to the time passed in
*seconds* since the last step. When using the default 60 Hz physics update rate,
it will typically be equal to ``0.01666...`` (but not always, see below).

.. note::

    It's recommended to always use the ``delta`` parameter when relevant in your
    physics calculations, so that the game behaves correctly if you change the
    physics update rate or if the player's device can't keep up.

.. _doc_physics_introduction_collision_layers_and_masks:

Collision layers and masks
~~~~~~~~~~~~~~~~~~~~~~~~~~

One of the most powerful, but frequently misunderstood, collision features
is the collision layer system. This system allows you to build up complex
interactions between a variety of objects. The key concepts are **layers**
and **masks**. Each ``CollisionObject2D`` has 20 different physics layers
it can interact with.

Let's look at each of the properties in turn:

- collision_layer
    This describes the layers that the object appears **in**. By default, all
    bodies are on layer ``1``.

- collision_mask
    This describes what layers the body will **scan** for collisions. If an
    object isn't in one of the mask layers, the body will ignore it. By default,
    all bodies scan layer ``1``.

These properties can be configured via code, or by editing them in the Inspector.

Keeping track of what you're using each layer for can be difficult, so you
may find it useful to assign names to the layers you're using. Names can
be assigned in Project Settings -> Layer Names.

.. image:: img/physics_layer_names.png

GUI example
^^^^^^^^^^^

You have four node types in your game: Walls, Player, Enemy, and Coin. Both
Player and Enemy should collide with Walls. The Player node should detect
collisions with both Enemy and Coin, but Enemy and Coin should ignore each
other.

Start by naming layers 1-4 "walls", "player", "enemies", and "coins" and
place each node type in its respective layer using the "Layer" property.
Then set each node's "Mask" property by selecting the layers it should
interact with. For example, the Player's settings would look like this:

.. image:: img/player_collision_layers.png
.. image:: img/player_collision_mask.png

.. _doc_physics_introduction_collision_layer_code_example:

Code example
^^^^^^^^^^^^

In function calls, layers are specified as a bitmask. Where a function enables
all layers by default, the layer mask will be given as ``0x7fffffff``. Your code
can use binary, hexadecimal, or decimal notation for layer masks, depending
on your preference.

The code equivalent of the above example where layers 1, 3 and 4 were enabled
would be as follows::

    # Example: Setting mask value for enabling layers 1, 3 and 4

    # Binary - set the bit corresponding to the layers you want to enable (1, 3, and 4) to 1, set all other bits to 0.
    # Note: Layer 20 is the first bit, layer 1 is the last. The mask for layers 4,3 and 1 is therefore
    0b00000000000000001101
    # (This can be shortened to 0b1101)

    # Hexadecimal equivalent (1101 binary converted to hexadecimal)
    0x000d
    # (This value can be shortened to 0xd)

    # Decimal - Add the results of 2 to the power of (layer to be enabled - 1).
    # (2^(1-1)) + (2^(3-1)) + (2^(4-1)) = 1 + 4 + 8 = 13
    pow(2, 1) + pow(2, 3) + pow(2, 4)


Area2D
------

Area nodes provide **detection** and **influence**. They can detect when
objects overlap and emit signals when bodies enter or exit. Areas can also
be used to override physics properties, such as gravity or damping, in a
defined area.

There are three main uses for :ref:`Area2D <class_Area2D>`:

- Overriding physics parameters (such as gravity) in a given region.

- Detecting when other bodies enter or exit a region or what bodies are currently in a region.

- Checking other areas for overlap.

By default, areas also receive mouse and touchscreen input.

StaticBody2D
------------

A static body is one that is not moved by the physics engine. It participates
in collision detection, but does not move in response to the collision. However,
it can impart motion or rotation to a colliding body **as if** it were moving,
using its ``constant_linear_velocity`` and ``constant_angular_velocity`` properties.

``StaticBody2D`` nodes are most often used for objects that are part of the environment
or that do not need to have any dynamic behavior.

Example uses for ``StaticBody2D``:

-   Platforms (including moving platforms)
-   Conveyor belts
-   Walls and other obstacles

RigidBody2D
-----------

This is the node that implements simulated 2D physics. You do not control a
:ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces
to it and the physics engine calculates the resulting movement, including
collisions with other bodies, and collision responses, such as bouncing,
rotating, etc.

You can modify a rigid body's behavior via properties such as "Mass",
"Friction", or "Bounce", which can be set in the Inspector.

The body's behavior is also affected by the world's properties, as set in
`Project Settings -> Physics`, or by entering an :ref:`Area2D <class_Area2D>`
that is overriding the global physics properties.

When a rigid body is at rest and hasn't moved for a while, it goes to sleep.
A sleeping body acts like a static body, and its forces are not calculated by
the physics engine. The body will wake up when forces are applied, either by
a collision or via code.

Rigid body modes
~~~~~~~~~~~~~~~~

A rigid body can be set to one of four modes:

-   **Rigid** - The body behaves as a physical object. It collides with other bodies and responds to forces applied to it. This is the default mode.
-   **Static** - The body behaves like a :ref:`StaticBody2D <class_StaticBody2D>` and does not move.
-   **Character** - Similar to "Rigid" mode, but the body cannot rotate.
-   **Kinematic** - The body behaves like a :ref:`KinematicBody2D <class_KinematicBody2D>` and must be moved by code.

Using RigidBody2D
~~~~~~~~~~~~~~~~~

One of the benefits of using a rigid body is that a lot of behavior can be had
"for free" without writing any code. For example, if you were making an
"Angry Birds"-style game with falling blocks, you would only need to create
RigidBody2Ds and adjust their properties. Stacking, falling, and bouncing would
automatically be calculated by the physics engine.

However, if you do wish to have some control over the body, you should take
care - altering the ``position``, ``linear_velocity``, or other physics properties
of a rigid body can result in unexpected behavior. If you need to alter any
of the physics-related properties, you should use the :ref:`_integrate_forces() <class_RigidBody2D_method__integrate_forces>`
callback instead of ``_physics_process()``. In this callback, you have access
to the body's :ref:`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`,
which allows for safely changing properties and synchronizing them with
the physics engine.

For example, here is the code for an "Asteroids" style spaceship:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends RigidBody2D

    var thrust = Vector2(0, 250)
    var torque = 20000

    func _integrate_forces(state):
        if Input.is_action_pressed("ui_up"):
            applied_force = thrust.rotated(rotation)
        else:
            applied_force = Vector2()
        var rotation_dir = 0
        if Input.is_action_pressed("ui_right"):
            rotation_dir += 1
        if Input.is_action_pressed("ui_left"):
            rotation_dir -= 1
        applied_torque = rotation_dir * torque

 .. code-tab:: csharp

    class Spaceship : RigidBody2D
    {
        private Vector2 _thrust = new Vector2(0, 250);
        private float _torque = 20000;

        public override void _IntegrateForces(Physics2DDirectBodyState state)
        {
            if (Input.IsActionPressed("ui_up"))
                AppliedForce = _thrust.Rotated(Rotation);
            else
                AppliedForce = new Vector2();

            var rotationDir = 0;
            if (Input.IsActionPressed("ui_right"))
                rotationDir += 1;
            if (Input.IsActionPressed("ui_left"))
                rotationDir -= 1;
            AppliedTorque = rotationDir * _torque;
        }
    }

Note that we are not setting the ``linear_velocity`` or ``angular_velocity``
properties directly, but rather applying forces (``thrust`` and ``torque``) to
the body and letting the physics engine calculate the resulting movement.

.. note:: When a rigid body goes to sleep, the ``_integrate_forces()``
          function will not be called. To override this behavior, you will
          need to keep the body awake by creating a collision, applying a
          force to it, or by disabling the :ref:`can_sleep <class_RigidBody2D_property_can_sleep>`
          property. Be aware that this can have a negative effect on performance.

Contact reporting
~~~~~~~~~~~~~~~~~

By default, rigid bodies do not keep track of contacts, because this can
require a huge amount of memory if many bodies are in the scene. To enable
contact reporting, set the :ref:`contacts_reported <class_RigidBody2D_property_contacts_reported>`
property to a non-zero value. The contacts can then be obtained via
:ref:`Physics2DDirectBodyState.get_contact_count() <class_Physics2DDirectBodyState_method_get_contact_count>`
and related functions.

Contact monitoring via signals can be enabled via the :ref:`contact_monitor <class_RigidBody2D_property_contact_monitor>`
property. See :ref:`RigidBody2D <class_RigidBody2D>` for the list of available
signals.

KinematicBody2D
---------------

:ref:`KinematicBody2D <class_KinematicBody2D>` bodies detect collisions with
other bodies, but are not affected by physics properties like gravity or friction.
Instead, they must be controlled by the user via code. The physics engine will
not move a kinematic body.

When moving a kinematic body, you should not set its ``position`` directly.
Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods.
These methods move the body along a given vector, and it will instantly stop
if a collision is detected with another body. After the body has collided,
any collision response must be coded manually.

Kinematic collision response
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After a collision, you may want the body to bounce, to slide along a wall,
or to alter the properties of the object it hit. The way you handle collision
response depends on which method you used to move the KinematicBody2D.

:ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When using ``move_and_collide()``, the function returns a
:ref:`KinematicCollision2D <class_KinematicCollision2D>` object, which contains
information about the collision and the colliding body. You can use this
information to determine the response.

For example, if you want to find the point in space where the collision
occurred:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    var velocity = Vector2(250, 250)

    func _physics_process(delta):
        var collision_info = move_and_collide(velocity * delta)
        if collision_info:
            var collision_point = collision_info.position

 .. code-tab:: csharp

    class Body : KinematicBody2D
    {
        private Vector2 _velocity = new Vector2(250, 250);

        public override void _PhysicsProcess(float delta)
        {
            var collisionInfo = MoveAndCollide(_velocity * delta);
            if (collisionInfo != null)
            {
                var collisionPoint = collisionInfo.GetPosition();
            }
        }
    }

Or to bounce off of the colliding object:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    var velocity = Vector2(250, 250)

    func _physics_process(delta):
        var collision_info = move_and_collide(velocity * delta)
        if collision_info:
            velocity = velocity.bounce(collision_info.normal)

 .. code-tab:: csharp

    class Body : KinematicBody2D
    {
        private Vector2 _velocity = new Vector2(250, 250);

        public override void _PhysicsProcess(float delta)
        {
            var collisionInfo = MoveAndCollide(_velocity * delta);
            if (collisionInfo != null)
                _velocity = _velocity.Bounce(collisionInfo.Normal);
        }
    }

:ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sliding is a common collision response; imagine a player moving along walls
in a top-down game or running up and down slopes in a platformer. While it's
possible to code this response yourself after using ``move_and_collide()``,
``move_and_slide()`` provides a convenient way to implement sliding movement
without writing much code.

.. warning:: ``move_and_slide()`` automatically includes the timestep in its
             calculation, so you should **not** multiply the velocity vector
             by ``delta``.

For example, use the following code to make a character that can walk along
the ground (including slopes) and jump when standing on the ground:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    var run_speed = 350
    var jump_speed = -1000
    var gravity = 2500

    var velocity = Vector2()

    func get_input():
        velocity.x = 0
        var right = Input.is_action_pressed('ui_right')
        var left = Input.is_action_pressed('ui_left')
        var jump = Input.is_action_just_pressed('ui_select')

        if is_on_floor() and jump:
            velocity.y = jump_speed
        if right:
            velocity.x += run_speed
        if left:
            velocity.x -= run_speed

    func _physics_process(delta):
        velocity.y += gravity * delta
        get_input()
        velocity = move_and_slide(velocity, Vector2(0, -1))

 .. code-tab:: csharp

    class Body : KinematicBody2D
    {
        private float _runSpeed = 350;
        private float _jumpSpeed = -1000;
        private float _gravity = 2500;

        private Vector2 _velocity = new Vector2();

        private void GetInput()
        {
            _velocity.x = 0;

            var right = Input.IsActionPressed("ui_right");
            var left = Input.IsActionPressed("ui_left");
            var jump = Input.IsActionPressed("ui_select");

            if (IsOnFloor() && jump)
                _velocity.y = _jumpSpeed;
            if (right)
                _velocity.x += _runSpeed;
            if (left)
                _velocity.x -= _runSpeed;
        }

        public override void _PhysicsProcess(float delta)
        {
            _velocity.y += _gravity * delta;
            GetInput();
            _velocity = MoveAndSlide(_velocity, new Vector2(0,-1));
        }
    }


See :ref:`doc_kinematic_character_2d` for more details on using ``move_and_slide()``,
including a demo project with detailed code.


===================================================
/. ./tutorials/physics/rigid_body.rst
===================================================

.. _doc_rigid_body:

Using RigidBody
===============

What is a rigid body?
---------------------

A rigid body is one that is directly controlled by the physics engine in order to simulate the behavior of physical objects.
In order to define the shape of the body, it must have one or more :ref:`Shape <class_Shape>` objects assigned. Note that setting the position of these shapes will affect the body's center of mass.

How to control a rigid body
---------------------------

A rigid body's behavior can be altered by setting its properties, such as mass and weight.
A physics material needs to be added to the rigid body to adjust its friction and bounce,
and set if it's absorbent and/or rough. These properties can be set in the Inspector or via code.
See :ref:`RigidBody <class_RigidBody>` and :ref:`PhysicsMaterial <class_PhysicsMaterial>` for
the full list of properties and their effects.

There are several ways to control a rigid body's movement, depending on your desired application.

If you only need to place a rigid body once, for example to set its initial location, you can use the methods provided by the :ref:`Spatial <class_Spatial>` node, such as ``set_global_transform()`` or ``look_at()``. However, these methods cannot be called every frame or the physics engine will not be able to correctly simulate the body's state.
As an example, consider a rigid body that you want to rotate so that it points towards another object. A common mistake when implementing this kind of behavior is to use ``look_at()`` every frame, which breaks the physics simulation. Below, we'll demonstrate how to implement this correctly.

The fact that you can't use ``set_global_transform()`` or ``look_at()`` methods doesn't mean that you can't have full control of a rigid body. Instead, you can control it by using the ``_integrate_forces()`` callback. In this method, you can add *forces*, apply *impulses*, or set the *velocity* in order to achieve any movement you desire.

The "look at" method
--------------------

As described above, using the Spatial node's ``look_at()`` method can't be used each frame to follow a target.
Here is a custom ``look_at()`` method that will work reliably with rigid bodies:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends RigidBody

    func look_follow(state, current_transform, target_position):
        var up_dir = Vector3(0, 1, 0)
        var cur_dir = current_transform.basis.xform(Vector3(0, 0, 1))
        var target_dir = (target_position - current_transform.origin).normalized()
        var rotation_angle = acos(cur_dir.x) - acos(target_dir.x)

        state.set_angular_velocity(up_dir * (rotation_angle / state.get_step()))

    func _integrate_forces(state):
        var target_position = $my_target_spatial_node.get_global_transform().origin
        look_follow(state, get_global_transform(), target_position)

 .. code-tab:: csharp

    class Body : RigidBody
    {
        private void LookFollow(PhysicsDirectBodyState state, Transform currentTransform, Vector3 targetPosition)
        {
            var upDir = new Vector3(0, 1, 0);
            var curDir = currentTransform.basis.Xform(new Vector3(0, 0, 1));
            var targetDir = (targetPosition - currentTransform.origin).Normalized();
            var rotationAngle = Mathf.Acos(curDir.x) - Mathf.Acos(targetDir.x);

            state.SetAngularVelocity(upDir * (rotationAngle / state.GetStep()));
        }

        public override void _IntegrateForces(PhysicsDirectBodyState state)
        {
            var targetPosition = GetNode<Spatial>("my_target_spatial_node").GetGlobalTransform().origin;
            LookFollow(state, GetGlobalTransform(), targetPosition);
        }
    }


This method uses the rigid body's ``set_angular_velocity()`` method to rotate the body. It first calculates the difference between the current and desired angle and then adds the velocity needed to rotate by that amount in one frame's time.

.. note:: This script will not work with rigid bodies in *character mode* because then, the body's rotation is locked. In that case, you would have to rotate the attached mesh node instead using the standard Spatial methods.


===================================================
/. ./tutorials/physics/using_area_2d.rst
===================================================

.. _doc_using_area_2d:

Using Area2D
============

Introduction
------------

Godot offers a number of collision objects to provide both collision detection
and response. Trying to decide which one to use for your project can be confusing.
You can avoid problems and simplify development if you understand how each of them
works and what their pros and cons are. In this tutorial, we'll look at the
:ref:`Area2D <class_Area2D>` node and show some examples of how it can be used.

.. note:: This document assumes you're familiar with Godot's various physics
          bodies. Please read :ref:`doc_physics_introduction` first.

What is an area?
----------------

An Area2D defines a region of 2D space. In this space you can detect other
:ref:`CollisionObject2D <class_CollisionObject2D>` nodes overlapping, entering,
and exiting. Areas also allow for overriding local physics properties. We'll
explore each of these functions below.

Area properties
---------------

Areas have many properties you can use to customize their behavior.

.. image:: img/area2d_properties.png

The first eight properties are used to configure the area's physics override
behavior. We'll look at how to use those in the section below.

*Monitoring* and *Monitorable* are used to enable and disable the area.

The "Collision" section is where you configure the area's collision layer(s)
and mask(s).

The "Audio Bus" section allows you to override audio in the area, for example to
apply an audio effect when the player moves through.

Note that Area2D extends :ref:`CollisionObject2D <class_CollisionObject2D>`, so it
also provides properties inherited from that class, such as ``input_pickable``.

Overlap detection
-----------------

Perhaps the most common use of Area2D nodes is for contact and overlap detection.
When you need to know that two objects have touched, but don't need physical
collision, you can use an area to notify you of the contact.

For example, let's say we're making a coin for the player to pick up. The coin is
not a solid object - the player can't stand on it or push it - we just want it
to disappear when the player touches it.

Here's the node setup for the coin:

.. image:: img/area2d_coin_nodes.png

To detect the overlap, we'll connect the appropriate signal on the Area2d. Which
signal to use depends on the player's node type. If the player is another area,
use ``area_entered``. However, let's assume our player is a ``KinematicBody2D``
(and therefore a ``CollisionObject2D`` type), so we'll connect the
``body_entered`` signal.

.. note:: If you're not familiar with using signals, see :ref:`doc_signals` for
          an introduction.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Area2D

    func _on_Coin_body_entered(body):
        queue_free()

 .. code-tab:: csharp

    public class Coin : Area2D
    {

        public void OnCoinBodyEntered(PhysicsBody2D body)
        {
            QueueFree();
        }
    }

Now our player can collect the coins!

Some other usage examples:

- Areas are great for bullets and other projectiles that hit and deal damage, but don't need any other physics such as bouncing.
- Use a large circular area around an enemy to define its "detect" radius. When the player is outside the area, the enemy can't "see" it.
- "Security cameras" - In a large level with multiple cameras, attach areas to each camera and activate them when the player enters.

See the :ref:`doc_your_first_2d_game` for an example of using Area2D in a game.

Area influence
--------------

The second major use for area nodes is to alter physics. By default, the area
won't do this, but you can enable this with the *Space Override* property. When
areas overlap, they are processed in *Priority* order (higher priority areas are
processed first). There are four options for override:

- *Combine* - The area adds its values to what has been calculated so far.
- *Replace* - The area replaces physics properties, and lower priority areas are ignored.
- *Combine-Replace* - The area adds its gravity/damping values to whatever has been calculated so far (in priority order), ignoring any lower priority areas.
- *Replace-Combine* - The area replaces any gravity/damping calculated so far, but keeps calculating the rest of the areas.

Using these properties, you can create very complex behavior with multiple
overlapping areas.

The physics properties that can be overridden are:

- *Gravity* - Gravity's strength inside the area.
- *Gravity Vec* - Gravity's direction. This vector does not need to be normalized.
- *Linear Damp* - How quickly objects stop moving - linear velocity lost per second.
- *Angular Damp* - How quickly objects stop spinning - angular velocity lost per second.

Point gravity
~~~~~~~~~~~~~

The *Gravity Point* property allows you to create an "attractor". Gravity in the
area will be calculated towards a point, given by the *Gravity Vec* property.
Values are relative to the Area2D, so for example using ``(0, 0)`` will attract
objects to the center of the area.

Examples
~~~~~~~~

The example project attached below has three areas demonstrating physics
override.

.. image:: img/area2d_override.gif

You can download this project here:
:download:`using_area_2d.zip <files/using_area_2d.zip>`


===================================================
/. ./tutorials/physics/using_kinematic_body_2d.rst
===================================================

.. _doc_using_kinematic_body_2d:

Using KinematicBody2D
=====================

Introduction
------------

Godot offers several collision objects to provide both collision detection
and response. Trying to decide which one to use for your project can be confusing.
You can avoid problems and simplify development if you understand how each of them
works and what their pros and cons are. In this tutorial, we'll look at the
:ref:`KinematicBody2D <class_KinematicBody2D>` node and show some examples
of how to use it.

.. note:: This document assumes you're familiar with Godot's various physics
          bodies. Please read :ref:`doc_physics_introduction` first.

What is a kinematic body?
-------------------------

``KinematicBody2D`` is for implementing bodies that are controlled via code.
Kinematic bodies detect collisions with other bodies when moving, but are not affected by
engine physics properties, like gravity or friction. While this means that you
have to write some code to create their behavior, it also means you have more
precise control over how they move and react.

.. tip:: A `KinematicBody2D` can be affected by gravity and other forces,
        but you must calculate the movement in code. The physics engine will
        not move a `KinematicBody2D`.

Movement and collision
----------------------

When moving a ``KinematicBody2D``, you should not set its ``position`` property
directly. Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods.
These methods move the body along a given vector and instantly stop if
a collision is detected with another body. After a KinematicBody2D has collided,
any *collision response* must be coded manually.

.. warning:: You should only do Kinematic body movement in the ``_physics_process()`` callback.

The two movement methods serve different purposes, and later in this tutorial, you'll
see examples of how they work.

``move_and_collide``
~~~~~~~~~~~~~~~~~~~~

This method takes one parameter: a :ref:`Vector2 <class_Vector2>` indicating the body's
relative movement. Typically, this is your velocity vector multiplied by the
frame timestep (``delta``). If the engine detects a collision anywhere along
this vector, the body will immediately stop moving. If this happens, the
method will return a :ref:`KinematicCollision2D <class_KinematicCollision2D>` object.

``KinematicCollision2D`` is an object containing data about the collision
and the colliding object. Using this data, you can calculate your collision
response.

``move_and_slide``
~~~~~~~~~~~~~~~~~~

The ``move_and_slide()`` method is intended to simplify the collision
response in the common case where you want one body to slide along the other.
It is especially useful in platformers or top-down games, for example.

.. tip:: ``move_and_slide()`` automatically calculates frame-based movement
         using ``delta``. Do *not* multiply your velocity vector by ``delta``
         before passing it to ``move_and_slide()``.

In addition to the velocity vector, ``move_and_slide()`` takes a number of
other parameters allowing you to customize the slide behavior:

- ``up_direction`` - *default value:* ``Vector2( 0, 0 )``

    This parameter allows you to define what surfaces the engine should consider
    being the floor. Setting this lets you use the ``is_on_floor()``, ``is_on_wall()``,
    and ``is_on_ceiling()`` methods to detect what type of surface the body is
    in contact with. The default value means that all surfaces are considered walls.

- ``stop_on_slope`` - *default value:* ``false``

    This parameter prevents a body from sliding down slopes when standing still.

- ``max_slides`` - *default value:* ``4``

    This parameter is the maximum number of collisions before the body stops moving. Setting
    it too low may prevent movement entirely.

- ``floor_max_angle`` - *default value:* ``0.785398`` (in radians, equivalent to ``45`` degrees)

    This parameter is the maximum angle before a surface is no longer considered a "floor."

- ``infinite_inertia`` - *default value:* ``true``

When this parameter is ``true``, the body can push :ref:`RigidBody2D <class_RigidBody2D>`
nodes, ignoring their mass, but won't detect collisions with them. If it's ``false``
the body will collide with rigid bodies and stop.

``move_and_slide_with_snap``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This method adds some additional functionality to ``move_and_slide()`` by adding
the ``snap`` parameter. As long as this vector is in contact with the ground, the
body will remain attached to the surface. Note that this means you must disable
snapping when jumping, for example. You can do this either by setting ``snap``
to ``Vector2.ZERO`` or by using ``move_and_slide()`` instead.


Detecting collisions
--------------------

When using ``move_and_collide()`` the function returns a ``KinematicCollision2D``
directly, and you can use this in your code.

When using ``move_and_slide()`` it's possible to have multiple collisions occur,
as the slide response is calculated. To process these collisions, use ``get_slide_count()``
and ``get_slide_collision()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Using move_and_collide.
    var collision = move_and_collide(velocity * delta)
    if collision:
        print("I collided with ", collision.collider.name)

    # Using move_and_slide.
    velocity = move_and_slide(velocity)
    for i in get_slide_count():
        var collision = get_slide_collision(i)
        print("I collided with ", collision.collider.name)
        
 .. code-tab:: csharp

    // Using MoveAndCollide.
    var collision = MoveAndCollide(velocity * delta);
    if (collision != null)
    {
        GD.Print("I collided with ", ((Node)collision.Collider).Name);
    }

    // Using MoveAndSlide.
    velocity = MoveAndSlide(velocity);
    for (int i = 0; i < GetSlideCount(); i++)
    {
        var collision = GetSlideCollision(i);
        GD.Print("I collided with ", ((Node)collision.Collider).Name);
    }

.. note:: `get_slide_count()` only counts times the body has collided and changed direction.      

See :ref:`KinematicCollision2D <class_KinematicCollision2D>` for details on what
collision data is returned.

Which movement method to use?
-----------------------------

A common question from new Godot users is: "How do you decide which movement
function to use?" Often, the response is to use ``move_and_slide()`` because
it's "simpler," but this is not necessarily the case. One way to think of it
is that ``move_and_slide()`` is a special case, and ``move_and_collide()``
is more general. For example, the following two code snippets result in
the same collision response:

.. image:: img/k2d_compare.gif

.. tabs::
 .. code-tab:: gdscript GDScript

    # using move_and_collide
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.slide(collision.normal)

    # using move_and_slide
    velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    // using MoveAndCollide
    var collision = MoveAndCollide(velocity * delta);
    if (collision != null)
    {
        velocity = velocity.Slide(collision.Normal);
    }
    // using MoveAndSlide
    velocity = MoveAndSlide(velocity);

Anything you do with ``move_and_slide()`` can also be done with ``move_and_collide()``,
but it might take a little more code. However, as we'll see in the examples below,
there are cases where ``move_and_slide()`` doesn't provide the response you want.

In the example above, we assign the velocity that ``move_and_slide()`` returns
back into the ``velocity`` variable. This is because when the character collides
with the environment, the function recalculates the speed internally to reflect
the slowdown.

For example, if your character fell on the floor, you don't want it to
accumulate vertical speed due to the effect of gravity. Instead, you want its
vertical speed to reset to zero.

``move_and_slide()`` may also recalculate the kinematic body's velocity several
times in a loop as, to produce a smooth motion, it moves the character and
collides up to five times by default. At the end of the process, the function
returns the character's new velocity that we can store in our ``velocity``
variable, and use on the next frame.

Examples
--------

To see these examples in action, download the sample project:
:download:`using_kinematic2d.zip <files/using_kinematic2d.zip>`.

Movement and walls
~~~~~~~~~~~~~~~~~~

If you've downloaded the sample project, this example is in "BasicMovement.tscn".

For this example, add a ``KinematicBody2D`` with two children: a ``Sprite`` and a
``CollisionShape2D``. Use the Godot "icon.png" as the Sprite's texture (drag it
from the Filesystem dock to the *Texture* property of the ``Sprite``). In the
``CollisionShape2D``'s *Shape* property, select "New RectangleShape2D" and
size the rectangle to fit over the sprite image.

.. note:: See :ref:`doc_2d_movement` for examples of implementing 2D movement schemes.

Attach a script to the KinematicBody2D and add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    var speed = 250
    var velocity = Vector2()

    func get_input():
        # Detect up/down/left/right keystate and only move when pressed.
        velocity = Vector2()
        if Input.is_action_pressed('ui_right'):
            velocity.x += 1
        if Input.is_action_pressed('ui_left'):
            velocity.x -= 1
        if Input.is_action_pressed('ui_down'):
            velocity.y += 1
        if Input.is_action_pressed('ui_up'):
            velocity.y -= 1
        velocity = velocity.normalized() * speed

    func _physics_process(delta):
        get_input()
        move_and_collide(velocity * delta)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class KBExample : KinematicBody2D
    {
        public int Speed = 250;
        private Vector2 _velocity = new Vector2();

        public void GetInput()
        {
            // Detect up/down/left/right keystate and only move when pressed
            _velocity = new Vector2();

            if (Input.IsActionPressed("ui_right"))
                _velocity.x += 1;

            if (Input.IsActionPressed("ui_left"))
                _velocity.x -= 1;

            if (Input.IsActionPressed("ui_down"))
                _velocity.y += 1;

            if (Input.IsActionPressed("ui_up"))
                _velocity.y -= 1;
            _velocity = _velocity.Normalized() * Speed;
        }

        public override void _PhysicsProcess(float delta)
        {
            GetInput();
            MoveAndCollide(_velocity * delta);
        }
    }


Run this scene and you'll see that ``move_and_collide()`` works as expected, moving
the body along the velocity vector. Now let's see what happens when you add
some obstacles. Add a :ref:`StaticBody2D <class_StaticBody2D>` with a
rectangular collision shape. For visibility, you can use a sprite, a
Polygon2D, or turn on "Visible Collision Shapes" from the "Debug" menu.

Run the scene again and try moving into the obstacle. You'll see that the ``KinematicBody2D``
can't penetrate the obstacle. However, try moving into the obstacle at an angle and
you'll find that the obstacle acts like glue - it feels like the body gets stuck.

This happens because there is no *collision response*. ``move_and_collide()`` stops
the body's movement when a collision occurs. We need to code whatever response we
want from the collision.

Try changing the function to ``move_and_slide(velocity)`` and running again.
Note that we removed ``delta`` from the velocity calculation.

``move_and_slide()`` provides a default collision response of sliding the body along the
collision object. This is useful for a great many game types, and may be all you need
to get the behavior you want.

Bouncing/reflecting
~~~~~~~~~~~~~~~~~~~

What if you don't want a sliding collision response? For this example ("BounceandCollide.tscn"
in the sample project), we have a character shooting bullets and we want the bullets to
bounce off the walls.

This example uses three scenes. The main scene contains the Player and Walls.
The Bullet and Wall are separate scenes so that they can be instanced.

The Player is controlled by the `w` and `s` keys for forward and back. Aiming
uses the mouse pointer. Here is the code for the Player, using ``move_and_slide()``:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    var Bullet = preload("res://Bullet.tscn")
    var speed = 200
    var velocity = Vector2()

    func get_input():
        # Add these actions in Project Settings -> Input Map.
        velocity = Vector2()
        if Input.is_action_pressed('backward'):
            velocity = Vector2(-speed/3, 0).rotated(rotation)
        if Input.is_action_pressed('forward'):
            velocity = Vector2(speed, 0).rotated(rotation)
        if Input.is_action_just_pressed('mouse_click'):
            shoot()

    func shoot():
        # "Muzzle" is a Position2D placed at the barrel of the gun.
        var b = Bullet.instance()
        b.start($Muzzle.global_position, rotation)
        get_parent().add_child(b)

    func _physics_process(delta):
        get_input()
        var dir = get_global_mouse_position() - global_position
        # Don't move if too close to the mouse pointer.
        if dir.length() > 5:
            rotation = dir.angle()
            velocity = move_and_slide(velocity)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class KBExample : KinematicBody2D
    {
        private PackedScene _bullet = (PackedScene)GD.Load("res://Bullet.tscn");
        public int Speed = 200;
        private Vector2 _velocity = new Vector2();

        public void GetInput()
        {
            // add these actions in Project Settings -> Input Map
            _velocity = new Vector2();
            if (Input.IsActionPressed("backward"))
            {
                _velocity = new Vector2(-Speed/3, 0).Rotated(Rotation);
            }
            if (Input.IsActionPressed("forward"))
            {
                _velocity = new Vector2(Speed, 0).Rotated(Rotation);
            }
            if (Input.IsActionPressed("mouse_click"))
            {
                Shoot();
            }
        }

        public void Shoot()
        {
            // "Muzzle" is a Position2D placed at the barrel of the gun
            var b = (Bullet)_bullet.Instance();
            b.Start(GetNode<Node2D>("Muzzle").GlobalPosition, Rotation);
            GetParent().AddChild(b);
        }

        public override void _PhysicsProcess(float delta)
        {
            GetInput();
            var dir = GetGlobalMousePosition() - GlobalPosition;
            // Don't move if too close to the mouse pointer
            if (dir.Length() > 5)
            {
                Rotation = dir.Angle();
                _velocity = MoveAndSlide(_velocity);
            }
        }
    }


And the code for the Bullet:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    var speed = 750
    var velocity = Vector2()

    func start(pos, dir):
        rotation = dir
        position = pos
        velocity = Vector2(speed, 0).rotated(rotation)

    func _physics_process(delta):
        var collision = move_and_collide(velocity * delta)
        if collision:
            velocity = velocity.bounce(collision.normal)
            if collision.collider.has_method("hit"):
                collision.collider.hit()

    func _on_VisibilityNotifier2D_screen_exited():
        queue_free()

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Bullet : KinematicBody2D
    {
        public int Speed = 750;
        private Vector2 _velocity = new Vector2();

        public void Start(Vector2 pos, float dir)
        {
            Rotation = dir;
            Position = pos;
            _velocity = new Vector2(speed, 0).Rotated(Rotation);
        }

        public override void _PhysicsProcess(float delta)
        {
            var collision = MoveAndCollide(_velocity * delta);
            if (collision != null)
            {
                _velocity = _velocity.Bounce(collision.Normal);
                if (collision.Collider.HasMethod("Hit"))
                {
                    collision.Collider.Call("Hit");
                }
            }
        }

        public void OnVisibilityNotifier2DScreenExited()
        {
            QueueFree();
        }
    }


The action happens in ``_physics_process()``. After using ``move_and_collide()``, if a
collision occurs, a ``KinematicCollision2D`` object is returned (otherwise, the return
is ``Nil``).

If there is a returned collision, we use the ``normal`` of the collision to reflect
the bullet's ``velocity`` with the ``Vector2.bounce()`` method.

If the colliding object (``collider``) has a ``hit`` method,
we also call it. In the example project, we've added a flashing color effect to
the Wall to demonstrate this.

.. image:: img/k2d_bullet_bounce.gif

Platformer movement
~~~~~~~~~~~~~~~~~~~

Let's try one more popular example: the 2D platformer. ``move_and_slide()``
is ideal for quickly getting a functional character controller up and running.
If you've downloaded the sample project, you can find this in "Platformer.tscn".

For this example, we'll assume you have a level made of ``StaticBody2D`` objects.
They can be any shape and size. In the sample project, we're using
:ref:`Polygon2D <class_Polygon2D>` to create the platform shapes.

Here's the code for the player body:


.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    export (int) var run_speed = 100
    export (int) var jump_speed = -400
    export (int) var gravity = 1200

    var velocity = Vector2()
    var jumping = false

    func get_input():
        velocity.x = 0
        var right = Input.is_action_pressed('ui_right')
        var left = Input.is_action_pressed('ui_left')
        var jump = Input.is_action_just_pressed('ui_select')

        if jump and is_on_floor():
            jumping = true
            velocity.y = jump_speed
        if right:
            velocity.x += run_speed
        if left:
            velocity.x -= run_speed

    func _physics_process(delta):
        get_input()
        velocity.y += gravity * delta
        if jumping and is_on_floor():
            jumping = false
        velocity = move_and_slide(velocity, Vector2(0, -1))

 .. code-tab:: csharp

    using Godot;
    using System;

    public class KBExample : KinematicBody2D
    {
        [Export] public int RunSpeed = 100;
        [Export] public int JumpSpeed = -400;
        [Export] public int Gravity = 1200;

        Vector2 velocity = new Vector2();
        bool jumping = false;

        public void GetInput()
        {
            velocity.x = 0;
            bool right = Input.IsActionPressed("ui_right");
            bool left = Input.IsActionPressed("ui_left");
            bool jump = Input.IsActionPressed("ui_select");

            if (jump && IsOnFloor())
            {
                jumping = true;
                velocity.y = JumpSpeed;
            }

            if (right)
                velocity.x += RunSpeed;
            if (left)
                velocity.x -= RunSpeed;
        }

        public override void _PhysicsProcess(float delta)
        {
            GetInput();
            velocity.y += Gravity * delta;
            if (jumping && IsOnFloor())
                jumping = false;
            velocity = MoveAndSlide(velocity, new Vector2(0, -1));
        }
    }

.. image:: img/k2d_platform.gif

When using ``move_and_slide()``, the function returns a vector representing the
movement that remained after the slide collision occurred. Setting that value back
to the character's ``velocity`` allows us to move up and down slopes smoothly. Try
removing ``velocity =`` and see what happens if you don't do this.

Also note that we've added ``Vector2(0, -1)`` as the floor normal. This vector points
straight upward. As a result, if the character collides with an object
that has this normal, it will be considered a floor.

Using the floor normal allows us to make jumping work, using ``is_on_floor()``.
This function will only return ``true`` after a ``move_and_slide()`` collision
where the colliding body's normal is within 45 degrees of the given floor
vector. You can control the maximum angle by setting ``floor_max_angle``.

This angle also allows you to implement other features like wall jumps using
``is_on_wall()``, for example.


===================================================
/. ./tutorials/physics/ray-casting.rst
===================================================

.. _doc_ray-casting:

Ray-casting
===========

Introduction
------------

One of the most common tasks in game development is casting a ray (or
custom shaped object) and checking what it hits. This enables complex
behaviors, AI, etc. to take place. This tutorial will explain how to
do this in 2D and 3D.

Godot stores all the low level game information in servers, while the
scene is just a frontend. As such, ray casting is generally a
lower-level task. For simple raycasts, node such as
:ref:`RayCast <class_RayCast>` and :ref:`RayCast2D <class_RayCast2D>`
will work, as they will return every frame what the result of a raycast
is.

Many times, though, ray-casting needs to be a more interactive process
so a way to do this by code must exist.

Space
-----

In the physics world, Godot stores all the low level collision and
physics information in a *space*. The current 2d space (for 2D Physics)
can be obtained by accessing
:ref:`CanvasItem.get_world_2d().space <class_CanvasItem_method_get_world_2d>`.
For 3D, it's :ref:`Spatial.get_world().space <class_Spatial_method_get_world>`.

The resulting space :ref:`RID <class_RID>` can be used in
:ref:`PhysicsServer <class_PhysicsServer>` and
:ref:`Physics2DServer <class_Physics2DServer>` respectively for 3D and 2D.

Accessing space
---------------

Godot physics runs by default in the same thread as game logic, but may
be set to run on a separate thread to work more efficiently. Due to
this, the only time accessing space is safe is during the
:ref:`Node._physics_process() <class_Node_method__physics_process>`
callback. Accessing it from outside this function may result in an error
due to space being *locked*.

To perform queries into physics space, the
:ref:`Physics2DDirectSpaceState <class_Physics2DDirectSpaceState>`
and :ref:`PhysicsDirectSpaceState <class_PhysicsDirectSpaceState>`
must be used.

Use the following code in 2D:

.. tabs::
 .. code-tab:: gdscript GDscript

    func _physics_process(delta):
        var space_rid = get_world_2d().space
        var space_state = Physics2DServer.space_get_direct_state(space_rid)

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        var spaceRid = GetWorld2d().Space;
        var spaceState = Physics2DServer.SpaceGetDirectState(spaceRid);
    }

Or more directly:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _physics_process(delta):
        var space_state = get_world_2d().direct_space_state

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        var spaceState = GetWorld2d().DirectSpaceState;
    }

And in 3D:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _physics_process(delta):
        var space_state = get_world().direct_space_state

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        var spaceState = GetWorld().DirectSpaceState;
    }

Raycast query
-------------

For performing a 2D raycast query, the method
:ref:`Physics2DDirectSpaceState.intersect_ray() <class_Physics2DDirectSpaceState_method_intersect_ray>`
may be used. For example:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _physics_process(delta):
        var space_state = get_world_2d().direct_space_state
        # use global coordinates, not local to node
        var result = space_state.intersect_ray(Vector2(0, 0), Vector2(50, 100))

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        var spaceState = GetWorld2d().DirectSpaceState;
        // use global coordinates, not local to node
        var result = spaceState.IntersectRay(new Vector2(), new Vector2(50, 100));
    }

The result is a dictionary. If the ray didn't hit anything, the dictionary will
be empty. If it did hit something, it will contain collision information:

.. tabs::
 .. code-tab:: gdscript GDScript

        if result:
            print("Hit at point: ", result.position)

 .. code-tab:: csharp

        if (result.Count > 0)
            GD.Print("Hit at point: ", result["position"]);

The ``result`` dictionary when a collision occurs contains the following
data:

::

    {
       position: Vector2 # point in world space for collision
       normal: Vector2 # normal in world space for collision
       collider: Object # Object collided or null (if unassociated)
       collider_id: ObjectID # Object it collided against
       rid: RID # RID it collided against
       shape: int # shape index of collider
       metadata: Variant() # metadata of collider
    }

The data is similar in 3D space, using Vector3 coordinates.

Collision exceptions
--------------------

A common use case for ray casting is to enable a character to gather data
about the world around it. One problem with this is that the same character
has a collider, so the ray will only detect its parent's collider,
as shown in the following image:

.. image:: img/raycast_falsepositive.png

To avoid self-intersection, the ``intersect_ray()`` function can take an
optional third parameter which is an array of exceptions. This is an
example of how to use it from a KinematicBody2D or any other
collision object node:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    func _physics_process(delta):
        var space_state = get_world_2d().direct_space_state
        var result = space_state.intersect_ray(global_position, enemy_position, [self])

 .. code-tab:: csharp

    class Body : KinematicBody2D
    {
        public override void _PhysicsProcess(float delta)
        {
            var spaceState = GetWorld2d().DirectSpaceState;
            var result = spaceState.IntersectRay(globalPosition, enemyPosition, new Godot.Collections.Array { this });
        }
    }

The exceptions array can contain objects or RIDs.

Collision Mask
--------------

While the exceptions method works fine for excluding the parent body, it becomes
very inconvenient if you need a large and/or dynamic list of exceptions. In
this case, it is much more efficient to use the collision layer/mask system.

The optional fourth argument for ``intersect_ray()`` is a collision mask. For
example, to use the same mask as the parent body, use the ``collision_mask``
member variable:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    func _physics_process(delta):
        var space_state = get_world().direct_space_state
        var result = space_state.intersect_ray(global_position, enemy_position,
                                [self], collision_mask)

 .. code-tab:: csharp

    class Body : KinematicBody2D
    {
        public override void _PhysicsProcess(float delta)
        {
            var spaceState = GetWorld2d().DirectSpaceState;
            var result = spaceState.IntersectRay(globalPosition, enemyPosition,
                            new Godot.Collections.Array { this }, CollisionMask);
        }
    }

See :ref:`doc_physics_introduction_collision_layer_code_example` for details on how to set the collision mask.

3D ray casting from screen
--------------------------

Casting a ray from screen to 3D physics space is useful for object
picking. There is not much need to do this because
:ref:`CollisionObject <class_CollisionObject>`
has an "input_event" signal that will let you know when it was clicked,
but in case there is any desire to do it manually, here's how.

To cast a ray from the screen, you need a :ref:`Camera <class_Camera>`
node. A ``Camera`` can be in two projection modes: perspective and
orthogonal. Because of this, both the ray origin and direction must be
obtained. This is because ``origin`` changes in orthogonal mode, while
``normal`` changes in perspective mode:

.. image:: img/raycast_projection.png

To obtain it using a camera, the following code can be used:

.. tabs::
 .. code-tab:: gdscript GDScript

    const ray_length = 1000

    func _input(event):
        if event is InputEventMouseButton and event.pressed and event.button_index == 1:
              var camera = $Camera
              var from = camera.project_ray_origin(event.position)
              var to = from + camera.project_ray_normal(event.position) * ray_length

 .. code-tab:: csharp

    private const float rayLength = 1000;

    public override void _Input(InputEvent @event)
    {
        if (@event is InputEventMouseButton eventMouseButton && eventMouseButton.Pressed && eventMouseButton.ButtonIndex == 1)
        {
            var camera = GetNode<Camera>("Camera");
            var from = camera.ProjectRayOrigin(eventMouseButton.Position);
            var to = from + camera.ProjectRayNormal(eventMouseButton.Position) * rayLength;
        }
    }


Remember that during ``_input()``, the space may be locked, so in practice
this query should be run in ``_physics_process()``.


===================================================
/. ./tutorials/physics/ragdoll_system.rst
===================================================

.. _doc_ragdoll_system:

Ragdoll system
==============

Introduction
------------

Since version 3.1, Godot supports ragdoll physics. Ragdolls rely on physics simulation to create realistic procedural animation. They are used for death animations in many games.

In this tutorial, we will be using the Platformer3D demo to set up a ragdoll.

.. note:: You can download the Platformer3D demo on `GitHub <https://github.com/godotengine/godot-demo-projects/tree/master/3d/platformer>`_ or using the `Asset Library <https://godotengine.org/asset-library/asset/125>`_.

Setting up the ragdoll
----------------------

Creating physical bones
~~~~~~~~~~~~~~~~~~~~~~~

Like many other features in the engine, there is a node to set up a ragdoll: the :ref:`PhysicalBone <class_PhysicalBone>` node. To simplify the setup, you can generate ``PhysicalBone`` nodes with the "Create physical skeleton" feature in the skeleton node.

Open the platformer demo in Godot, and then the Robi scene. Select the ``Skeleton`` node. A skeleton button appears on the top bar menu:

.. image:: img/ragdoll_menu.png

Click it and select the ``Create physical skeleton`` option. Godot will generate ``PhysicalBone`` nodes and collision shapes for each bone in the skeleton and pin joints to connect them together:

.. image:: img/ragdoll_bones.png

Some of the generated bones aren't necessary: the ``MASTER`` bone for example. So we're going to clean up the skeleton by removing them.

Cleaning up the skeleton
~~~~~~~~~~~~~~~~~~~~~~~~

Each ``PhysicalBone`` the engine needs to simulate has a performance cost, so you want to remove every bone that is too small to make a difference in the simulation, as well as all utility bones.

For example, if we take a humanoid, you do not want to have physical bones for each finger. You can use a single bone for the entire hand instead, or one for the palm, one for the thumb, and a last one for the other four fingers.

Remove these physical bones: ``MASTER``, ``waist``, ``neck``, ``headtracker``. This gives us an optimized skeleton and makes it easier to control the ragdoll.

Collision shape adjustment
~~~~~~~~~~~~~~~~~~~~~~~~~~

The next task is adjusting the collision shape and the size of physical bones to match the part of the body that each bone should simulate.

.. image:: img/ragdoll_shape_adjust.gif

Joints adjustment
~~~~~~~~~~~~~~~~~

Once you adjusted the collision shapes, your ragdoll is almost ready. You just want to adjust the pin joints to get a better simulation. ``PhysicalBone`` nodes have an unconstrained pin joint assigned to them by default. To change the pin joint, select the ``PhysicalBone`` and change the constraint type in the ``Joint`` section. There, you can change the constraint's orientation and its limits.

.. image:: img/ragdoll_joint_adjust.gif

This is the final result:

.. image:: img/ragdoll_result.png

Simulating the ragdoll
----------------------

The ragdoll is now ready to use. To start the simulation and play the ragdoll animation, you need to call the ``physical_bones_start_simulation`` method. Attach a script to the skeleton node and call the method in the ``_ready`` method:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        physical_bones_start_simulation()

To stop the simulation, call the ``physical_bones_stop_simulation()`` method.

.. image:: img/ragdoll_sim_stop.gif

You can also limit the simulation to only a few bones. To do so, pass the bone names as a parameter. Here's an example of partial ragdoll simulation:

.. image:: img/ ragdoll_sim_part.gif

Collision layer and mask
~~~~~~~~~~~~~~~~~~~~~~~~

Make sure to set up your collision layers and masks properly so the ``KinematicBody``'s capsule doesn't get in the way of the physics simulation:

.. image:: img/ragdoll_layer.png

For more information, read :ref:`doc_physics_introduction_collision_layers_and_masks`.


===================================================
/. ./tutorials/physics/kinematic_character_2d.rst
===================================================

.. _doc_kinematic_character_2d:

Kinematic character (2D)
========================

Introduction
~~~~~~~~~~~~

Yes, the name sounds strange. "Kinematic Character". What is that?
The reason for the name is that, when physics engines came out, they were called
"Dynamics" engines (because they dealt mainly with collision
responses). Many attempts were made to create a character controller
using the dynamics engines, but it wasn't as easy as it seemed. Godot
has one of the best implementations of dynamic character controller
you can find (as it can be seen in the 2d/platformer demo), but using
it requires a considerable level of skill and understanding of
physics engines (or a lot of patience with trial and error).

Some physics engines, such as Havok seem to swear by dynamic character
controllers as the best option, while others (PhysX) would rather
promote the kinematic one.

So, what is the difference?:

-  A **dynamic character controller** uses a rigid body with an infinite
   inertia tensor. It's a rigid body that can't rotate.
   Physics engines always let objects move and collide, then solve their
   collisions all together. This makes dynamic character controllers
   able to interact with other physics objects seamlessly, as seen in
   the platformer demo. However, these interactions are not always
   predictable. Collisions can take more than one frame to be
   solved, so a few collisions may seem to displace a tiny bit. Those
   problems can be fixed, but require a certain amount of skill.
-  A **kinematic character controller** is assumed to always begin in a
   non-colliding state, and will always move to a non-colliding state.
   If it starts in a colliding state, it will try to free itself like
   rigid bodies do, but this is the exception, not the rule. This makes
   their control and motion a lot more predictable and easier to
   program. However, as a downside, they can't directly interact with
   other physics objects, unless done by hand in code.

This short tutorial will focus on the kinematic character controller.
Basically, the old-school way of handling collisions (which is not
necessarily simpler under the hood, but well hidden and presented as a
nice and simple API).

Physics process
~~~~~~~~~~~~~~~

To manage the logic of a kinematic body or character, it is always
advised to use physics process, because it's called before physics step and its execution is
in sync with physics server, also it is called the same amount of times
per second, always. This makes physics and motion calculation work in a
more predictable way than using regular process, which might have spikes
or lose precision if the frame rate is too high or too low.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    func _physics_process(delta):
        pass

 .. code-tab:: csharp

    using Godot;
    using System;

    public class PhysicsScript : KinematicBody2D
    {
        public override void _PhysicsProcess(float delta)
        {
        }
    }


Scene setup
~~~~~~~~~~~

To have something to test, here's the scene (from the tilemap tutorial):
:download:`kbscene.zip <files/kbscene.zip>`. We'll be creating a new scene
for the character. Use the robot sprite and create a scene like this:

.. image:: img/kbscene.png

You'll notice that there's a warning icon next to our CollisionShape2D node;
that's because we haven't defined a shape for it. Create a new CircleShape2D
in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to the
options for it, and set the radius to 30:

.. image:: img/kbradius.png

**Note: As mentioned before in the physics tutorial, the physics engine
can't handle scale on most types of shapes (only collision polygons,
planes and segments work), so always change the parameters (such as
radius) of the shape instead of scaling it. The same is also true for
the kinematic/rigid/static bodies themselves, as their scale affects the
shape scale.**

Now, create a script for the character, the one used as an example
above should work as a base.

Finally, instance that character scene in the tilemap, and make the
map scene the main one, so it runs when pressing play.

.. image:: img/kbinstance.png

Moving the kinematic character
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Go back to the character scene, and open the script, the magic begins
now! Kinematic body will do nothing by default, but it has a
useful function called
:ref:`KinematicBody2D.move_and_collide() <class_KinematicBody2D_method_move_and_collide>`.
This function takes a :ref:`Vector2 <class_Vector2>` as
an argument, and tries to apply that motion to the kinematic body. If a
collision happens, it stops right at the moment of the collision.

So, let's move our sprite downwards until it hits the floor:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    func _physics_process(delta):
        move_and_collide(Vector2(0, 1)) # Move down 1 pixel per physics frame

 .. code-tab:: csharp

    using Godot;
    using System;

    public class PhysicsScript : KinematicBody2D
    {
        public override void _PhysicsProcess(float delta)
        {
            // Move down 1 pixel per physics frame
            MoveAndCollide(new Vector2(0, 1));
        }
    }

The result is that the character will move, but stop right when
hitting the floor. Pretty cool, huh?

The next step will be adding gravity to the mix, this way it behaves a
little more like a regular game character:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    const GRAVITY = 200.0
    var velocity = Vector2()

    func _physics_process(delta):
        velocity.y += delta * GRAVITY

        var motion = velocity * delta
        move_and_collide(motion)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class PhysicsScript : KinematicBody2D
    {
        const float gravity = 200.0f;
        Vector2 velocity;

        public override void _PhysicsProcess(float delta)
        {
            velocity.y += delta * gravity;

            var motion = velocity * delta;
            MoveAndCollide(motion);
        }
    }

Now the character falls smoothly. Let's make it walk to the sides, left
and right when touching the directional keys. Remember that the values
being used (for speed at least) are pixels/second.

This adds simple walking support by pressing left and right:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends KinematicBody2D

    const GRAVITY = 200.0
    const WALK_SPEED = 200

    var velocity = Vector2()

    func _physics_process(delta):
        velocity.y += delta * GRAVITY

        if Input.is_action_pressed("ui_left"):
            velocity.x = -WALK_SPEED
        elif Input.is_action_pressed("ui_right"):
            velocity.x =  WALK_SPEED
        else:
            velocity.x = 0

        # We don't need to multiply velocity by delta because "move_and_slide" already takes delta time into account.

        # The second parameter of "move_and_slide" is the normal pointing up.
        # In the case of a 2D platformer, in Godot, upward is negative y, which translates to -1 as a normal.
        velocity = move_and_slide(velocity, Vector2(0, -1))

 .. code-tab:: csharp

    using Godot;
    using System;

    public class PhysicsScript : KinematicBody2D
    {
        const float gravity = 200.0f;
        const int walkSpeed = 200;

        Vector2 velocity;

        public override void _PhysicsProcess(float delta)
        {
            velocity.y += delta * gravity;

            if (Input.IsActionPressed("ui_left"))
            {
                velocity.x = -walkSpeed;
            }
            else if (Input.IsActionPressed("ui_right"))
            {
                velocity.x = walkSpeed;
            }
            else
            {
                velocity.x = 0;
            }

            // We don't need to multiply velocity by delta because "MoveAndSlide" already takes delta time into account.

            // The second parameter of "MoveAndSlide" is the normal pointing up.
            // In the case of a 2D platformer, in Godot, upward is negative y, which translates to -1 as a normal.
            velocity = MoveAndSlide(velocity, new Vector2(0, -1));
        }
    }

And give it a try.

This is a good starting point for a platformer. A more complete demo can be found in the demo zip distributed with the
engine, or in the
https://github.com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character.


===================================================
/. ./tutorials/physics/soft_body.rst
===================================================

.. _doc_soft_body:

Using SoftBody
==============

Soft bodies (or *soft-body dynamics*) simulate movement, changing shape and other physical properties of deformable objects.
This can for example be used to simulate cloth or to create more realistic characters.

Basic set-up
~~~~~~~~~~~~

A :ref:`SoftBody <class_SoftBody>` node is used for soft body simulations.

We will create a bouncy cube to demonstrate the setup of a soft body.

Create a new scene with a ``Spatial`` node as root. Then, create a ``Softbody`` node. Add a ``CubeMesh`` in the ``mesh`` property of the node in the inspector and increase the subdivision of the mesh for simulation.

.. image:: img/softbody_cube.png

Set the parameters to obtain the type of soft body you aim for. Try to keep the ``Simulation Precision`` above 5, otherwise, the soft body may collapse.

.. image:: img/softbody_cube_menu.png

.. note:: Handle some parameters with care, as some value can lead to strange results. For example, if the shape is not completely closed and you set pressure to more than 0, the softbody will fly around like a plastic bag under strong wind.

Play the scene to view the simulation.

.. tip:: To improve the simulation's result, increase the ``Simulation Precision``, this will give significant improvement at the cost of performance.

Cloak simulation
~~~~~~~~~~~~~~~~

Let's make a cloak in the Platformer3D demo.

.. note:: You can download the Platformer3D demo on `GitHub <https://github.com/godotengine/godot-demo-projects/tree/master/3d/platformer>`_ or `the Asset Library <https://godotengine.org/asset-library/asset/125>`_.

Open the ``Player`` scene, add a ``SoftBody`` node and assign a ``PlaneMesh`` to it.

Open the ``PlaneMesh`` properties and set the size(x: 0.5 y: 1) then set ``Subdivide Width`` and ``Subdivide Depth`` to 5. Adjust the ``SoftBody``'s position. You should end up with something like this:

.. image:: img/softbody_cloak_subdivide.png

.. tip:: Subdivision generates a more tessellated mesh for better simulations.

Add a :ref:`BoneAttachment <class_BoneAttachment>` node under the skeleton node and select the Neck bone to attach the cloak to the character skeleton.

.. note:: ``BoneAttachment`` node is to attach objects to a bone of a armature. The attached object will follow the bone's movement, weapon of a character can be attached this way.

.. image:: img/softbody_cloak_bone_attach.png

To create pinned joints, select the upper vertices in the ``SoftBody`` node:

.. image:: img/softbody_cloak_pinned.png

The pinned joints can be found in ``SoftBody``'s ``Attachments`` property, choose the ``BoneAttachment`` as the ``SpatialAttachment`` for each pinned joints, the pinned joints are now attached to the neck.

.. image:: img/softbody_cloak_pinned_attach.png

Last step is to avoid clipping by adding the Kinematic Body `Player` to ``Parent Collision Ignore`` of the ``SoftBody``.

.. image:: img/softbody_cloak_ignore.png

Play the scene and the cloak should simulate correctly.

.. image:: img/softbody_cloak_finish.png

This covers the basic settings of softbody, experiment with the parameters to achieve the effect you are aiming for when making your game.


===================================================
/. ./tutorials/physics/collision_shapes_3d.rst
===================================================

.. _doc_collision_shapes_3d:

Collision shapes (3D)
=====================

This guide explains:

- The types of collision shapes available in 3D in Godot.
- Using a convex or a concave mesh as a collision shape.
- Performance considerations regarding 3D collisions.

Godot provides many kinds of collision shapes, with different performance and
accuracy tradeoffs.

You can define the shape of a :ref:`class_PhysicsBody` by adding one or more
:ref:`CollisionShapes <class_CollisionShape>` as child nodes. Note that you must
add a :ref:`class_Shape` *resource* to collision shape nodes in the Inspector
dock.

.. note::

    When you add multiple collision shapes to a single PhysicsBody, you don't
    have to worry about them overlapping. They won't "collide" with each other.

Primitive collision shapes
--------------------------

Godot provides the following primitive collision shape types:

- :ref:`class_BoxShape`
- :ref:`class_SphereShape`
- :ref:`class_CapsuleShape`
- :ref:`class_CylinderShape`

You can represent the collision of most smaller objects using one or more
primitive shapes. However, for more complex objects, such as a large ship or a
whole level, you may need convex or concave shapes instead. More on that below.

We recommend favoring primitive shapes for dynamic objects such as RigidBodies
and KinematicBodies as their behavior is the most reliable. They often provide
better performance as well.

Convex collision shapes
-----------------------

:ref:`Convex collision shapes <class_ConvexPolygonShape>` are a compromise
between primitive collision shapes and concave collision shapes. They can
represent shapes of any complexity, but with an important caveat. As their name
implies, an individual shape can only represent a *convex* shape. For instance,
a pyramid is *convex*, but a hollow box is *concave*. To define a concave object
with a single collision shape, you need to use a concave collision shape.

Depending on the object's complexity, you may get better performance by using
multiple convex shapes instead of a concave collision shape. Godot lets you use
*convex decomposition* to generate convex shapes that roughly match a hollow
object. Note this performance advantage no longer applies after a certain amount
of convex shapes. For large and complex objects such as a whole level, we
recommend using concave shapes instead.

You can generate one or several convex collision shapes from the editor by
selecting a MeshInstance and using the **Mesh** menu at the top of the 3D
viewport. The editor exposes two generation modes:

- **Create Single Convex Collision Sibling** uses the Quickhull algorithm. It
  creates one CollisionShape node with an automatically generated convex
  collision shape. Since it only generates a single shape, it provides good
  performance and is ideal for small objects.

- **Create Multiple Convex Collision Siblings** uses the V-HACD algorithm. It
  creates several CollisionShape nodes, each with a convex shape. Since it
  generates multiple shapes, it is more accurate for concave objects at the cost
  of performance. For objects with medium complexity, it will likely be faster
  than using a single concave collision shape.

Concave or trimesh collision shapes
-----------------------------------

:ref:`Concave collision shapes <class_ConcavePolygonShape>`, also called trimesh
collision shapes, can take any form, from a few triangles to thousands of
triangles. Concave shapes are the slowest option but are also the most accurate
in Godot. **You can only use concave shapes within StaticBodies.** They will not
work with KinematicBodies or RigidBodies unless the RigidBody's mode is Static.

.. note::

    Even though concave shapes offer the most accurate *collision*, contact
    reporting can be less precise than primitive shapes.

When not using GridMaps for level design, concave shapes are the best approach
for a level's collision. That said, if your level has small details, you may
want to exclude those from collision for performance and game feel. To do so,
you can build a simplified collision mesh in a 3D modeler and have Godot
generate a collision shape for it automatically. More on that below

Note that unlike primitive and convex shapes, a concave collision shape doesn't
have an actual "volume". You can place objects both *outside* of the shape as
well as *inside*.

You can generate a concave collision shape from the editor by selecting a
MeshInstance and using the **Mesh** menu at the top of the 3D viewport. The
editor exposes two options:

- **Create Trimesh Static Body** is a convenient option. It creates a StaticBody
  containing a concave shape matching the mesh's geometry.

- **Create Trimesh Collision Sibling** creates a CollisionShape node with a
  concave shape matching the mesh's geometry.

.. note::

    Suppose you need to make a RigidBody *slide* on a concave collision shape.
    In that case, you may notice that sometimes, the RigidBody will bump
    upwards. To solve this, open **Project > Project Settings** and enable
    **Physics > 3d > Smooth Trimesh Collision**.

    Once you've enabled smooth trimesh collision, make sure the concave shape is
    the only shape of your StaticBody and that it's located at its origin
    without any rotation. This way, the RigidBody should slide perfectly on the
    StaticBody.

.. seealso::

    Godot can generate collision shapes for your imported 3D scenes
    automatically. See :ref:`doc_importing_scenes_import_hints` in the
    documentation for more information.

Performance caveats
-------------------

You aren't limited to a single collision shape per PhysicsBody. Still, we
recommend keeping the number of shapes as low as possible to improve
performance, especially for dynamic objects like RigidBodies and
KinematicBodies. On top of that, avoid translating, rotating, or scaling
CollisionShapes to benefit from the physics engine's internal optimizations.

When using a single non-transformed collision shape in a StaticBody, the
engine's *broad phase* algorithm can discard inactive PhysicsBodies. The *narrow
phase* will then only have to take into account the active bodies' shapes. If a
StaticBody has many collision shapes, the broad phase will fail. The narrow
phase, which is slower, must then perform a collision check against each shape.

If you run into performance issues, you may have to make tradeoffs in terms of
accuracy. Most games out there don't have a 100% accurate collision. They find
creative ways to hide it or otherwise make it unnoticeable during normal
gameplay.


===================================================
/. ./tutorials/physics/interpolation/index.rst
===================================================

.. _doc_physics_interpolation:

Physics Interpolation
=====================

.. toctree::
   :maxdepth: 1
   :name: toc-physics-interpolation

   physics_interpolation_quick_start_guide
   physics_interpolation_introduction
   using_physics_interpolation
   advanced_physics_interpolation


===================================================
/. ./tutorials/physics/interpolation/physics_interpolation_quick_start_guide.rst
===================================================

.. _doc_physics_interpolation_quick_start_guide:

Quick start guide
=================

- Turn on physics interpolation: :ref:`ProjectSettings.physics/common/physics_interpolation<class_ProjectSettings_property_physics/common/physics_interpolation>`
- Make sure you move objects and run your game logic in ``_physics_process()`` rather than ``_process()``. This includes moving objects directly *and indirectly* (by e.g. moving a parent, or using another mechanism to automatically move nodes).
- Be sure to call :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>` on nodes *after* you first position or teleport them, to prevent "streaking"
- Temporarily try setting :ref:`ProjectSettings.physics/common/physics_fps<class_ProjectSettings_property_physics/common/physics_fps>` to 10 to see the difference with and without interpolation.


===================================================
/. ./tutorials/physics/interpolation/physics_interpolation_introduction.rst
===================================================

.. _doc_physics_interpolation_introduction:

Introduction
============

Physics ticks and rendered frames
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

One key concept to understand in Godot is the distinction between physics ticks (sometimes referred to as iterations or physics frames), and rendered frames. The physics proceeds at a fixed tick rate (set in :ref:`ProjectSettings.physics/common/physics_fps<class_ProjectSettings_property_physics/common/physics_fps>`), which defaults to 60 ticks per second.

However, the engine does not necessarily **render** at the same rate. Although many monitors refresh at 60 Hz (cycles per second), many refresh at completely different frequencies (e.g. 75 Hz, 144 Hz, 240 Hz or more). Even though a monitor may be able to show a new frame e.g. 60 times a second, there is no guarantee that the CPU and GPU will be able to *supply* frames at this rate. For instance, when running with V-Sync, the computer may be too slow for 60 and only reach the deadlines for 30 FPS, in which case the frames you see will change at 30 FPS (resulting in stuttering).

But there is a problem here. What happens if the physics ticks do not coincide with frames? What happens if the physics tick rate is out of phase with the frame rate? Or worse, what happens if the physics tick rate is *lower* than the rendered frame rate?

This problem is easier to understand if we consider an extreme scenario. If you set the physics tick rate to 10 ticks per second, in a simple game with a rendered frame rate of 60 FPS. If we plot a graph of the positions of an object against the rendered frames, you can see that the positions will appear to "jump" every 1/10th of a second, rather than giving a smooth motion. When the physics calculates a new position for a new object, it is not rendered in this position for just one frame, but for 6 frames.

.. image:: img/fti_graph_fixed_ticks.png

This jump can be seen in other combinations of tick / frame rate as glitches, or jitter, caused by this staircasing effect due to the discrepancy between physics tick time and rendered frame time.

What can we do about frames and ticks being out of sync?
--------------------------------------------------------

Lock the tick / frame rate together?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The most obvious solution is to get rid of the problem, by ensuring there is a physics tick that coincides with every frame. This used to be the approach on old consoles and fixed hardware computers. If you know that every player will be using the same hardware, you can ensure it is fast enough to calculate ticks and frames at e.g. 50 FPS, and you will be sure it will work great for everybody.

However, modern games are often no longer made for fixed hardware. You will often be planning to release on desktop computers, mobiles and more, all of which have huge variations in performance, as well as different monitor refresh rates. We need to come up with a better way of dealing with the problem.

Adapt the tick rate?
^^^^^^^^^^^^^^^^^^^^

Instead of designing the game at a fixed physics tick rate, we could allow the tick rate to scale according to the end users hardware. We could for example use a fixed tick rate that works for that hardware, or even vary the duration of each physics tick to match a particular frame duration.

This works, but there is a problem. Physics (*and game logic*, which is often also run in the ``_physics_process``) work best and most consistently when run at a **fixed**, predetermined tick rate. If you attempt to run a racing game physics that has been designed for 60 TPS (ticks per second) at e.g. 10 TPS, the physics will behave completely differently. Controls may be less responsive, collisions / trajectories can be completely different. You may test your game thoroughly at 60 TPS, then find it breaks on end users machines when it runs at a different tick rate.

This can make quality assurance difficult with hard to reproduce bugs, especially in AAA games where problems of this sort can be very costly. This can also be problematic for multiplayer games for competitive integrity, as running the game at certain tick rates may be more advantageous than others.

Lock the tick rate, but use interpolation to smooth frames in between physics ticks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This has become one of the most popular approaches to dealing with the problem. It is supported by Godot 3.5 and later in 3D (although it is optional and disabled by default).

We have established that the most desirable physics/game logic arrangement for consistency and predictability is a physics tick rate that is fixed at design-time. The problem is the discrepancy between the physics position recorded, and where we "want" a physics object to be shown on a frame to give smooth motion.

The answer turns out to be simple, but can be a little hard to get your head around at first.

Instead of keeping track of just the current position of a physics object in the engine, we keep track of *both the current position of the object, and the previous position* on the previous physics tick.

Why do we need the previous position *(in fact the entire transform, including rotation and scaling)*? By using a little math magic, we can use **interpolation** to calculate what the transform of the object would be between those two points, in our ideal world of smooth continuous movement.

.. image:: img/fti_graph_interpolated.png

Linear interpolation
^^^^^^^^^^^^^^^^^^^^

The simplest way to achieve this is linear interpolation, or lerping, which you may have used before.

Let us consider only the position, and a situation where we know that the previous physics tick X coordinate was 10 units, and the current physics tick X coordinate is 30 units.

.. note:: Although the maths is explained here, you do not have to worry about the details, as this step will be performed for you. Under the hood, Godot may use more complex forms of interpolation, but linear interpolation is the easiest in terms of explanation.

The physics interpolation fraction
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If our physics ticks are happening 10 times per second (for this example), what happens if our rendered frame takes place at time 0.12 seconds? We can do some math to figure out where the object would be to obtain a smooth motion between the two ticks.

First of all, we have to calculate how far through the physics tick we want the object to be. If the last physics tick took place at 0.1 seconds, we are 0.02 seconds *(0.12 - 0.1)* through a tick that we know will take 0.1 seconds (10 ticks per second). The fraction through the tick is thus:

.. code-block:: python

	fraction = 0.02 / 0.10
	fraction = 0.2

This is called the **physics interpolation fraction**, and is handily calculated for you by Godot. It can be retrieved on any frame by calling :ref:`Engine.get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>`.

Calculating the interpolated position
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Once we have the interpolation fraction, we can insert it into a standard linear interpolation equation. The X coordinate would thus be:

.. code-block:: python

	x_interpolated = x_prev + ((x_curr - x_prev) * 0.2)

So substituting our ``x_prev`` as 10, and ``x_curr`` as 30:

.. code-block:: python

	x_interpolated = 10 + ((30 - 10) * 0.2)
	x_interpolated = 10 + 4
	x_interpolated = 14

Let's break that down:

- We know the X starts from the coordinate on the previous tick (``x_prev``) which is 10 units.
- We know that after the full tick, the difference between the current tick and the previous tick will have been added (``x_curr - x_prev``) (which is 20 units).
- The only thing we need to vary is the proportion of this difference we add, according to how far we are through the physics tick.

.. note:: Although this example interpolates the position, the same thing can be done with the rotation and scale of objects. It is not necessary to know the details as Godot will do all this for you.

Smoothed transformations between physics ticks?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Putting all this together shows that it should be possible to have a nice smooth estimation of the transform of objects between the current and previous physics tick.

But wait, you may have noticed something. If we are interpolating between the current and previous ticks, we are not estimating the position of the object *now*, we are estimating the position of the object in the past. To be exact, we are estimating the position of the object *between 1 and 2 ticks* into the past.

In the past
^^^^^^^^^^^

What does this mean? This scheme does work, but it does mean we are effectively introducing a delay between what we see on the screen, and where the objects *should* be.

In practice, most people won't notice this delay, or rather, it is typically not *objectionable*. There are already significant delays involved in games, we just don't typically notice them. The most significant effect is there can be a slight delay to input, which can be a factor in fast twitch games. In some of these fast input situations, you may wish to turn off physics interpolation and use a different scheme, or use a high tick rate, which mitigates these delays.

Why look into the past? Why not predict the future?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There is an alternative to this scheme, which is: instead of interpolating between the previous and current tick, we use maths to *extrapolate* into the future. We try to predict where the object *will be*, rather than show it where it was. This can be done and may be offered as an option in future, but there are some significant downsides:

- The prediction may not be correct, especially when an object collides with another object during the physics tick.
- Where a prediction was incorrect, the object may extrapolate into an "impossible" position, like inside a wall.
- Providing the movement speed is slow, these incorrect predictions may not be too much of a problem.
- When a prediction was incorrect, the object may have to jump or snap back onto the corrected path. This can be visually jarring.

Fixed timestep interpolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In Godot this whole system is referred to as physics interpolation, but you may also hear it referred to as **"fixed timestep interpolation"**, as it is interpolating between objects moved with a fixed timestep (physics ticks per second). In some ways the second term is more accurate, because it can also be used to interpolate objects that are not driven by physics.

.. tip:: Although physics interpolation is usually a good choice, there are exceptions where you may choose not to use Godot's built-in physics interpolation (or use it in a limited fashion). An example category is internet multiplayer games. Multiplayer games often receive tick or timing based information from other players or a server and these may not coincide with local physics ticks, so a custom interpolation technique can often be a better fit.


===================================================
/. ./tutorials/physics/interpolation/using_physics_interpolation.rst
===================================================

.. _doc_using_physics_interpolation:

Using physics interpolation
===========================
How do we incorporate physics interpolation into a Godot game? Are there any caveats?

We have tried to make the system as easy to use as possible, and many existing games will work with few changes. That said there are some situations which require special treatment, and these will be described.

Turn on the physics interpolation setting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The first step is to turn on physics interpolation in :ref:`ProjectSettings.physics/common/physics_interpolation<class_ProjectSettings_property_physics/common/physics_interpolation>`. You can now run your game.

It is likely that nothing looks hugely different, particularly if you are running physics at 60 TPS or a multiple of it. However, quite a bit more is happening behind the scenes.

.. tip::

	To convert an existing game to use interpolation, it is highly recommended that you temporarily set :ref:`ProjectSettings.physics/common/physics_fps<class_ProjectSettings_property_physics/common/physics_fps>` to a low value such as 10, which will make interpolation problems more obvious.

Move (almost) all game logic from _process to _physics_process
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The most fundamental requirement for physics interpolation (which you may be doing already) is that you should be moving and performing game logic on your objects within ``_physics_process`` (which runs at a physics tick) rather than ``_process`` (which runs on a rendered frame). This means your scripts should typically be doing the bulk of their processing within ``_physics_process``, including responding to input and AI.

Setting the transform of objects only within physics ticks allows the automatic interpolation to deal with transforms *between* physics ticks, and ensures the game will run the same whatever machine it is run on. As a bonus, this also reduces CPU usage if the game is rendering at high FPS, since AI logic (for example) will no longer run on every rendered frame.

.. note:: If you attempt to set the transform of interpolated objects *outside* the physics tick, the calculations for the interpolated position will be incorrect, and you will get jitter. This jitter may not be visible on your machine, but it *will* occur for some players. For this reason, setting the transform of interpolated objects should be avoided outside of the physics tick. Godot will attempt to produce warnings in the editor if this case is detected.

.. tip:: This is only a *soft-rule*. There are some occasions where you might want to teleport objects outside of the physics tick (for instance when starting a level, or respawning objects). Still, in general, you should be applying transforms from the physics tick.


Ensure that all indirect movement happens during physics ticks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Consider that in Godot, Nodes can be moved not just directly in your own scripts, but also by automatic methods such as tweening, animation, and navigation. All these methods should also have their timing set to operate on the physics tick rather than each frame ("idle"), **if** you are using them to move objects (*these methods can also be used to control properties that are not interpolated*).

.. note:: Also consider that nodes can be moved not just by moving themselves, but also by moving parent nodes in the :ref:`SceneTree<class_SceneTree>`. The movement of parents should therefore also only occur during physics ticks.

Choose a physics tick rate
^^^^^^^^^^^^^^^^^^^^^^^^^^

When using physics interpolation, the rendering is decoupled from physics, and you can choose any value that makes sense for your game. You are no longer limited to values that are multiples of the user's monitor refresh rate (for stutter-free gameplay if the target FPS is reached).

As a rough guide:

.. csv-table::
    :header: "Low tick rates (10-30)", "Medium tick rates (30-60)", "High tick rates (60+)"
    :widths: 20, 20, 20
    
    "Better CPU performance","Good physics behaviour in complex scenes","Good with fast physics"
    "Add some delay to input","Good for first person games","Good for racing games"
    "Simple physics behaviour"

.. note:: You can always change the tick rate as you develop, it is as simple as changing the project setting.

Call reset_physics_interpolation() when teleporting objects
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Most of the time, interpolation is what you want between two physics ticks. However, there is one situation in which it may *not* be what you want. That is when you are initially placing objects, or moving them to a new location. Here, you don't want a smooth motion between the two - you want an instantaneous move.

The solution to this is to call the :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>` function. You should call this function on a Node *after* setting the position/transform. The rest is done for you automatically.

Even if you forget to call this, it is not usually a problem in most situations (especially at high tick rates). This is something you can easily leave to the polishing phase of your game. The worst that will happen is seeing a streaking motion for a frame or so when you move them - you will know when you need it!

.. important:: You should call ``reset_physics_interpolation()`` *after* setting the new position, rather than before. Otherwise, you will still see the unwanted streaking motion.

Testing and debugging tips
--------------------------

Even if you intend to run physics at 60 TPS, in order to thoroughly test your interpolation and get the smoothest gameplay, it is highly recommended to temporarily set the physics tick rate to a low value such as 10 TPS.

The gameplay may not work perfectly, but it should enable you to more easily see cases where you should be calling :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`, or where you should be using your own custom interpolation on e.g. a :ref:`Camera<class_Camera>`. Once you have these cases fixed, you can set the physics tick rate back to the desired setting.

The other great advantage to testing at a low tick rate is you can often notice other game systems that are synchronized to the physics tick and creating glitches which you may want to work around. Typical examples include setting animation blend values, which you may decide to set in ``_process()`` and interpolate manually.


===================================================
/. ./tutorials/physics/interpolation/advanced_physics_interpolation.rst
===================================================

.. _doc_advanced_physics_interpolation:

Advanced physics interpolation
==============================

Although the previous instructions will give satisfactory results in a lot of games, in some cases you will want to go a stage further to get the best possible results and the smoothest possible experience.

Exceptions to automatic physics interpolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Even with physics interpolation active, there may be some local situations where you would benefit from disabling automatic interpolation for a :ref:`Node<class_Node>` (or branch of the :ref:`SceneTree<class_SceneTree>`), and have the finer control of performing interpolation manually.

This is possible using the :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` property which is present in all Nodes. If you for example, turn off interpolation for a Node, the children will recursively also be affected (as they default to inheriting the parent setting). This means you can easily disable interpolation for an entire subscene.

The most common situation where you may want to perform your own interpolation is Cameras.

Cameras
^^^^^^^

In many cases, a :ref:`Camera<class_Camera>` can use automatic interpolation just like any other node. However, for best results, especially at low physics tick rates, it is recommended that you take a manual approach to Camera interpolation.

This is because viewers are very sensitive to Camera movement. For instance, a Camera that realigns slightly every 1/10th of a second (at 10tps tick rate) will often be noticeable. You can get a much smoother result by moving the Camera each frame in ``_process``, and following an interpolated target manually.

Manual Camera interpolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ensure the Camera is using global coordinate space**

The very first step when performing manual Camera interpolation is to make sure the Camera transform is specified in *global space* rather than inheriting the transform of a moving parent. This is because feedback can occur between the movement of a parent node of a Camera and the movement of the Camera Node itself, which can mess up the interpolation.

There are two ways of doing this:

1) Move the Camera so it is independent on its own branch, rather than being a child of a moving object.

.. image:: img/fti_camera_worldspace.png

2) Call :ref:`Spatial.set_as_toplevel<class_Spatial_method_set_as_toplevel>` and set this to ``true``, which will make the Camera ignore the transform of its parent.

Typical example
^^^^^^^^^^^^^^^

A typical example of a custom approach is to use the ``look_at`` function in the Camera every frame in ``_process()`` to look at a target node (such as the player).

But there is a problem. If we use the traditional ``get_global_transform()`` on a Camera "target" Node, this transform will only focus the Camera on the target *at the current physics tick*. This is *not* what we want, as the Camera will jump about on each physics tick as the target moves. Even though the Camera may be updated each frame, this does not help give smooth motion if the *target* is only changing each physics tick.

get_global_transform_interpolated()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

What we really want to focus the Camera on, is not the position of the target on the physics tick, but the *interpolated* position, i.e. the position at which the target will be rendered.

We can do this using the :ref:`Spatial.get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>` function. This acts exactly like getting :ref:`Spatial.global_transform<class_Spatial_property_global_transform>` but it gives you the *interpolated* transform (during a ``_process()`` call).

.. important:: ``get_global_transform_interpolated()`` should only be used once or twice for special cases such as Cameras. It should **not** be used all over the place in your code (both for performance reasons, and to give correct gameplay).

.. note:: Aside from exceptions like the Camera, in most cases, your game logic should be in ``_physics_process()``. In game logic you should be calling ``get_global_transform()`` or ``get_transform()``, which will give the current physics transform (in global or local space respectively), which is usually what you will want for gameplay code.

Example manual Camera script
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here is an example of a simple fixed Camera which follows an interpolated target:

.. code-block:: python

	extends Camera
		
	# Node that the camera will follow
	var _target
		
	# We will smoothly lerp to follow the target
	# rather than follow exactly
	var _target_pos : Vector3 = Vector3()
		
	func _ready() -> void:
		# Find the target node
		_target = get_node("../Player")
		
		# Turn off automatic physics interpolation for the Camera,
		# we will be doing this manually
		set_physics_interpolation_mode(Node.PHYSICS_INTERPOLATION_MODE_OFF)
		
	func _process(delta: float) -> void:
		# Find the current interpolated transform of the target
		var tr : Transform = _target.get_global_transform_interpolated()
		
		# Provide some delayed smoothed lerping towards the target position 
		_target_pos = lerp(_target_pos, tr.origin, min(delta, 1.0))
		
		# Fixed camera position, but it will follow the target
		look_at(_target_pos, Vector3(0, 1, 0))

Mouse look
^^^^^^^^^^

Mouse look is a very common way of controlling Cameras. But there is a problem. Unlike keyboard input which can be sampled periodically on the physics tick, mouse move events can come in continuously. The Camera will be expected to react and follow these mouse movements on the next frame, rather than waiting until the next physics tick.

In this situation, it can be better to disable physics interpolation for the Camera node (using :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) and directly apply the mouse input to the Camera rotation, rather than apply it in ``_physics_process``.

Sometimes, especially with Cameras, you will want to use a combination of interpolation and non-interpolation:

* A first person camera may position the camera at a player location (perhaps using :ref:`Spatial.get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>`), but control the Camera rotation from mouse look *without* interpolation.
* A third person camera may similarly determine the look at (target location) of the camera using :ref:`Spatial.get_global_transform_interpolated<class_Spatial_method_get_global_transform_interpolated>`, but position the camera using mouse look *without* interpolation.

There are many permutations and variations of Camera types, but it should be clear that in many cases, disabling automatic physics interpolation and handling this yourself can give a better result.

Disabling interpolation on other nodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Although Cameras are the most common example, there are a number of cases when you may wish other nodes to control their own interpolation, or be non-interpolated. Consider for example, a player in a top view game whose rotation is controlled by mouse look. Disabling physics rotation allows the player rotation to match the mouse in real-time.


MultiMeshes
^^^^^^^^^^^

Although most visual Nodes follow the single Node single visual instance paradigm, MultiMeshes can control several instances from the same Node. Therefore, they have some extra functions for controlling interpolation functionality on a *per-instance* basis. You should explore these functions if you are using interpolated MultiMeshes.

- :ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`
- :ref:`MultiMesh.set_as_bulk_array_interpolated<class_MultiMesh_method_set_as_bulk_array_interpolated>`

Full details are in the :ref:`MultiMesh<class_MultiMesh>` documentation.


===================================================
/. ./tutorials/platform/index.rst
===================================================

Platform-specific
=================

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-platform

   android/index
   ios/index
   platform_html5
   consoles
   mobile_rendering_limitations


===================================================
/. ./tutorials/platform/android/index.rst
===================================================

Android plugins
===============

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-plugins-android

   android_plugin
   android_in_app_purchases


===================================================
/. ./tutorials/platform/android/android_plugin.rst
===================================================

.. _doc_android_plugin:

Creating Android plugins
========================

Introduction
------------

Android plugins are powerful tools to extend the capabilities of the Godot engine
by tapping into the functionality provided by the Android platform and ecosystem.

Mobile gaming monetization is one such example since it requires features
and capabilities that don't belong to the core feature set of a game engine:

- Analytics
- In-app purchases
- Receipt validation
- Install tracking
- Ads
- Video ads
- Cross-promotion
- In-game soft & hard currencies
- Promo codes
- A/B testing
- Login
- Cloud saves
- Leaderboards and scores
- User support & feedback
- Posting to Facebook, Twitter, etc.
- Push notifications

Android plugin
--------------

While introduced in Godot 3.2, the Android plugin system got a significant architecture update starting with Godot 3.2.2.
The new plugin system is backward-incompatible with the previous one, but both systems are kept functional in future releases of the 3.2.x branch.
Since we previously did not version the Android plugin systems, the new one is now labelled ``v1`` and is the starting point for the modern Godot Android ecosystem.

**Note:** In Godot 4.0, the previous system will be fully deprecated and removed.

As a prerequisite, make sure you understand how to set up a :ref:`custom build environment<doc_android_custom_build>` for Android.

At its core, a Godot Android plugin is a `Android archive library <https://developer.android.com/studio/projects/android-library#aar-contents>`_ (*aar* archive file)
with the following caveats:

- The library must have a dependency on the Godot engine library (``godot-lib.<version>.<status>.aar``). A stable version is made available for each Godot release on the `Godot download page <https://godotengine.org/download>`_.
- The library must include a specifically configured ``<meta-data>`` tag in its manifest file.

Building an Android plugin
^^^^^^^^^^^^^^^^^^^^^^^^^^

**Prerequisite:** `Android Studio <https://developer.android.com/studio>`_ is strongly recommended as the IDE to use to create Android plugins.
The instructions below assumes that you're using Android Studio.

1. Follow `these instructions <https://developer.android.com/studio/projects/android-library>`__ to create an Android library module for your plugin.

2. Add the Godot engine library as a dependency to your plugin module:

  - Download the Godot engine library (``godot-lib.<version>.<status>.aar``) from the `Godot download page <https://godotengine.org/download>`_ (e.g.: ``godot-lib.3.4.2.stable.release.aar``). 
  - Follow `these instructions <https://developer.android.com/studio/projects/android-library#AddDependency>`__ to add
    the Godot engine library as a dependency for your plugin.
  - In the plugin module's ``build.gradle`` file, replace ``implementation`` with ``compileOnly`` for the dependency line for the Godot engine library.

3. Create a new class in the plugin module and make sure it extends ``org.godotengine.godot.plugin.GodotPlugin``.
   At runtime, it will be used to instantiate a singleton object that will be used by the Godot engine to load, initialize and run the plugin.

4. Update the plugin ``AndroidManifest.xml`` file:

  - Open the plugin ``AndroidManifest.xml`` file.
  - Add the ``<application></application>`` tag if it's missing.
  - In the ``<application>`` tag, add a ``<meta-data>`` tag setup as follow::

        <meta-data
            android:name="org.godotengine.plugin.v1.[PluginName]"
            android:value="[plugin.init.ClassFullName]" />

    Where ``PluginName`` is the name of the plugin, and ``plugin.init.ClassFullName`` is the full name (package + class name) of the plugin loading class.

5. Add the remaining logic for your plugin and run the ``gradlew build`` command to generate the plugin's ``aar`` file.
   The build will likely generate both a ``debug`` and ``release`` ``aar`` files.
   Depending on your need, pick only one version (usually the ``release`` one) which to provide your users with.

   It's recommended that the ``aar`` filename matches the following pattern: ``[PluginName]*.aar`` where ``PluginName`` is the name of the plugin in PascalCase (e.g.: ``GodotPayment.release.aar``).

6. Create a Godot Android Plugin configuration file to help the system detect and load your plugin:

  - The configuration file extension must be ``gdap`` (e.g.: ``MyPlugin.gdap``).
  - The configuration file format is as follow::

        [config]

        name="MyPlugin"
        binary_type="local"
        binary="MyPlugin.aar"

        [dependencies]

        local=["local_dep1.aar", "local_dep2.aar"]
        remote=["example.plugin.android:remote-dep1:0.0.1", "example.plugin.android:remote-dep2:0.0.1"]
        custom_maven_repos=["http://repo.mycompany.com/maven2"]

    The ``config`` section and fields are required and defined as follow:

    - **name**: name of the plugin.
    - **binary_type**: can be either ``local`` or ``remote``. The type affects the **binary** field.
    - **binary**:

      - If **binary_type** is ``local``, then this should be the filepath of the plugin ``aar`` file.

        - The filepath can be relative (e.g.: ``MyPlugin.aar``) in which case it's relative to the ``res://android/plugins`` directory.
        - The filepath can be absolute: ``res://some_path/MyPlugin.aar``.

      - If **binary_type** is ``remote``, then this should be a declaration for a `remote gradle binary <https://developer.android.com/studio/build/dependencies#dependency-types>`_ (e.g.: ``org.godot.example:my-plugin:0.0.0``).

    The ``dependencies`` section and fields are optional and defined as follow:

    - **local**: contains a list of filepaths to the local ``.aar`` binary files the plugin depends on. Similarly to the ``binary`` field (when the ``binary_type`` is ``local``), the local binaries' filepaths can be relative or absolute.
    - **remote**: contains a list of remote binary gradle dependencies for the plugin.
    - **custom_maven_repos**: contains a list of URLs specifying the custom maven repositories required for the plugin's dependencies.

Loading and using an Android plugin
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Move the plugin configuration file (e.g.: ``MyPlugin.gdap``) and, if any, its local binary (e.g.: ``MyPlugin.aar``) and dependencies to the Godot project's ``res://android/plugins`` directory.

The Godot editor will automatically parse all ``.gdap`` files in the ``res://android/plugins`` directory and show a list of detected and toggleable plugins in the Android export presets window under the **Plugins** section.

.. image:: img/android_export_preset_plugins_section.png

From your script:

.. code::

    if Engine.has_singleton("MyPlugin"):
        var singleton = Engine.get_singleton("MyPlugin")
        print(singleton.myPluginFunction("World"))


Bundling GDNative resources
^^^^^^^^^^^^^^^^^^^^^^^^^^^

An Android plugin can define and provide C/C++ GDNative resources, either to provide and/or access functionality from the game logic.
The GDNative resources can be bundled within the plugin ``aar`` file which simplifies the distribution and deployment process:

- The shared libraries (``.so``) for the defined GDNative libraries will be automatically bundled by the ``aar`` build system.
- Godot ``*.gdnlib`` and ``*.gdns`` resource files must be manually defined in the plugin ``assets`` directory.
  The recommended path for these resources relative to the ``assets`` directory should be: ``godot/plugin/v1/[PluginName]/``.

For GDNative libraries, the plugin singleton object must override the ``org.godotengine.godot.plugin.GodotPlugin::getPluginGDNativeLibrariesPaths()`` method,
and return the paths to the bundled GDNative libraries config files (``*.gdnlib``). The paths must be relative to the ``assets`` directory.
At runtime, the plugin will provide these paths to Godot core which will use them to load and initialize the bundled GDNative libraries.

Reference implementations
^^^^^^^^^^^^^^^^^^^^^^^^^

- `Godot Oculus Mobile plugin <https://github.com/GodotVR/godot_oculus_mobile>`_
  - `Bundled gdnative resources <https://github.com/GodotVR/godot_oculus_mobile/tree/master/plugin/src/main/assets/addons/godot_ovrmobile>`_
- `Godot Google Play Billing plugin <https://github.com/godotengine/godot-google-play-billing>`_


Troubleshooting
---------------

Godot crashes upon load
^^^^^^^^^^^^^^^^^^^^^^^

Check ``adb logcat`` for possible problems, then:

- Check that the methods exposed by the plugin used the following Java types: ``void``, ``boolean``, ``int``, ``float``, ``java.lang.String``, ``org.godotengine.godot.Dictionary``, ``int[]``, ``byte[]``, ``float[]``, ``java.lang.String[]``.
- More complex datatypes are not supported for now.


===================================================
/. ./tutorials/platform/android/android_in_app_purchases.rst
===================================================

.. _doc_android_in_app_purchases:

Android in-app purchases
========================

Godot offers a first-party ``GodotGooglePlayBilling`` Android plugin since Godot 3.2.2.
The new plugin uses the `Google Play Billing library <https://developer.android.com/google/play/billing>`__
instead of the now deprecated AIDL IAP implementation.

If you learn better by looking at an example, you can find the demo project
`here <https://github.com/godotengine/godot-demo-projects/tree/master/mobile/android_iap>`__.


Migrating from Godot 3.2.1 and lower (GodotPaymentsV3)
------------------------------------------------------

The new ``GodotGooglePlayBilling`` API is not compatible with its predecessor ``GodotPaymentsV3``.

Changes
*******

- You need to enable the Custom Build option in your Android export settings and install
  the ``GodotGooglePlayBilling`` plugin manually (see below for details)
- All purchases have to be acknowledged by your app. This is a
  `requirement from Google <https://developer.android.com/google/play/billing/integrate#process>`__.
  Purchases that are not acknowledged by your app will be refunded.
- Support for subscriptions
- Signals (no polling or callback objects)


Usage
-----

Getting started
***************

If not already done, make sure you have enabled and successfully set up :ref:`Android Custom Builds <doc_android_custom_build>`.
Grab the``GodotGooglePlayBilling`` plugin binary and config from the `releases page <https://github.com/godotengine/godot-google-play-billing/releases>`__
and put both into `res://android/plugins`.
The plugin should now show up in the Android export settings, where you can enable it.


Getting started
***************

To use the ``GodotGooglePlayBilling`` API you first have to get the ``GodotGooglePlayBilling``
singleton and start the connection:

::

    var payment

    func _ready():
        if Engine.has_singleton("GodotGooglePlayBilling"):
            payment = Engine.get_singleton("GodotGooglePlayBilling")

            # These are all signals supported by the API
            # You can drop some of these based on your needs
            payment.connect("connected", self, "_on_connected") # No params
            payment.connect("disconnected", self, "_on_disconnected") # No params
            payment.connect("connect_error", self, "_on_connect_error") # Response ID (int), Debug message (string)
            payment.connect("purchases_updated", self, "_on_purchases_updated") # Purchases (Dictionary[])
            payment.connect("purchase_error", self, "_on_purchase_error") # Response ID (int), Debug message (string)
            payment.connect("sku_details_query_completed", self, "_on_sku_details_query_completed") # SKUs (Dictionary[])
            payment.connect("sku_details_query_error", self, "_on_sku_details_query_error") # Response ID (int), Debug message (string), Queried SKUs (string[])
            payment.connect("purchase_acknowledged", self, "_on_purchase_acknowledged") # Purchase token (string)
            payment.connect("purchase_acknowledgement_error", self, "_on_purchase_acknowledgement_error") # Response ID (int), Debug message (string), Purchase token (string)
            payment.connect("purchase_consumed", self, "_on_purchase_consumed") # Purchase token (string)
            payment.connect("purchase_consumption_error", self, "_on_purchase_consumption_error") # Response ID (int), Debug message (string), Purchase token (string)

            payment.startConnection()
        else:
            print("Android IAP support is not enabled. Make sure you have enabled 'Custom Build' and the GodotGooglePlayBilling plugin in your Android export settings! IAP will not work.")

All API methods only work if the API is connected. You can use ``payment.isReady()`` to check the connection status.


Querying available items
************************

As soon as the API is connected, you can query SKUs using ``querySkuDetails``.

Full example:

::

    func _on_connected():
      payment.querySkuDetails(["my_iap_item"], "inapp") # "subs" for subscriptions

    func _on_sku_details_query_completed(sku_details):
      for available_sku in sku_details:
        print(available_sku)


Purchase an item
****************

To initiate the purchase flow for an item, call ``purchase``.
You **must** query the SKU details for an item before you can
initiate the purchase flow for it.

::

    payment.purchase("my_iap_item")

Then, wait for the ``_on_purchases_updated`` callback and handle the purchase result:

::

    func _on_purchases_updated(purchases):
        for purchase in purchases:
            if purchase.purchase_state == 1: # 1 means "purchased", see https://developer.android.com/reference/com/android/billingclient/api/Purchase.PurchaseState#constants_1
                # enable_premium(purchase.sku) # unlock paid content, add coins, save token on server, etc. (you have to implement enable_premium yourself)
                if not purchase.is_acknowledged:                                        
                    payment.acknowledgePurchase(purchase.purchase_token) # call if non-consumable product
                    if purchase.sku in list_of_consumable_products:
                        payment.consumePurchase(purchase.purchase_token) # call if consumable product


Check if the user purchased an item
***********************************

To get all purchases, call ``queryPurchases``. Unlike most of the other functions, ``queryPurchases`` is
a synchronous operation and returns a :ref:`Dictionary <class_Dictionary>` with a status code
and either an array of purchases or an error message. Only active subscriptions and non-consumed one-time purchases are returned.

Full example:

::

    var query = payment.queryPurchases("inapp") # Or "subs" for subscriptions
    if query.status == OK:
        for purchase in query.purchases:
            if purchase.sku == "my_iap_item" and purchase.purchase_state == 1:
                # enable_premium(purchase.sku) # unlock paid content, save token on server, etc.
                if !purchase.is_acknowledged:
                    payment.acknowledgePurchase(purchase.purchase_token)
                    # Or wait for the _on_purchase_acknowledged callback before giving the user what they bought


Consumables
***********

If your in-app item is not a one-time purchase but a consumable item (e.g. coins) which can be purchased
multiple times, you can consume an item by calling ``consumePurchase`` with a purchase token.
Call ``queryPurchases`` to get the purchase token. Calling ``consumePurchase`` automatically
acknowledges a purchase.
Consuming a product allows the user to purchase it again, and removes it from appearing in subsequent ``queryPurchases`` calls.

::

    var query = payment.queryPurchases("inapp") # Or "subs" for subscriptions
    if query.status == OK:
        for purchase in query.purchases:
            if purchase.sku == "my_consumable_iap_item" and purchase.purchase_state == 1:
                # enable_premium(purchase.sku) # add coins, save token on server, etc.
                payment.consumePurchase(purchase.purchase_token)
                # Or wait for the _on_purchase_consumed callback before giving the user what they bought

Subscriptions
*************

Subscriptions don't work much different from regular in-app items. Just use ``"subs"`` as second
argument to ``querySkuDetails`` to get subscription details.
Check ``is_auto_renewing`` in the results of ``queryPurchases()`` to see if a
user has cancelled an auto-renewing subscription


===================================================
/. ./tutorials/platform/ios/index.rst
===================================================

iOS plugins
===========

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-plugins-ios

   ios_plugin
   plugins_for_ios


===================================================
/. ./tutorials/platform/ios/ios_plugin.rst
===================================================

.. _doc_ios_plugin:

Creating iOS plugins
====================

This page explains what iOS plugins can do for you, how to use an existing plugin, and the steps to code a new one.

iOS plugins allow you to use third-party libraries and support iOS-specific features like In-App Purchases, GameCenter integration, ARKit support, and more.

Loading and using an existing plugin
------------------------------------

An iOS plugin requires a ``.gdip`` configuration file, a binary file which can be either ``.a`` static library or ``.xcframework`` containing ``.a`` static libraries, and possibly other dependencies. To use it, you need to:

1. Copy the plugin's files to your Godot project's ``res://ios/plugins`` directory. You can also group files in a sub-directory, like ``res://ios/plugins/my_plugin``.

2. The Godot editor automatically detects and imports ``.gdip`` files inside ``res://ios/plugins`` and its subdirectories.

3. You can find and activate detected plugins by going to Project -> Export... -> iOS and in the Options tab, scrolling to the Plugins section.

.. image:: img/ios_export_preset_plugins_section.png

When a plugin is active, you can access it in your using ``Engine.get_singleton()``::

    if Engine.has_singleton("MyPlugin"):
        var singleton = Engine.get_singleton("MyPlugin")
        print(singleton.foo())

Creating an iOS plugin
----------------------

At its core, a Godot iOS plugin is an iOS library (*.a* archive file or *.xcframework* containing static libraries) with the following requirements:

- The library must have a dependency on the Godot engine headers.

- The library must come with a ``.gdip`` configuration file.

An iOS plugin can have the same functionality as a Godot module but provides more flexibility and doesn't require to rebuild the engine.

Here are the steps to get a plugin's development started. We recommend using `Xcode <https://developer.apple.com/develop/>`_ as your development environment.

.. seealso:: The `Godot iOS Plugins <https://github.com/godotengine/godot-ios-plugins>`_ Godot iOS plugins.

    The `Godot iOS plugin template <https://github.com/naithar/godot_ios_plugin>`_ gives you all the boilerplate you need to get your iOS plugin started.


To build an iOS plugin:

1. Create an Objective-C static library for your plugin inside Xcode.

2. Add the Godot engine header files as a dependency for your plugin library in ``HEADER_SEARCH_PATHS``. You can find the setting inside the ``Build Settings`` tab:

    - Download the Godot engine source from the `Godot GitHub page <https://github.com/godotengine/godot>`_.

    - Run SCons to generate headers. You can learn the process by reading :ref:`doc_compiling_for_ios`. You don't have to wait for compilation to complete to move forward as headers are generated before the engine starts to compile.

    - You should use the same header files for iOS plugins and for the iOS export template.

3. In the ``Build Settings`` tab, specify the compilation flags for your static library in ``OTHER_CFLAGS``. The most important ones are ``-fcxx-modules``, ``-fmodules``, and ``-DDEBUG`` if you need debug support. Other flags should be the same you use to compile Godot. For instance:

::

    -DPTRCALL_ENABLED -DDEBUG_ENABLED -DDEBUG_MEMORY_ALLOC -DDISABLE_FORCED_INLINE -DTYPED_METHOD_BIND

4. Add the required logic for your plugin and build your library to generate a ``.a`` file. You will probably need to build both ``debug`` and ``release`` target ``.a`` files. Depending on your needs, pick either or both. If you need both debug and release ``.a`` files, their name should match following pattern: ``[PluginName].[TargetType].a``. You can also build the static library with your SCons configuration.

5. The iOS plugin system also supports ``.xcframework`` files. To generate one, you can use a command such as:

::

    xcodebuild -create-xcframework -library [DeviceLibrary].a -library [SimulatorLibrary].a -output [PluginName].xcframework

6. Create a Godot iOS Plugin configuration file to help the system detect and load your plugin:

    -   The configuration file extension must be ``gdip`` (e.g.: ``MyPlugin.gdip``).

    -   The configuration file format is as follow::

            [config]
            name="MyPlugin"
            binary="MyPlugin.a"

            initialization="init_my_plugin"
            deinitialization="deinit_my_plugin"

            [dependencies]
            linked=[]
            embedded=[]
            system=["Foundation.framework"]

            capabilities=["arkit", "metal"]

            files=["data.json"]

            linker_flags=["-ObjC"]

            [plist]
            PlistKeyWithDefaultType="Some Info.plist key you might need"
            StringPlistKey:string="String value"
            IntegerPlistKey:integer=42
            BooleanPlistKey:boolean=true
            RawPlistKey:raw="
            <array>
                <string>UIInterfaceOrientationPortrait</string>
            </array>
            "
            StringPlistKeyToInput:string_input="Type something"

        The ``config`` section and fields are required and defined as follow:

            -   **name**: name of the plugin

            -   **binary**: this should be the filepath of the plugin library (``a`` or ``xcframework``) file.

                -   The filepath can be relative (e.g.: ``MyPlugin.a``, ``MyPlugin.xcframework``) in which case it's relative to the directory where the ``gdip`` file is located.
                -   The filepath can be absolute: ``res://some_path/MyPlugin.a`` or ``res://some_path/MyPlugin.xcframework``.
                -   In case you need multitarget library usage, the filename should be ``MyPlugin.a`` and ``.a`` files should be named as ``MyPlugin.release.a`` and ``MyPlugin.debug.a``.
                -   In case you use multitarget ``xcframework`` libraries, their filename in the configuration should be ``MyPlugin.xcframework``. The ``.xcframework`` files should be named as ``MyPlugin.release.xcframework`` and ``MyPlugin.debug.xcframework``.

        The ``dependencies`` and ``plist`` sections are optional and defined as follow:

            -   **dependencies**:

                -   **linked**: contains a list of iOS frameworks that the iOS application should be linked with.

                -   **embedded**: contains a list of iOS frameworks or libraries that should be both linked and embedded into the resulting iOS application.

                -   **system**: contains a list of iOS system frameworks that are required for plugin.

                -   **capabilities**: contains a list of iOS capabilities that is required for plugin. A list of available capabilities can be found at `Apple UIRequiredDeviceCapabilities documentation page <https://developer.apple.com/documentation/bundleresources/information_property_list/uirequireddevicecapabilities>`_.

                -   **files**: contains a list of files that should be copied on export. This is useful for data files or images.

                -   **linker_flags**: contains a list of linker flags to add to the Xcode project when exporting the plugin.

            -   **plist**: should have keys and values that should be present in ``Info.plist`` file.

                -   Each line should follow pattern: ``KeyName:KeyType=KeyValue``
                -   Supported values for ``KeyType`` are ``string``, ``integer``, ``boolean``, ``raw``, ``string_input``
                -   If no type is used (e.g.: ``KeyName="KeyValue"``) ``string`` type will be used.
                -   If ``raw`` type is used value for coresponding key will be stored in ``Info.plist`` as is.
                -   If ``string_input`` type is used you will be able to modify value in Export window.


===================================================
/. ./tutorials/platform/ios/plugins_for_ios.rst
===================================================

.. _doc_plugins_for_ios:

Plugins for iOS
===============

Godot provides StoreKit, GameCenter, iCloud services and other plugins.
They are using same model of asynchronous calls explained below.

ARKit and Camera access are also provided as plugins.

Latest updates, documentation and source code can be found at `Godot iOS plugins repository <https://github.com/godotengine/godot-ios-plugins>`_

Accessing plugin singletons
---------------------------

To access plugin functionality, you first need to check that the plugin is
exported and available by calling the `Engine.has_singleton()` function, which
returns a registered singleton.

Here's an example of how to do this in GDScript:

::

    var in_app_store
    var game_center

    func _ready():
        if Engine.has_singleton("InAppStore"):
            in_app_store = Engine.get_singleton("InAppStore")
        else:
            print("iOS IAP plugin is not available on this platform.")

        if Engine.has_singleton("GameCenter"):
            game_center = Engine.get_singleton("GameCenter")
        else:
            print("iOS Game Center plugin is not available on this platform.")


Asynchronous methods
--------------------

When requesting an asynchronous operation, the method will look like
this:

::

    Error purchase(Variant params);

The parameter will usually be a Dictionary, with the information
necessary to make the request, and the call will have two phases. First,
the method will immediately return an Error value. If the Error is not
'OK', the call operation is completed, with an error probably caused
locally (no internet connection, API incorrectly configured, etc). If
the error value is 'OK', a response event will be produced and added to
the 'pending events' queue. Example:

::

    func on_purchase_pressed():
        var result = InAppStore.purchase({ "product_id": "my_product" })
        if result == OK:
            animation.play("busy") # show the "waiting for response" animation
        else:
            show_error()

    # put this on a 1 second timer or something
    func check_events():
        while in_app_store.get_pending_event_count() > 0:
            var event = in_app_store.pop_pending_event()
            if event.type == "purchase":
                if event.result == "ok":
                    show_success(event.product_id)
                else:
                    show_error()

Remember that when a call returns OK, the API will *always* produce an
event through the pending_event interface, even if it's an error, or a
network timeout, etc. You should be able to, for example, safely block
the interface waiting for a reply from the server. If any of the APIs
don't behave this way it should be treated as a bug.

The pending event interface consists of two methods:

-  ``get_pending_event_count()``
   Returns the number of pending events on the queue.

-  ``Variant pop_pending_event()``
   Pops the first event from the queue and returns it.

Store Kit
---------

Implemented in `Godot iOS InAppStore plugin <https://github.com/godotengine/godot-ios-plugins/blob/master/plugins/inappstore/in_app_store.mm>`_.

The Store Kit API is accessible through the ``InAppStore`` singleton.
It is initialized automatically.

The following methods are available and documented below:

::

    Error purchase(Variant params)
    Error request_product_info(Variant params)
    Error restore_purchases()
    void set_auto_finish_transaction(bool enable)
    void finish_transaction(String product_id)

 and the pending events interface:

 ::

    int get_pending_event_count()
    Variant pop_pending_event()

``purchase``
~~~~~~~~~~~~

Purchases a product ID through the Store Kit API. You have to call ``finish_transaction(product_id)`` once you
receive a successful response or call ``set_auto_finish_transaction(true)`` prior to calling ``purchase()``.
These two methods ensure the transaction is completed.

Parameters
^^^^^^^^^^

Takes a dictionary as a parameter, with one field, ``product_id``, a
string with your product ID. Example:

::

    var result = in_app_store.purchase({ "product_id": "my_product" })

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "purchase",
      "result": "error",
      "product_id": "the product ID requested",
    }

On success:

::

    {
      "type": "purchase",
      "result": "ok",
      "product_id": "the product ID requested",
    }

``request_product_info``
~~~~~~~~~~~~~~~~~~~~~~~~

Requests the product info on a list of product IDs.

Parameters
^^^^^^^^^^

Takes a dictionary as a parameter, with a single ``product_ids`` key to which a
string array of product IDs is assigned. Example:

::

    var result = in_app_store.request_product_info({ "product_ids": ["my_product1", "my_product2"] })

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

::

    {
      "type": "product_info",
      "result": "ok",
      "invalid_ids": [ list of requested IDs that were invalid ],
      "ids": [ list of IDs that were valid ],
      "titles": [ list of valid product titles (corresponds with list of valid IDs) ],
      "descriptions": [ list of valid product descriptions ] ,
      "prices": [ list of valid product prices ],
      "localized_prices": [ list of valid product localized prices ],
    }

``restore_purchases``
~~~~~~~~~~~~~~~~~~~~~

Restores previously made purchases on user's account. This will create
response events for each previously purchased product ID.

Response event
^^^^^^^^^^^^^^

The response events will be dictionaries with the following fields:

::

    {
      "type": "restore",
      "result": "ok",
      "product_id": "product ID of restored purchase",
    }

``set_auto_finish_transaction``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If set to ``true``, once a purchase is successful, your purchase will be
finalized automatically. Call this method prior to calling ``purchase()``.

Parameters
^^^^^^^^^^

Takes a boolean as a parameter which specifies if purchases should be
automatically finalized. Example:

::

    in_app_store.set_auto_finish_transaction(true)

``finish_transaction``
~~~~~~~~~~~~~~~~~~~~~~

If you don't want transactions to be automatically finalized, call this
method after you receive a successful purchase response.


Parameters
^^^^^^^^^^

Takes a string ``product_id`` as an argument. ``product_id`` specifies what product to
finalize the purchase on. Example:

::

    in_app_store.finish_transaction("my_product1")

Game Center
-----------

Implemented in `Godot iOS GameCenter plugin <https://github.com/godotengine/godot-ios-plugins/blob/master/plugins/gamecenter/game_center.mm>`_.

The Game Center API is available through the "GameCenter" singleton. It
has the following methods:

::

    Error authenticate()
    bool is_authenticated()
    Error post_score(Variant score)
    Error award_achievement(Variant params)
    void reset_achievements()
    void request_achievements()
    void request_achievement_descriptions()
    Error show_game_center(Variant params)
    Error request_identity_verification_signature()

and the pending events interface:

::

    int get_pending_event_count()
    Variant pop_pending_event()

``authenticate``
~~~~~~~~~~~~~~~~

Authenticates a user in Game Center.

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "authentication",
      "result": "error",
      "error_code": the value from NSError::code,
      "error_description": the value from NSError::localizedDescription,
    }

On success:

::

    {
      "type": "authentication",
      "result": "ok",
      "player_id": the value from GKLocalPlayer::playerID,
    }

``post_score``
~~~~~~~~~~~~~~

Posts a score to a Game Center leaderboard.

Parameters
^^^^^^^^^^

Takes a dictionary as a parameter, with two fields:

-  ``score`` a float number
-  ``category`` a string with the category name

Example:

::

    var result = game_center.post_score({ "score": 100, "category": "my_leaderboard", })

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "post_score",
      "result": "error",
      "error_code": the value from NSError::code,
      "error_description": the value from NSError::localizedDescription,
    }

On success:

::

    {
      "type": "post_score",
      "result": "ok",
    }

``award_achievement``
~~~~~~~~~~~~~~~~~~~~~

Modifies the progress of a Game Center achievement.

Parameters
^^^^^^^^^^

Takes a Dictionary as a parameter, with 3 fields:

-  ``name`` (string) the achievement name
-  ``progress`` (float) the achievement progress from 0.0 to 100.0
   (passed to ``GKAchievement::percentComplete``)
-  ``show_completion_banner`` (bool) whether Game Center should display
   an achievement banner at the top of the screen

Example:

::

    var result = award_achievement({ "name": "hard_mode_completed", "progress": 6.1 })

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "award_achievement",
      "result": "error",
      "error_code": the error code taken from NSError::code,
    }

On success:

::

    {
      "type": "award_achievement",
      "result": "ok",
    }

``reset_achievements``
~~~~~~~~~~~~~~~~~~~~~~

Clears all Game Center achievements. The function takes no parameters.

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "reset_achievements",
      "result": "error",
      "error_code": the value from NSError::code,
    }

On success:

::

    {
      "type": "reset_achievements",
      "result": "ok",
    }

``request_achievements``
~~~~~~~~~~~~~~~~~~~~~~~~

Request all the Game Center achievements the player has made progress
on. The function takes no parameters.

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "achievements",
      "result": "error",
      "error_code": the value from NSError::code,
    }

On success:

::

    {
      "type": "achievements",
      "result": "ok",
      "names": [ list of the name of each achievement ],
      "progress": [ list of the progress made on each achievement ],
    }

``request_achievement_descriptions``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Request the descriptions of all existing Game Center achievements
regardless of progress. The function takes no parameters.

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On error:

::

    {
      "type": "achievement_descriptions",
      "result": "error",
      "error_code": the value from NSError::code,
    }

On success:

::

    {
      "type": "achievement_descriptions",
      "result": "ok",
      "names": [ list of the name of each achievement ],
      "titles": [ list of the title of each achievement ],
      "unachieved_descriptions": [ list of the description of each achievement when it is unachieved ],
      "achieved_descriptions": [ list of the description of each achievement when it is achieved ],
      "maximum_points": [ list of the points earned by completing each achievement ],
      "hidden": [ list of booleans indicating whether each achievement is initially visible ],
      "replayable": [ list of booleans indicating whether each achievement can be earned more than once ],
    }

``show_game_center``
~~~~~~~~~~~~~~~~~~~~

Displays the built in Game Center overlay showing leaderboards,
achievements, and challenges.

Parameters
^^^^^^^^^^

Takes a Dictionary as a parameter, with two fields:

-  ``view`` (string) (optional) the name of the view to present. Accepts
   "default", "leaderboards", "achievements", or "challenges". Defaults
   to "default".
-  ``leaderboard_name`` (string) (optional) the name of the leaderboard
   to present. Only used when "view" is "leaderboards" (or "default" is
   configured to show leaderboards). If not specified, Game Center will
   display the aggregate leaderboard.

Examples:

::

    var result = show_game_center({ "view": "leaderboards", "leaderboard_name": "best_time_leaderboard" })
    var result = show_game_center({ "view": "achievements" })

Response event
^^^^^^^^^^^^^^

The response event will be a dictionary with the following fields:

On close:

::

    {
      "type": "show_game_center",
      "result": "ok",
    }

Multi-platform games
--------------------

When working on a multi-platform game, you won't always have the
"GameCenter" singleton available (for example when running on PC or
Android). Because the gdscript compiler looks up the singletons at
compile time, you can't just query the singletons to see and use what
you need inside a conditional block, you need to also define them as
valid identifiers (local variable or class member). This is an example
of how to work around this in a class:

::

    var GameCenter = null # define it as a class member

    func post_score(score):
        if GameCenter == null:
            return
        GameCenter.post_score({ "value": score, "category": "my_leaderboard" })

    func check_events():
        while GameCenter.get_pending_event_count() > 0:
            # do something with events here
            pass

    func _ready():
        # check if the singleton exists
        if Globals.has_singleton("GameCenter"):
            GameCenter = Globals.get_singleton("GameCenter")
            # connect your timer here to the "check_events" function


===================================================
/. ./tutorials/platform/platform_html5.rst
===================================================

.. _doc_platform_html5:

HTML5
=====

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-platform-html5

   html5_shell_classref
   customizing_html5_shell


===================================================
/. ./tutorials/platform/html5_shell_classref.rst
===================================================

.. _doc_html5_shell_classref:

HTML5 shell class reference
===========================

Projects exported for the Web expose the :js:class:`Engine` class to the JavaScript environment, that allows
fine control over the engine's start-up process.

This API is built in an asynchronous manner and requires basic understanding
of `Promises <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>`__.

Engine
------

The ``Engine`` class provides methods for loading and starting exported projects on the Web. For default export
settings, this is already part of the exported HTML page. To understand practical use of the ``Engine`` class,
see :ref:`Custom HTML page for Web export <doc_customizing_html5_shell>`.

Static Methods
^^^^^^^^^^^^^^

+---------+-----------------------------------------------------------------------------------------------+
| Promise | :js:attr:`load <Engine.load>` **(** string basePath **)**                                     |
+---------+-----------------------------------------------------------------------------------------------+
| void    | :js:attr:`unload <Engine.unload>` **(** **)**                                                 |
+---------+-----------------------------------------------------------------------------------------------+
| boolean | :js:attr:`isWebGLAvailable <Engine.isWebGLAvailable>` **(** *[ number majorVersion=1 ]* **)** |
+---------+-----------------------------------------------------------------------------------------------+

Instance Methods
^^^^^^^^^^^^^^^^

+---------+---------------------------------------------------------------------------------------------------------------+
| Promise | :js:attr:`init <Engine.prototype.init>` **(** *[ string basePath ]* **)**                                     |
+---------+---------------------------------------------------------------------------------------------------------------+
| Promise | :js:attr:`preloadFile <Engine.prototype.preloadFile>` **(** string\|ArrayBuffer file *[, string path ]* **)** |
+---------+---------------------------------------------------------------------------------------------------------------+
| Promise | :js:attr:`start <Engine.prototype.start>` **(** EngineConfig override **)**                                   |
+---------+---------------------------------------------------------------------------------------------------------------+
| Promise | :js:attr:`startGame <Engine.prototype.startGame>` **(** EngineConfig override **)**                           |
+---------+---------------------------------------------------------------------------------------------------------------+
| void    | :js:attr:`copyToFS <Engine.prototype.copyToFS>` **(** string path, ArrayBuffer buffer **)**                   |
+---------+---------------------------------------------------------------------------------------------------------------+
| void    | :js:attr:`requestQuit <Engine.prototype.requestQuit>` **(** **)**                                             |
+---------+---------------------------------------------------------------------------------------------------------------+

.. js:class:: Engine( initConfig )

   Create a new Engine instance with the given configuration.

   :param EngineConfig initConfig:
      The initial config for this instance.

   **Static Methods**

   .. js:function:: load( basePath )

      Load the engine from the specified base path.

      :param string basePath:
         Base path of the engine to load.

      :return:
         A Promise that resolves once the engine is loaded.

      :rtype: Promise

   .. js:function:: unload( )

      Unload the engine to free memory.

      This method will be called automatically depending on the configuration. See :js:attr:`unloadAfterInit`.

   .. js:function:: isWebGLAvailable( [ majorVersion=1 ] )

      Check whether WebGL is available. Optionally, specify a particular version of WebGL to check for.

      :param number majorVersion:
         The major WebGL version to check for.

      :return:
         If the given major version of WebGL is available.

      :rtype: boolean

   **Instance Methods**

   .. js:function:: prototype.init( [ basePath ] )

      Initialize the engine instance. Optionally, pass the base path to the engine to load it,
      if it hasn't been loaded yet. See :js:meth:`Engine.load`.

      :param string basePath:
         Base path of the engine to load.

      :return:
         A ``Promise`` that resolves once the engine is loaded and initialized.

      :rtype: Promise

   .. js:function:: prototype.preloadFile( file [, path ] )

      Load a file so it is available in the instance's file system once it runs. Must be called **before** starting the
      instance.

      If not provided, the ``path`` is derived from the URL of the loaded file.

      :param string\|ArrayBuffer file:
         The file to preload.

         If a ``string`` the file will be loaded from that path.

         If an ``ArrayBuffer`` or a view on one, the buffer will used as the content of the file.

      :param string path:
         Path by which the file will be accessible. Required, if ``file`` is not a string.

      :return:
         A Promise that resolves once the file is loaded.

      :rtype: Promise

   .. js:function:: prototype.start( override )

      Start the engine instance using the given override configuration (if any).
      :js:meth:`startGame <Engine.prototype.startGame>` can be used in typical cases instead.

      This will initialize the instance if it is not initialized. For manual initialization, see :js:meth:`init <Engine.prototype.init>`.
      The engine must be loaded beforehand.

      Fails if a canvas cannot be found on the page, or not specified in the configuration.

      :param EngineConfig override:
         An optional configuration override.

      :return:
         Promise that resolves once the engine started.

      :rtype: Promise

   .. js:function:: prototype.startGame( override )

      Start the game instance using the given configuration override (if any).

      This will initialize the instance if it is not initialized. For manual initialization, see :js:meth:`init <Engine.prototype.init>`.

      This will load the engine if it is not loaded, and preload the main pck.

      This method expects the initial config (or the override) to have both the :js:attr:`executable` and :js:attr:`mainPack`
      properties set (normally done by the editor during export).

      :param EngineConfig override:
         An optional configuration override.

      :return:
         Promise that resolves once the game started.

      :rtype: Promise

   .. js:function:: prototype.copyToFS( path, buffer )

      Create a file at the specified ``path`` with the passed as ``buffer`` in the instance's file system.

      :param string path:
         The location where the file will be created.

      :param ArrayBuffer buffer:
         The content of the file.

   .. js:function:: prototype.requestQuit( )

      Request that the current instance quit.

      This is akin the user pressing the close button in the window manager, and will
      have no effect if the engine has crashed, or is stuck in a loop.

Engine configuration
--------------------

An object used to configure the Engine instance based on godot export options, and to override those in custom HTML
templates if needed.

Properties
^^^^^^^^^^

+-------------------+-------------------------------+
| type              | name                          |
+-------------------+-------------------------------+
| boolean           | :js:attr:`unloadAfterInit`    |
+-------------------+-------------------------------+
| HTMLCanvasElement | :js:attr:`canvas`             |
+-------------------+-------------------------------+
| string            | :js:attr:`executable`         |
+-------------------+-------------------------------+
| string            | :js:attr:`mainPack`           |
+-------------------+-------------------------------+
| string            | :js:attr:`locale`             |
+-------------------+-------------------------------+
| number            | :js:attr:`canvasResizePolicy` |
+-------------------+-------------------------------+
| Array.<string>    | :js:attr:`args`               |
+-------------------+-------------------------------+
| function          | :js:attr:`onExecute`          |
+-------------------+-------------------------------+
| function          | :js:attr:`onExit`             |
+-------------------+-------------------------------+
| function          | :js:attr:`onProgress`         |
+-------------------+-------------------------------+
| function          | :js:attr:`onPrint`            |
+-------------------+-------------------------------+
| function          | :js:attr:`onPrintError`       |
+-------------------+-------------------------------+

.. js:attribute:: EngineConfig

   The Engine configuration object. This is just a typedef, create it like a regular object, e.g.:

   ``const MyConfig = { executable: 'godot', unloadAfterInit: false }``

   **Property Descriptions**

   .. js:attribute:: unloadAfterInit

      Whether the unload the engine automatically after the instance is initialized.

      :type: boolean

      :value: ``true``

   .. js:attribute:: canvas

      The HTML DOM Canvas object to use.

      By default, the first canvas element in the document will be used is none is specified.

      :type: HTMLCanvasElement

      :value: ``null``

   .. js:attribute:: executable

      The name of the WASM file without the extension. (Set by Godot Editor export process).

      :type: string

      :value: ``""``

   .. js:attribute:: mainPack

      An alternative name for the game pck to load. The executable name is used otherwise.

      :type: string

      :value: ``null``

   .. js:attribute:: locale

      Specify a language code to select the proper localization for the game.

      The browser locale will be used if none is specified. See complete list of
      :ref:`supported locales <doc_locales>`.

      :type: string

      :value: ``null``

   .. js:attribute:: canvasResizePolicy

      The canvas resize policy determines how the canvas should be resized by Godot.

      ``0`` means Godot won't do any resizing. This is useful if you want to control the canvas size from
      javascript code in your template.

      ``1`` means Godot will resize the canvas on start, and when changing window size via engine functions.

      ``2`` means Godot will adapt the canvas size to match the whole browser window.

      :type: number

      :value: ``2``

   .. js:attribute:: args

      The arguments to be passed as command line arguments on startup.

      See :ref:`command line tutorial <doc_command_line_tutorial>`.

      **Note**: :js:meth:`startGame <Engine.prototype.startGame>` will always add the ``--main-pack`` argument.

      :type: Array.<string>

      :value: ``[]``

   .. js:function:: onExecute( path, args )

      A callback function for handling Godot's ``OS.execute`` calls.

      This is for example used in the Web Editor template to switch between project manager and editor, and for running the game.

      :param string path:
         The path that Godot's wants executed.

      :param Array.<string> args:
         The arguments of the "command" to execute.

   .. js:function:: onExit( status_code )

      A callback function for being notified when the Godot instance quits.

      **Note**: This function will not be called if the engine crashes or become unresponsive.

      :param number status_code:
         The status code returned by Godot on exit.

   .. js:function:: onProgress( current, total )

      A callback function for displaying download progress.

      The function is called once per frame while downloading files, so the usage of ``requestAnimationFrame()``
      is not necessary.

      If the callback function receives a total amount of bytes as 0, this means that it is impossible to calculate.
      Possible reasons include:

      -  Files are delivered with server-side chunked compression
      -  Files are delivered with server-side compression on Chromium
      -  Not all file downloads have started yet (usually on servers without multi-threading)

      :param number current:
         The current amount of downloaded bytes so far.

      :param number total:
         The total amount of bytes to be downloaded.

   .. js:function:: onPrint( [ ...var_args ] )

      A callback function for handling the standard output stream. This method should usually only be used in debug pages.

      By default, ``console.log()`` is used.

      :param * var_args:
         A variadic number of arguments to be printed.

   .. js:function:: onPrintError( [ ...var_args ] )

      A callback function for handling the standard error stream. This method should usually only be used in debug pages.

      By default, ``console.error()`` is used.

      :param * var_args:
         A variadic number of arguments to be printed as errors.



===================================================
/. ./tutorials/platform/customizing_html5_shell.rst
===================================================

.. _doc_customizing_html5_shell:

Custom HTML page for Web export
====================================

While Web export templates provide a default HTML page fully capable of launching
the project without any further customization, it may be beneficial to create a custom
HTML page. While the game itself cannot easily be directly controlled from the outside yet,
such page allows to customize the initialization process for the engine.

Some use-cases where customizing the default page is useful include:

- Loading files from a different directory than the page;
- Loading a ``.zip`` file instead of a ``.pck`` file as the main pack;
- Loading the engine from a different directory than the main pack file;
- Adding a click-to-play button so that games can be started in the fullscreen mode;
- Loading some extra files before the engine starts, making them available in
  the project file system as soon as possible;
- Passing custom command line arguments, e.g. ``-s`` to start a ``MainLoop`` script.

The default HTML page is available in the Godot Engine repository at
`/misc/dist/html/full-size.html <https://github.com/godotengine/godot/blob/master/misc/dist/html/full-size.html>`__
but the following template can be used as a much simpler example:

.. code-block:: html

    <!DOCTYPE html>
    <html>
        <head>
            <title>My Template</title>
            <meta charset="UTF-8">
        </head>
        <body>
            <canvas id="canvas"></canvas>
            <script src="$GODOT_URL"></script>
            <script>
                var engine = new Engine($GODOT_CONFIG);
                engine.startGame();
            </script>
        </body>
    </html>

Setup
-----
As shown by the example above, it is mostly a regular HTML document, with few placeholders
which needs to be replaced during export, an html ``<canvas>`` element, and some simple
JavaScript code that calls the :js:class:`Engine` class.

The only required placeholders are:

- ``$GODOT_URL``:
  The name of the main JavaScript file, which provides the :js:class:`Engine` class required
  to start the engine and that must be included in the HTML as a ``<script>``.
  The name is generated from the *Export Path* during the export process.

- ``$GODOT_CONFIG``:
  A JavaScript object, containing the export options and can be later overridden.
  See :js:attr:`EngineConfig` for the full list of overrides.

The following optional placeholders will enable some extra features in your custom HTML template.

- ``$GODOT_PROJECT_NAME``:
  The project name as defined in the Project Settings. It is a good idea to use it as a ``<title>``
  in your template.

- ``$GODOT_HEAD_INCLUDE``:
  A custom string to include in the HTML document just before the end of the ``<head>`` tag. It
  is customized in the export options under the *Html / Head Include* section. While you fully
  control the HTML page you create, this variable can be useful for configuring parts of the
  HTML ``head`` element from the Godot Editor, e.g. for different Web export presets.

When the custom page is ready, it can be selected in the export options under the *Html / Custom Html Shell*
section.

.. image:: img/html5_export_options.png

Starting the project
--------------------
To be able to start the game, you need to write a script that initializes the engine — the control
code. This process consists of three steps, though as shown most of them can be skipped depending on
how much customization is needed (or be left to a default behavior).

See the :ref:`HTML5 shell class reference <doc_html5_shell_classref>`, for the full list of methods and options available.

First, the engine must be loaded, then it needs to be initialized, and after this the project
can finally be started. You can perform every of these steps manually and with great control.
However, in the simplest case all you need to do is to create an instance of the :js:class:`Engine`
class with the exported configuration, and then call the :js:meth:`engine.startGame <Engine.prototype.startGame>` method
optionally overriding any :js:attr:`EngineConfig` parameters.

.. code-block:: js

    const engine = new Engine($GODOT_CONFIG);
    engine.startGame({
        /* optional override configuration, eg. */
        // unloadAfterInit: false,
        // canvasResizePolicy: 0,
        // ...
    });

This snippet of code automatically loads and initializes the engine before starting the game.
It uses the given configuration to to load the engine. The :js:meth:`engine.startGame <Engine.prototype.startGame>`
method is asynchronous and returns a ``Promise``. This allows your control code to track if
the game was loaded correctly without blocking execution or relying on polling.

In case your project needs to have special control over the start arguments and dependency files,
the :js:meth:`engine.start <Engine.prototype.start>` method can be used instead. Note, that this method do not
automatically preload the ``pck`` file, so you will probably want to manually preload it
(and any other extra file) via the :js:meth:`engine.preloadFile <Engine.prototype.preloadFile>` method.

Optionally, you can also manually :js:meth:`engine.init <Engine.prototype.init>` to perform specific actions after
the module initialization, but before the engine starts.

This process is a bit more complex, but gives you full control over the engine startup process.

.. code-block:: js

    const myWasm = 'mygame.wasm';
    const myPck = 'mygame.pck';
    const engine = new Engine();
    Promise.all([
        // Load and init the engine
        engine.init(myWasm),
        // And the pck concurrently
        engine.preloadFile(myPck),
    ]).then(() => {
        // Now start the engine.
        return engine.start({ args: ['--main-pack', myPck] });
    }).then(() => {
        console.log('Engine has started!');
    });

To load the engine manually the :js:meth:`Engine.load` static method must be called. As
this method is static, multiple engine instances can be spawned if the share the same ``wasm``.

.. note:: Multiple instances cannot be spawned by default, as the engine is immediately unloaded after it is initialized.
          To prevent this from happening see the :js:attr:`unloadAfterInit` override option. It is still possible
          to unload the engine manually afterwards by calling the :js:meth:`Engine.unload` static method. Unloading the engine
          frees browser memory by unloading files that are no longer needed once the instance is initialized.

Customizing the behavior
------------------------
In the Web environment several methods can be used to guarantee that the game will work as intended.

If you target a specific version of WebGL, or just want to check if WebGL is available at all,
you can call the :js:meth:`Engine.isWebGLAvailable` method. It optionally takes an argument that
allows to test for a specific major version of WebGL.

As the real executable file does not exist in the Web environment, the engine only stores a virtual
filename formed from the base name of loaded engine files. This value affects the output of the
:ref:`OS.get_executable_path() <class_OS_method_get_executable_path>` method and defines the name of
the automatically started main pack. The :js:attr:`executable` override option can be
used to override this value.

Customizing the presentation
----------------------------
Several configuration options can be used to further customize the look and behavior of the game on your page.

By default, the first canvas element on the page is used for rendering. To use a different canvas
element the :js:attr:`canvas` override option can be used. It requires a reference to the DOM
element itself.

.. code-block:: js

    const canvasElement = document.querySelector("#my-canvas-element");
    engine.startGame({ canvas: canvasElement });

The way the engine resize the canvas can be configured via the :js:attr:`canvasResizePolicy`
override option.

If your game takes some time to load, it may be useful to display a custom loading UI which tracks
the progress. This can be achieved with the :js:attr:`onProgress` callback option, which
allows to set up a callback function that will be called regularly as the engine loads new bytes.

.. code-block:: js

    function printProgress(current, total) {
        console.log("Loaded " + current + " of " + total + " bytes");
    }
    engine.startGame({ onProgress: printProgress });

Be aware that in some cases ``total`` can be ``0``. This means that it cannot be calculated.

If your game supports multiple languages, the :js:attr:`locale` override option can be used to
force a specific locale, provided you have a valid language code string. It may be good to use server-side
logic to determine which languages a user may prefer. This way the language code can be taken from the
``Accept-Language`` HTTP header, or determined by a GeoIP service.

Debugging
---------
To debug exported projects, it may be useful to read the standard output and error streams generated
by the engine. This is similar to the output shown in the editor console window. By default, standard
``console.log`` and ``console.warn`` are used for the output and error streams respectively. This
behavior can be customized by setting your own functions to handle messages.

Use the :js:attr:`onPrint` override option to set a callback function for the output stream,
and the :js:attr:`onPrintError` override option to set a callback function for the error stream.

.. code-block:: js

    function print(text) {
        console.log(text);
    }
    function printError(text) {
        console.warn(text);
    }
    engine.startGame({ onPrint: print, onPrintError: printError });

When handling the engine output keep in mind, that it may not be desirable to print it out in the
finished product.


===================================================
/. ./tutorials/platform/consoles.rst
===================================================

.. _doc_consoles:

Console support in Godot
========================

Console publishing process
--------------------------

Regardless of the engine used to create the game, the process to publish a game
to a console platform is as follows:

- Register a developer account on the console manufacturer's website, then sign
  NDAs and publishing contracts. This requires you to have a registered legal
  entity.
- Gain access to the publishing platform by passing the acceptance process. This
  can take up to several months. Note that this step is significantly easier if
  an established publisher is backing your game. Nintendo is generally known to
  be more accepting of smaller developers, but this is not guaranteed.
- Get access to developer tools and order a console specially made for
  developers (*devkit*). The cost of those devkits is confidential.
- Port the engine to the console platform or pay a company to do it.
- To be published, your game needs to be rated in the regions you'd like to sell
  it in. For example, in North America, the `ESRB <https://www.esrb.org/>`__
  handles game ratings. In Europe, this is done by
  `PEGI <https://pegi.info/>`__. Indie developers can generally get a rating
  for cheaper compared to more established developers.

Due to the complexity of the process, the budget to publish a game by yourself on a
single console often exceeds $1,000 (this is a rough figure).

Official support
----------------

Godot supports the Linux-based Steam Deck. The reason other consoles are not
officially supported are:

- To develop for consoles, one must be licensed as a company.
  As an open source project, Godot does not have such a legal figure.
- Console SDKs are secret and covered by non-disclosure agreements.
  Even if we could get access to them, we could not publish
  the platform-specific code under an open source license.
- Consoles require specialized hardware to develop for, so regular individuals
  can't create games for them anyway.

However, it is still possible to port your games to consoles thanks to services
provided by third-party companies.

.. note::

    In practice, the process is quite similar to Unity and Unreal Engine, except
    that you need to contact a third-party developer to handle the porting
    process. In other words, there is no engine that is legally allowed to
    distribute console export templates without requiring the user to prove that
    they are a licensed console developer. Doing so would violate the console
    manufacturer's NDA.

Third-party support
-------------------

Console ports of Godot are offered by third-party companies (which have
ported Godot on their own). These companies also offer publishing of
your games to various consoles.

Following is the list of providers:

- `Lone Wolf Technology <http://www.lonewolftechnology.com/>`_ offers
  Switch and PS4 porting and publishing of Godot games.
- `Pineapple Works <https://pineapple.works/>`_ offers
  Switch, Xbox One & Xbox Series X/S (GDK) porting and publishing of Godot games (GDScript/C#).
- `RAWRLAB games <https://www.rawrlab.com/>`_ offers
  Switch porting of Godot games.
- `mazette! games <https://mazette.games/>`_ offers
  Switch, Xbox One and Xbox Series X/S porting and publishing of Godot games.

If your company offers porting, or porting *and* publishing services for Godot games,
feel free to
`open an issue or pull request <https://github.com/godotengine/godot-docs>`_
to add your company to the list above.


===================================================
/. ./tutorials/platform/mobile_rendering_limitations.rst
===================================================

.. _doc_mobile_rendering_limitations:

Mobile rendering limitations
============================

.. seealso::

    The general :ref:`doc_3d_rendering_limitations` also apply to mobile platforms.

To improve out-of-the-box performance on mobile devices, Godot automatically uses
low-end-friendly settings by default on both Android and iOS. These are configured
by project settings with a ``.mobile`` :ref:`feature tag <doc_feature_tags>` suffix.

One of the most notable changes on mobile that will affect 3D projects is that
lighting is done per-vertex instead of per-pixel. This improves performance a
lot, but can break rendering in some scenes, especially if your meshes aren't
sufficiently subdivided for per-vertex lighting to look good. This can be
disabled in the Project Settings at a performance cost (see below).

When using GLES2, some custom shaders may break when exporting to Android. This
is caused by a lower shader precision being used by default to improve
performance. You can force high precision on all shader computations by enabling
``rendering/gles2/compatibility/enable_high_float.Android`` project setting, but
this has a significant performance cost and won't work on all devices.

The following project settings have mobile-specific overrides:

+---------------------------------------------------------------------------+-----------------+--------------------+
| Setting                                                                   | Desktop default | Mobile default     |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/directional_shadow/size``                             | 4096            | 2048               |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/intended_usage/framebuffer_allocation``               | 3D              | 3D Without Effects |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/lightmapping/use_bicubic_sampling``                   | ``true``        | ``false``          |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/reflections/high_quality_ggx``                        | ``true``        | ``false``          |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/shading/force_blinn_over_ggx``                        | ``false``       | ``true``           |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/shading/force_lambert_over_burley``                   | ``false``       | ``true``           |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/shading/force_vertex_shading``                        | ``false``       | ``true``           |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/shadow_atlas/size``                                   | 4096            | 2048               |
+---------------------------------------------------------------------------+-----------------+--------------------+
| ``rendering/quality/shadows/filter_mode``                                 | PCF5            | Disabled           |
+---------------------------------------------------------------------------+-----------------+--------------------+
| *GLES3 only:* ``rendering/gles3/shaders/max_simultaneous_compiles``       | 2               | 1                  |
+---------------------------------------------------------------------------+-----------------+--------------------+
| *GLES3 only:* ``rendering/gles3/shaders/shader_cache_size_mb``            | 512             | 128                |
+---------------------------------------------------------------------------+-----------------+--------------------+
| *GLES3 only:* ``rendering/quality/depth/hdr``                             | ``true``        | ``false``          |
+---------------------------------------------------------------------------+-----------------+--------------------+
| *GLES3 only:* ``rendering/quality/reflections/texture_array_reflections`` | ``true``        | ``false``          |
+---------------------------------------------------------------------------+-----------------+--------------------+

See the :ref:`ProjectSettings class documentation <class_ProjectSettings>`
for more information on those setting overrides.

If you're only targeting mobile platforms in your project, consider changing the
project settings' values to match the mobile overrides. This way, you'll get a
preview that is closer to the mobile appearance when running the project on a
desktop platform (as well as within the editor).

.. warning::

    Due to driver bugs, GLES3 support on Android and iOS can be poor, especially
    on old or low-end devices. Therefore, it is recommended to use the GLES2
    renderer when targeting mobile platforms (especially Android).

    You can change the rendering backend in the Project Settings
    (**Rendering > Quality > Driver > Driver Name**).


===================================================
/. ./tutorials/plugins/index.rst
===================================================

Plugins
=======

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-extending

   editor/index
   running_code_in_the_editor


===================================================
/. ./tutorials/plugins/editor/index.rst
===================================================

Editor plugins
==============

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-plugins

   installing_plugins
   making_plugins
   making_main_screen_plugins
   import_plugins
   spatial_gizmos
   inspector_plugins
   visual_shader_plugins


===================================================
/. ./tutorials/plugins/editor/installing_plugins.rst
===================================================

.. _doc_installing_plugins:

Installing plugins
==================

Godot features an editor plugin system with numerous plugins developed by the
community. Plugins can extend the editor's functionality with new nodes,
additional docks, convenience features, and more.

Finding plugins
~~~~~~~~~~~~~~~

The preferred way to find Godot plugins is to use the
`Asset Library <https://godotengine.org/asset-library/>`_. While it can be
browsed online, it's more convenient to use it directly from the editor.
To do so, click the **AssetLib** tab at the top of the editor:

.. image:: img/installing_plugins_assetlib_tab.png

You can also find assets on code hosting websites such as GitHub.

.. note::

    Some repositories describe themselves as "plugins" but may not actually be
    *editor* plugins. This is especially the case for scripts that are intended
    to be used in a running project. You don't need to enable such plugins to
    use them. Download them and extract the files in your project folder.

    One way to distinguish editor plugins from non-editor plugins is to look for
    a ``plugin.cfg`` file in the repository that hosts the plugin. If the
    repository contains a ``plugin.cfg`` file in a folder placed in the
    ``addons/`` folder, then it is an editor plugin.

Installing a plugin
~~~~~~~~~~~~~~~~~~~

To install a plugin, download it as a ZIP archive. On the Asset Library, this
can be done using the **Download** button, either from the editor or using the
Web interface.

On GitHub, if a plugin has *tags* (versions) declared, go to the **Releases**
tab to download a stable release. This ensures you download a version that was
declared to be stable by its author.

On GitHub, if the plugin doesn't have any *tags* declared, use the **Download ZIP**
button to download a ZIP of the latest revision:

.. image:: img/installing_plugins_github_download_zip.png

Extract the ZIP archive and move the ``addons/`` folder it contains into your
project folder. If your project already contains an ``addons/`` folder, move the
plugin's ``addons/`` folder into your project folder to merge the new folder
contents with the existing one. Your file manager may ask you whether to write
into the folder; answer **Yes**. No files will be overwritten in the process.

Enabling a plugin
~~~~~~~~~~~~~~~~~

To enable the freshly installed plugin, open **Project > Project Settings** at
the top of the editor then go the **Plugins** tab. If the plugin was packaged
correctly, you should see it in the list of plugins. Click on the gray
**Inactive** text and choose **Active** to enable the plugin. The word
**Active** will display in green to confirm the plugin was enabled.

.. image:: img/installing_plugins_project_settings.png


You can use the plugin immediately after enabling it; there's no need to restart
the editor. Likewise, disabling a plugin can be done without having to restart
the editor.


===================================================
/. ./tutorials/plugins/editor/making_plugins.rst
===================================================

.. _doc_making_plugins:

Making plugins
==============

About plugins
~~~~~~~~~~~~~

A plugin is a great way to extend the editor with useful tools. It can be made
entirely with GDScript and standard scenes, without even reloading the editor.
Unlike modules, you don't need to create C++ code nor recompile the engine.
While this makes plugins less powerful, there are still many things you can
do with them. Note that a plugin is similar to any scene you can already
make, except it is created using a script to add editor functionality.

This tutorial will guide you through the creation of two simple plugins so
you can understand how they work and be able to develop your own. The first
will be a custom node that you can add to any scene in the project and the
other will be a custom dock added to the editor.

Creating a plugin
~~~~~~~~~~~~~~~~~

Before starting, create a new empty project wherever you want. This will serve
as a base to develop and test the plugins.

The first thing you need for the editor to identify a new plugin is to
create two files: a ``plugin.cfg`` for configuration and a tool script with the
functionality. Plugins have a standard path like ``addons/plugin_name`` inside
the project folder. Godot provides a dialog for generating those files and
placing them where they need to be.

In the main toolbar, click the ``Project`` dropdown. Then click
``Project Settings...``. Go to the ``Plugins`` tab and then click
on the ``Create`` button in the top-right.

You will see the dialog appear, like so:

.. image:: img/making_plugins-create_plugin_dialog.png

The placeholder text in each field describes how it affects the plugin's
creation of the files and the config file's values.

To continue with the example, use the following values:

.. tabs::
 .. code-tab:: ini GDScript

    Plugin Name: My Custom Node
    Subfolder: my_custom_node
    Description: A custom node made to extend the Godot Engine.
    Author: Your Name Here
    Version: 1.0.0
    Language: GDScript
    Script Name: custom_node.gd
    Activate now: No

 .. code-tab:: ini C#

    Plugin Name: My Custom Node
    Subfolder: my_custom_node
    Description: A custom node made to extend the Godot Engine.
    Author: Your Name Here
    Version: 1.0.0
    Language: C#
    Script Name: CustomNode.cs
    Activate now: No

.. warning::

    Unchecking the ``Activate now?`` option in C# is always required because,
    like every other C# script, the EditorPlugin script needs to be compiled which
    requires building the project. After building the project the plugin can be
    enabled in the ``Plugins`` tab of ``Project Settings``.

You should end up with a directory structure like this:

.. image:: img/making_plugins-my_custom_mode_folder.png

``plugin.cfg`` is a simple INI file with metadata about your plugin.
The name and description help people understand what it does.
Your name helps you get properly credited for your work.
The version number helps others know if they have an outdated version;
if you are unsure on how to come up with the version number, check out `Semantic Versioning <https://semver.org/>`_.
The main script file will instruct Godot what your plugin does in the editor
once it is active.

The script file
^^^^^^^^^^^^^^^

Upon creation of the plugin, the dialog will automatically open the
EditorPlugin script for you. The script has two requirements that you cannot
change: it must be a ``tool`` script, or else it will not load properly in the
editor, and it must inherit from :ref:`class_EditorPlugin`.

.. warning::

    In addition to the EditorPlugin script, any other GDScript that your plugin uses
    must *also* be a tool. Any GDScript without ``tool`` imported into the editor
    will act like an empty file!

It's important to deal with initialization and clean-up of resources.
A good practice is to use the virtual function
:ref:`_enter_tree() <class_Node_method__enter_tree>` to initialize your plugin and
:ref:`_exit_tree() <class_Node_method__exit_tree>` to clean it up. Thankfully,
the dialog generates these callbacks for you. Your script should look something
like this:

.. _doc_making_plugins_template_code:
.. tabs::
 .. code-tab:: gdscript GDScript

    tool
    extends EditorPlugin


    func _enter_tree():
        # Initialization of the plugin goes here.
        pass


    func _exit_tree():
        # Clean-up of the plugin goes here.
        pass

 .. code-tab:: csharp

    #if TOOLS
    using Godot;
    using System;

    [Tool]
    public class CustomNode : EditorPlugin
    {
        public override void _EnterTree()
        {
            // Initialization of the plugin goes here.
        }

        public override void _ExitTree()
        {
            // Clean-up of the plugin goes here.
        }
    }
    #endif

This is a good template to use when creating new plugins.

A custom node
~~~~~~~~~~~~~

Sometimes you want a certain behavior in many nodes, such as a custom scene
or control that can be reused. Instancing is helpful in a lot of cases, but
sometimes it can be cumbersome, especially if you're using it in many
projects. A good solution to this is to make a plugin that adds a node with a
custom behavior.

.. warning::

  Nodes added via an EditorPlugin are "CustomType" nodes. While they work
  with any scripting language, they have fewer features than
  :ref:`the Script Class system <doc_gdscript_basics_class_name>`. If you
  are writing GDScript or NativeScript, we recommend using Script Classes instead.

To create a new node type, you can use the function
:ref:`add_custom_type() <class_EditorPlugin_method_add_custom_type>` from the
:ref:`class_EditorPlugin` class. This function can add new types to the editor
(nodes or resources). However, before you can create the type, you need a script
that will act as the logic for the type. While that script doesn't have to use
the ``tool`` keyword, it can be added so the script runs in the editor.

For this tutorial, we'll create a simple button that prints a message when
clicked. For that, we'll need a simple script that extends from
:ref:`class_Button`. It could also extend
:ref:`class_BaseButton` if you prefer:

.. tabs::
 .. code-tab:: gdscript GDScript

    tool
    extends Button


    func _enter_tree():
        connect("pressed", self, "clicked")


    func clicked():
        print("You clicked me!")

 .. code-tab:: csharp

    using Godot;
    using System;

    [Tool]
    public class MyButton : Button
    {
        public override void _EnterTree()
        {
            Connect("pressed", this, "clicked");
        }

        public void clicked()
        {
            GD.Print("You clicked me!");
        }
    }

That's it for our basic button. You can save this as ``my_button.gd`` inside the
plugin folder. You'll also need a 16×16 icon to show in the scene tree. If you
don't have one, you can grab the default one from the engine and save it in your
`addons/my_custom_node` folder as `icon.png`, or use the default Godot logo
(`preload("res://icon.png")`). You can also use SVG icons if desired.

.. image:: img/making_plugins-custom_node_icon.png

Now, we need to add it as a custom type so it shows on the **Create New Node**
dialog. For that, change the ``custom_node.gd`` script to the following:

.. tabs::
 .. code-tab:: gdscript GDScript

    tool
    extends EditorPlugin


    func _enter_tree():
        # Initialization of the plugin goes here.
        # Add the new type with a name, a parent type, a script and an icon.
        add_custom_type("MyButton", "Button", preload("my_button.gd"), preload("icon.png"))


    func _exit_tree():
        # Clean-up of the plugin goes here.
        # Always remember to remove it from the engine when deactivated.
        remove_custom_type("MyButton")

 .. code-tab:: csharp

    #if TOOLS
    using Godot;
    using System;

    [Tool]
    public class CustomNode : EditorPlugin
    {
        public override void _EnterTree()
        {
            // Initialization of the plugin goes here.
            // Add the new type with a name, a parent type, a script and an icon.
            var script = GD.Load<Script>("MyButton.cs");
            var texture = GD.Load<Texture>("icon.png");
            AddCustomType("MyButton", "Button", script, texture);
        }

        public override void _ExitTree()
        {
            // Clean-up of the plugin goes here.
            // Always remember to remove it from the engine when deactivated.
            RemoveCustomType("MyButton");
        }
    }
    #endif

With that done, the plugin should already be available in the plugin list in the
**Project Settings**, so activate it as explained in `Checking the results`_.

Then try it out by adding your new node:

.. image:: img/making_plugins-custom_node_create.png

When you add the node, you can see that it already has the script you created
attached to it. Set a text to the button, save and run the scene. When you
click the button, you can see some text in the console:

.. image:: img/making_plugins-custom_node_console.png

A custom dock
^^^^^^^^^^^^^

Sometimes, you need to extend the editor and add tools that are always available.
An easy way to do it is to add a new dock with a plugin. Docks are just scenes
based on Control, so they are created in a way similar to usual GUI scenes.

Creating a custom dock is done just like a custom node. Create a new
``plugin.cfg`` file in the ``addons/my_custom_dock`` folder, then
add the following content to it:

.. tabs::
 .. code-tab:: gdscript GDScript

    [plugin]

    name="My Custom Dock"
    description="A custom dock made so I can learn how to make plugins."
    author="Your Name Here"
    version="1.0"
    script="custom_dock.gd"

 .. code-tab:: csharp

    [plugin]

    name="My Custom Dock"
    description="A custom dock made so I can learn how to make plugins."
    author="Your Name Here"
    version="1.0"
    script="CustomDock.cs"

Then create the script ``custom_dock.gd`` in the same folder. Fill it with the
:ref:`template we've seen before <doc_making_plugins_template_code>` to get a
good start.

Since we're trying to add a new custom dock, we need to create the contents of
the dock. This is nothing more than a standard Godot scene: just create
a new scene in the editor then edit it.

For an editor dock, the root node **must** be a :ref:`Control <class_Control>`
or one of its child classes. For this tutorial, you can create a single button.
The name of the root node will also be the name that appears on the dock tab,
so be sure to give it a short and descriptive name.
Also, don't forget to add some text to your button.

.. image:: img/making_plugins-my_custom_dock_scene.png

Save this scene as ``my_dock.tscn``. Now, we need to grab the scene we created
then add it as a dock in the editor. For this, you can rely on the function
:ref:`add_control_to_dock() <class_EditorPlugin_method_add_control_to_dock>` from the
:ref:`EditorPlugin <class_EditorPlugin>` class.

You need to select a dock position and define the control to add
(which is the scene you just created). Don't forget to
**remove the dock** when the plugin is deactivated.
The script could look like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    tool
    extends EditorPlugin


    # A class member to hold the dock during the plugin life cycle.
    var dock


    func _enter_tree():
        # Initialization of the plugin goes here.
        # Load the dock scene and instance it.
        dock = preload("res://addons/my_custom_dock/my_dock.tscn").instance()

        # Add the loaded scene to the docks.
        add_control_to_dock(DOCK_SLOT_LEFT_UL, dock)
        # Note that LEFT_UL means the left of the editor, upper-left dock.


    func _exit_tree():
        # Clean-up of the plugin goes here.
        # Remove the dock.
        remove_control_from_docks(dock)
        # Erase the control from the memory.
        dock.free()

 .. code-tab:: csharp

    #if TOOLS
    using Godot;
    using System;

    [Tool]
    public class CustomDock : EditorPlugin
    {
        Control dock;

        public override void _EnterTree()
        {
            dock = (Control)GD.Load<PackedScene>("addons/my_custom_dock/my_dock.tscn").Instance();
            AddControlToDock(DockSlot.LeftUl, dock);
        }

        public override void _ExitTree()
        {
            // Clean-up of the plugin goes here.
            // Remove the dock.
            RemoveControlFromDocks(dock);
            // Erase the control from the memory.
            dock.Free();
        }
    }
    #endif

Note that, while the dock will initially appear at its specified position,
the user can freely change its position and save the resulting layout.

Checking the results
^^^^^^^^^^^^^^^^^^^^

It's now time to check the results of your work. Open the **Project
Settings** and click on the **Plugins** tab. Your plugin should be the only one
on the list. If it is not showing, click on the **Update** button in the
top-right corner.

.. image:: img/making_plugins-project_settings.png

You can see the plugin is inactive on the **Status** column; click on the status
to select **Active**. The dock should become visible before you even close
the settings window. You should now have a custom dock:

.. image:: img/making_plugins-custom_dock.png

Going beyond
~~~~~~~~~~~~

Now that you've learned how to make basic plugins, you can extend the editor in
several ways. Lots of functionality can be added to the editor with GDScript;
it is a powerful way to create specialized editors without having to delve into
C++ modules.

You can make your own plugins to help yourself and share them in the
`Asset Library <https://godotengine.org/asset-library/>`_ so that people
can benefit from your work.

.. _doc_making_plugins_autoload:

Registering autoloads/singletons in plugins
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is possible for editor plugins to automatically register
:ref:`autoloads <doc_singletons_autoload>` when the plugin is enabled.
This also includes unregistering the autoload when the plugin is disabled.

This makes setting up plugins faster for users, as they no longer have to manually
add autoloads to their project settings if your editor plugin requires the use of
an autoload.

Use the following code to register a singleton from an editor plugin:

::

    tool
    extends EditorPlugin

    # Replace this value with a PascalCase autoload name, as per the GDScript style guide.
    const AUTOLOAD_NAME = "SomeAutoload"


    func _enter_tree():
        # The autoload can be a scene or script file.
        add_autoload_singleton(AUTOLOAD_NAME, "res://addons/my_addon/some_autoload.tscn")


    func _exit_tree():
        remove_autoload_singleton(AUTOLOAD_NAME)


===================================================
/. ./tutorials/plugins/editor/making_main_screen_plugins.rst
===================================================

.. _doc_making_main_screen_plugins:

Making main screen plugins
==========================

What this tutorial covers
-------------------------

As seen in the :ref:`doc_making_plugins` page, making a basic plugin that
extends the editor is fairly easy. Main screen plugins allow you to create
new UIs in the central part of the editor, which appear next to the
"2D", "3D", "Script", and "AssetLib" buttons. Such editor plugins are
referred as "Main screen plugins".

This tutorial leads you through the creation of a basic main screen plugin.
For the sake of simplicity, our main screen plugin will contain a single
button that prints text to the console.

Initializing the plugin
-----------------------

First create a new plugin from the Plugins menu. For this tutorial, we'll put
it in a folder called ``main_screen``, but you can use any name you'd like.

The plugin script will come with ``_enter_tree()`` and ``_exit_tree()``
methods, but for a main screen plugin we need to add a few extra methods.
Add five extra methods such that the script looks like this:

::

    tool
    extends EditorPlugin


    func _enter_tree():
        pass


    func _exit_tree():
        pass


    func has_main_screen():
        return true


    func make_visible(visible):
        pass


    func get_plugin_name():
        return "Main Screen Plugin"


    func get_plugin_icon():
        return get_editor_interface().get_base_control().get_icon("Node", "EditorIcons")

The important part in this script is the ``has_main_screen()`` function,
which is overloaded so it returns ``true``. This function is automatically
called by the editor on plugin activation, to tell it that this plugin
adds a new center view to the editor. For now, we'll leave this script
as-is and we'll come back to it later.

Main screen scene
-----------------

Create a new scene with a root node derived from ``Control`` (for this
example plugin, we'll make the root node a ``CenterContainer``).
Select this root node, and in the viewport, click the ``Layout`` menu
and select ``Full Rect``. You also need to enable the ``Expand``
vertical size flag in the inspector.
The panel now uses all the space available in the main viewport.

Next, let's add a button to our example main screen plugin.
Add a ``Button`` node, and set the text to "Print Hello" or similar.
Add a script to the button like this:

::

    tool
    extends Button


    func _on_PrintHello_pressed():
        print("Hello from the main screen plugin!")

Then connect the "pressed" signal to itself. If you need help with signals,
see the :ref:`doc_signals` article.

We are done with the main screen panel. Save the scene as ``main_panel.tscn``.

Update the plugin script
------------------------

We need to update the ``main_screen_plugin.gd`` script so the plugin
instances our main panel scene and places it where it needs to be.
Here is the full plugin script:

::

    tool
    extends EditorPlugin


    const MainPanel = preload("res://addons/main_screen/main_panel.tscn")

    var main_panel_instance


    func _enter_tree():
        main_panel_instance = MainPanel.instance()
        # Add the main panel to the editor's main viewport.
        get_editor_interface().get_editor_viewport().add_child(main_panel_instance)
        # Hide the main panel. Very much required.
        make_visible(false)


    func _exit_tree():
        if main_panel_instance:
            main_panel_instance.queue_free()


    func has_main_screen():
        return true


    func make_visible(visible):
        if main_panel_instance:
            main_panel_instance.visible = visible


    func get_plugin_name():
        return "Main Screen Plugin"


    func get_plugin_icon():
        # Must return some kind of Texture for the icon.
        return get_editor_interface().get_base_control().get_icon("Node", "EditorIcons")

A couple of specific lines were added. ``MainPanel`` is a constant that holds
a reference to the scene, and we instance it into `main_panel_instance`.

The ``_enter_tree()`` function is called before ``_ready()``. This is where
we instance the main panel scene, and add them as children of specific parts
of the editor. We use ``get_editor_interface().get_editor_viewport()`` to
obtain the viewport and add our main panel instance as a child to it.
We call the ``make_visible(false)`` function to hide the main panel so
it doesn't compete for space when first activating the plugin.

The ``_exit_tree()`` function is called when the plugin is deactivated.
If the main screen still exists, we call ``queue_free()`` to free the
instance and remove it from memory.

The ``make_visible()`` function is overridden to hide or show the main
panel as needed. This function is automatically called by the editor when the
user clicks on the main viewport buttons at the top of the editor.

The ``get_plugin_name()`` and ``get_plugin_icon()`` functions control
the displayed name and icon for the plugin's main viewport button.

Another function you can add is the ``handles()`` function, which
allows you to handle a node type, automatically focusing the main
screen when the type is selected. This is similar to how clicking
on a 3D node will automatically switch to the 3D viewport.

Try the plugin
--------------

Activate the plugin in the Project Settings. You'll observe a new button next
to 2D, 3D, Script above the main viewport. Clicking it will take you to your
new main screen plugin, and the button in the middle will print text.

If you would like to try a finished version of this plugin,
check out the plugin demos here:
https://github.com/godotengine/godot-demo-projects/tree/master/plugins

If you would like to see a more complete example of what main screen plugins
are capable of, check out the 2.5D demo projects here:
https://github.com/godotengine/godot-demo-projects/tree/master/misc/2.5d


===================================================
/. ./tutorials/plugins/editor/import_plugins.rst
===================================================

.. _doc_import_plugins:

Import plugins
==============

.. note:: This tutorial assumes you already know how to make generic plugins. If
          in doubt, refer to the :ref:`doc_making_plugins` page. This also
          assumes you are acquainted with Godot's import system.

Introduction
------------

An import plugin is a special type of editor tool that allows custom resources
to be imported by Godot and be treated as first-class resources. The editor
itself comes bundled with a lot of import plugins to handle the common resources
like PNG images, Collada and glTF models, Ogg Vorbis sounds, and many more.

This tutorial will show you how to create a simple import plugin to load a
custom text file as a material resource. This text file will contain three
numeric values separated by comma, which represents the three channels of a
color, and the resulting color will be used as the albedo (main color) of the
imported material. In this example it will contain the pure blue color
(zero red, zero green, and full blue):

.. code-block:: none

    0,0,255

Configuration
-------------

First we need a generic plugin that will handle the initialization and
destruction of our import plugin. Let's add the ``plugin.cfg`` file first:

.. code-block:: ini

    [plugin]

    name="Silly Material Importer"
    description="Imports a 3D Material from an external text file."
    author="Yours Truly"
    version="1.0"
    script="material_import.gd"

Then we need the ``material_import.gd`` file to add and remove the import plugin
when needed:

::

    # material_import.gd
    tool
    extends EditorPlugin


    var import_plugin


    func _enter_tree():
        import_plugin = preload("import_plugin.gd").new()
        add_import_plugin(import_plugin)


    func _exit_tree():
        remove_import_plugin(import_plugin)
        import_plugin = null

When this plugin is activated, it will create a new instance of the import
plugin (which we'll soon make) and add it to the editor using the
:ref:`add_import_plugin() <class_EditorPlugin_method_add_import_plugin>` method. We store
a reference to it in a class member ``import_plugin`` so we can refer to it
later when removing it. The
:ref:`remove_import_plugin() <class_EditorPlugin_method_remove_import_plugin>` method is
called when the plugin is deactivated to clean up the memory and let the editor
know the import plugin isn't available anymore.

Note that the import plugin is a reference type, so it doesn't need to be
explicitly released from memory with the ``free()`` function. It will be
released automatically by the engine when it goes out of scope.

The EditorImportPlugin class
----------------------------

The main character of the show is the
:ref:`EditorImportPlugin class <class_EditorImportPlugin>`. It is responsible for
implementing the methods that are called by Godot when it needs to know how to deal
with files.

Let's begin to code our plugin, one method at time:

::

    # import_plugin.gd
    tool
    extends EditorImportPlugin


    func get_importer_name():
        return "demos.sillymaterial"

The first method is the
:ref:`get_importer_name()<class_EditorImportPlugin_method_get_importer_name>`. This is a
unique name for your plugin that is used by Godot to know which import was used
in a certain file. When the files needs to be reimported, the editor will know
which plugin to call.

::

    func get_visible_name():
        return "Silly Material"

The :ref:`get_visible_name()<class_EditorImportPlugin_method_get_visible_name>` method is
responsible for returning the name of the type it imports and it will be shown to the
user in the Import dock.

You should choose this name as a continuation to "Import as", e.g. *"Import as
Silly Material"*. You can name it whatever you want but we recommend a
descriptive name for your plugin.

::

    func get_recognized_extensions():
        return ["mtxt"]

Godot's import system detects file types by their extension. In the
:ref:`get_recognized_extensions()<class_EditorImportPlugin_method_get_recognized_extensions>`
method you return an array of strings to represent each extension that this
plugin can understand. If an extension is recognized by more than one plugin,
the user can select which one to use when importing the files.

.. tip:: Common extensions like ``.json`` and ``.txt`` might be used by many
         plugins. Also, there could be files in the project that are just data
         for the game and should not be imported. You have to be careful when
         importing to validate the data. Never expect the file to be well-formed.

::

    func get_save_extension():
        return "material"

The imported files are saved in the ``.import`` folder at the project's root.
Their extension should match the type of resource you are importing, but since
Godot can't tell what you'll use (because there might be multiple valid
extensions for the same resource), you need to declare what will be used in
the import.

Since we're importing a Material, we'll use the special extension for such
resource types. If you are importing a scene, you can use ``scn``. Generic
resources can use the ``res`` extension. However, this is not enforced in any
way by the engine.

::

    func get_resource_type():
        return "SpatialMaterial"

The imported resource has a specific type, so the editor can know which property
slot it belongs to. This allows drag and drop from the FileSystem dock to a
property in the Inspector.

In our case it's a :ref:`class_SpatialMaterial`, which can be applied to 3D
objects.

.. note:: If you need to import different types from the same extension, you
          have to create multiple import plugins. You can abstract the import
          code on another file to avoid duplication in this regard.

Options and presets
-------------------

Your plugin can provide different options to allow the user to control how the
resource will be imported. If a set of selected options is common, you can also
create different presets to make it easier for the user. The following image
shows how the options will appear in the editor:

.. image:: img/import_plugin_options.png

Since there might be many presets and they are identified with a number, it's a
good practice to use an enum so you can refer to them using names.

::

    tool
    extends EditorImportPlugin


    enum Presets { DEFAULT }


    ...

Now that the enum is defined, let's keep looking at the methods of an import
plugin:

::

    func get_preset_count():
        return Presets.size()

The :ref:`get_preset_count() <class_EditorImportPlugin_method_get_preset_count>` method
returns the amount of presets that this plugins defines. We only have one preset
now, but we can make this method future-proof by returning the size of our
``Presets`` enumeration.

::

    func get_preset_name(preset):
        match preset:
            Presets.DEFAULT:
                return "Default"
            _:
                return "Unknown"


Here we have the
:ref:`get_preset_name() <class_EditorImportPlugin_method_get_preset_name>` method, which
gives names to the presets as they will be presented to the user, so be sure to
use short and clear names.

We can use the ``match`` statement here to make the code more structured. This
way it's easy to add new presets in the future. We use the catch all pattern to
return something too. Although Godot won't ask for presets beyond the preset
count you defined, it's always better to be on the safe side.

If you have only one preset you could simply return its name directly, but if
you do this you have to be careful when you add more presets.

::

    func get_import_options(preset):
        match preset:
            Presets.DEFAULT:
                return [{
                           "name": "use_red_anyway",
                           "default_value": false
                        }]
            _:
                return []

This is the method which defines the available options.
:ref:`get_import_options() <class_EditorImportPlugin_method_get_import_options>` returns
an array of dictionaries, and each dictionary contains a few keys that are
checked to customize the option as its shown to the user. The following table
shows the possible keys:

+-------------------+------------+----------------------------------------------------------------------------------------------------------+
| Key               | Type       | Description                                                                                              |
+===================+============+==========================================================================================================+
| ``name``          | String     | The name of the option. When showed, underscores become spaces and first letters are capitalized.        |
+-------------------+------------+----------------------------------------------------------------------------------------------------------+
| ``default_value`` | Any        | The default value of the option for this preset.                                                         |
+-------------------+------------+----------------------------------------------------------------------------------------------------------+
| ``property_hint`` | Enum value | One of the :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` values to use as hint.                   |
+-------------------+------------+----------------------------------------------------------------------------------------------------------+
| ``hint_string``   | String     | The hint text of the property. The same as you'd add in the ``export`` statement in GDScript.            |
+-------------------+------------+----------------------------------------------------------------------------------------------------------+
| ``usage``         | Enum value | One of the :ref:`PropertyUsageFlags <enum_@GlobalScope_PropertyUsageFlags>` values to define the usage.  |
+-------------------+------------+----------------------------------------------------------------------------------------------------------+

The ``name`` and ``default_value`` keys are **mandatory**, the rest are optional.

Note that the ``get_import_options`` method receives the preset number, so you
can configure the options for each different preset (especially the default
value). In this example we use the ``match`` statement, but if you have lots of
options and the presets only change the value you may want to create the array
of options first and then change it based on the preset.

.. warning:: The ``get_import_options`` method is called even if you don't
             define presets (by making ``get_preset_count`` return zero). You
             have to return an array even it's empty, otherwise you can get
             errors.

::

    func get_option_visibility(option, options):
        return true

For the
:ref:`get_option_visibility() <class_EditorImportPlugin_method_get_option_visibility>`
method, we simply return ``true`` because all of our options (i.e. the single
one we defined) are visible all the time.

If you need to make certain option visible only if another is set with a certain
value, you can add the logic in this method.

The ``import`` method
---------------------

The heavy part of the process, responsible for converting the files into
resources, is covered by the :ref:`import() <class_EditorImportPlugin_method_import>`
method. Our sample code is a bit long, so let's split in a few parts:

::

    func import(source_file, save_path, options, r_platform_variants, r_gen_files):
        var file = File.new()
        var err = file.open(source_file, File.READ)
        if err != OK:
            return err

        var line = file.get_line()

        file.close()

The first part of our import method opens and reads the source file. We use the
:ref:`File <class_File>` class to do that, passing the ``source_file``
parameter which is provided by the editor.

If there's an error when opening the file, we return it to let the editor know
that the import wasn't successful.

::

    var channels = line.split(",")
    if channels.size() != 3:
        return ERR_PARSE_ERROR

    var color
    if options.use_red_anyway:
        color = Color8(255, 0, 0)
    else:
        color = Color8(int(channels[0]), int(channels[1]), int(channels[2]))

This code takes the line of the file it read before and splits it in pieces
that are separated by a comma. If there are more or less than the three values,
it considers the file invalid and reports an error.

Then it creates a new :ref:`Color <class_Color>` variable and sets its values
according to the input file. If the ``use_red_anyway`` option is enabled, then
it sets the color as a pure red instead.

::

    var material = SpatialMaterial.new()
    material.albedo_color = color

This part makes a new :ref:`SpatialMaterial <class_SpatialMaterial>` that is the
imported resource. We create a new instance of it and then set its albedo color
as the value we got before.

::

    return ResourceSaver.save("%s.%s" % [save_path, get_save_extension()], material)

This is the last part and quite an important one, because here we save the made
resource to the disk. The path of the saved file is generated and informed by
the editor via the ``save_path`` parameter. Note that this comes **without** the
extension, so we add it using :ref:`string formatting <doc_gdscript_printf>`. For
this we call the ``get_save_extension`` method that we defined earlier, so we
can be sure that they won't get out of sync.

We also return the result from the
:ref:`ResourceSaver.save() <class_ResourceSaver_method_save>` method, so if there's an
error in this step, the editor will know about it.

Platform variants and generated files
-------------------------------------

You may have noticed that our plugin ignored two arguments of the ``import``
method. Those are *return arguments* (hence the ``r`` at the beginning of their
name), which means that the editor will read from them after calling your import
method. Both of them are arrays that you can fill with information.

The ``r_platform_variants`` argument is used if you need to import the resource
differently depending on the target platform. While it's called *platform*
variants, it is based on the presence of :ref:`feature tags <doc_feature_tags>`,
so even the same platform can have multiple variants depending on the setup.

To import a platform variant, you need to save it with the feature tag before
the extension, and then push the tag to the ``r_platform_variants`` array so the
editor can know that you did.

For example, let's say we save a different material for a mobile platform. We
would need to do something like the following:

::

    r_platform_variants.push_back("mobile")
    return ResourceSaver.save("%s.%s.%s" % [save_path, "mobile", get_save_extension()], mobile_material)

The ``r_gen_files`` argument is meant for extra files that are generated during
your import process and need to be kept. The editor will look at it to
understand the dependencies and make sure the extra file is not inadvertently
deleted.

This is also an array and should be filled with full paths of the files you
save. As an example, let's create another material for the next pass and save it
in a different file:

::

    var next_pass = SpatialMaterial.new()
    next_pass.albedo_color = color.inverted()
    var next_pass_path = "%s.next_pass.%s" % [save_path, get_save_extension()]

    err = ResourceSaver.save(next_pass_path, next_pass)
    if err != OK:
        return err
    r_gen_files.push_back(next_pass_path)

Trying the plugin
-----------------

This has been theoretical, but now that the import plugin is done, let's
test it. Make sure you created the sample file (with the contents described in
the introduction section) and save it as ``test.mtxt``. Then activate the plugin
in the Project Settings.

If everything goes well, the import plugin is added to the editor and the file
system is scanned, making the custom resource appear on the FileSystem dock. If
you select it and focus the Import dock, you can see the only option to select
there.

Create a MeshInstance node in the scene, and for its Mesh property set up a new
SphereMesh. Unfold the Material section in the Inspector and then drag the file
from the FileSystem dock to the material property. The object will update in the
viewport with the blue color of the imported material.

.. image:: img/import_plugin_trying.png

Go to Import dock, enable the "Use Red Anyway" option, and click on "Reimport".
This will update the imported material and should automatically update the view
showing the red color instead.

And that's it! Your first import plugin is done! Now get creative and make
plugins for your own beloved formats. This can be quite useful to write your
data in a custom format and then use it in Godot as if they were native
resources. This shows how the import system is powerful and extendable.


===================================================
/. ./tutorials/plugins/editor/spatial_gizmos.rst
===================================================

.. _doc_spatial_gizmo_plugins:

Spatial gizmo plugins
=====================

Introduction
------------

Spatial gizmo plugins are used by the editor and custom plugins to define the
gizmos attached to any kind of Spatial node.

This tutorial will show you the two main approaches to defining your own custom
gizmos. The first option works well for simple gizmos and creates less clutter in
your plugin structure, while the second one will let you store some per-gizmo data.

.. note:: This tutorial assumes you already know how to make generic plugins. If
          in doubt, refer to the :ref:`doc_making_plugins` page.

The EditorSpatialGizmoPlugin
----------------------------

Regardless of the approach we choose, we will need to create a new
:ref:`EditorSpatialGizmoPlugin <class_EditorSpatialGizmoPlugin>`. This will allow
us to set a name for the new gizmo type and define other behaviors such as whether
the gizmo can be hidden or not.

This would be a basic setup:

::

    # MyCustomGizmoPlugin.gd
    extends EditorSpatialGizmoPlugin


    func get_name():
        return "CustomNode"


::

    # MyCustomEditorPlugin.gd
    tool
    extends EditorPlugin


    const MyCustomGizmoPlugin = preload("res://addons/my-addon/MyCustomGizmoPlugin.gd")

    var gizmo_plugin = MyCustomGizmoPlugin.new()


    func _enter_tree():
        add_spatial_gizmo_plugin(gizmo_plugin)


    func _exit_tree():
        remove_spatial_gizmo_plugin(gizmo_plugin)


For simple gizmos, just inheriting :ref:`EditorSpatialGizmoPlugin <class_EditorSpatialGizmoPlugin>`
is enough. If you want to store some per-gizmo data or you are porting a Godot 3.0 gizmo
to 3.1+, you should go with the second approach.


Simple approach
---------------

The first step is to, in our custom gizmo plugin, override the :ref:`has_gizmo()<class_EditorSpatialGizmoPlugin_method_has_gizmo>`
method so that it returns ``true`` when the spatial parameter is of our target type.

::

    # ...


    func has_gizmo(spatial):
        return spatial is MyCustomSpatial


    # ...

Then we can override methods like :ref:`redraw()<class_EditorSpatialGizmoPlugin_method_redraw>`
or all the handle related ones.

::

    # ...


    func _init():
        create_material("main", Color(1, 0, 0))
        create_handle_material("handles")


    func redraw(gizmo):
        gizmo.clear()

        var spatial = gizmo.get_spatial_node()

        var lines = PoolVector3Array()

        lines.push_back(Vector3(0, 1, 0))
        lines.push_back(Vector3(0, spatial.my_custom_value, 0))

        var handles = PoolVector3Array()

        handles.push_back(Vector3(0, 1, 0))
        handles.push_back(Vector3(0, spatial.my_custom_value, 0))

        gizmo.add_lines(lines, get_material("main", gizmo), false)
        gizmo.add_handles(handles, get_material("handles", gizmo))


    # ...

Note that we created a material in the `_init` method, and retrieved it in the `redraw`
method using :ref:`get_material()<class_EditorSpatialGizmoPlugin_method_get_material>`. This
method retrieves one of the material's variants depending on the state of the gizmo
(selected and/or editable).

So the final plugin would look somewhat like this:

::

    extends EditorSpatialGizmoPlugin


    const MyCustomSpatial = preload("res://addons/my-addon/MyCustomSpatial.gd")


    func _init():
        create_material("main", Color(1,0,0))
        create_handle_material("handles")


    func has_gizmo(spatial):
        return spatial is MyCustomSpatial


    func redraw(gizmo):
        gizmo.clear()

        var spatial = gizmo.get_spatial_node()

        var lines = PoolVector3Array()

        lines.push_back(Vector3(0, 1, 0))
        lines.push_back(Vector3(0, spatial.my_custom_value, 0))

        var handles = PoolVector3Array()

        handles.push_back(Vector3(0, 1, 0))
        handles.push_back(Vector3(0, spatial.my_custom_value, 0))

        gizmo.add_lines(lines, get_material("main", gizmo), false)
        gizmo.add_handles(handles, get_material("handles", gizmo))


    # You should implement the rest of handle-related callbacks
    # (get_handle_name(), get_handle_value(), commit_handle()...).

Note that we just added some handles in the redraw method, but we still need to implement
the rest of handle-related callbacks in :ref:`EditorSpatialGizmoPlugin <class_EditorSpatialGizmoPlugin>`
to get properly working handles.

Alternative approach
--------------------

In some cases we want to provide our own implementation of :ref:`EditorSpatialGizmo<class_EditorSpatialGizmo>`,
maybe because we want to have some state stored in each gizmo or because we are porting
an old gizmo plugin and we don't want to go through the rewriting process.

In these cases all we need to do is, in our new gizmo plugin, override
:ref:`create_gizmo()<class_EditorSpatialGizmoPlugin_method_create_gizmo>`, so it returns our custom gizmo implementation
for the Spatial nodes we want to target.

::

    # MyCustomGizmoPlugin.gd
    extends EditorSpatialGizmoPlugin


    const MyCustomSpatial = preload("res://addons/my-addon/MyCustomSpatial.gd")
    const MyCustomGizmo = preload("res://addons/my-addon/MyCustomGizmo.gd")


    func _init():
        create_material("main", Color(1, 0, 0))
        create_handle_material("handles")


    func create_gizmo(spatial):
        if spatial is MyCustomSpatial:
            return MyCustomGizmo.new()
        else:
            return null

This way all the gizmo logic and drawing methods can be implemented in a new class extending
:ref:`EditorSpatialGizmo<class_EditorSpatialGizmo>`, like so:

::

    # MyCustomGizmo.gd
    extends EditorSpatialGizmo


    # You can store data in the gizmo itself (more useful when working with handles).
    var gizmo_size = 3.0


    func redraw():
        clear()

        var spatial = get_spatial_node()

        var lines = PoolVector3Array()

        lines.push_back(Vector3(0, 1, 0))
        lines.push_back(Vector3(gizmo_size, spatial.my_custom_value, 0))

        var handles = PoolVector3Array()

        handles.push_back(Vector3(0, 1, 0))
        handles.push_back(Vector3(gizmo_size, spatial.my_custom_value, 0))

        var material = get_plugin().get_material("main", self)
        add_lines(lines, material, false)

        var handles_material = get_plugin().get_material("handles", self)
        add_handles(handles, handles_material)


    # You should implement the rest of handle-related callbacks
    # (get_handle_name(), get_handle_value(), commit_handle()...).

Note that we just added some handles in the redraw method, but we still need to implement
the rest of handle-related callbacks in :ref:`EditorSpatialGizmo<class_EditorSpatialGizmo>`
to get properly working handles.


===================================================
/. ./tutorials/plugins/editor/inspector_plugins.rst
===================================================

.. _doc_inspector_plugins:

Inspector plugins
=================

The inspector dock allows you to create custom widgets to edit properties
through plugins. This can be beneficial when working with custom datatypes and
resources, although you can use the feature to change the inspector widgets for
built-in types. You can design custom controls for specific properties, entire
objects, and even separate controls associated with particular datatypes.

This guide explains how to use the :ref:`class_EditorInspectorPlugin` and
:ref:`class_EditorProperty` classes to create a custom interface for integers,
replacing the default behavior with a button that generates random values
between 0 and 99.

.. figure:: img/inspector_plugin_example.png
   :align: center

   The default behavior on the left and the end result on the right.


Setting up your plugin
----------------------

Create a new empty plugin to get started.

.. seealso:: See :ref:`doc_making_plugins` guide to set up your new plugin.

Let's assume you've called your plugin folder ``my_inspector_plugin``. If so,
you should end up with a new ``addons/my_inspector_plugin`` folder that contains
two files: ``plugin.cfg`` and ``plugin.gd``.

As before, ``plugin.gd`` is a script extending :ref:`class_EditorPlugin` and you
need to introduce new code for its ``_enter_tree`` and ``_exit_tree`` methods.
To set up your inspector plugin, you must load its script, then create and add
the instance by calling ``add_inspector_plugin()``. If the plugin is disabled,
you should remove the instance you have added by calling
``remove_inspector_plugin()``.

.. note:: Here, you are loading a script and not a packed scene. Therefore you
          should use ``new()`` instead of ``instance()``.

.. tabs::
  .. code-tab:: gdscript GDScript

    # plugin.gd
    tool
    extends EditorPlugin

    var plugin


    func _enter_tree():
        plugin = preload("res://addons/my_inspector_plugin/MyInspectorPlugin.gd").new()
        add_inspector_plugin(plugin)


    func _exit_tree():
        remove_inspector_plugin(plugin)

  .. code-tab:: csharp

    // Plugin.cs
    #if TOOLS
    using Godot;

    [Tool]
    public class Plugin : EditorPlugin
    {
        private MyInspectorPlugin _plugin;

        public override void _EnterTree()
        {
            _plugin = new MyInspectorPlugin();
            AddInspectorPlugin(_plugin);
        }

        public override void _ExitTree()
        {
            RemoveInspectorPlugin(_plugin);
        }
    }
    #endif


Interacting with the inspector
------------------------------

To interact with the inspector dock, your ``MyInspectorPlugin.gd`` script must
extend the :ref:`class_EditorInspectorPlugin` class. This class provides several
virtual methods that affect how the inspector handles properties.

To have any effect at all, the script must implement the ``can_handle()``
method. This function is called for each edited :ref:`class_Object` and must
return ``true`` if this plugin should handle the object or its properties.

.. note:: This includes any :ref:`class_Resource` attached to the object.

You can implement four other methods to add controls to the inspector at
specific positions. The ``parse_begin()`` and ``parse_end()`` methods are called
only once at the beginning and the end of parsing for each object, respectively.
They can add controls at the top or bottom of the inspector layout by calling
``add_custom_control()``.

As the editor parses the object, it calls the ``parse_category()`` and
``parse_property()`` methods. There, in addition to ``add_custom_control()``,
you can call both ``add_property_editor()`` and
``add_property_editor_for_multiple_properties()``. Use these last two methods to
specifically add :ref:`class_EditorProperty`-based controls.

.. tabs::
 .. code-tab:: gdscript GDScript

    # MyInspectorPlugin.gd
    extends EditorInspectorPlugin

    var RandomIntEditor = preload("res://addons/my_inspector_plugin/RandomIntEditor.gd")


    func can_handle(object):
        # We support all objects in this example.
        return true


    func parse_property(object, type, path, hint, hint_text, usage):
        # We handle properties of type integer.
        if type == TYPE_INT:
            # Create an instance of the custom property editor and register
            # it to a specific property path.
            add_property_editor(path, RandomIntEditor.new())
            # Inform the editor to remove the default property editor for
            # this property type.
            return true
        else:
            return false

 .. code-tab:: csharp

    // MyInspectorPlugin.cs
    #if TOOLS
    using Godot;

    public class MyInspectorPlugin : EditorInspectorPlugin
    {
        public override bool CanHandle(Object @object)
        {
            // We support all objects in this example.
            return true;
        }

        public override bool ParseProperty(Object @object, int type, string path, int hint, string hintText, int usage)
        {
            // We handle properties of type integer.
            if (type == (int)Variant.Type.Int)
            {
                // Create an instance of the custom property editor and register
                // it to a specific property path.
                AddPropertyEditor(path, new RandomIntEditor());
                // Inform the editor to remove the default property editor for
                // this property type.
                return true;
            }

            return false;
        }
    }
    #endif

Adding an interface to edit properties
--------------------------------------

The :ref:`class_EditorProperty` class is a special type of :ref:`class_Control`
that can interact with the inspector dock's edited objects. It doesn't display
anything but can house any other control nodes, including complex scenes.

There are three essential parts to the script extending
:ref:`class_EditorProperty`:

1. You must define the ``_init()`` method to set up the control nodes'
   structure.

2. You should implement the ``update_property()`` to handle changes to the data
   from the outside.

3. A signal must be emitted at some point to inform the inspector that the
   control has changed the property using ``emit_changed``.

You can display your custom widget in two ways. Use just the default ``add_child()``
method to display it to the right of the property name, and use ``add_child()``
followed by ``set_bottom_editor()`` to position it below the name.

.. tabs::
 .. code-tab:: gdscript GDScript

    # RandomIntEditor.gd
    extends EditorProperty


    # The main control for editing the property.
    var property_control = Button.new()
    # An internal value of the property.
    var current_value = 0
    # A guard against internal changes when the property is updated.
    var updating = false


    func _init():
        # Add the control as a direct child of EditorProperty node.
        add_child(property_control)
        # Make sure the control is able to retain the focus.
        add_focusable(property_control)
        # Setup the initial state and connect to the signal to track changes.
        refresh_control_text()
        property_control.connect("pressed", self, "_on_button_pressed")


    func _on_button_pressed():
        # Ignore the signal if the property is currently being updated.
        if (updating):
            return

        # Generate a new random integer between 0 and 99.
        current_value = randi() % 100
        refresh_control_text()
        emit_changed(get_edited_property(), current_value)


    func update_property():
        # Read the current value from the property.
        var new_value = get_edited_object()[get_edited_property()]
        if (new_value == current_value):
            return

        # Update the control with the new value.
        updating = true
        current_value = new_value
        refresh_control_text()
        updating = false

    func refresh_control_text():
        property_control.text = "Value: " + str(current_value)

 .. code-tab:: csharp

    // RandomIntEditor.cs
    #if TOOLS
    using Godot;

    public class RandomIntEditor : EditorProperty
    {
        // The main control for editing the property.
        private Button _propertyControl = new Button();
        // An internal value of the property.
        private int _currentValue = 0;
        // A guard against internal changes when the property is updated.
        private bool _updating = false;

        public RandomIntEditor()
        {
            // Add the control as a direct child of EditorProperty node.
            AddChild(_propertyControl);
            // Make sure the control is able to retain the focus.
            AddFocusable(_propertyControl);
            // Setup the initial state and connect to the signal to track changes.
            RefreshControlText();
            _propertyControl.Connect("pressed", this, nameof(OnButtonPressed));
        }

        private void OnButtonPressed()
        {
            // Ignore the signal if the property is currently being updated.
            if (_updating)
            {
                return;
            }

            // Generate a new random integer between 0 and 99.
            _currentValue = (int)GD.Randi() % 100;
            RefreshControlText();
            EmitChanged(GetEditedProperty(), _currentValue);
        }

        public override void UpdateProperty()
        {
            // Read the current value from the property.
            var newValue = (int)GetEditedObject().Get(GetEditedProperty());
            if (newValue == _currentValue)
            {
                return;
            }

            // Update the control with the new value.
            _updating = true;
            _currentValue = newValue;
            RefreshControlText();
            _updating = false;
        }

        private void RefreshControlText()
        {
            _propertyControl.Text = $"Value: {_currentValue}";
        }
    }
    #endif

Using the example code above you should be able to make a custom widget that
replaces the default :ref:`class_SpinBox` control for integers with a
:ref:`class_Button` that generates random values.


===================================================
/. ./tutorials/plugins/editor/visual_shader_plugins.rst
===================================================

.. _doc_visual_shader_plugins:

Visual Shader plugins
=====================

Visual Shader plugins are used to create custom :ref:`class_VisualShader` nodes
in GDScript.

The creation process is different from usual editor plugins. You do not need to
create a ``plugin.cfg`` file to register it; instead, create and save a script
file and it will be ready to use, provided the custom node is registered with
``class_name``.

This short tutorial will explain how to make a Perlin-3D noise node (original
code from this `GPU noise shaders plugin
<https://github.com/curly-brace/Godot-3.0-Noise-Shaders/blob/master/assets/gpu_noise_shaders/classic_perlin3d.tres>`_.

Create a Sprite and assign a :ref:`class_ShaderMaterial` to its material slot:

.. image:: img/visual_shader_plugins_start.png

Assign :ref:`class_VisualShader` to the shader slot of the material:

.. image:: img/visual_shader_plugins_start2.png

Don't forget to change its mode to "CanvasItem" (if you are using a Sprite):

.. image:: img/visual_shader_plugins_start3.png

Create a script which derives from :ref:`class_VisualShaderNodeCustom`. This is
all you need to initialize your plugin.

::

    # PerlinNoise3D.gd
    tool
    extends VisualShaderNodeCustom
    class_name VisualShaderNodePerlinNoise3D


    func _get_name():
        return "PerlinNoise3D"


    func _get_category():
        return "MyShaderNodes"


    func _get_description():
        return "Classic Perlin-Noise-3D function (by Curly-Brace)"


    func _get_return_icon_type():
        return VisualShaderNode.PORT_TYPE_SCALAR


    func _get_input_port_count():
        return 4


    func _get_input_port_name(port):
        match port:
            0:
                return "uv"
            1:
                return "offset"
            2:
                return "scale"
            3:
                return "time"


    func _get_input_port_type(port):
        match port:
            0:
                return VisualShaderNode.PORT_TYPE_VECTOR
            1:
                return VisualShaderNode.PORT_TYPE_VECTOR
            2:
                return VisualShaderNode.PORT_TYPE_SCALAR
            3:
                return VisualShaderNode.PORT_TYPE_SCALAR


    func _get_output_port_count():
        return 1


    func _get_output_port_name(port):
        return "result"


    func _get_output_port_type(port):
        return VisualShaderNode.PORT_TYPE_SCALAR


    func _get_global_code(mode):
        return """
            vec3 mod289_3(vec3 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289_4(vec4 x) {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x) {
                return mod289_4(((x * 34.0) + 1.0) * x);
            }

            vec4 taylorInvSqrt(vec4 r) {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
                return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
            }

            // Classic Perlin noise.
            float cnoise(vec3 P) {
                vec3 Pi0 = floor(P); // Integer part for indexing.
                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1.
                Pi0 = mod289_3(Pi0);
                Pi1 = mod289_3(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation.
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0.
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = vec4(Pi0.z);
                vec4 iz1 = vec4(Pi1.z);

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
                vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
                vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
                vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
                vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
                vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
                vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
                vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }
        """


    func _get_code(input_vars, output_vars, mode, type):
        return output_vars[0] + " = cnoise(vec3((%s.xy + %s.xy) * %s, %s)) * 0.5 + 0.5;" % [input_vars[0], input_vars[1], input_vars[2], input_vars[3]]

Save it and open the Visual Shader. You should see your new node type within the member's dialog (if you can't see your new node, try restarting the editor):

.. image:: img/visual_shader_plugins_result1.png

Place it on a graph and connect the required ports:

.. image:: img/visual_shader_plugins_result2.png

That is everything you need to do, as you can see it is easy to create your own custom VisualShader nodes!


===================================================
/. ./tutorials/plugins/running_code_in_the_editor.rst
===================================================

.. _doc_running_code_in_the_editor:

Running code in the editor
==========================

What is ``tool``?
-----------------

``tool`` is a powerful line of code that, when added at the top of your script, makes it execute in the editor. You can also decide which parts of the script execute in the editor, which in game, and which in both.

You can use it for doing many things, but it is mostly useful in level design for visually presenting things that are hard to predict ourselves. Here are some use cases:

- If you have a cannon that shoots cannonballs affected by physics (gravity), you can draw the cannonball's trajectory in the editor, making level design a lot easier.
- If you have jumppads with varying jump heights, you can draw the maximum jump height a player would reach if it jumped on one, also making level design easier.
- If your player doesn't use a sprite, but draws itself using code, you can make that drawing code execute in the editor to see your player.

.. DANGER::

    ``tool`` scripts run inside the editor, and let you access the scene tree
    of the currently edited scene. This is a powerful feature which also comes
    with caveats, as the editor does not include protections for potential
    misuse of ``tool`` scripts.
    Be **extremely** cautious when manipulating the scene tree, especially via
    :ref:`Node.queue_free<class_Node_method_queue_free>`, as it can cause
    crashes if you free a node while the editor runs logic involving it.

How to use it
-------------

To turn a script into a tool, add the keyword ``tool`` at the top of your code.

To check if you are currently in the editor, use: ``Engine.editor_hint``.

For example, if you want to execute some code only in the editor, use:

.. tabs::
 .. code-tab:: gdscript GDScript

    if Engine.editor_hint:
        # Code to execute when in editor.

 .. code-tab:: csharp

    if (Engine.EditorHint)
    {
        // Code to execute when in editor.
    }

On the other hand, if you want to execute code only in game, simply negate the same statement:

.. tabs::
 .. code-tab:: gdscript GDScript

    if not Engine.editor_hint:
        # Code to execute when in game.

 .. code-tab:: csharp

    if (!Engine.EditorHint)
    {
        // Code to execute when in game.
    }

Pieces of code do not have either of the 2 conditions above will run both in-editor and in-game.

Here is how a ``_process()`` function might look for you:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        if Engine.editor_hint:
            # Code to execute in editor.

        if not Engine.editor_hint:
            # Code to execute in game.

        # Code to execute both in editor and in game.

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        if (Engine.EditorHint)
        {
            // Code to execute in editor.
        }

        if (!Engine.EditorHint)
        {
            // Code to execute in game.
        }

        // Code to execute both in editor and in game.
    }

.. note:: Modifications in editor are permanent. For example, in the following case, when we remove the script, the node will keep its rotation. Be careful to avoid making unwanted modifications.

Try it out
-----------

Add a ``Sprite`` node to your scene and set the texture to Godot icon. Attach and open a script, and change it to this:

.. tabs::
 .. code-tab:: gdscript GDScript

    tool
    extends Sprite

    func _process(delta):
        rotation_degrees += 180 * delta

 .. code-tab:: csharp

    using Godot;
    using System;

    [Tool]
    public class MySprite : Sprite
    {
        public override void _Process(float delta)
        {
            RotationDegrees += 180 * delta;
        }
    }

Save the script and return to the editor. You should now see your object rotate. If you run the game, it will also rotate.

.. image:: img/rotating_in_editor.gif

.. note:: If you don't see the changes, reload the scene (close it and open it again).

Now let's choose which code runs when. Modify your ``_process()`` function to look like this:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        if Engine.editor_hint:
            rotation_degrees += 180 * delta
        else:
            rotation_degrees -= 180 * delta

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        if (Engine.EditorHint)
        {
            RotationDegrees += 180 * delta;
        }
        else
        {
            RotationDegrees -= 180 * delta;
        }
    }

Save the script. Now the object will spin clockwise in the editor, but if you run the game, it will spin counter-clockwise.

Editing variables
-----------------
Add and export a variable speed to the script. The function set_speed after "setget" is executed with your input to change the variable.
Modify  ``_process()`` to include the rotation speed.

.. tabs::
 .. code-tab:: gdscript GDScript

    tool
    extends Sprite


    export var speed = 1 setget set_speed


    # Update speed and reset the rotation.
    func set_speed(new_speed):
    	speed = new_speed
    	rotation_degrees = 0


    func _process(delta):
    	rotation_degrees += 180 * delta * speed

 .. code-tab:: csharp

    using Godot;
    using System;

    [Tool]
    public class MySprite : Sprite
    {
        private float speed = 1;

        [Export]
        public float Speed {
            get => speed;
            set => SetSpeed(value);
        }

        // Update speed and reset the rotation.
        private void SetSpeed(float newSpeed)
        {
            speed = newSpeed;
            RotationDegrees = 0;
        }

        public override void _Process(float delta)
        {
            RotationDegrees += 180 * delta * speed;
        }
    }

.. note:: Code from other nodes doesn't run in the editor. Your access to other nodes is limited. You can access the tree and nodes, and their default properties, but you can't access user variables. If you want to do so, other nodes have to run in the editor too. AutoLoad nodes cannot be accessed in the editor at all.

Instancing scenes
-----------------

You can instantiate packed scenes normally and add them to the scene currently
opened in the editor. By default, nodes or scenes added with
:ref:`Node.add_child(node) <class_Node_method_add_child>` are **not** visible
in the Scene tree dock and are **not** persisted to disk. If you wish the node
or scene to be visible in the scene tree dock and persisted to disk when saving
the scene, you need to set the child node's :ref:`owner <class_Node_property_owner>`
property to the currently edited scene root.

If you are using ``tool``:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        var node = Spatial.new()
        add_child(node) # Parent could be any node in the scene

        # The line below is required to make the node visible in the Scene tree dock
        # and persist changes made by the tool script to the saved scene file.
        node.set_owner(get_tree().edited_scene_root)

 .. code-tab:: csharp

    public override void _Ready()
    {
        var node = new Spatial();
        AddChild(node); // Parent could be any node in the scene

        // The line below is required to make the node visible in the Scene tree dock
        // and persist changes made by the tool script to the saved scene file.
        node.Owner = GetTree().EditedSceneRoot;
    }

If you are using :ref:`EditorScript<class_EditorScript>`:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _run():
        var parent = get_scene().find_node("Parent") # Parent could be any node in the scene
        var node = Spatial.new()
        parent.add_child(node)

        # The line below is required to make the node visible in the Scene tree dock
        # and persist changes made by the tool script to the saved scene file.
        node.set_owner(get_scene())

 .. code-tab:: csharp

    public override void _Run()
    {
        var parent = GetScene().FindNode("Parent"); // Parent could be any node in the scene
        var node = new Spatial();
        parent.AddChild(node);

        // The line below is required to make the node visible in the Scene tree dock
        // and persist changes made by the tool script to the saved scene file.
        node.Owner = GetScene();
    }

.. warning:: Using ``tool`` improperly can yield many errors. It is advised to first write the code how you want it, and only then add the ``tool`` keyword to the top. Also, make sure to separate code that runs in-editor from code that runs in-game. This way, you can find bugs more easily.


===================================================
/. ./tutorials/rendering/index.rst
===================================================

Rendering
=========

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-rendering

   viewports
   multiple_resolutions
   jitter_stutter
   gles2_gles3_differences


===================================================
/. ./tutorials/rendering/viewports.rst
===================================================

.. _doc_viewports:

Using Viewports
===============

Introduction
------------

Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game is projected. In order
to see the game, we need to have a surface on which to draw it; that surface is
the Root :ref:`Viewport <class_Viewport>`.

.. image:: img/viewportnode.png


:ref:`Viewports <class_Viewport>` can also be added to the scene so that there
are multiple surfaces to draw on. When we are drawing to a :ref:`Viewport <class_Viewport>`
that is not the Root, we call it a render target. We can access the contents
of a render target by accessing its corresponding :ref:`texture <class_ViewportTexture>`.
By using a :ref:`Viewport <class_Viewport>` as a render target,
we can either render multiple scenes simultaneously or we can render to
a :ref:`texture <class_ViewportTexture>` which is applied to an object in the scene, for example a dynamic
skybox.

:ref:`Viewports <class_Viewport>` have a variety of use cases, including:

- Rendering 3D objects within a 2D game
- Rendering 2D elements in a 3D game
- Rendering dynamic textures
- Generating procedural textures at runtime
- Rendering multiple cameras in the same scene

What all these use cases have in common is that you are given the ability to
draw objects to a texture as if it were another screen and can then choose
what to do with the resulting texture.

Input
-----

:ref:`Viewports <class_Viewport>` are also responsible for delivering properly adjusted and
scaled input events to all their children nodes. Typically, input is received by the
nearest :ref:`Viewport <class_Viewport>` in the tree, but you can set :ref:`Viewports <class_Viewport>` not to receive input by checking
'Disable Input' to 'on'; this will allow the next nearest :ref:`Viewport <class_Viewport>` in the tree to capture
the input.

.. image:: img/input.png

For more information on how Godot handles input, please read the :ref:`Input Event Tutorial<doc_inputevent>`.

Listener
--------

Godot supports 3D sound (in both 2D and 3D nodes); more on this can be
found in the :ref:`Audio Streams Tutorial<doc_audio_streams>`. For this type of sound to be
audible, the :ref:`Viewport <class_Viewport>` needs to be enabled as a listener (for 2D or 3D).
If you are using a custom :ref:`Viewport <class_Viewport>` to display your :ref:`World <class_World>`, don't forget
to enable this!

Cameras (2D & 3D)
-----------------

When using a :ref:`Camera <class_Camera>` /
:ref:`Camera2D <class_Camera2D>`, cameras will always display on the
closest parent :ref:`Viewport <class_Viewport>` (going towards the root). For example, in the
following hierarchy:

.. image:: img/cameras.png

CameraA will display on the Root :ref:`Viewport <class_Viewport>` and it will draw MeshA. CameraB
will be captured by the :ref:`Viewport <class_Viewport>` Node along with MeshB. Even though MeshB is in the scene
hierarchy, it will still not be drawn to the Root :ref:`Viewport <class_Viewport>`. Similarly MeshA will not
be visible from the :ref:`Viewport <class_Viewport>` node because :ref:`Viewport <class_Viewport>` nodes only
capture nodes below them in the hierarchy.

There can only be one active camera per :ref:`Viewport <class_Viewport>`, so if there is more
than one, make sure that the desired one has the "current" property set,
or make it the current camera by calling:

::

    camera.make_current()

By default, cameras will render all objects in their world. In 3D, cameras can use their
:ref:`cull_mask <class_Camera_property_cull_mask>` property combined with the
:ref:`VisualInstance's <class_VisualInstance>` :ref:`layer <class_VisualInstance_property_layers>`
property to restrict which objects are rendered.

Scale & stretching
------------------

:ref:`Viewports <class_Viewport>` have a "size" property, which represents the size of the :ref:`Viewport <class_Viewport>`
in pixels. For :ref:`Viewports <class_Viewport>` which are children of :ref:`ViewportContainers <class_viewportcontainer>`,
these values are overridden, but for all others, this sets their resolution.

It is also possible to scale the 2D content and make the :ref:`Viewport <class_Viewport>` resolution
different from the one specified in size, by calling:

::

    viewport.set_size_override(true, Vector2(width, height)) # Custom size for 2D.
    viewport.set_size_override_stretch(true) # Enable stretch for custom size.

The root :ref:`Viewport <class_Viewport>` uses this for the stretch options in the project
settings. For more information on scaling and stretching visit the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`

Worlds
------

For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World <class_World>`. This
is basically the universe that links physics and rendering together.
Spatial-based nodes will register using the :ref:`World <class_World>` of the closest
:ref:`Viewport <class_Viewport>`. By default, newly created :ref:`Viewports <class_Viewport>` do not contain a :ref:`World <class_World>` but
use the same as their parent :ref:`Viewport <class_Viewport>` (the root :ref:`Viewport <class_Viewport>` always contains a
:ref:`World <class_World>`, which is the one objects are rendered to by default). A :ref:`World <class_World>` can
be set in a :ref:`Viewport <class_Viewport>` using the "world" property, and that will separate
all children nodes of that :ref:`Viewport <class_Viewport>` from interacting with the parent
:ref:`Viewport's <class_Viewport>` :ref:`World <class_World>`. This is especially useful in scenarios where, for
example, you might want to show a separate character in 3D imposed over
the game (like in StarCraft).

As a helper for situations where you want to create :ref:`Viewports <class_Viewport>` that
display single objects and don't want to create a :ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` has
the option to use its own :ref:`World <class_World>`. This is useful when you want to
instance 3D characters or objects in a 2D :ref:`World <class_World2D>`.

For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:`World2D <class_World2D>`.
This suffices in most cases, but in case sharing them may be desired, it
is possible to do so by setting the :ref:`Viewport's <class_Viewport>` :ref:`World2D <class_World2D>` manually.

For an example of how this works, see the demo projects `3D in 2D <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/2d_in_3d>`_ respectively.

Capture
-------

It is possible to query a capture of the :ref:`Viewport <class_Viewport>` contents. For the root
:ref:`Viewport <class_Viewport>`, this is effectively a screen capture. This is done with the
following code:

::

   # Retrieve the captured Image using get_data().
   var img = get_viewport().get_texture().get_data()
   # Flip on the Y axis.
   # You can also set "V Flip" to true if not on the root Viewport.
   img.flip_y()
   # Convert Image to ImageTexture.
   var tex = ImageTexture.new()
   tex.create_from_image(img)
   # Set Sprite Texture.
   $sprite.texture = tex

But if you use this in ``_ready()`` or from the first frame of the :ref:`Viewport's <class_Viewport>` initialization,
you will get an empty texture because there is nothing to get as texture. You can deal with
it using (for example):

::

   # Wait until the frame has finished before getting the texture.
   yield(VisualServer, "frame_post_draw")
   # You can get the image after this.

Viewport Container
------------------

If the :ref:`Viewport <class_Viewport>` is a child of a :ref:`ViewportContainer <class_viewportcontainer>`, it will become active and display anything it has inside. The layout looks like this:

.. image:: img/container.png

The :ref:`Viewport <class_Viewport>` will cover the area of its parent :ref:`ViewportContainer <class_viewportcontainer>` completely
if :ref:`Stretch<class_viewportcontainer_property_stretch>` is set to ``true`` in :ref:`ViewportContainer <class_viewportcontainer>`.
Note: The size of the :ref:`ViewportContainer <class_viewportcontainer>` cannot be smaller than the size of the :ref:`Viewport <class_Viewport>`.

Rendering
---------

Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway into another rendering surface, it exposes a few
rendering properties that can be different from the project settings. The first is MSAA; you can
choose to use a different level of MSAA for each :ref:`Viewport <class_Viewport>`; the default behavior is DISABLED.
You can also set the :ref:`Viewport <class_Viewport>` to use HDR, HDR is very useful for when you want to store values in the texture that are outside the range 0.0 - 1.0.

If you know how the :ref:`Viewport <class_Viewport>` is going to be used, you can set its Usage to either 3D or 2D. Godot will then
restrict how the :ref:`Viewport <class_Viewport>` is drawn to in accordance with your choice; default is 3D.
The 2D usage mode is slightly faster and uses less memory compared to the 3D one. It's a good idea to set the :ref:`Viewport <class_Viewport>`'s Usage property to 2D if your viewport doesn't render anything in 3D.

.. note::

    If you need to render 3D shadows in the viewport, make sure to set the viewport's *Shadow Atlas Size* property to a value higher than 0.
    Otherwise, shadows won't be rendered. For reference, the Project Settings define it to 4096 by default.

Godot also provides a way of customizing how everything is drawn inside :ref:`Viewports <class_Viewport>` using “Debug Draw”.
Debug Draw allows you to specify one of four options for how the :ref:`Viewport <class_Viewport>` will display things drawn
inside it. Debug Draw is disabled by default.

.. image:: img/default_scene.png

*A scene drawn with Debug Draw disabled*

The other three options are Unshaded, Overdraw, and Wireframe. Unshaded draws the scene
without using lighting information so all the objects appear flatly colored the color of
their albedo.

.. image:: img/unshaded.png

*The same scene with Debug Draw set to Unshaded*

Overdraw draws the meshes semi-transparent with an additive blend so you can see how the meshes overlap.

.. image:: img/overdraw.png

*The same scene with Debug Draw set to Overdraw*

Lastly, Wireframe draws the scene using only the edges of triangles in the meshes.

.. note::

    The effects of the Wireframe mode are only visible in the editor, not while the project is running.

Render target
-------------

When rendering to a :ref:`Viewport <class_Viewport>`, whatever is inside will not be
visible in the scene editor. To display the contents, you have to draw the :ref:`Viewport's <class_Viewport>` :ref:`ViewportTexture <class_ViewportTexture>` somewhere.
This can be requested via code using (for example):

::

    # This gives us the ViewportTexture.
    var rtt = viewport.get_texture()
    sprite.texture = rtt

Or it can be assigned in the editor by selecting "New ViewportTexture"

.. image:: img/texturemenu.png

and then selecting the :ref:`Viewport <class_Viewport>` you want to use.

.. image:: img/texturepath.png

Every frame, the :ref:`Viewport <class_Viewport>`'s texture is cleared away with the default clear color (or a transparent
color if :ref:`Transparent Bg<class_Viewport_property_transparent_bg>` is set to ``true``). This can be changed by setting :ref:`Clear Mode<class_Viewport_property_render_target_clear_mode>` to Never or Next Frame.
As the name implies, Never means the texture will never be cleared, while next frame will
clear the texture on the next frame and then set itself to Never.

By default, re-rendering of the :ref:`Viewport <class_Viewport>` happens when the
:ref:`Viewport <class_Viewport>`'s :ref:`ViewportTexture <class_ViewportTexture>` has been drawn in a frame. If visible, it will be
rendered; otherwise, it will not. This behavior can be changed to manual
rendering (once), or always render, no matter if visible or not. This flexibility
allows users to render an image once and then use the texture without
incurring the cost of rendering every frame.


Make sure to check the Viewport demos! Viewport folder in the demos
archive available to download, or
https://github.com/godotengine/godot-demo-projects/tree/master/viewport


===================================================
/. ./tutorials/rendering/multiple_resolutions.rst
===================================================

.. _doc_multiple_resolutions:

Multiple resolutions
====================

The problem of multiple resolutions
-----------------------------------

Developers often have trouble understanding how to best support multiple
resolutions in their games. For desktop and console games, this is more or less
straightforward, as most screen aspect ratios are 16:9 and resolutions
are standard (720p, 1080p, 1440p, 4K, …).

For mobile games, at first, it was easy. For many years, the iPhone and iPad
used the same resolution. When *Retina* was implemented, they just doubled
the pixel density; most developers had to supply assets in default and double
resolutions.

Nowadays, this is no longer the case, as there are plenty of different screen
sizes, densities, and aspect ratios. Non-conventional sizes are also becoming
increasingly popular, such as ultrawide displays.

For 3D games, there is not much of a need to support multiple resolutions (from
the aesthetic point of view). The 3D geometry will just fill the screen based on
the field of view, disregarding the aspect ratio. The main reason one may want
to support this, in this case, is for *performance* reasons (running in lower
resolution to increase frames per second).

For 2D and game UIs, this is a different matter, as art needs to be created
using specific pixel sizes in software such as Photoshop, GIMP or Krita.

Since layouts, aspect ratios, resolutions, and pixel densities can change so
much, it is no longer possible to design UIs for every specific screen.
Another method must be used.

One size fits all
-----------------

The most common approach is to use a single *base* resolution and
then fit it to everything else. This resolution is how most players are expected
to play the game (given their hardware). For mobile, Google has useful `stats
<https://developer.android.com/about/dashboards>`_ online, and for desktop,
Steam `also does <https://store.steampowered.com/hwsurvey/>`_.

As an example, Steam shows that the most common *primary display resolution* is
1920×1080, so a sensible approach is to develop a game for this resolution, then
handle scaling for different sizes and aspect ratios.

Godot provides several useful tools to do this easily.

.. seealso::

    You can see how Godot's support for multiple resolutions works in action using the
    `Multiple Resolutions and Aspect Ratios demo project <https://github.com/godotengine/godot-demo-projects/tree/3.x/gui/multiple_resolutions>`__.

Base size
---------

A base size for the window can be specified in the Project Settings under
**Display → Window**.

.. image:: img/screenres.png

However, what it does is not completely obvious; the engine will *not*
attempt to switch the monitor to this resolution. Rather, think of this
setting as the "design size", i.e. the size of the area that you work
with in the editor. This setting corresponds directly to the size of the
blue rectangle in the 2D editor.

There is often a need to support devices with screen and window sizes
that are different from this base size. Godot offers many ways to
control how the viewport will be resized and stretched to different
screen sizes.

.. note::

   Godot follows a modern approach to multiple resolutions. The engine will
   never change the monitor's resolution on its own. While changing the
   monitor's resolution is the most efficient approach, it's also the least
   reliable approach as it can leave the monitor stuck on a low resolution if
   the game crashes. This is especially common on macOS or Linux which don't
   handle resolution changes as well as Windows.

   Changing the monitor's resolution also removes any control from the game
   developer over filtering and aspect ratio stretching, which can be important
   to ensure correct display for pixel art games.

   On top of that, changing the monitor's resolution makes alt-tabbing in and
   out of a game much slower since the monitor has to change resolutions every
   time this is done.

Resizing
--------

There are several types of devices, with several types of screens, which
in turn have different pixel density and resolutions. Handling all of
them can be a lot of work, so Godot tries to make the developer's life a
little easier. The :ref:`Viewport <class_Viewport>`
node has several functions to handle resizing, and the root node of the
scene tree is always a viewport (scenes loaded are instanced as a child
of it, and it can always be accessed by calling
``get_tree().get_root()`` or ``get_node("/root")``).

In any case, while changing the root Viewport params is probably the
most flexible way to deal with the problem, it can be a lot of work,
code and guessing, so Godot provides a simple set of parameters in the
project settings to handle multiple resolutions.

Stretch settings
----------------

Stretch settings are located in the project settings and provide several options:

.. image:: img/stretchsettings.png

Stretch Mode
^^^^^^^^^^^^

The **Stretch Mode** setting defines how the base size is stretched to fit
the resolution of the window or screen.

.. image:: img/stretch.png

The animations below use a "base size" of just 16×9 pixels to
demonstrate the effect of different stretch modes. A single sprite, also
16×9 pixels in size, covers the entire viewport, and a diagonal
:ref:`Line2D <class_Line2D>` is added on top of it:

.. image:: img/stretch_demo_scene.png

.. Animated GIFs are generated from:
.. https://github.com/ttencate/godot_scaling_mode

-  **Stretch Mode = Disabled** (default): No stretching happens. One
   unit in the scene corresponds to one pixel on the screen. In this
   mode, the **Stretch Aspect** setting has no effect.

   .. image:: img/stretch_disabled_expand.gif

-  **Stretch Mode = 2D**: In this mode, the base size specified in
   width and height in the project settings is
   stretched to cover the whole screen (taking the **Stretch Aspect**
   setting into account). This means that everything is rendered
   directly at the target resolution. 3D is unaffected,
   while in 2D, there is no longer a 1:1 correspondence between sprite
   pixels and screen pixels, which may result in scaling artifacts.

   .. image:: img/stretch_2d_expand.gif

-  **Stretch Mode = Viewport**: Viewport scaling means that the size of
   the root :ref:`Viewport <class_Viewport>` is set precisely to the
   base size specified in the Project Settings' **Display** section.
   The scene is rendered to this viewport first. Finally, this viewport
   is scaled to fit the screen (taking the **Stretch Aspect** setting into
   account).

   .. image:: img/stretch_viewport_expand.gif

Stretch Aspect
^^^^^^^^^^^^^^

The second setting is the stretch aspect. Note that this only takes effect if
**Stretch Mode** is set to something other than **Disabled**.

In the animations below, you will notice gray and black areas. The black
areas are added by the engine and cannot be drawn into. The gray areas
are part of your scene, and can be drawn to. The gray areas correspond
to the region outside the blue frame you see in the 2D editor.

-  **Stretch Aspect = Ignore**: Ignore the aspect ratio when stretching
   the screen. This means that the original resolution will be stretched
   to exactly fill the screen, even if it's wider or narrower. This may
   result in nonuniform stretching: things looking wider or taller than
   designed.

   .. image:: img/stretch_viewport_ignore.gif

-  **Stretch Aspect = Keep**: Keep aspect ratio when stretching the
   screen. This means that the viewport retains its original size
   regardless of the screen resolution, and black bars will be added to
   the top/bottom of the screen ("letterboxing") or the sides
   ("pillarboxing").

   This is a good option if you know the aspect ratio of your target
   devices in advance, or if you don't want to handle different aspect
   ratios.

   .. image:: img/stretch_viewport_keep.gif

-  **Stretch Aspect = Keep Width**: Keep aspect ratio when stretching the
   screen. If the screen is wider than the base size, black bars are
   added at the left and right (pillarboxing). But if the screen is
   taller than the base resolution, the viewport will be grown in the
   vertical direction (and more content will be visible to the bottom).
   You can also think of this as "Expand Vertically".

   This is usually the best option for creating GUIs or HUDs that scale,
   so some controls can be anchored to the bottom
   (:ref:`doc_size_and_anchors`).

   .. image:: img/stretch_viewport_keep_width.gif

-  **Stretch Aspect = Keep Height**: Keep aspect ratio when stretching
   the screen. If the screen is taller than the base size, black
   bars are added at the top and bottom (letterboxing). But if the
   screen is wider than the base resolution, the viewport will be grown
   in the horizontal direction (and more content will be visible to the
   right). You can also think of this as "Expand Horizontally".

   This is usually the best option for 2D games that scroll horizontally
   (like runners or platformers).

   .. image:: img/stretch_viewport_keep_height.gif

-  **Stretch Aspect = Expand**: Keep aspect ratio when stretching the
   screen, but keep neither the base width nor height. Depending on the
   screen aspect ratio, the viewport will either be larger in the
   horizontal direction (if the screen is wider than the base size) or
   in the vertical direction (if the screen is taller than the original
   size).

   .. image:: img/stretch_viewport_expand.gif

.. tip::

    To support both portrait and landscape mode with a similar automatically
    determined scale factor, set your project's base resolution to be a *square*
    (1:1 aspect ratio) instead of a rectangle. For instance, if you wish to design
    for 1280×720 as the base resolution but wish to support both portrait and
    landscape mode, use 720×720 as the project's base window size in the
    Project Settings.

    To allow the user to choose their preferred screen orientation at run-time,
    remember to set **Display > Window > Handheld > Orientation** to ``sensor``.

Stretch Shrink
^^^^^^^^^^^^^^

The **Shrink** setting allows you to add an extra scaling factor on top of
what the **Stretch** options above already provide. The default value of 1
means that no scaling occurs.

If, for example, you set **Shrink** to 4 and leave **Stretch Mode** on
**Disabled**, each unit in your scene will correspond to 4×4 pixels on the
screen.

If **Stretch Mode** is set to something other than **Disabled**, the size of
the root viewport is scaled down by the **Shrink** factor, and pixels
in the output are scaled up by the same amount. This is rarely useful for
2D games, but can be used to increase performance in 3D games
by rendering them at a lower resolution.

From scripts
^^^^^^^^^^^^

To configure stretching at runtime from a script, use the
``get_tree().set_screen_stretch()`` method (see
:ref:`SceneTree.set_screen_stretch() <class_SceneTree_method_set_screen_stretch>`).

Common use case scenarios
-------------------------

The following settings are recommended to support multiple resolutions and aspect
ratios well.

Desktop game
^^^^^^^^^^^^

**Non-pixel art:**

- Set the base window width to ``1920`` and window height to ``1080``. If you have a
  display smaller than 1920×1080, set **Test Width** and **Test Height** to
  lower values to make the window smaller when the project starts.
- Alternatively, if you're targeting high-end devices primarily, set the base
  window width to ``3840`` and window height to ``2160``.
  This allows you to provide higher resolution 2D assets, resulting in crisper
  visuals at the cost of higher memory usage and file sizes.
  Note that this will make non-mipmapped textures grainy on low resolution devices,
  so make sure to follow the instructions described in
  :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`.
- Set the stretch mode to ``2d``.
- Set the stretch aspect to ``expand``. This allows for supporting multiple aspect ratios
  and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).
- Configure Control nodes' anchors to snap to the correct corners using the **Layout** menu.

**Pixel art:**

- Set the base window size to the viewport size you intend to use. Most pixel art games
  use viewport sizes between 256×224 and 640×480. Higher viewport sizes will
  require using higher resolution artwork, unless you intend to show more of the
  game world at a given time.
- Set the stretch mode to ``viewport``.
- Set the stretch aspect to ``keep`` to enforce a single aspect ratio (with
  black bars). As an alternative, you can set the stretch aspect to ``expand`` to
  support multiple aspect ratios.
- If using the ``expand`` stretch aspect, Configure Control nodes' anchors to
  snap to the correct corners using the **Layout** menu.

.. note::

    The ``viewport`` stretch mode provides low-resolution rendering that is then
    stretched to the final window size. If you are OK with sprites being able to
    move or rotate in "sub-pixel" positions or wish to have a high resolution 3D
    viewport, you should use the ``2d`` stretch mode instead of the ``viewport``
    stretch mode.

    Godot currently doesn't have a way to enforce integer scaling when using the
    ``2d`` or ``viewport`` stretch mode, which means pixel art may look bad if the
    final window size is not a multiple of the base window size.
    To fix this, use an add-on such as the `Integer Resolution Handler <https://github.com/Yukitty/godot-addon-integer_resolution_handler>`__.

Mobile game in landscape mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Godot is configured to use landscape mode by default. This means you don't need
to change the display orientation project setting.

- Set the base window width to ``1280`` and window height to ``720``.
- Alternatively, if you're targeting high-end devices primarily, set the base
  window width to ``1920`` and window height to ``1080``.
  This allows you to provide higher resolution 2D assets, resulting in crisper
  visuals at the cost of higher memory usage and file sizes. Many devices have
  even higher resolution displays (1440p), but the difference with 1080p is
  barely visible given the small size of smartphone displays.
  Note that this will make non-mipmapped textures grainy on low resolution devices,
  so make sure to follow the instructions described in
  :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`.
- Set the stretch mode to ``2d``.
- Set the stretch aspect to ``expand``. This allows for supporting multiple aspect ratios
  and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).
- Configure Control nodes' anchors to snap to the correct corners using the **Layout** menu.

Mobile game in portrait mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Set the base window width to ``720`` and window height to ``1080``.
- Alternatively, if you're targeting high-end devices primarily, set the base
  window width to ``1080`` and window height to ``1920``.
  This allows you to provide higher resolution 2D assets, resulting in crisper
  visuals at the cost of higher memory usage and file sizes. Many devices have
  even higher resolution displays (1440p), but the difference with 1080p is
  barely visible given the small size of smartphone displays.
  Note that this will make non-mipmapped textures grainy on low resolution devices,
  so make sure to follow the instructions described in
  :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`.
- Set **Display > Window > Handheld > Orientation** to ``portrait``.
- Set the stretch mode to ``2d``.
- Set the stretch aspect to ``expand``. This allows for supporting multiple aspect ratios
  and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).
- Configure Control nodes' anchors to snap to the correct corners using the **Layout** menu.

Non-game application
^^^^^^^^^^^^^^^^^^^^

- Set the base window width and height to the smallest window size that you intend to target.
  This is not required, but this ensures that you design your UI with small window sizes in mind.
- Keep the stretch mode to its default value, ``disabled``.
- Keep the stretch aspect to its default value, ``ignore``
  (its value won't be used since the stretch mode is ``disabled``).
- You can define a minimum window size by setting ``OS.min_window_size`` in a
  script's ``_ready()`` function. This prevents the user from resizing the application
  below a certain size, which could break the UI layout.

.. note::

    Godot doesn't support manually overriding the 2D scale factor yet, so it is
    not possible to have hiDPI support in non-game applications. Due to this, it
    is recommended to leave **Allow Hidpi** disabled in non-game applications to
    allow for the OS to use its low-DPI fallback.

hiDPI support
-------------

By default, Godot projects aren't considered DPI-aware by the operating system.
This is done to improve performance on low-end systems, since the operating
system's DPI fallback scaling will be faster than letting the application scale
itself (even when using the ``viewport`` stretch mode).

However, the OS-provided DPI fallback scaling doesn't play well with fullscreen
mode. If you want crisp visuals on hiDPI displays or if project uses fullscreen,
it's recommended to enable **Display > Window > Dpi > Allow Hidpi** in the
Project Settings.

**Allow Hidpi** is only effective on Windows and macOS. It's ignored on all
other platforms.

.. note::

    The Godot editor itself is always marked as DPI-aware. Running the project
    from the editor will only be DPI-aware if **Allow Hidpi** is enabled in the
    Project Settings.

.. _doc_multiple_resolutions_reducing_aliasing_on_downsampling:

Reducing aliasing on downsampling
---------------------------------

If the game has a very high base resolution (e.g. 3840×2160), aliasing might
appear when downsampling to something considerably lower like 1280×720.
Aliasing can be made less visible by shrinking all images by a factor of 2
upon loading. This can be done by calling the method below before
the game data is loaded::

    VisualServer.texture_set_shrink_all_x2_on_set_data(true)

Alternatively, you can also enable mipmaps on all your 2D textures. However,
enabling mipmaps will increase memory usage which may be problematic on low-end
mobile devices.

Handling aspect ratios
----------------------

Once scaling for different resolutions is accounted for, make sure that
your *user interface* also scales for different aspect ratios. This can be
done using :ref:`anchors <doc_size_and_anchors>` and/or :ref:`containers
<doc_gui_containers>`.

Field of view scaling
---------------------

The 3D Camera node's **Keep Aspect** property defaults to the **Keep Height**
scaling mode (also called *Hor+*). This is usually the best value for desktop
games and mobile games in landscape mode, as widescreen displays will
automatically use a wider field of view.

However, if your 3D game is intended to be played in portrait mode, it may make
more sense to use **Keep Width** instead (also called *Vert-*). This way,
smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use a
*taller* field of view, which is more logical here.

Scaling 2D and 3D elements differently using Viewports
------------------------------------------------------

Using multiple Viewport nodes, you can have different scales for various
elements. For instance, you can use this to render the 3D world at a low
resolution while keeping 2D elements at the native resolution. This can improve
performance significantly while keeping the HUD and other 2D elements crisp.

This is done by using the root Viewport node only for 2D elements, then creating
a Viewport node to display the 3D world and displaying it using a
ViewportContainer or TextureRect node. There will effectively be two viewports
in the final project. One upside of using TextureRect over ViewportContainer is
that it allows enable linear filtering. This makes scaled 3D viewports look
better in many cases.

See the
`3D viewport scaling demo <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_scaling>`__
for examples.


===================================================
/. ./tutorials/rendering/jitter_stutter.rst
===================================================

.. _doc_jitter_stutter:

Fixing jitter, stutter and input lag
====================================

What is jitter, stutter and input lag?
--------------------------------------

*Jitter* and *stutter* are two different alterations to visible motion of
objects on screen that may affect a game, even when running at full speed. These
effects are mostly visible in games where the world moves at a constant speed in
a fixed direction, like runners or platformers.

*Input lag* is unrelated to jitter and stutter, but is sometimes discussed
alongside. Input lag refers to visible on-screen delay when performing actions
with the mouse, keyboard, controller or touchscreen. It can be related to game
code, engine code or external factors (such as hardware). Input lag is most
noticeable in games that use the mouse to aim, such as first-person games.
Input lag can't be completely eliminated, but it can be reduced in several ways.

Distinguishing between jitter and stutter
-----------------------------------------

A game running at a normal framerate without exhibiting any effect will appear smooth:

.. image:: img/motion_normal.gif

A game exhibiting *jitter* will shake constantly in a very subtle way:

.. image:: img/motion_jitter.gif

Finally, a game exhibiting *stutter* will appear smooth, but appear to *stop* or
*roll back a frame* every few seconds:

.. image:: img/motion_stutter.gif


Jitter
------

There can be many causes of jitter, the most typical one happens when the game
*physics frequency* (usually 60 Hz) runs at a different resolution than the
monitor refresh rate. Check whether your monitor refresh rate is different from
60 Hz.

This is generally not a problem, given that most monitors are 60 Hz, and
starting with Godot 3.1, a frame timer was introduced that tries to synchronize
with refresh as well as possible.

Sometimes only some objects appear to jitter (character or background). This
happens when they are processed in different time sources (one is processed in
the physics step while another is processed in the idle step). Godot 3.1 does
some improvements to this, from allowing kinematic bodies to be animated in the
regular ``_process()`` loop, to further fixes in the frame timer.

.. note::

    In 3D, you can use :ref:`physics interpolation <doc_physics_interpolation>`
    to mitigate physics-related jittering.

    For 2D, see `lawnjelly's smoothing-addon <https://github.com/lawnjelly/smoothing-addon>`__
    for an add-on that can be dropped into any project to enable physics interpolation.

Stutter
-------

Stutter may happen due to two different reasons. The first, and most obvious
one, is the game not being able to keep full framerate performance. Solving this
is game specific and will require optimization.

The second is more complicated, because it is often not associated to the engine
or game but the underlying operating system. Here is some information regarding
stutter on different OSs.

On platforms that support disabling V-Sync, suttering can be made less
noticeable by disabling V-Sync in the project settings. This will however cause
tearing to appear, especially on monitors with low refresh rates. If your
monitor supports it, consider enabling variable refresh rate (G-Sync/FreeSync)
while leaving V-Sync enabled. This avoids mitigating some forms of stuttering
without introducing tearing.

Forcing your graphics card to use the maximum performance profile can also help
reduce stuttering, at the cost of increased GPU power draw.

Windows
^^^^^^^

Windows is known to cause stutter in windowed games. This mostly depends on the
hardware installed, drivers version and processes running in parallel (e.g.
having many browser tabs open may cause stutter in a running game). To avoid
this, starting with 3.1, Godot raises the game priority to "Above Normal". This
helps considerably but may not completely eliminate stutter.

Eliminating this completely requires giving your game full privileges to become
"time critical", which is not advised. Some games may do it, but it is advised
to learn to live with this problem, as it is common for Windows games and most
users won't play games windowed (games that are played in a window, e.g. puzzle
games, will usually not exhibit this problem anyway).

For fullscreen, Windows gives special priority to the game so stutter is no
longer visible and very rare. This is how most games are played.

Linux
^^^^^

Stutter may be visible on desktop Linux, but this is usually associated with
different video drivers and compositors. Some compositors may also trigger this
problem (e.g. KWin), so it is advised to try using a different one to rule it
out as the cause. Some window managers such as KWin and Xfwm allow you to
manually disable compositing, which can improve performance (at the cost of
tearing).

There is no workaround for driver or compositor stuttering, other than reporting
it as an issue to the driver or compositor developers.

`Feral GameMode <https://github.com/FeralInteractive/gamemode>`__ can be used
to automatically apply optimizations (such as forcing the GPU performance profile)
when running specific processes.

macOS
^^^^^

Generally, macOS is stutter-free, although recently some bugs were reported when
running on fullscreen (this is a macOS bug). If you have a machine exhibiting
this behavior, please let us know.

Android
^^^^^^^

Generally, Android is stutter and jitter-free because the running activity gets
all the priority. That said, there may be problematic devices (older Kindle Fire
is known to be one). If you see this problem on Android, please let us know.

iOS
^^^

iOS devices are generally stutter-free, but older devices running newer versions
of the operating system may exhibit problems. This is generally unavoidable.

Input lag
---------

Project configuration
^^^^^^^^^^^^^^^^^^^^^

On platforms that support disabling V-Sync, input lag can be made less
noticeable by disabling V-Sync in the project settings. This will however cause
tearing to appear, especially on monitors with low refresh rates.

Increasing the number of physics iterations per second can also reduce
physics-induced input latency. This is especially noticeable when using physics
interpolation (which improves smoothness but increases latency). To do so, set
**Physics > Common > Physics FPS** to a value higher than the
default ``60``, or set ``Engine.physics_fps`` at run-time in a
script. Values that are a multiple of the monitor refresh rate (typically
``60``) work best when physics interpolation is disabled, as they will avoid
jitter. This means values such as ``120``, ``180`` and ``240`` are good starting
points. As a bonus, higher physics FPSes make tunneling and physics unstability
issues less likely to occur.

The downside of increasing physics FPS is that CPU usage will increase, which
can lead to performance bottlenecks in games that have heavy physics simulation
code. This can be alleviated by increasing physics FPS only in situations where
low latency is critical, or by letting players adjust physics FPS to match their
hardware. However, different physics FPS will lead to different outcomes in
physics simulation, even when ``delta`` is consistently used in your game logic.
This can give certain players an advantage over others. Therefore, allowing the
player to change the physics FPS themselves should be avoided for competitive
multiplayer games.

Lastly, you can disable input buffering on a per-rendered frame basis by calling
``Input.set_use_accumulated_input(false)`` in a script. This will make it so the
``_input()`` and ``_unhandled_input()`` functions in your scripts are called on
every input, rather than accumulating inputs and waiting for a frame to be
rendered. Disabling input accumulation will increase CPU usage, so it should be
done with caution.

Hardware/OS-specific
^^^^^^^^^^^^^^^^^^^^

If your monitor supports it, consider enabling variable refresh rate
(G-Sync/FreeSync) while leaving V-Sync enabled, then cap the framerate in the
project settings to a slightly lower value than your monitor's maximum refresh
rate as per `this page <https://blurbusters.com/howto-low-lag-vsync-on/>`__.
For example, on a 144 Hz monitor, you can set the project's framerate cap to
``141``. This may be counterintuitive at first, but capping the FPS below the
maximum refresh rate range ensures that the OS never has to wait for vertical
blanking to finish. This leads to *similar* input lag as V-Sync disabled with
the same framerate cap (usually less than 1 ms greater), but without any
tearing.

This can be done by changing the **Debug > Settings > FPS > Force FPS** project
setting or assigning ``Engine.target_fps`` at run-time in a script.

On some platforms, you can also opt into a low-latency mode in the graphics
driver options (such as the NVIDIA Control Panel on Windows). The **Ultra**
setting will give you the lowest possible latency, at the cost of slightly lower
average framerates. Forcing the GPU to use the maximum performance profile
can also further reduce input lag, at the cost of higher power consumption
(and resulting heat/fan noise).

Finally, make sure your monitor is running at its highest possible refresh rate
in the OS' display settings.

Also, ensure that your mouse is configured to use its highest polling rate
(typically 1,000 Hz for gaming mice, sometimes more). High USB polling rates can
however result in high CPU usage, so 500 Hz may be a safer bet on low-end CPUs.
If your mouse offers multiple :abbr:`DPI (Dots Per Inch)` settings, consider also
`using the highest possible setting and reducing in-game sensitivity to reduce mouse latency <https://www.youtube.com/watch?v=6AoRfv9W110>`__.

On Linux, disabling compositing in window managers that allow it (such as KWin
or Xfwm) can reduce input lag significantly.

Reporting jitter, stutter or input lag problems
-----------------------------------------------

If you are reporting a stutter or jitter problem (opening an issue) not caused
by any of the above reasons, please specify very clearly all the information
possible about device, operating system, driver versions, etc. This may help to
better troubleshoot it.

If you are reporting input lag problems, please include a capture made with a
high speed camera (such as your phone's slow motion video mode). The capture
**must** have both the screen and the input device visible so that the number of
frames between an input and the on-screen result can can be counted. Also, make
sure to mention your monitor's refresh rate and your input device's polling rate
(especially for mice).

Also, make sure to use the correct term (jitter, stutter, input lag) based on the
exhibited behavior. This will help understand your issue much faster. Provide a
project that can be used to reproduce the issue, and if possible, include a
screen capture demonstrating the bug.


===================================================
/. ./tutorials/rendering/gles2_gles3_differences.rst
===================================================

.. _doc_gles2_gles3_differences:

Differences between GLES2 and GLES3
===================================

This page documents the differences between GLES2 and GLES3 that are by design and are not the result
of bugs. There may be differences that are unintentional, but they should be reported as bugs.

.. note:: "GLES2" and "GLES3" are the names used in Godot for the two OpenGL-based rendering backends.
          In terms of graphics APIs, the GLES2 backend maps to OpenGL 2.1 on desktop, OpenGL ES 2.0 on
          mobile and WebGL 1.0 on the web. The GLES3 backend maps to OpenGL 3.3 on desktop, OpenGL ES
          3.0 on mobile and WebGL 2.0 on the web.

Particles
---------

GLES2 cannot use the :ref:`Particles <class_Particles>` or :ref:`Particles2D <class_Particles2D>` nodes
as they require advanced GPU features. Instead, use :ref:`CPUParticles <class_CPUParticles>` or
:ref:`CPUParticles2D <class_CPUParticles2D>`, which provides a similar interface to a
:ref:`ParticlesMaterial <class_ParticlesMaterial>`.

.. tip:: Particles and Particles2D can be converted to their CPU equivalent node with the "Convert to
         CPUParticles" option in the editor.

``SCREEN_TEXTURE`` mip-maps
---------------------------

In GLES2, ``SCREEN_TEXTURE`` (accessed via a :ref:`ShaderMaterial <class_ShaderMaterial>`) does not have
computed mip-maps. So when accessing at a different LOD, the texture will not appear blurry.

``DEPTH_TEXTURE``
-----------------

While GLES2 supports ``DEPTH_TEXTURE`` in shaders, it may not work on some old hardware (especially mobile).

Color space
-----------

GLES2 and GLES3 are in different color spaces. This means that colors will appear slightly
different between them especially when lighting is used.

If your game is going to use both GLES2 and GLES3, you can use an ``if``
statement check and see if the output is in sRGB, using ``OUTPUT_IS_SRGB``. ``OUTPUT_IS_SRGB`` is
``true`` in GLES2 and ``false`` in GLES3.

HDR
---

GLES2 is not capable of using High Dynamic Range (HDR) rendering features. If HDR is set for your
project, or for a given viewport, Godot will still use Low Dynamic Range (LDR) which limits
viewport values to the ``0-1`` range.

The Viewport **Debanding** property and associated project setting will also have
no effect when HDR is disabled. This means debanding can't be used in GLES2.

SpatialMaterial features
------------------------

In GLES2, the following advanced rendering features in the :ref:`SpatialMaterial <class_SpatialMaterial>` are missing:

- Refraction
- Subsurface scattering
- Anisotropy
- Clearcoat
- Depth mapping

When using SpatialMaterials they will not even appear in the editor.

In custom :ref:`ShaderMaterials <class_ShaderMaterial>`, you can set values for these features but they
will be non-functional. For example, you will still be able to set the ``SSS`` built-in (which normally adds
subsurface scattering) in your shader, but nothing will happen.

Environment features
--------------------

In GLES2, the following features in the :ref:`Environment <class_Environment>` are missing:

- Auto exposure
- Tonemapping
- Screen space reflections
- Screen space ambient occlusion

That means that in GLES2 environments you can only set:

- Sky (including procedural sky)
- Ambient light
- Fog
- Depth of field
- Glow (also known as bloom)
- Adjustment

GIProbes
--------

:ref:`GIProbes <class_GIProbe>` do not work in GLES2. Instead use :ref:`Baked Lightmaps <class_BakedLightmap>`.
For a description of how baked lightmaps work see the :ref:`Baked Lightmaps tutorial <doc_baked_lightmaps>`.

Contact shadows
---------------

The ``shadow_contact`` property of :ref:`Lights <class_Light>` is not supported in GLES2 and so does nothing.

Light performance
-----------------

In GLES2, performance scales poorly with several lights, as each light is processed in a separate render
pass (in opposition to GLES3 which is all done in a single pass). Try to limit scenes to as few lights as
possible in order to achieve greatest performance.

Texture compression
-------------------

On mobile, GLES2 requires ETC texture compression, while GLES3 requires ETC2. ETC2 is enabled by default,
so if exporting to mobile using GLES2 make sure to set the project setting
``rendering/vram_compression/import_etc`` and then reimport textures.

.. warning::

    Since ETC doesn't support transparency, you must reimport textures that contain
    an alpha channel to use the Uncompressed, Lossy or Lossless compression mode
    (instead of Video RAM). This can be done in the Import dock after selecting
    them in the FileSystem dock.

Blend shapes
------------

In GLES2, blend shapes are implemented on the CPU instead of the GPU.
Accordingly, they may not perform as well as blend shapes in GLES3. To avoid
performance issues when using blend shapes in GLES2, try to minimize the number
of blend shapes that are updated each frame.

Shading language
----------------

GLES3 provides many built-in functions that GLES2 does not. Below is a list of functions
that are not available or are have limited support in GLES2.

For a complete list of built-in GLSL functions see the :ref:`Shading Language doc <doc_shading_language>`.

+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| Function                                                                                    |                                                  |
+=============================================================================================+==================================================+
| vec_type **modf** ( vec_type x, out vec_type i )                                            |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_int_type **floatBitsToInt** ( vec_type x )                                              |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_uint_type **floatBitsToUint** ( vec_type x )                                            |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_type **intBitsToFloat** ( vec_int_type x )                                              |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_type **uintBitsToFloat** ( vec_uint_type x )                                            |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| ivec2 **textureSize** ( sampler2D_type s, int lod )                                         | See workaround below                             |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| ivec2 **textureSize** ( samplerCube s, int lod )                                            | See workaround below                             |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec4_type **texture** ( sampler_type s, vec_type uv [, float bias] )                        | **bias** not available in vertex shader          |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec4_type **textureProj** ( sampler_type s, vec_type uv [, float bias] )                    |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec4_type **textureLod** ( sampler_type s, vec_type uv, float lod )                         | Only available in vertex shader on some hardware |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec4_type **textureProjLod** ( sampler_type s, vec_type uv, float lod )                     |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, vec_type dPdy )     |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_type **dFdx** ( vec_type p )                                                            |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_type **dFdy** ( vec_type p )                                                            |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+
| vec_type **fwidth** ( vec_type p )                                                          |                                                  |
+---------------------------------------------------------------------------------------------+--------------------------------------------------+

.. note:: Functions not in GLES2's GLSL were added with Godots own shader standard library. These functions may perform worse in GLES2 compared to GLES3.

``textureSize()`` workaround
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GLES2 does not support ``textureSize()``. You can get the size of a texture the old fashioned way by passing in a
uniform with the texture size yourself.

.. code-block:: glsl

    // In the shader:
    uniform sampler2D textureName;
    uniform vec2 textureName_size;

::

    # In GDScript:
    material_name.set_shader_param("textureName", my_texture)
    material_name.set_shader_param("textureName_size", my_texture_size)

Built in variables and render modes
-----------------------------------

Godot also provides many built-in variables and render modes. Some cannot be supported in GLES2. Below is a list of
built-in variables and render modes that, when written to, will have no effect or could even cause issues when using
the GLES2 backend.

+----------------------------+
| Variable / Render Mode     |
+============================+
| ``ensure_correct_normals`` |
+----------------------------+
| ``INSTANCE_ID``            |
+----------------------------+
| ``DEPTH``                  |
+----------------------------+
| ``ANISOTROPY``             |
+----------------------------+
| ``ANISOTROPY_FLOW``        |
+----------------------------+
| ``SSS_STRENGTH``           |
+----------------------------+


===================================================
/. ./tutorials/scripting/index.rst
===================================================

Scripting
=========

This section covers programming languages and core features to code your games
in Godot.

Here, you will find information that is not already covered in more specific
sections. For instance, to learn about inputs, we recommend you to read
:ref:`Inputs <toc-learn-features-inputs>`.

Programming languages
---------------------

The sections below each focus on a given programming language or, in GDNative's
case, an interface that works with multiple languages.

.. toctree::
   :maxdepth: 1
   :name: toc-learn-scripting

   gdscript/index
   visual_script/index
   c_sharp/index
   gdnative/index

Core features
-------------

Some features are specific to the engine and are available in all supported
languages. Whether you code in GDScript, C#, or another language, the pages
below will help you make the most of Godot.

.. To split and organize better, into some related toctrees?

.. toctree::
   :maxdepth: 1
   :name: toc-scripting-core-features

   debug/index
   idle_and_physics_processing
   groups
   nodes_and_scene_instances
   overridable_functions
   cross_language_scripting
   creating_script_templates
   evaluating_expressions
   change_scenes_manually
   instancing_with_signals
   pausing_games
   filesystem
   resources
   singletons_autoload
   scene_tree
   scene_unique_nodes


===================================================
/. ./tutorials/scripting/gdscript/index.rst
===================================================

GDScript
========

.. toctree::
   :maxdepth: 1
   :name: toc-learn-scripting-gdscript

   gdscript_basics
   gdscript_advanced
   gdscript_exports
   gdscript_styleguide
   static_typing
   warning_system
   gdscript_format_string

.. seealso::

    See :ref:`doc_gdscript_grammar` if you are interested in writing a third-party
    tool that interacts with GDScript, such as a linter or formatter.


===================================================
/. ./tutorials/scripting/gdscript/gdscript_basics.rst
===================================================

.. _doc_gdscript:

GDScript basics
===============

Introduction
------------

*GDScript* is a high-level, dynamically typed programming language used to
create content. It uses a syntax similar to
`Python <https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_
(blocks are indent-based and many keywords are similar). Its goal is
to be optimized for and tightly integrated with Godot Engine, allowing great
flexibility for content creation and integration.

History
~~~~~~~

.. note::

    Documentation about GDScript's history has been moved to the
    :ref:`Frequently Asked Questions <doc_faq_what_is_gdscript>`.

Example of GDScript
~~~~~~~~~~~~~~~~~~~

Some people can learn better by taking a look at the syntax, so
here's a simple example of how GDScript looks.

::

    # A file is a class!

    # Inheritance

    extends BaseClass

    # (optional) class definition with a custom icon

    class_name MyClass, "res://path/to/optional/icon.svg"


    # Member variables

    var a = 5
    var s = "Hello"
    var arr = [1, 2, 3]
    var dict = {"key": "value", 2: 3}
    var typed_var: int
    var inferred_type := "String"

    # Constants

    const ANSWER = 42
    const THE_NAME = "Charly"

    # Enums

    enum {UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY}
    enum Named {THING_1, THING_2, ANOTHER_THING = -1}

    # Built-in vector types

    var v2 = Vector2(1, 2)
    var v3 = Vector3(1, 2, 3)


    # Function

    func some_function(param1, param2):
        var local_var = 5

        if param1 < local_var:
            print(param1)
        elif param2 > 5:
            print(param2)
        else:
            print("Fail!")

        for i in range(20):
            print(i)

        while param2 != 0:
            param2 -= 1

        var local_var2 = param1 + 3
        return local_var2


    # Functions override functions with the same name on the base/parent class.
    # If you still want to call them, use '.' (like 'super' in other languages).

    func something(p1, p2):
        .something(p1, p2)


    # Inner class

    class Something:
        var a = 10


    # Constructor

    func _init():
        print("Constructed!")
        var lv = Something.new()
        print(lv.a)

If you have previous experience with statically typed languages such as
C, C++, or C# but never used a dynamically typed one before, it is advised you
read this tutorial: :ref:`doc_gdscript_more_efficiently`.

Language
--------

In the following, an overview is given to GDScript. Details, such as which
methods are available to arrays or other objects, should be looked up in
the linked class descriptions.

Identifiers
~~~~~~~~~~~

Any string that restricts itself to alphabetic characters (``a`` to
``z`` and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies
as an identifier. Additionally, identifiers must not begin with a digit.
Identifiers are case-sensitive (``foo`` is different from ``FOO``).

Keywords
~~~~~~~~

The following is the list of keywords supported by the language. Since
keywords are reserved words (tokens), they can't be used as identifiers.
Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in types
as listed in the following sections are also reserved.

Keywords are defined in the `GDScript tokenizer <https://github.com/godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_
in case you want to take a look under the hood.

+------------+---------------------------------------------------------------------------------------------------------------+
|  Keyword   | Description                                                                                                   |
+============+===============================================================================================================+
| if         | See `if/else/elif`_.                                                                                          |
+------------+---------------------------------------------------------------------------------------------------------------+
| elif       | See `if/else/elif`_.                                                                                          |
+------------+---------------------------------------------------------------------------------------------------------------+
| else       | See `if/else/elif`_.                                                                                          |
+------------+---------------------------------------------------------------------------------------------------------------+
| for        | See for_.                                                                                                     |
+------------+---------------------------------------------------------------------------------------------------------------+
| while      | See while_.                                                                                                   |
+------------+---------------------------------------------------------------------------------------------------------------+
| match      | See match_.                                                                                                   |
+------------+---------------------------------------------------------------------------------------------------------------+
| break      | Exits the execution of the current ``for`` or ``while`` loop.                                                 |
+------------+---------------------------------------------------------------------------------------------------------------+
| continue   | Immediately skips to the next iteration of the ``for`` or ``while`` loop.                                     |
+------------+---------------------------------------------------------------------------------------------------------------+
| pass       | Used where a statement is required syntactically but execution of code is undesired, e.g. in empty functions. |
+------------+---------------------------------------------------------------------------------------------------------------+
| return     | Returns a value from a function.                                                                              |
+------------+---------------------------------------------------------------------------------------------------------------+
| class      | Defines an inner class.                                                                                       |
+------------+---------------------------------------------------------------------------------------------------------------+
| class_name | Defines a class name and optional icon for your script.                                                       |
+------------+---------------------------------------------------------------------------------------------------------------+
| extends    | Defines what class to extend with the current class.                                                          |
+------------+---------------------------------------------------------------------------------------------------------------+
| is         | Tests whether a variable extends a given class, or is of a given built-in type.                               |
+------------+---------------------------------------------------------------------------------------------------------------+
| as         | Cast the value to a given type if possible.                                                                   |
+------------+---------------------------------------------------------------------------------------------------------------+
| self       | Refers to current class instance.                                                                             |
+------------+---------------------------------------------------------------------------------------------------------------+
| tool       | Executes the script in the editor.                                                                            |
+------------+---------------------------------------------------------------------------------------------------------------+
| signal     | Defines a signal.                                                                                             |
+------------+---------------------------------------------------------------------------------------------------------------+
| func       | Defines a function.                                                                                           |
+------------+---------------------------------------------------------------------------------------------------------------+
| static     | Defines a static function. Static member variables are not allowed.                                           |
+------------+---------------------------------------------------------------------------------------------------------------+
| const      | Defines a constant.                                                                                           |
+------------+---------------------------------------------------------------------------------------------------------------+
| enum       | Defines an enum.                                                                                              |
+------------+---------------------------------------------------------------------------------------------------------------+
| var        | Defines a variable.                                                                                           |
+------------+---------------------------------------------------------------------------------------------------------------+
| onready    | Initializes a variable once the Node the script is attached to and its children are part of the scene tree.   |
+------------+---------------------------------------------------------------------------------------------------------------+
| export     | Saves a variable along with the resource it's attached to and makes it visible and modifiable in the editor.  |
+------------+---------------------------------------------------------------------------------------------------------------+
| setget     | Defines setter and getter functions for a variable.                                                           |
+------------+---------------------------------------------------------------------------------------------------------------+
| breakpoint | Editor helper for debugger breakpoints.                                                                       |
+------------+---------------------------------------------------------------------------------------------------------------+
| preload    | Preloads a class or variable. See `Classes as resources`_.                                                    |
+------------+---------------------------------------------------------------------------------------------------------------+
| yield      | Coroutine support. See `Coroutines with yield`_.                                                              |
+------------+---------------------------------------------------------------------------------------------------------------+
| assert     | Asserts a condition, logs error on failure. Ignored in non-debug builds. See `Assert keyword`_.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| remote     | Networking RPC annotation. See :ref:`high-level multiplayer docs <doc_high_level_multiplayer>`.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| master     | Networking RPC annotation. See :ref:`high-level multiplayer docs <doc_high_level_multiplayer>`.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| puppet     | Networking RPC annotation. See :ref:`high-level multiplayer docs <doc_high_level_multiplayer>`.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| remotesync | Networking RPC annotation. See :ref:`high-level multiplayer docs <doc_high_level_multiplayer>`.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| mastersync | Networking RPC annotation. See :ref:`high-level multiplayer docs <doc_high_level_multiplayer>`.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| puppetsync | Networking RPC annotation. See :ref:`high-level multiplayer docs <doc_high_level_multiplayer>`.               |
+------------+---------------------------------------------------------------------------------------------------------------+
| PI         | PI constant.                                                                                                  |
+------------+---------------------------------------------------------------------------------------------------------------+
| TAU        | TAU constant.                                                                                                 |
+------------+---------------------------------------------------------------------------------------------------------------+
| INF        | Infinity constant. Used for comparisons.                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------+
| NAN        | NAN (not a number) constant. Used for comparisons.                                                            |
+------------+---------------------------------------------------------------------------------------------------------------+

Operators
~~~~~~~~~

The following is the list of supported operators and their precedence.

+------------------------------------------------------------------------+-----------------------------------------+
| **Operator**                                                           | **Description**                         |
+------------------------------------------------------------------------+-----------------------------------------+
| ``x[index]``                                                           | Subscription (highest priority)         |
+------------------------------------------------------------------------+-----------------------------------------+
| ``x.attribute``                                                        | Attribute reference                     |
+------------------------------------------------------------------------+-----------------------------------------+
| ``foo()``                                                              | Function call                           |
+------------------------------------------------------------------------+-----------------------------------------+
| ``is``                                                                 | Instance type checker                   |
+------------------------------------------------------------------------+-----------------------------------------+
| ``~``                                                                  | Bitwise NOT                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``-x``                                                                 | Negative / Unary negation               |
+------------------------------------------------------------------------+-----------------------------------------+
| ``*`` ``/`` ``%``                                                      | Multiplication / Division / Remainder   |
|                                                                        |                                         |
|                                                                        | These operators have the same behavior  |
|                                                                        | as C++. Integer division is truncated   |
|                                                                        | rather than returning a fractional      |
|                                                                        | number, and the % operator is only      |
|                                                                        | available for ints ("fmod" for floats), |
|                                                                        | and is additionally used for Format     |
|                                                                        | Strings                                 |
+------------------------------------------------------------------------+-----------------------------------------+
| ``+``                                                                  | Addition / Concatenation of arrays      |
+------------------------------------------------------------------------+-----------------------------------------+
| ``-``                                                                  | Subtraction                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``<<`` ``>>``                                                          | Bit shifting                            |
+------------------------------------------------------------------------+-----------------------------------------+
| ``&``                                                                  | Bitwise AND                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``^``                                                                  | Bitwise XOR                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``|``                                                                  | Bitwise OR                              |
+------------------------------------------------------------------------+-----------------------------------------+
| ``<`` ``>`` ``==`` ``!=`` ``>=`` ``<=``                                | Comparisons                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``in``                                                                 | When used with the ``if`` keyword it    |
|                                                                        | checks if a value is within a string,   |
|                                                                        | list, range, dictionary, or node. When  |
|                                                                        | used with the ``for`` keyword it is used|
|                                                                        | to iterate though the contents of a     |
|                                                                        | string, list, range, dictionary or node.|
+------------------------------------------------------------------------+-----------------------------------------+
| ``!`` ``not``                                                          | Boolean NOT                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``and`` ``&&``                                                         | Boolean AND                             |
+------------------------------------------------------------------------+-----------------------------------------+
| ``or`` ``||``                                                          | Boolean OR                              |
+------------------------------------------------------------------------+-----------------------------------------+
| ``if x else``                                                          | Ternary if/else                         |
+------------------------------------------------------------------------+-----------------------------------------+
| ``as``                                                                 | Type casting                            |
+------------------------------------------------------------------------+-----------------------------------------+
| ``=`` ``+=`` ``-=`` ``*=`` ``/=`` ``%=`` ``&=`` ``|=`` ``<<=`` ``>>=`` | Assignment (lowest priority)            |
+------------------------------------------------------------------------+-----------------------------------------+

Literals
~~~~~~~~

+--------------------------+----------------------------------------+
| **Literal**              | **Type**                               |
+--------------------------+----------------------------------------+
| ``45``                   | Base 10 integer                        |
+--------------------------+----------------------------------------+
| ``0x8f51``               | Base 16 (hexadecimal) integer          |
+--------------------------+----------------------------------------+
| ``0b101010``             | Base 2 (binary) integer                |
+--------------------------+----------------------------------------+
| ``3.14``, ``58.1e-10``   | Floating-point number (real)           |
+--------------------------+----------------------------------------+
| ``"Hello"``, ``"Hi"``    | Strings                                |
+--------------------------+----------------------------------------+
| ``"""Hello"""``          | Multiline string                       |
+--------------------------+----------------------------------------+
| ``@"Node/Label"``        | :ref:`class_NodePath` or StringName    |
+--------------------------+----------------------------------------+
| ``$NodePath``            | Shorthand for ``get_node("NodePath")`` |
+--------------------------+----------------------------------------+

Integers and floats can have their numbers separated with ``_`` to make them more readable.
The following ways to write numbers are all valid::

    12_345_678  # Equal to 12345678.
    3.141_592_7  # Equal to 3.1415927.
    0x8080_0000_ffff  # Equal to 0x80800000ffff.
    0b11_00_11_00  # Equal to 0b11001100.

Comments
~~~~~~~~

Anything from a ``#`` to the end of the line is ignored and is
considered a comment.

::

    # This is a comment.

.. _doc_gdscript_builtin_types:

Built-in types
--------------

Built-in types are stack-allocated. They are passed as values. This means a copy
is created on each assignment or when passing them as arguments to functions.
The only exceptions are ``Array``\ s and ``Dictionaries``, which are passed by
reference so they are shared. (Pooled arrays such as ``PoolByteArray`` are still
passed as values.)

Basic built-in types
~~~~~~~~~~~~~~~~~~~~

A variable in GDScript can be assigned to several built-in types.

null
^^^^

``null`` is an empty data type that contains no information and can not
be assigned any other value.

:ref:`bool <class_bool>`
^^^^^^^^^^^^^^^^^^^^^^^^

Short for "boolean", it can only contain ``true`` or ``false``.

:ref:`int <class_int>`
^^^^^^^^^^^^^^^^^^^^^^

Short for "integer", it stores whole numbers (positive and negative).
It is stored as a 64-bit value, equivalent to "int64_t" in C++.

:ref:`float <class_float>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

Stores real numbers, including decimals, using floating-point values.
It is stored as a 64-bit value, equivalent to "double" in C++.
Note: Currently, data structures such as Vector2, Vector3, and
PoolRealArray store 32-bit single-precision "float" values.

:ref:`String <class_String>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A sequence of characters in `Unicode format <https://en.wikipedia.org/wiki/Unicode>`_.
Strings can contain the following escape sequences:

+---------------------+---------------------------------+
| **Escape sequence** | **Expands to**                  |
+---------------------+---------------------------------+
| ``\n``              | Newline (line feed)             |
+---------------------+---------------------------------+
| ``\t``              | Horizontal tab character        |
+---------------------+---------------------------------+
| ``\r``              | Carriage return                 |
+---------------------+---------------------------------+
| ``\a``              | Alert (beep/bell)               |
+---------------------+---------------------------------+
| ``\b``              | Backspace                       |
+---------------------+---------------------------------+
| ``\f``              | Formfeed page break             |
+---------------------+---------------------------------+
| ``\v``              | Vertical tab character          |
+---------------------+---------------------------------+
| ``\"``              | Double quote                    |
+---------------------+---------------------------------+
| ``\'``              | Single quote                    |
+---------------------+---------------------------------+
| ``\\``              | Backslash                       |
+---------------------+---------------------------------+
| ``\uXXXX``          | Unicode codepoint ``XXXX``      |
|                     | (hexadecimal, case-insensitive) |
+---------------------+---------------------------------+

GDScript also supports :ref:`doc_gdscript_printf`.

Vector built-in types
~~~~~~~~~~~~~~~~~~~~~

:ref:`Vector2 <class_Vector2>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2D vector type containing ``x`` and ``y`` fields. Can also be
accessed as an array.

:ref:`Rect2 <class_Rect2>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

2D Rectangle type containing two vectors fields: ``position`` and ``size``.
Also contains an ``end`` field which is ``position + size``.

:ref:`Vector3 <class_Vector3>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

3D vector type containing ``x``, ``y`` and ``z`` fields. This can also
be accessed as an array.

:ref:`Transform2D <class_Transform2D>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

3×2 matrix used for 2D transforms.

:ref:`Plane <class_Plane>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

3D Plane type in normalized form that contains a ``normal`` vector field
and a ``d`` scalar distance.

:ref:`Quat <class_Quat>`
^^^^^^^^^^^^^^^^^^^^^^^^

Quaternion is a datatype used for representing a 3D rotation. It's
useful for interpolating rotations.

:ref:`AABB <class_AABB>`
^^^^^^^^^^^^^^^^^^^^^^^^

Axis-aligned bounding box (or 3D box) contains 2 vectors fields: ``position``
and ``size``. Also contains an ``end`` field which is
``position + size``.

:ref:`Basis <class_Basis>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

3x3 matrix used for 3D rotation and scale. It contains 3 vector fields
(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D
vectors.

:ref:`Transform <class_Transform>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

3D Transform contains a Basis field ``basis`` and a Vector3 field
``origin``.

Engine built-in types
~~~~~~~~~~~~~~~~~~~~~

:ref:`Color <class_Color>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can
also be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value.

:ref:`NodePath <class_NodePath>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Compiled path to a node used mainly in the scene system. It can be
easily assigned to, and from, a String.

:ref:`RID <class_RID>`
^^^^^^^^^^^^^^^^^^^^^^

Resource ID (RID). Servers use generic RIDs to reference opaque data.

:ref:`Object <class_Object>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Base class for anything that is not a built-in type.

Container built-in types
~~~~~~~~~~~~~~~~~~~~~~~~

:ref:`Array <class_Array>`
^^^^^^^^^^^^^^^^^^^^^^^^^^

Generic sequence of arbitrary object types, including other arrays or dictionaries (see below).
The array can resize dynamically. Arrays are indexed starting from index ``0``.
Negative indices count from the end.

::

    var arr = []
    arr = [1, 2, 3]
    var b = arr[1] # This is 2.
    var c = arr[arr.size() - 1] # This is 3.
    var d = arr[-1] # Same as the previous line, but shorter.
    arr[0] = "Hi!" # Replacing value 1 with "Hi!".
    arr.append(4) # Array is now ["Hi!", 2, 3, 4].

GDScript arrays are allocated linearly in memory for speed.
Large arrays (more than tens of thousands of elements) may however cause
memory fragmentation. If this is a concern, special types of
arrays are available. These only accept a single data type. They avoid memory
fragmentation and use less memory, but are atomic and tend to run slower than generic
arrays. They are therefore only recommended to use for large data sets:

- :ref:`PoolByteArray <class_PoolByteArray>`: An array of bytes (integers from 0 to 255).
- :ref:`PoolIntArray <class_PoolIntArray>`: An array of integers.
- :ref:`PoolRealArray <class_PoolRealArray>`: An array of floats.
- :ref:`PoolStringArray <class_PoolStringArray>`: An array of strings.
- :ref:`PoolVector2Array <class_PoolVector2Array>`: An array of :ref:`Vector2 <class_Vector2>` objects.
- :ref:`PoolVector3Array <class_PoolVector3Array>`: An array of :ref:`Vector3 <class_Vector3>` objects.
- :ref:`PoolColorArray <class_PoolColorArray>`: An array of :ref:`Color <class_Color>` objects.

:ref:`Dictionary <class_Dictionary>`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Associative container which contains values referenced by unique keys.

::

    var d = {4: 5, "A key": "A value", 28: [1, 2, 3]}
    d["Hi!"] = 0
    d = {
        22: "value",
        "some_key": 2,
        "other_key": [2, 3, 4],
        "more_key": "Hello"
    }

Lua-style table syntax is also supported. Lua-style uses ``=`` instead of ``:``
and doesn't use quotes to mark string keys (making for slightly less to write).
However, keys written in this form can't start with a digit (like any GDScript
identifier).

::

    var d = {
        test22 = "value",
        some_key = 2,
        other_key = [2, 3, 4],
        more_key = "Hello"
    }

To add a key to an existing dictionary, access it like an existing key and
assign to it::

    var d = {} # Create an empty Dictionary.
    d.waiting = 14 # Add String "waiting" as a key and assign the value 14 to it.
    d[4] = "hello" # Add integer 4 as a key and assign the String "hello" as its value.
    d["Godot"] = 3.01 # Add String "Godot" as a key and assign the value 3.01 to it.

    var test = 4
    # Prints "hello" by indexing the dictionary with a dynamic key.
    # This is not the same as `d.test`. The bracket syntax equivalent to
    # `d.test` is `d["test"]`.
    print(d[test])

.. note::

    The bracket syntax can be used to access properties of any
    :ref:`class_Object`, not just Dictionaries. Keep in mind it will cause a
    script error when attempting to index a non-existing property. To avoid
    this, use the :ref:`Object.get() <class_Object_method_get>` and
    :ref:`Object.set() <class_Object_method_set>` methods instead.

Data
----

Variables
~~~~~~~~~

Variables can exist as class members or local to functions. They are
created with the ``var`` keyword and may, optionally, be assigned a
value upon initialization.

::

    var a # Data type is 'null' by default.
    var b = 5
    var c = 3.8
    var d = b + c # Variables are always initialized in order.

Variables can optionally have a type specification. When a type is specified,
the variable will be forced to have always that same type, and trying to assign
an incompatible value will raise an error.

Types are specified in the variable declaration using a ``:`` (colon) symbol
after the variable name, followed by the type.

::

    var my_vector2: Vector2
    var my_node: Node = Sprite.new()

If the variable is initialized within the declaration, the type can be inferred, so
it's possible to omit the type name::

    var my_vector2 := Vector2() # 'my_vector2' is of type 'Vector2'.
    var my_node := Sprite.new() # 'my_node' is of type 'Sprite'.

Type inference is only possible if the assigned value has a defined type, otherwise
it will raise an error.

Valid types are:

- Built-in types (Array, Vector2, int, String, etc.).
- Engine classes (Node, Resource, Reference, etc.).
- Constant names if they contain a script resource (``MyScript`` if you declared ``const MyScript = preload("res://my_script.gd")``).
- Other classes in the same script, respecting scope (``InnerClass.NestedClass`` if you declared ``class NestedClass`` inside the ``class InnerClass`` in the same scope).
- Script classes declared with the ``class_name`` keyword.

Casting
^^^^^^^

Values assigned to typed variables must have a compatible type. If it's needed to
coerce a value to be of a certain type, in particular for object types, you can
use the casting operator ``as``.

Casting between object types results in the same object if the value is of the
same type or a subtype of the cast type.

::

    var my_node2D: Node2D
    my_node2D = $Sprite as Node2D # Works since Sprite is a subtype of Node2D.

If the value is not a subtype, the casting operation will result in a ``null`` value.

::

    var my_node2D: Node2D
    my_node2D = $Button as Node2D # Results in 'null' since a Button is not a subtype of Node2D.

For built-in types, they will be forcibly converted if possible, otherwise the
engine will raise an error.

::

    var my_int: int
    my_int = "123" as int # The string can be converted to int.
    my_int = Vector2() as int # A Vector2 can't be converted to int, this will cause an error.

Casting is also useful to have better type-safe variables when interacting with
the scene tree::

    # Will infer the variable to be of type Sprite.
    var my_sprite := $Character as Sprite

    # Will fail if $AnimPlayer is not an AnimationPlayer, even if it has the method 'play()'.
    ($AnimPlayer as AnimationPlayer).play("walk")

Constants
~~~~~~~~~

Constants are values you cannot change when the game is running.
Their value must be known at compile-time. Using the
``const`` keyword allows you to give a constant value a name. Trying to assign a
value to a constant after it's declared will give you an error.

We recommend using constants whenever a value is not meant to change.

::

    const A = 5
    const B = Vector2(20, 20)
    const C = 10 + 20 # Constant expression.
    const D = Vector2(20, 30).x # Constant expression: 20.
    const E = [1, 2, 3, 4][0] # Constant expression: 1.
    const F = sin(20) # 'sin()' can be used in constant expressions.
    const G = x + 20 # Invalid; this is not a constant expression!
    const H = A + 20 # Constant expression: 25 (`A` is a constant).

Although the type of constants is inferred from the assigned value, it's also
possible to add explicit type specification::

    const A: int = 5
    const B: Vector2 = Vector2()

Assigning a value of an incompatible type will raise an error.

.. note::

    Since arrays and dictionaries are passed by reference, constants are "flat".
    This means that if you declare a constant array or dictionary, it can still
    be modified afterwards. They can't be reassigned with another value though.

Enums
^^^^^

Enums are basically a shorthand for constants, and are pretty useful if you
want to assign consecutive integers to some constant.

If you pass a name to the enum, it will put all the keys inside a constant
dictionary of that name.

.. important:: In Godot 3.1 and later, keys in a named enum are not registered
               as global constants. They should be accessed prefixed by the
               enum's name (``Name.KEY``); see an example below.

::

    enum {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT}
    # Is the same as:
    const TILE_BRICK = 0
    const TILE_FLOOR = 1
    const TILE_SPIKE = 2
    const TILE_TELEPORT = 3

    enum State {STATE_IDLE, STATE_JUMP = 5, STATE_SHOOT}
    # Is the same as:
    const State = {STATE_IDLE = 0, STATE_JUMP = 5, STATE_SHOOT = 6}
    # Access values with State.STATE_IDLE, etc.


Functions
~~~~~~~~~

Functions always belong to a `class <Classes_>`_. The scope priority for
variable look-up is: local → class member → global. The ``self`` variable is
always available and is provided as an option for accessing class members, but
is not always required (and should *not* be sent as the function's first
argument, unlike Python).

::

    func my_function(a, b):
        print(a)
        print(b)
        return a + b  # Return is optional; without it 'null' is returned.

A function can ``return`` at any point. The default return value is ``null``.

Functions can also have type specification for the arguments and for the return
value. Types for arguments can be added in a similar way to variables::

    func my_function(a: int, b: String):
        pass

If a function argument has a default value, it's possible to infer the type::

    func my_function(int_arg := 42, String_arg := "string"):
        pass

The return type of the function can be specified after the arguments list using
the arrow token (``->``)::

    func my_int_function() -> int:
        return 0

Functions that have a return type **must** return a proper value. Setting the
type as ``void`` means the function doesn't return anything. Void functions can
return early with the ``return`` keyword, but they can't return any value.

::

    func void_function() -> void:
        return # Can't return a value

.. note:: Non-void functions must **always** return a value, so if your code has
          branching statements (such as an ``if``/``else`` construct), all the
          possible paths must have a return. E.g., if you have a ``return``
          inside an ``if`` block but not after it, the editor will raise an
          error because if the block is not executed, the function won't have a
          valid value to return.

Referencing functions
^^^^^^^^^^^^^^^^^^^^^

Contrary to Python, functions are *not* first-class objects in GDScript. This
means they cannot be stored in variables, passed as an argument to another
function or be returned from other functions. This is for performance reasons.

To reference a function by name at run-time, (e.g. to store it in a variable, or
pass it to another function as an argument) one must use the ``call`` or
``funcref`` helpers::

    # Call a function by name in one step.
    my_node.call("my_function", args)

    # Store a function reference.
    var my_func = funcref(my_node, "my_function")
    # Call stored function reference.
    my_func.call_func(args)


Static functions
^^^^^^^^^^^^^^^^

A function can be declared static. When a function is static, it has no
access to the instance member variables or ``self``. This is mainly
useful to make libraries of helper functions::

    static func sum2(a, b):
        return a + b


Statements and control flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Statements are standard and can be assignments, function calls, control
flow structures, etc (see below). ``;`` as a statement separator is
entirely optional.

if/else/elif
^^^^^^^^^^^^

Simple conditions are created by using the ``if``/``else``/``elif`` syntax.
Parenthesis around conditions are allowed, but not required. Given the
nature of the tab-based indentation, ``elif`` can be used instead of
``else``/``if`` to maintain a level of indentation.

::

    if [expression]:
        statement(s)
    elif [expression]:
        statement(s)
    else:
        statement(s)

Short statements can be written on the same line as the condition::

    if 1 + 1 == 2: return 2 + 2
    else:
        var x = 3 + 3
        return x

Sometimes, you might want to assign a different initial value based on a
boolean expression. In this case, ternary-if expressions come in handy::

    var x = [value] if [expression] else [value]
    y += 3 if y < 10 else -1

Ternary-if expressions can be nested to handle more than 2 cases. When nesting
ternary-if expressions, it is recommended to wrap the complete expression over
multiple lines to preserve readability::

    var count = 0

    var fruit = (
            "apple" if count == 2
            else "pear" if count == 1
            else "banana" if count == 0
            else "orange"
    )
    print(fruit)  # banana

    # Alternative syntax with backslashes instead of parentheses (for multi-line expressions).
    # Less lines required, but harder to refactor.
    var fruit_alt = \
            "apple" if count == 2 \
            else "pear" if count == 1 \
            else "banana" if count == 0 \
            else "orange"
    print(fruit_alt)  # banana

You may also wish to check if a value is contained within something. You can
use an ``if`` statement combined with the ``in`` operator to accomplish this::

    # Check if a letter is in a string.
    var text = "abc"
    if 'b' in text: print("The string contains b")

    # Check if a variable is contained within a node.
    if "varName" in get_parent(): print("varName is defined in parent!")

while
^^^^^

Simple loops are created by using ``while`` syntax. Loops can be broken
using ``break`` or continued using ``continue`` (i.e. skipping to the next iteration of the loop without executing any further code in the current iteration):

::

    while [expression]:
        statement(s)

for
^^^

To iterate through a range, such as an array or table, a *for* loop is
used. When iterating over an array, the current array element is stored in
the loop variable. When iterating over a dictionary, the *key* is stored
in the loop variable.

::

    for x in [5, 7, 11]:
        statement # Loop iterates 3 times with 'x' as 5, then 7 and finally 11.

    var dict = {"a": 0, "b": 1, "c": 2}
    for i in dict:
        print(dict[i]) # Prints 0, then 1, then 2.

    for i in range(3):
        statement # Similar to [0, 1, 2] but does not allocate an array.

    for i in range(1, 3):
        statement # Similar to [1, 2] but does not allocate an array.

    for i in range(2, 8, 2):
        statement # Similar to [2, 4, 6] but does not allocate an array.

    for c in "Hello":
        print(c) # Iterate through all characters in a String, print every letter on new line.

    for i in 3:
        statement # Similar to range(3)

    for i in 2.2:
        statement # Similar to range(ceil(2.2))

match
^^^^^

A ``match`` statement is used to branch execution of a program.
It's the equivalent of the ``switch`` statement found in many other languages, but offers some additional features.

Basic syntax::

    match [expression]:
        [pattern](s):
            [block]
        [pattern](s):
            [block]
        [pattern](s):
            [block]


**Crash-course for people who are familiar with switch statements**:

1. Replace ``switch`` with ``match``.
2. Remove ``case``.
3. Remove any ``break``\ s. If you don't want to ``break`` by default, you can use ``continue`` for a fallthrough.
4. Change ``default`` to a single underscore.


**Control flow**:

The patterns are matched from top to bottom.
If a pattern matches, the first corresponding block will be executed. After that, the execution continues below the ``match`` statement.
You can use ``continue`` to stop execution in the current block and check for an additional match in the patterns below it.

There are 6 pattern types:

- Constant pattern
    Constant primitives, like numbers and strings::

        match x:
            1:
                print("We are number one!")
            2:
                print("Two are better than one!")
            "test":
                print("Oh snap! It's a string!")


- Variable pattern
    Matches the contents of a variable/enum::

        match typeof(x):
            TYPE_REAL:
                print("float")
            TYPE_STRING:
                print("text")
            TYPE_ARRAY:
                print("array")


- Wildcard pattern
    This pattern matches everything. It's written as a single underscore.

    It can be used as the equivalent of the ``default`` in a ``switch`` statement in other languages::

        match x:
            1:
                print("It's one!")
            2:
                print("It's one times two!")
            _:
                print("It's not 1 or 2. I don't care to be honest.")


- Binding pattern
    A binding pattern introduces a new variable. Like the wildcard pattern, it matches everything - and also gives that value a name.
    It's especially useful in array and dictionary patterns::

        match x:
            1:
                print("It's one!")
            2:
                print("It's one times two!")
            var new_var:
                print("It's not 1 or 2, it's ", new_var)


- Array pattern
    Matches an array. Every single element of the array pattern is a pattern itself, so you can nest them.

    The length of the array is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match.

    **Open-ended array**: An array can be bigger than the pattern by making the last subpattern ``..``.

    Every subpattern has to be comma-separated.

    ::

        match x:
            []:
                print("Empty array")
            [1, 3, "test", null]:
                print("Very specific array")
            [var start, _, "test"]:
                print("First element is ", start, ", and the last is \"test\"")
            [42, ..]:
                print("Open ended array")

- Dictionary pattern
    Works in the same way as the array pattern. Every key has to be a constant pattern.

    The size of the dictionary is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match.

    **Open-ended dictionary**: A dictionary can be bigger than the pattern by making the last subpattern ``..``.

    Every subpattern has to be comma separated.

    If you don't specify a value, then only the existence of the key is checked.

    A value pattern is separated from the key pattern with a ``:``.

    ::

        match x:
            {}:
                print("Empty dict")
            {"name": "Dennis"}:
                print("The name is Dennis")
            {"name": "Dennis", "age": var age}:
                print("Dennis is ", age, " years old.")
            {"name", "age"}:
                print("Has a name and an age, but it's not Dennis :(")
            {"key": "godotisawesome", ..}:
                print("I only checked for one entry and ignored the rest")

- Multiple patterns
    You can also specify multiple patterns separated by a comma. These patterns aren't allowed to have any bindings in them.

    ::

        match x:
            1, 2, 3:
                print("It's 1 - 3")
            "Sword", "Splash potion", "Fist":
                print("Yep, you've taken damage")

Classes
~~~~~~~

By default, all script files are unnamed classes. In this case, you can only
reference them using the file's path, using either a relative or an absolute
path. For example, if you name a script file ``character.gd``::

   # Inherit from 'Character.gd'.

   extends "res://path/to/character.gd"

   # Load character.gd and create a new node instance from it.

   var Character = load("res://path/to/character.gd")
   var character_node = Character.new()

.. _doc_gdscript_basics_class_name:

Registering named classes
~~~~~~~~~~~~~~~~~~~~~~~~~

You can give your class a name to register it as a new type in Godot's
editor. For that, you use the ``class_name`` keyword. You can optionally add
a comma followed by a path to an image, to use it as an icon. Your
class will then appear with its new icon in the editor::

   # Item.gd

   extends Node
   class_name Item, "res://interface/icons/item.png"

.. image:: img/class_name_editor_register_example.png

.. warning::

    If the script is located in the ``res://addons/`` directory, ``class_name``
    will only cause the node to show up in the **Create New Node** dialog if
    the script is part of an *enabled* editor plugin. See :ref:`doc_making_plugins`
    for more information.

Here's a class file example:

::

    # Saved as a file named 'character.gd'.

    class_name Character


    var health = 5


    func print_health():
        print(health)


    func print_this_script_three_times():
        print(get_script())
        print(ResourceLoader.load("res://character.gd"))
        print(Character)


.. note:: Godot's class syntax is compact: it can only contain member variables or
          functions. You can use static functions, but not static member variables. In the
          same way, the engine initializes variables every time you create an instance,
          and this includes arrays and dictionaries. This is in the spirit of thread
          safety, since scripts can be initialized in separate threads without the user
          knowing.

Inheritance
^^^^^^^^^^^

A class (stored as a file) can inherit from:

- A global class.
- Another class file.
- An inner class inside another class file.

Multiple inheritance is not allowed.

Inheritance uses the ``extends`` keyword::

    # Inherit/extend a globally available class.
    extends SomeClass

    # Inherit/extend a named class file.
    extends "somefile.gd"

    # Inherit/extend an inner class in another file.
    extends "somefile.gd".SomeInnerClass


To check if a given instance inherits from a given class,
the ``is`` keyword can be used::

    # Cache the enemy class.
    const Enemy = preload("enemy.gd")

    # [...]

    # Use 'is' to check inheritance.
    if entity is Enemy:
        entity.apply_damage()

To call a function in a *parent class* (i.e. one ``extend``-ed in your current
class), prepend ``.`` to the function name::

    .base_func(args)

This is especially useful because functions in extending classes replace
functions with the same name in their parent classes. If you still want to
call them, you can prefix them with ``.`` (like the ``super`` keyword
in other languages)::

    func some_func(x):
        .some_func(x) # Calls the same function on the parent class.

.. note:: Default functions like  ``_init``, and most notifications such as
          ``_enter_tree``, ``_exit_tree``, ``_process``, ``_physics_process``,
          etc. are called in all parent classes automatically.
          There is no need to call them explicitly when overloading them.


Class constructor
^^^^^^^^^^^^^^^^^

The class constructor, called on class instantiation, is named ``_init``. As
mentioned earlier, the constructors of parent classes are called automatically
when inheriting a class. So, there is usually no need to call ``._init()``
explicitly.

Unlike the call of a regular function, like in the above example with
``.some_func``, if the constructor from the inherited class takes arguments,
they are passed like this::

    func _init(args).(parent_args):
       pass

This is better explained through examples. Consider this scenario::

    # State.gd (inherited class)
    var entity = null
    var message = null


    func _init(e=null):
        entity = e


    func enter(m):
        message = m


    # Idle.gd (inheriting class)
    extends "State.gd"


    func _init(e=null, m=null).(e):
        # Do something with 'e'.
        message = m

There are a few things to keep in mind here:

1. If the inherited class (``State.gd``) defines a ``_init`` constructor that takes
   arguments (``e`` in this case), then the inheriting class (``Idle.gd``) *must*
   define ``_init`` as well and pass appropriate parameters to ``_init`` from ``State.gd``.
2. ``Idle.gd`` can have a different number of arguments than the parent class ``State.gd``.
3. In the example above, ``e`` passed to the ``State.gd`` constructor is the same ``e`` passed
   in to ``Idle.gd``.
4. If ``Idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to pass some value
   to the ``State.gd`` parent class, even if it does nothing. This brings us to the fact that you
   can pass literals in the base constructor as well, not just variables, e.g.::

    # Idle.gd

    func _init().(5):
        pass

Inner classes
^^^^^^^^^^^^^

A class file can contain inner classes. Inner classes are defined using the
``class`` keyword. They are instanced using the ``ClassName.new()``
function.

::

    # Inside a class file.

    # An inner class in this class file.
    class SomeInnerClass:
        var a = 5


        func print_value_of_a():
            print(a)


    # This is the constructor of the class file's main class.
    func _init():
        var c = SomeInnerClass.new()
        c.print_value_of_a()

.. _doc_gdscript_classes_as_resources:

Classes as resources
^^^^^^^^^^^^^^^^^^^^

Classes stored as files are treated as :ref:`resources <class_GDScript>`. They
must be loaded from disk to access them in other classes. This is done using
either the ``load`` or ``preload`` functions (see below). Instancing of a loaded
class resource is done by calling the ``new`` function on the class object::

    # Load the class resource when calling load().
    var MyClass = load("myclass.gd")

    # Preload the class only once at compile time.
    const MyClass = preload("myclass.gd")


    func _init():
        var a = MyClass.new()
        a.some_function()

Exports
~~~~~~~

.. note::

    Documentation about exports has been moved to :ref:`doc_gdscript_exports`.

Setters/getters
~~~~~~~~~~~~~~~

It is often useful to know when a class' member variable changes for
whatever reason. It may also be desired to encapsulate its access in some way.

For this, GDScript provides a *setter/getter* syntax using the ``setget`` keyword.
It is used directly after a variable definition:

::

    var variable = value setget setterfunc, getterfunc

Whenever the value of ``variable`` is modified by an *external* source
(i.e. not from local usage in the class), the *setter* function (``setterfunc`` above)
will be called. This happens *before* the value is changed. The *setter* must decide what to do
with the new value. Vice versa, when ``variable`` is accessed, the *getter* function
(``getterfunc`` above) must ``return`` the desired value. Below is an example::

    var my_var setget my_var_set, my_var_get


    func my_var_set(new_value):
        my_var = new_value


    func my_var_get():
        return my_var # Getter must return a value.

Either of the *setter* or *getter* functions can be omitted::

    # Only a setter.
    var my_var = 5 setget my_var_set
    # Only a getter (note the comma).
    var my_var = 5 setget ,my_var_get

Setters and getters are useful when :ref:`exporting variables <doc_gdscript_exports>`
to the editor in tool scripts or plugins, for validating input.

As said, *local* access will *not* trigger the setter and getter. Here is an
illustration of this:

::

    func _init():
        # Does not trigger setter/getter.
        my_integer = 5
        print(my_integer)

        # Does trigger setter/getter.
        self.my_integer = 5
        print(self.my_integer)

.. _doc_gdscript_tool_mode:

Tool mode
~~~~~~~~~

By default, scripts don't run inside the editor and only the exported
properties can be changed. In some cases, it is desired that they do run
inside the editor (as long as they don't execute game code or manually
avoid doing so). For this, the ``tool`` keyword exists and must be
placed at the top of the file::

    tool
    extends Button


    func _ready():
        print("Hello")


See :ref:`doc_running_code_in_the_editor` for more information.

.. warning:: Be cautious when freeing nodes with ``queue_free()`` or ``free()``
             in a tool script (especially the script's owner itself). As tool
             scripts run their code in the editor, misusing them may lead to
             crashing the editor.

.. _doc_gdscript_basics_memory_management:

Memory management
~~~~~~~~~~~~~~~~~

If a class inherits from :ref:`class_Reference`, then instances will be
freed when no longer in use. No garbage collector exists, just
reference counting. By default, all classes that don't define
inheritance extend **Reference**. If this is not desired, then a class
must inherit :ref:`class_Object` manually and must call ``instance.free()``. To
avoid reference cycles that can't be freed, a :ref:`class_WeakRef` function is
provided for creating weak references. Here is an example:

::

    extends Node

    var my_node_ref

    func _ready():
        my_node_ref = weakref(get_node("MyNode"))

    func _this_is_called_later():
        var my_node = my_node_ref.get_ref()
        if my_node:
            my_node.do_something()

Alternatively, when not using references, the
``is_instance_valid(instance)`` can be used to check if an object has been
freed.

.. _doc_gdscript_signals:

Signals
~~~~~~~

Signals are a tool to emit messages from an object that other objects can react
to. To create custom signals for a class, use the ``signal`` keyword.

::

   extends Node


   # A signal named health_depleted.
   signal health_depleted

.. note::

   Signals are a `Callback
   <https://en.wikipedia.org/wiki/Callback_(computer_programming)>`_
   mechanism. They also fill the role of Observers, a common programming
   pattern. For more information, read the `Observer tutorial
   <https://gameprogrammingpatterns.com/observer.html>`_ in the
   Game Programming Patterns ebook.

You can connect these signals to methods the same way you connect built-in
signals of nodes like :ref:`class_Button` or :ref:`class_RigidBody`.

In the example below, we connect the ``health_depleted`` signal from a
``Character`` node to a ``Game`` node. When the ``Character`` node emits the
signal, the game node's ``_on_Character_health_depleted`` is called::

    # Game.gd

    func _ready():
        var character_node = get_node('Character')
        character_node.connect("health_depleted", self, "_on_Character_health_depleted")


    func _on_Character_health_depleted():
        get_tree().reload_current_scene()

You can emit as many arguments as you want along with a signal.

Here is an example where this is useful. Let's say we want a life bar on screen
to react to health changes with an animation, but we want to keep the user
interface separate from the player in our scene tree.

In our ``Character.gd`` script, we define a ``health_changed`` signal and emit
it with :ref:`Object.emit_signal() <class_Object_method_emit_signal>`, and from
a ``Game`` node higher up our scene tree, we connect it to the ``Lifebar`` using
the :ref:`Object.connect() <class_Object_method_connect>` method::

    # Character.gd

    ...
    signal health_changed


    func take_damage(amount):
        var old_health = health
        health -= amount

        # We emit the health_changed signal every time the
        # character takes damage.
        emit_signal("health_changed", old_health, health)
    ...

::

    # Lifebar.gd

    # Here, we define a function to use as a callback when the
    # character's health_changed signal is emitted.

    ...
    func _on_Character_health_changed(old_value, new_value):
        if old_value > new_value:
            progress_bar.modulate = Color.red
        else:
            progress_bar.modulate = Color.green

        # Imagine that `animate` is a user-defined function that animates the
        # bar filling up or emptying itself.
        progress_bar.animate(old_value, new_value)
    ...

.. note::

    To use signals, your class has to extend the ``Object`` class or any
    type extending it like ``Node``, ``KinematicBody``, ``Control``...

In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, then
connect the character, that emits the signal, to the receiver, the ``Lifebar``
node in this case.

::

    # Game.gd

    func _ready():
        var character_node = get_node('Character')
        var lifebar_node = get_node('UserInterface/Lifebar')

        character_node.connect("health_changed", lifebar_node, "_on_Character_health_changed")

This allows the ``Lifebar`` to react to health changes without coupling it to
the ``Character`` node.

You can write optional argument names in parentheses after the signal's
definition::

    # Defining a signal that forwards two arguments.
    signal health_changed(old_value, new_value)

These arguments show up in the editor's node dock, and Godot can use them to
generate callback functions for you. However, you can still emit any number of
arguments when you emit signals; it's up to you to emit the correct values.

.. image:: img/gdscript_basics_signals_node_tab_1.png

GDScript can bind an array of values to connections between a signal
and a method. When the signal is emitted, the callback method receives
the bound values. These bound arguments are unique to each connection,
and the values will stay the same.

You can use this array of values to add extra constant information to the
connection if the emitted signal itself doesn't give you access to all the data
that you need.

Building on the example above, let's say we want to display a log of the damage
taken by each character on the screen, like ``Player1 took 22 damage.``. The
``health_changed`` signal doesn't give us the name of the character that took
damage. So when we connect the signal to the in-game console, we can add the
character's name in the binds array argument::

    # Game.gd

    func _ready():
        var character_node = get_node('Character')
        var battle_log_node = get_node('UserInterface/BattleLog')

        character_node.connect("health_changed", battle_log_node, "_on_Character_health_changed", [character_node.name])

Our ``BattleLog`` node receives each element in the binds array as an extra argument::

    # BattleLog.gd

    func _on_Character_health_changed(old_value, new_value, character_name):
        if not new_value <= old_value:
            return

        var damage = old_value - new_value
        label.text += character_name + " took " + str(damage) + " damage."


Coroutines with yield
~~~~~~~~~~~~~~~~~~~~~

GDScript offers support for `coroutines <https://en.wikipedia.org/wiki/Coroutine>`_
via the :ref:`yield<class_@GDScript_method_yield>` built-in function. Calling ``yield()`` will
immediately return from the current function, with the current frozen
state of the same function as the return value. Calling ``resume()`` on
this resulting object will continue execution and return whatever the
function returns. Once resumed, the state object becomes invalid. Here is
an example::

    func my_func():
        print("Hello")
        yield()
        print("world")


    func _ready():
        var y = my_func()
        # Function state saved in 'y'.
        print("my dear")
        y.resume()
        # 'y' resumed and is now an invalid state.

Will print::

    Hello
    my dear
    world

It is also possible to pass values between ``yield()`` and ``resume()``,
for example::

    func my_func():
        print("Hello")
        print(yield())
        return "cheers!"


    func _ready():
        var y = my_func()
        # Function state saved in 'y'.
        print(y.resume("world"))
        # 'y' resumed and is now an invalid state.

Will print::

    Hello
    world
    cheers!

Remember to save the new function state, when using multiple ``yield``\s::

    func co_func():
        for i in range(1, 5):
            print("Turn %d" % i)
            yield();


    func _ready():
        var co = co_func();
        while co is GDScriptFunctionState && co.is_valid():
            co = co.resume();


Coroutines & signals
^^^^^^^^^^^^^^^^^^^^

The real strength of using ``yield`` is when combined with signals.
``yield`` can accept two arguments, an object and a signal. When the
signal is received, execution will recommence. Here are some examples::

    # Resume execution the next frame.
    yield(get_tree(), "idle_frame")

    # Resume execution when animation is done playing.
    yield(get_node("AnimationPlayer"), "animation_finished")

    # Wait 5 seconds, then resume execution.
    yield(get_tree().create_timer(5.0), "timeout")

Coroutines themselves use the ``completed`` signal when they transition
into an invalid state, for example::

    func my_func():
        yield(button_func(), "completed")
        print("All buttons were pressed, hurray!")


    func button_func():
        yield($Button0, "pressed")
        yield($Button1, "pressed")

``my_func`` will only continue execution once both buttons have been pressed.

You can also get the signal's argument once it's emitted by an object:

::

    # Wait for when any node is added to the scene tree.
    var node = yield(get_tree(), "node_added")

If there is more than one argument, ``yield`` returns an array containing
the arguments::

    signal done(input, processed)

    func process_input(input):
        print("Processing initialized")
        yield(get_tree(), "idle_frame")
        print("Waiting")
        yield(get_tree(), "idle_frame")
        emit_signal("done", input, "Processed " + input)


    func _ready():
        process_input("Test") # Prints: Processing initialized
        var data = yield(self, "done") # Prints: waiting
        print(data[1]) # Prints: Processed Test

If you're unsure whether a function may yield or not, or whether it may yield
multiple times, you can yield to the ``completed`` signal conditionally:

::

    func generate():
        var result = rand_range(-1.0, 1.0)

        if result < 0.0:
            yield(get_tree(), "idle_frame")

        return result


    func make():
        var result = generate()

        if result is GDScriptFunctionState: # Still working.
            result = yield(result, "completed")

        return result

This ensures that the function returns whatever it was supposed to return
regardless of whether coroutines were used internally. Note that using
``while`` would be redundant here as the ``completed`` signal is only emitted
when the function didn't yield anymore.

.. _doc_gdscript_onready_keyword:

`onready` keyword
~~~~~~~~~~~~~~~~~

When using nodes, it's common to desire to keep references to parts
of the scene in a variable. As scenes are only warranted to be
configured when entering the active scene tree, the sub-nodes can only
be obtained when a call to ``Node._ready()`` is made.

::

    var my_label


    func _ready():
        my_label = get_node("MyLabel")

This can get a little cumbersome, especially when nodes and external
references pile up. For this, GDScript has the ``onready`` keyword, that
defers initialization of a member variable until ``_ready()`` is called. It
can replace the above code with a single line::

    onready var my_label = get_node("MyLabel")

Assert keyword
~~~~~~~~~~~~~~

The ``assert`` keyword can be used to check conditions in debug builds. These
assertions are ignored in non-debug builds. This means that the expression
passed as argument won't be evaluated in a project exported in release mode.
Due to this, assertions must **not** contain expressions that have
side effects. Otherwise, the behavior of the script would vary
depending on whether the project is run in a debug build.

::

    # Check that 'i' is 0. If 'i' is not 0, an assertion error will occur.
    assert(i == 0)

When running a project from the editor, the project will be paused if an
assertion error occurs.


===================================================
/. ./tutorials/scripting/gdscript/gdscript_advanced.rst
===================================================

.. _doc_gdscript_more_efficiently:

GDScript: An introduction to dynamic languages
==============================================

About
-----

This tutorial aims to be a quick reference for how to use GDScript more
efficiently. It focuses on common cases specific to the language, but
also covers a lot of information on dynamically typed languages.

It's meant to be especially useful for programmers with little or no previous
experience with dynamically typed languages.

Dynamic nature
--------------

Pros & cons of dynamic typing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GDScript is a Dynamically Typed language. As such, its main advantages
are that:

-  The language is simple and easy to learn.
-  Most code can be written and changed quickly and without hassle.
-  Less code written means less errors & mistakes to fix.
-  Easier to read the code (less clutter).
-  No compilation is required to test.
-  Runtime is tiny.
-  Duck-typing and polymorphism by nature.

While the main disadvantages are:

-  Less performance than statically typed languages.
-  More difficult to refactor (symbols can't be traced)
-  Some errors that would typically be detected at compile time in
   statically typed languages only appear while running the code
   (because expression parsing is more strict).
-  Less flexibility for code-completion (some variable types are only
   known at run-time).

This, translated to reality, means that Godot+GDScript are a combination
designed to create games quickly and efficiently. For games that are very
computationally intensive and can't benefit from the engine built-in
tools (such as the Vector types, Physics Engine, Math library, etc), the
possibility of using C++ is present too. This allows you to still create most of the
game in GDScript and add small bits of C++ in the areas that need
a performance boost.

Variables & assignment
~~~~~~~~~~~~~~~~~~~~~~

All variables in a dynamically typed language are "variant"-like. This
means that their type is not fixed, and is only modified through
assignment. Example:

Static:

.. code-block:: cpp

    int a; // Value uninitialized.
    a = 5; // This is valid.
    a = "Hi!"; // This is invalid.

Dynamic:

::

    var a # 'null' by default.
    a = 5 # Valid, 'a' becomes an integer.
    a = "Hi!" # Valid, 'a' changed to a string.

As function arguments:
~~~~~~~~~~~~~~~~~~~~~~

Functions are of dynamic nature too, which means they can be called with
different arguments, for example:

Static:

.. code-block:: cpp

    void print_value(int value) {

        printf("value is %i\n", value);
    }

    [..]

    print_value(55); // Valid.
    print_value("Hello"); // Invalid.

Dynamic:

::

    func print_value(value):
        print(value)

    [..]

    print_value(55) # Valid.
    print_value("Hello") # Valid.

Pointers & referencing:
~~~~~~~~~~~~~~~~~~~~~~~

In static languages, such as C or C++ (and to some extent Java and C#),
there is a distinction between a variable and a pointer/reference to a
variable. The latter allows the object to be modified by other functions
by passing a reference to the original one.

In C# or Java, everything not a built-in type (int, float, sometimes
String) is always a pointer or a reference. References are also
garbage-collected automatically, which means they are erased when no
longer used. Dynamically typed languages tend to use this memory model,
too. Some Examples:

-  C++:

.. code-block:: cpp

    void use_class(SomeClass *instance) {

        instance->use();
    }

    void do_something() {

        SomeClass *instance = new SomeClass; // Created as pointer.
        use_class(instance); // Passed as pointer.
        delete instance; // Otherwise it will leak memory.
    }

-  Java:

.. code-block:: java

    @Override
    public final void use_class(SomeClass instance) {

        instance.use();
    }

    public final void do_something() {

        SomeClass instance = new SomeClass(); // Created as reference.
        use_class(instance); // Passed as reference.
        // Garbage collector will get rid of it when not in
        // use and freeze your game randomly for a second.
    }

-  GDScript:

::

    func use_class(instance): # Does not care about class type
        instance.use() # Will work with any class that has a ".use()" method.

    func do_something():
        var instance = SomeClass.new() # Created as reference.
        use_class(instance) # Passed as reference.
        # Will be unreferenced and deleted.

In GDScript, only base types (int, float, String and PoolArray types)
are passed by value to functions (value is copied). Everything else
(instances, Arrays, Dictionaries, etc) is passed as reference. Classes
that inherit :ref:`class_Reference` (the default if nothing is specified)
will be freed when not used, but manual memory management is allowed too
if inheriting manually from :ref:`class_Object`.

.. note::

    A value is **passed by value** when it is copied every time it's specified
    as a function parameter. One consequence of this is that the function cannot
    modify the parameter in a way that is visible from outside the function::

        func greet(text):
            text = "Hello " + text

        func _ready():
            # Create a String (passed by value and immutable).
            var example = "Godot"

            # Pass example as a parameter to `greet()`,
            # which modifies the parameter and does not return any value.
            greet(example)

            print(example)  #  Godot

    A value is **passed by reference** when it is *not* copied every time it's
    specified as a function parameter. This allows modifying a function
    parameter within a function body (and having the modified value accessible
    outside the function). The downside is that the data passed as a function
    parameter is no longer guaranteed to be immutable, which can cause
    difficult-to-track bugs if not done carefully::

        func greet(text):
            text.push_front("Hello")

        func _ready():
            # Create an Array (passed by reference and mutable) containing a String,
            # instead of a String (passed by value and immutable).
            var example = ["Godot"]

            # Pass example as a parameter to `greet()`,
            # which modifies the parameter and does not return any value.
            greet(example)

            print(example)  #  [Hello, Godot] (Array with 2 String elements)

    Compared to passing by value, passing by reference can perform better when
    using large objects since copying large objects in memory can be slow.

    Additionally, in Godot, base types such as String are **immutable**. This
    means that modifying them will *always* return a copy of the original value,
    rather than modifying the value in-place.

Arrays
------

Arrays in dynamically typed languages can contain many different mixed
datatypes inside and are always dynamic (can be resized at any time).
Compare for example arrays in statically typed languages:

.. code-block:: cpp

    int *array = new int[4]; // Create array.
    array[0] = 10; // Initialize manually.
    array[1] = 20; // Can't mix types.
    array[2] = 40;
    array[3] = 60;
    // Can't resize.
    use_array(array); // Passed as pointer.
    delete[] array; // Must be freed.

    // or

    std::vector<int> array;
    array.resize(4);
    array[0] = 10; // Initialize manually.
    array[1] = 20; // Can't mix types.
    array[2] = 40;
    array[3] = 60;
    array.resize(3); // Can be resized.
    use_array(array); // Passed reference or value.
    // Freed when stack ends.

And in GDScript:

::

    var array = [10, "hello", 40, 60] # Simple, and can mix types.
    array.resize(3) # Can be resized.
    use_array(array) # Passed as reference.
    # Freed when no longer in use.

In dynamically typed languages, arrays can also double as other
datatypes, such as lists:

::

    var array = []
    array.append(4)
    array.append(5)
    array.pop_front()

Or unordered sets:

::

    var a = 20
    if a in [10, 20, 30]:
        print("We have a winner!")

Dictionaries
------------

Dictionaries are a powerful tool in dynamically typed languages.
Most programmers that come from statically typed languages (such as C++
or C#) ignore their existence and make their life unnecessarily more
difficult. This datatype is generally not present in such languages (or
only in limited form).

Dictionaries can map any value to any other value with complete
disregard for the datatype used as either key or value. Contrary to
popular belief, they are efficient because they can be implemented
with hash tables. They are, in fact, so efficient that some languages
will go as far as implementing arrays as dictionaries.

Example of Dictionary:

::

    var d = {"name": "John", "age": 22} # Simple syntax.
    print("Name: ", d["name"], " Age: ", d["age"])

Dictionaries are also dynamic, keys can be added or removed at any point
at little cost:

::

    d["mother"] = "Rebecca" # Addition.
    d["age"] = 11 # Modification.
    d.erase("name") # Removal.

In most cases, two-dimensional arrays can often be implemented more
easily with dictionaries. Here's a simple battleship game example:

::

    # Battleship Game

    const SHIP = 0
    const SHIP_HIT = 1
    const WATER_HIT = 2

    var board = {}

    func initialize():
        board[Vector2(1, 1)] = SHIP
        board[Vector2(1, 2)] = SHIP
        board[Vector2(1, 3)] = SHIP

    func missile(pos):
        if pos in board: # Something at that position.
            if board[pos] == SHIP: # There was a ship! hit it.
                board[pos] = SHIP_HIT
            else:
                print("Already hit here!") # Hey dude you already hit here.
        else: # Nothing, mark as water.
            board[pos] = WATER_HIT

    func game():
        initialize()
        missile(Vector2(1, 1))
        missile(Vector2(5, 8))
        missile(Vector2(2, 3))

Dictionaries can also be used as data markup or quick structures. While
GDScript's dictionaries resemble python dictionaries, it also supports Lua
style syntax and indexing, which makes it useful for writing initial
states and quick structs:

::

    # Same example, lua-style support.
    # This syntax is a lot more readable and usable.
    # Like any GDScript identifier, keys written in this form cannot start
    # with a digit.

    var d = {
        name = "John",
        age = 22
    }

    print("Name: ", d.name, " Age: ", d.age) # Used "." based indexing.

    # Indexing

    d["mother"] = "Rebecca"
    d.mother = "Caroline" # This would work too to create a new key.

For & while
-----------

Iterating in some statically typed languages can be quite complex:

.. code-block:: cpp

    const char* strings = new const char*[50];

    [..]

    for (int i = 0; i < 50; i++) {

        printf("Value: %s\n", i, strings[i]);
    }

    // Even in STL:

    for (std::list<std::string>::const_iterator it = strings.begin(); it != strings.end(); it++) {

        std::cout << *it << std::endl;
    }

This is usually greatly simplified in dynamically typed languages:

::

    for s in strings:
        print(s)

Container datatypes (arrays and dictionaries) are iterable. Dictionaries
allow iterating the keys:

::

    for key in dict:
        print(key, " -> ", dict[key])

Iterating with indices is also possible:

::

    for i in range(strings.size()):
        print(strings[i])

The range() function can take 3 arguments:

::

    range(n) # Will go from 0 to n-1.
    range(b, n) # Will go from b to n-1.
    range(b, n, s) # Will go from b to n-1, in steps of s.

Some statically typed programming language examples:

.. code-block:: cpp

    for (int i = 0; i < 10; i++) {}

    for (int i = 5; i < 10; i++) {}

    for (int i = 5; i < 10; i += 2) {}

Translate to:

::

    for i in range(10):
        pass

    for i in range(5, 10):
        pass

    for i in range(5, 10, 2):
        pass

And backwards looping is done through a negative counter:

::

    for (int i = 10; i > 0; i--) {}

Becomes:

::

    for i in range(10, 0, -1):
        pass

While
-----

while() loops are the same everywhere:

::

    var i = 0

    while i < strings.size():
        print(strings[i])
        i += 1

Custom iterators
----------------
You can create custom iterators in case the default ones don't quite meet your
needs by overriding the Variant class's ``_iter_init``, ``_iter_next``, and ``_iter_get``
functions in your script. An example implementation of a forward iterator follows:

.. code-block:: py

    class ForwardIterator:
        var start
        var current
        var end
        var increment

        func _init(start, stop, increment):
            self.start = start
            self.current = start
            self.end = stop
            self.increment = increment

        func should_continue():
            return (current < end)

        func _iter_init(arg):
            current = start
            return should_continue()

        func _iter_next(arg):
            current += increment
            return should_continue()

        func _iter_get(arg):
            return current

And it can be used like any other iterator:

::

    var itr = ForwardIterator.new(0, 6, 2)
    for i in itr:
        print(i) # Will print 0, 2, and 4.

Make sure to reset the state of the iterator in ``_iter_init``, otherwise nested
for-loops that use custom iterators will not work as expected.

Duck typing
-----------

One of the most difficult concepts to grasp when moving from a
statically typed language to a dynamic one is duck typing. Duck typing
makes overall code design much simpler and straightforward to write, but
it's not obvious how it works.

As an example, imagine a situation where a big rock is falling down a
tunnel, smashing everything on its way. The code for the rock, in a
statically typed language would be something like:

.. code-block:: cpp

    void BigRollingRock::on_object_hit(Smashable *entity) {

        entity->smash();
    }

This way, everything that can be smashed by a rock would have to
inherit Smashable. If a character, enemy, piece of furniture, small rock
were all smashable, they would need to inherit from the class Smashable,
possibly requiring multiple inheritance. If multiple inheritance was
undesired, then they would have to inherit a common class like Entity.
Yet, it would not be very elegant to add a virtual method ``smash()`` to
Entity only if a few of them can be smashed.

With dynamically typed languages, this is not a problem. Duck typing
makes sure you only have to define a ``smash()`` function where required
and that's it. No need to consider inheritance, base classes, etc.

::

    func _on_object_hit(object):
        object.smash()

And that's it. If the object that hit the big rock has a smash() method,
it will be called. No need for inheritance or polymorphism. Dynamically
typed languages only care about the instance having the desired method
or member, not what it inherits or the class type. The definition of
Duck Typing should make this clearer:

*"When I see a bird that walks like a duck and swims like a duck and
quacks like a duck, I call that bird a duck"*

In this case, it translates to:

*"If the object can be smashed, don't care what it is, just smash it."*

Yes, we should call it Hulk typing instead.

It's possible that the object being hit doesn't have a smash() function.
Some dynamically typed languages simply ignore a method call when it
doesn't exist, but GDScript is stricter, so checking if the function
exists is desirable:

::

    func _on_object_hit(object):
        if object.has_method("smash"):
            object.smash()

Then, simply define that method and anything the rock touches can be
smashed.


===================================================
/. ./tutorials/scripting/gdscript/gdscript_exports.rst
===================================================

.. _doc_gdscript_exports:

GDScript exports
================

Introduction to exports
-----------------------

In Godot, class members can be exported. This means their value gets saved along
with the resource (such as the :ref:`scene <class_PackedScene>`) they're
attached to. They will also be available for editing in the property editor.
Exporting is done by using the ``export`` keyword::

    extends Button

    export var number = 5 # Value will be saved and visible in the property editor.

An exported variable must be initialized to a constant expression or have an
export hint in the form of an argument to the ``export`` keyword (see the
*Examples* section below).

One of the fundamental benefits of exporting member variables is to have
them visible and editable in the editor. This way, artists and game designers
can modify values that later influence how the program runs. For this, a
special export syntax is provided.

.. note::

    Exporting properties can also be done in other languages such as C#.
    The syntax varies depending on the language.

..
   See  ref `doc_c_sharp_exports` for information on C# exports.

Examples
--------

::

    # If the exported value assigns a constant or constant expression,
    # the type will be inferred and used in the editor.

    export var number = 5

    # Export can take a basic data type as an argument, which will be
    # used in the editor.

    export(int) var number

    # Export can also take a resource type to use as a hint.

    export(Texture) var character_face
    export(PackedScene) var scene_file
    # There are many resource types that can be used this way, try e.g.
    # the following to list them:
    export(Resource) var resource

    # Integers and strings hint enumerated values.

    # Editor will enumerate as 0, 1 and 2.
    export(int, "Warrior", "Magician", "Thief") var character_class
    # Editor will enumerate with string names.
    export(String, "Rebecca", "Mary", "Leah") var character_name

    # Named enum values

    # Editor will enumerate as THING_1, THING_2, ANOTHER_THING.
    enum NamedEnum {THING_1, THING_2, ANOTHER_THING = -1}
    export(NamedEnum) var x

    # Strings as paths

    # String is a path to a file.
    export(String, FILE) var f
    # String is a path to a directory.
    export(String, DIR) var f
    # String is a path to a file, custom filter provided as hint.
    export(String, FILE, "*.txt") var f

    # Using paths in the global filesystem is also possible,
    # but only in scripts in "tool" mode.

    # String is a path to a PNG file in the global filesystem.
    export(String, FILE, GLOBAL, "*.png") var tool_image
    # String is a path to a directory in the global filesystem.
    export(String, DIR, GLOBAL) var tool_dir

    # The MULTILINE setting tells the editor to show a large input
    # field for editing over multiple lines.
    export(String, MULTILINE) var text

    # Limiting editor input ranges

    # Allow integer values from 0 to 20.
    export(int, 20) var i
    # Allow integer values from -10 to 20.
    export(int, -10, 20) var j
    # Allow floats from -10 to 20 and snap the value to multiples of 0.2.
    export(float, -10, 20, 0.2) var k
    # Allow values 'y = exp(x)' where 'y' varies between 100 and 1000
    # while snapping to steps of 20. The editor will present a
    # slider for easily editing the value.
    export(float, EXP, 100, 1000, 20) var l

    # Floats with easing hint

    # Display a visual representation of the 'ease()' function
    # when editing.
    export(float, EASE) var transition_speed

    # Colors

    # Color given as red-green-blue value (alpha will always be 1).
    export(Color, RGB) var col
    # Color given as red-green-blue-alpha value.
    export(Color, RGBA) var col

    # Nodes

    # Another node in the scene can be exported as a NodePath.
    export(NodePath) var node_path
    # Do take note that the node itself isn't being exported -
    # there is one more step to call the true node:
    onready var node = get_node(node_path)

    # Resources

    export(Resource) var resource
    # In the Inspector, you can then drag and drop a resource file
    # from the FileSystem dock into the variable slot.

    # Opening the inspector dropdown may result in an
    # extremely long list of possible classes to create, however.
    # Therefore, if you specify an extension of Resource such as:
    export(AnimationNode) var resource
    # The drop-down menu will be limited to AnimationNode and all
    # its inherited classes.

It must be noted that even if the script is not being run while in the
editor, the exported properties are still editable. This can be used
in conjunction with a :ref:`script in "tool" mode <doc_gdscript_tool_mode>`.

Exporting bit flags
-------------------

Integers used as bit flags can store multiple ``true``/``false`` (boolean)
values in one property. By using the export hint ``int, FLAGS, ...``, they
can be set from the editor::

    # Set any of the given flags from the editor.
    export(int, FLAGS, "Fire", "Water", "Earth", "Wind") var spell_elements = 0

You must provide a string description for each flag. In this example, ``Fire``
has value 1, ``Water`` has value 2, ``Earth`` has value 4 and ``Wind``
corresponds to value 8. Usually, constants should be defined accordingly (e.g.
``const ELEMENT_WIND = 8`` and so on).

Export hints are also provided for the physics and render layers defined in the project settings::

    export(int, LAYERS_2D_PHYSICS) var layers_2d_physics
    export(int, LAYERS_2D_RENDER) var layers_2d_render
    export(int, LAYERS_3D_PHYSICS) var layers_3d_physics
    export(int, LAYERS_3D_RENDER) var layers_3d_render

Using bit flags requires some understanding of bitwise operations.
If in doubt, use boolean variables instead.

Exporting arrays
----------------

Exported arrays can have initializers, but they must be constant expressions.

If the exported array specifies a type which inherits from Resource, the array
values can be set in the inspector by dragging and dropping multiple files
from the FileSystem dock at once.

::

    # Default value must be a constant expression.

    export var a = [1, 2, 3]

    # Exported arrays can specify type (using the same hints as before).

    export(Array, int) var ints = [1, 2, 3]
    export(Array, int, "Red", "Green", "Blue") var enums = [2, 1, 0]
    export(Array, Array, float) var two_dimensional = [[1.0, 2.0], [3.0, 4.0]]

    # You can omit the default value, but then it would be null if not assigned.

    export(Array) var b
    export(Array, PackedScene) var scenes

    # Arrays with specified types which inherit from resource can be set by
    # drag-and-dropping multiple files from the FileSystem dock.

    export(Array, Texture) var textures
    export(Array, PackedScene) var scenes

    # Typed arrays also work, only initialized empty:

    export var vector3s = PoolVector3Array()
    export var strings = PoolStringArray()

    # Default value can include run-time values, but can't
    # be exported.

    var c = [a, 2, 3]

Setting exported variables from a tool script
---------------------------------------------

When changing an exported variable's value from a script in
:ref:`doc_gdscript_tool_mode`, the value in the inspector won't be updated
automatically. To update it, call
:ref:`property_list_changed_notify() <class_Object_method_property_list_changed_notify>`
after setting the exported variable's value.

Advanced exports
----------------

Not every type of export can be provided on the level of the language itself to
avoid unnecessary design complexity. The following describes some more or less
common exporting features which can be implemented with a low-level API.

Before reading further, you should get familiar with the way properties are
handled and how they can be customized with
:ref:`_set() <class_Object_method__get_property_list>`,
:ref:`_get() <class_Object_method__get_property_list>`, and
:ref:`_get_property_list() <class_Object_method__get_property_list>` methods as
described in :ref:`doc_accessing_data_or_logic_from_object`.

.. seealso:: For binding properties using the above methods in C++, see
             :ref:`doc_binding_properties_using_set_get_property_list`.

.. warning:: The script must operate in the ``tool`` mode so the above methods
             can work from within the editor.

Properties
~~~~~~~~~~

To understand how to better use the sections below, you should understand
how to make properties with advanced exports.

::

    func _get_property_list():
        var properties = [] 
        # Same as "export(int) var my_property"
        properties.append({
            name = "my_property",
            type = TYPE_INT
        })
        return properties

* The ``_get_property_list()`` function gets called by the inspector. You
  can override it for more advanced exports. You must return an ``Array``
  with the contents of the properties for the function to work.

* ``name`` is the name of the property

* ``type`` is the type of the property from ``Variant.Type``.

.. note:: The ``float`` type is called a real (``TYPE_REAL``) in the ``Variant.Type`` enum.

Attaching variables to properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To attach variables to properties (allowing the value of the property to be used
in scripts), you need to create a variable with the exact same name as the
property or else you may need to override the 
:ref:`_set() <class_Object_method__get_property_list>` and 
:ref:`_get() <class_Object_method__get_property_list>` methods. Attaching
a variable to to a property also gives you the ability to give it a default state.
::


    # This variable is determined by the function below.
    # This variable acts just like a regular gdscript export.
    var my_property = 5

    func _get_property_list():
        var properties = [] 
        # Same as "export(int) var my_property"
        properties.append({
            name = "my_property",
            type = TYPE_INT
        })
        return properties

Adding default values for properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To define default values for advanced exports, you need to override the ``property_can_revert()`` and ``property_get_revert()`` methods.

* The ``property_can_revert()`` method takes the name of a property and must return ``true`` if the property can be reverted. This will enable the Revert button next to the property in the inspector.

* The ``property_get_revert()`` method takes the name of a property and must return the default value for that property.

::

    func _get_property_list():
        var properties = []
        properties.append({
            name = "my_property",
            type = TYPE_INT
        })
        return properties

    func property_can_revert(property):
        if property == "my_property":
            return true
        return false

    func property_get_revert(property):
        if property == "my_property":
            return 5

Adding script categories
~~~~~~~~~~~~~~~~~~~~~~~~

For better visual distinguishing of properties, a special script category can be
embedded into the inspector to act as a separator. ``Script Variables`` is one
example of a built-in category.
::
    
    func _get_property_list():
        var properties = []
        properties.append({
            name = "Debug",
            type = TYPE_NIL,
            usage = PROPERTY_USAGE_CATEGORY | PROPERTY_USAGE_SCRIPT_VARIABLE
        })
        
        # Example of adding a property to the script category
        properties.append({
            name = "Logging_Enabled",
            type = TYPE_BOOL
        })
        return properties

* ``name`` is the name of a category to be added to the inspector;

* Every following property added after the category definition will be a part
  of the category. 

* ``PROPERTY_USAGE_CATEGORY`` indicates that the property should be treated as a
  script category specifically, so the type ``TYPE_NIL`` can be ignored as it
  won't be actually used for the scripting logic, yet it must be defined anyway.

Grouping properties
~~~~~~~~~~~~~~~~~~~

A list of properties with similar names can be grouped.
::
    
    func _get_property_list():
        var properties = []
        properties.append({
            name = "Rotate",
            type = TYPE_NIL,
            hint_string = "rotate_",
            usage = PROPERTY_USAGE_GROUP | PROPERTY_USAGE_SCRIPT_VARIABLE
        })

        # Example of adding to the group
        properties.append({
            name = "rotate_speed",
            type = TYPE_REAL
        })

        # This property won't get added to the group 
        # due to not having the "rotate_" prefix.
        properties.append({
            name = "trail_color",
            type = TYPE_COLOR
        })
        return properties

* ``name`` is the name of a group which is going to be displayed as collapsible
  list of properties;

* Every following property added after the group property with the prefix
  (which determined by ``hint_string``) will be shortened. For instance, 
  ``rotate_speed`` is going to be shortened to ``speed`` in this case.
  However, ``movement_speed`` won't be a part of the group and will not
  be shortened.

* ``PROPERTY_USAGE_GROUP`` indicates that the property should be treated as a
  script group specifically, so the type ``TYPE_NIL`` can be ignored as it
  won't be actually used for the scripting logic, yet it must be defined anyway.


===================================================
/. ./tutorials/scripting/gdscript/gdscript_styleguide.rst
===================================================

.. _doc_gdscript_styleguide:

GDScript style guide
====================

This style guide lists conventions to write elegant GDScript. The goal is to
encourage writing clean, readable code and promote consistency across projects,
discussions, and tutorials. Hopefully, this will also support the development of
auto-formatting tools.

Since GDScript is close to Python, this guide is inspired by Python's
`PEP 8 <https://www.python.org/dev/peps/pep-0008/>`__ programming
style guide.

Style guides aren't meant as hard rulebooks. At times, you may not be able to
apply some of the guidelines below. When that happens, use your best judgment,
and ask fellow developers for insights.

In general, keeping your code consistent in your projects and within your team is
more important than following this guide to a tee.

.. note:: Godot's built-in script editor uses a lot of these conventions
          by default. Let it help you.

Here is a complete class example based on these guidelines:

::

    class_name StateMachine
    extends Node
    # Hierarchical State machine for the player.
    # Initializes states and delegates engine callbacks
    # (_physics_process, _unhandled_input) to the state.


    signal state_changed(previous, new)

    export var initial_state = NodePath()
    var is_active = true setget set_is_active

    onready var _state = get_node(initial_state) setget set_state
    onready var _state_name = _state.name


    func _init():
        add_to_group("state_machine")


    func _ready():
        connect("state_changed", self, "_on_state_changed")
        _state.enter()


    func _unhandled_input(event):
        _state.unhandled_input(event)


    func _physics_process(delta):
        _state.physics_process(delta)


    func transition_to(target_state_path, msg={}):
        if not has_node(target_state_path):
            return

        var target_state = get_node(target_state_path)
        assert(target_state.is_composite == false)

        _state.exit()
        self._state = target_state
        _state.enter(msg)
        Events.emit_signal("player_state_changed", _state.name)


    func set_is_active(value):
        is_active = value
        set_physics_process(value)
        set_process_unhandled_input(value)
        set_block_signals(not value)


    func set_state(value):
        _state = value
        _state_name = _state.name


    func _on_state_changed(previous, new):
        print("state changed")
        emit_signal("state_changed")

.. _formatting:

Formatting
----------

Encoding and special characters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Use line feed (**LF**) characters to break lines, not CRLF or CR. *(editor default)*
* Use one line feed character at the end of each file. *(editor default)*
* Use **UTF-8** encoding without a `byte order mark <https://en.wikipedia.org/wiki/Byte_order_mark>`_. *(editor default)*
* Use **Tabs** instead of spaces for indentation. *(editor default)*

Indentation
~~~~~~~~~~~

Each indent level should be one greater than the block containing it.

**Good**:

::

    for i in range(10):
        print("hello")

**Bad**:

::

    for i in range(10):
      print("hello")

    for i in range(10):
            print("hello")

Use 2 indent levels to distinguish continuation lines from
regular code blocks.

**Good**:

::

    effect.interpolate_property(sprite, "transform/scale",
                sprite.get_scale(), Vector2(2.0, 2.0), 0.3,
                Tween.TRANS_QUAD, Tween.EASE_OUT)

**Bad**:

::

    effect.interpolate_property(sprite, "transform/scale",
        sprite.get_scale(), Vector2(2.0, 2.0), 0.3,
        Tween.TRANS_QUAD, Tween.EASE_OUT)

Exceptions to this rule are arrays, dictionaries, and enums. Use a single
indentation level to distinguish continuation lines:

**Good**:

::

    var party = [
        "Godot",
        "Godette",
        "Steve",
    ]

    var character_dict = {
        "Name": "Bob",
        "Age": 27,
        "Job": "Mechanic",
    }

    enum Tiles {
        TILE_BRICK,
        TILE_FLOOR,
        TILE_SPIKE,
        TILE_TELEPORT,
    }

**Bad**:

::

    var party = [
            "Godot",
            "Godette",
            "Steve",
    ]

    var character_dict = {
            "Name": "Bob",
            "Age": 27,
            "Job": "Mechanic",
    }

    enum Tiles {
            TILE_BRICK,
            TILE_FLOOR,
            TILE_SPIKE,
            TILE_TELEPORT,
    }

Trailing comma
~~~~~~~~~~~~~~

Use a trailing comma on the last line in arrays, dictionaries, and enums. This
results in easier refactoring and better diffs in version control as the last
line doesn't need to be modified when adding new elements.

**Good**:

::

    enum Tiles {
        TILE_BRICK,
        TILE_FLOOR,
        TILE_SPIKE,
        TILE_TELEPORT,
    }

**Bad**:

::

    enum Tiles {
        TILE_BRICK,
        TILE_FLOOR,
        TILE_SPIKE,
        TILE_TELEPORT
    }

Trailing commas are unnecessary in single-line lists, so don't add them in this case.

**Good**:

::

    enum Tiles {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT}

**Bad**:

::

    enum Tiles {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT,}

Blank lines
~~~~~~~~~~~

Surround functions and class definitions with two blank lines:

::

    func heal(amount):
        health += amount
        health = min(health, max_health)
        emit_signal("health_changed", health)


    func take_damage(amount, effect=null):
        health -= amount
        health = max(0, health)
        emit_signal("health_changed", health)

Use one blank line inside functions to separate logical sections.

.. note:: We use a single line between classes and function definitions in the class reference and
          in short code snippets in this documentation.

Line length
~~~~~~~~~~~

Keep individual lines of code under 100 characters.

If you can, try to keep lines under 80 characters. This helps to read the code
on small displays and with two scripts opened side-by-side in an external text
editor. For example, when looking at a differential revision.

One statement per line
~~~~~~~~~~~~~~~~~~~~~~

Never combine multiple statements on a single line. No, C programmers,
not even with a single line conditional statement.

**Good**:

::

    if position.x > width:
        position.x = 0

    if flag:
        print("flagged")

**Bad**:

::

    if position.x > width: position.x = 0

    if flag: print("flagged")

The only exception to that rule is the ternary operator:

::

   next_state = "fall" if not is_on_floor() else "idle"

Format multiline statements for readability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you have particularly long ``if`` statements or nested ternary expressions,
wrapping them over multiple lines improves readability. Since continuation lines
are still part of the same expression, 2 indent levels should be used instead of one.

GDScript allows wrapping statements using multiple lines using parentheses or
backslashes. Parentheses are favored in this style guide since they make for
easier refactoring. With backslashes, you have to ensure that the last line
never contains a backslash at the end. With parentheses, you don't have to
worry about the last line having a backslash at the end.

When wrapping a conditional expression over multiple lines, the ``and``/``or``
keywords should be placed at the beginning of the line continuation, not at the
end of the previous line.

**Good**:

::

    var angle_degrees = 135
    var quadrant = (
            "northeast" if angle_degrees <= 90
            else "southeast" if angle_degrees <= 180
            else "southwest" if angle_degrees <= 270
            else "northwest"
    )

    var position = Vector2(250, 350)
    if (
            position.x > 200 and position.x < 400
            and position.y > 300 and position.y < 400
    ):
        pass

**Bad**:

::

    var angle_degrees = 135
    var quadrant = "northeast" if angle_degrees <= 90 else "southeast" if angle_degrees <= 180 else "southwest" if angle_degrees <= 270 else "northwest"

    var position = Vector2(250, 350)
    if position.x > 200 and position.x < 400 and position.y > 300 and position.y < 400:
        pass

Avoid unnecessary parentheses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Avoid parentheses in expressions and conditional statements. Unless
necessary for order of operations or wrapping over multiple lines,
they only reduce readability.

**Good**:

::

    if is_colliding():
        queue_free()

**Bad**:

::

    if (is_colliding()):
        queue_free()

Boolean operators
~~~~~~~~~~~~~~~~~

Prefer the plain English versions of boolean operators, as they are the most accessible:

- Use ``and`` instead of ``&&``.
- Use ``or`` instead of ``||``.

You may also use parentheses around boolean operators to clear any ambiguity.
This can make long expressions easier to read.

**Good**:

::

    if (foo and bar) or baz:
        print("condition is true")

**Bad**:

::

    if foo && bar || baz:
        print("condition is true")

Comment spacing
~~~~~~~~~~~~~~~

Regular comments should start with a space, but not code that you comment out.
This helps differentiate text comments from disabled code.

**Good**:

::

    # This is a comment.
    #print("This is disabled code")

**Bad**:

::

    #This is a comment.
    # print("This is disabled code")

.. note::

   In the script editor, to toggle the selected code commented, press
   :kbd:`Ctrl + K`. This feature adds a single # sign at the start
   of the selected lines.

Whitespace
~~~~~~~~~~

Always use one space around operators and after commas. Also, avoid extra spaces
in dictionary references and function calls.

**Good**:

::

    position.x = 5
    position.y = target_position.y + 10
    dict["key"] = 5
    my_array = [4, 5, 6]
    print("foo")

**Bad**:

::

    position.x=5
    position.y = mpos.y+10
    dict ["key"] = 5
    myarray = [4,5,6]
    print ("foo")

Don't use spaces to align expressions vertically:

::

    x        = 100
    y        = 100
    velocity = 500

Quotes
~~~~~~

Use double quotes unless single quotes make it possible to escape fewer
characters in a given string. See the examples below:

::

    # Normal string.
    print("hello world")

    # Use double quotes as usual to avoid escapes.
    print("hello 'world'")

    # Use single quotes as an exception to the rule to avoid escapes.
    print('hello "world"')

    # Both quote styles would require 2 escapes; prefer double quotes if it's a tie.
    print("'hello' \"world\"")

Numbers
~~~~~~~

Don't omit the leading or trailing zero in floating-point numbers. Otherwise,
this makes them less readable and harder to distinguish from integers at a
glance.

**Good**::

    var float_number = 0.234
    var other_float_number = 13.0

**Bad**::

    var float_number = .234
    var other_float_number = 13.

Use lowercase for letters in hexadecimal numbers, as their lower height makes
the number easier to read.

**Good**::

    var hex_number = 0xfb8c0b

**Bad**::

    var hex_number = 0xFB8C0B

Take advantage of GDScript's underscores in literals to make large numbers more
readable.

**Good**::

    var large_number = 1_234_567_890
    var large_hex_number = 0xffff_f8f8_0000
    var large_bin_number = 0b1101_0010_1010
    # Numbers lower than 1000000 generally don't need separators.
    var small_number = 12345

**Bad**::

    var large_number = 1234567890
    var large_hex_number = 0xfffff8f80000
    var large_bin_number = 0b110100101010
    # Numbers lower than 1000000 generally don't need separators.
    var small_number = 12_345

.. _naming_conventions:

Naming conventions
------------------

These naming conventions follow the Godot Engine style. Breaking these will make
your code clash with the built-in naming conventions, leading to inconsistent
code.

File names
~~~~~~~~~~

Use snake_case for file names. For named classes, convert the PascalCase class
name to snake_case::

    # This file should be saved as `weapon.gd`.
    class_name Weapon
    extends Node

::

    # This file should be saved as `yaml_parser.gd`.
    class_name YAMLParser
    extends Object

This is consistent with how C++ files are named in Godot's source code. This
also avoids case sensitivity issues that can crop up when exporting a project
from Windows to other platforms.

Classes and nodes
~~~~~~~~~~~~~~~~~

Use PascalCase for class and node names:

::

   extends KinematicBody

Also use PascalCase when loading a class into a constant or a variable:

::

    const Weapon = preload("res://weapon.gd")

Functions and variables
~~~~~~~~~~~~~~~~~~~~~~~

Use snake\_case to name functions and variables:

::

   var particle_effect
   func load_level():

Prepend a single underscore (\_) to virtual methods functions the user must
override, private functions, and private variables:

::

   var _counter = 0
   func _recalculate_path():

Signals
~~~~~~~

Use the past tense to name signals:

::

    signal door_opened
    signal score_changed

Constants and enums
~~~~~~~~~~~~~~~~~~~

Write constants with CONSTANT\_CASE, that is to say in all caps with an
underscore (\_) to separate words:

::

    const MAX_SPEED = 200

Use PascalCase for enum *names* and CONSTANT\_CASE for their members, as they
are constants:

::

    enum Element {
        EARTH,
        WATER,
        AIR,
        FIRE,
    }


Code order
----------

This first section focuses on code order. For formatting, see
:ref:`formatting`. For naming conventions, see :ref:`naming_conventions`.

We suggest to organize GDScript code this way:

::

    01. tool
    02. class_name
    03. extends
    04. # docstring

    05. signals
    06. enums
    07. constants
    08. exported variables
    09. public variables
    10. private variables
    11. onready variables

    12. optional built-in virtual _init method
    13. built-in virtual _ready method
    14. remaining built-in virtual methods
    15. public methods
    16. private methods

We optimized the order to make it easy to read the code from top to bottom, to
help developers reading the code for the first time understand how it works, and
to avoid errors linked to the order of variable declarations.

This code order follows four rules of thumb:

1. Properties and signals come first, followed by methods.
2. Public comes before private.
3. Virtual callbacks come before the class's interface.
4. The object's construction and initialization functions, ``_init`` and
   ``_ready``, come before functions that modify the object at runtime.


Class declaration
~~~~~~~~~~~~~~~~~

If the code is meant to run in the editor, place the ``tool`` keyword on the
first line of the script.

Follow with the `class_name` if necessary. You can turn a GDScript file into a
global type in your project using this feature. For more information, see
:ref:`doc_gdscript`.

Then, add the `extends` keyword if the class extends a built-in type.

Following that, you should have the class's optional docstring as comments. You
can use that to explain the role of your class to your teammates, how it works,
and how other developers should use it, for example.

::

   class_name MyNode
   extends Node
   # A brief description of the class's role and functionality.
   # Longer description.

Signals and properties
~~~~~~~~~~~~~~~~~~~~~~

Write signal declarations, followed by properties, that is to say, member
variables, after the docstring.

Enums should come after signals, as you can use them as export hints for other
properties.

Then, write constants, exported variables, public, private, and onready
variables, in that order.

::

   signal spawn_player(position)

   enum Jobs {KNIGHT, WIZARD, ROGUE, HEALER, SHAMAN}

   const MAX_LIVES = 3

   export(Jobs) var job = Jobs.KNIGHT
   export var max_health = 50
   export var attack = 5

   var health = max_health setget set_health

   var _speed = 300.0

   onready var sword = get_node("Sword")
   onready var gun = get_node("Gun")


.. note::

   The GDScript compiler evaluates onready variables right before the ``_ready``
   callback. You can use that to cache node dependencies, that is to say, to get
   child nodes in the scene that your class relies on. This is what the example
   above shows.

Member variables
~~~~~~~~~~~~~~~~

Don't declare member variables if they are only used locally in a method, as it
makes the code more difficult to follow. Instead, declare them as local
variables in the method's body.

Local variables
~~~~~~~~~~~~~~~

Declare local variables as close as possible to their first use. This makes it
easier to follow the code, without having to scroll too much to find where the
variable was declared.

Methods and static functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After the class's properties come the methods.

Start with the ``_init()`` callback method, that the engine will call upon
creating the object in memory. Follow with the ``_ready()`` callback, that Godot
calls when it adds a node to the scene tree.

These functions should come first because they show how the object is
initialized.

Other built-in virtual callbacks, like ``_unhandled_input()`` and
``_physics_process``, should come next. These control the object's main loop and
interactions with the game engine.

The rest of the class's interface, public and private methods, come after that,
in that order.

::

    func _init():
        add_to_group("state_machine")


    func _ready():
        connect("state_changed", self, "_on_state_changed")
        _state.enter()


    func _unhandled_input(event):
        _state.unhandled_input(event)


    func transition_to(target_state_path, msg={}):
        if not has_node(target_state_path):
            return

        var target_state = get_node(target_state_path)
        assert(target_state.is_composite == false)

        _state.exit()
        self._state = target_state
        _state.enter(msg)
        Events.emit_signal("player_state_changed", _state.name)


    func _on_state_changed(previous, new):
        print("state changed")
        emit_signal("state_changed")


Static typing
-------------

Since Godot 3.1, GDScript supports :ref:`optional static typing<doc_gdscript_static_typing>`.

Declared types
~~~~~~~~~~~~~~

To declare a variable's type, use ``<variable>: <type>``:

::

   var health: int = 0

To declare the return type of a function, use ``-> <type>``:

::

   func heal(amount: int) -> void:

Inferred types
~~~~~~~~~~~~~~

In most cases you can let the compiler infer the type, using ``:=``:

::

   var health := 0  # The compiler will use the int type.

However, in a few cases when context is missing, the compiler falls back to
the function's return type. For example, ``get_node()`` cannot infer a type
unless the scene or file of the node is loaded in memory. In this case, you
should set the type explicitly.

**Good**:

::

   onready var health_bar: ProgressBar = get_node("UI/LifeBar")

Alternatively, you can use the ``as`` keyword to cast the return type, and
that type will be used to infer the type of the var.

.. rst-class:: code-example-good

::

   onready var health_bar := get_node("UI/LifeBar") as ProgressBar
   # health_bar will be typed as ProgressBar

This option is also considered more :ref:`type-safe<doc_gdscript_static_typing_safe_lines>` than the first.

**Bad**:

::

   # The compiler can't infer the exact type and will use Node
   # instead of ProgressBar.
   onready var health_bar := get_node("UI/LifeBar")


===================================================
/. ./tutorials/scripting/gdscript/static_typing.rst
===================================================

.. _doc_gdscript_static_typing:

Static typing in GDScript
=========================

In this guide, you will learn:

-  **How to use types in GDScript**
-  That **static types can help you avoid bugs**

Where and how you use this new language feature is entirely up to you:
you can use it only in some sensitive GDScript files, use it everywhere,
or write code like you always did!

Static types can be used on variables, constants, functions, parameters,
and return types.

.. note::

    Typed GDScript is available since Godot 3.1.

A brief look at static typing
-----------------------------

With typed GDScript, Godot can detect even more errors as you write
code! It gives you and your teammates more information as you're
working, as the arguments' types show up when you call a method.

Imagine you're programming an inventory system. You code an ``Item``
node, then an ``Inventory``. To add items to the inventory, the people
who work with your code should always pass an ``Item`` to the
``Inventory.add`` method. With types, you can enforce this:

::

    # In 'Item.gd'.
    class_name Item
    # In 'Inventory.gd'.
    class_name Inventory


    func add(reference: Item, amount: int = 1):
        var item = find_item(reference)
        if not item:
            item = _instance_item_from_db(reference)

        item.amount += amount

Another significant advantage of typed GDScript is the new **warning
system**. From version 3.1, Godot gives you warnings about your code as
you write it: the engine identifies sections of your code that may lead
to issues at runtime, but lets you decide whether or not you want to
leave the code as it is. More on that in a moment.

Static types also give you better code completion options. Below, you
can see the difference between a dynamic and a static typed completion
options for a class called ``PlayerController``.

You've probably stored a node in a variable before, and typed a dot to
be left with no autocomplete suggestions:

.. figure:: img/typed_gdscript_code_completion_dynamic.png
   :alt: code completion options for dynamic

This is due to dynamic code. Godot cannot know what node or value type
you're passing to the function. If you write the type explicitly
however, you will get all public methods and variables from the node:

.. figure:: img/typed_gdscript_code_completion_typed.png
   :alt: code completion options for typed

In the future, typed GDScript will also increase code performance:
Just-In-Time compilation and other compiler improvements are already
on the roadmap!

Overall, typed programming gives you a more structured experience. It
helps prevent errors and improves the self-documenting aspect of your
scripts. This is especially helpful when you're working in a team or on
a long-term project: studies have shown that developers spend most of
their time reading other people's code, or scripts they wrote in the
past and forgot about. The clearer and the more structured the code, the
faster it is to understand, the faster you can move forward.

How to use static typing
------------------------

To define the type of a variable or a constant, write a colon after the
variable's name, followed by its type. E.g. ``var health: int``. This
forces the variable's type to always stay the same:

::

    var damage: float = 10.5
    const MOVE_SPEED: float = 50.0

Godot will try to infer types if you write a colon, but you omit the
type:

::

    var life_points := 4
    var damage := 10.5
    var motion := Vector2()

Currently you can use three types of… types:

1. :ref:`Built-in <doc_gdscript_builtin_types>`
2. Core classes and nodes (``Object``, ``Node``, ``Area2D``,
   ``Camera2D``, etc.)
3. Your own custom classes. Look at the new :ref:`class_name <doc_gdscript_basics_class_name>`
   feature to register types in the editor.

.. note::

    You don't need to write type hints for constants, as Godot sets it automatically from the assigned value. But you can still do so to make the intent of your code clearer.

Custom variable types
~~~~~~~~~~~~~~~~~~~~~

You can use any class, including your custom classes, as types. There
are two ways to use them in scripts. The first method is to preload the
script you want to use as a type in a constant:

::

    const Rifle = preload("res://player/weapons/Rifle.gd")
    var my_rifle: Rifle

The second method is to use the ``class_name`` keyword when you create.
For the example above, your Rifle.gd would look like this:

::

    class_name Rifle
    extends Node2D

If you use ``class_name``, Godot registers the Rifle type globally in
the editor, and you can use it anywhere, without having to preload it
into a constant:

::

    var my_rifle: Rifle

Variable casting
~~~~~~~~~~~~~~~~

Type casting is a key concept in typed languages.
Casting is the conversion of a value from one type to another.

Imagine an Enemy in your game, that ``extends Area2D``. You want it to
collide with the Player, a ``KinematicBody2D`` with a script called
``PlayerController`` attached to it. You use the ``on_body_entered``
signal to detect the collision. With typed code, the body you detect is
going to be a generic ``PhysicsBody2D``, and not your
``PlayerController`` on the ``_on_body_entered`` callback.

You can check if this ``PhysicsBody2D`` is your Player with the ``as``
casting keyword, and using the colon ``:`` again to force the variable
to use this type. This forces the variable to stick to the
``PlayerController`` type:

::

    func _on_body_entered(body: PhysicsBody2D) -> void:
        var player := body as PlayerController
        if not player:
            return

        player.damage()

As we're dealing with a custom type, if the ``body`` doesn't extend
``PlayerController``, the ``player``\ variable will be set to ``null``.
We can use this to check if the body is the player or not. We will also
get full autocompletion on the player variable thanks to that cast.

.. note::

    If you try to cast with a built-in type and it fails, Godot will throw an error.

.. _doc_gdscript_static_typing_safe_lines:

Safe lines
^^^^^^^^^^

You can also use casting to ensure safe lines. Safe lines are a new
tool in Godot 3.1 to tell you when ambiguous lines of code are
type-safe. As you can mix and match typed and dynamic code, at times,
Godot doesn't have enough information to know if an instruction will trigger
an error or not at runtime.

This happens when you get a child node. Let's take a timer for example:
with dynamic code, you can get the node with ``$Timer``. GDScript
supports `duck-typing <https://stackoverflow.com/a/4205163/8125343>`__,
so even if your timer is of type ``Timer``, it is also a ``Node`` and an
``Object``, two classes it extends. With dynamic GDScript, you also
don't care about the node's type as long as it has the methods you need
to call.

You can use casting to tell Godot the type you expect when you get a
node: ``($Timer as Timer)``, ``($Player as KinematicBody2D)``, etc.
Godot will ensure the type works and if so, the line number will turn
green at the left of the script editor.

.. figure:: img/typed_gdscript_safe_unsafe_line.png
   :alt: Unsafe vs Safe Line

   Unsafe line (line 7) vs Safe Lines (line 6 and 8)

.. note::

    You can turn off safe lines or change their color in the editor settings.

Define the return type of a function with the arrow ->
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To define the return type of a function, write a dash and a right angle
bracket ``->`` after its declaration, followed by the return type:

::

    func _process(delta: float) -> void:
        pass

The type ``void`` means the function does not return anything. You can
use any type, as with variables:

::

    func hit(damage: float) -> bool:
        health_points -= damage
        return health_points <= 0

You can also use your own nodes as return types:

::

    # Inventory.gd

    # Adds an item to the inventory and returns it.
    func add(reference: Item, amount: int) -> Item:
        var item: Item = find_item(reference)
        if not item:
            item = ItemDatabase.get_instance(reference)

        item.amount += amount
        return item

Typed or dynamic: stick to one style
------------------------------------

Typed GDScript and dynamic GDScript can coexist in the same project. But
it's recommended to stick to either style for consistency in your codebase,
and for your peers. It's easier for everyone to work together if you
follow the same guidelines, and faster to read and understand other
people's code.

Typed code takes a little more writing, but you get the benefits we
discussed above. Here's an example of the same, empty script, in a
dynamic style:

::

    extends Node


    func _ready():
        pass


    func _process(delta):
        pass

And with static typing:

::

    extends Node


    func _ready() -> void:
        pass


    func _process(delta: float) -> void:
        pass

As you can see, you can also use types with the engine's virtual
methods. Signal callbacks, like any methods, can also use types. Here's
a ``body_entered`` signal in a dynamic style:

::

    func _on_Area2D_body_entered(body):
        pass

And the same callback, with type hints:

::

    func _on_area_entered(area: CollisionObject2D) -> void:
        pass

You're free to replace, e.g. the ``CollisionObject2D``, with your own type,
to cast parameters automatically:

::

    func _on_area_entered(bullet: Bullet) -> void:
        if not bullet:
            return

        take_damage(bullet.damage)

The ``bullet`` variable could hold any ``CollisionObject2D`` here, but
we make sure it is our ``Bullet``, a node we created for our project. If
it's anything else, like an ``Area2D``, or any node that doesn't extend
``Bullet``, the ``bullet`` variable will be ``null``.

Warning system
--------------

.. note::

    Documentation about the GDScript warning system has been moved to
    :ref:`doc_gdscript_warning_system`.

Cases where you can't specify types
-----------------------------------

To wrap up this introduction, let's cover a few cases where you can't
use type hints. All the examples below **will trigger errors**.

You can't use Enums as types:

::

    enum MoveDirection {UP, DOWN, LEFT, RIGHT}
    var current_direction: MoveDirection

You can't specify the type of individual members in an array. This will
give you an error:

::

    var enemies: Array = [$Goblin: Enemy, $Zombie: Enemy]

You can't force the assignment of types in a ``for`` loop, as each
element the ``for`` keyword loops over already has a different type. So you
**cannot** write:

::

    var names = ["John", "Marta", "Samantha", "Jimmy"]
    for name: String in names:
        pass

Two scripts can't depend on each other in a cyclic fashion:

::

    # Player.gd

    extends Area2D
    class_name Player


    var rifle: Rifle

::

    # Rifle.gd

    extends Area2D
    class_name Rifle


    var player: Player

Summary
-------

Typed GDScript is a powerful tool. Available as of version 3.1 of Godot, it
helps you write more structured code, avoid common errors, and
create scalable systems. In the future, static types will also bring you
a nice performance boost thanks to upcoming compiler optimizations.


===================================================
/. ./tutorials/scripting/gdscript/warning_system.rst
===================================================

.. _doc_gdscript_warning_system:

GDScript warning system
=======================

The GDScript warning system complements :ref:`static typing <doc_gdscript_static_typing>`
(but it can work without static typing too). It's here to help you avoid
mistakes that are hard to spot during development, and that may lead
to runtime errors.

You can configure warnings in the Project Settings under the section
called **Gdscript**:

.. figure:: img/typed_gdscript_warning_system_settings.png
   :alt: Warning system project settings

   Warning system project settings

You can find a list of warnings for the active GDScript file in the
script editor's status bar. The example below has 3 warnings:

.. figure:: img/typed_gdscript_warning_example.png
   :alt: Warning system example

   Warning system example

To ignore specific warnings in one file, insert a special comment of the
form ``# warning-ignore:warning-id``, or click on the ignore link to the
right of the warning's description. Godot will add a comment above the
corresponding line and the code won't trigger the corresponding warning
anymore:

.. figure:: img/typed_gdscript_warning_system_ignore.png
   :alt: Warning system ignore example

   Warning system ignore example

You can also choose to ignore not just one but all warnings of a certain
type in this file with ``# warning-ignore-all:warning-id``. To ignore all
warnings of all types in a file add the comment ``# warnings-disable`` to it.

Warnings won't prevent the game from running, but you can turn them into
errors if you'd like. This way your game won't compile unless you fix
all warnings. Head to the ``GDScript`` section of the Project Settings to
turn on this option. Here's the same file as the previous example with
warnings as errors turned on:

.. figure:: img/typed_gdscript_warning_system_errors.png
   :alt: Warnings as errors

   Warnings as errors


===================================================
/. ./tutorials/scripting/gdscript/gdscript_format_string.rst
===================================================

.. _doc_gdscript_printf:

GDScript format strings
=======================

GDScript offers a feature called *format strings*, which allows reusing text
templates to succinctly create different but similar strings.

Format strings are just like normal strings, except they contain certain
placeholder character-sequences. These placeholders can then easily be replaced
by parameters handed to the format string.

As an example, with ``%s`` as a placeholder, the format string ``"Hello %s, how
are you?"`` can easily be changed to ``"Hello World, how are you?"``. Notice
the placeholder is in the middle of the string; modifying it without format
strings could be cumbersome.


Usage in GDScript
-----------------

Examine this concrete GDScript example:

::

    # Define a format string with placeholder '%s'
    var format_string = "We're waiting for %s."

    # Using the '%' operator, the placeholder is replaced with the desired value
    var actual_string = format_string % "Godot"

    print(actual_string)
    # Output: "We're waiting for Godot."

Placeholders always start with a ``%``, but the next character or characters,
the *format specifier*, determines how the given value is converted to a
string.

The ``%s`` seen in the example above is the simplest placeholder and works for
most use cases: it converts the value by the same method by which an implicit
String conversion or ``str()`` would convert it. Strings remain unchanged,
Booleans turn into either ``"True"`` or ``"False"``, an integral or real number
becomes a decimal, other types usually return their data in a human-readable
string.

There is also another way to format text in GDScript, namely the ``String.format()``
method. It replaces all occurrences of a key in the string with the corresponding
value. The method can handle arrays or dictionaries for the key/value pairs.

Arrays can be used as key, index, or mixed style (see below examples). Order only
matters when the index or mixed style of Array is used.

A quick example in GDScript:

::

    # Define a format string
    var format_string = "We're waiting for {str}"

    # Using the 'format' method, replace the 'str' placeholder
    var actual_string = format_string.format({"str": "Godot"})

    print(actual_string)
    # Output: "We're waiting for Godot"

There are other `format specifiers`_, but they are only applicable when using
the ``%`` operator.


Multiple placeholders
---------------------

Format strings may contain multiple placeholders. In such a case, the values
are handed in the form of an array, one value per placeholder (unless using a
format specifier with ``*``, see `dynamic padding`_):

::

    var format_string = "%s was reluctant to learn %s, but now he enjoys it."
    var actual_string = format_string % ["Estragon", "GDScript"]

    print(actual_string)
    # Output: "Estragon was reluctant to learn GDScript, but now he enjoys it."

Note the values are inserted in order. Remember all placeholders must be
replaced at once, so there must be an appropriate number of values.


Format specifiers
-----------------

There are format specifiers other than ``s`` that can be used in placeholders.
They consist of one or more characters. Some of them work by themselves like
``s``, some appear before other characters, some only work with certain
values or characters.


Placeholder types
~~~~~~~~~~~~~~~~~

One and only one of these must always appear as the last character in a format
specifier. Apart from ``s``, these require certain types of parameters.

+-------+---------------------------------------------------------------------+
| ``s`` | **Simple** conversion to String by the same method as implicit      |
|       | String conversion.                                                  |
+-------+---------------------------------------------------------------------+
| ``c`` | A single **Unicode character**. Expects an unsigned 8-bit integer   |
|       | (0-255) for a code point or a single-character string.              |
+-------+---------------------------------------------------------------------+
| ``d`` | A **decimal integral** number. Expects an integral or real number   |
|       | (will be floored).                                                  |
+-------+---------------------------------------------------------------------+
| ``o`` | An **octal integral** number. Expects an integral or real number    |
|       | (will be floored).                                                  |
+-------+---------------------------------------------------------------------+
| ``x`` | A **hexadecimal integral** number with **lower-case** letters.      |
|       | Expects an integral or real number (will be floored).               |
+-------+---------------------------------------------------------------------+
| ``X`` | A **hexadecimal integral** number with **upper-case** letters.      |
|       | Expects an integral or real number (will be floored).               |
+-------+---------------------------------------------------------------------+
| ``f`` | A **decimal real** number. Expects an integral or real number.      |
+-------+---------------------------------------------------------------------+


Placeholder modifiers
~~~~~~~~~~~~~~~~~~~~~

These characters appear before the above. Some of them work only under certain
conditions.

+---------+-------------------------------------------------------------------+
| ``+``   | In number specifiers, **show + sign** if positive.                |
+---------+-------------------------------------------------------------------+
| Integer | Set **padding**. Padded with spaces or with zeroes if integer     |
|         | starts with ``0`` in an integer or real number placeholder.       |
|         | The leading ``0`` is ignored if ``-`` is present.                 |
|         | When used after ``.``, see ``.``.                                 |
+---------+-------------------------------------------------------------------+
| ``.``   | Before ``f``, set **precision** to 0 decimal places. Can be       |
|         | followed up with numbers to change. Padded with zeroes.           |
+---------+-------------------------------------------------------------------+
| ``-``   | **Pad to the right** rather than the left.                        |
+---------+-------------------------------------------------------------------+
| ``*``   | **Dynamic padding**, expect additional integral parameter to set  |
|         | padding or precision after ``.``, see `dynamic padding`_.         |
+---------+-------------------------------------------------------------------+


Padding
-------

The ``.`` (*dot*), ``*`` (*asterisk*), ``-`` (*minus sign*) and digit
(``0``-``9``) characters are used for padding. This allows printing several
values aligned vertically as if in a column, provided a fixed-width font is
used.

To pad a string to a minimum length, add an integer to the specifier:

::

    print("%10d" % 12345)
    # output: "     12345"
    # 5 leading spaces for a total length of 10

If the integer starts with ``0``, integral values are padded with zeroes
instead of white space:

::

    print("%010d" % 12345)
    # output: "0000012345"

Precision can be specified for real numbers by adding a ``.`` (*dot*) with an
integer following it. With no integer after ``.``, a precision of 0 is used,
rounding to integral value. The integer to use for padding must appear before
the dot.

::

    # Pad to minimum length of 10, round to 3 decimal places
    print("%10.3f" % 10000.5555)
    # Output: " 10000.556"
    # 1 leading space

The ``-`` character will cause padding to the right rather than the left,
useful for right text alignment:

::

    print("%-10d" % 12345678)
    # Output: "12345678  "
    # 2 trailing spaces


Dynamic padding
~~~~~~~~~~~~~~~

By using the ``*`` (*asterisk*) character, the padding or precision can be set
without modifying the format string. It is used in place of an integer in the
format specifier. The values for padding and precision are then passed when
formatting:

::

    var format_string = "%*.*f"
    # Pad to length of 7, round to 3 decimal places:
    print(format_string % [7, 3, 8.8888])
    # Output: "  8.889"
    # 2 leading spaces

It is still possible to pad with zeroes in integer placeholders by adding ``0``
before ``*``:

::

    print("%0*d" % [2, 3])
    # Output: "03"


Escape sequence
---------------

To insert a literal ``%`` character into a format string, it must be escaped to
avoid reading it as a placeholder. This is done by doubling the character:

::

    var health = 56
    print("Remaining health: %d%%" % health)
    # Output: "Remaining health: 56%"


Format method examples
----------------------

The following are some examples of how to use the various invocations of the
``String.format``  method.


+------------+-----------+------------------------------------------------------------------------------+-------------------+
| **Type**   | **Style** | **Example**                                                                  | **Result**        |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Dictionary | key       | ``"Hi, {name} v{version}!".format({"name":"Godette", "version":"3.0"})``     | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Dictionary | index     | ``"Hi, {0} v{1}!".format({"0":"Godette", "1":"3.0"})``                       | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Dictionary | mix       | ``"Hi, {0} v{version}!".format({"0":"Godette", "version":"3.0"})``           | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Array      | key       | ``"Hi, {name} v{version}!".format([["version","3.0"], ["name","Godette"]])`` | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Array      | index     | ``"Hi, {0} v{1}!".format(["Godette","3.0"])``                                | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Array      | mix       | ``"Hi, {name} v{0}!".format([3.0, ["name","Godette"]])``                     | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+
| Array      | no index  | ``"Hi, {} v{}!".format(["Godette", 3.0], "{}")``                             | Hi, Godette v3.0! |
+------------+-----------+------------------------------------------------------------------------------+-------------------+

Placeholders can also be customized when using ``String.format``, here's some
examples of that functionality.


+-----------------+------------------------------------------------------+------------------+
| **Type**        | **Example**                                          | **Result**       |
+-----------------+------------------------------------------------------+------------------+
| Infix (default) | ``"Hi, {0} v{1}".format(["Godette", "3.0"], "{_}")`` | Hi, Godette v3.0 |
+-----------------+------------------------------------------------------+------------------+
| Postfix         | ``"Hi, 0% v1%".format(["Godette", "3.0"], "_%")``    | Hi, Godette v3.0 |
+-----------------+------------------------------------------------------+------------------+
| Prefix          | ``"Hi, %0 v%1".format(["Godette", "3.0"], "%_")``    | Hi, Godette v3.0 |
+-----------------+------------------------------------------------------+------------------+

Combining both the ``String.format`` method and the ``%`` operator could be useful, as
``String.format`` does not have a way to manipulate the representation of numbers.

+---------------------------------------------------------------------------+-------------------+
| **Example**                                                               | **Result**        |
+---------------------------------------------------------------------------+-------------------+
| ``"Hi, {0} v{version}".format({0:"Godette", "version":"%0.2f" % 3.114})`` | Hi, Godette v3.11 |
+---------------------------------------------------------------------------+-------------------+


===================================================
/. ./tutorials/scripting/visual_script/index.rst
===================================================

VisualScript
============

.. warning::

    `Godot 4.0 will remove VisualScript from core entirely. <https://godotengine.org/article/godot-4-will-discontinue-visual-scripting>`__
    As a result, creating new projects using visual scripting in Godot is not recommended.
    Future Godot 4.x releases may have VisualScript reimplemented as an extension.

    While Godot 3.x will keep VisualScript supported, we recommend
    :ref:`trying out GDScript <toc-learn-scripting-gdscript>` instead,
    especially if you intend to migrate your project to Godot 4.

.. toctree::
   :maxdepth: 3
   :name: toc-learn-scripting-visual_script

   what_is_visual_scripting
   getting_started
   nodes_purposes
   custom_visualscript_nodes


===================================================
/. ./tutorials/scripting/visual_script/what_is_visual_scripting.rst
===================================================

.. _doc_what_is_visual_script:

What is Visual Scripting
========================

Visual Scripting is a tool designed to make the entry barrier to programming
much lower. As code is more visual, it needs less abstract thinking to be
understood. Any artist, animator, game designer, etc. can look at it and quickly
grasp the flow of logic.

The reason it does not make existing programming obsolete is, simply, that it does not scale as well.
It takes considerably more time to create code with it, and it's often more difficult
to modify than just writing a few characters.

With the misunderstanding cleared up, the question that remains is what are the practical
uses for Visual Scripting.

The most common use cases are as follows:

* Game development beginners who want to learn an engine but have no programming experience yet.
* Artists and Game Designers who have no experience in programming and want to create quick prototypes or simple games.
* Programmers working in a team that want to make part of the game logic available to Artists or Game Designers in order to offload some of their work.

These scenarios are far more common than one might think, so this is why Godot has added this feature.


===================================================
/. ./tutorials/scripting/visual_script/getting_started.rst
===================================================

.. _doc_getting_started_visual_script:

Getting started with Visual Scripting
=====================================

As with everything in Godot, we prioritize a good experience over copying or integrating third party solutions
which might not fit nicely in the current workflow. This led us to write our own version of how we believe
this feature would work best with the engine.

In Godot, a Visual Script fits smoothly together with regular scripts in the Editor tab

.. image:: img/visual_script1.png


In fact, Visual Scripting integrates so well to Godot that it's hard to believe it was added only
in version 3.0. This is because, when editing, the rest of Godot panels and docks act like a
palette from where you can drag and drop all sorts of information to the script canvas:

.. image:: img/visual_script2.png


Creating a script
-----------------

Creating scripts works the same as with other scripting languages: Select any node in the scene
and push the "New Script" button at the top right corner of the Scene Tree dock:

.. image:: img/visual_script3.png


Once it opens, the script type "Visual Script" must be selected from the drop down list. The script extension
must be ".vs" (for Visual Script!).

.. image:: img/visual_script4.png


Finally, the Script Editor will open, allowing you to start editing the visual script:

.. image:: img/visual_script5.png


Adding a function
-----------------

Unlike other visual scripting implementations, Visual Scripting in Godot is heavily based on functions.
This happens because it uses the same interface to communicate with the engine as other scripting engines.
In Godot, the scripting interface is universal and all implementations conform to it.

A function is an individual canvas with nodes connected.

A single script can contain many functions, each of which will have a canvas of its own, allowing for more organization.

There are three main ways to add functions in a script:

Overriding a virtual function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most types of nodes and other types of objects in Godot contain virtual functions. These are functions that
will be called (run your code) when something happens and can be looked up in the reference. Virtual functions
are listed when pressing the "Override" icon in the member panel:

.. image:: img/visual_script6.png


In the following example, a function will be executed when the node is loaded and added to the running scene.
For this, the _ready() virtual method will be overridden:

.. image:: img/visual_script7.png


Finally, a canvas appears for this function, showing the override:

.. image:: img/visual_script8.png


As some functions expect you to return a value, they will also add a return node where such value is supposed to be
provided:

.. image:: img/visual_script9.png


Connecting a signal to a function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nodes in a tree emit signals when something happens. Godot uses signals for all sorts of things.
A typical example would be a button that emits a "pressed" signal when actually pressed.

For this, a node must be selected and the Node tab opened. This will allow inspecting the signals.
Once they are displayed, connect the "pressed" signal:

.. image:: img/visual_script10.png


This will open the connection dialog. In this dialog, you must select the node where the signal will be
connected to, and the function that will receive the signal:

.. image:: img/visual_script11.png


If this is done right, a new function will be created in our script and a signal will automatically be
connected to it:

.. image:: img/visual_script12.png


Creating a function manually
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The last way to create functions is to do it manually. In general, this is not as common unless you
really need it. Custom functions work when another (or the same) script calls them manually.
The main use cases for this are breaking a larger function up into several manageable chunks and reusing your visual code.

To create a function manually, push the big "Plus" button, and a new function will be added
with a default name:

.. image:: img/visual_script13.png


This will add a new function, which can be renamed by simply double clicking its name:


.. image:: img/visual_script14.png


To edit the "arguments" this function can get (the values you pass to it when you call this function),
simply click the Function node and check the inspector:

.. image:: img/visual_script15.png


More on that will be explained later in this document.


===================================================
/. ./tutorials/scripting/visual_script/nodes_purposes.rst
===================================================

.. _doc_nodes_purposes_visual_script:

Nodes and terminology
=====================

Before continuing, it must be noted that the *Node* terminology needs to be used with care.
When referring to *Visual Script Nodes* (or generally *Nodes*) this text will refer to the little boxes you connect with lines, which are part of a graph.
When referring to *Scene Nodes*, it is implied that the elements that make up a Scene are being referred, which are part of a tree. Their naming is similar but their function is different.
When referring to *Node* here, it will be implied that a *Visual Script Node* is referred to unless indicated otherwise.

.. image:: img/visual_script16.png


Node properties
---------------

Like in most visual scripting implementations, each node has editable properties. In Godot, though, we try to avoid
bloating the nodes with editable controls for the sake of readability.

Nodes still display the required information as text, but editing is done via the *Inspector*. To edit them,
select any node and edit its properties in the *Inspector*.


Ports and connections
---------------------

Programming in Godot Visual Scripting is done via *Nodes* and *Port Connections* inside each function.


Ports
~~~~~

Nodes in Godot Visual Scripting have *Ports*. These are endpoints that appear to the
left and right of nodes and which can be used to make *Connections*:
There are two types of *Ports*: *Sequence* and *Data*.

.. image:: img/visual_script17.png


*Sequence Ports* indicate the order in which operations are executed.
Typically when a *Node* is done processing, it will go to the next node from one of the ports at the right.
If nothing is connected, the function may end, or another output *Sequence Port* might be tried (this depends on the node).
Thanks to this, you can follow the logic flow within a function by following the white lines.
Not every *Node* has *Sequence Ports*. In fact, most do not.

*Data Ports* ports contain typed values. Types can be any regular Godot types,
such as a boolean, an integer, a string, a Vector3, an array, any Object or Scene Node, etc.
A *Data Port* on the right side of a node is considered an output, while,
a port on the left side is an input. Connecting them allows information to flow to the next node.

Not all *Data Port* types are compatible and will allow connections, though.
Pay special attention to colors and icons, as each type has a different representation:

.. image:: img/visual_script18.png


Connections
~~~~~~~~~~~

Connecting is a relatively simple process. Drag an *Output Port* towards an *Input Port*.

.. image:: img/visual_script_connect.gif


Disconnecting takes a bit more practice. Disconnecting in *Data Ports* happens by
dragging the *Input* away, while for *Sequence Ports*, this happens by dragging the *Output* away.

.. image:: img/visual_script_disconnect.gif


This may seem strange at first, but it happens because *Data Ports* are 1:N
(A single output port can connect to many inputs), while *Sequence Ports* are N:1
(Many sequence outputs can be connected to a single input).

Connecting to empty space (drag to connect but unpress over empty space) is also context sensitive, it will supply
a list of most common operations. For sequences, it will be conditional nodes:

.. image:: img/visual_script52.png


While, for data, a contextual set/get/call menu will open:

.. image:: img/visual_script53.png


Adding nodes
------------

Finally! We got to the fun part! But, before explaining in more detail what each type of node does,
let's take a short look at how nodes are most commonly added and dealt with.


Accessing scene nodes
~~~~~~~~~~~~~~~~~~~~~

One of the most common tasks is accessing Scene Tree Nodes (again, not to mistake with *Visual Script Nodes*).
Dragging from the Scene Tree and dropping into the canvas will ask you to *call a method* (sometimes referred to as *member function*) on this node.

.. image:: img/visual_script19.png


While accessing properties is desired in most cases (more on that below), sometimes *calling methods* can be useful too.
Methods execute specific actions on objects. In the above case, the mouse pointer can be warped to a position in local
coordinates to the control. Another common use case is queueing a node for deletion, which is done with the *queue_free* method.

.. image:: img/visual_script20.png


Care must be taken that this only works if the scene being edited contains your *Visual Script* in one of the nodes! Otherwise, a warning will be shown.


Accessing scene node properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is the most common way to edit *Scene Nodes* in Visual Scripting. Select a *Scene Node* from the *Scene Tree*, go to the Inspector, find *the Name* of the property you want to edit (hint, *not* the value!) and drag it to the canvas:

.. image:: img/visual_script21.png


The result is that this value can be changed from your script by writing to a *Data Port*.

If instead reading this value is desired, drag the node again but hold :kbd:`Ctrl` (or :kbd:`Cmd` on macOS). This will create a getter:

.. image:: img/visual_script22.png


In this case, the value can be read from a *Data Port*.


Variables
~~~~~~~~~

Variables are memory containers local to the script which can hold a value. This value can be read from any of the functions of the script or from other scripts via the method described in the previous step.

To add a Variable, push the "+" button on the *Variables* section of the Members panel. Double-click the new variable to rename it:

.. image:: img/visual_script23.png


Right-clicking the variable allows you to configure its properties:

.. image:: img/visual_script24.png

.. image:: img/visual_script25.png


As it can be seen above, the type and initial value of the variable can be changed, as well as some property hints.
Ticking the "Export" option makes the variable visible in the Inspector when selecting the node. This also makes it available to other scripts via the method described in the previous step.

.. image:: img/visual_script28.png


To use the variable in the script, simply drag it to the canvas to create a getter:

.. image:: img/visual_script26.png


Likewise, hold :kbd:`Ctrl` (or :kbd:`Cmd` on macOS) to drop a setter:

.. image:: img/visual_script27.png


Signals
~~~~~~~

It is also possible to create your own signals in a script and use them. For this, do the same steps you did for variables in the previous step, except for *Signals*:

.. image:: img/visual_script29.png


A signal can also be edited via the right-click menu to customize its arguments:

.. image:: img/visual_script30.png


The signal you have created will appear in the Inspector, along with the built-in node signals. This allows you to connect it from another script from another *Scene Node*:

.. image:: img/visual_script31.png


Finally, to emit the signal, simply drag it to the canvas:

.. image:: img/visual_script32.png


Remember that emitting a signal is a sequenced operation, so it must come from a Sequence port.


Adding more nodes
-----------------

Now that the basics are covered, let's discuss the large amount of utility nodes available for your canvas!
Below the member panel, exists the list of all available node types:

.. image:: img/visual_script33.png


Pressing :kbd:`Ctrl + F` (or :kbd:`Cmd + F` on macOS) allows you to search the list.

Any of them can be dragged to the scene. Unlike nodes (e.g. dragging a property
from the Inspector sets the context to the node being edited automatically), these are added without any "contextual" information, so this has to be done manually.

.. image:: img/visual_script34.png


Remember that you can check the class reference for what each node does, as they are documented there. That mentioned,
a brief overview of node types follows:


Constants
~~~~~~~~~

Constant nodes are nodes that provide values that, while not changing over time, can be useful as reference values.
Most of the time they are integer or float.

.. image:: img/visual_script36.png


The first one is "Constant", which allows you to select any value of any type as constant, from an integer (42) to a String ("Hello!"). In general, this node is not used that often because of default input values in *Data Ports*, but it's good to know it exists.

The second is the GlobalConstant node, which contains a long list of constants for global types in Godot. In there
you can find some useful constants to refer to key names, joystick or mouse buttons, etc.

The third one is MathConstant, which provides typical mathematical constants, such as PI, E, etc.


Data
~~~~

Data nodes deal with all sorts of access to information. Any information in Godot is accessed via these nodes, so
they are some of the most important ones to use and pretty diverse.

.. image:: img/visual_script37.png


There are many types of nodes of interest here, so a short attempt to describe them will follow:


Action
^^^^^^

Action nodes are vital when dealing with input from a device. You can read more about actions in the (@TODO ACTION TUTE LINK).
In the following example below, the control is moved to the right when the "move_right" action is pressed.

.. image:: img/visual_script38.png


Engine Singleton
^^^^^^^^^^^^^^^^

Engine singletons are global interfaces (meaning they can be accessed without a reference; unlike Scene Nodes, they are always available).
They have several purposes, but in general, they are useful for low-level access or OS-related access.

.. image:: img/visual_script39.png


Remember that dragging a connection to empty space will help you call functions or set/get properties on these:

.. image:: img/visual_script40.png


Local Variables
^^^^^^^^^^^^^^^

These are nodes you can use as temporary storage for your graphs. Make sure they all have the same name and type when using them and they will reference the same piece of memory.

.. image:: img/visual_script41.png


As it can be seen above, there are two nodes available: A simple getter, and a sequenced setter (setting requires a sequence port).


Scene Node
^^^^^^^^^^

This is just a reference to a node in the tree, but it's easier to use this node by dragging the actual node
from the scene tree to the canvas (this will create it and configure it).


Self
^^^^

In some rare occasions, it may be desired to pass this Scene Node as argument.
It can be used to call functions and set/get properties, or drag nodes (or event the node itself that has the script) from the Scene Tree to the canvas for this.


SceneTree
^^^^^^^^^

This node is similar to the Singleton node because it references the SceneTree, which contains the active scene.
SceneTree, however, only works when the node is sitting in the scene and active, otherwise accessing it will
return an error.

SceneTree allows for many low-level things, like setting stretch options, calling groups, make timers, or even
load another scene. It's a good class to get familiar with.


Preload
^^^^^^^

This does the same function as preload() in GDScript. It maintains this resource loaded and ready to use. Rather than
instancing the node, it's simpler to drag the desired resource from the filesystem dock to the canvas.


Resource Path
^^^^^^^^^^^^^

This node is a simple helper to get a string with a path to a resource you can pick. It's useful in functions that
load things from disk.


Comment
^^^^^^^

A Comment node works as a node you can resize to put around other nodes. It will not try to get focus or be brought
to top when selecting it. It can also be used to write text on it.

.. image:: img/visual_script42.png


Flow Control
~~~~~~~~~~~~

Flow control nodes allow the execution to take different branches, usually depending on a
given condition.

.. image:: img/visual_script43.png


Condition
^^^^^^^^^

This is a simple node that checks a bool port. If ``true``, it will go via the "true" sequence port. If ``false``,
the second. After going for either of them, it goes via the "done" port. Leaving sequence
ports disconnected is fine if not all of them are used.


Iterator
^^^^^^^^

Some data types in Godot (ie, arrays, dictionaries) are iterable. This means that a bit of code can run
for each element that it has.

The Iterator node goes through all elements and, for each of them, it goes via the "each" sequence port,
making the element available in the "elem" data port.

When done, it goes via the "exit" sequence port.


Return
^^^^^^

Some functions can return values. In general for virtual ones, Godot will add the Return node for you.
A return node forces the function to end.


Sequence
^^^^^^^^

This node is useful mostly for organizing your graph. It calls its sequence ports in order.


TypeCast
^^^^^^^^

This is a useful and commonly used node. You can use it to cast arguments or other objects
to the type you desire. Afterwards, you can even drag the object output to get full completion.

.. image:: img/visual_script55.png


It is also possible to cast to a script, which will allow complete script properties and functions:

.. image:: img/visual_script54.png


Switch
^^^^^^

The Switch node is similar to the Condition node, but it matches many values at the same time.


While
^^^^^

This is a more primitive form of iteration. "repeat" sequence output will be called as long as
the condition in the "cond" data port is met.


Functions
~~~~~~~~~

Functions are simple helpers, most of the time deterministic. They take some arguments as
input and return an output. They are almost never sequenced.


Built-In
^^^^^^^^

There is a list of built-in helpers. The list is almost identical to the one from :ref:`GDScript<class_@GDScript>`. Most of them are mathematical functions, but others can be useful helpers. Make sure to take a look at the list
at some point.

By Type
^^^^^^^

Those are the methods available to basic types. For example, if you want a dot-product, you can search for "dot" instead of the Vector3 category.
In most cases just search the list of nodes, it should be faster.


Call
^^^^

This is the generic calling node. It is rarely used directly but by dragging to empty space on an already configured node.


Constructors
^^^^^^^^^^^^

These are all the functions needed to create Godot basic datatypes. For example, If you need to create a Vector3 out of 3 floats, a constructor must be used.

.. image:: img/visual_script44.png


Destructor
^^^^^^^^^^

This is the opposite to Constructor, it allows to separate any basic type (ie, Vector3) into its sub-elements.

.. image:: img/visual_script45.png


Emit Signal
^^^^^^^^^^^

Emits signals from any object. In general it's not that useful, as dragging a signal to the canvas works better.


Get/Set
^^^^^^^

Generic Getter/Setter node. Dragging properties from the Inspector works better, as they appear properly configured on drop.


Wait
^^^^

The Wait nodes will suspend execution of the function until something happens (many frames can pass until resuming, in fact).
Default nodes allow you to wait for a frame to pass, a fixed frame or a given amount of time until execution is resumed.


Yield
^^^^^

This node completely suspends the execution of the script, and it will make the function return a value that can be used to resume execution.


Yield Signal
^^^^^^^^^^^^

Same as Yield, but will wait until a given signal is emitted.


Index
~~~~~

Generic indexing operator, not often used but it's good that it exists just in case.


Operators
~~~~~~~~~

These are mostly generic operators, such as addition, multiplication, comparison, etc.
By default, these mostly accept any datatype (and will throw an error at run-time if the types
fed do not match those expected by the operator). It is always recommended to set the right
type for operators to catch errors faster and make the graph easier to read.

.. image:: img/visual_script46.png


Expression Node
^^^^^^^^^^^^^^^

Among the operators, the *Expression* node is the most powerful. If well used, it allows you to enormously simplify
visual scripts that are math or logic heavy. Type any expression on it and it will be executed in real-time.

Expression nodes can:

- Perform math and logic expressions based on custom inputs (eg: "a*5+b", where a and b are custom inputs):

.. image:: img/visual_script47.png


- Access local variables or properties:

.. image:: img/visual_script48.png


- Use most of the existing built-in functions that are available to GDScript, such as ``sin()``, ``cos()``, ``print()``, as well as constructors, such as ``Vector3(x, y, z)``, ``Rect2(...)``, etc.:

.. image:: img/visual_script49.png


- Call API functions:

.. image:: img/visual_script50.png


- Use sequenced mode, which makes more sense in case of respecting the processing order:

.. image:: img/visual_script51.png


===================================================
/. ./tutorials/scripting/visual_script/custom_visualscript_nodes.rst
===================================================

.. _doc_custom_visualscript_nodes:

Custom VisualScript nodes
=========================

.. warning::

    `Godot 4.0 will remove VisualScript from core entirely. <https://godotengine.org/article/godot-4-will-discontinue-visual-scripting>`__
    As a result, creating new projects using visual scripting in Godot is not recommended.
    Future Godot 4.x releases may have VisualScript reimplemented as an extension.

    While Godot 3.x will keep VisualScript supported, we recommend
    :ref:`trying out GDScript <toc-learn-scripting-gdscript>` instead,
    especially if you intend to migrate your project to Godot 4.

Custom nodes are written in GDScript and can then be used in VisualScript.
This is useful for offloading complex code to GDScript and reusing it.

Creating a custom node
----------------------

Create a new script that extends :ref:`class_VisualScriptCustomNode` and put a ``tool`` keyword at the top. This is needed for the script to run in the editor.

There are some functions that can be implemented to set parameters of the custom node.
Only add functions that are needed, a ``_has_input_sequence_port`` function is not necessary if it should return ``false`` for example.

The most important part of a custom node is the ``_step`` function. The logic of the node is defined there.

The ``inputs`` parameter holds the value of the input ports.

The ``outputs`` parameter is an array where the indices represent the output port ids. It can be modified to set the values of the output ports.

``start_mode`` can be checked to see if it is the first time ``_step`` is called.

``working_mem`` is persistent each ``_step`` call. It can be used to store information.

If you want to throw an error, for example if the input types are incorrect, you can return the error message as a string.
When everything goes right, return the id of the sequence port which should be called next. If your custom node doesn't have any, just return 0.


Example:

::

    tool
    extends VisualScriptCustomNode

    # The name of the custom node as it appears in the search.
    func _get_caption():
        return "Get Input Direction 2D"

    func _get_category():
        return "Input"

    # The text displayed after the input port / sequence arrow.
    func _get_text():
        return ""

    func _get_input_value_port_count():
        return 0

    # The types of the inputs per index starting from 0.
    func _get_input_value_port_type(idx):
        return TYPE_OBJECT

    func _get_output_value_port_count():
        return 1

    # The types of outputs per index starting from 0.
    func _get_output_value_port_type(idx):
        return TYPE_VECTOR2

    # The text displayed before each output node per index.
    func _get_output_value_port_name(idx):
        return "Direction"

    func _has_input_sequence_port():
        return true

    # The number of output sequence ports to use
    # (has to be at least one if you have an input sequence port).
    func _get_output_sequence_port_count():
        return 1

    func _step(inputs, outputs, start_mode, working_mem):
        # start_mode can be checked to see if it is the first time _step is called.
        # This is useful if you only want to do an operation once.

        # working_memory is persistent between _step calls.

        # The inputs array contains the value of the input ports.

        var x = int(Input.is_action_pressed("ui_right")) - int(Input.is_action_pressed("ui_left"))
        var y = int(Input.is_action_pressed("ui_down")) - int(Input.is_action_pressed("ui_up"))

        # The outputs array is used to set the data of the output ports.

        outputs[0] = Vector2(x, y)

        # Return the error string if an error occurred, else the id of the next sequence port.
        return 0

Using a custom node
-------------------

To use the script, add a ``CustomNode``, select it and drag your custom node script into the ``script`` property shown in the inspector.

.. image:: img/visual_script_custom_node_set_script.png

Result:

.. image:: img/visual_script_custom_node_result.png


===================================================
/. ./tutorials/scripting/c_sharp/index.rst
===================================================

C#
===

.. toctree::
   :maxdepth: 1
   :name: toc-learn-scripting-C#

   c_sharp_basics
   c_sharp_features
   c_sharp_differences
   c_sharp_style_guide


===================================================
/. ./tutorials/scripting/c_sharp/c_sharp_basics.rst
===================================================

.. _doc_c_sharp:

C# basics
=========

Introduction
------------

.. warning:: C# support is a new feature available since Godot 3.0.
             As such, you may still run into some issues, or find spots
             where the documentation could be improved.
             Please report issues with C# in Godot on the
             `engine GitHub page <https://github.com/godotengine/godot/issues>`_,
             and any documentation issues on the
             `documentation GitHub page <https://github.com/godotengine/godot-docs/issues>`_.

This page provides a brief introduction to C#, both what it is and
how to use it in Godot. Afterwards, you may want to look at
:ref:`how to use specific features <doc_c_sharp_features>`, read about the
:ref:`differences between the C# and the GDScript API <doc_c_sharp_differences>`
and (re)visit the :ref:`Scripting section <doc_scripting>` of the
step-by-step tutorial.

C# is a high-level programming language developed by Microsoft. In Godot,
it is implemented with the Mono 6.x .NET framework, including full support
for C# 8.0. Mono is an open source implementation of Microsoft's .NET Framework
based on the ECMA standards for C# and the Common Language Runtime.
A good starting point for checking its capabilities is the
`Compatibility <http://www.mono-project.com/docs/about-mono/compatibility/>`_
page in the Mono documentation.

.. note:: This is **not** a full-scale tutorial on the C# language as a whole.
        If you aren't already familiar with its syntax or features,
        see the
        `Microsoft C# guide <https://docs.microsoft.com/en-us/dotnet/csharp/index>`_
        or look for a suitable introduction elsewhere.

.. _doc_c_sharp_setup:

Setting up C# for Godot
-----------------------

Prerequisites
~~~~~~~~~~~~~

Install the latest stable version of the
`.NET SDK <https://dotnet.microsoft.com/download>`__, previously known as the
.NET Core SDK.

From Godot 3.2.3 onwards, installing Mono SDK is not a requirement anymore,
except it is required if you are building the engine from source.

Godot bundles the parts of Mono needed to run already compiled games.
However, Godot does not bundle the tools required to build and compile
games, such as MSBuild and the C# compiler. These are
included in the .NET SDK, which needs to be installed separately.

In summary, you must have installed the .NET SDK
**and** the Mono-enabled version of Godot.

Additional notes
~~~~~~~~~~~~~~~~

Be sure to install the 64-bit version of the SDK(s)
if you are using the 64-bit version of Godot.

If you are building Godot from source, install the latest stable version of
`Mono <https://www.mono-project.com/download/stable/>`__, and make sure to
follow the steps to enable Mono support in your build as outlined in the
:ref:`doc_compiling_with_mono` page.

Configuring an external editor
------------------------------

C# support in Godot's built-in script editor is minimal. Consider using an
external IDE or editor, such as  `Visual Studio Code <https://code.visualstudio.com/>`__
or MonoDevelop. These provide autocompletion, debugging, and other
useful features for C#. To select an external editor in Godot,
click on **Editor → Editor Settings** and scroll down to
**Mono**. Under **Mono**, click on **Editor**, and select your
external editor of choice. Godot currently supports the following
external editors:

- Visual Studio 2019
- Visual Studio Code
- MonoDevelop
- Visual Studio for Mac
- JetBrains Rider

See the following sections for how to configure an external editor:

JetBrains Rider
~~~~~~~~~~~~~~~

After reading the "Prerequisites" section, you can download and install
`JetBrains Rider <https://www.jetbrains.com/rider/download>`__.

In Godot's **Editor → Editor Settings** menu:

- Set **Mono** -> **Editor** -> **External Editor** to **JetBrains Rider**.
- Set **Mono** -> **Builds** -> **Build Tool** to **dotnet CLI**.

In Rider:

- Set **MSBuild version** to **.NET Core**.
- Install the **Godot support** plugin.

Visual Studio Code
~~~~~~~~~~~~~~~~~~

After reading the "Prerequisites" section, you can download and install
`Visual Studio Code <https://code.visualstudio.com/download>`__ (aka VS Code).

In Godot's **Editor → Editor Settings** menu:

- Set **Mono** -> **Editor** -> **External Editor** to **Visual Studio Code**.
- Set **Mono** -> **Builds** -> **Build Tool** to **dotnet CLI**.

In Visual Studio Code:

- Install the `C# <https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp>`__ extension.
- Install the `Mono Debug <https://marketplace.visualstudio.com/items?itemName=ms-vscode.mono-debug>`__ extension.
- Install the `C# Tools for Godot <https://marketplace.visualstudio.com/items?itemName=neikeq.godot-csharp-vscode>`__ extension.

.. note:: If you are using Linux you need to install the
          `Mono SDK <https://www.mono-project.com/download/stable/#download-lin>`__
          for the C# tools plugin to work.

To configure a project for debugging open the Godot project folder in VS Code.
Go to the Run tab and click on **Add Configuration...**. Select **C# Godot**
from the dropdown menu. Open the ``tasks.json`` and ``launch.json`` files that
were created. Change the executable setting in ``launch.json`` and  command
settings in ``tasks.json`` to your Godot executable path. Now, when you start
the debugger in VS Code, your Godot project will run.

Visual Studio (Windows only)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Download and install the latest version of
`Visual Studio <https://visualstudio.microsoft.com/downloads/>`__.
Visual Studio will include the required SDKs if you have the correct
workloads selected, so you don't need to manually install the things
listed in the "Prerequisites" section.

While installing Visual Studio, select these workloads:

- Mobile development with .NET
- .NET Core cross-platform development

In Godot's **Editor → Editor Settings** menu:

- Set **Mono** -> **Editor** -> **External Editor** to **Visual Studio**.
- Set **Mono** -> **Builds** -> **Build Tool** to **dotnet CLI**.

Next, you can download the Godot Visual Studio extension from github
`here <https://github.com/godotengine/godot-csharp-visualstudio/releases>`__.
Double click on the downloaded file and follow the installation process.

.. note:: The option to debug your game in Visual Studio may not appear after
          installing the extension. To enable debugging, there is a
          `workaround for Visual Studio 2019 <https://github.com/godotengine/godot-csharp-visualstudio/issues/10#issuecomment-720153256>`__.
          There is
          `a separate issue about this problem in Visual Studio 2022 <https://github.com/godotengine/godot-csharp-visualstudio/issues/28>`__.

.. note:: If you see an error like "Unable to find package Godot.NET.Sdk",
          your NuGet configuration may be incorrect and need to be fixed.

          A simple way to fix the NuGet configuration file is to regenerate it.
          In a file explorer window, go to ``%AppData%\NuGet``. Rename or delete
          the ``NuGet.Config`` file. When you build your Godot project again,
          the file will be automatically created with default values.

Creating a C# script
--------------------

After you successfully set up C# for Godot, you should see the following option
when selecting **Attach Script** in the context menu of a node in your scene:

.. image:: img/attachcsharpscript.png

Note that while some specifics change, most concepts work the same
when using C# for scripting. If you're new to Godot, you may want to follow
the tutorials on :ref:`doc_scripting` at this point.
While some places in the documentation still lack C# examples, most concepts
can be transferred easily from GDScript.

Project setup and workflow
--------------------------

When you create the first C# script, Godot initializes the C# project files
for your Godot project. This includes generating a C# solution (``.sln``)
and a project file (``.csproj``), as well as some utility files and folders
(``.mono`` and ``Properties/AssemblyInfo.cs``).
All of these but ``.mono`` are important and should be committed to your
version control system. ``.mono`` can be safely added to the ignore list of your VCS.
When troubleshooting, it can sometimes help to delete the ``.mono`` folder
and let it regenerate.

Example
-------

Here's a blank C# script with some comments to demonstrate how it works.

.. code-block:: csharp

    using Godot;
    using System;

    public class YourCustomClass : Node
    {
        // Member variables here, example:
        private int a = 2;
        private string b = "textvar";

        public override void _Ready()
        {
            // Called every time the node is added to the scene.
            // Initialization here.
            GD.Print("Hello from C# to Godot :)");
        }

        public override void _Process(float delta)
        {
            // Called every frame. Delta is time since the last frame.
            // Update game logic here.
        }
    }

As you can see, functions normally in global scope in GDScript like Godot's
``print`` function are available in the ``GD`` class which is part of
the ``Godot`` namespace. For a list of methods in the ``GD`` class, see the
class reference pages for
:ref:`@GDScript <class_@gdscript>` and :ref:`@GlobalScope <class_@globalscope>`.

.. note::
    Keep in mind that the class you wish to attach to your node should have the same
    name as the ``.cs`` file. Otherwise, you will get the following error
    and won't be able to run the scene:
    *"Cannot find class XXX for script res://XXX.cs"*

General differences between C# and GDScript
-------------------------------------------

The C# API uses ``PascalCase`` instead of ``snake_case`` in GDScript/C++.
Where possible, fields and getters/setters have been converted to properties.
In general, the C# Godot API strives to be as idiomatic as is reasonably possible.

For more information, see the :ref:`doc_c_sharp_differences` page.

.. warning::

    You need to (re)build the project assemblies whenever you want to see new
    exported variables or signals in the editor. This build can be manually
    triggered by clicking the word **Build** in the top right corner of the
    editor. You can also click **Mono** at the bottom of the editor window
    to reveal the Mono panel, then click the **Build Project** button.

    You will also need to rebuild the project assemblies to apply changes in
    "tool" scripts.

Current gotchas and known issues
--------------------------------

As C# support is quite new in Godot, there are some growing pains and things
that need to be ironed out. Below is a list of the most important issues
you should be aware of when diving into C# in Godot, but if in doubt, also
take a look over the official
`issue tracker for Mono issues <https://github.com/godotengine/godot/labels/topic%3Amono>`_.

- Writing editor plugins is possible, but it is currently quite convoluted.
- State is currently not saved and restored when hot-reloading,
  with the exception of exported variables.
- Attached C# scripts should refer to a class that has a class name
  that matches the file name.
- There are some methods such as ``Get()``/``Set()``, ``Call()``/``CallDeferred()``
  and signal connection method ``Connect()`` that rely on Godot's ``snake_case`` API
  naming conventions.
  So when using e.g. ``CallDeferred("AddChild")``, ``AddChild`` will not work because
  the API is expecting the original ``snake_case`` version ``add_child``. However, you
  can use any custom properties or methods without this limitation.


Exporting Mono projects is supported for desktop platforms (Linux, Windows and
macOS), Android, HTML5, and iOS. The only platform not supported yet is UWP.

Performance of C# in Godot
--------------------------

According to some preliminary `benchmarks <https://github.com/cart/godot3-bunnymark>`_,
the performance of C# in Godot — while generally in the same order of magnitude
— is roughly **~4×** that of GDScript in some naive cases. C++ is still
a little faster; the specifics are going to vary according to your use case.
GDScript is likely fast enough for most general scripting workloads.
C# is faster, but requires some expensive marshalling when talking to Godot.

Using NuGet packages in Godot
-----------------------------

`NuGet <https://www.nuget.org/>`_ packages can be installed and used with Godot,
as with any C# project. Many IDEs are able to add packages directly.
They can also be added manually by adding the package reference in
the ``.csproj`` file located in the project root:

.. code-block:: xml
    :emphasize-lines: 2

        <ItemGroup>
            <PackageReference Include="Newtonsoft.Json" Version="11.0.2" />
        </ItemGroup>
        ...
    </Project>

As of Godot 3.2.3, Godot automatically downloads and sets up newly added NuGet
packages the next time it builds the project.

Profiling your C# code
----------------------

- `Mono log profiler <https://www.mono-project.com/docs/debug+profile/profile/profiler/>`_ is available for Linux and macOS. Due to a Mono change, it does not work on Windows currently.
- External Mono profiler like `JetBrains dotTrace <https://www.jetbrains.com/profiler/>`_ can be used as described `here <https://github.com/godotengine/godot/pull/34382>`_.


===================================================
/. ./tutorials/scripting/c_sharp/c_sharp_features.rst
===================================================

.. _doc_c_sharp_features:

C# features
===========

This page provides an overview of the commonly used features of both C# and Godot
and how they are used together.

.. _doc_c_sharp_features_type_conversion_and_casting:

Type conversion and casting
---------------------------

C# is a statically typed language. Therefore, you can't do the following:

.. code-block:: csharp

    var mySprite = GetNode("MySprite");
    mySprite.SetFrame(0);

The method ``GetNode()`` returns a ``Node`` instance.
You must explicitly convert it to the desired derived type, ``Sprite`` in this case.

For this, you have various options in C#.

**Casting and Type Checking**

Throws ``InvalidCastException`` if the returned node cannot be cast to Sprite.
You would use it instead of the ``as`` operator if you are pretty sure it won't fail.

.. code-block:: csharp

    Sprite mySprite = (Sprite)GetNode("MySprite");
    mySprite.SetFrame(0);

**Using the AS operator**

The ``as`` operator returns ``null`` if the node cannot be cast to Sprite,
and for that reason, it cannot be used with value types.

.. code-block:: csharp

    Sprite mySprite = GetNode("MySprite") as Sprite;
    // Only call SetFrame() if mySprite is not null
    mySprite?.SetFrame(0);

**Using the generic methods**

Generic methods are also provided to make this type conversion transparent.

``GetNode<T>()`` casts the node before returning it. It will throw an ``InvalidCastException`` if the node cannot be cast to the desired type.

.. code-block:: csharp

    Sprite mySprite = GetNode<Sprite>("MySprite");
    mySprite.SetFrame(0);

``GetNodeOrNull<T>()`` uses the ``as`` operator and will return ``null`` if the node cannot be cast to the desired type.

.. code-block:: csharp

    Sprite mySprite = GetNodeOrNull<Sprite>("MySprite");
    // Only call SetFrame() if mySprite is not null
    mySprite?.SetFrame(0);

**Type checking using the IS operator**

To check if the node can be cast to Sprite, you can use the ``is`` operator.
The ``is`` operator returns false if the node cannot be cast to Sprite,
otherwise it returns true.

.. code-block:: csharp

    if (GetNode("MySprite") is Sprite)
    {
        // Yup, it's a sprite!
    }

For more advanced type checking, you can look into `Pattern Matching <https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching>`_.

.. _doc_c_sharp_signals:

C# signals
----------

For a complete C# example, see the **Handling a signal** section in the step by step :ref:`doc_scripting` tutorial.

Declaring a signal in C# is done with the ``[Signal]`` attribute on a delegate.

.. code-block:: csharp

    [Signal]
    delegate void MySignal();

    [Signal]
    delegate void MySignalWithArguments(string foo, int bar);

These signals can then be connected either in the editor or from code with ``Connect``.
If you want to connect a signal in the editor, you need to (re)build the project assemblies to see the new signal. This build can be manually triggered by clicking the “Build” button at the top right corner of the editor window.

.. code-block:: csharp

    public void MyCallback()
    {
        GD.Print("My callback!");
    }

    public void MyCallbackWithArguments(string foo, int bar)
    {
        GD.Print("My callback with: ", foo, " and ", bar, "!");
    }

    public void SomeFunction()
    {
        instance.Connect("MySignal", this, "MyCallback");
        instance.Connect(nameof(MySignalWithArguments), this, "MyCallbackWithArguments");
    }

Emitting signals is done with the ``EmitSignal`` method.

.. code-block:: csharp

    public void SomeFunction()
    {
        EmitSignal(nameof(MySignal));
        EmitSignal("MySignalWithArguments", "hello there", 28);
    }

Notice that you can always reference a signal name with the ``nameof`` keyword (applied on the delegate itself).

It is possible to bind values when establishing a connection by passing a Godot array.

.. code-block:: csharp

    public int Value { get; private set; } = 0;

    private void ModifyValue(int modifier)
    {
        Value += modifier;
    }

    public void SomeFunction()
    {
        var plusButton = (Button)GetNode("PlusButton");
        var minusButton = (Button)GetNode("MinusButton");

        plusButton.Connect("pressed", this, "ModifyValue", new Godot.Collections.Array { 1 });
        minusButton.Connect("pressed", this, "ModifyValue", new Godot.Collections.Array { -1 });
    }

Signals support parameters and bound values of all the `built-in types <https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/built-in-types-table>`_ and Classes derived from :ref:`Godot.Object <class_Object>`.
Consequently, any ``Node`` or ``Reference`` will be compatible automatically, but custom data objects will need to extend from `Godot.Object` or one of its subclasses.

.. code-block:: csharp

    public class DataObject : Godot.Object
    {
        public string Field1 { get; set; }
        public string Field2 { get; set; }
    }


Finally, signals can be created by calling ``AddUserSignal``, but be aware that it should be executed before any use of said signals (with ``Connect`` or ``EmitSignal``).

.. code-block:: csharp

    public void SomeFunction()
    {
        AddUserSignal("MyOtherSignal");
        EmitSignal("MyOtherSignal");
    }

Preprocessor defines
--------------------

Godot has a set of defines that allow you to change your C# code
depending on the environment you are compiling to.

.. note:: If you created your project before Godot 3.2, you have to modify
          or regenerate your `csproj` file to use this feature
          (compare ``<DefineConstants>`` with a new 3.2+ project).

Examples
~~~~~~~~

For example, you can change code based on the platform:

.. code-block:: csharp

        public override void _Ready()
        {
    #if GODOT_SERVER
            // Don't try to load meshes or anything, this is a server!
            LaunchServer();
    #elif GODOT_32 || GODOT_MOBILE || GODOT_WEB
            // Use simple objects when running on less powerful systems.
            SpawnSimpleObjects();
    #else
            SpawnComplexObjects();
    #endif
        }

Or you can detect which engine your code is in, useful for making cross-engine libraries:

.. code-block:: csharp

        public void MyPlatformPrinter()
        {
    #if GODOT
            GD.Print("This is Godot.");
    #elif UNITY_5_3_OR_NEWER
            print("This is Unity.");
    #else
            throw new InvalidWorkflowException("Only Godot and Unity are supported.");
    #endif
        }

Full list of defines
~~~~~~~~~~~~~~~~~~~~

* ``GODOT`` is always defined for Godot projects.

* One of ``GODOT_64`` or ``GODOT_32`` is defined depending on if the architecture is 64-bit or 32-bit.

* One of ``GODOT_X11``, ``GODOT_WINDOWS``, ``GODOT_OSX``,
  ``GODOT_ANDROID``, ``GODOT_IOS``, ``GODOT_HTML5``, or ``GODOT_SERVER``
  depending on the OS. These names may change in the future.
  These are created from the ``get_name()`` method of the
  :ref:`OS <class_OS>` singleton, but not every possible OS
  the method returns is an OS that Godot with Mono runs on.

When **exporting**, the following may also be defined depending on the export features:

* One of ``GODOT_PC``, ``GODOT_MOBILE``, or ``GODOT_WEB`` depending on the platform type.

* One of ``GODOT_ARM64_V8A`` or ``GODOT_ARMEABI_V7A`` on Android only depending on the architecture.

* One of ``GODOT_ARM64`` or ``GODOT_ARMV7`` on iOS only depending on the architecture.

* Any of ``GODOT_S3TC``, ``GODOT_ETC``, and ``GODOT_ETC2`` depending on the texture compression type.

* Any custom features added in the export menu will be capitalized and prefixed: ``foo`` -> ``GODOT_FOO``.

To see an example project, see the OS testing demo:
https://github.com/godotengine/godot-demo-projects/tree/master/misc/os_test


===================================================
/. ./tutorials/scripting/c_sharp/c_sharp_differences.rst
===================================================

.. _doc_c_sharp_differences:

C# API differences to GDScript
==============================

This is a (incomplete) list of API differences between C# and GDScript.

General differences
-------------------

As explained in the :ref:`doc_c_sharp`, C# generally uses ``PascalCase`` instead
of the ``snake_case`` used in GDScript and C++.

Global scope
------------

Global functions and some constants had to be moved to classes, since C#
does not allow declaring them in namespaces.
Most global constants were moved to their own enums.

Constants
^^^^^^^^^

Global constants were moved to their own enums.
For example, ``ERR_*`` constants were moved to the ``Error`` enum.

Special cases:

=======================  ===========================================================
GDScript                 C#
=======================  ===========================================================
``SPKEY``                ``GD.SpKey``
``TYPE_*``               ``Variant.Type`` enum
``OP_*``                 ``Variant.Operator`` enum
=======================  ===========================================================

Math functions
^^^^^^^^^^^^^^

Math global functions, like ``abs``, ``acos``, ``asin``, ``atan`` and ``atan2``, are
located under ``Mathf`` as ``Abs``, ``Acos``, ``Asin``, ``Atan`` and ``Atan2``.
The ``PI`` constant can be found as ``Mathf.Pi``.

Random functions
^^^^^^^^^^^^^^^^

Random global functions, like ``rand_range`` and ``rand_seed``, are located under ``GD``.
Example: ``GD.RandRange`` and ``GD.RandSeed``.

Other functions
^^^^^^^^^^^^^^^

Many other global functions like ``print`` and ``var2str`` are located under ``GD``.
Example: ``GD.Print`` and ``GD.Var2Str``.

Exceptions:

===========================  =======================================================
GDScript                     C#
===========================  =======================================================
``weakref(obj)``             ``Object.WeakRef(obj)``
``is_instance_valid(obj)``   ``Object.IsInstanceValid(obj)``
===========================  =======================================================

Tips
^^^^

Sometimes it can be useful to use the ``using static`` directive. This directive allows
to access the members and nested types of a class without specifying the class name.

Example:

.. code-block:: csharp

    using static Godot.GD;

    public class Test
    {
        static Test()
        {
            Print("Hello"); // Instead of GD.Print("Hello");
        }
    }

Export keyword
--------------

Use the ``[Export]`` attribute instead of the GDScript ``export`` keyword.
This attribute can also be provided with optional :ref:`PropertyHint<enum_@GlobalScope_PropertyHint>` and ``hintString`` parameters.
Default values can be set by assigning a value.

Example:

.. code-block:: csharp

    using Godot;

    public class MyNode : Node
    {
        [Export]
        private NodePath _nodePath;

        [Export]
        private string _name = "default";

        [Export(PropertyHint.Range, "0,100000,1000,or_greater")]
        private int _income;

        [Export(PropertyHint.File, "*.png,*.jpg")]
        private string _icon;
    }

Signal keyword
--------------

Use the ``[Signal]`` attribute to declare a signal instead of the GDScript ``signal`` keyword.
This attribute should be used on a `delegate`, whose name signature will be used to define the signal.

.. code-block:: csharp

    [Signal]
    delegate void MySignal(string willSendsAString);

See also: :ref:`doc_c_sharp_signals`.

`onready` keyword
-----------------

GDScript has the ability to defer the initialization of a member variable until the ready function
is called with `onready` (cf. :ref:`doc_gdscript_onready_keyword`).
For example:

.. code-block:: gdscript

    onready var my_label = get_node("MyLabel")

However C# does not have this ability. To achieve the same effect you need to do this.

.. code-block:: csharp

    private Label _myLabel;

    public override void _Ready()
    {
        _myLabel = GetNode<Label>("MyLabel");
    }

Singletons
----------

Singletons are available as static classes rather than using the singleton pattern.
This is to make code less verbose than it would be with an ``Instance`` property.

Example:

.. code-block:: csharp

    Input.IsActionPressed("ui_down")

However, in some very rare cases this is not enough. For example, you may want
to access a member from the base class ``Godot.Object``, like ``Connect``.
For such use cases we provide a static property named ``Singleton`` that returns
the singleton instance. The type of this instance is ``Godot.Object``.

Example:

.. code-block:: csharp

    Input.Singleton.Connect("joy_connection_changed", this, nameof(Input_JoyConnectionChanged));

String
------

Use ``System.String`` (``string``). Most of Godot's String methods are
provided by the ``StringExtensions`` class as extension methods.

Example:

.. code-block:: csharp

    string upper = "I LIKE SALAD FORKS";
    string lower = upper.ToLower();

There are a few differences, though:

* ``erase``: Strings are immutable in C#, so we cannot modify the string
  passed to the extension method. For this reason, ``Erase`` was added as an
  extension method of ``StringBuilder`` instead of string.
  Alternatively, you can use ``string.Remove``.
* ``IsSubsequenceOf``/``IsSubsequenceOfi``: An additional method is provided,
  which is an overload of ``IsSubsequenceOf``, allowing you to explicitly specify
  case sensitivity:

.. code-block:: csharp

  str.IsSubsequenceOf("ok"); // Case sensitive
  str.IsSubsequenceOf("ok", true); // Case sensitive
  str.IsSubsequenceOfi("ok"); // Case insensitive
  str.IsSubsequenceOf("ok", false); // Case insensitive

* ``Match``/``Matchn``/``ExprMatch``: An additional method is provided besides
  ``Match`` and ``Matchn``, which allows you to explicitly specify case sensitivity:

.. code-block:: csharp

  str.Match("*.txt"); // Case sensitive
  str.ExprMatch("*.txt", true); // Case sensitive
  str.Matchn("*.txt"); // Case insensitive
  str.ExprMatch("*.txt", false); // Case insensitive

Basis
-----

Structs cannot have parameterless constructors in C#. Therefore, ``new Basis()``
initializes all primitive members to their default value. Use ``Basis.Identity``
for the equivalent of ``Basis()`` in GDScript and C++.

The following method was converted to a property with a different name:

====================  ==============================================================
GDScript              C#
====================  ==============================================================
``get_scale()``       ``Scale``
====================  ==============================================================

Transform2D
-----------

Structs cannot have parameterless constructors in C#. Therefore, ``new Transform2D()``
initializes all primitive members to their default value.
Please use ``Transform2D.Identity`` for the equivalent of ``Transform2D()`` in GDScript and C++.

The following methods were converted to properties with their respective names changed:

====================  ==============================================================
GDScript              C#
====================  ==============================================================
``get_rotation()``    ``Rotation``
``get_scale()``       ``Scale``
====================  ==============================================================

Plane
-----

The following method was converted to a property with a *slightly* different name:

================  ==================================================================
GDScript          C#
================  ==================================================================
``center()``      ``Center``
================  ==================================================================

Rect2
-----

The following field was converted to a property with a *slightly* different name:

================  ==================================================================
GDScript          C#
================  ==================================================================
``end``           ``End``
================  ==================================================================

The following method was converted to a property with a different name:

================  ==================================================================
GDScript          C#
================  ==================================================================
``get_area()``    ``Area``
================  ==================================================================

Quat
----

Structs cannot have parameterless constructors in C#. Therefore, ``new Quat()``
initializes all primitive members to their default value.
Please use ``Quat.Identity`` for the equivalent of ``Quat()`` in GDScript and C++.

The following methods were converted to a property with a different name:

=====================  =============================================================
GDScript               C#
=====================  =============================================================
``length()``           ``Length``
``length_squared()``   ``LengthSquared``
=====================  =============================================================

Array
-----

*This is temporary. PoolArrays will need their own types to be used the way they are meant to.*

=====================  ==============================================================
GDScript               C#
=====================  ==============================================================
``Array``              ``Godot.Collections.Array``
``PoolIntArray``       ``int[]``
``PoolByteArray``      ``byte[]``
``PoolFloatArray``     ``float[]``
``PoolStringArray``    ``String[]``
``PoolColorArray``     ``Color[]``
``PoolVector2Array``   ``Vector2[]``
``PoolVector3Array``   ``Vector3[]``
=====================  ==============================================================

``Godot.Collections.Array<T>`` is a type-safe wrapper around ``Godot.Collections.Array``.
Use the ``Godot.Collections.Array<T>(Godot.Collections.Array)`` constructor to create one.

Dictionary
----------

Use ``Godot.Collections.Dictionary``.

``Godot.Collections.Dictionary<T>`` is a type-safe wrapper around ``Godot.Collections.Dictionary``.
Use the ``Godot.Collections.Dictionary<T>(Godot.Collections.Dictionary)`` constructor to create one.

Variant
-------

``System.Object`` (``object``) is used instead of ``Variant``.

Communicating with other scripting languages
--------------------------------------------

This is explained extensively in :ref:`doc_cross_language_scripting`.

Yield
-----

Something similar to GDScript's ``yield`` with a single parameter can be achieved with
C#'s `yield keyword <https://docs.microsoft.com/en-US/dotnet/csharp/language-reference/keywords/yield>`_.

The equivalent of yield on signal can be achieved with async/await and ``Godot.Object.ToSignal``.

Example:

.. code-block:: csharp

  await ToSignal(timer, "timeout");
  GD.Print("After timeout");

Other differences
-----------------

``preload``, as it works in GDScript, is not available in C#.
Use ``GD.Load`` or ``ResourceLoader.Load`` instead.

Other differences:

================  ==================================================================
GDScript          C#
================  ==================================================================
``Color8``        ``Color.Color8``
``is_inf``        ``float.IsInfinity``
``is_nan``        ``float.IsNaN``
``dict2inst``     TODO
``inst2dict``     TODO
================  ==================================================================


===================================================
/. ./tutorials/scripting/c_sharp/c_sharp_style_guide.rst
===================================================

.. _doc_c_sharp_styleguide:

C# style guide
==============

Having well-defined and consistent coding conventions is important for every project, and Godot
is no exception to this rule.

This page contains a coding style guide, which is followed by developers of and contributors to Godot
itself. As such, it is mainly intended for those who want to contribute to the project, but since
the conventions and guidelines mentioned in this article are those most widely adopted by the users
of the language, we encourage you to do the same, especially if you do not have such a guide yet.

.. note:: This article is by no means an exhaustive guide on how to follow the standard coding
        conventions or best practices. If you feel unsure of an aspect which is not covered here,
        please refer to more comprehensive documentation, such as
        `C# Coding Conventions <https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions>`_ or
        `Framework Design Guidelines <https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines>`_.

Language specification
----------------------

Godot currently uses **C# version 7.0** in its engine and example source code. So, before we move to
a newer version, care must be taken to avoid mixing language features only available in C# 7.1 or
later.

For detailed information on C# features in different versions, please see
`What's New in C# <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/>`_.

Formatting
----------

General guidelines
~~~~~~~~~~~~~~~~~~

* Use line feed (**LF**) characters to break lines, not CRLF or CR.
* Use one line feed character at the end of each file, except for `csproj` files.
* Use **UTF-8** encoding without a `byte order mark <https://en.wikipedia.org/wiki/Byte_order_mark>`_.
* Use **4 spaces** instead of tabs for indentation (which is referred to as "soft tabs").
* Consider breaking a line into several if it's longer than 100 characters.


Line breaks and blank lines
~~~~~~~~~~~~~~~~~~~~~~~~~~~

For a general indentation rule, follow `the "Allman Style" <https://en.wikipedia.org/wiki/Indentation_style#Allman_style>`_
which recommends placing the brace associated with a control statement on the next line, indented to
the same level:

.. code-block:: csharp

    // Use this style:
    if (x > 0)
    {
        DoSomething();
    }

    // NOT this:
    if (x > 0) {
        DoSomething();
    }

However, you may choose to omit line breaks inside brackets:

* For simple property accessors.
* For simple object, array, or collection initializers.
* For abstract auto property, indexer, or event declarations.

.. code-block:: csharp

    // You may put the brackets in a single line in following cases:
    public interface MyInterface
    {
        int MyProperty { get; set; }
    }

    public class MyClass : ParentClass
    {
        public int Value
        {
            get { return 0; }
            set
            {
                ArrayValue = new [] {value};
            }
        }
    }

Insert a blank line:

* After a list of ``using`` statements.
* Between method, properties, and inner type declarations.
* At the end of each file.

Field and constant declarations can be grouped together according to relevance. In that case, consider
inserting a blank line between the groups for easier reading.

Avoid inserting a blank line:

* After ``{``, the opening brace.
* Before ``}``, the closing brace.
* After a comment block or a single-line comment.
* Adjacent to another blank line.

.. code-block:: csharp

    using System;
    using Godot;
                                              // Blank line after `using` list.
    public class MyClass
    {                                         // No blank line after `{`.
        public enum MyEnum
        {
            Value,
            AnotherValue                      // No blank line before `}`.
        }
                                              // Blank line around inner types.
        public const int SomeConstant = 1;
        public const int AnotherConstant = 2;

        private Vector3 _x;                  // Related constants or fields can be
        private Vector3 _y;                  // grouped together.

        private float _width;
        private float _height;

        public int MyProperty { get; set; }
                                              // Blank line around properties.
        public void MyMethod()
        {
            // Some comment.
            AnotherMethod();                  // No blank line after a comment.
        }
                                              // Blank line around methods.
        public void AnotherMethod()
        {
        }
    }


Using spaces
~~~~~~~~~~~~

Insert a space:

* Around a binary and tertiary operator.
* Between an opening parenthesis and ``if``, ``for``, ``foreach``, ``catch``, ``while``, ``lock`` or ``using`` keywords.
* Before and within a single line accessor block.
* Between accessors in a single line accessor block.
* After a comma which is not at the end of a line.
* After a semicolon in a ``for`` statement.
* After a colon in a single line ``case`` statement.
* Around a colon in a type declaration.
* Around a lambda arrow.
* After a single-line comment symbol (``//``), and before it if used at the end of a line.

Do not use a space:

* After type cast parentheses.
* Within single line initializer braces.

The following example shows a proper use of spaces, according to some of the above mentioned conventions:

.. code-block:: csharp

    public class MyClass<A, B> : Parent<A, B>
    {
        public float MyProperty { get; set; }

        public float AnotherProperty
        {
            get { return MyProperty; }
        }

        public void MyMethod()
        {
            int[] values = {1, 2, 3, 4}; // No space within initializer brackets.
            int sum = 0;

            // Single line comment.
            for (int i = 0; i < values.Length; i++)
            {
                switch (i)
                {
                    case 3: return;
                    default:
                        sum += i > 2 ? 0 : 1;
                        break;
                }
            }

            i += (int)MyProperty; // No space after a type cast.
        }
    }

Naming conventions
------------------

Use **PascalCase** for all namespaces, type names and member level identifiers (i.e. methods, properties,
constants, events), except for private fields:

.. code-block:: csharp

    namespace ExampleProject
    {
        public class PlayerCharacter
        {
            public const float DefaultSpeed = 10f;

            public float CurrentSpeed { get; set; }

            protected int HitPoints;

            private void CalculateWeaponDamage()
            {
            }
        }
    }

Use **camelCase** for all other identifiers (i.e. local variables, method arguments), and use
an underscore (``_``) as a prefix for private fields (but not for methods or properties, as explained above):

.. code-block:: csharp

    private Vector3 _aimingAt; // Use a `_` prefix for private fields.

    private void Attack(float attackStrength)
    {
        Enemy targetFound = FindTarget(_aimingAt);

        targetFound?.Hit(attackStrength);
    }

There's an exception with acronyms which consist of two letters, like ``UI``, which should be written in
uppercase letters where PascalCase would be expected, and in lowercase letters otherwise.

Note that ``id`` is **not** an acronym, so it should be treated as a normal identifier:

.. code-block:: csharp

    public string Id { get; }

    public UIManager UI
    {
        get { return uiManager; }
    }

It is generally discouraged to use a type name as a prefix of an identifier, like ``string strText``
or ``float fPower``, for example. An exception is made, however, for interfaces, which
**should**, in fact, have an uppercase letter ``I`` prefixed to their names, like ``IInventoryHolder`` or ``IDamageable``.

Lastly, consider choosing descriptive names and do not try to shorten them too much if it affects
readability.

For instance, if you want to write code to find a nearby enemy and hit it with a weapon, prefer:

.. code-block:: csharp

    FindNearbyEnemy()?.Damage(weaponDamage);

Rather than:

.. code-block:: csharp

    FindNode()?.Change(wpnDmg);

Member variables
----------------

Don't declare member variables if they are only used locally in a method, as it
makes the code more difficult to follow. Instead, declare them as local
variables in the method's body.

Local variables
---------------

Declare local variables as close as possible to their first use. This makes it
easier to follow the code, without having to scroll too much to find where the
variable was declared.

Implicitly typed local variables
--------------------------------

Consider using implicitly typing (``var``) for declaration of a local variable, but do so
**only when the type is evident** from the right side of the assignment:

.. code-block:: csharp

    // You can use `var` for these cases:

    var direction = new Vector2(1, 0);

    var value = (int)speed;

    var text = "Some value";

    for (var i = 0; i < 10; i++)
    {
    }

    // But not for these:

    var value = GetValue();

    var velocity = direction * 1.5;

    // It's generally a better idea to use explicit typing for numeric values, especially with
    // the existence of the `real_t` alias in Godot, which can either be double or float
    // depending on the build configuration.

    var value = 1.5;

Other considerations
--------------------

 * Use explicit access modifiers.
 * Use properties instead of non-private fields.
 * Use modifiers in this order:
   ``public``/``protected``/``private``/``internal``/``virtual``/``override``/``abstract``/``new``/``static``/``readonly``.
 * Avoid using fully-qualified names or ``this.`` prefix for members when it's not necessary.
 * Remove unused ``using`` statements and unnecessary parentheses.
 * Consider omitting the default initial value for a type.
 * Consider using null-conditional operators or type initializers to make the code more compact.
 * Use safe cast when there is a possibility of the value being a different type, and use direct cast otherwise.


===================================================
/. ./tutorials/scripting/gdnative/index.rst
===================================================

GDNative
========

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-gdnative

   what_is_gdnative
   gdnative_c_example
   gdnative_cpp_example


===================================================
/. ./tutorials/scripting/gdnative/what_is_gdnative.rst
===================================================

.. _doc_what_is_gdnative:

What is GDNative?
=================

Introduction
------------

**GDNative** is a Godot-specific technology that lets the engine interact with
native `shared libraries <https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries>`__
at run-time. You can use it to run native code without compiling it with the engine.

.. note:: GDNative is *not* a scripting language and has no relation to
          :ref:`GDScript <doc_gdscript>`.

Differences between GDNative and C++ modules
--------------------------------------------

You can use both GDNative and :ref:`C++ modules <doc_custom_modules_in_c++>` to
run C or C++ code in a Godot project.

They also both allow you to integrate third-party libraries into Godot. The one
you should choose depends on your needs.

Advantages of GDNative
^^^^^^^^^^^^^^^^^^^^^^

Unlike modules, GDNative doesn't require compiling the engine's source code,
making it easier to distribute your work. It gives you access to most of the API
available to GDScript C#, allowing you to code game logic with full control
regarding performance. It's ideal if you need high-performance code you'd like
to distribute as an add-on in the :ref:`asset library <doc_what_is_assetlib>`.

Also:

- GDNative is not limited to C and C++. Thanks to :ref:`third-party bindings
  <doc_what_is_gdnative_third_party_bindings>`, you can use it with many other
  languages.
- You can use the same compiled GDNative library in the editor and exported
  project. With C++ modules, you have to recompile all the export templates you
  plan to use if you require its functionality at run-time.
- GDNative only requires you to compile your library, not the whole engine.
  That's unlike C++ modules, which are statically compiled into the engine.
  Every time you change a module, you need to recompile the engine. Even with
  incremental builds, this process is slower than using GDNative.

Advantages of C++ modules
^^^^^^^^^^^^^^^^^^^^^^^^^

We recommend :ref:`C++ modules <doc_custom_modules_in_c++>` in cases where
GDNative isn't enough:

- C++ modules provide deeper integration into the engine. GDNative's access is
  limited to what the scripting API exposes.
- You can use C++ modules to provide additional features in a project without
  carrying native library files around. This extends to exported projects.
- C++ modules are supported on all platforms. In contrast, GDNative has only
  limited support on HTML5 (cannot be used together with multi-threading), and
  is not supported on Universal Windows Platform (UWP).
- C++ modules can be faster than GDNative, especially when the code requires a
  lot of communication through the scripting API.

Supported languages
-------------------

The Godot developers officially support the following language bindings for
GDNative:

- C++ :ref:`(tutorial) <doc_gdnative_cpp_example>`
- C :ref:`(tutorial) <doc_gdnative_c_example>`

.. note::

    There are no plans to support additional languages with GDNative officially.
    That said, the community offers several bindings for other languages (see
    below).

.. _doc_what_is_gdnative_third_party_bindings:

The bindings below are developed and maintained by the community:

.. Binding developers: Feel free to open a pull request to add your binding if it's well-developed enough to be used in a project.
.. Please keep languages sorted in alphabetical order.

- `D <https://github.com/godot-d/godot-d>`__
- `Kotlin <https://github.com/utopia-rise/godot-kotlin-jvm>`__
- `Nim <https://github.com/pragmagic/godot-nim>`__
- `Python <https://github.com/touilleMan/godot-python>`__
- `Rust <https://github.com/godot-rust/godot-rust>`__

.. note::

    Not all bindings mentioned here may be production-ready. Make sure to
    research options thoroughly before starting a project with one of those.
    Also, double-check whether the binding is compatible with the Godot version
    you're using.

Version compatibility
---------------------

:ref:`Unlike Godot itself <doc_release_policy>`, GDNative has stricter version
compatibility requirements as it relies on low-level *ptrcalls* to function.

GDNative add-ons compiled for a given Godot version are only guaranteed to work
with the same minor release series. For example, a GDNative add-on compiled for
Godot 3.4 will only work with Godot 3.4, 3.4.1, 3.4.2… but not Godot 3.3 or 3.5.


===================================================
/. ./tutorials/scripting/gdnative/gdnative_c_example.rst
===================================================

.. _doc_gdnative_c_example:

GDNative C example
==================

Introduction
------------

This tutorial will introduce you to the bare minimum required to create GDNative
modules. This should be your starting point into the world of GDNative.
Understanding the contents of this tutorial will help you in understanding all
that is to come after this.

Before we begin, you can download the source code to the example object we
describe below in the `GDNative-demos repository
<https://github.com/godotengine/gdnative-demos/tree/master/c/simple>`_.

This example project also contains a SConstruct file that makes compiling a
little easier, but in this tutorial we'll be doing things by hand to
understand the process.

:ref:`GDNative <class_GDNative>` can be used to create several types of
additions to Godot, using interfaces such as
:ref:`PluginScript <class_PluginScript>` or
:ref:`ARVRInterfaceGDNative <class_ARVRInterfaceGDNative>`. In this tutorial we
are going to look at creating a :ref:`NativeScript <class_NativeScript>`
module. NativeScript allows you to write logic in C or C++ in a similar fashion
as you would write a GDScript file. We'll be creating the C equivalent of this
GDScript:

::

    extends Reference

    var data

    func _ready():
        data = "World from GDScript!"

    func get_data():
        return data

Future tutorials will focus on the other types of GDNative modules and explain
when and how to use each of them.

Prerequisites
-------------

Before we start you'll need a few things:

1) A Godot executable for your target version.
2) A C compiler. On Linux, install ``gcc`` or ``clang`` from your package
   manager. On macOS, you can install Xcode from the Mac App Store. On Windows,
   you can use Visual Studio 2015 or later, or MinGW-w64.
3) A Git clone of the `godot-headers
   repository <https://github.com/godotengine/godot-headers.git>`_: these are
   the C headers for Godot's public API exposed to GDNative.

For the latter, we suggest that you create a dedicated folder for this GDNative
example project, open a terminal in that folder and execute:

.. code-block:: none

    git clone https://github.com/godotengine/godot-headers.git --branch=3.4

This will download the required files into that folder.

.. tip::

    If you plan to use Git for your GDNative project, you can also add
    ``godot-headers`` as a Git submodule.

.. note::

    The ``godot-headers`` repository has different branches. As Godot evolves,
    so does GDNative. While we try to preserve compatibility between version,
    you should always build your GDNative module against headers matching the
    Godot stable branch (e.g. ``3.4``) and ideally actual release (e.g.
    ``3.4.4-stable``) that you use.
    GDNative modules built against older versions of the Godot headers *may*
    work with newer versions of the engine, but not the other way around.

The ``master`` branch of the ``godot-headers`` repository is kept in line with
the ``master`` branch of Godot and thus contains the GDNative class and
structure definitions that will work with the latest development builds.

If you want to write a GDNative module for a stable version of Godot, look at
the available Git tags (with ``git tags``) for the one matching your engine
version. In the ``godot-headers`` repository, such tags are prefixed with
``godot-``, so you can e.g. checkout the ``godot-3.4.4-stable`` tag for use with
Godot 3.4.4. In your cloned repository, you can do:

.. code-block:: none

    git checkout godot-3.4.4-stable

If a tag matching your stable release is missing for any reason, you can fall
back to the matching stable branch (e.g. ``3.4``), which you would also check
out with ``git checkout 3.4``.

If you are building Godot from source with your own changes that impact
GDNative, you can find the updated class and structure definition in
``<godotsource>/modules/gdnative/include``

Our C source
------------

Let's start by writing our main code. Eventually, we want to end up with a file
structure that looks along those lines:

.. code-block:: none

    + <your development folder>
      + godot-headers
        - <lots of files here>
      + simple
        + bin
          - libsimple.dll/so/dylib
          - libsimple.gdnlib
          - simple.gdns
        main.tscn
        project.godot
      + src
        - simple.c

Open up Godot and create a new project called "simple" alongside your
``godot-headers`` Git clone. This will create the ``simple`` folder and
``project.godot`` file. Then manually create a ``src`` folder alongside the
``simple`` folder, and a ``bin`` subfolder in the ``simple`` folder.

We're going to start by having a look at what our ``simple.c`` file contains.
Now, for our example here we're making a single C source file without a header
to keep things simple. Once you start writing bigger projects it is advisable
to break your project up into multiple files. That however falls outside of the
scope of this tutorial.

We'll be looking at the source code bit by bit so all the parts below should all
be put together into one big file. Each section will be explained as we add it.

.. code-block:: C

    #include <gdnative_api_struct.gen.h>

    #include <string.h>

    const godot_gdnative_core_api_struct *api = NULL;
    const godot_gdnative_ext_nativescript_api_struct *nativescript_api = NULL;

The above code includes the GDNative API struct header and a standard header
that we will use further down for string operations.
It then defines two pointers to two different structs. GDNative supports a large
collection of functions for calling back into the main Godot executable. In
order for your module to have access to these functions, GDNative provides your
application with a struct containing pointers to all these functions.

To keep this implementation modular and easily extendable, the core functions
are available directly through the "core" API struct, but additional functions
have their own "GDNative structs" that are accessible through extensions.

In our example, we access one of these extension to gain access to the functions
specifically needed for NativeScript.

A NativeScript behaves like any other script in Godot. Because the NativeScript
API is rather low level, it requires the library to specify many things more
verbosely than other scripting systems, such as GDScript. When a NativeScript
instance gets created, a library-given constructor gets called. When that
instance gets destroyed, the given destructor will be executed.

.. code-block:: C

    void *simple_constructor(godot_object *p_instance, void *p_method_data);
    void simple_destructor(godot_object *p_instance, void *p_method_data, void *p_user_data);
    godot_variant simple_get_data(godot_object *p_instance, void *p_method_data,
            void *p_user_data, int p_num_args, godot_variant **p_args);

These are forward declarations for the functions we'll be implementing for our
object. A constructor and destructor is needed. Additionally, the object will
have a single method called ``get_data``.

Next up is the first of the entry points Godot will call when our dynamic
library is loaded. These methods are all prefixed with ``godot_`` (you can
change this later on) followed by their name. ``gdnative_init`` is a function
that initializes our dynamic library. Godot will give it a pointer to a
structure that contains various bits of information we may find useful among
which the pointers to our API structures.

For any additional API structures we need to loop through our extensions array
and check the type of extension.

.. code-block:: C

    void GDN_EXPORT godot_gdnative_init(godot_gdnative_init_options *p_options) {
        api = p_options->api_struct;

        // Now find our extensions.
        for (int i = 0; i < api->num_extensions; i++) {
            switch (api->extensions[i]->type) {
                case GDNATIVE_EXT_NATIVESCRIPT: {
                    nativescript_api = (godot_gdnative_ext_nativescript_api_struct *)api->extensions[i];
                }; break;
                default: break;
            }
        }
    }

Next up is ``gdnative_terminate`` which is called before the library is
unloaded. Godot will unload the library when no object uses it anymore. Here,
you can do any cleanup you may need to do. For our example, we're simply going
to clear our API pointers.

.. code-block:: C

    void GDN_EXPORT godot_gdnative_terminate(godot_gdnative_terminate_options *p_options) {
        api = NULL;
        nativescript_api = NULL;
    }

Finally, we have ``nativescript_init`` which is the most important function we'll
need today. This function will be called by Godot as part of loading a GDNative
library and communicates back to the engine what objects we make available.

.. code-block:: C

    void GDN_EXPORT godot_nativescript_init(void *p_handle) {
        godot_instance_create_func create = { NULL, NULL, NULL };
        create.create_func = &simple_constructor;

        godot_instance_destroy_func destroy = { NULL, NULL, NULL };
        destroy.destroy_func = &simple_destructor;

        nativescript_api->godot_nativescript_register_class(p_handle, "SIMPLE", "Reference",
                create, destroy);

        godot_instance_method get_data = { NULL, NULL, NULL };
        get_data.method = &simple_get_data;

        godot_method_attributes attributes = { GODOT_METHOD_RPC_MODE_DISABLED };

        nativescript_api->godot_nativescript_register_method(p_handle, "SIMPLE", "get_data",
                attributes, get_data);
    }

We first tell the engine which classes are implemented by calling
``nativescript_register_class``. The first parameter here is the handle pointer
given to us. The second is the name of our object class. The third is the type
of object in Godot that we 'inherit' from; this is not true inheritance but it's
close enough. Finally, our fourth and fifth parameters are descriptions for our
constructor and destructor.

We then tell Godot about our methods (well our one method in this case), by
calling ``nativescript_register_method`` for each method of our class. In our
case, that is just ``get_data``. Our first parameter is yet again our handle
pointer. The second is again the name of the object class we're registering. The
third is the name of our function as it will be known to GDScript. The fourth is
our attributes setting (see ``godot_method_rpc_mode`` enum in
``godot-headers/nativescript/godot_nativescript.h`` for possible values). The
fifth and final parameter is a description of which function to call when the
method gets called.

The description struct ``instance_method`` contains the function pointer to the
function itself as first field. The other two fields in these structs are for
specifying per-method userdata. The second is the ``method_data`` field which is
passed on every function call as the ``p_method_data`` argument. This is useful
to reuse one function for different methods on possibly multiple different
script-classes. If the ``method_data`` value is a pointer to memory that needs
to be freed, the third ``free_func`` field can contain a pointer to a function
that will free that memory. That free function gets called when the script
itself (not instance!) gets unloaded (so usually at library-unload time).

Now, it's time to start working on the functions of our object. First, we define
a structure that we use to store the member data of an instance of our GDNative
class.

.. code-block:: C

    typedef struct user_data_struct {
        char data[256];
    } user_data_struct;

And then, we define our constructor. All we do in our constructor is allocate
memory for our structure and fill it with some data. Note that we use Godot's
memory functions so the memory gets tracked and then return the pointer to our
new structure. This pointer will act as our instance identifier in case multiple
objects are instantiated.

This pointer will be passed to any of our functions related to our object as a
parameter called ``p_user_data``, and can both be used to identify our instance
and to access its member data.

.. code-block:: C

    void *simple_constructor(godot_object *p_instance, void *p_method_data) {
        user_data_struct *user_data = api->godot_alloc(sizeof(user_data_struct));
        strcpy(user_data->data, "World from GDNative!");

        return user_data;
    }

Our destructor is called when Godot is done with our object and we free our
instances' member data.

.. code-block:: C

    void simple_destructor(godot_object *p_instance, void *p_method_data, void *p_user_data) {
        api->godot_free(p_user_data);
    }

And finally, we implement our ``get_data`` function. Data is always sent and
returned as variants so in order to return our data, which is a string, we first
need to convert our C string to a Godot string object, and then copy that string
object into the variant we are returning.

.. code-block:: C

    godot_variant simple_get_data(godot_object *p_instance, void *p_method_data,
            void *p_user_data, int p_num_args, godot_variant **p_args) {
        godot_string data;
        godot_variant ret;
        user_data_struct *user_data = (user_data_struct *)p_user_data;

        api->godot_string_new(&data);
        api->godot_string_parse_utf8(&data, user_data->data);
        api->godot_variant_new_string(&ret, &data);
        api->godot_string_destroy(&data);

        return ret;
    }

Strings are heap-allocated in Godot, so they have a destructor which frees the
memory. Destructors are named ``godot_TYPENAME_destroy``. When a Variant gets
created with a String, it references the String. That means that the original
String can be "destroyed" to decrease the ref-count. If that does not happen the
String memory will leak since the ref-count will never be zero and the memory
never deallocated. The returned variant gets automatically destroyed by Godot.

.. note::

    In more complex operations it can be confusing the keep track of which value
    needs to be deallocated and which does not. As a general rule: call
    ``godot_TYPENAME_destroy`` when a C++ destructor would be called instead.
    The String destructor would be called in C++ after the Variant was created,
    so the same is necessary in C.

The variant we return is destroyed automatically by Godot.

And that is the whole source code of our module.

Compiling
---------

We now need to compile our source code. As mentioned our example project on
GitHub contains a SCons configuration that does all the hard work for you, but
for our tutorial here we are going to call the compilers directly.

Assuming you are sticking to the folder structure suggested above, it is best to
open a terminal session in the ``src`` folder and execute the commands from
there. Make sure to create the ``bin`` folder before you proceed.

On Linux:

.. code-block:: none

    gcc -std=c11 -fPIC -c -I../godot-headers simple.c -o simple.o
    gcc -rdynamic -shared simple.o -o ../simple/bin/libsimple.so

On macOS:

.. code-block:: none

    clang -std=c11 -fPIC -c -I../godot-headers simple.c -o simple.os
    clang -dynamiclib simple.os -o ../simple/bin/libsimple.dylib

On Windows:

.. code-block:: none

    cl /Fosimple.obj /c simple.c /nologo -EHsc -DNDEBUG /MD /I. /I..\godot-headers
    link /nologo /dll /out:..\simple\bin\libsimple.dll /implib:..\simple\bin\libsimple.lib simple.obj

.. note::

    On the Windows build you also end up with a ``libsimple.lib`` library. This
    is a library that you can compile into a project to provide access to the
    DLL. We get it as a byproduct and we do not need it :)
    When exporting your game for release this file will be ignored.

Creating the GDNativeLibrary (``.gdnlib``) file
-----------------------------------------------

With our module compiled, we now need to create a corresponding
:ref:`GDNativeLibrary <class_GDNativeLibrary>` resource with ``.gdnlib``
extension which we place alongside our dynamic libraries. This file tells Godot
what dynamic libraries are part of our module and need to be loaded per
platform.

We can use Godot to generate this file, so open the "simple" project in the
editor.

Start by clicking the create resource button in the Inspector:

.. image:: img/new_resource.gif

And select ``GDNativeLibrary``:

.. image:: img/gdnativelibrary_resource.png

You should see a contextual editor appear in the bottom panel. Use the "Expand
Bottom Panel" button in the bottom right to expand it to full height:

.. image:: img/gdnativelibrary_editor.png

General properties
~~~~~~~~~~~~~~~~~~

In the Inspector, you have various properties to control loading the library.

If *Load Once* is enabled, our library is loaded only once and each individual
script that uses our library will use the same data. Any variable you define
globally will be accessible from any instance of your object you create. If
*Load Once* is disabled, a new copy of the library is loaded into memory each
time a script accesses the library.

If *Singleton* is enabled, our library is automatically loaded and a function
called ``godot_gdnative_singleton`` is called. We'll leave that for another
tutorial.

The *Symbol Prefix* is a prefix for our core functions, such as ``godot_`` in
``godot_nativescript_init`` seen earlier. If you use multiple GDNative libraries
that you wish to statically link, you will have to use different prefixes. This
again is a subject to dive into deeper in a separate tutorial, it is only needed
at this time for deployment to iOS as this platform does not like dynamic
libraries.

*Reloadable* defines whether the library should be reloaded when the editor
loses and gains focus, typically to pick up new or modified symbols from any
change made to the library externally.

Platform libraries
~~~~~~~~~~~~~~~~~~

The GDNativeLibrary editor plugin lets you configure two things for each
platform and architecture that you aim to support.

The *Dynamic Library* column (``entry`` section in the saved file) tells us for
each platform and feature combination which dynamic library has to be loaded.
This also informs the exporter which files need to be exported when exporting to
a specific platform.

The *Dependencies* column (also ``dependencies`` section) tells Godot what other
files need to be exported for each platform in order for our library to work.
Say that your GDNative module uses another DLL to implement functionality from a
3rd party library, this is where you list that DLL.

For our example, we only built libraries for Linux, macOS and/or Windows, so you
can link them in the relevant fields by clicking the folder button. If you built
all three libraries, you should have something like this:

.. image:: img/gdnativelibrary_editor_complete.png

Saving the resource
~~~~~~~~~~~~~~~~~~~

We can then save our GDNativeLibrary resource as ``bin/libsimple.gdnlib`` with
the Save button in the Inspector:

.. image:: img/gdnativelibrary_save.png

The file is saved in a text-based format and should have contents similar to
this:

.. code-block:: none

    [general]

    singleton=false
    load_once=true
    symbol_prefix="godot_"
    reloadable=true

    [entry]

    OSX.64="res://bin/libsimple.dylib"
    OSX.32="res://bin/libsimple.dylib"
    Windows.64="res://bin/libsimple.dll"
    X11.64="res://bin/libsimple.so"

    [dependencies]

    OSX.64=[  ]
    OSX.32=[  ]
    Windows.64=[  ]
    X11.64=[  ]

Creating the NativeScript (``.gdns``) file
------------------------------------------

With our ``.gdnlib`` file we've told Godot how to load our library, now we need
to tell it about our "SIMPLE" object class. We do this by creating a
:ref:`NativeScript <class_NativeScript>` resource file with ``.gdns`` extension.

Like done for the GDNativeLibrary resource, click the button to create a new
resource in the Inspector and select ``NativeScript``:

.. image:: img/nativescript_resource.png

The inspector will show a few properties that we need to fill. As *Class Name*
we enter "SIMPLE" which is the object class name that we declared in our C
source when calling ``godot_nativescript_register_class``. We also need to
select our ``.gdnlib`` file by clicking on *Library* and selecting *Load*:

.. image:: img/nativescript_library.png

.. note::

    The *Class Name* must have the same spelling as the one given in ``godot_nativescript_init``
    when registering the class.


Finally, click on the save icon and save this as ``bin/simple.gdns``:

.. image:: img/save_gdns.gif

Now it's time to build our scene. Add a Control node to your scene as your root
and call it ``main``. Then add a Button and a Label as child nodes. Place them
somewhere nice on screen and give your button a name.

.. image:: img/c_main_scene_layout.png

Select the control node and attach a script to it:

.. image:: img/add_main_script.gif

Next link up the ``pressed`` signal on the button to your script:

.. image:: img/connect_button_signal.gif

Don't forget to save your scene, call it ``main.tscn``.

Now we can implement our ``main.gd`` code:

::

    extends Control

    # load the Simple library
    onready var data = preload("res://bin/simple.gdns").new()

    func _on_Button_pressed():
        $Label.text = "Data = " + data.get_data()

After all that, our project should work. The first time you run it Godot will
ask you what your main scene is and you select your ``main.tscn`` file and
presto:

.. image:: img/c_sample_result.png


===================================================
/. ./tutorials/scripting/gdnative/gdnative_cpp_example.rst
===================================================

.. _doc_gdnative_cpp_example:

GDNative C++ example
====================

Introduction
------------

This tutorial builds on top of the information given in the
:ref:`GDNative C example <doc_gdnative_c_example>`, so we highly recommend you
read that first.

The C++ bindings for GDNative are built on top of the NativeScript GDNative API
and provide a nicer way to "extend" nodes in Godot using C++. This is equivalent
to writing scripts in GDScript, but in C++ instead.

You can download the full example we'll be creating in this tutorial `on
GitHub <https://github.com/BastiaanOlij/gdnative_cpp_example>`__.

Setting up the project
----------------------

There are a few prerequisites you'll need:

- a Godot 3.x executable,
- a C++ compiler,
- SCons as a build tool,
- a copy of the `godot-cpp
  repository <https://github.com/godotengine/godot-cpp>`__.

See also :ref:`Compiling <toc-devel-compiling>` as the build tools are identical
to the ones you need to compile Godot from source.

You can download these repositories from GitHub or let Git do the work for you.
Note that these repositories now have different branches for different versions
of Godot. GDNative modules written for an earlier version of Godot will work in
newer versions (with the exception of one breaking change in ARVR interfaces
between 3.0 and 3.1) but not vice versa so make sure you download the correct
branch. Also note that the version of Godot you use to generate the ``api.json``
with becomes your minimum version.

.. note::

    `GDExtension <https://godotengine.org/article/introducing-gd-extensions>`__
    has been merged in the ``master`` branch of godot-cpp,
    but it is only compatible with the upcoming Godot 4.0.
    Therefore, you need to use the ``3.x`` branch of godot-cpp to use GDNative
    and follow this example.

    This tutorial covers only GDNative in Godot 3.x, *not* GDExtension in Godot 4.0.

If you are versioning your project using Git, it is a good idea to add them as
Git submodules:

.. code-block:: none

    mkdir gdnative_cpp_example
    cd gdnative_cpp_example
    git init
    git submodule add -b 3.x https://github.com/godotengine/godot-cpp
    cd godot-cpp
    git submodule update --init

If you decide to just download the repositories or clone them into your project
folder, make sure to keep the folder layout identical to the one described here,
as much of the code we'll be showcasing here assumes the project follows this
layout.

Do make sure you clone recursive to pull in both repositories:

.. code-block:: none

    mkdir gdnative_cpp_example
    cd gdnative_cpp_example
    git clone --recursive -b 3.x https://github.com/godotengine/godot-cpp

.. note::

    ``godot-cpp`` now includes ``godot-headers`` as a nested submodule, if you've
    manually downloaded them please make sure to place ``godot-headers`` inside
    of the ``godot-cpp`` folder.

    You don't have to do it this way, but we've found it easiest to manage. If you
    decide to download the repositories or clone them into your folder,
    make sure to keep the folder layout the same as we've setup here. Much of
    the code we'll be showcasing here assumes the project has this layout.

If you cloned the example from the link specified in the introduction, the
submodules are not automatically initialized. You will need to execute the
following commands:

.. code-block:: none

    cd gdnative_cpp_example
    git submodule update --init --recursive

This will clone these two repositories into your project folder.

Building the C++ bindings
-------------------------

Now that we've downloaded our prerequisites, it is time to build the C++
bindings.

The repository contains a copy of the metadata for the current Godot release,
but if you need to build these bindings for a newer version of Godot, simply
call the Godot executable:

.. code-block:: none

    godot --gdnative-generate-json-api api.json

Place the resulting ``api.json`` file in the project folder and add
``use_custom_api_file=yes custom_api_file=../api.json`` to the scons command
below.

To generate and compile the bindings, use this command (replacing ``<platform>``
with ``windows``, ``linux`` or ``osx`` depending on your OS):

To speed up compilation, add `-jN` at the end of the SCons command line where `N`
is the number of CPU threads you have on your system. The example below uses 4 threads.

.. code-block:: none

    cd godot-cpp
    scons platform=<platform> generate_bindings=yes -j4
    cd ..

This step will take a while. When it is completed, you should have static
libraries that can be compiled into your project stored in ``godot-cpp/bin/``.

.. note::

    You may need to add ``bits=64`` to the command on Windows or Linux.

Creating a simple plugin
------------------------

Now it's time to build an actual plugin. We'll start by creating an empty Godot
project in which we'll place a few files.

Open Godot and create a new project. For this example, we will place it in a
folder called ``demo`` inside our GDNative module's folder structure.

In our demo project, we'll create a scene containing a Node called "Main" and
we'll save it as ``main.tscn``. We'll come back to that later.

Back in the top-level GDNative module folder, we're also going to create a
subfolder called ``src`` in which we'll place our source files.

You should now have ``demo``, ``godot-cpp``, ``godot-headers``, and ``src``
directories in your GDNative module.

In the ``src`` folder, we'll start with creating our header file for the
GDNative node we'll be creating. We will name it ``gdexample.h``:

.. code-block:: C++

    #ifndef GDEXAMPLE_H
    #define GDEXAMPLE_H

    #include <Godot.hpp>
    #include <Sprite.hpp>

    namespace godot {

    class GDExample : public Sprite {
        GODOT_CLASS(GDExample, Sprite)

    private:
        float time_passed;

    public:
        static void _register_methods();

        GDExample();
        ~GDExample();

        void _init(); // our initializer called by Godot

        void _process(float delta);
    };

    }

    #endif

There are a few things of note to the above. We're including ``Godot.hpp`` which
contains all our basic definitions. After that, we include ``Sprite.hpp`` which
contains bindings to the Sprite class. We'll be extending this class in our
module.

We're using the namespace ``godot``, since everything in GDNative is defined
within this namespace.

Then we have our class definition, which inherits from our Sprite through a
container class. We'll see a few side effects of this later on. The
``GODOT_CLASS`` macro sets up a few internal things for us.

After that, we declare a single member variable called ``time_passed``.

In the next block we're defining our methods, we obviously have our constructor
and destructor defined, but there are two other functions that will likely look
familiar to some, and one new method.

The first is ``_register_methods``, which is a static function that Godot will
call to find out which methods can be called on our NativeScript and which
properties it exposes. The second is our ``_process`` function, which will work
exactly the same as the ``_process`` function you're used to in GDScript. The
third is our ``_init`` function which is called after Godot has properly set up
our object. It has to exist even if you don't place any code in it.

Let's implement our functions by creating our ``gdexample.cpp`` file:

.. code-block:: C++

    #include "gdexample.h"

    using namespace godot;

    void GDExample::_register_methods() {
        register_method("_process", &GDExample::_process);
    }

    GDExample::GDExample() {
    }

    GDExample::~GDExample() {
        // add your cleanup here
    }

    void GDExample::_init() {
        // initialize any variables here
        time_passed = 0.0;
    }

    void GDExample::_process(float delta) {
        time_passed += delta;

        Vector2 new_position = Vector2(10.0 + (10.0 * sin(time_passed * 2.0)), 10.0 + (10.0 * cos(time_passed * 1.5)));

        set_position(new_position);
    }

This one should be straightforward. We're implementing each method of our class
that we defined in our header file. Note that the ``register_method`` call
**must** expose the ``_process`` method, otherwise Godot will not be able to use
it. However, we do not have to tell Godot about our constructor, destructor and
``_init`` functions.

The other method of note is our ``_process`` function, which simply keeps track
of how much time has passed and calculates a new position for our sprite using a
sine and cosine function. What stands out is calling
``owner->set_position`` to call one of the built-in methods of our Sprite. This
is because our class is a container class; ``owner`` points to the actual Sprite
node our script relates to.

There is one more C++ file we need; we'll name it ``gdlibrary.cpp``. Our
GDNative plugin can contain multiple NativeScripts, each with their own header
and source file like we've implemented ``GDExample`` up above. What we need now
is a small bit of code that tells Godot about all the NativeScripts in our
GDNative plugin.

.. code-block:: C++

    #include "gdexample.h"

    extern "C" void GDN_EXPORT godot_gdnative_init(godot_gdnative_init_options *o) {
        godot::Godot::gdnative_init(o);
    }

    extern "C" void GDN_EXPORT godot_gdnative_terminate(godot_gdnative_terminate_options *o) {
        godot::Godot::gdnative_terminate(o);
    }

    extern "C" void GDN_EXPORT godot_nativescript_init(void *handle) {
        godot::Godot::nativescript_init(handle);

        godot::register_class<godot::GDExample>();
    }

Note that we are not using the ``godot`` namespace here, since the three
functions implemented here need to be defined without a namespace.

The ``godot_gdnative_init`` and ``godot_gdnative_terminate`` functions get
called respectively when Godot loads our plugin and when it unloads it. All
we're doing here is parse through the functions in our bindings module to
initialize them, but you might have to set up more things depending on your
needs.

The important function is the third function called ``godot_nativescript_init``.
We first call a function in our bindings library that does its usual stuff.
After that, we call the function ``register_class`` for each of our classes in
our library.

Compiling the plugin
--------------------

We cannot easily write by hand a ``SConstruct`` file that SCons would use for
building. For the purpose of this example, just use
:download:`this hardcoded SConstruct file <files/cpp_example/SConstruct>` we've
prepared. We'll cover a more customizable, detailed example on how to use these
build files in a subsequent tutorial.

.. note::

    This ``SConstruct`` file was written to be used with the latest ``godot-cpp``
    master, you may need to make small changes using it with older versions or
    refer to the ``SConstruct`` file in the Godot 3.0 documentation.

Once you've downloaded the ``SConstruct`` file, place it in your GDNative module
folder besides ``godot-cpp``, ``godot-headers`` and ``demo``, then run:

.. code-block:: none

    scons platform=<platform>

You should now be able to find the module in ``demo/bin/<platform>``.

.. note::

    Here, we've compiled both godot-cpp and our gdexample library as debug
    builds. For optimized builds, you should compile them using the
    ``target=release`` switch.

Using the GDNative module
-------------------------

Before we jump back into Godot, we need to create two more files in
``demo/bin/``. Both can be created using the Godot editor, but it may be faster
to create them directly.

The first one is a file that lets Godot know what dynamic libraries should be
loaded for each platform and is called ``gdexample.gdnlib``.

.. code-block:: none

    [general]

    singleton=false
    load_once=true
    symbol_prefix="godot_"
    reloadable=false

    [entry]

    X11.64="res://bin/x11/libgdexample.so"
    Windows.64="res://bin/win64/libgdexample.dll"
    OSX.64="res://bin/osx/libgdexample.dylib"

    [dependencies]

    X11.64=[]
    Windows.64=[]
    OSX.64=[]

This file contains a ``general`` section that controls how the module is loaded.
It also contains a prefix section which should be left on ``godot_`` for now. If
you change this, you'll need to rename various functions that are used as entry
points. This was added for the iPhone platform because it doesn't allow dynamic
libraries to be deployed, yet GDNative modules are linked statically.

The ``entry`` section is the important bit: it tells Godot the location of the
dynamic library in the project's filesystem for each supported platform. It will
also result in *just* that file being exported when you export the project,
which means the data pack won't contain libraries that are incompatible with the
target platform.

Finally, the ``dependencies`` section allows you to name additional dynamic
libraries that should be included as well. This is important when your GDNative
plugin implements someone else's library and requires you to supply a
third-party dynamic library with your project.

If you double click on the ``gdexample.gdnlib`` file within Godot, you'll see
there are far more options to set:

.. image:: img/gdnative_library.png

The second file we need to create is a file used by each NativeScript we've
added to our plugin. We'll name it ``gdexample.gdns`` for our gdexample
NativeScript.

.. code-block:: none

    [gd_resource type="NativeScript" load_steps=2 format=2]

    [ext_resource path="res://bin/gdexample.gdnlib" type="GDNativeLibrary" id=1]

    [resource]

    resource_name = "gdexample"
    class_name = "GDExample"
    library = ExtResource( 1 )

This is a standard Godot resource; you could just create it directly in your
scene, but saving it to a file makes it much easier to reuse it in other places.
This resource points to our gdnlib file, so that Godot can know which dynamic
library contains our NativeScript. It also defines the ``class_name`` which
identifies the NativeScript in our plugin we want to use.

Time to jump back into Godot. We load up the main scene we created way back in
the beginning and now add a Sprite to our scene:

.. image:: img/gdnative_cpp_nodes.png

We're going to assign the Godot logo to this sprite as our texture, disable the
``centered`` property and drag our ``gdexample.gdns`` file onto the ``script``
property of the sprite:

.. image:: img/gdnative_cpp_sprite.png

We're finally ready to run the project:

.. image:: img/gdnative_cpp_animated.gif

Adding properties
-----------------

GDScript allows you to add properties to your script using the ``export``
keyword. In GDNative you have to register the properties and there are two ways
of doing this. You can either bind directly to a member or use a setter and
getter function.

.. note::

    There is a third option, just like in GDScript you can directly implement the
    ``_get_property_list``, ``_get`` and ``_set`` methods of an object but that
    goes far beyond the scope of this tutorial.

We'll examine both starting with the direct bind. Lets add a property that
allows us to control the amplitude of our wave.

In our ``gdexample.h`` file we simply need to add a member variable like so:

.. code-block:: C++

    ...
    private:
        float time_passed;
        float amplitude;
    ...

In our ``gdexample.cpp`` file we need to make a number of changes, we will only
show the methods we end up changing, don't remove the lines we're omitting:

.. code-block:: C++

    void GDExample::_register_methods() {
        register_method("_process", &GDExample::_process);
        register_property<GDExample, float>("amplitude", &GDExample::amplitude, 10.0);
    }

    void GDExample::_init() {
        // initialize any variables here
        time_passed = 0.0;
        amplitude = 10.0;
    }

    void GDExample::_process(float delta) {
        time_passed += delta;

        Vector2 new_position = Vector2(
            amplitude + (amplitude * sin(time_passed * 2.0)),
            amplitude + (amplitude * cos(time_passed * 1.5))
        );

        set_position(new_position);
    }

Once you compile the module with these changes in place, you will see that a
property has been added to our interface. You can now change this property and
when you run your project, you will see that our Godot icon travels along a
larger figure.

.. note::

    The ``reloadable`` property in the ``gdexample.gdnlib`` file must be set to
    ``true`` for the Godot editor to automatically pick up the newly added
    property.

    However, this setting should be used with care, especially when tool classes
    are used, as the editor might hold objects then that have script instances
    attached to them that are managed by a GDNative library.

Let's do the same but for the speed of our animation and use a setter and getter
function. Our ``gdexample.h`` header file again only needs a few more lines of
code:

.. code-block:: C++

    ...
        float amplitude;
        float speed;
    ...
        void _process(float delta);
        void set_speed(float p_speed);
        float get_speed();
    ...

This requires a few more changes to our ``gdexample.cpp`` file, again we're only
showing the methods that have changed so don't remove anything we're omitting:

.. code-block:: C++

    void GDExample::_register_methods() {
        register_method("_process", &GDExample::_process);
        register_property<GDExample, float>("amplitude", &GDExample::amplitude, 10.0);
        register_property<GDExample, float>("speed", &GDExample::set_speed, &GDExample::get_speed, 1.0);
    }

    void GDExample::_init() {
        // initialize any variables here
        time_passed = 0.0;
        amplitude = 10.0;
        speed = 1.0;
    }

    void GDExample::_process(float delta) {
        time_passed += speed * delta;

        Vector2 new_position = Vector2(
            amplitude + (amplitude * sin(time_passed * 2.0)),
            amplitude + (amplitude * cos(time_passed * 1.5))
        );

        set_position(new_position);
    }

    void GDExample::set_speed(float p_speed) {
        speed = p_speed;
    }

    float GDExample::get_speed() {
        return speed;
    }

Now when the project is compiled, we'll see another property called speed.
Changing its value will make the animation go faster or slower.

For this example, there is no obvious advantage of using a setter and getter.
A good reason for a setter would be if you wanted to react on the variable being changed.
If you don't need to do something like that, binding the variable is enough.

Getters and setters become far more useful in more complex scenarios where you
need to make additional choices based on the state of your object.

.. note::

    For simplicity, we've left out the optional parameters in the
    register_property<class, type> method call. These parameters are
    ``rpc_mode``, ``usage``, ``hint`` and ``hint_string``. These can be used to
    further configure how properties are displayed and set on the Godot side.

    Modern C++ compilers are able to infer the class and variable type and allow
    you to omit the ``<GDExample, float>`` part of our ``register_property``
    method. We've had mixed experiences with this however.

Signals
-------

Last but not least, signals fully work in GDNative as well. Having your module
react to a signal given out by another object requires you to call ``connect``
on that object. We can't think of a good example for our wobbling Godot icon, we
would need to showcase a far more complete example.

This is the required syntax:

.. code-block:: C++

    some_other_node->connect("the_signal", this, "my_method");

Note that you can only call ``my_method`` if you've previously registered it in
your ``_register_methods`` method.

Having your object sending out signals is more common. For our wobbling
Godot icon, we'll do something silly just to show how it works. We're going to
emit a signal every time a second has passed and pass the new location along.

In our ``gdexample.h`` header file, we need to define a new member ``time_emit``:

.. code-block:: C++

    ...
        float time_passed;
        float time_emit;
        float amplitude;
    ...

This time, the changes in ``gdexample.cpp`` are more elaborate. First,
you'll need to set ``time_emit = 0.0;`` in either our ``_init`` method or in our
constructor. We'll look at the other 2 needed changes one by one.

In our ``_register_methods`` method, we need to declare our signal. This is done
as follows:

.. code-block:: C++

    void GDExample::_register_methods() {
        register_method("_process", &GDExample::_process);
        register_property<GDExample, float>("amplitude", &GDExample::amplitude, 10.0);
        register_property<GDExample, float>("speed", &GDExample::set_speed, &GDExample::get_speed, 1.0);

        register_signal<GDExample>((char *)"position_changed", "node", GODOT_VARIANT_TYPE_OBJECT, "new_pos", GODOT_VARIANT_TYPE_VECTOR2);
    }

Here, our ``register_signal`` method can be a single call first taking the
signals name, then having pairs of values specifying the parameter name and
type of each parameter we'll send along with this signal.

Next, we'll need to change our ``_process`` method:

.. code-block:: C++

    void GDExample::_process(float delta) {
        time_passed += speed * delta;

        Vector2 new_position = Vector2(
            amplitude + (amplitude * sin(time_passed * 2.0)),
            amplitude + (amplitude * cos(time_passed * 1.5))
        );

        set_position(new_position);

        time_emit += delta;
        if (time_emit > 1.0) {
            emit_signal("position_changed", this, new_position);

            time_emit = 0.0;
        }
    }

After a second has passed, we emit our signal and reset our counter. We can add
our parameter values directly to ``emit_signal``.

Once the GDNative library is compiled, we can go into Godot and select our sprite
node. In the **Node** dock, we can find our new signal and link it up by pressing
the **Connect** button or double-clicking the signal. We've added a script on
our main node and implemented our signal like this:

.. code-block:: GDScript

    extends Node

    func _on_Sprite_position_changed(node, new_pos):
        print("The position of " + node.name + " is now " + str(new_pos))

Every second, we output our position to the console.

Next steps
----------

The above is only a simple example, but we hope it shows you the basics. You can
build upon this example to create full-fledged scripts to control nodes in Godot
using C++.

To edit and recompile the plugin while the Godot editor
remains open, re-run the project after the library has finished building.


===================================================
/. ./tutorials/scripting/debug/index.rst
===================================================

Debug
=====

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-debug

   overview_of_debugging_tools
   debugger_panel


===================================================
/. ./tutorials/scripting/debug/overview_of_debugging_tools.rst
===================================================

.. _doc_overview_of_debugging_tools:

Overview of debugging tools
===========================

This guide will give you an overview of the available debugging tools in the
engine.

Godot comes with a powerful debugger and profilers to track down bugs, inspect
your game at runtime, monitor essential metrics, and measure performances.
It also offers options to visualize collision boxes and navigation polygons
in the running game.

Finally, you have options to debug the game running on a remote device
and to reload changes to your scenes or your code while the game is running.

Debugger Panel
--------------

Many of Godot's debugging tools are part of the Debugger panel, which you can
find information about in :ref:`doc_debugger_panel`.

Debug menu options
------------------

There are a few common debug options you can toggle on or off when running
your game in the editor, which can help you in debugging your game.

You can find these options in the **Debug** editor menu.

.. image:: img/overview_debug.png

Here are the descriptions of the options:

Deploy with Remote Debug
++++++++++++++++++++++++

When exporting and deploying, the resulting executable will attempt to connect
to the IP of your computer for debugging.

Small Deploy with Network FS
++++++++++++++++++++++++++++

This option speeds up testing for games with a large footprint on remote devices.

When **Small Deploy with Network FS** is on, instead of exporting the full game,
deploying the game builds a minimal executable. The editor then provides files
from the project over the network.

Also, on Android, the game is deployed using the USB cable to speed up deployment.

Visible Collision Shapes
++++++++++++++++++++++++

This option makes collision shapes and raycast nodes visible in the running game.

Visible Navigation
++++++++++++++++++

Navigation meshes and polygons will be visible on the running game.

Sync Scene Changes
++++++++++++++++++

With this option, any change you make to a scene in the editor at runtime
appears instantly. When used remotely on a device, this is more efficient
with the network filesystem.

Sync Script Changes
+++++++++++++++++++

Any script that is saved will be reloaded on the running game. When used
remotely on a device, this is more efficient with the network filesystem.

Script editor debug tools and options
-------------------------------------

The script editor has its own set of debug tools for use with breakpoints and
two options. The breakpoint tools can also be found in the **Debugger** tab
of the debugger.

.. image:: img/overview_script_editor.png

The **Break** button causes a break in the script like a breakpoint would.
**Continue** makes the game continue after pausing at a breakpoint.
**Step Over** goes to the next line of code, and **Step Into** goes into
a function if possible. Otherwise, it does the same thing as **Step Over**.

The **Keep Debugger Open** option keeps the debugger open after a scene
has been closed. And the **Debug with External Editor** option lets you
debug your game with an external editor.

.. warning::

    Breakpoints won't break on code if it's
    :ref:`running in a thread <doc_using_multiple_threads>`.
    This is a current limitation of the GDScript debugger.

Debug project settings
----------------------

In the project settings, there is a **Debug** category with three subcategories
which control different things.

Settings
++++++++

These are some general settings such as printing the current FPS
to the **Output** panel, the maximum amount of functions when profiling
and others.

GDScript
++++++++

These settings allow you to toggle specific GDScript warnings, such as for
unused variables. You can also turn off warnings completely.

Shapes
++++++

Shapes are where you can adjust the color of shapes that only appear for
debugging purposes, such as collision and navigation shapes.

Remote in scene dock
--------------------

When running a game in the editor two options appear at the top of the **Scene**
dock, **Remote** and **Local**. While using **Remote** you can inspect or change
the nodes' parameters in the running project.

.. image:: img/overview_remote.png

.. note:: Some editor settings related to debugging can be found inside
          the **Editor Settings**, under the **Network > Debug** and **Debugger** sections.


===================================================
/. ./tutorials/scripting/debug/debugger_panel.rst
===================================================

.. _doc_debugger_panel:

Debugger panel
==============

Many of Godot's debugging tools, including the debugger, can be found in the
debugger panel at the bottom of the screen. Click on **Debugger** to open it.

.. image:: img/overview_debugger.png

The debugger panel is split into several tabs, each focusing on a specific task.

Debugger
++++++++

The Debugger tab opens automatically when the GDScript compiler reaches
a breakpoint in your code.

It gives you a `stack trace <https://en.wikipedia.org/wiki/Stack_trace>`__,
information about the state of the object, and buttons to control
the program's execution.

You can use the buttons in the top-right corner to:

- Skip all breakpoints. That way, you can save breakpoints for future
  debugging sessions.
- Copy the current error message.
- **Step Into** the code. This button takes you to the next line of code,
  and if it's a function, it steps line-by-line through the function.
- **Step Over** the code. This button goes to the next line of code,
  but it doesn't step line-by-line through functions.
- **Break**. This button pauses the game's execution.
- **Continue**. This button resumes the game after a breakpoint or pause.

.. warning::

    Breakpoints won't break on code if it's
    :ref:`running in a thread <doc_using_multiple_threads>`.
    This is a current limitation of the GDScript debugger.

Errors
++++++

This is where error and warning messages are printed while running the game.

You can disable specific warnings in **Project Settings > Debug > GDScript**.

Profiler
++++++++

The debugger comes with three profilers for your processor, network operations,
and video memory.

The profiler is used to show why individual frames take as long as they do
to process and render.

Unlike other debugging tools, the profiler does not start automatically. It can
be started at any time during gameplay by pressing the start button. You can
even start the profiler before opening the game to profile startup performance.
It can also be started and stopped while the game is running without losing
information from when it was last running. The information it records won't
go away unless you click clear, or close the game, reopen it and start
the profiler again.

After starting and stopping the profiler, you should see things being kept track
of on the left and a graph on the right. The items listed on the left are
everything that contributes to frame time, and they should each have a value
for time and calls for the current frame you are looking at.

The frame number in the top right tells you which frame you are currently
looking at. You can change this by using the up or down arrows, typing in the
frame number, or clicking on the graph.

If you want to add something to your graph or think it looks too cluttered,
you can check and uncheck the box next to an item to add or remove it
from the graph.

Network Profiler
++++++++++++++++

The Network Profiler contains a list of all the nodes that communicate over the
multiplayer API and, for each one, some counters on the amount of incoming and
outgoing network interactions. It also features a bandwidth meter that displays
the total bandwidth usage at any given moment.

Monitors
++++++++

The monitors are graphs of several aspects of the game while its running such as
FPS, memory usage, how many nodes are in a scene and more. All monitors keep
track of stats automatically, so even if one monitor isn't open while the game
is running, you can open it later and see how the values changed.

Video RAM
+++++++++

The **Video RAM** tab shows the video RAM usage of the game while it is running.
It provides a list of every resource using video RAM by resource path, the type
of resource it is, what format it is in, and how much Video RAM that resource is
using. There is also a total video RAM usage number at the top right of the panel.

.. image:: img/video_ram.png

Misc
++++

The **Misc** tab contains tools to identify the control nodes you are clicking
at runtime:

- **Clicked Control** tells you where the clicked node is in the scene tree.
- **Clicked Control Type** tells you the type of the node you clicked is.


===================================================
/. ./tutorials/scripting/idle_and_physics_processing.rst
===================================================

.. _doc_idle_and_physics_processing:

Idle and Physics Processing
===========================

Games run in a loop. Each frame, you need to update the state of your game world
before drawing it on screen. Godot provides two virtual methods in the Node
class to do so: :ref:`Node._process() <class_Node_method__process>` and
:ref:`Node._physics_process() <class_Node_method__physics_process>`. If you
define either or both in a script, the engine will call them automatically.

There are two types of processing available to you:

1. **Idle processing** allows you to run code that updates a node every frame,
   as often as possible.
2. **Physics processing** happens at a fixed rate, 60 times per second by
   default. This is independent of your game's actual framerate, and keeps physics
   running smoothly. You should use it for anything that involves the physics
   engine, like moving a body that collides with the environment.

You can activate idle processing by defining the ``_process()`` method in a
script. You can turn it off and back on by calling :ref:`Node.set_process()
<class_Node_method_set_process>`.

The engine calls this method every time it draws a frame:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _process(delta):
        # Do something...
        pass

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        // Do something...
    }

Keep in mind that the frequency at which the engine calls ``_process()`` depends
on your application's framerate, which varies over time and across devices.

The function's ``delta`` parameter is the time elapsed in seconds since the
previous call to ``_process()``. Use this parameter to make calculations
independent of the framerate. For example, you should always multiply a speed
value by ``delta`` to animate a moving object.

Physics processing works with a similar virtual function:
``_physics_process()``. Use it for calculations that must happen before each
physics step, like moving a character that collides with the game world. As
mentioned above, ``_physics_process()`` runs at fixed time intervals as much as
possible to keep the physics interactions stable. You can change the interval
between physics steps in the Project Settings, under Physics -> Common ->
Physics Fps. By default, it's set to run 60 times per second.

The engine calls this method every time it draws a frame:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _physics_process(delta):
        # Do something...
        pass

 .. code-tab:: csharp

    public override void _PhysicsProcess(float delta)
    {
        // Do something...
    }

The function ``_process()`` is not synchronized with physics. Its rate depends on
hardware and game optimization. It also runs after the physics step in
single-threaded games.

You can see the ``_process()`` function at work by creating a scene with a
single Label node, with the following script attached to it:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Label

    var time = 0

    func _process(delta):
        time += delta
        text = str(time) # 'text' is a built-in Label property.

 .. code-tab:: csharp

    public class CustomLabel : Label
    {
        private float _time;

        public override void _Process(float delta)
        {
            _time += delta;
            Text = _time.ToString(); // 'Text' is a built-in Label property.
        }
    }

When you run the scene, you should see a counter increasing each frame.


===================================================
/. ./tutorials/scripting/groups.rst
===================================================

.. _doc_groups:

Groups
======

Groups in Godot work like tags in other software. You can add a node to as many
groups as you want. Then, in code, you can use the SceneTree to:

- Get a list of nodes in a group.
- Call a method on all nodes in a group.
- Send a notification to all nodes in a group.

This is a useful feature to organize large scenes and decouple code.


Managing groups
---------------

Groups are created by adding a node to a new group name, and likewise they are
removed by removing all nodes from a given group.

There are two ways to add/remove nodes to groups:

- During design, by using the Node dock in the editor.
- During execution, by calling :ref:`Node.add_to_group() <class_Node_method_add_to_group>`
  or :ref:`Node.remove_from_group() <class_Node_method_remove_from_group>`.


Using the Node dock
~~~~~~~~~~~~~~~~~~~

You can add nodes in the current scene to groups using the Groups tab in the
Node dock.

.. image:: img/groups_node_tab.png

Select one or more nodes in the Scene dock and write the group name in the
field, then click Add.

.. image:: img/groups_add_node_to_group.png

You should now see the group appear.

.. image:: img/groups_node_after_adding.png

In a complex project, you may end up with many groups or large scenes with many
nodes. You can add or remove any node to groups using the Group Editor window.
To access it, click the Manage Groups button.

.. image:: img/groups_manage_groups_button.png

The Group Editor window appears. Here's a screenshot from a complex project to
illustrate the tool's purpose.

.. image:: img/groups_group_editor_window.png

It has three columns:

1. A list of groups used by nodes in the current scene.
2. A list of nodes that are not part of the selected group.
3. A list of nodes in the group.

The fields at the bottom allow you to add new groups or filter nodes in the
second and third columns.

.. note:: Any node name that's greyed out means the node was added to the group
          in a different scene and you cannot edit it here. This happens on
          scene instances in particular.

Using code
~~~~~~~~~~

You can also manage groups from scripts. The following code adds the node to
which you attach the script to the ``guards`` group as soon as it enters the
scene tree.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        add_to_group("guards")

 .. code-tab:: csharp

    public override void _Ready()
    {
        base._Ready();

        AddToGroup("guards");
    }

Imagine you're creating an infiltration game. When an
enemy spots the player, you want all guards and robots to be on alert.

In the fictional example below, we use ``SceneTree.call_group()`` to alert all
enemies that the player was spotted.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_Player_spotted():
        get_tree().call_group("guards", "enter_alert_mode")

 .. code-tab:: csharp

    public void _OnPlayerDiscovered()
    {
        GetTree().CallGroup("guards", "enter_alert_mode");
    }

The above code calls the function ``enter_alert_mode`` on every member of the
group ``guards``.

To get the full list of nodes in the ``guards`` group as an array, you can call
:ref:`SceneTree.get_nodes_in_group()
<class_SceneTree_method_get_nodes_in_group>`:

.. tabs::
 .. code-tab:: gdscript GDScript

    var guards = get_tree().get_nodes_in_group("guards")

 .. code-tab:: csharp

    var guards = GetTree().GetNodesInGroup("guards");

The :ref:`SceneTree <class_SceneTree>` class provides many more useful methods
to interact with scenes, their node hierarchy, and groups. It allows you to
switch scenes easily or reload them, quit the game or pause and unpause it. It
also provides useful signals.


===================================================
/. ./tutorials/scripting/nodes_and_scene_instances.rst
===================================================

.. _doc_nodes_and_scene_instances:

Nodes and scene instances
=========================

This guide explains how to get nodes, create nodes, add them as a child, and
instantiate scenes from code.

Getting nodes
-------------

You can get a reference to a node by calling the :ref:`Node.get_node()
<class_Node_method_get_node>` method. For this to work, the child node must be
present in the scene tree. Getting it in the parent node's ``_ready()`` function
guarantees that.

If, for example,  you have a scene tree like this, and you want to get a reference to the
Sprite and Camera2D nodes to access them in your script.

.. image:: img/nodes_and_scene_instances_player_scene_example.png

To do so, you can use the following code.

.. tabs::
 .. code-tab:: gdscript GDScript

    var sprite
    var camera2d

    func _ready():
        sprite = get_node("Sprite")
        camera2d = get_node("Camera2D")

 .. code-tab:: csharp

    private Sprite _sprite;
    private Camera2D _camera2d;

    public override void _Ready()
    {
        base._Ready();

        _sprite = GetNode<Sprite>("Sprite");
        _camera2d = GetNode<Camera2D>("Camera2D");
    }

Note that you get nodes using their name, not their type. Above, "Sprite" and
"Camera2D" are the nodes' names in the scene.

.. image:: img/nodes_and_scene_instances_sprite_node.png

If you rename the Sprite node as Skin in the Scene dock, you have to change the
line that gets the node to ``get_node("Skin")`` in the script.

.. image:: img/nodes_and_scene_instances_sprite_node_renamed.png

Node paths
----------

When getting a reference to a node, you're not limited to getting a direct child. The ``get_node()`` function
supports paths, a bit like when working with a file browser. Add a slash to
separate nodes.

Take the following example scene, with the script attached to the UserInterface
node.

.. image:: img/nodes_and_scene_instances_ui_scene_example.png

To get the Tween node, you would use the following code.

.. tabs::
 .. code-tab:: gdscript GDScript

    var tween

    func _ready():
        tween = get_node("ShieldBar/Tween")

 .. code-tab:: csharp

    private Tween _tween;

    public override void _Ready()
    {
        base._Ready();

        _tween = GetNode<Tween>("ShieldBar/Tween");
    }

.. note:: As with file paths, you can use ".." to get a parent node. The best
          practice is to avoid doing that though not to break encapsulation.
          You can also start the path with a forward
          slash to make it absolute, in which case your topmost node would be
          "/root", the application's predefined root viewport.

Syntactic sugar
~~~~~~~~~~~~~~~

You can use two shorthands to shorten your code in GDScript. Firstly, putting the
``onready`` keyword before a member variable makes it initialize right before
the ``_ready()`` callback.

.. code-block:: gdscript

    onready var sprite = get_node("Sprite")

There is also a short notation for ``get_node()``: the dollar sign, "$". You
place it before the name or path of the node you want to get.

.. code-block:: gdscript

    onready var sprite = $Sprite
    onready var tween = $ShieldBar/Tween

Creating nodes
--------------

To create a node from code, call its ``new()`` method like for any other
class-based datatype.

You can store the newly created node's reference in a variable and call
``add_child()`` to add it as a child of the node to which you attached the
script.

.. tabs::
 .. code-tab:: gdscript GDScript

    var sprite

    func _ready():
        var sprite = Sprite.new() # Create a new Sprite.
        add_child(sprite) # Add it as a child of this node.

 .. code-tab:: csharp

    private Sprite _sprite;

    public override void _Ready()
    {
        base._Ready();

        _sprite = new Sprite(); // Create a new Sprite.
        AddChild(_sprite); // Add it as a child of this node.
    }

To delete a node and free it from memory, you can call its ``queue_free()``
method. Doing so queues the node for deletion at the end of the current frame
after it has finished processing. At that point, the engine removes the node from
the scene and frees the object in memory.

.. tabs::
 .. code-tab:: gdscript GDScript

    sprite.queue_free()

 .. code-tab:: csharp

    _sprite.QueueFree();

Before calling ``sprite.queue_free()``, the remote scene tree looks like this.

.. image:: img/nodes_and_scene_instances_remote_tree_with_sprite.png

After the engine freed the node, the remote scene tree doesn't display the
sprite anymore.

.. image:: img/nodes_and_scene_instances_remote_tree_no_sprite.png

You can alternatively call ``free()`` to immediately destroy the node. You
should do this with care as any reference to it will instantly become ``null``.
We recommend using ``queue_free()`` unless you know what you're doing.

When you free a node, it also frees all its children. Thanks to this, to delete
an entire branch of the scene tree, you only have to free the topmost parent
node.

Instancing scenes
-----------------

Scenes are templates from which you can create as many reproductions as you'd
like. This operation is called instancing, and doing it from code happens in two
steps:

1. Loading the scene from the hard drive.
2. Creating an instance of the loaded :ref:`PackedScene <class_PackedScene>`
   resource.

.. tabs::
 .. code-tab:: gdscript GDScript

    var scene = load("res://MyScene.tscn")

 .. code-tab:: csharp

    var scene = GD.Load<PackedScene>("res://MyScene.tscn");

Preloading the scene can improve the user's experience as the load operation
happens when the compiler reads the script and not at runtime. This feature is
only available with GDScript.

.. tabs::
 .. code-tab:: gdscript GDScript

    var scene = preload("res://MyScene.tscn")

At that point, ``scene`` is a packed scene resource, not a node. To create the
actual node, you need to call :ref:`PackedScene.instance()
<class_PackedScene_method_instance>`. It returns a tree of nodes that you can
as a child of your current node.

.. tabs::
 .. code-tab:: gdscript GDScript

    var instance = scene.instance()
    add_child(instance)

 .. code-tab:: csharp

    var instance = scene.Instance();
    AddChild(instance);

The advantage of this two-step process is you can keep a packed scene loaded and
create new instances on the fly. For example, to quickly instance several
enemies or bullets.


===================================================
/. ./tutorials/scripting/overridable_functions.rst
===================================================

.. _doc_overridable_functions:

Overridable functions
=====================

Godot's Node class provides virtual functions you can override to update nodes
every frame or on specific events, like when they enter the scene tree.

This document presents the ones you'll use most often.

.. seealso:: Under the hood, these functions rely on Godot's low-level
             notifications system. To learn more about it, see
             :ref:`doc_godot_notifications`.

Two functions allow you to initialize and get nodes, besides the class's
constructor: ``_enter_tree()`` and ``_ready()``.

When the node enters the Scene Tree, it becomes active and the engine calls its
``_enter_tree()`` method. That node's children may not be part of the active scene yet. As
you can remove and re-add nodes to the scene tree, this function may be called
multiple times throughout a node's lifetime.

Most of the time, you'll use ``_ready()`` instead. This function is called only
once in a node's lifetime, after ``_enter_tree()``. ``_ready()`` ensures that all children
have entered the scene tree first, so you can safely call ``get_node()`` on it.

.. seealso:: To learn more about getting node references, read
             :ref:`doc_nodes_and_scene_instances`.

Another related callback is ``_exit_tree()``, which the engine calls every time
a node exits the scene tree. This can be when you call :ref:`Node.remove_child()
<class_Node_method_remove_child>` or when you free a node.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Called every time the node enters the scene tree.
    func _enter_tree():
        pass

    # Called when both the node and its children have entered the scene tree.
    func _ready():
        pass

    # Called when the node is about to leave the scene tree, after all its
    # children received the _exit_tree() callback.
    func _exit_tree():
        pass

 .. code-tab:: csharp

    // Called every time the node enters the scene tree.
    public override void _EnterTree()
    {
        base._EnterTree();
    }

    // Called when both the node and its children have entered the scene tree.
    public override void _Ready()
    {
        base._Ready();
    }

    // Called when the node is about to leave the scene tree, after all its
    // children.
    public override void _ExitTree()
    {
        base._ExitTree();
    }

The two virtual methods ``_process()`` and ``_physics_process()`` allow you to
update the node, every frame and every physics frame respectively. For more
information, read the dedicated documentation:
:ref:`doc_idle_and_physics_processing`.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Called every frame, as often as possible.
    func _process(delta):
        pass

    # Called every physics frame.
    func _physics_process(delta):
        pass

 .. code-tab:: csharp

    public override void _Process(float delta)
    {
        // Called every frame, as often as possible.
        base._Process(delta);
    }

    public override void _PhysicsProcess(float delta)
    {
        // Called every physics frame.
        base._PhysicsProcess(delta);
    }

Two more essential built-in node callback functions are
:ref:`Node._unhandled_input() <class_Node_method__unhandled_input>` and
:ref:`Node._input() <class_Node_method__input>`, which you use to both receive
and process individual input events. The ``_unhandled_input()`` method receives
every key press, mouse click, etc. that have not been handled already in an
``_input()`` callback or in a user interface component. You want to use it for
gameplay input in general. The ``_input()`` callback allows you to intercept and
process input events before ``_unhandled_input()`` gets them.

To learn more about inputs in Godot, see the :ref:`Input section <toc-learn-features-inputs>`.

.. tabs::
 .. code-tab:: gdscript GDScript

    # Called once for every event.
    func _unhandled_input(event):
        pass

    # Called once for every event, before _unhandled_input(), allowing you to
    # consume some events.
    func _input(event):
        pass

 .. code-tab:: csharp

    // Called once for every event.
    public override void _UnhandledInput(InputEvent @event)
    {
        base._UnhandledInput(event);
    }

    // Called once for every event, before _unhandled_input(), allowing you to
    // consume some events.
    public override void _Input(InputEvent @event)
    {
        base._Input(event);
    }

There are some more overridable functions like
:ref:`Node._get_configuration_warning()
<class_Node_method__get_configuration_warning>`. Specialized node types provide
more callbacks like :ref:`CanvasItem._draw() <class_CanvasItem_method__draw>` to
draw programmatically or :ref:`Control._gui_input()
<class_Control_method__gui_input>` to handle clicks and input on UI elements.


===================================================
/. ./tutorials/scripting/cross_language_scripting.rst
===================================================

.. _doc_cross_language_scripting:

Cross-language scripting
========================

Godot allows you to mix and match scripting languages to suit your needs.
This means a single project can define nodes in both C# and GDScript.
This page will go through the possible interactions between two nodes written
in different languages.

The following two scripts will be used as references throughout this page.

.. tabs::

 .. code-tab:: gdscript GDScript

    extends Node

    var str1 : String = "foo"
    var str2 : String setget ,get_str2

    func get_str2() -> String:
        return "foofoo"

    func print_node_name(node : Node) -> void:
        print(node.get_name())

    func print_array(arr : Array) -> void:
        for element in arr:
            print(element)

    func print_n_times(msg : String, n : int) -> void:
        for i in range(n):
            print(msg)

 .. code-tab:: csharp

    public class MyCSharpNode : Node
    {
        public String str1 = "bar";
        public String str2 { get { return "barbar"; } }

        public void PrintNodeName(Node node)
        {
            GD.Print(node.GetName());
        }

        public void PrintArray(String[] arr)
        {
            foreach (String element in arr)
            {
                GD.Print(element);
            }
        }

        public void PrintNTimes(String msg, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                GD.Print(msg);
            }
        }
    }

Instantiating nodes
-------------------

If you're not using nodes from the scene tree, you'll probably want to
instantiate nodes directly from the code.

Instantiating C# nodes from GDScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using C# from GDScript doesn't need much work. Once loaded
(see :ref:`doc_gdscript_classes_as_resources`), the script can be instantiated
with :ref:`new() <class_CSharpScript_method_new>`.

::

    var my_csharp_script = load("res://path_to_cs_file.cs")
    var my_csharp_node = my_csharp_script.new()
    print(my_csharp_node.str2) # barbar

.. warning::

    When creating ``.cs`` scripts, you should always keep in mind that the class
    Godot will use is the one named like the ``.cs`` file itself. If that class
    does not exist in the file, you'll see the following error:
    ``Invalid call. Nonexistent function `new` in base``.

    For example, MyCoolNode.cs should contain a class named MyCoolNode.

    You also need to check your ``.cs`` file is referenced in the project's
    ``.csproj`` file. Otherwise, the same error will occur.

Instantiating GDScript nodes from C#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From the C# side, everything work the same way. Once loaded, the GDScript can
be instantiated with :ref:`GDScript.New() <class_GDScript_method_new>`.

.. code-block:: csharp

    GDScript MyGDScript = (GDScript) GD.Load("res://path_to_gd_file.gd");
    Object myGDScriptNode = (Godot.Object) MyGDScript.New(); // This is a Godot.Object

Here we are using an :ref:`class_Object`, but you can use type conversion like
explained in :ref:`doc_c_sharp_features_type_conversion_and_casting`.

Accessing fields
----------------

Accessing C# fields from GDScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Accessing C# fields from GDScript is straightforward, you shouldn't have
anything to worry about.

::

    print(my_csharp_node.str1) # bar
    my_csharp_node.str1 = "BAR"
    print(my_csharp_node.str1) # BAR

    print(my_csharp_node.str2) # barbar
    # my_csharp_node.str2 = "BARBAR" # This line will hang and crash

Note that it doesn't matter if the field is defined as a property or an
attribute. However, trying to set a value on a property that does not define
a setter will result in a crash.

Accessing GDScript fields from C#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As C# is statically typed, accessing GDScript from C# is a bit more
convoluted, you will have to use :ref:`Object.Get() <class_Object_method_get>`
and :ref:`Object.Set() <class_Object_method_set>`. The first argument is the name of the field you want to access.

.. code-block:: csharp

    GD.Print(myGDScriptNode.Get("str1")); // foo
    myGDScriptNode.Set("str1", "FOO");
    GD.Print(myGDScriptNode.Get("str1")); // FOO

    GD.Print(myGDScriptNode.Get("str2")); // foofoo
    // myGDScriptNode.Set("str2", "FOOFOO"); // This line won't do anything

Keep in mind that when setting a field value you should only use types the
GDScript side knows about.
Essentially, you want to work with built-in types as described in :ref:`doc_gdscript` or classes extending :ref:`class_Object`.

Calling methods
---------------

Calling C# methods from GDScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Again, calling C# methods from GDScript should be straightforward. The
marshalling process will do its best to cast the arguments to match
function signatures.
If that's impossible, you'll see the following error: ``Invalid call. Nonexistent function `FunctionName```.

::

    my_csharp_node.PrintNodeName(self) # myGDScriptNode
    # my_csharp_node.PrintNodeName() # This line will fail.

    my_csharp_node.PrintNTimes("Hello there!", 2) # Hello there! Hello there!

    my_csharp_node.PrintArray(["a", "b", "c"]) # a, b, c
    my_csharp_node.PrintArray([1, 2, 3]) # 1, 2, 3

Calling GDScript methods from C#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To call GDScript methods from C# you'll need to use
:ref:`Object.Call() <class_Object_method_call>`. The first argument is the
name of the method you want to call. The following arguments will be passed
to said method.

.. code-block:: csharp

    myGDScriptNode.Call("print_node_name", this); // my_csharp_node
    // myGDScriptNode.Call("print_node_name"); // This line will fail silently and won't error out.

    myGDScriptNode.Call("print_n_times", "Hello there!", 2); // Hello there! Hello there!

    // When dealing with functions taking a single array as arguments, we need to be careful.
    // If we don't cast it into an object, the engine will treat each element of the array as a separate argument and the call will fail.
    String[] arr = new String[] { "a", "b", "c" };
    // myGDScriptNode.Call("print_array", arr); // This line will fail silently and won't error out.
    myGDScriptNode.Call("print_array", (object)arr); // a, b, c
    myGDScriptNode.Call("print_array", (object)new int[] { 1, 2, 3 }); // 1, 2, 3
    // Note how the type of each array entry does not matter as long as it can be handled by the marshaller

.. warning::

    As you can see, if the first argument of the called method is an array,
    you'll need to cast it as ``object``.
    Otherwise, each element of your array will be treated as a single argument
    and the function signature won't match.

Inheritance
-----------

A GDScript file may not inherit from a C# script. Likewise, a C# script may not
inherit from a GDScript file. Due to how complex this would be to implement,
this limitation is unlikely to be lifted in the future. See
`this GitHub issue <https://github.com/godotengine/godot/issues/38352>`__
for more information.


===================================================
/. ./tutorials/scripting/creating_script_templates.rst
===================================================

.. _doc_creating_script_templates:

Creating script templates
=========================

Godot provides a way to use script templates as seen in the
``Script Create Dialog`` while creating a new script:

.. image:: img/script_create_dialog_templates.png

A set of default script templates is provided by default, but it's also possible
to modify existing and create new ones, both per project and the editor.

Locating the templates
----------------------

There are two places where templates can be managed.

Editor-defined templates
~~~~~~~~~~~~~~~~~~~~~~~~

These are available globally throughout any project. The location of these
templates are determined per each OS:

-  Windows: ``%APPDATA%\Godot\script_templates\``
-  Linux: ``$HOME/.config/godot/script_templates/``
-  macOS: ``$HOME/Library/Application Support/Godot/script_templates/``

If no ``script_templates`` is detected, Godot will create a default set of
built-in templates automatically, so this logic can be used to reset the default
templates in case you've accidentally overwritten them.

Project-defined templates
~~~~~~~~~~~~~~~~~~~~~~~~~

The default path to search for templates is the
``res://script_templates/`` directory. The path can be changed by configuring
the ``editor/script_templates_search_path`` setting in the
:ref:`ProjectSettings <class_ProjectSettings>`, both via code and the editor.

If no ``script_templates`` directory is found within a project, it is simply
ignored.

Language support and overriding behavior
----------------------------------------

Depending on whether a particular language implements a way to generate scripts
out of templates, it's possible to create a template which can be recognized by
that language according to template's file extension. For GDScript and C#, the
extensions must be ``gd`` and ``cs`` respectively.

.. note:: The script templates have the same extension as the regular script
          files. This may lead to an issue of a script parser treating those templates as
          actual scripts within a project. To avoid this, make sure to ignore the
          directory containing them by creating an empty ``.gdignore`` file. The directory won't be
          visible throughout the project's filesystem anymore, yet the templates can be
          modified by an external text editor anytime.

The built-in editor templates are automatically shadowed by the project-specific
templates given both scripts have the same filename.

Default template
----------------

The ``Default`` template is always generated dynamically per language and cannot
be configured nor overridden, but you can use these as the base for creating
other templates.

.. tabs::

 .. code-tab:: gdscript GDScript

    extends %BASE%


    # Declare member variables here. Examples:
    # var a%INT_TYPE% = 2
    # var b%STRING_TYPE% = "text"


    # Called when the node enters the scene tree for the first time.
    func _ready()%VOID_RETURN%:
        pass # Replace with function body.


    # Called every frame. 'delta' is the elapsed time since the previous frame.
    #func _process(delta%FLOAT_TYPE%)%VOID_RETURN%:
    #	pass


 .. code-tab:: csharp

    using Godot;
    using System;

    public class %CLASS% : %BASE%
    {
        // Declare member variables here. Examples:
        // private int a = 2;
        // private string b = "text";

        // Called when the node enters the scene tree for the first time.
        public override void _Ready()
        {

        }

    //  // Called every frame. 'delta' is the elapsed time since the previous frame.
    //  public override void _Process(float delta)
    //  {
    //
    //  }
    }

List of template placeholders
-----------------------------

The following describes the complete list of built-in template placeholders
which are currently implemented.

Base placeholders
~~~~~~~~~~~~~~~~~

+-------------+----------------------------------------------------------------+
| Placeholder | Description                                                    |
+=============+================================================================+
| ``%CLASS%`` | The name of the new class (used in C# only).                   |
+-------------+----------------------------------------------------------------+
| ``%BASE%``  | The base type a new script inherits from.                      |
+-------------+----------------------------------------------------------------+
| ``%TS%``    | Indentation placeholder. The exact type and number of          |
|             | whitespace characters used for indentation is determined by    |
|             | the ``text_editor/indent/type`` and ``text_editor/indent/size``|
|             | settings in the :ref:`EditorSettings <class_EditorSettings>`   |
|             | respectively.                                                  |
+-------------+----------------------------------------------------------------+

Type placeholders
~~~~~~~~~~~~~~~~~

These are only relevant for GDScript with static typing. Whether these
placeholders are actually replaced is determined by the
``text_editor/completion/add_type_hints`` setting in the
:ref:`EditorSettings <class_EditorSettings>`.

+-------------------+--------------+
| Placeholder       | Value        |
+===================+==============+
| ``%INT_TYPE%``    | ``: int``    |
+-------------------+--------------+
| ``%STRING_TYPE%`` | ``: String`` |
+-------------------+--------------+
| ``%FLOAT_TYPE%``  | ``: float``  |
+-------------------+--------------+
| ``%VOID_RETURN%`` | ``-> void``  |
+-------------------+--------------+


===================================================
/. ./tutorials/scripting/evaluating_expressions.rst
===================================================

.. _doc_evaluating_expressions:

Evaluating expressions
======================

Godot provides an :ref:`class_Expression` class you can use to evaluate expressions.

An expression can be:

- A mathematical expression such as ``(2 + 4) * 16/4.0``.
- A built-in method call like ``deg2rad(90)``.
- A method call on an user-provided script like ``update_health()``,
  if ``base_instance`` is set to a value other than ``null`` when calling
  :ref:`Expression.execute() <class_Expression_method_execute>`.

.. note::

    The Expression class is independent from GDScript.
    It's available even if you compile Godot with the GDScript module disabled.

Basic usage
-----------

To evaluate a mathematical expression, use::

    var expression = Expression.new()
    expression.parse("20 + 10*2 - 5/2.0")
    var result = expression.execute()
    print(result)  # 37.5

The following operators are available:

+------------------------+-------------------------------------------------------------------------------------+
| Operator               | Notes                                                                               |
+========================+=====================================================================================+
| Addition ``+``         | Can also be used to concatenate strings and arrays:                                 |
|                        | - ``"hello" + " world"`` = ``hello world``                                          |
|                        | - ``[1, 2] + [3, 4]`` = ``[1, 2, 3, 4]``                                            |
+------------------------+-------------------------------------------------------------------------------------+
| Subtraction (``-``)    |                                                                                     |
+------------------------+-------------------------------------------------------------------------------------+
| Multiplication (``*``) |                                                                                     |
+------------------------+-------------------------------------------------------------------------------------+
| Division (``/``)       | Performs and integer division if both operands are integers.                        |
|                        | If at least one of them is a floating-point number, returns a floating-point value. |
+------------------------+-------------------------------------------------------------------------------------+
| Modulo (``%``)         | Returns the remainder of an integer division.                                       |
+------------------------+-------------------------------------------------------------------------------------+

Spaces around operators are optional. Also, keep in mind the usual
`order of operations <https://en.wikipedia.org/wiki/Order_of_operations>`__
applies. Use parentheses to override the order of operations if needed.

All the Variant types supported in Godot can be used: integers, floating-point
numbers, strings, arrays, dictionaries, colors, vectors, …

Arrays and dictionaries can be indexed like in GDScript::

    # Returns 1.
    [1, 2][0]

    # Returns 3. Negative indices can be used to count from the end of the array.
    [1, 3][-1]

    # Returns "green".
    {"favorite_color": "green"}["favorite_color"]

    # All 3 lines below return 7.0 (Vector3 is floating-point).
    Vector3(5, 6, 7)[2]
    Vector3(5, 6, 7)["z"]
    Vector3(5, 6, 7).z

Passing variables to an expression
----------------------------------

You can pass variables to an expression. These variables will then
become available in the expression's "context" and will be substituted when used
in the expression::

    var expression = Expression.new()
    # Define the variable names first in the second parameter of `parse()`.
    # In this example, we use `x` for the variable name.
    expression.parse("20 + 2 * x", ["x"])
    # Then define the variable values in the first parameter of `execute()`.
    # Here, `x` is assigned the integer value 5.
    var result = expression.execute([5])
    print(result)  # 30

Both the variable names and variable values **must** be specified as an array,
even if you only define one variable. Also, variable names are **case-sensitive**.

Setting a base instance for the expression
------------------------------------------

By default, an expression has a base instance of ``null``. This means the
expression has no base instance associated to it.

When calling :ref:`Expression.execute() <class_Expression_method_execute>`,
you can set the value of the ``base_instance`` parameter to a specific object
instance such as ``self``, another script instance or even a singleton::

    func double(number):
        return number * 2


    func _ready():
        var expression = Expression.new()
        expression.parse("double(10)")

        # This won't work since we're not passing the current script as the base instance.
        var result = expression.execute([], null)
        print(result)  # null

        # This will work since we're passing the current script (i.e. self)
        # as the base instance.
        result = expression.execute([], self)
        print(result)  # 20

Associating a base instance allows doing the following:

- Reference the instance's constants (``const``) in the expression.
- Reference the instance's member variables (``var``) in the expression.
- Call methods defined in the instance and use their return values in the expression.

.. warning::

    Setting a base instance to a value other than ``null`` allows referencing
    constants, member variables, and calling all methods defined in the script
    attached to the instance. Allowing users to enter expressions may allow
    cheating in your game, or may even introduce security vulnerabilities if you
    allow arbitrary clients to run expressions on other players' devices.

Example script
--------------

The script below demonstrates what the Expression class is capable of::

    const DAYS_IN_YEAR = 365
    var script_member_variable = 1000


    func _ready():
        # Constant mathexpression.
        evaluate("2 + 2")
        # Math expression with variables.
        evaluate("x + y", ["x", "y"], [60, 100])

        # Call built-in method (hardcoded in the Expression class).
        evaluate("deg2rad(90)")

        # Call user method (defined in the script).
        # We can do this because the expression execution is bound to `self`
        # in the `evaluate()` method.
        # Since this user method returns a value, we can use it in math expressions.
        evaluate("call_me() + DAYS_IN_YEAR + script_member_variable")
        evaluate("call_me(42)")
        evaluate("call_me('some string')")


    func evaluate(command, variable_names = [], variable_values = []) -> void:
        var expression = Expression.new()
        var error = expression.parse(command, variable_names)
        if error != OK:
            push_error(expression.get_error_text())
            return

        var result = expression.execute(variable_values, self)

        if not expression.has_execute_failed():
            print(str(result))


    func call_me(argument = null):
        print("\nYou called 'call_me()' in the expression text.")
        if argument:
            print("Argument passed: %s" % argument)

        # The method's return value is also the expression's return value.
        return 0

The output from the script will be::

    4
    160
    1.570796

    You called 'call_me()' in the expression text.
    1365

    You called 'call_me()' in the expression text.
    Argument passed: 42
    0

    You called 'call_me()' in the expression text.
    Argument passed: some string
    0

Built-in functions
------------------

Most methods available in the :ref:`class_@GDScript` scope are available in the
Expression class, even if no base instance is bound to the expression.
The same parameters and return types are available.

However, unlike GDScript, parameters are **always required** even if they're
specified as being optional in the class reference. In contrast, this
restriction on arguments doesn't apply to user-made functions when you bind a
base instance to the expression.


===================================================
/. ./tutorials/scripting/change_scenes_manually.rst
===================================================

.. _doc_change_scenes_manually:

Change scenes manually
======================

Sometimes it helps to have more control over how one swaps scenes around.
As mentioned above, a :ref:`Viewport <class_Viewport>`'s child nodes
will render to the image it generates. This holds true even for nodes outside
of the "current" scene. Autoloads fall into this category, but so do
scenes which one instances and adds to the tree at runtime:

.. tabs::
 .. code-tab:: gdscript GDScript

    var simultaneous_scene = preload("res://levels/level2.tscn").instance()

    func _add_a_scene_manually():
        # This is like autoloading the scene, only
        # it happens after already loading the main scene.
        get_tree().get_root().add_child(simultaneous_scene)

 .. code-tab:: csharp

    public PackedScene simultaneousScene;

    public MyClass()
    {
        simultaneousScene = (PackedScene)ResourceLoader.Load("res://levels/level2.tscn").instance();
    }

    public void _AddASceneManually()
    {
        // This is like autoloading the scene, only
        // it happens after already loading the main scene.
        GetTree().GetRoot().AddChild(simultaneousScene);
    }

To complete the cycle and swap out the new scene with the old one,
developers have a choice to make. Many strategies exist for removing a scene
from view of the :ref:`Viewport <class_Viewport>`. The tradeoffs involve
balancing operation speed and memory consumption as well as balancing data
access and integrity.

1. **We can delete the existing scene.**
   :ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>` and
   :ref:`SceneTree.change_scene_to() <class_SceneTree_method_change_scene_to>`
   will delete the current scene immediately. Developers can also delete the
   main scene though. Assuming the root node's name is "Main", one could do
   ``get_node("/root/Main").free()`` to delete the whole scene.

    - Unloads memory.

        - Pro: RAM is no longer dragging the dead weight.

        - Con: Returning to that scene is now more expensive since it must be
          loaded back into memory again (takes time AND memory). Not a problem
          if returning soon is unnecessary.

        - Con: No longer have access to that scene's data. Not a problem if
          using that data soon is unnecessary.

        - Note: It can be useful to preserve the data in a soon-to-be-deleted
          scene by re-attaching one or more of its nodes to a different scene,
          or even directly to the :ref:`SceneTree <class_SceneTree>`.

    - Processing stops.

        - Pro: No nodes means no process, physics process, or input
          handling. The CPU is available to work on the new scene's contents.

        - Con: Those nodes' processing and input handling no longer operate.
          Not a problem if using the updated data is unnecessary.

2. **We can hide the existing scene.** By changing the visibility or collision
   detection of the nodes, we can hide the entire node sub-tree from the
   player's perspective.

    - Memory still exists.

        - Pro: One can still access the data if need be.

        - Pro: There's no need to move any more nodes around to save data.

        - Con: More data is being kept in memory which will be become a problem
          on memory-sensitive platforms like web or mobile.

    - Processing continues.

        - Pro: Data continues to receive processing updates, so the scene will
          keep updated any data within it that relies on delta time or frame
          data.

        - Pro: Nodes are still members of groups (since groups belong to the
          :ref:`SceneTree <class_SceneTree>`).

        - Con: The CPU's attention is now divided between both scenes. Too much
          load could result in low frame rates. One should be sure to test
          performance as they go to ensure the target platform can support the
          load they are giving it.

3. **We can remove the existing scene from the tree.** Assign a variable
   to the existing scene's root node. Then use
   :ref:`Node.remove_child(Node) <class_Node_method_remove_child>` to detach the entire
   scene from the tree.

    - Memory still exists (similar pros/cons as with hiding it from view).

    - Processing stops (similar pros/cons as with deleting it completely).

    - Pro: This variation of "hiding" it is much easier to show/hide. Rather
      than potentially keeping track of multiple changes to the scene, one
      must only call the one method add/remove_child pair of methods. It is
      similar to disabling game objects in other engines.

    - Con: Unlike with hiding it from view only, the data contained within
      the scene will become stale if it relies on delta time, input, groups,
      or other data that is derived from :ref:`SceneTree <class_SceneTree>`
      access.

There are also cases where one may wish to have many scenes present at the same
time. Perhaps one is adding their own singleton at runtime, or preserving a
a scene's data between scene changes (adding the scene to the root node).

.. tabs::
 .. code-tab:: gdscript GDScript

        get_tree().get_root().add_child(scene)

 .. code-tab:: csharp

        GetTree().GetRoot().AddChild(scene);

Perhaps instead they wish to display multiple scenes at the same time using
:ref:`ViewportContainers <class_ViewportContainer>`. This is optimal in
cases where the intent is to render different content in different parts of the
screen. Minimaps and split-screen multiplayer are good examples.

Each option will have cases where it is best appropriate, so one must
examine the effects of each and determine what path best fits
their unique situation.


===================================================
/. ./tutorials/scripting/instancing_with_signals.rst
===================================================

.. meta::
    :keywords: Signal

.. _doc_instancing_with_signals:

Instancing with signals
=======================

Signals provide a way to decouple game objects, allowing you to avoid forcing a
fixed arrangement of nodes. One sign that a signal might be called for is when
you find yourself using ``get_parent()``. Referring directly to a node's parent
means that you can't easily move that node to another location in the scene tree.
This can be especially problematic when you are instancing objects at runtime
and may want to place them in an arbitrary location in the running scene tree.

Below we'll consider an example of such a situation: firing bullets.

Shooting example
----------------

Consider a player character that can rotate and shoot towards the mouse. Every
time the mouse button is clicked, we create an instance of the bullet at the
player's location. See :ref:`doc_instancing` for details.

We'll use an ``Area2D`` for the bullet, which moves in a straight line at a
given velocity:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Area2D

    var velocity = Vector2.ZERO

    func _physics_process(delta):
        position += velocity * delta

 .. code-tab:: csharp

    public class Bullet : Area2D
    {
        Vector2 Velocity = new Vector2();

        public override void _PhysicsProcess(float delta)
        {
            Position += Velocity * delta;
        }
    }

However, if the bullets are added as children of the player, then they will
remain "attached" to the player as it rotates:

.. image:: img/signals_shoot1.gif

Instead, we need the bullets to be independent of the player's movement - once
fired, they should continue traveling in a straight line and the player can no
longer affect them. Instead of being added to the scene tree as a child of the
player, it makes more sense to add the bullet as a child of the "main" game
scene, which may be the player's parent or even further up the tree.

You could do this by adding the bullet to the main scene directly:

.. tabs::
 .. code-tab:: gdscript GDScript

    var bullet_instance = Bullet.instance()
    get_parent().add_child(bullet_instance)

 .. code-tab:: csharp

    Node bulletInstance = Bullet.Instance();
    GetParent().AddChild(bulletInstance);

However, this will lead to a different problem. Now if you try to test your
"Player" scene independently, it will crash on shooting, because there is no
parent node to access. This makes it a lot harder to test your player code
independently and also means that if you decide to change your main scene's
node structure, the player's parent may no longer be the appropriate node to
receive the bullets.

The solution to this is to use a signal to "emit" the bullets from the player.
The player then has no need to "know" what happens to the bullets after that -
whatever node is connected to the signal can "receive" the bullets and take the
appropriate action to spawn them.

Here is the code for the player using signals to emit the bullet:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Sprite

    signal shoot(bullet, direction, location)

    var Bullet = preload("res://Bullet.tscn")

    func _input(event):
        if event is InputEventMouseButton:
            if event.button_index == BUTTON_LEFT and event.pressed:
                emit_signal("shoot", Bullet, rotation, position)

    func _process(delta):
        look_at(get_global_mouse_position())

 .. code-tab:: csharp

    public class Player : Sprite
    {
        [Signal]
        delegate void Shoot(PackedScene bullet, Vector2 direction, Vector2 location);

        private PackedScene _bullet = GD.Load<PackedScene>("res://Bullet.tscn");

        public override void _Input(InputEvent event)
        {
            if (input is InputEventMouseButton mouseButton)
            {
                if (mouseButton.ButtonIndex == (int)ButtonList.Left && mouseButton.Pressed)
                {
                    EmitSignal(nameof(Shoot), _bullet, Rotation, Position);
                }
            }
        }

        public override _Process(float delta)
        {
            LookAt(GetGlobalMousePosition());
        }
    }

In the main scene, we then connect the player's signal (it will appear in the
"Node" tab).

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_Player_shoot(Bullet, direction, location):
        var b = Bullet.instance()
        add_child(b)
        b.rotation = direction
        b.position = location
        b.velocity = b.velocity.rotated(direction)

 .. code-tab:: csharp

    public void _on_Player_Shoot(PackedScene bullet, Vector2 direction, Vector2 location)
    {
        var bulletInstance = (Bullet)bullet.Instance();
        AddChild(bulletInstance);
        bulletInstance.Rotation = direction;
        bulletInstance.Position = location;
        bulletInstance.Velocity = bulletInstance.Velocity.Rotated(direction);
    }

Now the bullets will maintain their own movement independent of the player's
rotation:

.. image:: img/signals_shoot2.gif


===================================================
/. ./tutorials/scripting/pausing_games.rst
===================================================

.. _doc_pausing_games:

Pausing games and process mode
==============================

Introduction
------------

In most games it is desirable to, at some point, interrupt the
game to do something else, such as taking a break or changing options.
Implementing a fine-grained control for what can be paused (and what cannot)
is a lot of work, so a simple framework for pausing is provided in
Godot.

How pausing works
-----------------

To pause the game the pause state must be set. This is done by assigning
``true`` to the :ref:`SceneTree.paused <class_SceneTree_property_paused>` property:

.. tabs::
 .. code-tab:: gdscript GDScript

    get_tree().paused = true

 .. code-tab:: csharp

    GetTree().Paused = true;

Doing this will cause two things. First, 2D and 3D physics will be stopped
for all nodes. Second, the behavior of certain nodes will stop or start
depending on their process mode.

.. note:: The physics servers can be made active while the game is
          paused by using their ``set_active`` methods.

Process Modes
-------------

Each node in Godot has a "Pause Mode" that defines when it processes. It can
be found and changed under a node's :ref:`Node <class_Node>` properties in the inspector.

.. image:: img/pausemode.png

You can also alter the property with code:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        pause_mode = Node.PAUSE_MODE_PROCESS

 .. code-tab:: csharp

    public override void _Ready()
    {
        PauseMode = Node.PauseModeEnum.Process;
    }

This is what each mode tells a node to do:

-  **Inherit**: Process depending on the state of the parent, grandparent, etc.
   The first parent that has a state other than Inherit determines the effective
   value that will be used.
-  **Stop**: If the scene tree is paused, pause the node no matter what (and
   children in Inherit mode). When paused, this node *will not* process.
-  **Process**: Even if the scene tree is paused, process the node no matter
   what (and children in Inherit mode). Paused or not, this node *will* process.

By default, all nodes have this property in the "Inherit" state. If the
parent is set to "Inherit", then the grandparent will be checked and so
on. If a state can't be found in any of the grandparents, the pause state
in SceneTree is used. This means that, by default, when the game is paused
every node will be paused. Several things happen when a node stops processing.

The ``_process``, ``_physics_process``, ``_input``, and ``_input_event`` functions
will not be called. However signals still work and cause their connected function to
run, even if that function's script is attached to a node that has its pause
mode set to "Stop".

Animation nodes will pause their current animation, audio nodes
will pause their current audio stream, and particles will pause. These resume
automatically when the game is no longer paused.

It is important to note that even if a node is processing while the game is
paused physics will **NOT** work for it by default. As stated earlier this is
because the physics servers are turned off. The physics servers can be made
active while the game is paused by using their ``set_active`` methods.

Pause Menu Example
------------------

Here is an example of a pause menu. Create a popup or panel with controls
inside, and set its pause mode to "Process" then hide it. By setting the
root of the pause popup to "Process", all children and grandchildren will
inherit that state. This way, this branch of the scene tree will continue
working when paused.

Finally, make it so when a pause button is pressed (any button will do),
enable the pause and show the pause screen.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_pause_button_pressed():
        get_tree().paused = true
        $pause_popup.show()

 .. code-tab:: csharp

    public void _on_pause_button_pressed()
    {
        GetTree().Paused = true;
        GetNode<Control>("pause_popup").Show();
    }

To unpause, do the opposite when the pause screen is
closed:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_pause_popup_close_pressed():
        $pause_popup.hide()
        get_tree().paused = false

 .. code-tab:: csharp

    public void _on_pause_popup_close_pressed()
    {
        GetNode<Control>("pause_popup").Hide();
        GetTree().Paused = false;
    }


===================================================
/. ./tutorials/scripting/filesystem.rst
===================================================

.. _doc_filesystem:

File system
===========

Introduction
------------

A file system manages how assets are stored and how they are accessed.
A well-designed file system also allows multiple developers to edit the
same source files and assets while collaborating. Godot stores
all assets as files in its file system.

Implementation
--------------

The file system stores resources on disk. Anything, from a script, to a scene or a
PNG image is a resource to the engine. If a resource contains properties
that reference other resources on disk, the paths to those resources are also
included. If a resource has sub-resources that are built-in, the resource is
saved in a single file together with all the bundled sub-resources. For
example, a font resource is often bundled together with the font textures.

The Godot file system avoids using metadata files. Existing asset managers and VCSs 
are better than anything we can implement, so Godot tries its best to play along 
with SVN, Git, Mercurial, Perforce, etc.

Example of file system contents:

.. code-block:: none

    /project.godot
    /enemy/enemy.tscn
    /enemy/enemy.gd
    /enemy/enemysprite.png
    /player/player.gd

project.godot
-------------

The ``project.godot`` file is the project description file, and it is always found 
at the root of the project. In fact, its location defines where the root is. This
is the first file that Godot looks for when opening a project.

This file contains the project configuration in plain text, using the win.ini
format. Even an empty ``project.godot`` can function as a basic definition of 
a blank project.

Path delimiter
--------------

Godot only supports ``/`` as a path delimiter. This is done for
portability reasons. All operating systems support this, even Windows,
so a path such as ``C:\project\project.godot`` needs to be typed as
``C:/project/project.godot``.

Resource path
-------------

When accessing resources, using the host OS file system layout can be
cumbersome and non-portable. To solve this problem, the special path
``res://`` was created.

The path ``res://`` will always point at the project root (where
``project.godot`` is located, so ``res://project.godot`` is always
valid).

This file system is read-write only when running the project locally from
the editor. When exported or when running on different devices (such as
phones or consoles, or running from DVD), the file system will become
read-only and writing will no longer be permitted.

User path
---------

Writing to disk is still needed for tasks such as saving game state or 
downloading content packs. To this end, the engine ensures that there is a
special path ``user://`` that is always writable. This path resolves 
differently depending on the OS the project is running on. Local path 
resolution is further explained in :ref:`doc_data_paths`.

Host file system
----------------

Alternatively host file system paths can also be used, but this is not recommended
for a released product as these paths are not guaranteed to work on all platforms.
However, using host file system paths can be useful when writing development
tools in Godot.

Drawbacks
---------

There are some drawbacks to this simple file system design. The first issue is that
moving assets around (renaming them or moving them from one path to another inside
the project) will break existing references to these assets. These references will
have to be re-defined to point at the new asset location.

To avoid this, do all your move, delete and rename operations from within Godot, on 
the FileSystem dock. Never move assets from outside Godot, or dependencies will have 
to be fixed manually (Godot detects this and helps you fix them anyway, but why
go the hard route?).

The second is that, under Windows and macOS, file and path names are case insensitive.
If a developer working in a case insensitive host file system saves an asset as ``myfile.PNG``,
but then references it as ``myfile.png``, it will work fine on their platform, but not
on other platforms, such as Linux, Android, etc. This may also apply to exported binaries,
which use a compressed package to store all files.

It is recommended that your team clearly define a naming convention for files when
working with Godot. One simple fool-proof convention is to only allow lowercase
file and path names.


===================================================
/. ./tutorials/scripting/resources.rst
===================================================

.. _doc_resources:

Resources
=========

Nodes and resources
-------------------

Up to this tutorial, we focused on the :ref:`Node <class_Node>`
class in Godot as that's the one you use to code behavior and
most of the engine's features rely on it. There is
another datatype that is just as important:
:ref:`Resource <class_Resource>`.

*Nodes* give you functionality: they draw sprites, 3D models, simulate physics,
arrange user interfaces, etc. **Resources** are **data containers**. They don't
do anything on their own: instead, nodes use the data contained in resources.

Anything Godot saves or loads from disk is a resource. Be it a scene (a ``.tscn``
or an ``.scn`` file), an image, a script... Here are some ``Resource`` examples:
:ref:`Texture <class_Texture>`, :ref:`Script <class_Script>`, :ref:`Mesh
<class_Mesh>`, :ref:`Animation <class_Animation>`, :ref:`AudioStream
<class_AudioStream>`, :ref:`Font <class_Font>`, :ref:`Translation
<class_Translation>`.

When the engine loads a resource from disk, **it only loads it once**. If a copy
of that resource is already in memory, trying to load the resource again will
return the same copy every time. As resources only contain data, there is no need
to duplicate them.

Every object, be it a Node or a Resource, can export properties. There are many
types of Properties, like String, integer, Vector2, etc., and any of these types
can become a resource. This means that both nodes and resources can contain
resources as properties:

.. image:: img/nodes_resources.png

External vs built-in
--------------------

There are two ways to save resources. They can be:

1. **External** to a scene, saved on the disk as individual files.
2. **Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're attached to.

To be more specific, here's a :ref:`Texture <class_Texture>`
in a :ref:`Sprite <class_Sprite>` node:

.. image:: img/spriteprop.png

Clicking the resource preview allows us to view and edit the resource's properties.

.. image:: img/resourcerobi.png

The path property tells us where the resource comes from. In this case, it comes
from a PNG image called ``robi.png``. When the resource comes from a file like
this, it is an external resource. If you erase the path or this path is empty,
it becomes a built-in resource.

The switch between built-in and external resources happens when you save the
scene. In the example above, if you erase the path ``"res://robi.png"`` and
save, Godot will save the image inside the ``.tscn`` scene file.

.. note::

    Even if you save a built-in resource, when you instance a scene multiple
    times, the engine will only load one copy of it.

Loading resources from code
---------------------------

There are two ways to load resources from code. First, you can use the ``load()`` function anytime:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
            var res = load("res://robi.png") # Godot loads the Resource when it reads the line.
            get_node("sprite").texture = res

 .. code-tab:: csharp

    public override void _Ready()
    {
        var texture = (Texture)GD.Load("res://robi.png"); // Godot loads the Resource when it reads the line.
        var sprite = GetNode<Sprite>("sprite");
        sprite.Texture = texture;
    }

You can also ``preload`` resources. Unlike ``load``, this function will read the
file from disk and load it at compile-time. As a result, you cannot call preload
with a variable path: you need to use a constant string.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
            var res = preload("res://robi.png") # Godot loads the resource at compile-time
            get_node("sprite").texture = res

 .. code-tab:: csharp

    // 'preload()' is unavailable in C Sharp.

Loading scenes
--------------

Scenes are also resources, but there is a catch. Scenes saved to disk are
resources of type :ref:`PackedScene <class_PackedScene>`. The
scene is packed inside a resource.

To get an instance of the scene, you have to use the
:ref:`PackedScene.instance() <class_PackedScene_method_instance>` method.

.. tabs::
 .. code-tab:: gdscript GDScript

    func _on_shoot():
            var bullet = preload("res://bullet.tscn").instance()
            add_child(bullet)


 .. code-tab:: csharp

    private PackedScene _bulletScene = (PackedScene)GD.Load("res://bullet.tscn");

    public void OnShoot()
    {
        Node bullet = _bulletScene.Instance();
        AddChild(bullet);
    }

This method creates the nodes in the scene's hierarchy, configures them, and
returns the root node of the scene. You can then add it as a child of any other
node.

The approach has several advantages. As the :ref:`PackedScene.instance()
<class_PackedScene_method_instance>` function is fast, you can create new
enemies, bullets, effects, etc. without having to load them again from disk each
time. Remember that, as always, images, meshes, etc. are all shared between the
scene instances.

Freeing resources
-----------------

When a ``Resource`` is no longer in use, it will automatically free itself.
Since, in most cases, Resources are contained in Nodes, when you free a node,
the engine frees all the resources it owns as well if no other node uses them.

Creating your own resources
---------------------------

Like any Object in Godot, users can also script Resources. Resource scripts
inherit the ability to freely translate between object properties and serialized
text or binary data (\*.tres, \*.res). They also inherit the reference-counting
memory management from the Reference type.

This comes with many distinct advantages over alternative data
structures, such as JSON, CSV, or custom TXT files. Users can only import these
assets as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a
:ref:`File <class_File>` to parse. What sets Resources apart is their
inheritance of :ref:`Object <class_Object>`, :ref:`Reference <class_Reference>`,
and :ref:`Resource <class_Resource>` features:

- They can define constants, so constants from other data fields or objects are not needed.

- They can define methods, including setter/getter methods for properties. This allows for abstraction and encapsulation of the underlying data. If the Resource script's structure needs to change, the game using the Resource need not also change.

- They can define signals, so Resources can trigger responses to changes in the data they manage.

- They have defined properties, so users know 100% that their data will exist.

- Resource auto-serialization and deserialization is a built-in Godot Engine feature. Users do not need to implement custom logic to import/export a resource file's data.

- Resources can even serialize sub-Resources recursively, meaning users can design even more sophisticated data structures.

- Users can save Resources as version-control-friendly text files (\*.tres). Upon exporting a game, Godot serializes resource files as binary files (\*.res) for increased speed and compression.

- Godot Engine's Inspector renders and edits Resource files out-of-the-box. As such, users often do not need to implement custom logic to visualize or edit their data. To do so, double-click the resource file in the FileSystem dock or click the folder icon in the Inspector and open the file in the dialog.

- They can extend **other** resource types besides just the base Resource.

Godot makes it easy to create custom Resources in the Inspector.

1. Create a plain Resource object in the Inspector. This can even be a type that derives Resource, so long as your script is extending that type.
2. Set the ``script`` property in the Inspector to be your script.

The Inspector will now display your Resource script's custom properties. If one edits
those values and saves the resource, the Inspector serializes the custom properties
too! To save a resource from the Inspector, click the Inspector's tools menu (top right),
and select "Save" or "Save As...".

If the script's language supports :ref:`script classes <doc_gdscript_basics_class_name>`,
then it streamlines the process. Defining a name for your script alone will add it to
the Inspector's creation dialog. This will auto-add your script to the Resource
object you create.

Let's see some examples.

.. tabs::
  .. code-tab:: gdscript GDScript

    # bot_stats.gd
    extends Resource
    export(int) var health
    export(Resource) var sub_resource
    export(Array, String) var strings

    # Make sure that every parameter has a default value. 
    # Otherwise, there will be problems with creating and editing
    # your resource via the inspector.
    func _init(p_health = 0, p_sub_resource = null, p_strings = []):
        health = p_health
        sub_resource = p_sub_resource
        strings = p_strings

    # bot.gd
    extends KinematicBody

    export(Resource) var stats

    func _ready():
        # Uses an implicit, duck-typed interface for any 'health'-compatible resources.
        if stats:
            print(stats.health) # Prints '10'.
  .. code-tab:: csharp

        // BotStats.cs
        using System;
        using Godot;

        namespace ExampleProject {
            public class BotStats : Resource
            {
                [Export]
                public int Health { get; set; }

                [Export]
                public Resource SubResource { get; set; }

                [Export]
                public String[] Strings { get; set; }

                // Make sure that every parameter has a default value. 
                // Otherwise, there will be problems with creating and editing
                // your resource via the inspector.
                public BotStats(int health = 0, Resource subResource = null, String[] strings = null)
                {
                    Health = health;
                    SubResource = subResource;
                    Strings = strings ?? new String[0];
                }
            }
        }

        // Bot.cs
        using System;
        using Godot;

        namespace ExampleProject {
            public class Bot : KinematicBody
            {
                [Export]
                public Resource Stats;

                public override void _Ready()
                {
                    if (Stats != null && Stats is BotStats botStats) {
                        GD.Print(botStats.Health); // Prints '10'.
                    }
                }
            }
        }

.. note::

    Resource scripts are similar to Unity's ScriptableObjects. The Inspector
    provides built-in support for custom resources. If desired though, users
    can even design their own Control-based tool scripts and combine them
    with an :ref:`EditorPlugin <class_EditorPlugin>` to create custom
    visualizations and editors for their data.

    Unreal Engine 4's DataTables and CurveTables are also easy to recreate with
    Resource scripts. DataTables are a String mapped to a custom struct, similar
    to a Dictionary mapping a String to a secondary custom Resource script.

    .. tabs::
      .. code-tab:: gdscript GDScript

        # bot_stats_table.gd
        extends Resource

        const BotStats = preload("bot_stats.gd")

        var data = {
            "GodotBot": BotStats.new(10), # Creates instance with 10 health.
            "DifferentBot": BotStats.new(20) # A different one with 20 health.
        }

        func _init():
            print(data)
      .. code-tab:: csharp

        using System;
        using Godot;

        public class BotStatsTable : Resource
        {
            private Godot.Dictionary<String, BotStats> _stats = new Godot.Dictionary<String, BotStats>();

            public BotStatsTable()
            {
                _stats["GodotBot"] = new BotStats(10); // Creates instance with 10 health.
                _stats["DifferentBot"] = new BotStats(20); // A different one with 20 health.
                GD.Print(_stats);
            }
        }

    Instead of just inlining the Dictionary values, one could also, alternatively...

    1. Import a table of values from a spreadsheet and generate these key-value pairs, or...

    2. Design a visualization within the editor and create a simple plugin that adds it
       to the Inspector when you open these types of Resources.

    CurveTables are the same thing, except mapped to an Array of float values
    or a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object.

.. warning::

    Beware that resource files (\*.tres/\*.res) will store the path of the script
    they use in the file. When loaded, they will fetch and load this script as an
    extension of their type. This means that trying to assign a subclass, i.e. an
    inner class of a script (such as using the ``class`` keyword in GDScript) won't
    work. Godot will not serialize the custom properties on the script subclass properly.

    In the example below, Godot would load the ``Node`` script, see that it doesn't
    extend ``Resource``, and then determine that the script failed to load for the
    Resource object since the types are incompatible.

    .. tabs::
      .. code-tab:: gdscript GDScript

        extends Node

        class MyResource:
            extends Resource
            export var value = 5

        func _ready():
            var my_res = MyResource.new()

            # This will NOT serialize the 'value' property.
            ResourceSaver.save("res://my_res.tres", my_res)
      .. code-tab:: csharp

        using System;
        using Godot;

        public class MyNode : Node
        {
            public class MyResource : Resource
            {
                [Export]
                public int Value { get; set; } = 5;
            }

            public override void _Ready()
            {
                var res = new MyResource();

                // This will NOT serialize the 'Value' property.
                ResourceSaver.Save("res://MyRes.tres", res);
            }
        }


===================================================
/. ./tutorials/scripting/singletons_autoload.rst
===================================================

.. _doc_singletons_autoload:

Singletons (AutoLoad)
=====================

Introduction
------------

Godot's scene system, while powerful and flexible, has a drawback: there is no
method for storing information (e.g. a player's score or inventory) that is
needed by more than one scene.

It's possible to address this with some workarounds, but they come with their
own limitations:

-  You can use a "master" scene that loads and unloads other scenes as
   its children. However, this means you can no longer run those scenes
   individually and expect them to work correctly.
-  Information can be stored to disk in ``user://`` and then loaded by scenes
   that require it, but frequently saving and loading data is cumbersome and
   may be slow.

The `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ is
a useful tool for solving the common use case where you need to store
persistent information between scenes. In our case, it's possible to reuse the
same scene or class for multiple singletons as long as they have different
names.

Using this concept, you can create objects that:

- Are always loaded, no matter which scene is currently running.
- Can store global variables such as player information.
- Can handle switching scenes and between-scene transitions.
- *Act* like a singleton, since GDScript does not support global variables by design.

Autoloading nodes and scripts can give us these characteristics.

.. note::

    Godot won't make an AutoLoad a "true" singleton as per the singleton design
    pattern. It may still be instanced more than once by the user if desired.

.. tip::

    If you're creating an autoload as part of an editor plugin, consider
    :ref:`registering it automatically in the Project Settings <doc_making_plugins_autoload>`
    when the plugin is enabled.

AutoLoad
--------

You can create an AutoLoad to load a scene or a script that inherits from
:ref:`class_Node`.

.. note::

    When autoloading a script, a :ref:`class_Node` will be created and the script will be
    attached to it. This node will be added to the root viewport before any
    other scenes are loaded.

.. image:: img/singleton.png

To autoload a scene or script, select **Project > Project Settings** from the
menu and switch to the **AutoLoad** tab.

.. image:: img/autoload_tab.png

Here you can add any number of scenes or scripts. Each entry in the list
requires a name, which is assigned as the node's ``name`` property. The order of
the entries as they are added to the global scene tree can be manipulated using
the up/down arrow keys. Like regular scenes, the engine will read these nodes
in top-to-bottom order.

.. image:: img/autoload_example.png

This means that any node can access a singleton named "PlayerVariables" with:

.. tabs::
 .. code-tab:: gdscript GDScript

   var player_vars = get_node("/root/PlayerVariables")
   player_vars.health -= 10

 .. code-tab:: csharp

    var playerVariables = GetNode<PlayerVariables>("/root/PlayerVariables");
    playerVariables.Health -= 10; // Instance field.

If the **Enable** column is checked (which is the default), then the singleton can
be accessed directly without requiring ``get_node()``:

.. tabs::
 .. code-tab:: gdscript GDScript

   PlayerVariables.health -= 10

 .. code-tab:: csharp

    // Static members can be accessed by using the class name.
    PlayerVariables.Health -= 10;

Note that autoload objects (scripts and/or scenes) are accessed just like any
other node in the scene tree. In fact, if you look at the running scene tree,
you'll see the autoloaded nodes appear:

.. image:: img/autoload_runtime.png

.. warning::

    Autoloads must **not** be removed using ``free()`` or ``queue_free()`` at
    runtime, or the engine will crash.

Custom scene switcher
---------------------

This tutorial will demonstrate building a scene switcher using autoloads.
For basic scene switching, you can use the
:ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>`
method (see :ref:`doc_scene_tree` for details). However, if you need more
complex behavior when changing scenes, this method provides more functionality.

To begin, download the template from here:
:download:`autoload.zip <files/autoload.zip>` and open it in Godot.

The project contains two scenes: ``Scene1.tscn`` and ``Scene2.tscn``. Each
scene contains a label displaying the scene name and a button with its
``pressed()`` signal connected. When you run the project, it starts in
``Scene1.tscn``. However, pressing the button does nothing.

Global.gd
~~~~~~~~~

Switch to the **Script** tab and create a new script called ``Global.gd``.
Make sure it inherits from ``Node``:

.. image:: img/autoload_script.png

The next step is to add this script to the autoLoad list. Open
**Project > Project Settings** from the menu, switch to the **AutoLoad** tab and
select the script by clicking the browse button or typing its path:
``res://Global.gd``. Press **Add** to add it to the autoload list:

.. image:: img/autoload_tutorial1.png

Now whenever we run any scene in the project, this script will always be loaded.

Returning to the script, it needs to fetch the current scene in the
`_ready()` function. Both the current scene (the one with the button) and
``Global.gd`` are children of root, but autoloaded nodes are always first. This
means that the last child of root is always the loaded scene.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Node

    var current_scene = null

    func _ready():
        var root = get_tree().root
        current_scene = root.get_child(root.get_child_count() - 1)

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Global : Godot.Node
    {
        public Node CurrentScene { get; set; }

        public override void _Ready()
        {
            Viewport root = GetTree().Root;
            CurrentScene = root.GetChild(root.GetChildCount() - 1);
        }
    }

Now we need a function for changing the scene. This function needs to free the
current scene and replace it with the requested one.

.. tabs::
 .. code-tab:: gdscript GDScript

    func goto_scene(path):
        # This function will usually be called from a signal callback,
        # or some other function in the current scene.
        # Deleting the current scene at this point is
        # a bad idea, because it may still be executing code.
        # This will result in a crash or unexpected behavior.

        # The solution is to defer the load to a later time, when
        # we can be sure that no code from the current scene is running:

        call_deferred("_deferred_goto_scene", path)


    func _deferred_goto_scene(path):
        # It is now safe to remove the current scene
        current_scene.free()

        # Load the new scene.
        var s = ResourceLoader.load(path)

        # Instance the new scene.
        current_scene = s.instance()

        # Add it to the active scene, as child of root.
        get_tree().root.add_child(current_scene)

        # Optionally, to make it compatible with the SceneTree.change_scene() API.
        get_tree().current_scene = current_scene

 .. code-tab:: csharp

    public void GotoScene(string path)
    {
        // This function will usually be called from a signal callback,
        // or some other function from the current scene.
        // Deleting the current scene at this point is
        // a bad idea, because it may still be executing code.
        // This will result in a crash or unexpected behavior.

        // The solution is to defer the load to a later time, when
        // we can be sure that no code from the current scene is running:

        CallDeferred(nameof(DeferredGotoScene), path);
    }

    public void DeferredGotoScene(string path)
    {
        // It is now safe to remove the current scene
        CurrentScene.Free();

        // Load a new scene.
        var nextScene = (PackedScene)GD.Load(path);

        // Instance the new scene.
        CurrentScene = nextScene.Instance();

        // Add it to the active scene, as child of root.
        GetTree().Root.AddChild(CurrentScene);

        // Optionally, to make it compatible with the SceneTree.change_scene() API.
        GetTree().CurrentScene = CurrentScene;
    }

Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`,
the second function will only run once all code from the current scene has
completed. Thus, the current scene will not be removed while it is
still being used (i.e. its code is still running).

Finally, we need to fill the empty callback functions in the two scenes:

.. tabs::
 .. code-tab:: gdscript GDScript

    # Add to 'Scene1.gd'.

    func _on_Button_pressed():
        Global.goto_scene("res://Scene2.tscn")

 .. code-tab:: csharp

    // Add to 'Scene1.cs'.

    public void OnButtonPressed()
    {
        var global = GetNode<Global>("/root/Global");
        global.GotoScene("res://Scene2.tscn");
    }

and

.. tabs::
 .. code-tab:: gdscript GDScript

    # Add to 'Scene2.gd'.

    func _on_Button_pressed():
        Global.goto_scene("res://Scene1.tscn")

 .. code-tab:: csharp

    // Add to 'Scene2.cs'.

    public void OnButtonPressed()
    {
        var global = GetNode<Global>("/root/Global");
        global.GotoScene("res://Scene1.tscn");
    }

Run the project and test that you can switch between scenes by pressing
the button.

.. note::

    When scenes are small, the transition is instantaneous. However, if your
    scenes are more complex, they may take a noticeable amount of time to appear.
    To learn how to handle this, see the next tutorial: :ref:`doc_background_loading`.

    Alternatively, if the loading time is relatively short (less than 3 seconds or so),
    you can display a "loading plaque" by showing some kind of 2D element just before
    changing the scene. You can then hide it just after the scene is changed. This can
    be used to indicate to the player that a scene is being loaded.


===================================================
/. ./tutorials/scripting/scene_tree.rst
===================================================

.. _doc_scene_tree:

Using SceneTree
===============

Introduction
------------

In previous tutorials, everything revolved around the concept of
nodes. Scenes are collections of nodes. They become active once
they enter the *scene tree*.

MainLoop
--------

The way Godot works internally is as follows. There is the
:ref:`OS <class_OS>` class,
which is the only instance that runs at the beginning. Afterwards, all
drivers, servers, scripting languages, scene system, etc are loaded.

When initialization is complete, :ref:`OS <class_OS>` needs to be
supplied a :ref:`MainLoop <class_MainLoop>`
to run. Up to this point, all this is internals working (you can check
main/main.cpp file in the source code if you are ever interested to
see how this works internally).

The user program, or game, starts in the MainLoop. This class has a few
methods, for initialization, idle (frame-synchronized callback), fixed
(physics-synchronized callback), and input. Again, this is low
level and when making games in Godot, writing your own MainLoop seldom makes sense.

SceneTree
---------

One of the ways to explain how Godot works is that it's a high level
game engine over a low level middleware.

The scene system is the game engine, while the :ref:`OS <class_OS>`
and servers are the low level API.

The scene system provides its own main loop to OS,
:ref:`SceneTree <class_SceneTree>`.
This is automatically instanced and set when running a scene, no need
to do any extra work.

It's important to know that this class exists because it has a few
important uses:

-  It contains the root :ref:`Viewport <class_Viewport>`, to which a
   scene is added as a child when it's first opened to become
   part of the *Scene Tree* (more on that next).
-  It contains information about the groups and has the means to call all
   nodes in a group or get a list of them.
-  It contains some global state functionality, such as setting pause
   mode or quitting the process.

When a node is part of the Scene Tree, the
:ref:`SceneTree <class_SceneTree>`
singleton can be obtained by calling
:ref:`Node.get_tree() <class_Node_method_get_tree>`.

Root viewport
-------------

The root :ref:`Viewport <class_Viewport>`
is always at the top of the scene. From a node, it can be obtained in
two different ways:

.. tabs::
 .. code-tab:: gdscript GDScript

        get_tree().get_root() # Access via scene main loop.
        get_node("/root") # Access via absolute path.

 .. code-tab:: csharp

        GetTree().GetRoot(); // Access via scene main loop.
        GetNode("/root"); // Access via absolute path.

This node contains the main viewport. Anything that is a child of a
:ref:`Viewport <class_Viewport>`
is drawn inside of it by default, so it makes sense that the top of all
nodes is always a node of this type otherwise nothing would be seen.

While other viewports can be created in the scene (for split-screen
effects and such), this one is the only one that is never created by the
user. It's created automatically inside SceneTree.

Scene tree
----------

When a node is connected, directly or indirectly, to the root
viewport, it becomes part of the *scene tree*.

This means that as explained in previous tutorials, it will get the
``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``).

.. image:: img/activescene.png

When nodes enter the *Scene Tree*, they become active. They get access
to everything they need to process, get input, display 2D and 3D visuals,
receive and send notifications, play sounds, etc. When they are removed from the
*scene tree*, they lose these abilities.

Tree order
----------

Most node operations in Godot, such as drawing 2D, processing, or getting
notifications are done in tree order. This means that parents and
siblings with a lower rank in the tree order will get notified before
the current node.

.. image:: img/toptobottom.png

"Becoming active" by entering the *Scene Tree*
----------------------------------------------

#. A scene is loaded from disk or created by scripting.
#. The root node of that scene (only one root, remember?) is added as
   either a child of the "root" Viewport (from SceneTree), or to any
   child or grandchild of it.
#. Every node of the newly added scene, will receive the "enter_tree"
   notification ( _enter_tree() callback in GDScript) in top-to-bottom
   order.
#. An extra notification, "ready" ( _ready() callback in GDScript) is
   provided for convenience, when a node and all its children are
   inside the active scene.
#. When a scene (or part of it) is removed, they receive the "exit
   scene" notification ( _exit_tree() callback in GDScript) in
   bottom-to-top order

Changing current scene
----------------------

After a scene is loaded, it is often desired to change this scene for
another one. The simple way to do this is to use the
:ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>`
function:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _my_level_was_completed():
        get_tree().change_scene("res://levels/level2.tscn")

 .. code-tab:: csharp

    public void _MyLevelWasCompleted()
    {
        GetTree().ChangeScene("res://levels/level2.tscn");
    }

Rather than using file paths, one can also use ready-made
:ref:`PackedScene <class_PackedScene>` resources using the equivalent
function
:ref:`SceneTree.change_scene_to(PackedScene scene) <class_SceneTree_method_change_scene_to>`:

.. tabs::
 .. code-tab:: gdscript GDScript

    var next_scene = preload("res://levels/level2.tscn")

    func _my_level_was_completed():
    	get_tree().change_scene_to(next_scene)

 .. code-tab:: csharp

    public void _MyLevelWasCompleted()
    {
        var nextScene = (PackedScene)ResourceLoader.Load("res://levels/level2.tscn");
        GetTree().ChangeSceneTo(nextScene);
    }

These are quick and useful ways to switch scenes but have the drawback
that the game will stall until the new scene is loaded and running. At
some point in the development of your game, it may be preferable to create proper loading
screens with progress bar, animated indicators or thread (background)
loading. This must be done manually using autoloads (see next chapter)
and :ref:`doc_background_loading`.


===================================================
/. ./tutorials/scripting/scene_unique_nodes.rst
===================================================

.. _doc_scene_unique_nodes:

Scene Unique Nodes
==================

Introduction
------------

There are times in a project where a node needs to be called
from a script. However, its position in the tree might change
over time as adjustments are made to a scene, such as a
button in a UI scene.

In situations like this, a node can be turned into a scene
unique node to avoid having to update a script every time
its path is changed.

Creating and using them
-----------------------

In the Scene tree dock, right-click on a node and select
**Access as Scene Unique Name** in the context menu.

.. image:: img/unique_name.png

After checking this, the node will now have a percent symbol (**%**) next
to its name in the scene tree:

.. image:: img/percent.png

To use a unique node in a script, use the ``%`` symbol and the node's
name in the path for ``get_node()``. For example:

.. tabs::
 .. code-tab:: gdscript GDScript

    get_node("%RedButton").text = "Hello"


===================================================
/. ./tutorials/shaders/index.rst
===================================================

Shaders
=======

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-shading

   introduction_to_shaders
   shader_reference/index
   your_first_shader/index
   shader_materials
   visual_shaders
   screen-reading_shaders
   converting_glsl_to_godot_shaders
   shaders_style_guide
   advanced_postprocessing
   using_viewport_as_texture
   custom_postprocessing
   making_trees


===================================================
/. ./tutorials/shaders/introduction_to_shaders.rst
===================================================

.. _doc_introduction_to_shaders:

Introduction to shaders
=======================

This page explains what shaders are and will give you an overview of how they
work in Godot. For a detailed reference of the engine's shading language, see
:ref:`doc_shading_language`.

Shaders are a special kind of program that runs on Graphics Processing Units
(GPUs). They were initially used to shade 3D scenes but can nowadays do much
more. You can use them to control how the engine draws geometry and pixels on
the screen, allowing you to achieve all sorts of effects.

Modern rendering engines like Godot draw everything with shaders: graphics cards
can run thousands of instructions in parallel, leading to incredible rendering
speed.

Because of their parallel nature, though, shaders don't process information the
way a typical program does. Shader code runs on each vertex or pixel in
isolation. You cannot store data between frames either. As a result, when
working with shaders, you need to code and think differently from other
programming languages.

Suppose you want to update all the pixels in a texture to a given color. In
GDScript, your code would use ``for`` loops::

  for x in range(width):
    for y in range(height):
      set_color(x, y, some_color)

Your code is already part of a loop in a shader, so the corresponding code would
look like this.

.. code-block:: glsl

  void fragment() {
    COLOR = some_color;
  }

.. note::

   The graphics card calls the ``fragment()`` function once or more for each pixel it has to draw. More on that below.

Shaders in Godot
----------------

Godot provides a shading language based on the popular OpenGL Shading Language
(GLSL) but simplified. The engine handles some of the lower-level initialization
work for you, making it easier to write complex shaders.

In Godot, shaders are made up of three main functions: ``vertex()``,
``fragment()``, and ``light()``.

1. The ``vertex()`` function runs over all the vertices in the mesh and sets
   their positions and some other per-vertex variables.

2. The ``fragment()`` function runs for every pixel covered by the mesh. It uses
   values output by the ``vertex()`` function, interpolated between the
   vertices.

3. The ``light()`` function runs for every pixel and for every light. It takes
   variables from the ``fragment()`` function and from its previous runs.

.. warning::

    The ``light()`` function won't run if the ``vertex_lighting`` render mode is
    enabled, or if **Rendering > Quality > Shading > Force Vertex Shading** is
    enabled in the Project Settings. It's enabled by default on mobile
    platforms.

Shader types
------------

Instead of supplying a general-purpose configuration for all uses (2D, 3D,
particles), you must specify the type of shader you're writing. Different types
support different render modes, built-in variables, and processing functions.

In Godot, all shaders need to specify their type in the first line, like so:

.. code-block:: glsl

    shader_type spatial;

Here are the available types:

* :ref:`spatial <doc_spatial_shader>` for 3D rendering.
* :ref:`canvas_item <doc_canvas_item_shader>` for 2D rendering.
* :ref:`particles <doc_particle_shader>` for particle systems.

Render modes
------------

Shaders have optional render modes you can specify on the second line, after the
shader type, like so:

.. code-block:: glsl

    shader_type spatial;
    render_mode unshaded, cull_disabled;

Render modes alter the way Godot applies the shader. For example, the
``unshaded`` mode makes the engine skip the built-in light processor function.

Each shader type has different render modes. See the reference for each shader
type for a complete list of render modes.

Processor functions
-------------------

Depending on the shader type, you can override different processor functions.
For ``spatial`` and ``canvas_item``, you have access to ``vertex()``,
``fragment()``, and ``light()``. For ``particles``, you only have access to
``vertex()``.

Vertex processor
^^^^^^^^^^^^^^^^

The ``vertex()`` processing function is called once for every vertex in
``spatial`` and ``canvas_item`` shaders. For ``particles`` shaders, it is called
once for every particle.

Each vertex in your world's geometry has properties like a position and color.
The function modifies those values and passes them to the fragment function. You
can also use it to send extra data to the fragment function using varyings.

By default, Godot transforms your vertex information for you, which is necessary
to project geometry onto the screen. You can use render modes to transform the
data yourself; see the :ref:`Spatial shader doc <doc_spatial_shader>` for an
example.

Fragment processor
^^^^^^^^^^^^^^^^^^

The ``fragment()`` processing function is used to set up the Godot material
parameters per pixel. This code runs on every visible pixel the object or
primitive draws. It is only available in ``spatial`` and ``canvas_item`` shaders.

The standard use of the fragment function is to set up material properties used
to calculate lighting. For example, you would set values for ``ROUGHNESS``,
``RIM``, or ``TRANSMISSION``, which would tell the light function how the lights
respond to that fragment. This makes it possible to control a complex shading
pipeline without the user having to write much code. If you don't need this
built-in functionality, you can ignore it and write your own light processing
function, and Godot will optimize it away. For example, if you do not write a
value to ``RIM``, Godot will not calculate rim lighting. During compilation,
Godot checks to see if ``RIM`` is used; if not, it cuts all the corresponding
code out. Therefore, you will not waste calculations on the effects that you do
not use.

Light processor
^^^^^^^^^^^^^^^

The ``light()`` processor runs per pixel too, and it runs once for every light
that affects the object. It does not run if no lights affect the object. It
exists as a function called inside the ``fragment()`` processor and typically
operates on the material properties setup inside the ``fragment()`` function.

The ``light()`` processor works differently in 2D than it does in 3D; for a
description of how it works in each, see their documentation, :ref:`CanvasItem
shaders <doc_canvas_item_shader>` and :ref:`Spatial shaders
<doc_spatial_shader>`, respectively.


===================================================
/. ./tutorials/shaders/shader_reference/index.rst
===================================================

Shading reference
=================

.. toctree::
   :maxdepth: 1
   :name: toc-shading-reference

   shading_language
   spatial_shader
   canvas_item_shader
   particle_shader


===================================================
/. ./tutorials/shaders/shader_reference/shading_language.rst
===================================================

.. _doc_shading_language:

Shading language
================

Introduction
------------

Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and functions are supported,
and the few remaining ones will likely be added over time.

If you are already familiar with GLSL, the :ref:`Godot Shader Migration Guide<doc_converting_glsl_to_godot_shaders>`
is a resource that will help you transition from regular GLSL to Godot's shading language.

Data types
----------

Most GLSL ES 3.0 datatypes are supported:

+---------------------+---------------------------------------------------------------------------------+
| Type                | Description                                                                     |
+=====================+=================================================================================+
| **void**            | Void datatype, useful only for functions that return nothing.                   |
+---------------------+---------------------------------------------------------------------------------+
| **bool**            | Boolean datatype, can only contain ``true`` or ``false``.                       |
+---------------------+---------------------------------------------------------------------------------+
| **bvec2**           | Two-component vector of booleans.                                               |
+---------------------+---------------------------------------------------------------------------------+
| **bvec3**           | Three-component vector of booleans.                                             |
+---------------------+---------------------------------------------------------------------------------+
| **bvec4**           | Four-component vector of booleans.                                              |
+---------------------+---------------------------------------------------------------------------------+
| **int**             | Signed scalar integer.                                                          |
+---------------------+---------------------------------------------------------------------------------+
| **ivec2**           | Two-component vector of signed integers.                                        |
+---------------------+---------------------------------------------------------------------------------+
| **ivec3**           | Three-component vector of signed integers.                                      |
+---------------------+---------------------------------------------------------------------------------+
| **ivec4**           | Four-component vector of signed integers.                                       |
+---------------------+---------------------------------------------------------------------------------+
| **uint**            | Unsigned scalar integer; can't contain negative numbers.                        |
+---------------------+---------------------------------------------------------------------------------+
| **uvec2**           | Two-component vector of unsigned integers.                                      |
+---------------------+---------------------------------------------------------------------------------+
| **uvec3**           | Three-component vector of unsigned integers.                                    |
+---------------------+---------------------------------------------------------------------------------+
| **uvec4**           | Four-component vector of unsigned integers.                                     |
+---------------------+---------------------------------------------------------------------------------+
| **float**           | Floating-point scalar.                                                          |
+---------------------+---------------------------------------------------------------------------------+
| **vec2**            | Two-component vector of floating-point values.                                  |
+---------------------+---------------------------------------------------------------------------------+
| **vec3**            | Three-component vector of floating-point values.                                |
+---------------------+---------------------------------------------------------------------------------+
| **vec4**            | Four-component vector of floating-point values.                                 |
+---------------------+---------------------------------------------------------------------------------+
| **mat2**            | 2x2 matrix, in column major order.                                              |
+---------------------+---------------------------------------------------------------------------------+
| **mat3**            | 3x3 matrix, in column major order.                                              |
+---------------------+---------------------------------------------------------------------------------+
| **mat4**            | 4x4 matrix, in column major order.                                              |
+---------------------+---------------------------------------------------------------------------------+
| **sampler2D**       | Sampler type for binding 2D textures, which are read as float.                  |
+---------------------+---------------------------------------------------------------------------------+
| **isampler2D**      | Sampler type for binding 2D textures, which are read as signed integer.         |
+---------------------+---------------------------------------------------------------------------------+
| **usampler2D**      | Sampler type for binding 2D textures, which are read as unsigned integer.       |
+---------------------+---------------------------------------------------------------------------------+
| **sampler2DArray**  | Sampler type for binding 2D texture arrays, which are read as float.            |
+---------------------+---------------------------------------------------------------------------------+
| **isampler2DArray** | Sampler type for binding 2D texture arrays, which are read as signed integer.   |
+---------------------+---------------------------------------------------------------------------------+
| **usampler2DArray** | Sampler type for binding 2D texture arrays, which are read as unsigned integer. |
+---------------------+---------------------------------------------------------------------------------+
| **sampler3D**       | Sampler type for binding 3D textures, which are read as float.                  |
+---------------------+---------------------------------------------------------------------------------+
| **isampler3D**      | Sampler type for binding 3D textures, which are read as signed integer.         |
+---------------------+---------------------------------------------------------------------------------+
| **usampler3D**      | Sampler type for binding 3D textures, which are read as unsigned integer.       |
+---------------------+---------------------------------------------------------------------------------+
| **samplerCube**     | Sampler type for binding Cubemaps, which are read as floats.                    |
+---------------------+---------------------------------------------------------------------------------+

Casting
~~~~~~~

Just like GLSL ES 3.0, implicit casting between scalars and vectors of the same size but different type is not allowed.
Casting of types of different size is also not allowed. Conversion must be done explicitly via constructors.

Example:

.. code-block:: glsl

    float a = 2; // invalid
    float a = 2.0; // valid
    float a = float(2); // valid

Default integer constants are signed, so casting is always needed to convert to unsigned:

.. code-block:: glsl

    int a = 2; // valid
    uint a = 2; // invalid
    uint a = uint(2); // valid

Members
~~~~~~~

Individual scalar members of vector types are accessed via the "x", "y", "z" and "w" members.
Alternatively, using "r", "g", "b" and "a" also works and is equivalent. Use whatever fits
best for your needs.

For matrices, use the ``m[column][row]`` indexing syntax to access each scalar,
or ``m[idx]`` to access a vector by row index. For example, for accessing the y
position of an object in a mat4 you use ``m[3][1]``.

Constructing
~~~~~~~~~~~~

Construction of vector types must always pass:

.. code-block:: glsl

    // The required amount of scalars
    vec4 a = vec4(0.0, 1.0, 2.0, 3.0);
    // Complementary vectors and/or scalars
    vec4 a = vec4(vec2(0.0, 1.0), vec2(2.0, 3.0));
    vec4 a = vec4(vec3(0.0, 1.0, 2.0), 3.0);
    // A single scalar for the whole vector
    vec4 a = vec4(0.0);

Construction of matrix types requires vectors of the same dimension as the matrix. You can
also build a diagonal matrix using ``matx(float)`` syntax. Accordingly, ``mat4(1.0)`` is
an identity matrix.

.. code-block:: glsl

    mat2 m2 = mat2(vec2(1.0, 0.0), vec2(0.0, 1.0));
    mat3 m3 = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));
    mat4 identity = mat4(1.0);

Matrices can also be built from a matrix of another dimension.
There are two rules :
If a larger matrix is constructed from a smaller matrix, the additional rows and columns are
set to the values they would have in an identity matrix. If a smaller matrix is constructed
from a larger matrix, the top, left submatrix of the larger matrix is used.

.. code-block:: glsl

	mat3 basis = mat3(WORLD_MATRIX);
	mat4 m4 = mat4(basis);
	mat2 m2 = mat2(m4);

Swizzling
~~~~~~~~~

It is possible to obtain any combination of components in any order, as long as the result
is another vector type (or scalar). This is easier shown than explained:

.. code-block:: glsl

    vec4 a = vec4(0.0, 1.0, 2.0, 3.0);
    vec3 b = a.rgb; // Creates a vec3 with vec4 components.
    vec3 b = a.ggg; // Also valid; creates a vec3 and fills it with a single vec4 component.
    vec3 b = a.bgr; // "b" will be vec3(2.0, 1.0, 0.0).
    vec3 b = a.xyz; // Also rgba, xyzw are equivalent.
    vec3 b = a.stp; // And stpq (for texture coordinates).
    float c = b.w; // Invalid, because "w" is not present in vec3 b.
    vec3 c = b.xrt; // Invalid, mixing different styles is forbidden.
    b.rrr = a.rgb; // Invalid, assignment with duplication.
    b.bgr = a.rgb; // Valid assignment. "b"'s "blue" component will be "a"'s "red" and vice versa.

Precision
~~~~~~~~~

It is possible to add precision modifiers to datatypes; use them for uniforms, variables, arguments and varyings:

.. code-block:: glsl

    lowp vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // low precision, usually 8 bits per component mapped to 0-1
    mediump vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // medium precision, usually 16 bits or half float
    highp vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // high precision, uses full float or integer range (default)


Using lower precision for some operations can speed up the math involved (at the cost of less precision).
This is rarely needed in the vertex processor function (where full precision is needed most of the time),
but is often useful in the fragment processor.

Some architectures (mainly mobile) can benefit significantly from this, but
there are downsides such as the additional overhead of conversion between
precisions. Refer to the documentation of the target architecture for further
information. In many cases, mobile drivers cause inconsistent or unexpected
behavior and it is best to avoid specifying precision unless necessary.

Arrays
------

Arrays are containers for multiple variables of a similar type.
Note: As of Godot 3.2, only local and varying arrays have been implemented.

Local arrays
~~~~~~~~~~~~

Local arrays are declared in functions. They can use all of the allowed datatypes, except samplers.
The array declaration follows a C-style syntax: ``[const] + [precision] + typename + identifier + [array size]``.

.. code-block:: glsl

    void fragment() {
        float arr[3];
    }

They can be initialized at the beginning like:

.. code-block:: glsl

    float float_arr[3] = float[3] (1.0, 0.5, 0.0); // first constructor

    int int_arr[3] = int[] (2, 1, 0); // second constructor

    vec2 vec2_arr[3] = { vec2(1.0, 1.0), vec2(0.5, 0.5), vec2(0.0, 0.0) }; // third constructor

    bool bool_arr[] = { true, true, false }; // fourth constructor - size is defined automatically from the element count

You can declare multiple arrays (even with different sizes) in one expression:

.. code-block:: glsl

    float a[3] = float[3] (1.0, 0.5, 0.0),
    b[2] = { 1.0, 0.5 },
    c[] = { 0.7 },
    d = 0.0,
    e[5];

To access an array element, use the indexing syntax:

.. code-block:: glsl

    float arr[3];

    arr[0] = 1.0; // setter

    COLOR.r = arr[0]; // getter

Arrays also have a built-in function ``.length()`` (not to be confused with the built-in ``length()`` function). It doesn't accept any parameters and will return the array's size.

.. code-block:: glsl

    float arr[] = { 0.0, 1.0, 0.5, -1.0 };
    for (int i = 0; i < arr.length(); i++) {
        // ...
    }

.. note::

    If you use an index below 0 or greater than array size - the shader will crash and break rendering. To prevent this, use ``length()``, ``if``, or ``clamp()`` functions to ensure the index is between 0 and the array's length. Always carefully test and check your code. If you pass a constant expression or a simple number, the editor will check its bounds to prevent this crash.

Constants
---------

Use the ``const`` keyword before the variable declaration to make that variable immutable, which means that it cannot be modified. All basic types, except samplers can be declared as constants. Accessing and using a constant value is slightly faster than using a uniform. Constants must be initialized at their declaration.

.. code-block:: glsl

    const vec2 a = vec2(0.0, 1.0);
    vec2 b;

    a = b; // invalid
    b = a; // valid

Constants cannot be modified and additionally cannot have hints, but multiple of them (if they have the same type) can be declared in a single expression e.g

.. code-block:: glsl

    const vec2 V1 = vec2(1, 1), V2 = vec2(2, 2);

Similar to variables, arrays can also be declared with ``const``.

.. code-block:: glsl

    const float arr[] = { 1.0, 0.5, 0.0 };

    arr[0] = 1.0; // invalid

    COLOR.r = arr[0]; // valid

Constants can be declared both globally (outside of any function) or locally (inside a function).
Global constants are useful when you want to have access to a value throughout your shader that does not need to be modified. Like uniforms, global constants are shared between all shader stages, but they are not accessible outside of the shader.

.. code-block:: glsl

    shader_type spatial;

    const float PI = 3.14159265358979323846;

Operators
---------

Godot shading language supports the same set of operators as GLSL ES 3.0. Below is the list of them in precedence order:

+-------------+------------------------+------------------+
| Precedence  | Class                  | Operator         |
+-------------+------------------------+------------------+
| 1 (highest) | parenthetical grouping | **()**           |
+-------------+------------------------+------------------+
| 2           | unary                  | **+, -, !, ~**   |
+-------------+------------------------+------------------+
| 3           | multiplicative         | **/, \*, %**     |
+-------------+------------------------+------------------+
| 4           | additive               | **+, -**         |
+-------------+------------------------+------------------+
| 5           | bit-wise shift         | **<<, >>**       |
+-------------+------------------------+------------------+
| 6           | relational             | **<, >, <=, >=** |
+-------------+------------------------+------------------+
| 7           | equality               | **==, !=**       |
+-------------+------------------------+------------------+
| 8           | bit-wise AND           | **&**            |
+-------------+------------------------+------------------+
| 9           | bit-wise exclusive OR  | **^**            |
+-------------+------------------------+------------------+
| 10          | bit-wise inclusive OR  | **|**            |
+-------------+------------------------+------------------+
| 11          | logical AND            | **&&**           |
+-------------+------------------------+------------------+
| 12 (lowest) | logical inclusive OR   | **||**           |
+-------------+------------------------+------------------+

Flow control
------------

Godot Shading language supports the most common types of flow control:

.. code-block:: glsl

    // if and else
    if (cond) {

    } else {

    }

    // switch
    switch(i) { // signed integer expression
        case -1:
            break;
        case 0:
            return; // break or return
        case 1: // pass-through
        case 2:
            break;
        //...
        default: // optional
            break;
    }

    // for loops
    for (int i = 0; i < 10; i++) {

    }

    // while
    while (true) {

    }

    // do while
    do {

    } while(true);

Keep in mind that, in modern GPUs, an infinite loop can exist and can freeze your application (including editor).
Godot can't protect you from this, so be careful not to make this mistake!

.. warning::

    When exporting a GLES2 project to HTML5, WebGL 1.0 will be used. WebGL 1.0
    doesn't support dynamic loops, so shaders using those won't work there.

Discarding
----------

Fragment and light functions can use the **discard** keyword. If used, the fragment is discarded and nothing is written.

Functions
---------

It is possible to define functions in a Godot shader. They use the following syntax:

.. code-block:: glsl

    ret_type func_name(args) {
        return ret_type; // if returning a value
    }

    // a more specific example:

    int sum2(int a, int b) {
        return a + b;
    }


You can only use functions that have been defined above (higher in the editor) the function from which you are calling
them.

Function arguments can have special qualifiers:

* **in**: Means the argument is only for reading (default).
* **out**: Means the argument is only for writing.
* **inout**: Means the argument is fully passed via reference.

Example below:

.. code-block:: glsl

    void sum2(int a, int b, inout int result) {
        result = a + b;
    }

Varyings
~~~~~~~~

To send data from the vertex to the fragment (or light) processor function, *varyings* are
used. They are set for every primitive vertex in the *vertex processor*, and the
value is interpolated for every pixel in the *fragment processor*.

.. code-block:: glsl

    shader_type spatial;

    varying vec3 some_color;

    void vertex() {
        some_color = NORMAL; // Make the normal the color.
    }

    void fragment() {
        ALBEDO = some_color;
    }

    void light() {
        DIFFUSE_LIGHT = some_color * 100; // optionally
    }

Varying can also be an array:

.. code-block:: glsl

    shader_type spatial;

    varying float var_arr[3];

    void vertex() {
        var_arr[0] = 1.0;
        var_arr[1] = 0.0;
    }

    void fragment() {
        ALBEDO = vec3(var_arr[0], var_arr[1], var_arr[2]); // red color
    }

It's also possible to send data from *fragment* to *light* processors using *varying* keyword. To do so you can assign it in the *fragment* and later use it in the *light* function.

.. code-block:: glsl

    shader_type spatial;

    varying vec3 some_light;

    void fragment() {
        some_light = ALBEDO * 100.0; // Make a shining light.
    }

    void light() {
        DIFFUSE_LIGHT = some_light;
    }

Note that varying may not be assigned in custom functions or a *light processor* function like:

.. code-block:: glsl

    shader_type spatial;

    varying float test;

    void foo() {
        test = 0.0; // Error.
    }

    void vertex() {
        test = 0.0;
    }

    void light() {
        test = 0.0; // Error too.
    }

This limitation was introduced to prevent incorrect usage before initialization.

Interpolation qualifiers
~~~~~~~~~~~~~~~~~~~~~~~~

Certain values are interpolated during the shading pipeline. You can modify how these interpolations
are done by using *interpolation qualifiers*.

.. code-block:: glsl

    shader_type spatial;

    varying flat vec3 our_color;

    void vertex() {
        our_color = COLOR.rgb;
    }

    void fragment() {
        ALBEDO = our_color;
    }

There are two possible interpolation qualifiers:

+-------------------+---------------------------------------------------------------------------------+
| Qualifier         | Description                                                                     |
+===================+=================================================================================+
| **flat**          | The value is not interpolated.                                                  |
+-------------------+---------------------------------------------------------------------------------+
| **smooth**        | The value is interpolated in a perspective-correct fashion. This is the default.|
+-------------------+---------------------------------------------------------------------------------+


Uniforms
~~~~~~~~

Passing values to shaders is possible. These are global to the whole shader and are called *uniforms*.
When a shader is later assigned to a material, the uniforms will appear as editable parameters in it.
Uniforms can't be written from within the shader.

.. code-block:: glsl

    shader_type spatial;

    uniform float some_value;

You can set uniforms in the editor in the material. Or you can set them through GDScript:

::

  material.set_shader_param("some_value", some_value)

.. note:: The first argument to ``set_shader_param`` is the name of the uniform in the shader. It
          must match *exactly* to the name of the uniform in the shader or else it will not be recognized.

Any GLSL type except for *void* can be a uniform. Additionally, Godot provides
optional shader hints to make the compiler understand for what the uniform is
used, and how the editor should allow users to modify it.

.. code-block:: glsl

    shader_type spatial;

    uniform vec4 color : hint_color;
    uniform float amount : hint_range(0, 1);
    uniform vec4 other_color : hint_color = vec4(1.0);

It's important to understand that textures that are supplied as color require hints for proper sRGB->linear conversion (i.e. ``hint_albedo``), as Godot's 3D engine renders in linear color space.

Full list of hints below:

+----------------+------------------------------+------------------------------------------------------+
| Type           | Hint                         | Description                                          |
+================+==============================+======================================================+
| **vec4**       | hint_color                   | Used as color.                                       |
+----------------+------------------------------+------------------------------------------------------+
| **int, float** | hint_range(min, max[, step]) | Restricted to values in a range (with min/max/step). |
+----------------+------------------------------+------------------------------------------------------+
| **sampler2D**  | hint_albedo                  | Used as albedo color, default white.                 |
+----------------+------------------------------+------------------------------------------------------+
| **sampler2D**  | hint_black_albedo            | Used as albedo color, default black.                 |
+----------------+------------------------------+------------------------------------------------------+
| **sampler2D**  | hint_normal                  | Used as normalmap.                                   |
+----------------+------------------------------+------------------------------------------------------+
| **sampler2D**  | hint_white                   | As value, default to white.                          |
+----------------+------------------------------+------------------------------------------------------+
| **sampler2D**  | hint_black                   | As value, default to black                           |
+----------------+------------------------------+------------------------------------------------------+
| **sampler2D**  | hint_aniso                   | As flowmap, default to right.                        |
+----------------+------------------------------+------------------------------------------------------+

GDScript uses different variable types than GLSL does, so when passing variables from GDScript
to shaders, Godot converts the type automatically. Below is a table of the corresponding types:

+-----------------+-----------+
| GDScript type   | GLSL type |
+=================+===========+
| **bool**        | **bool**  |
+-----------------+-----------+
| **int**         | **int**   |
+-----------------+-----------+
| **float**       | **float** |
+-----------------+-----------+
| **Vector2**     | **vec2**  |
+-----------------+-----------+
| **Vector3**     | **vec3**  |
+-----------------+-----------+
| **Color**       | **vec4**  |
+-----------------+-----------+
| **Transform**   | **mat4**  |
+-----------------+-----------+
| **Transform2D** | **mat4**  |
+-----------------+-----------+

.. note:: Be careful when setting shader uniforms from GDScript, no error will be thrown if the
          type does not match. Your shader will just exhibit undefined behavior.

Uniforms can also be assigned default values:

.. code-block:: glsl

    shader_type spatial;

    uniform vec4 some_vector = vec4(0.0);
    uniform vec4 some_color : hint_color = vec4(1.0);

Built-in variables
------------------

A large number of built-in variables are available, like ``UV``, ``COLOR`` and ``VERTEX``. What variables are available depends on the type of shader (``spatial``, ``canvas_item`` or ``particle``) and the function used (``vertex``, ``fragment`` or ``light``).
For a list of the build-in variables that are available, please see the corresponding pages:

- :ref:`Spatial shaders <doc_spatial_shader>`
- :ref:`Canvas item shaders <doc_canvas_item_shader>`
- :ref:`Particle shaders <doc_particle_shader>`

Built-in functions
------------------

A large number of built-in functions are supported, conforming to GLSL ES 3.0.
When vec_type (float), vec_int_type, vec_uint_type, vec_bool_type nomenclature is used, it can be scalar or vector.

.. note:: For a list of the functions that are not available in the GLES2 backend, please see the
          :ref:`Differences between GLES2 and GLES3 doc <doc_gles2_gles3_differences>`.

+------------------------------------------------------------------------+---------------------------------------------------------------+
| Function                                                               | Description                                                   |
+========================================================================+===============================================================+
| vec_type **radians** (vec_type degrees)                                | Convert degrees to radians                                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **degrees** (vec_type radians)                                | Convert radians to degrees                                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **sin** (vec_type x)                                          | Sine                                                          |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **cos** (vec_type x)                                          | Cosine                                                        |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **tan** (vec_type x)                                          | Tangent                                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **asin** (vec_type x)                                         | Arcsine                                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **acos** (vec_type x)                                         | Arccosine                                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **atan** (vec_type y_over_x)                                  | Arctangent                                                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **atan** (vec_type y, vec_type x)                             | Arctangent to convert vector to angle                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **sinh** (vec_type x)                                         | Hyperbolic sine                                               |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **cosh** (vec_type x)                                         | Hyperbolic cosine                                             |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **tanh** (vec_type x)                                         | Hyperbolic tangent                                            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **asinh** (vec_type x)                                        | Inverse hyperbolic sine                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **acosh** (vec_type x)                                        | Inverse hyperbolic cosine                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **atanh** (vec_type x)                                        | Inverse hyperbolic tangent                                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **pow** (vec_type x, vec_type y)                              | Power (undefined if ``x`` < 0 or if ``x`` = 0 and ``y`` <= 0) |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **exp** (vec_type x)                                          | Base-e exponential                                            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **exp2** (vec_type x)                                         | Base-2 exponential                                            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **log** (vec_type x)                                          | Natural logarithm                                             |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **log2** (vec_type x)                                         | Base-2 logarithm                                              |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **sqrt** (vec_type x)                                         | Square root                                                   |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **inversesqrt** (vec_type x)                                  | Inverse square root                                           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **abs** (vec_type x)                                          | Absolute                                                      |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec_type **abs** (ivec_type x)                                        | Absolute                                                      |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **sign** (vec_type x)                                         | Sign                                                          |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec_type **sign** (ivec_type x)                                       | Sign                                                          |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **floor** (vec_type x)                                        | Floor                                                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **round** (vec_type x)                                        | Round                                                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **roundEven** (vec_type x)                                    | Round to the nearest even number                              |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **trunc** (vec_type x)                                        | Truncation                                                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **ceil** (vec_type x)                                         | Ceil                                                          |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **fract** (vec_type x)                                        | Fractional                                                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **mod** (vec_type x, vec_type y)                              | Remainder                                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **mod** (vec_type x , float y)                                | Remainder                                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **modf** (vec_type x, out vec_type i)                         | Fractional of ``x``, with ``i`` as integer part               |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type  **min** (vec_type a, vec_type b)                             | Minimum                                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type  **max** (vec_type a, vec_type b)                             | Maximum                                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **clamp** (vec_type x, vec_type min, vec_type max)            | Clamp to ``min..max``                                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| float **mix** (float a, float b, float c)                              | Linear interpolate                                            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **mix** (vec_type a, vec_type b, float c)                     | Linear interpolate (scalar coefficient)                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **mix** (vec_type a, vec_type b, vec_type c)                  | Linear interpolate (vector coefficient)                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **mix** (vec_type a, vec_type b, bvec_type c)                 | Linear interpolate (boolean-vector selection)                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **step** (vec_type a, vec_type b)                             | ``b[i] < a[i] ? 0.0 : 1.0``                                   |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **step** (float a, vec_type b)                                | ``b[i] < a ? 0.0 : 1.0``                                      |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)           | Hermite interpolate                                           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **smoothstep** (float a, float b, vec_type c)                 | Hermite interpolate                                           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **isnan** (vec_type x)                                       | Returns ``true`` if scalar or vector component is ``NaN``     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **isinf** (vec_type x)                                       | Returns ``true`` if scalar or vector component is ``INF``     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec_type **floatBitsToInt** (vec_type x)                              | Float->Int bit copying, no conversion                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| uvec_type **floatBitsToUint** (vec_type x)                             | Float->UInt bit copying, no conversion                        |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **intBitsToFloat** (ivec_type x)                              | Int->Float bit copying, no conversion                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **uintBitsToFloat** (uvec_type x)                             | UInt->Float bit copying, no conversion                        |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| float **length** (vec_type x)                                          | Vector length                                                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| float **distance** (vec_type a, vec_type b)                            | Distance between vectors i.e ``length(a - b)``                |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| float **dot** (vec_type a, vec_type b)                                 | Dot product                                                   |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec3 **cross** (vec3 a, vec3 b)                                        | Cross product                                                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **normalize** (vec_type x)                                    | Normalize to unit length                                      |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec3 **reflect** (vec3 I, vec3 N)                                      | Reflect                                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec3 **refract** (vec3 I, vec3 N, float eta)                           | Refract                                                       |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **faceforward** (vec_type N, vec_type I, vec_type Nref)       | If ``dot(Nref, I)`` < 0, return N, otherwise –N               |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| mat_type **matrixCompMult** (mat_type x, mat_type y)                   | Matrix component multiplication                               |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| mat_type **outerProduct** (vec_type column, vec_type row)              | Matrix outer product                                          |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| mat_type **transpose** (mat_type m)                                    | Transpose matrix                                              |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| float **determinant** (mat_type m)                                     | Matrix determinant                                            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| mat_type **inverse** (mat_type m)                                      | Inverse matrix                                                |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **lessThan** (vec_type x, vec_type y)                        | Bool vector comparison on < int/uint/float vectors            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **greaterThan** (vec_type x, vec_type y)                     | Bool vector comparison on > int/uint/float vectors            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **lessThanEqual** (vec_type x, vec_type y)                   | Bool vector comparison on <= int/uint/float vectors           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **greaterThanEqual** (vec_type x, vec_type y)                | Bool vector comparison on >= int/uint/float vectors           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **equal** (vec_type x, vec_type y)                           | Bool vector comparison on == int/uint/float vectors           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **notEqual** (vec_type x, vec_type y)                        | Bool vector comparison on != int/uint/float vectors           |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bool **any** (bvec_type x)                                             | Any component is ``true``                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bool **all** (bvec_type x)                                             | All components are ``true``                                   |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| bvec_type **not** (bvec_type x)                                        | Invert boolean vector                                         |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec2 **textureSize** (sampler2D_type s, int lod)                      | Get the size of a 2D texture                                  |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec3 **textureSize** (sampler2DArray_type s, int lod)                 | Get the size of a 2D texture array                            |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec3 **textureSize** (sampler3D s, int lod)                           | Get the size of a 3D texture                                  |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| ivec2 **textureSize** (samplerCube s, int lod)                         | Get the size of a cubemap texture                             |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **texture** (sampler2D_type s, vec2 uv [, float bias])       | Perform a 2D texture read                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type  **texture** (sampler2DArray_type s, vec3 uv [, float bias]) | Perform a 2D texture array read                               |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type  **texture** (sampler3D_type s, vec3 uv [, float bias])      | Perform a 3D texture read                                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4 **texture** (samplerCube s, vec3 uv [, float bias])               | Perform a cubemap texture read                                |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureProj** (sampler2D_type s, vec3 uv [, float bias])   | Perform a 2D texture read with projection                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureProj** (sampler2D_type s, vec4 uv [, float bias])   | Perform a 2D texture read with projection                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type  **textureProj** (sampler3D_type s, vec4 uv [, float bias])  | Perform a 3D texture read with projection                     |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureLod** (sampler2D_type s, vec2 uv, float lod)        | Perform a 2D texture read at custom mipmap                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureLod** (sampler2DArray_type s, vec3 uv, float lod)   | Perform a 2D texture array read at custom mipmap              |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureLod** (sampler3D_type s, vec3 uv, float lod)        | Perform a 3D texture read at custom mipmap                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4 **textureLod** (samplerCube s, vec3 uv, float lod)                | Perform a 3D texture read at custom mipmap                    |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureProjLod** (sampler2D_type s, vec3 uv, float lod)    | Perform a 2D texture read with projection/LOD                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureProjLod** (sampler2D_type s, vec4 uv, float lod)    | Perform a 2D texture read with projection/LOD                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **textureProjLod** (sampler3D_type s, vec4 uv, float lod)    | Perform a 3D texture read with projection/LOD                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **texelFetch** (sampler2D_type s, ivec2 uv, int lod)         | Fetch a single texel using integer coordinates                |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **texelFetch** (sampler2DArray_type s, ivec3 uv, int lod)    | Fetch a single texel using integer coordinates                |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec4_type **texelFetch** (sampler3D_type s, ivec3 uv, int lod)         | Fetch a single texel using integer coordinates                |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **dFdx** (vec_type p)                                         | Derivative in ``x`` using local differencing                  |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **dFdy** (vec_type p)                                         | Derivative in ``y`` using local differencing                  |
+------------------------------------------------------------------------+---------------------------------------------------------------+
| vec_type **fwidth** (vec_type p)                                       | Sum of absolute derivative in ``x`` and ``y``                 |
+------------------------------------------------------------------------+---------------------------------------------------------------+


===================================================
/. ./tutorials/shaders/shader_reference/spatial_shader.rst
===================================================

.. _doc_spatial_shader:

Spatial shaders
===============

Spatial shaders are used for shading 3D objects. They are the most complex type of shader Godot offers.
Spatial shaders are highly configurable with different render modes and different rendering options
(e.g. Subsurface Scattering, Transmission, Ambient Occlusion, Rim lighting etc). Users can optionally
write vertex, fragment, and light processor functions to affect how objects are drawn.

Render modes
^^^^^^^^^^^^

+---------------------------------+-----------------------------------------------------------------------+
| Render mode                     | Description                                                           |
+=================================+=======================================================================+
| **blend_mix**                   | Mix blend mode (alpha is transparency), default.                      |
+---------------------------------+-----------------------------------------------------------------------+
| **blend_add**                   | Additive blend mode.                                                  |
+---------------------------------+-----------------------------------------------------------------------+
| **blend_sub**                   | Subtractive blend mode.                                               |
+---------------------------------+-----------------------------------------------------------------------+
| **blend_mul**                   | Multiplicative blend mode.                                            |
+---------------------------------+-----------------------------------------------------------------------+
| **depth_draw_opaque**           | Only draw depth for opaque geometry (not transparent).                |
+---------------------------------+-----------------------------------------------------------------------+
| **depth_draw_always**           | Always draw depth (opaque and transparent).                           |
+---------------------------------+-----------------------------------------------------------------------+
| **depth_draw_never**            | Never draw depth.                                                     |
+---------------------------------+-----------------------------------------------------------------------+
| **depth_draw_alpha_prepass**    | Do opaque depth pre-pass for transparent geometry.                    |
+---------------------------------+-----------------------------------------------------------------------+
| **depth_test_disable**          | Disable depth testing.                                                |
+---------------------------------+-----------------------------------------------------------------------+
| **cull_front**                  | Cull front-faces.                                                     |
+---------------------------------+-----------------------------------------------------------------------+
| **cull_back**                   | Cull back-faces (default).                                            |
+---------------------------------+-----------------------------------------------------------------------+
| **cull_disabled**               | Culling disabled (double sided).                                      |
+---------------------------------+-----------------------------------------------------------------------+
| **unshaded**                    | Result is just albedo. No lighting/shading happens in material.       |
+---------------------------------+-----------------------------------------------------------------------+
| **diffuse_lambert**             | Lambert shading for diffuse (default).                                |
+---------------------------------+-----------------------------------------------------------------------+
| **diffuse_lambert_wrap**        | Lambert wrapping (roughness dependent) for diffuse.                   |
+---------------------------------+-----------------------------------------------------------------------+
| **diffuse_oren_nayar**          | Oren Nayar for diffuse.                                               |
+---------------------------------+-----------------------------------------------------------------------+
| **diffuse_burley**              | Burley (Disney PBS) for diffuse.                                      |
+---------------------------------+-----------------------------------------------------------------------+
| **diffuse_toon**                | Toon shading for diffuse.                                             |
+---------------------------------+-----------------------------------------------------------------------+
| **specular_schlick_ggx**        | Schlick-GGX for specular (default).                                   |
+---------------------------------+-----------------------------------------------------------------------+
| **specular_blinn**              | Blinn for specular (compatibility).                                   |
+---------------------------------+-----------------------------------------------------------------------+
| **specular_phong**              | Phong for specular (compatibility).                                   |
+---------------------------------+-----------------------------------------------------------------------+
| **specular_toon**               | Toon for specular.                                                    |
+---------------------------------+-----------------------------------------------------------------------+
| **specular_disabled**           | Disable specular.                                                     |
+---------------------------------+-----------------------------------------------------------------------+
| **skip_vertex_transform**       | VERTEX/NORMAL/etc. need to be transformed manually in vertex function.|
+---------------------------------+-----------------------------------------------------------------------+
| **world_vertex_coords**         | VERTEX/NORMAL/etc. are modified in world coordinates instead of local.|
+---------------------------------+-----------------------------------------------------------------------+
| **ensure_correct_normals**      | Use when non-uniform scale is applied to mesh.                        |
+---------------------------------+-----------------------------------------------------------------------+
| **vertex_lighting**             | Use vertex-based lighting.                                            |
+---------------------------------+-----------------------------------------------------------------------+
| **shadows_disabled**            | Disable computing shadows in shader.                                  |
+---------------------------------+-----------------------------------------------------------------------+
| **ambient_light_disabled**      | Disable contribution from ambient light and radiance map.             |
+---------------------------------+-----------------------------------------------------------------------+
| **shadow_to_opacity**           | Lighting modifies the alpha so shadowed areas are opaque and          |
|                                 | non-shadowed areas are transparent. Useful for overlaying shadows onto|
|                                 | a camera feed in AR.                                                  |
+---------------------------------+-----------------------------------------------------------------------+

Built-ins
^^^^^^^^^

Values marked as "in" are read-only. Values marked as "out" are for optional writing and will
not necessarily contain sensible values. Values marked as "inout" provide a sensible default
value, and can optionally be written to. Samplers are not subjects of writing and they are
not marked.

Global built-ins
^^^^^^^^^^^^^^^^

Global built-ins are available everywhere, including custom functions.

+-------------------+--------------------------+
| Built-in          | Description              |
+===================+==========================+
| in float **TIME** | Global time, in seconds. |
+-------------------+--------------------------+

Vertex built-ins
^^^^^^^^^^^^^^^^

Vertex data (``VERTEX``, ``NORMAL``, ``TANGENT``, ``BITANGENT``) are presented in local
model space. If not written to, these values will not be modified and be passed through
as they came.

They can optionally be presented in world space by using the *world_vertex_coords* render mode.

Users can disable the built-in modelview transform (projection will still happen later) and do
it manually with the following code:

.. code-block:: glsl

    shader_type spatial;
    render_mode skip_vertex_transform;

    void vertex() {
        VERTEX = (MODELVIEW_MATRIX * vec4(VERTEX, 1.0)).xyz;
        NORMAL = normalize((MODELVIEW_MATRIX * vec4(NORMAL, 0.0)).xyz);
        // same as above for binormal and tangent, if normal mapping is used
    }

Other built-ins, such as UV, UV2 and COLOR, are also passed through to the fragment function if not modified.

Users can override the modelview and projection transforms using the ``POSITION`` built-in. When ``POSITION`` is used,
the value from ``VERTEX`` is ignored and projection does not happen. However, the value passed to the fragment shader
still comes from ``VERTEX``.

For instancing, the INSTANCE_CUSTOM variable contains the instance custom data. When using particles, this information
is usually:

* **x**: Rotation angle in radians.
* **y**: Phase during lifetime (0 to 1).
* **z**: Animation frame.

This allows you to easily adjust the shader to a particle system using default particles material. When writing a custom particle
shader, this value can be used as desired.

+--------------------------------------+--------------------------------------------------------+
| Built-in                             | Description                                            |
+======================================+========================================================+
| in vec2 **VIEWPORT_SIZE**            | Size of viewport (in pixels).                          |
+--------------------------------------+--------------------------------------------------------+
| inout mat4 **WORLD_MATRIX**          | Model space to world space transform.                  |
+--------------------------------------+--------------------------------------------------------+
| in mat4 **INV_CAMERA_MATRIX**        | World space to view space transform.                   |
+--------------------------------------+--------------------------------------------------------+
| inout mat4 **PROJECTION_MATRIX**     | View space to clip space transform.                    |
+--------------------------------------+--------------------------------------------------------+
| in mat4 **CAMERA_MATRIX**            | View space to world space transform.                   |
+--------------------------------------+--------------------------------------------------------+
| inout mat4 **MODELVIEW_MATRIX**      | Model space to view space transform (use if possible). |
+--------------------------------------+--------------------------------------------------------+
| inout mat4 **INV_PROJECTION_MATRIX** | Clip space to view space transform.                    |
+--------------------------------------+--------------------------------------------------------+
| in vec3 **NODE_POSITION_WORLD**      | Node position, in world space.                         |
+--------------------------------------+--------------------------------------------------------+
| in vec3 **NODE_POSITION_VIEW**       | Node position, in view space.                          |
+--------------------------------------+--------------------------------------------------------+
| in vec3 **CAMERA_POSITION_WORLD**    | Camera position, in world space.                       |
+--------------------------------------+--------------------------------------------------------+
| in vec3 **CAMERA_DIRECTION_WORLD**   | Camera direction, in world space.                      |
+--------------------------------------+--------------------------------------------------------+
| inout vec3 **VERTEX**                | Vertex in local coordinates.                           |
+--------------------------------------+--------------------------------------------------------+
| in int **VERTEX_ID**                 | The index of the current vertex in the vertex buffer.  |
|                                      | Not supported in GLES2 (returns 0).                    |
+--------------------------------------+--------------------------------------------------------+
| out vec4 **POSITION**                | If written to, overrides final vertex position.        |
+--------------------------------------+--------------------------------------------------------+
| inout vec3 **NORMAL**                | Normal in local coordinates.                           |
+--------------------------------------+--------------------------------------------------------+
| inout vec3 **TANGENT**               | Tangent in local coordinates.                          |
+--------------------------------------+--------------------------------------------------------+
| inout vec3 **BINORMAL**              | Binormal in local coordinates.                         |
+--------------------------------------+--------------------------------------------------------+
| out float **ROUGHNESS**              | Roughness for vertex lighting.                         |
+--------------------------------------+--------------------------------------------------------+
| inout vec2 **UV**                    | UV main channel.                                       |
+--------------------------------------+--------------------------------------------------------+
| inout vec2 **UV2**                   | UV secondary channel.                                  |
+--------------------------------------+--------------------------------------------------------+
| in bool **OUTPUT_IS_SRGB**           | ``true`` when calculations happen in sRGB color space  |
|                                      | (``true`` in GLES2, ``false`` in GLES3).               |
+--------------------------------------+--------------------------------------------------------+
| inout vec4 **COLOR**                 | Color from vertices.                                   |
+--------------------------------------+--------------------------------------------------------+
| inout float **POINT_SIZE**           | Point size for point rendering.                        |
+--------------------------------------+--------------------------------------------------------+
| in int **INSTANCE_ID**               | Instance ID for instancing. Not supported in GLES2     |
|                                      | (returns 0).                                           |
+--------------------------------------+--------------------------------------------------------+
| in vec4 **INSTANCE_CUSTOM**          | Instance custom data (for particles, mostly).          |
+--------------------------------------+--------------------------------------------------------+

.. note::

    ``MODELVIEW_MATRIX`` combines both the ``WORLD_MATRIX`` and ``INV_CAMERA_MATRIX`` and is better suited when floating point issues may arise. For example, if the object is very far away from the world origin, you may run into floating point issues when using the seperated ``WORLD_MATRIX`` and ``INV_CAMERA_MATRIX``.

Fragment built-ins
^^^^^^^^^^^^^^^^^^

The default use of a Godot fragment processor function is to set up the material properties of your object
and to let the built-in renderer handle the final shading. However, you are not required to use all
these properties, and if you don't write to them, Godot will optimize away the corresponding functionality.

+-----------------------------------+--------------------------------------------------------------------------------------------------+
| Built-in                          | Description                                                                                      |
+===================================+==================================================================================================+
| in vec2 **VIEWPORT_SIZE**         | Size of viewport (in pixels).                                                                    |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec4 **FRAGCOORD**             | Coordinate of pixel center in screen space. ``xy`` specifies  position in window, ``z``          |
|                                   | specifies fragment depth if ``DEPTH`` is not used. Origin is lower-left.                         |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in mat4 **WORLD_MATRIX**          | Model space to world space transform.                                                            |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in mat4 **INV_CAMERA_MATRIX**     | World space to view space transform.                                                             |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in mat4 **CAMERA_MATRIX**         | View space to world space transform.                                                             |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in mat4 **PROJECTION_MATRIX**     | View space to clip space transform.                                                              |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in mat4 **INV_PROJECTION_MATRIX** | Clip space to view space transform.                                                              |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec3 **NODE_POSITION_WORLD**   | Node world space position.                                                                       |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec3 **NODE_POSITION_VIEW**    | Node view space position.                                                                        |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec3 **CAMERA_POSITION_WORLD** | Camera world space position.                                                                     |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec3 **CAMERA_DIRECTION_WORLD**| Camera world space direction.                                                                    |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec3 **VERTEX**                | Vertex that comes from vertex function (default, in view space).                                 |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec3 **VIEW**                  | Vector from camera to fragment position (in view space).                                         |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in bool **FRONT_FACING**          | ``true`` if current face is front face.                                                          |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| inout vec3 **NORMAL**             | Normal that comes from vertex function (default, in view space).                                 |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| inout vec3 **TANGENT**            | Tangent that comes from vertex function.                                                         |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| inout vec3 **BINORMAL**           | Binormal that comes from vertex function.                                                        |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out vec3 **NORMALMAP**            | Set normal here if reading normal from a texture instead of NORMAL.                              |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **NORMALMAP_DEPTH**     | Depth from variable above. Defaults to 1.0.                                                      |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec2 **UV**                    | UV that comes from vertex function.                                                              |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec2 **UV2**                   | UV2 that comes from vertex function.                                                             |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in bool **OUTPUT_IS_SRGB**        | ``true`` when calculations happen in sRGB color space (``true`` in GLES2, ``false`` in GLES3).   |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec4 **COLOR**                 | COLOR that comes from vertex function.                                                           |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out vec3 **ALBEDO**               | Albedo (default white).                                                                          |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **ALPHA**               | Alpha (0..1); if written to, the material will go to the transparent pipeline.                   |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **ALPHA_SCISSOR**       | If written to, values below a certain amount of alpha are discarded.                             |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **METALLIC**            | Metallic (0..1).                                                                                 |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **SPECULAR**            | Specular. Defaults to 0.5, best not to modify unless you want to change IOR.                     |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **ROUGHNESS**           | Roughness (0..1).                                                                                |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **RIM**                 | Rim (0..1). If used, Godot calculates rim lighting.                                              |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **RIM_TINT**            | Rim Tint, goes from 0 (white) to 1 (albedo). If used, Godot calculates rim lighting.             |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **CLEARCOAT**           | Small added specular blob. If used, Godot calculates Clearcoat.                                  |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **CLEARCOAT_GLOSS**     | Gloss of Clearcoat. If used, Godot calculates Clearcoat.                                         |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **ANISOTROPY**          | For distorting the specular blob according to tangent space.                                     |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out vec2 **ANISOTROPY_FLOW**      | Distortion direction, use with flowmaps.                                                         |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **SSS_STRENGTH**        | Strength of Subsurface Scattering. If used, Subsurface Scattering will be applied to object.     |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out vec3 **TRANSMISSION**         | Transmission mask (default 0,0,0). Allows light to pass through object. Only applied if used.    |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out vec3 **EMISSION**             | Emission color (can go over 1,1,1 for HDR).                                                      |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **AO**                  | Strength of Ambient Occlusion. For use with pre-baked AO.                                        |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **AO_LIGHT_AFFECT**     | How much AO affects lights (0..1; default 0).                                                    |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| sampler2D **SCREEN_TEXTURE**      | Built-in Texture for reading from the screen. Mipmaps contain increasingly blurred copies.       |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| sampler2D **DEPTH_TEXTURE**       | Built-in Texture for reading depth from the screen. Must convert to linear using INV_PROJECTION. |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| out float **DEPTH**               | Custom depth value (0..1). If ``DEPTH`` is being written to in any shader branch, then you are   |
|                                   | responsible for setting the ``DEPTH`` for **all** other branches. Otherwise, the graphics API    |
|                                   | will leave them uninitialized.                                                                   |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec2 **SCREEN_UV**             | Screen UV coordinate for current pixel.                                                          |
+-----------------------------------+--------------------------------------------------------------------------------------------------+
| in vec2 **POINT_COORD**           | Point Coordinate for drawing points with POINT_SIZE.                                             |
+-----------------------------------+--------------------------------------------------------------------------------------------------+

.. note::

    Shaders going through the transparent pipeline when ``ALPHA`` is written to
    may exhibit transparency sorting issues. Read the
    :ref:`transparency sorting section in the 3D rendering limitations page <doc_3d_rendering_limitations_transparency_sorting>`
    for more information and ways to avoid issues.

Light built-ins
^^^^^^^^^^^^^^^

Writing light processor functions is completely optional. You can skip the light function by setting
render_mode to ``unshaded``. If no light function is written, Godot will use the material
properties written to in the fragment function to calculate the lighting for you (subject to
the render_mode).

To write a light function, assign something to ``DIFFUSE_LIGHT`` or ``SPECULAR_LIGHT``. Assigning nothing
means no light is processed.

The light function is called for every light in every pixel. It is called within a loop for
each light type.

Below is an example of a custom light function using a Lambertian lighting model:

.. code-block:: glsl

    void light() {
        DIFFUSE_LIGHT += clamp(dot(NORMAL, LIGHT), 0.0, 1.0) * ATTENUATION * ALBEDO;
    }

If you want the lights to add together, add the light contribution to ``DIFFUSE_LIGHT`` using ``+=``, rather than overwriting it.

.. warning::

    In GLES2, lights will always be added together even if you override ``DIFFUSE_LIGHT`` using ``=``. This is due to lighting being computed in multiple passes (one for each light), unlike GLES3.

.. warning::

    The ``light()`` function won't be run if the ``vertex_lighting`` render mode
    is enabled, or if
    **Rendering > Quality > Shading > Force Vertex Shading** is enabled in the
    Project Settings. (It's enabled by default on mobile platforms.)

+-----------------------------------+-----------------------------------------------------+
| Built-in                          | Description                                         |
+===================================+=====================================================+
| in float **TIME**                 | Elapsed total time in seconds.                      |
+-----------------------------------+-----------------------------------------------------+
| in vec2 **VIEWPORT_SIZE**         | Size of viewport (in pixels).                       |
+-----------------------------------+-----------------------------------------------------+
| in vec4 **FRAGCOORD**             | Coordinate of pixel center in screen space.         |
|                                   | ``xy`` specifies position in window, ``z``          |
|                                   | specifies fragment depth if ``DEPTH`` is not used.  |
|                                   | Origin is lower-left.                               |
+-----------------------------------+-----------------------------------------------------+
| in mat4 **WORLD_MATRIX**          | Model space to world space transform.               |
+-----------------------------------+-----------------------------------------------------+
| in mat4 **INV_CAMERA_MATRIX**     | World space to view space transform.                |
+-----------------------------------+-----------------------------------------------------+
| in mat4 **CAMERA_MATRIX**         | View space to world space transform.                |
+-----------------------------------+-----------------------------------------------------+
| in mat4 **PROJECTION_MATRIX**     | View space to clip space transform.                 |
+-----------------------------------+-----------------------------------------------------+
| in mat4 **INV_PROJECTION_MATRIX** | Clip space to view space transform.                 |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **NORMAL**                | Normal vector, in view space.                       |
+-----------------------------------+-----------------------------------------------------+
| in vec2 **UV**                    | UV that comes from vertex function.                 |
+-----------------------------------+-----------------------------------------------------+
| in vec2 **UV2**                   | UV2 that comes from vertex function.                |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **VIEW**                  | View vector, in view space.                         |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **LIGHT**                 | Light Vector, in view space.                        |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **ATTENUATION**           | Attenuation based on distance or shadow.            |
+-----------------------------------+-----------------------------------------------------+
| in bool **OUTPUT_IS_SRGB**        | ``true`` when calculations happen in sRGB color     |
|                                   | space (``true`` in GLES2, ``false`` in GLES3).      |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **ALBEDO**                | Base albedo.                                        |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **LIGHT_COLOR**           | Color of light multiplied by ``energy * PI``.       |
|                                   | The ``PI`` multiplication is present because        |
|                                   | physically-based lighting models include a          |
|                                   | division by ``PI``.                                 |
+-----------------------------------+-----------------------------------------------------+
| out float **ALPHA**               | Alpha (0..1); if written to, the material will go   |
|                                   | to the transparent pipeline.                        |
+-----------------------------------+-----------------------------------------------------+
| in float **ROUGHNESS**            | Roughness.                                          |
+-----------------------------------+-----------------------------------------------------+
| in vec3 **TRANSMISSION**          | Transmission mask from fragment function.           |
+-----------------------------------+-----------------------------------------------------+
| out vec3 **DIFFUSE_LIGHT**        | Diffuse light result.                               |
+-----------------------------------+-----------------------------------------------------+
| out vec3 **SPECULAR_LIGHT**       | Specular light result.                              |
+-----------------------------------+-----------------------------------------------------+

.. note::

    Shaders going through the transparent pipeline when ``ALPHA`` is written to
    may exhibit transparency sorting issues. Read the
    :ref:`transparency sorting section in the 3D rendering limitations page <doc_3d_rendering_limitations_transparency_sorting>`
    for more information and ways to avoid issues.


===================================================
/. ./tutorials/shaders/shader_reference/canvas_item_shader.rst
===================================================

.. _doc_canvas_item_shader:

CanvasItem shaders
==================

CanvasItem shaders are used to draw all 2D elements in Godot. These include
all nodes that inherit from CanvasItems, and all GUI elements.

CanvasItem shaders contain less built-in variables and functionality than Spatial
shaders, but they maintain the same basic structure with vertex, fragment, and
light processor functions.

Render modes
^^^^^^^^^^^^

+---------------------------------+----------------------------------------------------------------------+
| Render mode                     | Description                                                          |
+=================================+======================================================================+
| **blend_mix**                   | Mix blend mode (alpha is transparency), default.                     |
+---------------------------------+----------------------------------------------------------------------+
| **blend_add**                   | Additive blend mode.                                                 |
+---------------------------------+----------------------------------------------------------------------+
| **blend_sub**                   | Subtractive blend mode.                                              |
+---------------------------------+----------------------------------------------------------------------+
| **blend_mul**                   | Multiplicative blend mode.                                           |
+---------------------------------+----------------------------------------------------------------------+
| **blend_premul_alpha**          | Pre-multiplied alpha blend mode.                                     |
+---------------------------------+----------------------------------------------------------------------+
| **blend_disabled**              | Disable blending, values (including alpha) are written as-is.        |
+---------------------------------+----------------------------------------------------------------------+
| **unshaded**                    | Result is just albedo. No lighting/shading happens in material.      |
+---------------------------------+----------------------------------------------------------------------+
| **light_only**                  | Only draw on light pass.                                             |
+---------------------------------+----------------------------------------------------------------------+
| **skip_vertex_transform**       | VERTEX/NORMAL/etc need to be transformed manually in vertex function.|
+---------------------------------+----------------------------------------------------------------------+

Built-ins
^^^^^^^^^

Values marked as "in" are read-only. Values marked as "out" are for optional writing and will
not necessarily contain sensible values. Values marked as "inout" provide a sensible default
value, and can optionally be written to. Samplers are not subjects of writing and they are
not marked.

Global built-ins
^^^^^^^^^^^^^^^^

Global built-ins are available everywhere, including custom functions.

+-------------------+-----------------------------------------------------------------------------+
| Built-in          | Description                                                                 |
+===================+=============================================================================+
| in float **TIME** | Global time since the engine has started, in seconds (always positive).     |
|                   | It's subject to the rollover setting (which is 3,600 seconds by default).   |
|                   | It's not affected by :ref:`time_scale<class_Engine_property_time_scale>`    |
|                   | or pausing, but you can override the ``TIME`` variable's time scale by      |
|                   | calling ``VisualServer.set_shader_time_scale()`` with the desired           |
|                   | time scale factor as parameter (``1.0`` being the default).                 |
+-------------------+-----------------------------------------------------------------------------+

Vertex built-ins
^^^^^^^^^^^^^^^^

Vertex data (``VERTEX``) is presented in local space (pixel coordinates, relative to the camera).
If not written to, these values will not be modified and be passed through as they came.

The user can disable the built-in modelview transform (projection will still happen later) and do
it manually with the following code:

.. code-block:: glsl

    shader_type canvas_item;
    render_mode skip_vertex_transform;

    void vertex() {

        VERTEX = (WORLD_MATRIX * (EXTRA_MATRIX * vec4(VERTEX, 0.0, 1.0))).xy;
    }

.. note:: ``WORLD_MATRIX`` is actually a modelview matrix. It takes input in local space and transforms it
          into view space.

In order to get the world space coordinates of a vertex, you have to pass in a custom uniform like so:

::

    material.set_shader_param("global_transform", get_global_transform())


Then, in your vertex shader:

.. code-block:: glsl

    uniform mat4 global_transform;
    varying vec2 world_position;

    void vertex(){
        world_position = (global_transform * vec4(VERTEX, 0.0, 1.0)).xy;
    }

``world_position`` can then be used in either the vertex or fragment functions.

Other built-ins, such as UV and COLOR, are also passed through to the fragment function if not modified.

For instancing, the INSTANCE_CUSTOM variable contains the instance custom data. When using particles, this information
is usually:

* **x**: Rotation angle in radians.
* **y**: Phase during lifetime (0 to 1).
* **z**: Animation frame.

+--------------------------------+----------------------------------------------------------------+
| Built-in                       | Description                                                    |
+================================+================================================================+
| in mat4 **WORLD_MATRIX**       | Image space to view space transform.                           |
+--------------------------------+----------------------------------------------------------------+
| in mat4 **EXTRA_MATRIX**       | Extra transform.                                               |
+--------------------------------+----------------------------------------------------------------+
| in mat4 **PROJECTION_MATRIX**  | View space to clip space transform.                            |
+--------------------------------+----------------------------------------------------------------+
| in int **INSTANCE_ID**         | Instance ID for instancing. Not supported in GLES2 (returns    |
|                                | 0).                                                            |
+--------------------------------+----------------------------------------------------------------+
| in vec4 **INSTANCE_CUSTOM**    | Instance custom data.                                          |
+--------------------------------+----------------------------------------------------------------+
| in bool **AT_LIGHT_PASS**      | ``true`` if this is a light pass.                              |
+--------------------------------+----------------------------------------------------------------+
| inout vec2 **VERTEX**          | Vertex, in image space.                                        |
+--------------------------------+----------------------------------------------------------------+
| in int **VERTEX_ID**           | The index of the current vertex in the vertex buffer. Not      |
|                                | supported in GLES2 (returns 0).                                |
+--------------------------------+----------------------------------------------------------------+
| in vec2 **TEXTURE_PIXEL_SIZE** | Normalized pixel size of default 2D texture.                   |
|                                | For a Sprite with a texture of size 64x32px,                   |
|                                | **TEXTURE_PIXEL_SIZE** = :code:`vec2(1/64, 1/32)`              |
+--------------------------------+----------------------------------------------------------------+
| inout vec2 **UV**              | Texture coordinates.                                           |
+--------------------------------+----------------------------------------------------------------+
| inout vec4 **COLOR**           | Color from vertex primitive.                                   |
+--------------------------------+----------------------------------------------------------------+
| in vec4 **MODULATE**           | Final modulate color.                                          |
|                                | If used, **COLOR** will not be multiplied by modulate          |
|                                | automatically after the fragment function.                     |
+--------------------------------+----------------------------------------------------------------+
| inout float **POINT_SIZE**     | Point size for point drawing.                                  |
+--------------------------------+----------------------------------------------------------------+

Fragment built-ins
^^^^^^^^^^^^^^^^^^

Certain Nodes (for example, :ref:`Sprites <class_Sprite>`) display a texture by default. However,
when a custom fragment function is attached to these nodes, the texture lookup needs to be done
manually. Godot does not provide the texture color in the ``COLOR`` built-in variable; to read
the texture color for such nodes, use:

.. code-block:: glsl

  COLOR = texture(TEXTURE, UV);

This differs from the behavior of the built-in normal map. If a normal map is attached, Godot uses
it by default and assigns its value to the built-in ``NORMAL`` variable. If you are using a normal
map meant for use in 3D, it will appear inverted. In order to use it in your shader, you must assign
it to the ``NORMALMAP`` property. Godot will handle converting it for use in 2D and overwriting ``NORMAL``.

.. code-block:: glsl

  NORMALMAP = texture(NORMAL_TEXTURE, UV).rgb;

+----------------------------------+----------------------------------------------------------------+
| Built-in                         | Description                                                    |
+==================================+================================================================+
| in vec4 **FRAGCOORD**            | Coordinate of pixel center. In screen space. ``xy`` specifies  |
|                                  | position in window, ``z`` specifies fragment depth if          |
|                                  | ``DEPTH`` is not used. Origin is lower-left.                   |
+----------------------------------+----------------------------------------------------------------+
| inout vec3 **NORMAL**            | Normal read from **NORMAL_TEXTURE**. Writable.                 |
+----------------------------------+----------------------------------------------------------------+
| out vec3 **NORMALMAP**           | Configures normal maps meant for 3D for use in 2D. If used,    |
|                                  | overwrites **NORMAL**.                                         |
+----------------------------------+----------------------------------------------------------------+
| inout float **NORMALMAP_DEPTH**  | Normalmap depth for scaling.                                   |
+----------------------------------+----------------------------------------------------------------+
| in vec2 **UV**                   | UV from vertex function.                                       |
+----------------------------------+----------------------------------------------------------------+
| inout vec4 **COLOR**             | Color from vertex function and output fragment color. If       |
|                                  | unused, will be set to **TEXTURE** color.                      |
+----------------------------------+----------------------------------------------------------------+
| in vec4 **MODULATE**             | Final modulate color.                                          |
|                                  | If used, **COLOR** will not be multiplied by modulate          |
|                                  | automatically after the fragment function.                     |
+----------------------------------+----------------------------------------------------------------+
| in sampler2D **TEXTURE**         | Default 2D texture.                                            |
+----------------------------------+----------------------------------------------------------------+
| in sampler2D **NORMAL_TEXTURE**  | Default 2D normal texture.                                     |
+----------------------------------+----------------------------------------------------------------+
| in vec2 **TEXTURE_PIXEL_SIZE**   | Normalized pixel size of default 2D texture.                   |
|                                  | For a Sprite with a texture of size 64x32px,                   |
|                                  | **TEXTURE_PIXEL_SIZE** = :code:`vec2(1/64, 1/32)`              |
+----------------------------------+----------------------------------------------------------------+
| in vec2 **SCREEN_UV**            | Screen UV for use with **SCREEN_TEXTURE**.                     |
+----------------------------------+----------------------------------------------------------------+
| in vec2 **SCREEN_PIXEL_SIZE**    | Size of individual pixels. Equal to inverse of resolution.     |
+----------------------------------+----------------------------------------------------------------+
| in vec2 **POINT_COORD**          | Coordinate for drawing points.                                 |
+----------------------------------+----------------------------------------------------------------+
| in bool **AT_LIGHT_PASS**        | ``true`` if this is a light pass.                              |
+----------------------------------+----------------------------------------------------------------+
| in sampler2D **SCREEN_TEXTURE**  | Screen texture, mipmaps contain gaussian blurred versions.     |
+----------------------------------+----------------------------------------------------------------+

Light built-ins
^^^^^^^^^^^^^^^

Light processor functions work differently in 2D than they do in 3D. In CanvasItem shaders, the
shader is called once for the object being drawn, and then once for each light touching that
object in the scene. Use render_mode ``unshaded`` if you do not want any light passes to occur
for that object. Use render_mode ``light_only`` if you only want light passes to occur for
that object; this can be useful when you only want the object visible where it is covered by light.

When the shader is on a light pass, the ``AT_LIGHT_PASS`` variable will be ``true``.

+-------------------------------------+-------------------------------------------------------------------------------+
| Built-in                            | Description                                                                   |
+=====================================+===============================================================================+
| in vec4 **FRAGCOORD**               | Coordinate of pixel center. In screen space. ``xy`` specifies                 |
|                                     | position in window, ``z`` specifies fragment depth if                         |
|                                     | ``DEPTH`` is not used. Origin is lower-left.                                  |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec3 **NORMAL**                  | Input Normal. Although this value is passed in,                               |
|                                     | **normal calculation still happens outside of this function**.                |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec2 **UV**                      | UV from vertex function, equivalent to the UV in the fragment function.       |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec4 **COLOR**                   | Input Color.                                                                  |
|                                     | This is the output of the fragment function (with final modulation applied,   |
|                                     | if **MODULATE** is not used in any function of the shader).                   |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec4 **MODULATE**                | Final modulate color.                                                         |
|                                     | If used, **COLOR** will not be multiplied by modulate                         |
|                                     | automatically after the fragment function.                                    |
+-------------------------------------+-------------------------------------------------------------------------------+
| sampler2D **TEXTURE**               | Current texture in use for CanvasItem.                                        |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec2 **TEXTURE_PIXEL_SIZE**      | Normalized pixel size of default 2D texture.                                  |
|                                     | For a Sprite with a texture of size 64x32px,                                  |
|                                     | **TEXTURE_PIXEL_SIZE** = :code:`vec2(1/64, 1/32)`                             |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec2 **SCREEN_UV**               | **SCREEN_TEXTURE** Coordinate (for using with screen texture).                |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec2 **POINT_COORD**             | UV for Point Sprite.                                                          |
+-------------------------------------+-------------------------------------------------------------------------------+
| inout vec2 **LIGHT_VEC**            | Vector from light to fragment in local coordinates. It can be modified to     |
|                                     | alter illumination direction when normal maps are used.                       |
+-------------------------------------+-------------------------------------------------------------------------------+
| inout vec2 **SHADOW_VEC**           | Vector from light to fragment in local coordinates. It can be modified to     |
|                                     | alter shadow computation.                                                     |
+-------------------------------------+-------------------------------------------------------------------------------+
| inout float **LIGHT_HEIGHT**        | Height of Light. Only effective when normals are used.                        |
+-------------------------------------+-------------------------------------------------------------------------------+
| inout vec4 **LIGHT_COLOR**          | Color of Light.                                                               |
+-------------------------------------+-------------------------------------------------------------------------------+
| in vec2 **LIGHT_UV**                | UV for Light texture.                                                         |
+-------------------------------------+-------------------------------------------------------------------------------+
| out vec4 **SHADOW_COLOR**           | Shadow Color of Light.                                                        |
+-------------------------------------+-------------------------------------------------------------------------------+
| inout vec4 **LIGHT**                | Value from the Light texture and output color. Can be modified. If not used,  |
|                                     | the light function is ignored.                                                |
+-------------------------------------+-------------------------------------------------------------------------------+


===================================================
/. ./tutorials/shaders/shader_reference/particle_shader.rst
===================================================

.. _doc_particle_shader:

Particle shaders
================

Particle shaders are a special type of vertex shader that runs before the
object is drawn. They are used for calculating material properties such as
color, position, and rotation. They are drawn with any regular material for
CanvasItem or Spatial, depending on whether they are 2D or 3D.

Particle shaders are unique because they are not used to draw the object
itself; they are used to calculate particle properties, which are then used
by the CanvasItem of Spatial shader. They contain only a vertex processor
function that outputs multiple properties (see built-ins below).

Particle shaders use a transform feedback shader, which is a special type of
vertex shader that runs on its own. It takes in data in a buffer like a regular
vertex shader does, but it also outputs to data buffers instead of outputting
to the fragment shader for pixel-processing. Because of this, transform feedback
shaders can build on themselves each run, unlike other shaders that discard the
data they have calculated once they draw to the frame buffer.

.. note:: Particle shaders are only available in the GLES3 backend. If you need
          particles in GLES2, use :ref:`CPUParticles <class_CPUParticles>`.

Render modes
^^^^^^^^^^^^

+---------------------------------+----------------------------------------------------------------------+
| Render mode                     | Description                                                          |
+=================================+======================================================================+
| **keep_data**                   | Do not clear previous data on restart.                               |
+---------------------------------+----------------------------------------------------------------------+
| **disable_force**               | Disable attractor force. (Not currently implemented in 3.1)          |
+---------------------------------+----------------------------------------------------------------------+
| **disable_velocity**            | Ignore **VELOCITY** value.                                           |
+---------------------------------+----------------------------------------------------------------------+

Built-ins
^^^^^^^^^

Values marked as "in" are read-only. Values marked as "out" are for optional writing and will
not necessarily contain sensible values. Values marked as "inout" provide a sensible default
value, and can optionally be written to. Samplers are not subjects of writing and they are
not marked.

Global built-ins
^^^^^^^^^^^^^^^^

Global built-ins are available everywhere, including custom functions.

+-------------------+--------------------------+
| Built-in          | Description              |
+===================+==========================+
| in float **TIME** | Global time, in seconds. |
+-------------------+--------------------------+

Vertex built-ins
^^^^^^^^^^^^^^^^

In order to use the ``COLOR`` variable in a SpatialMaterial, set ``use_vertex_as_albedo``
to ``true``. In a ShaderMaterial, access it with the ``COLOR`` variable.

+---------------------------------+-------------------------------------------------------------------------------------+
| Built-in                        | Description                                                                         |
+=================================+=====================================================================================+
| inout vec4 **COLOR**            | Particle color, can be written to and accessed in mesh's vertex function.           |
+---------------------------------+-------------------------------------------------------------------------------------+
| inout vec3 **VELOCITY**         | Particle velocity, can be modified.                                                 |
+---------------------------------+-------------------------------------------------------------------------------------+
| out float **MASS**              | Particle mass, use for attractors (not implemented in 3.1).                         |
+---------------------------------+-------------------------------------------------------------------------------------+
| inout bool **ACTIVE**           | ``true`` when Particle is active, can be set to ``false``.                          |
+---------------------------------+-------------------------------------------------------------------------------------+
| in bool **RESTART**             | ``true`` when particle must restart (lifetime cycled).                              |
+---------------------------------+-------------------------------------------------------------------------------------+
| inout vec4 **CUSTOM**           | Custom particle data. Accessible from shader of mesh as **INSTANCE_CUSTOM**.        |
+---------------------------------+-------------------------------------------------------------------------------------+
| inout mat4 **TRANSFORM**        | Particle transform.                                                                 |
+---------------------------------+-------------------------------------------------------------------------------------+
| in float **LIFETIME**           | Particle lifetime.                                                                  |
+---------------------------------+-------------------------------------------------------------------------------------+
| in float **DELTA**              | Delta process time.                                                                 |
+---------------------------------+-------------------------------------------------------------------------------------+
| in uint **NUMBER**              | Unique number since emission start.                                                 |
+---------------------------------+-------------------------------------------------------------------------------------+
| in int **INDEX**                | Particle index (from total particles).                                              |
+---------------------------------+-------------------------------------------------------------------------------------+
| in mat4 **EMISSION_TRANSFORM**  | Emitter transform (used for non-local systems).                                     |
+---------------------------------+-------------------------------------------------------------------------------------+
| in uint **RANDOM_SEED**         | Random seed used as base for random.                                                |
+---------------------------------+-------------------------------------------------------------------------------------+


===================================================
/. ./tutorials/shaders/your_first_shader/index.rst
===================================================

Your first shader
=================

This tutorial series will walk you through writing your first shader. It is intended
for people who have very little prior experience with shaders and want to get started
with the basics. This tutorial will not cover advanced topics and it is not
comprehensive. For a comprehensive and detailed overview of shaders in Godot see the
:ref:`Shading Reference Page <toc-shading-reference>`.

The "your first shader" tutorials walk you through the process of writing a shader
step-by-step.

For a more general introduction into shaders and the OpenGL Shading Language, use
`The Book of Shaders <https://thebookofshaders.com>`_.

.. toctree::
   :maxdepth: 1
   :name: toc-your-first-shader

   your_first_2d_shader
   your_first_3d_shader
   your_second_3d_shader


===================================================
/. ./tutorials/shaders/your_first_shader/your_first_2d_shader.rst
===================================================

.. _doc_your_first_canvasitem_shader:

Your first 2D shader
====================

Introduction
------------

Shaders are special programs that execute on the GPU and are used for rendering
graphics. All modern rendering is done with shaders. For a more detailed
description of what shaders are please see :ref:`What are shaders
<doc_introduction_to_shaders>`.

This tutorial will focus on the practical aspects of writing shader programs by
walking you through the process of writing a shader with both vertex and
fragment functions. This tutorial targets absolute beginners to shaders.

.. note:: If you have experience writing shaders and are just looking for an
          overview of how shaders work in Godot, see the :ref:`Shading Reference
          <toc-shading-reference>`.

Setup
-----

:ref:`CanvasItem <doc_canvas_item_shader>` shaders are used to draw all 2D
     objects in Godot, while :ref:`Spatial <doc_spatial_shader>` shaders are
     used to draw all 3D objects.

In order to use a shader it must be attached inside a :ref:`Material
<class_material>` which must be attached to an object. Materials are a type of
:ref:`Resource <doc_resources>`. To draw multiple objects with the same
material, the material must be attached to each object.

All objects derived from a :ref:`CanvasItem <class_canvasitem>` have a material
property. This includes all :ref:`GUI elements <class_Control>`, :ref:`Sprites
<class_sprite>`, :ref:`TileMaps <class_tilemap>`, :ref:`MeshInstance2Ds
<class_meshinstance2d>` etc. They also have an option to inherit their parent's
material. This can be useful if you have a large number of nodes that you want
to use the same material.

To begin, create a Sprite node. You can use any CanvasItem, but for this
tutorial we will use a Sprite.

In the Inspector, click beside "Texture" where it says "[empty]" and select
"Load", then select "Icon.png". For new projects, this is the Godot icon. You
should now see the icon in the viewport.

Next, look down in the Inspector, under the CanvasItem section, click beside
"Material" and select "New ShaderMaterial". This creates a new Material
resource. Click on the sphere that appears. Godot currently doesn't know whether
you are writing a CanvasItem Shader or a Spatial Shader and it previews the
output of spatial shaders. So what you are seeing is the output of the default
Spatial Shader.

Click beside "Shader" and select "New Shader". Finally, click on the new shader
resource and the shader editor will open. You are now ready to begin writing
your first shader.

Your first CanvasItem shader
----------------------------

In Godot, all shaders start with a line specifying what type of shader they are.
It uses the following format:

.. code-block:: glsl

  shader_type canvas_item;

Because we are writing a CanvasItem shader, we specify ``canvas_item`` in the
first line. All our code will go beneath this declaration.

This line tells the engine which built-in variables and functionality to supply
you with.

In Godot you can override three functions to control how the shader operates;
``vertex``, ``fragment``, and ``light``. This tutorial will walk you through
writing a shader with both vertex and fragment functions. Light functions are
significantly more complex than vertex and fragment functions and so will not be
covered here.

Your first fragment function
----------------------------

The fragment function runs for every pixel in a Sprite and determines what color
that pixel should be.

They are restricted to the pixels covered by the Sprite, that means you cannot
use one to, for example, create an outline around a Sprite.

The most basic fragment function does nothing except assign a single color to
every pixel.

We do so by writing a ``vec4`` to the built-in variable ``COLOR``. ``vec4`` is
shorthand for constructing a vector with 4 numbers. For more information about
vectors see the :ref:`Vector math tutorial <doc_vector_math>` ``COLOR`` is both
an input variable to the fragment function and the final output from it.

.. code-block:: glsl

  void fragment(){
    COLOR = vec4(0.4, 0.6, 0.9, 1.0);
  }

.. image:: img/blue-box.png

Congratulations! You're done. You have successfully written your first shader in
Godot.

Now let's make things more complex.

There are many inputs to the fragment function that you can use for calculating
``COLOR``. ``UV`` is one of them. UV coordinates are specified in your Sprite
(without you knowing it!) and they tell the shader where to read from textures
for each part of the mesh.

In the fragment function you can only read from ``UV``, but you can use it in
other functions or to assign values to ``COLOR`` directly.

``UV`` varies between 0-1 from left-right and from top-bottom.

.. image:: img/iconuv.png

.. code-block:: glsl

  void fragment() {
    COLOR = vec4(UV, 0.5, 1.0);
  }

.. image:: img/UV.png

Using ``TEXTURE`` built-in
^^^^^^^^^^^^^^^^^^^^^^^^^^

When you want to adjust a color in a Sprite you cannot just adjust the color
from the texture manually like in the code below.

.. code-block:: glsl

  void fragment(){
    //this shader will result in an all white rectangle
    COLOR.b = 1.0;
  }

The default fragment function reads from a texture and displays it. When you
overwrite the default fragment function, you lose that functionality, so you
have to implement it yourself. You read from textures using the ``texture``
function. Certain nodes, like Sprites, have a dedicated texture variable that
can be accessed in the shader using ``TEXTURE``. Use it together with ``UV`` and
``texture`` to draw the Sprite.

.. code-block:: glsl

  void fragment(){
    COLOR = texture(TEXTURE, UV); //read from texture
    COLOR.b = 1.0; //set blue channel to 1.0
  }

.. image:: img/blue-tex.png

Uniform input
^^^^^^^^^^^^^

Uniform input is used to pass data into a shader that will be the same across
the entire shader.

You can use uniforms by defining them at the top of your shader like so:

.. code-block:: glsl

  uniform float size;

For more information about usage see the :ref:`Shading Language doc
<doc_shading_language>`.

Add a uniform to change the amount of blue in our Sprite.

.. code-block:: glsl

  uniform float blue = 1.0; // you can assign a default value to uniforms

  void fragment(){
    COLOR = texture(TEXTURE, UV); //read from texture
    COLOR.b = blue;
  }

Now you can change the amount of blue in the Sprite from the editor. Look back
at the Inspector under where you created your shader. You should see a section
called "Shader Param". Unfold that section and you will see the uniform you just
declared. If you change the value in the editor, it will overwrite the default
value you provided in the shader.

Interacting with shaders from code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can change uniforms from code using the function ``set_shader_param()``
which is called on the node's material resource. With a Sprite node, the
following code can be used to set the ``blue`` uniform.

::

  var blue_value = 1.0
  material.set_shader_param("blue", blue_value)

Note that the name of the uniform is a string. The string must match exactly
with how it is written in the shader, including spelling and case.

Your first vertex function
--------------------------

Now that we have a fragment function, let's write a vertex function.

Use the vertex function to calculate where on the screen each vertex should end
up.

The most important variable in the vertex function is ``VERTEX``. Initially, it
specifies the vertex coordinates in your model, but you also write to it to
determine where to actually draw those vertices. ``VERTEX`` is a ``vec2`` that
is initially presented in local-space (i.e. not relative to the camera,
viewport, or parent nodes).

You can offset the vertices by directly adding to ``VERTEX``.

.. code-block:: glsl

  void vertex() {
    VERTEX += vec2(10.0, 0.0);
  }

Combined with the ``TIME`` built-in variable, this can be used for simple
animation.

.. code-block:: glsl

  void vertex() {
    // Animate Sprite moving in big circle around its location
    VERTEX += vec2(cos(TIME)*100.0, sin(TIME)*100.0);
  }

Conclusion
----------

At their core, shaders do what you have seen so far, they compute ``VERTEX`` and
``COLOR``. It is up to you to dream up more complex mathematical strategies for
assigning values to those variables.

For inspiration, take a look at some of the more advanced shader tutorials, and
look at other sites like `Shadertoy
<https://www.shadertoy.com/results?query=&sort=popular&from=10&num=4>`_ and `The
Book of Shaders <https://thebookofshaders.com>`_.


===================================================
/. ./tutorials/shaders/your_first_shader/your_first_3d_shader.rst
===================================================

.. _doc_your_first_spatial_shader:

Your first 3D shader
====================

You have decided to start writing your own custom Spatial shader. Maybe you saw
a cool trick online that was done with shaders, or you have found that the
:ref:`SpatialMaterial <class_SpatialMaterial>` isn't quite meeting your
needs. Either way, you have decided to write your own and now you need to figure
out where to start.

This tutorial will explain how to write a Spatial shader and will cover more
topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` tutorial.

Spatial shaders have more built-in functionality than CanvasItem shaders. The
expectation with spatial shaders is that Godot has already provided the
functionality for common use cases and all the user needs to do in the shader is
set the proper parameters. This is especially true for a PBR (physically based
rendering) workflow.

This is a two-part tutorial. In this first part we are going to go through how
to make a simple terrain using vertex displacement from a heightmap in the
vertex function. In the :ref:`second part <doc_your_second_spatial_shader>` we
are going to take the concepts from this tutorial and walk through how to set up
custom materials in a fragment shader by writing an ocean water shader.

.. note:: This tutorial assumes some basic shader knowledge such as types
          (``vec2``, ``float``, ``sampler2D``), and functions. If you are
          uncomfortable with these concepts it is best to get a gentle
          introduction from `The Book of Shaders
          <https://thebookofshaders.com>`_ before completing this tutorial.

Where to assign my material
---------------------------

In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a resource
type that store geometry (the shape of your object) and materials (the color and
how the object reacts to light) in units called "surfaces". A Mesh can have
multiple surfaces, or just one. Typically, you would import a mesh from another
program (e.g. Blender). But Godot also has a few :ref:`PrimitiveMeshes
<class_primitivemesh>` that allow you to add basic geometry to a scene without
importing Meshes.

There are multiple node types that you can use to draw a mesh. The main one is
:ref:`MeshInstance <class_meshinstance>`, but you can also use :ref:`Particles
<class_particles>`, :ref:`MultiMeshes <class_MultiMesh>` (with a
:ref:`MultiMeshInstance <class_multimeshinstance>`), or others.

Typically, a material is associated with a given surface in a mesh, but some
nodes, like MeshInstance, allow you to override the material for a specific
surface, or for all surfaces.

If you set a material on the surface or mesh itself, then all MeshInstances that
share that mesh will share that material. However, if you want to reuse the same
mesh across multiple mesh instances, but have different materials for each
instance then you should set the material on the Meshinstance.

For this tutorial we will set our material on the mesh itself rather than taking
advantage of the MeshInstance's ability to override materials.

Setting up
----------

Add a new :ref:`MeshInstance <class_meshinstance>` node to your scene.

In the inspector tab beside "Mesh" click "[empty]" and select "New PlaneMesh".
Then click on the image of a plane that appears.

This adds a :ref:`PlaneMesh <class_planemesh>` to our scene.

Then, in the viewport, click in the upper left corner on the button that says
"Perspective". A menu will appear. In the middle of the menu are options for how
to display the scene. Select 'Display Wireframe'.

This will allow you to see the triangles making up the plane.

.. image:: img/plane.png

Now set ``Subdivide Width`` and ``Subdivide Depth`` to ``32``.

.. image:: img/plane-sub-set.png

You can see that there are now many more triangles in the
:ref:`Mesh<class_MeshInstance>`. This will give us more vertices to work with
and thus allow us to add more detail.

.. image:: img/plane-sub.png

:ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one
     surface, so instead of an array of materials there is only one. Click
     beside "Material" where it says "[empty]" and select "New ShaderMaterial".
     Then click the sphere that appears.

Now click beside "Shader" where it says "[empty]" and select "New Shader".

The shader editor should now pop up and you are ready to begin writing your
first Spatial shader!

Shader magic
------------

.. image:: img/shader-error.png

Notice how there is already error? This is because the shader editor reloads
shaders on the fly. The first thing Godot shaders need is a declaration of what
type of shader they are. We set the variable ``shader_type`` to ``spatial``
because this is a spatial shader.

.. code-block:: glsl

  shader_type spatial;

Next we will define the ``vertex()`` function. The ``vertex()`` function
determines where the vertices of your :ref:`Mesh<class_MeshInstance>` appear in
the final scene. We will be using it to offset the height of each vertex and
make our flat plane appear like a little terrain.

We define the vertex shader like so:

.. code-block:: glsl

  void vertex() {

  }

With nothing in the ``vertex()`` function, Godot will use its default vertex
shader. We can easily start to make changes by adding a single line:

.. code-block:: glsl

  void vertex() {
    VERTEX.y += cos(VERTEX.x) * sin(VERTEX.z);
  }

Adding this line, you should get an image like the one below.

.. image:: img/cos.png

Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being increased.
And we are passing the ``x`` and ``z`` components of the ``VERTEX`` as arguments
to ``cos`` and ``sin``; that gives us a wave-like appearance across the ``x``
and ``z`` axes.

What we want to achieve is the look of little hills; after all. ``cos`` and
``sin`` already look kind of like hills. We do so by scaling the inputs to the
``cos`` and ``sin`` functions.

.. code-block:: glsl

  void vertex() {
    VERTEX.y += cos(VERTEX.x * 4.0) * sin(VERTEX.z * 4.0);
  }

.. image:: img/cos4.png

This looks better, but it is still too spiky and repetitive, let's make it a
little more interesting.

Noise heightmap
---------------

Noise is a very popular tool for faking the look of terrain. Think of it as
similar to the cosine function where you have repeating hills except, with
noise, each hill has a different height.

Godot provides the :ref:`NoiseTexture <class_noisetexture>` resource for
generating a noise texture that can be accessed from a shader.

To access a texture in a shader add the following code near the top of your
shader, outside the ``vertex()`` function.

.. code-block:: glsl

  uniform sampler2D noise;

This will allow you to send a noise texture to the shader. Now look in the
inspector under your material. You should see a section called "Shader Params".
If you open it up, you'll see a section called "noise".

Click beside it where it says "[empty]" and select "New NoiseTexture". Then in
your NoiseTexture click beside where it says "Noise" and select "New
OpenSimplexNoise".

:ref:`OpenSimplexNoise <class_opensimplexnoise>` is used by the NoiseTexture to
     generate a heightmap.

Once you set it up and should look like this.

.. image:: img/noise-set.png

Now, access the noise texture using the ``texture()`` function. ``texture()``
takes a texture as the first argument and a ``vec2`` for the position on the
texture as the second argument. We use the ``x`` and ``z`` channels of
``VERTEX`` to determine where on the texture to look up. Note that the PlaneMesh
coordinates are within the [-1,1] range (for a size of 2), while the texture
coordinates are within [0,1], so to normalize we divide by the size of the
PlaneMesh 2.0 and add 0.5. ``texture()`` returns a ``vec4`` of the ``r, g, b,
a`` channels at the position. Since the noise texture is grayscale, all of the
values are the same, so we can use any one of the channels as the height. In
this case we'll use the ``r``, or ``x`` channel.

.. code-block:: glsl

  float height = texture(noise, VERTEX.xz / 2.0 + 0.5).x;
  VERTEX.y += height;

Note: ``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture().x``
above, we could use ``texture().r``. See the `OpenGL documentation
<https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more
details.

Using this code you can see the texture creates random looking hills.

.. image:: img/noise.png

Right now it is too spiky, we want to soften the hills a bit. To do that, we
will use a uniform. You already used a uniform above to pass in the noise
texture, now let's learn how they work.

Uniforms
--------

Uniform variables allow you to pass data from the game into the shader. They are
very useful for controlling shader effects. Uniforms can be almost any datatype
that can be used in the shader. To use a uniform, you declare it in your
:ref:`Shader<class_Shader>` using the keyword ``uniform``.

Let's make a uniform that changes the height of the terrain.

.. code-block:: glsl

  uniform float height_scale = 0.5;


Godot lets you initialize a uniform with a value; here, ``height_scale`` is set
to ``0.5``. You can set uniforms from GDScript by calling the function
``set_shader_param()`` on the material corresponding to the shader. The value
passed from GDScript takes precedence over the value used to initialize it in
the shader.

::

  # called from the MeshInstance
  mesh.material.set_shader_param("height_scale", 0.5)

.. note:: Changing uniforms in Spatial-based nodes is different from
          CanvasItem-based nodes. Here, we set the material inside the PlaneMesh
          resource. In other mesh resources you may need to first access the
          material by calling ``surface_get_material()``. While in the
          MeshInstance you would access the material using
          ``get_surface_material()`` or ``material_override``.

Remember that the string passed into ``set_shader_param()`` must match the name
of the uniform variable in the :ref:`Shader<class_Shader>`. You can use the
uniform variable anywhere inside your :ref:`Shader<class_Shader>`. Here, we will
use it to set the height value instead of arbitrarily multiplying by ``0.5``.

.. code-block:: glsl

  VERTEX.y += height * height_scale;

Now it looks  much better.

.. image:: img/noise-low.png

Using uniforms, we can even change the value every frame to animate the height
of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can be
especially useful for simple animations.

Interacting with light
----------------------

First, turn wireframe off. To do so, click in the upper-left of the Viewport
again, where it says "Perspective", and select "Display Normal".

.. image:: img/normal.png

Note how the mesh color goes flat. This is because the lighting on it is flat.
Let's add a light!

First, we will add an :ref:`OmniLight<class_OmniLight>` to the scene.

.. image:: img/light.png

You can see the light affecting the terrain, but it looks odd. The problem is
the light is affecting the terrain as if it were a flat plane. This is because
the light shader uses the normals from the :ref:`Mesh <class_mesh>` to calculate
light.

The normals are stored in the Mesh, but we are changing the shape of the Mesh in
the shader, so the normals are no longer correct. To fix this, we can
recalculate the normals in the shader or use a normal texture that corresponds
to our noise. Godot makes both easy for us.

You can calculate the new normal manually in the vertex function and then just
set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult lighting
calculations for us. We will cover this method in the next part of this
tutorial, for now we will read normals from a texture.

Instead we will rely on the NoiseTexture again to calculate normals for us. We
do that by passing in a second noise texture.

.. code-block:: glsl

  uniform sampler2D normalmap;

Set this second uniform texture to another NoiseTexture with another
OpenSimplexNoise. But this time, check off "As Normalmap".

.. image:: img/normal-set.png

Now, because this is a normalmap and not a per-vertex normal, we are going to
assign it in the ``fragment()`` function. The ``fragment()`` function will be
explained in more detail in the next part of this tutorial.

.. code-block:: glsl

  void fragment() {
  }

When we have normals that correspond to a specific vertex we set ``NORMAL``, but
if you have a normalmap that comes from a texture, set the normal using
``NORMALMAP``. This way Godot will handle the wrapping the texture around the
mesh automatically.

Lastly, in order to ensure that we are reading from the same places on the noise
texture and the normalmap texture, we are going to pass the ``VERTEX.xz``
position from the ``vertex()`` function to the ``fragment()`` function. We do
that with varyings.

Above the ``vertex()`` define a ``vec2`` called ``tex_position``. And inside the
``vertex()`` function assign ``VERTEX.xz`` to ``tex_position``.

.. code-block:: glsl

  varying vec2 tex_position;

  void vertex() {
    ...
    tex_position = VERTEX.xz / 2.0 + 0.5;
    float height = texture(noise, tex_position).x;
    ...
  }

And now we can access ``tex_position`` from the ``fragment()`` function.

.. code-block:: glsl

  void fragment() {
    NORMALMAP = texture(normalmap, tex_position).xyz;
  }

With the normals in place the light now reacts to the height of the mesh
dynamically.

.. image:: img/normalmap.png

We can even drag the light around and the lighting will update automatically.

.. image:: img/normalmap2.png

Here is the full code for this tutorial. You can see it is not very long as
Godot handles most of the difficult stuff for you.

.. code-block:: glsl

  shader_type spatial;

  uniform float height_scale = 0.5;
  uniform sampler2D noise;
  uniform sampler2D normalmap;

  varying vec2 tex_position;

  void vertex() {
    tex_position = VERTEX.xz / 2.0 + 0.5;
    float height = texture(noise, tex_position).x;
    VERTEX.y += height * height_scale;
  }

  void fragment() {
    NORMALMAP = texture(normalmap, tex_position).xyz;
  }

That is everything for this part. Hopefully, you now understand the basics of
vertex shaders in Godot. In the next part of this tutorial we will write a
fragment function to accompany this vertex function and we will cover a more
advanced technique to turn this terrain into an ocean of moving waves.


===================================================
/. ./tutorials/shaders/your_first_shader/your_second_3d_shader.rst
===================================================

.. _doc_your_second_spatial_shader:

Your second 3D shader
=====================

From a high-level, what Godot does is give the user a bunch of parameters that
can be optionally set (``AO``, ``SSS_Strength``, ``RIM``, etc.). These
parameters correspond to different complex effects (Ambient Occlusion,
SubSurface Scattering, Rim Lighting, etc.). When not written to, the code is
thrown out before it is compiled and so the shader does not incur the cost of
the extra feature. This makes it easy for users to have complex PBR-correct
shading, without writing complex shaders. Of course, Godot also allows you to
ignore all these parameters and write a fully customized shader.

For a full list of these parameters see the :ref:`spatial shader
<doc_spatial_shader>` reference doc.

A difference between the vertex function and a fragment function is that the
vertex function runs per vertex and sets properties such as ``VERTEX``
(position) and ``NORMAL``, while the fragment shader runs per pixel and, most
importantly, sets the ``ALBEDO`` color of the :ref:`Mesh<class_MeshInstance>`.

Your first spatial fragment function
------------------------------------

As mentioned in the previous part of this tutorial. The standard use of the
fragment function in Godot is to set up different material properties and let
Godot handle the rest. In order to provide even more flexibility, Godot also
provides things called render modes. Render modes are set at the top of the
shader, directly below ``shader_type``, and they specify what sort of
functionality you want the built-in aspects of the shader to have.

For example, if you do not want to have lights affect an object, set the render
mode to ``unshaded``:

.. code-block:: glsl

  render_mode unshaded;

You can also stack multiple render modes together. For example, if you want to
use toon shading instead of more-realistic PBR shading, set the diffuse mode and
specular mode to toon:

.. code-block:: glsl

  render_mode diffuse_toon, specular_toon;

This model of built-in functionality allows you to write complex custom shaders
by changing only a few parameters.

For a full list of render modes see the :ref:`Spatial shader reference
<doc_spatial_shader>`.

In this part of the tutorial, we will walk through how to take the bumpy terrain
from the previous part and turn it into an ocean.

First let's set the color of the water. We do that by setting ``ALBEDO``.

``ALBEDO`` is a ``vec3`` that contains the color of the object.

Let's set it to a nice shade of blue.

.. code-block:: glsl

  void fragment() {
    ALBEDO = vec3(0.1, 0.3, 0.5);
  }

.. image:: img/albedo.png

We set it to a very dark shade of blue because most of the blueness of the water
will come from reflections from the sky.

The PBR model that Godot uses relies on two main parameters: ``METALLIC`` and
``ROUGHNESS``.

``ROUGHNESS`` specifies how smooth/rough the surface of a material is. A low
``ROUGHNESS`` will make a material appear like a shiny plastic, while a high
roughness makes the material appear more solid in color.

``METALLIC`` specifies how much like a metal the object is. It is better set
close to ``0`` or ``1``. Think of ``METALLIC`` as changing the balance between
the reflection and the ``ALBEDO`` color. A high ``METALLIC`` almost ignores
``ALBEDO`` altogether, and looks like a mirror of the sky. While a low
``METALLIC`` has a more equal representation of sky color and ``ALBEDO`` color.

``ROUGHNESS`` increases from ``0`` to ``1`` from left to right while
``METALLIC`` increase from ``0`` to ``1`` from top to bottom.

.. image:: img/PBR.png

.. note:: ``METALLIC`` should be close to ``0`` or ``1`` for proper PBR shading.
          Only set it between them for blending between materials.

Water is not a metal, so we will set its ``METALLIC`` property to ``0.0``. Water
is also highly reflective, so we will set its ``ROUGHNESS`` property to be quite
low as well.

.. code-block:: glsl

  void fragment() {
    METALLIC = 0.0;
    ROUGHNESS = 0.01;
    ALBEDO = vec3(0.1, 0.3, 0.5);
  }

.. image:: img/plastic.png

Now we have a smooth plastic looking surface. It is time to think about some
particular properties of water that we want to emulate. There are two main ones
that will take this from a weird plastic surface to nice stylized water. The
first is specular reflections. Specular reflections are those bright spots you
see from where the sun reflects directly into your eye. The second is fresnel
reflectance. Fresnel reflectance is the property of objects to become more
reflective at shallow angles. It is the reason why you can see into water below
you, but farther away it reflects the sky.

In order to increase the specular reflections, we will do two things. First, we
will change the render mode for specular to toon because the toon render mode
has larger specular highlights.

.. code-block:: glsl

  render_mode specular_toon;

.. image:: img/specular-toon.png

Second we will add rim lighting. Rim lighting increases the effect of light at
glancing angles. Usually it is used to emulate the way light passes through
fabric on the edges of an object, but we will use it here to help achieve a nice
watery effect.

.. code-block:: glsl

  void fragment() {
    RIM = 0.2;
    METALLIC = 0.0;
    ROUGHNESS = 0.01;
    ALBEDO = vec3(0.1, 0.3, 0.5);
  }

.. image:: img/rim.png

In order to add fresnal reflectance, we will compute a fresnel term in our
fragment shader. Here, we aren't going to use a real fresnel term for
performance reasons. Instead, we'll approximate it using the dot product of the
``NORMAL`` and ``VIEW`` vectors. The ``NORMAL`` vector points away from the
mesh's surface, while the ``VIEW`` vector is the direction between your eye and
that point on the surface. The dot product between them is a handy way to tell
when you are looking at the surface head-on or at a glancing angle.

.. code-block:: glsl

  float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));

And mix it into both ``ROUGHNESS`` and ``ALBEDO``. This is the benefit of
ShaderMaterials over SpatialMaterials. With SpatialMaterial, we could set
these properties with a texture, or to a flat number. But with shaders we can
set them based on any mathematical function that we can dream up.


.. code-block:: glsl

  void fragment() {
    float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));
    RIM = 0.2;
    METALLIC = 0.0;
    ROUGHNESS = 0.01 * (1.0 - fresnel);
    ALBEDO = vec3(0.1, 0.3, 0.5) + (0.1 * fresnel);
  }

.. image:: img/fresnel.png

And now, with only 5 lines of code, you can have complex looking water. Now that
we have lighting, this water is looking too bright. Let's darken it. This is
done easily by decreasing the values of the ``vec3`` we pass into ``ALBEDO``.
Let's set them to ``vec3(0.01, 0.03, 0.05)``.

.. image:: img/dark-water.png

Animating with ``TIME``
-----------------------

Going back to the vertex function, we can animate the waves using the built-in
variable ``TIME``.

``TIME`` is a built-in variable that is accessible from the vertex and fragment
functions.


In the last tutorial we calculated height by reading from a heightmap. For this
tutorial, we will do the same. Put the heightmap code in a function called
``height()``.

.. code-block:: glsl

  float height(vec2 position) {
    return texture(noise, position / 10.0).x; // Scaling factor is based on mesh size (this PlaneMesh is 10×10).
  }

In order to use ``TIME`` in the ``height()`` function, we need to pass it in.

.. code-block:: glsl

  float height(vec2 position, float time) {
  }

And make sure to correctly pass it in inside the vertex function.

.. code-block:: glsl

  void vertex() {
    vec2 pos = VERTEX.xz;
    float k = height(pos, TIME);
    VERTEX.y = k;
  }

Instead of using a normalmap to calculate normals. We are going to compute them
manually in the ``vertex()`` function. To do so use the following line of code.

.. code-block:: glsl

  NORMAL = normalize(vec3(k - height(pos + vec2(0.1, 0.0), TIME), 0.1, k - height(pos + vec2(0.0, 0.1), TIME)));

We need to compute ``NORMAL`` manually because in the next section we will be
using math to create complex-looking waves.

Now, we are going to make the ``height()`` function a little more complicated by
offsetting ``position`` by the cosine of ``TIME``.

.. code-block:: glsl

  float height(vec2 position, float time) {
    vec2 offset = 0.01 * cos(position + time);
    return texture(noise, (position / 10.0) - offset).x;
  }

This results in waves that move slowly, but not in a very natural way. The next
section will dig deeper into using shaders to create more complex effects, in
this case realistic waves, by adding a few more mathematical functions.

Advanced effects: waves
-----------------------

What makes shaders so powerful is that you can achieve complex effects by using
math. To illustrate this, we are going to take our waves to the next level by
modifying the ``height()`` function and by introducing a new function called
``wave()``.

``wave()`` has one parameter, ``position``, which is the same as it is in
``height()``.

We are going to call ``wave()`` multiple times in ``height()`` in order to fake
the way waves look.

.. code-block:: glsl

  float wave(vec2 position){
    position += texture(noise, position / 10.0).x * 2.0 - 1.0;
    vec2 wv = 1.0 - abs(sin(position));
    return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);
  }

At first this looks complicated. So let's go through it line-by-line.

.. code-block:: glsl

    position += texture(noise, position / 10.0).x * 2.0 - 1.0;

Offset the position by the ``noise`` texture. This will make the waves curve, so
they won't be straight lines completely aligned with the grid.

.. code-block:: glsl

    vec2 wv = 1.0 - abs(sin(position));

Define a wave-like function using ``sin()`` and ``position``. Normally ``sin()``
waves are very round. We use ``abs()`` to absolute to give them a sharp ridge
and constrain them to the 0-1 range. And then we subtract it from ``1.0`` to put
the peak on top.

.. code-block:: glsl

    return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);

Multiply the x-directional wave by the y-directional wave and raise it to a
power to sharpen the peaks. Then subtract that from ``1.0`` so that the ridges
become peaks and raise that to a power to sharpen the ridges.

We can now replace the contents of our ``height()`` function with ``wave()``.

.. code-block:: glsl

  float height(vec2 position, float time) {
    float h = wave(position);
    return h;
  }

Using this, you get:

.. image:: img/wave1.png

The shape of the sin wave is too obvious. So let's spread the waves out a bit.
We do this by scaling ``position``.

.. code-block:: glsl

  float height(vec2 position, float time) {
    float h = wave(position * 0.4);
    return h;
  }

Now it looks much better.

.. image:: img/wave2.png

We can do even better if we layer multiple waves on top of each other at varying
frequencies and amplitudes. What this means is that we are going to scale
position for each one to make the waves thinner or wider (frequency). And we are
going to multiply the output of the wave to make them shorter or taller
(amplitude).

Here is an example for how you could layer the four waves to achieve nicer
looking waves.

.. code-block:: glsl

  float height(vec2 position, float time) {
    float d = wave((position + time) * 0.4) * 0.3;
    d += wave((position - time) * 0.3) * 0.3;
    d += wave((position + time) * 0.5) * 0.2;
    d += wave((position - time) * 0.6) * 0.2;
    return d;
  }

Note that we add time to two and subtract it from the other two. This makes the
waves move in different directions creating a complex effect. Also note that the
amplitudes (the number the result is multiplied by) all add up to ``1.0``. This
keeps the wave in the 0-1 range.

With this code you should end up with more complex looking waves and all you had
to do was add a bit of math!

.. image:: img/wave3.png

For more information about Spatial shaders read the :ref:`Shading Language
<doc_shading_language>` doc and the :ref:`Spatial Shaders <doc_spatial_shader>`
doc. Also look at more advanced tutorials in the :ref:`Shading section
<toc-learn-features-shading>` and the :ref:`3D <toc-learn-features-3d>`
sections.


===================================================
/. ./tutorials/shaders/shader_materials.rst
===================================================

.. _doc_shader_materials:

Shader materials
================

Introduction
------------

For the most common cases, Godot provides ready to use materials for
most types of shaders, such as :ref:`SpatialMaterial <class_SpatialMaterial>`,
:ref:`CanvasItemMaterial <class_CanvasItemMaterial>` and :ref:`ParticlesMaterial <class_ParticlesMaterial>`.
They are flexible implementations that cover most use cases.

Shader materials allow writing a custom shader directly, for maximum flexibility.
Examples of this are:

-  Create procedural textures.
-  Create complex texture blending effects.
-  Create animated materials, or materials that change over time.
-  Create refractive effects or other advanced effects.
-  Create special lighting shaders for more exotic materials.
-  Animate vertices, like tree leaves or grass.
-  Create custom particle code.
-  And much more!

Godot provides built in functionality to make frequent operations
easier. Additionally, Godot's shader editor will detect errors as you
type, so you can see your edited shaders in real-time. It is also
possible to edit shaders using a visual, node-based graph editor.

Creating a ShaderMaterial
-------------------------

Create a new ShaderMaterial in some object of your choice. Go to the
"Material" property and create a ShaderMaterial.

.. image:: img/shader_material_create.png

Next, click on the shader material to see its properties. From here you
can create a shader or visual shader. Regular shaders use code to set
their properties while a visual shader uses a node based workflow.

If you need to you can convert a visual shader to a text shader.
However you can't convert a text shader to a visual shader.

Choose one of them and you can start editing your shader.

.. image:: img/shader_create.png

If you create a regular shader click on it and the shader editor will open.

.. image:: img/shader_material_editor.png

If you create a visual shader the visual shader editor will open automatically.

.. image:: img/visual_shader_editor.png

In the visual shader editor you can click a button and see what your visual
shader looks like as shader code. This can be useful if you're trying to
replicate a text shader as nodes, or it can be used as a preview for converting
your visual shader to a text shader.

.. image:: img/visual_shader_code.png

.. note::

   To learn more about visual shaders, read :ref:`doc_visual_shaders`.

Converting to ShaderMaterial
----------------------------

It is possible to convert from SpatialMaterial, CanvasItemMaterial and
ParticlesMaterial to ShaderMaterial. To do so, go to the material properties
and select the convert option.

.. image:: img/shader_material_convert.png

.. note::

   Using the convert option will turn the SpatialMaterial into a ShaderMaterial
   with a text shader, not a visual shader.


===================================================
/. ./tutorials/shaders/visual_shaders.rst
===================================================

.. _doc_visual_shaders:

Using VisualShaders
===================

Just as VisualScript is an alternative for users that prefer a graphical
approach to coding, VisualShaders are the visual alternative for creating
shaders.

As shaders are inherently linked to visuals, the graph-based approach with
previews of textures, materials, etc. offers a lot of additional convenience
compared to purely script-based shaders. On the other hand, VisualShaders do not
expose all features of the shader script and using both in parallel might be
necessary for specific effects.

.. note::

    If you are not familiar with shaders, start by reading
    :ref:`doc_introduction_to_shaders`.

Creating a VisualShader
-----------------------

VisualShaders can be created in any :ref:`class_ShaderMaterial`. To begin using
VisualShaders, create a new ``ShaderMaterial`` in an object of your choice.

.. image:: img/shader_material_create_mesh.png

Then assign a :ref:`class_VisualShader` resource to the ``Shader`` property.

.. image:: img/visual_shader_create.png

Click on the new ``VisualShader`` resource and the Visual Shader Editor will
open automatically. The layout of the Visual Shader Editor comprises two parts:
the upper toolbar and the graph itself.

.. image:: img/visual_shader_editor2.png

From left to right in the toolbar:

- The ``Add Node`` button displays a popup menu to let you add nodes to the
  shader graph.
- The drop-down menu is the shader type: Vertex, Fragment and Light. Like for
  script shaders, it defines what built-in nodes will be available.
- The following buttons and number input control the zooming level, grid
  snapping and distance between grid lines (in pixels).
- The last icon shows the generated shader code corresponding to your graph.

.. note::

    Although VisualShaders do not require coding, they share the same logic with
    script shaders. It is advised to learn the basics of both to have a good
    understanding of the shading pipeline.

    The visual shader graph is converted to a script shader behind the scene,
    and you can see this code by pressing the last button in the toolbar. This
    can be convenient to understand what a given node does and how to reproduce
    it in scripts.

Using the Visual Shader Editor
------------------------------

By default, every new ``VisualShader`` will have an output node. Every node
connection ends at one of the output node's sockets. A node is the basic unit to
create your shader. To add a new node, click on the ``Add Node`` button on the
upper left corner or right click on any empty location in the graph, and a menu
will pop up.

.. image:: img/vs_popup.png

This popup has the following properties:

- If you right-click on the graph, this menu will be called at the cursor
  position and the created node, in that case, will also be placed under that
  position; otherwise, it will be created at the graph's center.
- It can be resized horizontally and vertically allowing more content to be
  shown. Size transform and tree content position are saved between the calls,
  so if you suddenly closed the popup you can easily restore its previous state.
- The ``Expand All`` and ``Collapse All`` options in the drop-down option menu
  can be used to easily list the available nodes.
- You can also drag and drop nodes from the popup onto the graph.

While the popup has nodes sorted in categories, it can seem overwhelming at
first. Try to add some of the nodes, plug them in the output socket and observe
what happens.

When connecting any ``scalar`` output to a ``vector`` input, all components of
the vector will take the value of the scalar.

When connecting any ``vector`` output to a ``scalar`` input, the value of the
scalar will be the average of the vector's components.

Visual Shader nodes
-------------------

Below are some special nodes that are worth knowing about. The list is not
exhaustive and might be expanded with more nodes and examples.

Expression node
+++++++++++++++

The ``Expression`` node allows you to write Godot Shading Language (GLSL-like)
expressions inside your visual shaders. The node has buttons to add any amount
of required input and output ports and can be resized. You can also set up the
name and type of each port. The expression you have entered will apply
immediately to the material (once the focus leaves the expression text box). Any
parsing or compilation errors will be printed to the Output tab. The outputs are
initialized to their zero value by default. The node is located under the
Special tab and can be used in all shader modes.

.. image:: img/vs_expression.gif

The possibilities of this node are almost limitless – you can write complex
procedures, and use all the power of text-based shaders, such as loops, the
``discard`` keyword, extended types, etc. For example:

.. image:: img/vs_expression2.png

Fresnel node
++++++++++++

The ``Fresnel`` node is designed to accept normal and view vectors and produces
a scalar which is the saturated dot product between them. Additionally, you can
setup the inversion and the power of equation. The ``Fresnel`` node is great for
adding a rim-like lighting effect to objects.

.. image:: img/vs_fresnel.png

Boolean node
++++++++++++

The ``Boolean`` node can be converted to ``Scalar`` or ``Vector`` to represent
``0`` or ``1`` and ``(0, 0, 0)`` or ``(1, 1, 1)`` respectively. This property
can be used to enable or disable some effect parts with one click.

.. image:: img/vs_boolean.gif

If node
+++++++

The ``If`` node allows you to setup a vector which will be returned the result
of the comparison between ``a`` and ``b``. There are three vectors which can be
returned: ``a == b`` (in that case the tolerance parameter is provided as a
comparison threshold – by default it is equal to the minimal value, i.e.
``0.00001``), ``a > b`` and ``a < b``.

.. image:: img/vs_if.png

Switch node
+++++++++++

The ``Switch`` node returns a vector if the boolean condition is ``true`` or
``false``. ``Boolean`` was introduced above. If you convert a vector to a true
boolean, all components of the vector should be above zero.

.. image:: img/vs_switch.png

.. note::

    The ``Switch`` node is only available on the GLES3 backed. If you are
    targeting GLES2 devices, you cannot use ``switch`` statements.


===================================================
/. ./tutorials/shaders/screen-reading_shaders.rst
===================================================

.. _doc_screen-reading_shaders:

Screen-reading shaders
======================

Introduction
~~~~~~~~~~~~

It is often desired to make a shader that reads from the same
screen to which it's writing. 3D APIs, such as OpenGL or DirectX, make this very
difficult because of internal hardware limitations. GPUs are extremely
parallel, so reading and writing causes all sorts of cache and coherency
problems. As a result, not even the most modern hardware supports this
properly.

The workaround is to make a copy of the screen, or a part of the screen,
to a back-buffer and then read from it while drawing. Godot provides a
few tools that make this process easy.

SCREEN_TEXTURE built-in texture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Godot :ref:`doc_shading_language` has a special texture, ``SCREEN_TEXTURE`` (and ``DEPTH_TEXTURE`` for depth, in the case of 3D).
It takes as argument the UV of the screen and returns a vec3 RGB with the color. A
special built-in varying: SCREEN_UV can be used to obtain the UV for
the current fragment. As a result, this simple canvas_item fragment shader:

.. code-block:: glsl

    void fragment() {
        COLOR = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
    }

results in an invisible object, because it just shows what lies behind.

The reason why textureLod must be used is because, when Godot copies back
a chunk of the screen, it also does an efficient separatable gaussian blur to its mipmaps.

This allows for not only reading from the screen, but reading from it with different amounts
of blur at no cost.

.. note::

   Mipmaps are not generated in GLES2 due to poor performance and compatibility with older
   devices.

SCREEN_TEXTURE example
~~~~~~~~~~~~~~~~~~~~~~

``SCREEN_TEXTURE`` can be used for many things. There is a
special demo for *Screen Space Shaders*, that you can download to see
and learn. One example is a simple shader to adjust brightness, contrast
and saturation:

.. code-block:: glsl

    shader_type canvas_item;

    uniform float brightness = 1.0;
    uniform float contrast = 1.0;
    uniform float saturation = 1.0;

    void fragment() {
        vec3 c = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0).rgb;

        c.rgb = mix(vec3(0.0), c.rgb, brightness);
        c.rgb = mix(vec3(0.5), c.rgb, contrast);
        c.rgb = mix(vec3(dot(vec3(1.0), c.rgb) * 0.33333), c.rgb, saturation);

        COLOR.rgb = c;
    }

Behind the scenes
~~~~~~~~~~~~~~~~~

While this seems magical, it's not. In 2D, the ``SCREEN_TEXTURE`` built-in, when
first found in a node that is about to be drawn, does a full-screen
copy to a back-buffer. Subsequent nodes that use it in
shaders will not have the screen copied for them, because this ends up
being inefficient. In 3D, the screen is copied after the opaque geometry pass,
but before the transparent geometry pass, so transparent objects will not be
captured in the ``SCREEN_TEXTURE``.

As a result, in 2D, if shaders that use ``SCREEN_TEXTURE`` overlap, the second one
will not use the result of the first one, resulting in unexpected
visuals:

.. image:: img/texscreen_demo1.png

In the above image, the second sphere (top right) is using the same
source for ``SCREEN_TEXTURE`` as the first one below, so the first one
"disappears", or is not visible.

In 2D, this can be corrected via the :ref:`BackBufferCopy <class_BackBufferCopy>`
node, which can be instantiated between both spheres. BackBufferCopy can work by
either specifying a screen region or the whole screen:

.. image:: img/texscreen_bbc.png

With correct back-buffer copying, the two spheres blend correctly:

.. image:: img/texscreen_demo2.png

.. warning:

    Materials that use ``SCREEN_TEXTURE`` are considered transparent themselves and
    will not appear in the resulting ``SCREEN_TEXTURE`` of other materials.
    If you plan to instance a scene that uses a material with ``SCREEN_TEXTURE``,
    you will need to use a BackBufferCopy node.

In 3D, there is less flexibility to solve this particular issue because the
``SCREEN_TEXTURE`` is only captured once. Be careful when using
``SCREEN_TEXTURE`` in 3D as it won't capture transparent objects and may capture
some opaque objects that are in front of the object.

You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport <class_Viewport>`
with a camera in the same position as your object, and then use the
:ref:`Viewport's <class_Viewport>` texture instead of ``SCREEN_TEXTURE``.

Back-buffer logic
~~~~~~~~~~~~~~~~~

So, to make it clearer, here's how the backbuffer copying logic works in
Godot:

-  If a node uses the ``SCREEN_TEXTURE``, the entire screen is copied to the
   back buffer before drawing that node. This only happens the first
   time; subsequent nodes do not trigger this.
-  If a BackBufferCopy node was processed before the situation in the
   point above (even if ``SCREEN_TEXTURE`` was not used), the behavior
   described in the point above does not happen. In other words,
   automatic copying of the entire screen only happens if ``SCREEN_TEXTURE`` is
   used in a node for the first time and no BackBufferCopy node (not
   disabled) was found before in tree-order.
-  BackBufferCopy can copy either the entire screen or a region. If set
   to only a region (not the whole screen) and your shader uses pixels
   not in the region copied, the result of that read is undefined
   (most likely garbage from previous frames). In other words, it's
   possible to use BackBufferCopy to copy back a region of the screen
   and then use ``SCREEN_TEXTURE`` on a different region. Avoid this behavior!


DEPTH_TEXTURE
~~~~~~~~~~~~~

For 3D shaders, it's also possible to access the screen depth buffer. For this,
the ``DEPTH_TEXTURE`` built-in is used. This texture is not linear; it must be
converted via the inverse projection matrix.

The following code retrieves the 3D position below the pixel being drawn:

.. code-block:: glsl

    void fragment() {
        float depth = textureLod(DEPTH_TEXTURE, SCREEN_UV, 0.0).r;
        vec4 upos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
        vec3 pixel_position = upos.xyz / upos.w;
    }


===================================================
/. ./tutorials/shaders/converting_glsl_to_godot_shaders.rst
===================================================

.. _doc_converting_glsl_to_godot_shaders:

Converting GLSL to Godot shaders
================================

This document explains the differences between Godot's shading language and GLSL
and gives practical advice on how to migrate shaders from other sources, such as
Shadertoy and The Book of Shaders, into Godot shaders.

For detailed information on Godot's shading language, please refer to the
:ref:`Shading Language <doc_shading_language>` reference.

GLSL
----

Godot uses a shading language based on GLSL with the addition of a few
quality-of-life features. Accordingly, most features available in GLSL are
available in Godot's shading language.

Shader programs
^^^^^^^^^^^^^^^

In GLSL, each shader uses a separate program. You have one program for the
vertex shader and one for the fragment shader. In Godot, you have a single
shader that contains a ``vertex`` and/or a ``fragment`` function. If you only
choose to write one, Godot will supply the other.

Godot allows uniform variables and functions to be shared by defining the
fragment and vertex shaders in one file. In GLSL, the vertex and fragment
programs cannot share variables except when varyings are used.

Vertex attributes
^^^^^^^^^^^^^^^^^

In GLSL, you can pass in per-vertex information using attributes and have the
flexibility to pass in as much or as little as you want. In Godot, you have a
set number of input attributes, including ``VERTEX`` (position), ``COLOR``,
``UV``, ``UV2``, ``NORMAL``. For a complete list, see the :ref:`Shading language
reference <doc_shading_language>`.

gl_Position
^^^^^^^^^^^

``gl_Position`` receives the final position of a vertex specified in the vertex
shader. It is specified by the user in clip space. Typically, in GLSL, the model
space vertex position is passed in using a vertex attribute called ``position``
and you handle the conversion from model space to clip space manually.

In Godot, ``VERTEX`` specifies the vertex position in model space at the
beginning of the ``vertex`` function. Godot also handles the final conversion to
clip space after the user-defined ``vertex`` function is run. If you want to
skip the conversion from model to view space, you can set the ``render_mode`` to
``skip_vertex_transform``. If you want to skip all transforms, set
``render_mode`` to ``skip_vertex_transform`` and set the ``PROJECTION_MATRIX``
to ``mat4(1.0)`` in order to nullify the final transform from view space to clip
space.

Varyings
^^^^^^^^

Varyings are a type of variable that can be passed from the vertex shader to the
fragment shader. In modern GLSL (3.0 and up), varyings are defined with the
``in`` and ``out`` keywords. A variable going out of the vertex shader is
defined with ``out`` in the vertex shader and ``in`` inside the fragment shader.

Main
^^^^

In GLSL, each shader program looks like a self-contained C-style program.
Accordingly, the main entry point is ``main``. If you are copying a vertex
shader, rename ``main`` to ``vertex`` and if you are copying a fragment shader,
rename ``main`` to ``fragment``.

Constants
^^^^^^^^^

Global array constants are not supported in Godot 3.x. You can fake the functionality by using a uniform
initialized to the value, but you will not benefit from the increased speed from using a constant.

Macros
^^^^^^

In keeping with its similarity to C, GLSL lets you use macros. Commonly
``#define`` is used to define constants or small functions. There is no
straightforward way to translate defines to Godot's shading language. If it is a
function that is defined, then replace with a function, and if it is a constant,
then replace with a uniform. For other macros (``#if``, ``#ifdef``, etc.), there
is no equivalent because they run during the pre-processing stage of
compilation.

Variables
^^^^^^^^^

GLSL has many built-in variables that are hard-coded. These variables are not
uniforms, so they are not editable from the main program.

+---------------------+---------+------------------------+-----------------------------------------------------+
|Variable             |Type     |Equivalent              |Description                                          |
+=====================+=========+========================+=====================================================+
|gl_FragColor         |out vec4 |COLOR                   |Output color for each pixel.                         |
+---------------------+---------+------------------------+-----------------------------------------------------+
|gl_FragCoord         |vec4     |FRAGCOORD               |For full screen quads. For smaller quads, use UV.    |
+---------------------+---------+------------------------+-----------------------------------------------------+
|gl_Position          |vec4     |VERTEX                  |Position of Vertex, output from Vertex Shader.       |
+---------------------+---------+------------------------+-----------------------------------------------------+
|gl_PointSize         |float    |POINT_SIZE              |Size of Point primitive.                             |
+---------------------+---------+------------------------+-----------------------------------------------------+
|gl_PointCoord        |vec2     |POINT_COORD             |Position on point when drawing Point primitives.     |
+---------------------+---------+------------------------+-----------------------------------------------------+
|gl_FrontFacing       |bool     |FRONT_FACING            |True if front face of primitive.                     |
+---------------------+---------+------------------------+-----------------------------------------------------+

.. _glsl_coordinates:

Coordinates
^^^^^^^^^^^

``gl_FragCoord`` in GLSL and ``FRAGCOORD`` in the Godot shading language use the
same coordinate system. If using UV in Godot, the y-coordinate will be flipped
upside down.

Precision
^^^^^^^^^

In GLSL, you can define the precision of a given type (float or int) at the top
of the shader with the ``precision`` keyword. In Godot, you can set the
precision of individual variables as you need by placing precision qualifiers
``lowp``, ``mediump``, and ``highp`` before the type when defining the variable.
For more information, see the :ref:`Shading Language <doc_shading_language>`
reference.

Shadertoy
---------

`Shadertoy <https://www.shadertoy.com/results?query=&sort=popular&from=10&num=4>`_
is a website that makes it easy to write fragment shaders and
create `pure magic <https://www.shadertoy.com/view/4tjGRh>`_.

Shadertoy does not give the user full control over the shader. It handles all
the input and uniforms and only lets the user write the fragment shader.

Types
^^^^^

Shadertoy uses the webgl spec, so it runs a slightly different version of GLSL.
However, it still has the regular types, including constants and macros.

mainImage
^^^^^^^^^

The main point of entry to a Shadertoy shader is the ``mainImage`` function.
``mainImage`` has two parameters, ``fragColor`` and ``fragCoord``, which
correspond to ``COLOR`` and ``FRAGCOORD`` in Godot, respectively. These
parameters are handled automatically in Godot, so you do not need to include
them as parameters yourself. Anything in the ``mainImage`` function should be
copied into the ``fragment`` function when porting to Godot.

Variables
^^^^^^^^^

In order to make writing fragment shaders straightforward and easy, Shadertoy
handles passing a lot of helpful information from the main program into the
fragment shader for you. A few of these have no equivalents in Godot because
Godot has chosen not to make them available by default. This is okay because
Godot gives you the ability to make your own uniforms. For variables whose
equivalents are listed as "Provide with Uniform", users are responsible for
creating that uniform themselves. The description gives the reader a hint about
what they can pass in as a substitute.

+---------------------+---------+------------------------+-----------------------------------------------------+
|Variable             |Type     |Equivalent              |Description                                          |
+=====================+=========+========================+=====================================================+
|fragColor            |out vec4 |COLOR                   |Output color for each pixel.                         |
+---------------------+---------+------------------------+-----------------------------------------------------+
|fragCoord            |vec2     |FRAGCOORD.xy            |For full screen quads. For smaller quads, use UV.    |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iResolution          |vec3     |1.0 / SCREEN_PIXEL_SIZE |Can also pass in manually.                           |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iTime                |float    |TIME                    |Time since shader started.                           |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iTimeDelta           |float    |Provide with Uniform    |Time to render previous frame.                       |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iFrame               |float    |Provide with Uniform    |Frame number.                                        |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iChannelTime[4]      |float    |Provide with Uniform    |Time since that particular texture started.          |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iMouse               |vec4     |Provide with Uniform    |Mouse position in pixel coordinates.                 |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iDate                |vec4     |Provide with Uniform    |Current date, expressed in seconds.                  |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iChannelResolution[4]|vec3     |1.0 / TEXTURE_PIXEL_SIZE|Resolution of particular texture.                    |
+---------------------+---------+------------------------+-----------------------------------------------------+
|iChanneli            |Sampler2D|TEXTURE                 |Godot provides only one built-in; user can make more.|
+---------------------+---------+------------------------+-----------------------------------------------------+

Coordinates
^^^^^^^^^^^

``fragCoord`` behaves the same as ``gl_FragCoord`` in :ref:`GLSL
<glsl_coordinates>` and ``FRAGCOORD`` in Godot.


The Book of Shaders
-------------------

Similar to Shadertoy, `The Book of Shaders <https://thebookofshaders.com>`_
provides access to a fragment shader in the web browser, with which the user may
interact. The user is restricted to writing fragment shader code with a set list
of uniforms passed in and with no ability to add additional uniforms.

For further help on porting shaders to various frameworks generally, The Book of
Shaders provides a `page <https://thebookofshaders.com/04>`_ on running shaders
in various frameworks.

Types
^^^^^

The Book of Shaders uses the webgl spec, so it runs a slightly different version
of GLSL. However, it still has the regular types, including constants and
macros.

Main
^^^^

The entry point for a Book of Shaders fragment shader is ``main``, just like in
GLSL. Everything written in a Book of Shaders ``main`` function should be copied
into Godot's ``fragment`` function.

Variables
^^^^^^^^^

The Book of Shaders sticks closer to plain GLSL than Shadertoy does. It also
implements fewer uniforms than Shadertoy.

+---------------------+---------+------------------------+-----------------------------------------------------+
|Variable             |Type     |Equivalent              |Description                                          |
+=====================+=========+========================+=====================================================+
|gl_FragColor         |out vec4 |COLOR                   |Output color for each pixel.                         |
+---------------------+---------+------------------------+-----------------------------------------------------+
|gl_FragCoord         |vec4     |FRAGCOORD               |For full screen quads. For smaller quads, use UV.    |
+---------------------+---------+------------------------+-----------------------------------------------------+
|u_resolution         |vec2     |1.0 / SCREEN_PIXEL_SIZE |Can also pass in manually.                           |
+---------------------+---------+------------------------+-----------------------------------------------------+
|u_time               |float    |TIME                    |Time since shader started.                           |
+---------------------+---------+------------------------+-----------------------------------------------------+
|u_mouse              |vec2     |Provide with Uniform    |Mouse position in pixel coordinates.                 |
+---------------------+---------+------------------------+-----------------------------------------------------+

Coordinates
^^^^^^^^^^^

The Book of Shaders uses the same coordinate system as
:ref:`GLSL <glsl_coordinates>`.


===================================================
/. ./tutorials/shaders/shaders_style_guide.rst
===================================================

.. _doc_shaders_style_guide:

Shaders style guide
===================

This style guide lists conventions to write elegant shaders. The goal is to
encourage writing clean, readable code and promote consistency across projects,
discussions, and tutorials. Hopefully, this will also support the development of
auto-formatting tools.

Since the Godot shader language is close to C-style languages and GLSL, this
guide is inspired by Godot's own GLSL formatting. You can view an example of a
GLSL file in Godot's source code
`here <https://github.com/godotengine/godot/blob/master/drivers/gles2/shaders/copy.glsl>`__.

Style guides aren't meant as hard rulebooks. At times, you may not be able to
apply some of the guidelines below. When that happens, use your best judgment,
and ask fellow developers for insights.

In general, keeping your code consistent in your projects and within your team is
more important than following this guide to a tee.

.. note:: Godot's built-in shader editor uses a lot of these conventions
          by default. Let it help you.

Here is a complete shader example based on these guidelines:

.. code-block:: glsl

    shader_type canvas_item;
    // Screen-space shader to adjust a 2D scene's brightness, contrast
    // and saturation. Taken from
    // https://github.com/godotengine/godot-demo-projects/blob/master/2d/screen_space_shaders/shaders/BCS.shader

    uniform float brightness = 0.8;
    uniform float contrast = 1.5;
    uniform float saturation = 1.8;

    void fragment() {
        vec3 c = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0).rgb;

        c.rgb = mix(vec3(0.0), c.rgb, brightness);
        c.rgb = mix(vec3(0.5), c.rgb, contrast);
        c.rgb = mix(vec3(dot(vec3(1.0), c.rgb) * 0.33333), c.rgb, saturation);

        COLOR.rgb = c;
    }

Formatting
----------

Encoding and special characters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Use line feed (**LF**) characters to break lines, not CRLF or CR. *(editor default)*
* Use one line feed character at the end of each file. *(editor default)*
* Use **UTF-8** encoding without a `byte order mark <https://en.wikipedia.org/wiki/Byte_order_mark>`_. *(editor default)*
* Use **Tabs** instead of spaces for indentation. *(editor default)*

Indentation
~~~~~~~~~~~

Each indent level should be one tab greater than the block containing it.

**Good**:

.. code-block:: glsl

    void fragment() {
        COLOR = vec3(1.0, 1.0, 1.0);
    }

**Bad**:

.. code-block:: glsl

    void fragment() {
            COLOR = vec3(1.0, 1.0, 1.0);
    }

Use 2 indent levels to distinguish continuation lines from
regular code blocks.

**Good**:

.. code-block:: glsl

    vec2 st = vec2(
            atan(NORMAL.x, NORMAL.z),
            acos(NORMAL.y));

**Bad**:

.. code-block:: glsl

    vec2 st = vec2(
        atan(NORMAL.x, NORMAL.z),
        acos(NORMAL.y));


Line breaks and blank lines
~~~~~~~~~~~~~~~~~~~~~~~~~~~

For a general indentation rule, follow
`the "1TBS Style" <https://en.wikipedia.org/wiki/Indentation_style#Variant:_1TBS_(OTBS)>`_
which recommends placing the brace associated with a control statement on the
same line. Always use braces for statements, even if they only span one line.
This makes them easier to refactor and avoids mistakes when adding more lines to
an ``if`` statement or similar.

**Good**:

.. code-block:: glsl

    void fragment() {
        if (true) {
            // ...
        }
    }

**Bad**:

.. code-block:: glsl

    void fragment()
    {
        if (true)
            // ...
    }

Blank lines
~~~~~~~~~~~

Surround function definitions with one (and only one) blank line:

.. code-block:: glsl

    void do_something() {
        // ...
    }

    void fragment() {
        // ...
    }

Use one (and only one) blank line inside functions to separate logical sections.

Line length
~~~~~~~~~~~

Keep individual lines of code under 100 characters.

If you can, try to keep lines under 80 characters. This helps to read the code
on small displays and with two shaders opened side-by-side in an external text
editor. For example, when looking at a differential revision.

One statement per line
~~~~~~~~~~~~~~~~~~~~~~

Never combine multiple statements on a single line.

**Good**:

.. code-block:: glsl

    void fragment() {
        ALBEDO = vec3(1.0);
        EMISSION = vec3(1.0);
    }

**Bad**:

.. code-block:: glsl

    void fragment() {
        ALBEDO = vec3(1.0); EMISSION = vec3(1.0);
    }

The only exception to that rule is the ternary operator:

.. code-block:: glsl

   void fragment() {
        bool should_be_white = true;
        ALBEDO = should_be_white ? vec3(1.0) : vec3(0.0);
    }

Comment spacing
~~~~~~~~~~~~~~~

Regular comments should start with a space, but not code that you comment out.
This helps differentiate text comments from disabled code.

**Good**:

.. code-block:: glsl

    // This is a comment.
    //return;

**Bad**:

.. code-block:: glsl

    //This is a comment.
    // return;

Don't use multiline comment syntax if your comment can fit on a single line:

.. code-block:: glsl

    /* This is another comment. */

.. note::

   In the shader editor, to make the selected code a comment (or uncomment it),
   press :kbd:`Ctrl + K`. This feature adds or removes ``//`` at the start of
   the selected lines.

Whitespace
~~~~~~~~~~

Always use one space around operators and after commas. Also, avoid extraneous spaces
in function calls.

**Good**:

.. code-block:: glsl

    COLOR.r = 5.0;
    COLOR.r = COLOR.g + 0.1;
    COLOR.b = some_function(1.0, 2.0);

**Bad**:

.. code-block:: glsl

    COLOR.r=5.0;
    COLOR.r = COLOR.g+0.1;
    COLOR.b = some_function (1.0,2.0);

Don't use spaces to align expressions vertically:

.. code-block:: glsl

    ALBEDO.r   = 1.0;
    EMISSION.r = 1.0;

Floating-point numbers
~~~~~~~~~~~~~~~~~~~~~~

Always specify at least one digit for both the integer and fractional part. This
makes it easier to distinguish floating-point numbers from integers, as well as
distinguishing numbers greater than 1 from those lower than 1.

**Good**:

.. code-block:: glsl

    void fragment() {
        ALBEDO.rgb = vec3(5.0, 0.1, 0.2);
    }

**Bad**:

.. code-block:: glsl

    void fragment() {
        ALBEDO.rgb = vec3(5., .1, .2);
    }

Accessing vector members
------------------------

Use ``r``, ``g``, ``b``, and ``a`` when accessing a vector's members if it
contains a color. If the vector contains anything else than a color, use ``x``,
``y``, ``z``, and ``w``. This allows those reading your code to better
understand what the underlying data represents.

**Good**:

.. code-block:: glsl

    COLOR.rgb = vec3(5.0, 0.1, 0.2);

**Bad**:

.. code-block:: glsl

    COLOR.xyz = vec3(5.0, 0.1, 0.2);

Naming conventions
------------------

These naming conventions follow the Godot Engine style. Breaking these will make
your code clash with the built-in naming conventions, leading to inconsistent
code.

Functions and variables
~~~~~~~~~~~~~~~~~~~~~~~

Use snake\_case to name functions and variables:

.. code-block:: glsl

   void some_function() {
        float some_variable = 0.5;
   }

Constants
~~~~~~~~~

Write constants with CONSTANT\_CASE, that is to say in all caps with an
underscore (\_) to separate words:

.. code-block:: glsl

    const float GOLDEN_RATIO = 1.618;

Code order
----------

We suggest to organize shader code this way:

.. code-block:: glsl

    01. shader type declaration
    02. render mode declaration
    03. // docstring

    04. uniforms
    05. constants
    06. varyings

    07. other functions
    08. vertex() function
    09. fragment() function
    10. light() function

We optimized the order to make it easy to read the code from top to bottom, to
help developers reading the code for the first time understand how it works, and
to avoid errors linked to the order of variable declarations.

This code order follows two rules of thumb:

1. Metadata and properties first, followed by methods.
2. "Public" comes before "private". In a shader language's context, "public"
   refers to what's easily adjustable by the user (uniforms).

Local variables
~~~~~~~~~~~~~~~

Declare local variables as close as possible to their first use. This makes it
easier to follow the code, without having to scroll too much to find where the
variable was declared.


===================================================
/. ./tutorials/shaders/advanced_postprocessing.rst
===================================================

.. _doc_advanced_postprocessing:

Advanced post-processing
========================

Introduction
------------

This tutorial describes an advanced method for post-processing in Godot.
In particular, it will explain how to write a post-processing shader that
uses the depth buffer. You should already be familiar with post-processing
generally and, in particular, with the methods outlined in the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`.

In the previous post-processing tutorial, we rendered the scene to a :ref:`Viewport <class_Viewport>`
and then rendered the Viewport in a :ref:`ViewportContainer <class_ViewportContainer>`
to the main scene. One limitation of this method is that we could not access the
depth buffer because the depth buffer is only available in spatial shaders and
Viewports do not maintain depth information.

Full screen quad
----------------

In the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`, we
covered how to use a Viewport to make custom post-processing effects. There are
two main drawbacks of using a Viewport:

1. The depth buffer cannot be accessed
2. The effect of the post-processing shader is not visible in the editor

To get around the limitation on using the depth buffer, use a :ref:`MeshInstance <class_MeshInstance>`
with a :ref:`QuadMesh <class_QuadMesh>` primitive. This allows us to use a spatial
shader and to access the depth texture of the scene. Next, use a vertex shader
to make the quad cover the screen at all times so that the post-processing
effect will be applied at all times, including in the editor.

First, create a new MeshInstance and set its mesh to a QuadMesh. This creates a quad
centered at position ``(0, 0, 0)`` with a width and height of ``1``. Set the width
and height to ``2``. Right now, the quad occupies a position in world space at the
origin; however, we want it to move with the camera so that it always covers the
entire screen. To do this, we will bypass the coordinate transforms that translate
the vertex positions through the difference coordinate spaces and treat the vertices
as if they were already in clip space.

The vertex shader expects coordinates to be output in clip space, which are coordinates
ranging from ``-1`` at the left and bottom of the screen to ``1`` at the top and right
of the screen. This is why the QuadMesh needs to have height and width of ``2``.
Godot handles the transform from model to view space to clip space behind the scenes,
so we need to nullify the effects of Godot's transformations. We do this by setting the
``POSITION`` built-in to our desired position. ``POSITION`` bypasses the built-in transformations
and sets the vertex position directly.

.. code-block:: glsl

  shader_type spatial;

  void vertex() {
    POSITION = vec4(VERTEX, 1.0);
  }

Even with this vertex shader, the quad keeps disappearing. This is due to frustum
culling, which is done on the CPU. Frustum culling uses the camera matrix and the
AABBs of Meshes to determine if the Mesh will be visible *before* passing it to the GPU.
The CPU has no knowledge of what we are doing with the vertices, so it assumes the
coordinates specified refer to world positions, not clip space positions, which results
in Godot culling the quad when we turn away from the center of the scene. In
order to keep the quad from being culled, there are a few options:

1. Add the QuadMesh as a child to the camera, so the camera is always pointed at it
2. Set the Geometry property ``extra_cull_margin`` as large as possible in the QuadMesh

The second option ensures that the quad is visible in the editor, while the first
option guarantees that it will still be visible even if the camera moves outside the cull margin.
You can also use both options.

Depth texture
-------------

To read from the depth texture, perform a texture lookup using ``texture()`` and
the uniform variable ``DEPTH_TEXTURE``.

.. code-block:: glsl

  float depth = texture(DEPTH_TEXTURE, SCREEN_UV).x;

.. note:: Similar to accessing the screen texture, accessing the depth texture is only
          possible when reading from the current viewport. The depth texture cannot be
          accessed from another viewport to which you have rendered.

The values returned by ``DEPTH_TEXTURE`` are between ``0`` and ``1`` and are nonlinear.
When displaying depth directly from the ``DEPTH_TEXTURE``, everything will look almost
white unless it is very close. This is because the depth buffer stores objects closer
to the camera using more bits than those further, so most of the detail in depth
buffer is found close to the camera. In order to make the depth value align with world or
model coordinates, we need to linearize the value. When we apply the projection matrix to the
vertex position, the z value is made nonlinear, so to linearize it, we multiply it by the
inverse of the projection matrix, which in Godot, is accessible with the variable
``INV_PROJECTION_MATRIX``.

Firstly, take the screen space coordinates and transform them into normalized device
coordinates (NDC). NDC run from ``-1`` to ``1``, similar to clip space coordinates.
Reconstruct the NDC using ``SCREEN_UV`` for the ``x`` and ``y`` axis, and
the depth value for ``z``.

.. code-block:: glsl

  void fragment() {
    float depth = texture(DEPTH_TEXTURE, SCREEN_UV).x;
    vec3 ndc = vec3(SCREEN_UV, depth) * 2.0 - 1.0;
  }

Convert NDC to view space by multiplying the NDC by ``INV_PROJECTION_MATRIX``.
Recall that view space gives positions relative to the camera, so the ``z`` value will give us
the distance to the point.

.. code-block:: glsl

  void fragment() {
    ...
    vec4 view = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
    view.xyz /= view.w;
    float linear_depth = -view.z;
  }

Because the camera is facing the negative ``z`` direction, the position will have a negative ``z`` value.
In order to get a usable depth value, we have to negate ``view.z``.

The world position can be constructed from the depth buffer using the following code. Note
that the ``CAMERA_MATRIX`` is needed to transform the position from view space into world space, so
it needs to be passed to the fragment shader with a varying.

.. code-block:: glsl

  varying mat4 CAMERA;

  void vertex() {
    CAMERA = CAMERA_MATRIX;
  }

  void fragment() {
    ...
    vec4 world = CAMERA * INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
    vec3 world_position = world.xyz / world.w;
  }

An optimization
---------------

You can benefit from using a single large triangle rather than using a full
screen quad. The reason for this is explained `here <https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_.
However, the benefit is quite small and only beneficial when running especially
complex fragment shaders.

Set the Mesh in the MeshInstance to an :ref:`ArrayMesh <class_ArrayMesh>`. An
ArrayMesh is a tool that allows you to easily construct a Mesh from Arrays for
vertices, normals, colors, etc.

Now, attach a script to the MeshInstance and use the following code:

::

  extends MeshInstance

  func _ready():
    # Create a single triangle out of vertices:
    var verts = PoolVector3Array()
    verts.append(Vector3(-1.0, -1.0, 0.0))
    verts.append(Vector3(-1.0, 3.0, 0.0))
    verts.append(Vector3(3.0, -1.0, 0.0))

    # Create an array of arrays.
    # This could contain normals, colors, UVs, etc.
    var mesh_array = []
    mesh_array.resize(Mesh.ARRAY_MAX) #required size for ArrayMesh Array
    mesh_array[Mesh.ARRAY_VERTEX] = verts #position of vertex array in ArrayMesh Array

    # Create mesh from mesh_array:
    mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, mesh_array)

.. note:: The triangle is specified in normalized device coordinates. Recall, NDC run
          from ``-1`` to ``1`` in both the ``x`` and ``y`` directions. This makes the screen
          ``2`` units wide and ``2`` units tall. In order to cover the entire screen with
          a single triangle, use a triangle that is ``4`` units wide and ``4``
          units tall, double its height and width.

Assign the same vertex shader from above and everything should look exactly the same.

The one drawback to using an ArrayMesh over using a QuadMesh is that the ArrayMesh
is not visible in the editor because the triangle is not constructed until the scene
is run. To get around that, construct a single triangle Mesh in a modelling program
and use that in the MeshInstance instead.


===================================================
/. ./tutorials/shaders/using_viewport_as_texture.rst
===================================================

.. _doc_viewport_as_texture:

Using a Viewport as a texture
=============================

Introduction
------------

This tutorial will introduce you to using the :ref:`Viewport <class_Viewport>` as a
texture that can be applied to 3D objects. In order to do so, it will walk you through the process
of making a procedural planet like the one below:

.. image:: img/planet_example.png

.. note:: This tutorial does not cover how to code a dynamic atmosphere like the one this planet has.

This tutorial assumes you are familiar with how to set up a basic scene including:
a :ref:`Camera <class_Camera>`, a :ref:`light source <class_OmniLight>`, a
:ref:`Mesh Instance <class_MeshInstance>` with a :ref:`Primitive Mesh <class_PrimitiveMesh>`,
and applying a :ref:`SpatialMaterial <class_SpatialMaterial>` to the mesh. The focus will be on using
the :ref:`Viewport <class_Viewport>` to dynamically create textures that can be applied to the mesh.

In this tutorial, we'll cover the following topics:

- How to use a :ref:`Viewport <class_Viewport>` as a render texture
- Mapping a texture to a sphere with equirectangular mapping
- Fragment shader techniques for procedural planets
- Setting a Roughness map from a :ref:`Viewport Texture <class_ViewportTexture>`

Setting up the Viewport
-----------------------

First, add a :ref:`Viewport <class_Viewport>` to the scene.

Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, 512)``. The
:ref:`Viewport <class_Viewport>` can actually be any size so long as the width is double the height.
The width needs to be double the height so that the image will accurately map onto the
sphere, as we will be using equirectangular projection, but more on that later.

.. image:: img/planet_new_viewport.png

Next, disable HDR and disable 3D. We don't need HDR because our planet's surface will not be especially
bright, so values between ``0`` and ``1`` will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>`
to render the surface, so we don't need 3D either.

Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child.

Set the anchors "Right" and "Bottom" to ``1``, then make sure all the margins are set to ``0``. This
will ensure that the :ref:`ColorRect <class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`.

.. image:: img/planet_new_colorrect.png

Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material > ``New ShaderMaterial``).

.. note:: Basic familiarity with shading is recommended for this tutorial. However, even if you are new
          to shaders, all the code will be provided, so you should have no problem following along.

ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial > Shader > ``New Shader`` > click / Edit:

.. code-block:: glsl

    shader_type canvas_item;

    void fragment() {
        COLOR = vec4(UV.x, UV.y, 0.5, 1.0);
    }

The above code renders a gradient like the one below.

.. image:: img/planet_gradient.png

Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render to and we have a unique image that we can
apply to the sphere.

Applying the texture
--------------------

MeshInstance > GeometryInstance > Geometry > Material Override > ``New SpatialMaterial``:

Now we go into the :ref:`Mesh Instance <class_MeshInstance>` and add a :ref:`SpatialMaterial <class_SpatialMaterial>`
to it. No need for a special :ref:`Shader Material <class_ShaderMaterial>` (although that would be a good idea
for more advanced effects, like the atmosphere in the example above).

MeshInstance > GeometryInstance > Geometry > Material Override > ``click`` / ``Edit``:

Open the newly created :ref:`SpatialMaterial <class_SpatialMaterial>` and scroll down to the "Albedo" section
and click beside the "Texture" property to add an Albedo Texture. Here we will apply the texture we made.
Choose "New ViewportTexture"

.. image:: img/planet_new_viewport_texture.png

Then, from the menu that pops up, select the Viewport that we rendered to earlier.

.. image:: img/planet_pick_viewport_texture.png

Your sphere should now be colored in with the colors we rendered to the Viewport.

.. image:: img/planet_seam.png

Notice the ugly seam that forms where the texture wraps around? This is because we are picking
a color based on UV coordinates and UV coordinates do not wrap around the texture. This is a classic
problem in 2D map projection. Game developers often have a 2-dimensional map they want to project
onto a sphere, but when it wraps around, it has large seams. There is an elegant workaround for this
problem that we will illustrate in the next section.

Making the planet texture
-------------------------

So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears magically on the sphere. But there is an ugly
seam created by our texture coordinates. So how do we get a range of coordinates that wrap around
the sphere in a nice way? One solution is to use a function that repeats on the domain of our texture.
``sin`` and ``cos`` are two such functions. Let's apply them to the texture and see what happens.

.. code-block:: glsl

    COLOR.xyz = vec3(sin(UV.x * 3.14159 * 4.0) * cos(UV.y * 3.14159 * 4.0) * 0.5 + 0.5);

.. image:: img/planet_sincos.png

Not too bad. If you look around, you can see that the seam has now disappeared, but in its place, we
have pinching at the poles. This pinching is due to the way Godot maps textures to spheres in its
:ref:`SpatialMaterial <class_SpatialMaterial>`. It uses a projection technique called equirectangular
projection, which translates a spherical map onto a 2D plane.

.. note:: If you are interested in a little extra information on the technique, we will be converting from
          spherical coordinates into Cartesian coordinates. Spherical coordinates map the longitude and
          latitude of the sphere, while Cartesian coordinates are, for all intents and purposes, a
          vector from the center of the sphere to the point.

For each pixel, we will calculate its 3D position on the sphere. From that, we will use
3D noise to determine a color value. By calculating the noise in 3D, we solve the problem
of the pinching at the poles. To understand why, picture the noise being calculated across the
surface of the sphere instead of across the 2D plane. When you calculate across the
surface of the sphere, you never hit an edge, and hence you never create a seam or
a pinch point on the pole. The following code converts the ``UVs`` into Cartesian
coordinates.

.. code-block:: glsl

    float theta = UV.y * 3.14159;
    float phi = UV.x * 3.14159 * 2.0;
    vec3 unit = vec3(0.0, 0.0, 0.0);

    unit.x = sin(phi) * sin(theta);
    unit.y = cos(theta) * -1.0;
    unit.z = cos(phi) * sin(theta);
    unit = normalize(unit);

And if we use ``unit`` as an output ``COLOR`` value, we get:

.. image:: img/planet_normals.png

Now that we can calculate the 3D position of the surface of the sphere, we can use 3D noise
to make the planet. We will be using this noise function directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:

.. code-block:: glsl

    vec3 hash(vec3 p) {
        p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
                 dot(p, vec3(269.5, 183.3, 246.1)),
                 dot(p, vec3(113.5, 271.9, 124.6)));

        return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
    }

    float noise(vec3 p) {
      vec3 i = floor(p);
      vec3 f = fract(p);
      vec3 u = f * f * (3.0 - 2.0 * f);

      return mix(mix(mix(dot(hash(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),
                         dot(hash(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),
                     mix(dot(hash(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),
                         dot(hash(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),
                 mix(mix(dot(hash(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),
                         dot(hash(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),
                     mix(dot(hash(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)),
                         dot(hash(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z );
    }

.. note:: All credit goes to the author, Inigo Quilez. It is published under the ``MIT`` licence.

Now to use ``noise``, add the following to the    ``fragment`` function:

.. code-block:: glsl

    float n = noise(unit * 5.0);
    COLOR.xyz = vec3(n * 0.5 + 0.5);

.. image:: img/planet_noise.png

.. note:: In order to highlight the texture, we set the material to unshaded.

You can see now that the noise indeed wraps seamlessly around the sphere. Although this
looks nothing like the planet you were promised. So let's move onto something more colorful.

Coloring the planet
-------------------

Now to make the planet colors. While there are many ways to do this, for now, we will stick
with a gradient between water and land.

To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two values to interpolate
between and a third argument to choose how much to interpolate between them; in essence,
it *mixes* the two values together. In other APIs, this function is often called ``lerp``.
However, ``lerp`` is typically reserved for mixing two floats together; ``mix`` can take any
values whether it be floats or vector types.

.. code-block:: glsl

    COLOR.xyz = mix(vec3(0.05, 0.3, 0.5), vec3(0.9, 0.4, 0.1), n * 0.5 + 0.5);

The first color is blue for the ocean. The second color is a kind of reddish color (because
all alien planets need red terrain). And finally, they are mixed together by ``n * 0.5 + 0.5``.
``n`` smoothly varies between ``-1`` and ``1``. So we map it into the ``0-1`` range that ``mix`` expects.
Now you can see that the colors change between blue and red.

.. image:: img/planet_noise_color.png

That is a little more blurry than we want. Planets typically have a relatively clear separation between
land and sea. In order to do that, we will change the last term to ``smoothstep(-0.1, 0.0, n)``.
And thus the whole line becomes:

.. code-block:: glsl

    COLOR.xyz = mix(vec3(0.05, 0.3, 0.5), vec3(0.9, 0.4, 0.1), smoothstep(-0.1, 0.0, n));

What ``smoothstep`` does is return ``0`` if the third argument is below the first and ``1`` if the
third argument is larger than the second and smoothly blends between ``0`` and ``1`` if the third number
is between the first and the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is less than ``-0.1``
and it returns ``1`` whenever ``n`` is above ``0``.

.. image:: img/planet_noise_smooth.png

One more thing to make this a little more planet-y. The land shouldn't be so blobby; let's make the edges
a little rougher. A trick that is often used in shaders to make rough looking terrain with noise is
to layer levels of noise over one another at various frequencies. We use one layer to make the
overall blobby structure of the continents. Then another layer breaks up the edges a bit, and then
another, and so on. What we will do is calculate ``n`` with four lines of shader code
instead of just one. ``n`` becomes:

.. code-block:: glsl

    float n = noise(unit * 5.0) * 0.5;
    n += noise(unit * 10.0) * 0.25;
    n += noise(unit * 20.0) * 0.125;
    n += noise(unit * 40.0) * 0.0625;

And now the planet looks like:

.. image:: img/planet_noise_fbm.png

And with shading turned back on, it looks like:

.. image:: img/planet_noise_fbm_shaded.png

Making an ocean
---------------

One final thing to make this look more like a planet. The ocean and the land reflect light differently.
So we want the ocean to shine a little more than the land. We can do this by passing a fourth value
into the ``alpha`` channel of our output ``COLOR`` and using it as a Roughness map.

.. code-block:: glsl

    COLOR.a = 0.3 + 0.7 * smoothstep(-0.1, 0.0, n);

This line returns ``0.3`` for water and ``1.0`` for land. This means that the land is going to be quite
rough, while the water will be quite smooth.

And then, in the material, under the "Metallic" section, make sure ``Metallic`` is set to ``0`` and
``Specular`` is set to ``1``. The reason for this is the water reflects light really well, but
isn't metallic. These values are not physically accurate, but they are good enough for this demo.

Next, under the "Roughness" section, set ``Roughness`` to ``1`` and set the roughness texture to a
:ref:`Viewport Texture <class_ViewportTexture>` pointing to our planet texture :ref:`Viewport <class_Viewport>`.
Finally, set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use the ``alpha``
channel of our output ``COLOR`` as the ``Roughness`` value.

.. image:: img/planet_ocean.png

You'll notice that very little changes except that the planet is no longer reflecting the sky.
This is happening because, by default, when something is rendered with an
alpha value, it gets drawn as a transparent object over the background. And since the default background
of the :ref:`Viewport <class_Viewport>` is opaque, the ``alpha`` channel of the
:ref:`Viewport Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture being
drawn with slightly fainter colors and a ``Roughness`` value of ``1`` everywhere. To correct this, we
go into the :ref:`Viewport <class_Viewport>` and enable the "Transparent Bg" property. Since we are now
rendering one transparent object on top of another, we want to enable ``blend_premul_alpha``:

.. code-block:: glsl

    render_mode blend_premul_alpha;

This pre-multiplies the colors by the ``alpha`` value and then blends them correctly together. Typically,
when blending one transparent color on top of another, even if the background has an ``alpha`` of ``0`` (as it
does in this case), you end up with weird color bleed issues. Setting ``blend_premul_alpha`` fixes that.

Now the planet should look like it is reflecting light on the ocean but not the land. If you haven't done
so already, add an :ref:`OmniLight <class_OmniLight>` to the scene so you can move it around and see the
effect of the reflections on the ocean.

.. image:: img/planet_ocean_reflect.png

And there you have it. A procedural planet generated using a :ref:`Viewport <class_Viewport>`.


===================================================
/. ./tutorials/shaders/custom_postprocessing.rst
===================================================

.. _doc_custom_postprocessing:

Custom post-processing
======================

Introduction
------------

Godot provides many post-processing effects out of the box, including Bloom, DOF, and SSAO. Sometimes you
want to write your own custom effect. Here's how you can do so.

Post-processing effects are shaders applied to a frame after Godot rendered it. You first want to render
your scene into a :ref:`Viewport <class_Viewport>`, then render the ``Viewport``
inside a :ref:`ViewportTexture <class_ViewportTexture>` and show it on the screen.

The easiest way to implement a custom post-processing shader is to use Godot's built-in ability to read from
the screen texture. If you're not familiar with this, you should read the :ref:`Screen Reading Shaders
Tutorial <doc_screen-reading_shaders>` first.

.. note::

    As of the time of writing, Godot does not support rendering to multiple buffers at the same time. Your
    post-processing shader will not have access to normals or other render passes. You only have
    access to the rendered frame.

Single pass post-processing
---------------------------

You will need a ``Viewport`` to render your scene to, and a scene to render your
``Viewport`` on the screen. You can use a :ref:`ViewportContainer
<class_ViewportContainer>` to display your ``Viewport`` on the entire screen or inside
another :ref:`Control <class_Control>` node.

.. note::

    Rendering using a ``Viewport`` gives you control over
    how the scene render, including the framerate, and you can use the
    ``ViewportContainer`` to render 3D objects in a 2D scene.

For this demo, we will use a :ref:`Node2D <class_Node2D>` with a ``ViewportContainer`` and finally a
``Viewport``. Your **Scene** tab should look like this:

.. image:: img/post_hierarchy1.png

Inside the ``Viewport``, you can have whatever you want. This will contain
your main scene. For this tutorial, we will use a field of random boxes:

.. image:: img/post_boxes.png

Add a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the ``ViewportContainer``, and assign a new
shader resource to it. You can access your rendered ``Viewport`` with the built-in ``TEXTURE`` uniform.

.. note::

    You can choose not to use a ``ViewportContainer``, but if you do so, you will
    need to create your own uniform in the shader and pass the ``Viewport`` texture in
    manually, like so:

    .. code-block:: glsl

      // Inside the Shader.
      uniform sampler2D ViewportTexture;

    And you can pass the texture into the shader from GDScript like so:

    ::

      # In GDScript.
      func _ready():
        $Sprite.material.set_shader_param("ViewportTexture", $Viewport.get_texture())

Copy the following code to your shader. The above code is a single pass edge detection filter, a
`Sobel filter <https://en.wikipedia.org/wiki/Sobel_operator>`_.

.. code-block:: glsl

  shader_type canvas_item;

  void fragment() {
      vec3 col = -8.0 * texture(TEXTURE, UV).xyz;
      col += texture(TEXTURE, UV + vec2(0.0, SCREEN_PIXEL_SIZE.y)).xyz;
      col += texture(TEXTURE, UV + vec2(0.0, -SCREEN_PIXEL_SIZE.y)).xyz;
      col += texture(TEXTURE, UV + vec2(SCREEN_PIXEL_SIZE.x, 0.0)).xyz;
      col += texture(TEXTURE, UV + vec2(-SCREEN_PIXEL_SIZE.x, 0.0)).xyz;
      col += texture(TEXTURE, UV + SCREEN_PIXEL_SIZE.xy).xyz;
      col += texture(TEXTURE, UV - SCREEN_PIXEL_SIZE.xy).xyz;
      col += texture(TEXTURE, UV + vec2(-SCREEN_PIXEL_SIZE.x, SCREEN_PIXEL_SIZE.y)).xyz;
      col += texture(TEXTURE, UV + vec2(SCREEN_PIXEL_SIZE.x, -SCREEN_PIXEL_SIZE.y)).xyz;
      COLOR.xyz = col;
  }

.. note::

    The Sobel filter reads pixels in a 9x9 grid around the current pixel and adds them together, using weight.
    What makes it interesting is that it assigns weights to each pixel; +1 for each of the eight around the
    center and -8 for the center pixel. The choice of weights is called a "kernel". You can use different
    kernels to create edge detection filters, outlines, and all sorts of effects.

    .. image:: img/post_outline.png

Multi-pass post-processing
--------------------------

Some post-processing effects like blur are resource intensive. If you break them down in multiple passes
however, you can make them run a lot faster. In a multipass material, each pass takes the result from the
previous pass as an input and processes it.

To make a multi-pass post-processing shader, you stack ``Viewport`` nodes. In the example above, you
rendered the content of one ``Viewport`` object into the root ``Viewport``, through a ``ViewportContainer``
node. You can do the same thing for a multi-pass shader by rendering the content of one ``Viewport`` into
another and then rendering the last ``Viewport`` into the root ``Viewport``.

Your scene hierarchy will look something like this:

.. image:: img/post_hierarchy2.png

Godot will render the bottom ``Viewport`` node first. So if the order of the passes matters for your
shaders, make sure that you assign the shader you want to apply first to the lowest ``ViewportContainer`` in
the tree.

.. note::

    You can also render your Viewports separately without nesting them like this. You just
    need to use two Viewports and to render them one after the other.

Apart from the node structure, the steps are the same as with the single-pass post-processing shader.

As an example, you could write a full screen Gaussian blur effect by attaching the following pieces of code
to each of the :ref:`ViewportContainers <class_ViewportContainer>`. The order in which you apply the shaders
does not matter:

.. code-block:: glsl

  shader_type canvas_item;

  // Blurs the screen in the X-direction.
  void fragment() {
      vec3 col = texture(TEXTURE, UV).xyz * 0.16;
      col += texture(TEXTURE, UV + vec2(SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.15;
      col += texture(TEXTURE, UV + vec2(-SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.15;
      col += texture(TEXTURE, UV + vec2(2.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.12;
      col += texture(TEXTURE, UV + vec2(2.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.12;
      col += texture(TEXTURE, UV + vec2(3.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.09;
      col += texture(TEXTURE, UV + vec2(3.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.09;
      col += texture(TEXTURE, UV + vec2(4.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.05;
      col += texture(TEXTURE, UV + vec2(4.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.05;
      COLOR.xyz = col;
  }

.. code-block:: glsl

  shader_type canvas_item;

  // Blurs the screen in the Y-direction.
  void fragment() {
      vec3 col = texture(TEXTURE, UV).xyz * 0.16;
      col += texture(TEXTURE, UV + vec2(0.0, SCREEN_PIXEL_SIZE.y)).xyz * 0.15;
      col += texture(TEXTURE, UV + vec2(0.0, -SCREEN_PIXEL_SIZE.y)).xyz * 0.15;
      col += texture(TEXTURE, UV + vec2(0.0, 2.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.12;
      col += texture(TEXTURE, UV + vec2(0.0, 2.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.12;
      col += texture(TEXTURE, UV + vec2(0.0, 3.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.09;
      col += texture(TEXTURE, UV + vec2(0.0, 3.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.09;
      col += texture(TEXTURE, UV + vec2(0.0, 4.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.05;
      col += texture(TEXTURE, UV + vec2(0.0, 4.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.05;
      COLOR.xyz = col;
  }

Using the above code, you should end up with a full screen blur effect like below.

.. image:: img/post_blur.png

For more information on how ``Viewport`` nodes work, see the :ref:`Viewports Tutorial <doc_viewports>`.


===================================================
/. ./tutorials/shaders/making_trees.rst
===================================================

.. _doc_making_trees:

Making trees
============

This is a short tutorial on how to make trees and other types of vegetation from scratch.

The aim is to not focus on the modelling techniques (there are plenty of tutorials about that), but how to make them look good in Godot.

.. image:: img/tree_sway.gif

Start with a tree
-----------------

I took this tree from SketchFab:

.. image:: img/tree_base.png

https://sketchfab.com/models/ea5e6ed7f9d6445ba69589d503e8cebf

and opened it in Blender.

Paint with vertex colors
------------------------

The first thing you may want to do is to use the vertex colors to paint how much the tree will sway when there is wind. Just use the vertex color painting tool of your favorite 3D modelling program and paint something like this:

.. image:: img/tree_vertex_paint.png

This is a bit exaggerated, but the idea is that color indicates how much sway affects every part of the tree. This scale here represents it better:

.. image:: img/tree_gradient.png

Write a custom shader for the leaves
------------------------------------

This is a simple example of a shader for leaves:

.. code-block:: glsl

    shader_type spatial;
    render_mode depth_draw_alpha_prepass, cull_disabled, world_vertex_coords;

This is a spatial shader. There is no front/back culling (so leaves can be seen from both sides), and alpha prepass is used, so there are less depth artifacts that result from using transparency (and leaves cast shadow). Finally, for the sway effect, world coordinates are recommended, so the tree can be duplicated, moved, etc. and it will still work together with other trees.

.. code-block:: glsl

    uniform sampler2D texture_albedo : hint_albedo;
    uniform vec4 transmission : hint_color;

Here, the texture is read, as well as a transmission color, which is used to add some back-lighting to the leaves, simulating subsurface scattering.


.. code-block:: glsl

    uniform float sway_speed = 1.0;
    uniform float sway_strength = 0.05;
    uniform float sway_phase_len = 8.0;

    void vertex() {
        float strength = COLOR.r * sway_strength;
        VERTEX.x += sin(VERTEX.x * sway_phase_len * 1.123 + TIME * sway_speed) * strength;
        VERTEX.y += sin(VERTEX.y * sway_phase_len + TIME * sway_speed * 1.12412) * strength;
        VERTEX.z += sin(VERTEX.z * sway_phase_len * 0.9123 + TIME * sway_speed * 1.3123) * strength;
    }

This is the code to create the sway of the leaves. It's basic (just uses a sinewave multiplying by the time and axis position, but works well). Notice that the strength is multiplied by the color. Every axis uses a different small near 1.0 multiplication factor so axes don't appear in sync.


Finally, all that's left is the fragment shader:

.. code-block:: glsl

    void fragment() {
        vec4 albedo_tex = texture(texture_albedo, UV);
        ALBEDO = albedo_tex.rgb;
        ALPHA = albedo_tex.a;
        METALLIC = 0.0;
        ROUGHNESS = 1.0;
        TRANSMISSION = transmission.rgb;
    }

And this is pretty much it.

The trunk shader is similar, except it does not write to the alpha channel (thus no alpha prepass is needed) and does not require transmission to work. Both shaders can be improved by adding normal mapping, AO and other maps.

Improving the shader
--------------------

There are many more resources on how to do this that you can read. Now that you know the basics, a recommended read is the chapter from GPU Gems3 about how Crysis does this
(focus mostly on the sway code, as many other techniques shown there are obsolete):

https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch16.html


===================================================
/. ./tutorials/ui/index.rst
===================================================

User Interface (UI)
===================

.. toctree::
   :maxdepth: 1
   :name: toc-gui-basics

   size_and_anchors
   gui_containers
   custom_gui_controls
   gui_navigation
   control_node_gallery

GUI skinning and themes
-----------------------

Godot features an in-depth skinning/theming system for control nodes. The pages in this section
explain the benefits of that system and how to set it up in your projects.

.. toctree::
   :maxdepth: 1
   :name: toc-gui-skinning

   gui_skinning
   gui_using_theme_editor
   gui_theme_type_variations

Control node tutorials
----------------------

The following articles cover specific details of using particular control nodes.

.. toctree::
   :maxdepth: 1
   :name: toc-control-nodes-tutorials

   bbcode_in_richtextlabel


===================================================
/. ./tutorials/ui/size_and_anchors.rst
===================================================

.. _doc_size_and_anchors:

Size and anchors
================

If a game was always going to be run on the same device and at the same
resolution, positioning controls would be a simple matter of setting the
position and size of each one of them. Unfortunately, that is rarely the
case.

Only TVs nowadays have a standard resolution and aspect ratio.
Everything else, from computer monitors to tablets, portable consoles
and mobile phones have different resolutions and aspect ratios.

There are several ways to handle this, but for now, let's just imagine
that the screen resolution has changed and the controls need to be
re-positioned. Some will need to follow the bottom of the screen, others
the top of the screen, or maybe the right or left margins.

.. image:: img/anchors.png

This is done by editing the *margin* properties of controls. Each
control has four margins: left, right, bottom and top. By default, all of
them represent a distance in pixels relative to the top-left corner of
the parent control or (in case there is no parent control) the viewport.

.. image:: img/margin.png

When horizontal (left, right) and/or vertical (top, bottom) anchors are
changed to 1, the margin values become relative to the bottom-right
corner of the parent control or viewport.

.. image:: img/marginend.png

Here, the control is set to expand its bottom-right corner with that of
the parent, so when re-sizing the parent, the control will always cover
it, leaving a 20 pixel margin:

.. image:: img/marginaround.png

Centering a control
-------------------

To center a control in its parent, set its anchors to 0.5 and each margin
to half of its relevant dimension. For example, the code below shows how
a TextureRect can be centered in its parent:

::

    var rect = TextureRect.new()
    rect.texture = load("res://icon.png")
    rect.anchor_left = 0.5
    rect.anchor_right = 0.5
    rect.anchor_top = 0.5
    rect.anchor_bottom = 0.5
    var texture_size = rect.texture.get_size()
    rect.margin_left = -texture_size.x / 2
    rect.margin_right = -texture_size.x / 2
    rect.margin_top = -texture_size.y / 2
    rect.margin_bottom = -texture_size.y / 2
    add_child(rect)

Setting each anchor to 0.5 moves the reference point for the margins to
the center of its parent. From there, we set negative margins so that
the control gets its natural size.

Layout Presets
--------------

Instead of manually adjusting the margin and anchor values, you can use the
toolbar's Layout menu, above the viewport. Besides centering, it gives you many
options to align and resize control nodes.

.. image:: img/layout_dropdown_menu.png


===================================================
/. ./tutorials/ui/gui_containers.rst
===================================================

.. _doc_gui_containers:

Using Containers
================

:ref:`Anchors <doc_size_and_anchors>` are an efficient way to handle
different aspect ratios for basic multiple resolution handling in GUIs,

For more complex user interfaces, they can become difficult to use.

This is often the case of games, such as RPGs, online chats, tycoons or simulations. Another
common case where more advanced layout features may be required is in-game tools (or simply just tools).

All these situations require a more capable OS-like user interface, with advanced layout and formatting.
For that, :ref:`Containers <class_container>` are more useful.

Container layout
----------------

Containers provide a huge amount of layout power (as an example, the Godot editor user interface is entirely done using them):

   .. image:: img/godot_containers.png

When a :ref:`Container <class_Container>`-derived node is used, all children :ref:`Control <class_Control>` nodes give up their
own positioning ability. This means the *Container* will control their positioning and any attempt to manually alter these
nodes will be either ignored or invalidated the next time their parent is resized.

Likewise, when a *Container* derived node is resized, all its children will be re-positioned according to it,
with a behavior based on the type of container used:

   .. image:: img/container_example.gif

Example of *HBoxContainer* resizing children buttons.

The real strength of containers is that they can be nested (as nodes), allowing the creation of very complex layouts that resize effortlessly.

Size flags
----------

When adding a node to a container, the way the container treats each child depends mainly on their *size flags*. These flags
can be found by inspecting any control that is a child of a *Container*.

   .. image:: img/container_size_flags.png

Size flags are independent for vertical and horizontal sizing and not all containers make use of them (but most do):

* **Fill**: Ensures the control *fills* the designated area within the container. No matter if
  a control *expands* or not (see below), it will only *fill* the designated area when this is toggled on (it is by default).
* **Expand**: Attempts to use as much space as possible in the parent container (in each axis).
  Controls that don't expand will be pushed away by those that do. Between expanding controls, the
  amount of space they take from each other is determined by the *Ratio* (see below).
* **Shrink Center** When expanding (and if not filling), try to remain at the center of the expanded
  area (by default it remains at the left or top).
* **Ratio** Simple ratio of how much expanded controls take up the available space in relation to each
  other. A control with "2", will take up twice as much available space as one with "1".

Experimenting with these flags and different containers is recommended to get a better grasp on how they work.

Container types
---------------

Godot provides several container types out of the box as they serve different purposes:

Box Containers
^^^^^^^^^^^^^^

Arranges child controls vertically or horizontally (via :ref:`HBoxContainer <class_HBoxContainer>` and
:ref:`VBoxContainer <class_VBoxContainer>`). In the opposite of the designated direction
(as in, vertical for an horizontal container), it just expands the children.

   .. image:: img/containers_box.png

These containers make use of the *Ratio* property for children with the *Expand* flag set.

Grid Container
^^^^^^^^^^^^^^

Arranges child controls in a grid layout (via :ref:`GridContainer <class_GridContainer>`, amount
of columns must be specified). Uses both the vertical and horizontal expand flags.

   .. image:: img/containers_grid.png

Margin Container
^^^^^^^^^^^^^^^^

Child controls are expanded towards the bounds of this control (via
:ref:`MarginContainer <class_MarginContainer>`). Padding will be added on the margins
depending on the theme configuration.

   .. image:: img/containers_margin.png

Again, keep in mind that the margins are a *Theme* value, so they need to be edited from the
constants overrides section of each control:

   .. image:: img/containers_margin_constants.png

Tab Container
^^^^^^^^^^^^^

Allows you to place several child controls stacked on top of each other (via
:ref:`TabContainer <class_TabContainer>`), with only the *current* one visible.

   .. image:: img/containers_tab.png

Changing the *current* one is done via tabs located at the top of the container, via clicking:

   .. image:: img/containers_tab_click.gif

The titles are generated from the node names by default (although they can be overridden via *TabContainer* API).

Settings such as tab placement and *StyleBox* can be modified in the *TabContainer* theme overrides.

Split Container
^^^^^^^^^^^^^^^

Accepts only one or two children controls, then places them side to side with a divisor
(via :ref:`HSplitContainer <class_HSplitContainer>` and :ref:`VSplitContainer <class_VSplitContainer>`).
Respects both horizontal and vertical flags, as well as *Ratio*.

   .. image:: img/containers_split.png

The divisor can be dragged around to change the size relation between both children:

   .. image:: img/containers_split_drag.gif


PanelContainer
^^^^^^^^^^^^^^

Simple container that draws a *StyleBox*, then expands children to cover its whole area
(via :ref:`PanelContainer <class_PanelContainer>`, respecting the *StyleBox* margins).
It respects both the horizontal and vertical size flags.

   .. image:: img/containers_panel.png

This container is useful as top-level, or just to add custom backgrounds to sections of a layout.

ScrollContainer
^^^^^^^^^^^^^^^

Accepts a single child node. If this node is bigger than the container, scrollbars will be added
to allow panning the node around (via :ref:`ScrollContainer <class_ScrollContainer>`). Both
vertical and horizontal size flags are respected, and the behavior can be turned on or off
per axis in the properties.

   .. image:: img/containers_scroll.png

Mouse wheel and touch drag (when touch is available) are also valid ways to pan the child control around.

   .. image:: img/containers_center_pan.gif

As in the example above, one of the most common ways to use this container is together with a *VBoxContainer* as child.


ViewportContainer
^^^^^^^^^^^^^^^^^

This is a special control that will only accept a single *Viewport* node as child, and it will display
it as if it was an image (via :ref:`ViewportContainer <class_ViewportContainer>`).

Creating custom Containers
--------------------------

It is possible to easily create a custom container using script. Here is an example of a simple container that fits children
to its rect size:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Container

    func _notification(what):
        if what == NOTIFICATION_SORT_CHILDREN:
            # Must re-sort the children
            for c in get_children():
                # Fit to own size
                fit_child_in_rect( c, Rect2( Vector2(), rect_size ) )

    func set_some_setting():
        # Some setting changed, ask for children re-sort
        queue_sort()


===================================================
/. ./tutorials/ui/custom_gui_controls.rst
===================================================

.. _doc_custom_gui_controls:

Custom GUI controls
===================

So many controls...
-------------------

Yet there are never enough. Creating your own custom controls that act
just the way you want them to is an obsession of almost every GUI
programmer. Godot provides plenty of them, but they may not work exactly
the way you want. Before contacting the developers with a pull-request
to support diagonal scrollbars, at least it will be good to know how to
create these controls easily from script.

Drawing
-------

For drawing, it is recommended to check the :ref:`doc_custom_drawing_in_2d` tutorial.
The same applies. Some functions are worth mentioning due to their
usefulness when drawing, so they will be detailed next:

Checking control size
~~~~~~~~~~~~~~~~~~~~~

Unlike 2D nodes, "size" is important with controls, as it helps to
organize them in proper layouts. For this, the
:ref:`Control.rect_size <class_Control_property_rect_size>`
property is provided. Checking it during ``_draw()`` is vital to ensure
everything is kept in-bounds.

Checking focus
~~~~~~~~~~~~~~

Some controls (such as buttons or text editors) might provide input
focus for keyboard or joypad input. Examples of this are entering text
or pressing a button. This is controlled with the
:ref:`Control.focus_mode <class_Control_property_focus_mode>`
property. When drawing, and if the control supports input focus, it is
always desired to show some sort of indicator (highlight, box, etc.) to
indicate that this is the currently focused control. To check for this
status, the :ref:`Control.has_focus() <class_Control_method_has_focus>` method
exists. Example

.. tabs::
 .. code-tab:: gdscript GDScript

    func _draw():
        if has_focus():
             draw_selected()
        else:
             draw_normal()

 .. code-tab:: csharp

    public override void _Draw()
    {
        if (HasFocus())
        {
            DrawSelected()
        }
        else
        {
            DrawNormal();
        }
    }

Sizing
------

As mentioned before, size is important to controls. This allows
them to lay out properly, when set into grids, containers, or anchored.
Controls, most of the time, provide a *minimum size* to help properly
lay them out. For example, if controls are placed vertically on top of
each other using a :ref:`VBoxContainer <class_VBoxContainer>`,
the minimum size will make sure your custom control is not squished by
the other controls in the container.

To provide this callback, just override
:ref:`Control.get_minimum_size() <class_Control_method_get_minimum_size>`,
for example:

.. tabs::
 .. code-tab:: gdscript GDScript

    func get_minimum_size():
        return Vector2(30, 30)

 .. code-tab:: csharp

    public override Vector2 _GetMinimumSize()
    {
        return new Vector2(20, 20);
    }

Alternatively, set it using a function:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        set_custom_minimum_size(Vector2(30, 30))

 .. code-tab:: csharp

    public override void _Ready()
    {
        SetCustomMinimumSize(new Vector2(20, 20));
    }

Input
-----

Controls provide a few helpers to make managing input events much easier
than regular nodes.

Input events
~~~~~~~~~~~~

There are a few tutorials about input before this one, but it's worth
mentioning that controls have a special input method that only works
when:

-  The mouse pointer is over the control.
-  The button was pressed over this control (control always
   captures input until button is released)
-  Control provides keyboard/joypad focus via
   :ref:`Control.focus_mode <class_Control_property_focus_mode>`.

This function is
:ref:`Control._gui_input() <class_Control_method__gui_input>`.
Simply override it in your control. No processing needs to be set.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Control

    func _gui_input(event):
       if event is InputEventMouseButton and event.button_index == BUTTON_LEFT and event.pressed:
           print("Left mouse button was pressed!")

 .. code-tab:: csharp

    public override void _GuiInput(InputEvent @event)
    {
        if (@event is InputEventMouseButton mbe && mbe.ButtonIndex == (int)ButtonList.Left && mbe.Pressed)
        {
            GD.Print("Left mouse button was pressed!");
        }
    }

For more information about events themselves, check the :ref:`doc_inputevent`
tutorial.

Notifications
~~~~~~~~~~~~~

Controls also have many useful notifications for which no dedicated callback
exists, but which can be checked with the _notification callback:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _notification(what):
        match what:
            NOTIFICATION_MOUSE_ENTER:
                pass # Mouse entered the area of this control.
            NOTIFICATION_MOUSE_EXIT:
                pass # Mouse exited the area of this control.
            NOTIFICATION_FOCUS_ENTER:
                pass # Control gained focus.
            NOTIFICATION_FOCUS_EXIT:
                pass # Control lost focus.
            NOTIFICATION_THEME_CHANGED:
                pass # Theme used to draw the control changed;
                # update and redraw is recommended if using a theme.
            NOTIFICATION_VISIBILITY_CHANGED:
                pass # Control became visible/invisible;
                # check new status with is_visible().
            NOTIFICATION_RESIZED:
                pass # Control changed size; check new size
                # with get_size().
            NOTIFICATION_MODAL_CLOSE:
                pass # For modal pop-ups, notification
                # that the pop-up was closed.

 .. code-tab:: csharp

    public override void _Notification(int what)
    {
        switch (what)
        {
            case NotificationMouseEnter:
                // Mouse entered the area of this control.
                break;

            case NotificationMouseExit:
                // Mouse exited the area of this control.
                break;

            case NotificationFocusEnter:
                // Control gained focus.
                break;

            case NotificationFocusExit:
                // Control lost focus.
                break;

            case NotificationThemeChanged:
                // Theme used to draw the control changed;
                // update and redraw is recommended if using a theme.
                break;

            case NotificationVisibilityChanged:
                // Control became visible/invisible;
                // check new status with is_visible().
                break;

            case NotificationResized:
                // Control changed size; check new size with get_size().
                break;

            case NotificationModalClose:
                // For modal pop-ups, notification that the pop-up was closed.
                break;
        }
    }


===================================================
/. ./tutorials/ui/gui_navigation.rst
===================================================

.. _doc_gui_navigation:

Keyboard/Controller Navigation and Focus
========================================

It is a common requirement for a user interface to have full keyboard
and controller support for navigation and interaction. There are two main
reasons why this is beneficial for projects: improved accessibility (not everyone
can use mouse or touch controls for interactions), and getting your project
ready for :ref:`consoles <doc_consoles>` (or just for people who prefer
to game with a controller on PC).

Navigating between UI elements with keyboard or controller is done by
changing which node is actively selected. This is also called changing UI focus.
Every :ref:`Control <class_Control>` node in Godot is capable of having focus.
By default, some control nodes have the ability to automatically grab focus
reacting to built-in UI actions such as ``ui_up``, ``ui_down``, ``ui_focus_next``, etc.
These actions can be seen in the project settings in the input map and can be modified.

.. warning::

    Because these actions are used for focus they should not be used for any
    gameplay code.

Node settings
-------------

In addition to the built-in logic, you can define what is known as focus neighbors
for each individual control node. This allows to finely tune the path the UI focus
takes across the user interface of your project. The settings for individual
nodes can be found in the Inspector dock, under the "Focus" category of the
"Control" section.

.. image:: img/focus_settings.png

Neighbor options are used to define nodes for 4-directional navigation, such
as using arrow keys or a D-pad on a controller. For example, the bottom neighbor
will be used when navigating down with the down arrow or by pushing down on
the D-pad. The "Next" and "Previous" options are used with the focus shift button,
such as :kbd:`Tab` on desktop operating systems.

.. note::
    A node can lose focus if it becomes hidden.

The mode setting defines how a node can be focused. **All** means a node can
be focused by clicking on it with the mouse, or selecting it with a keyboard
or controller. **Click** means it can only be focused on by clicking on it.
Finally, **None** means it can't be focused at all. Different control nodes have
different default settings for this based on how they are typically used, for
example, :ref:`Label <class_Label>` nodes are set to "None" by default,
while :ref:`buttons <class_Button>` are set to "All".

Make sure to properly configure your scenes for focus and navigation. If a node has
no focus neighbor configured, the engine will try to guess the next control automatically.
This may result in unintended behavior, especially in a complex user interface that doesn't
have well-defined vertical or horizontal navigation flow.

Necessary code
--------------

For keyboard and controller navigation to work correctly, any node must be focused on
using code when the scene starts. Without doing this, pressing buttons or keys won't
do anything. Here is a basic example of setting initial focus with code:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        $StartButton.grab_focus()

 .. code-tab:: csharp

    public override void _Ready()
    {
        GetNode<Button>("StartButton").GrabFocus();
    }

Now when the scene starts the "Start Button" node will be focused, and the keyboard
or a controller can be used to navigate between it and other UI elements.


===================================================
/. ./tutorials/ui/control_node_gallery.rst
===================================================

Control node gallery
====================

Here is a list of common Control nodes with their name next to them:

.. image:: /img/control_gallery.png

The Control Gallery demo pictured above can be found
`on GitHub <https://github.com/godotengine/godot-demo-projects/tree/master/gui/control_gallery>`__.


===================================================
/. ./tutorials/ui/gui_skinning.rst
===================================================

.. _doc_gui_skinning:

Introduction to GUI skinning
============================

It is essential for a game to provide clear, informative, and yet visually
pleasing user interface to its players. While :ref:`Control <class_Control>`
nodes come with a decently functional look out of the box, there is always
room for uniqueness and case-specific tuning. For this purpose Godot engine
includes a system for GUI skinning (or theming), which allows you to customize
the look of every control in your user interface, including your custom controls.

Here is an example of this system in action — a game with the GUI that is
radically different from the default UI theme of the engine:

.. figure:: img/tank-kings-by-winterpixel-games.png
   :align: center

   A "Gear Up!" screen in Tank Kings, courtesy of Winterpixel Games

Beyond achieving a unique look for your game, this system also enables developers
to provide customization options to the end users, including accessibility settings.
UI themes are applied in a cascading manner (i.e. they propagate from parent
controls to their children), which means that font settings or adjustments for
colorblind users can be applied in a single place and affect the entire UI tree.
Of course this system can also be used for gameplay purposes: your hero-based game
can change its style for the selected player character, or you can give different
flavors to the sides in your team-based project.

Basics of themes
----------------

The skinning system is driven by the :ref:`Theme <class_Theme>` resource. Every
Godot project has an inherent default theme that contains the settings used by
the built-in control nodes. This is what gives the controls their distinct look
out of the box. A theme only describes the configuration, however, and it is still
the job of each individual control to use that configuration in the way it requires
to display itself. This is important to remember when implementing
:ref:`your own custom controls <doc_custom_gui_controls>`.

.. note::
   Even the Godot editor itself relies on the default theme. But it doesn't look the
   same as a Godot project, because it applies its own heavily customized theme on top
   of the default one. In principle, this works exactly like it would in your game
   as explained :ref:`below <doc_gui_theme_in_project>`.

Theme items
~~~~~~~~~~~

The configuration that is stored in a theme consists of theme items. Each item has
a unique name and must be one of the following data types:

-  **Color**

   A :ref:`color <class_Color>` value, which is often used for fonts
   and backgrounds. Colors can also be used for modulation of controls
   and icons.

-  **Constant**

   An integer value, which can be used either for numeric properties of
   controls (such as the item separation in a :ref:`BoxContainer <class_BoxContainer>`),
   or for boolean flags (such as the drawing of relationship lines in a :ref:`Tree <class_Tree>`).

-  **Font**

   A :ref:`font <class_Font>` resource, which is used by controls that
   display text. Fonts contain most text rendering settings, except for
   its size and color. On top of that, alignment and text direction are
   controlled by individual controls.

-  **Icon**

   A :ref:`texture <class_Texture>` resource, which is normally used
   to display an icon (on a :ref:`Button <class_Button>`, for example).

-  **StyleBox**

   A :ref:`StyleBox <class_StyleBox>` resource, a collection of configuration
   options which define the way a UI panel should be displayed. This is
   not limited to the :ref:`Panel <class_Panel>` control, as styleboxes
   are used by many controls for their backgrounds and overlays.

Theme types
~~~~~~~~~~~

To help with the organization of its items each theme is separated into types,
and each item must belong to a single type. In other words, each theme item
is defined by its name, its data type and its theme type. This combination
must be unique within the theme. For example, there cannot be two color items named
``font_color`` in a type called ``Label``, but there can be another ``font_color``
item in a type ``LineEdit``.

The default Godot theme comes with multiple theme types already defined,
one for every built-in control node that uses UI skinning. The example above
contains actual theme items present in the default theme. You can refer to the
**Theme Properties** section in the class reference for each control to see
which items are available to it and its child classes.

.. note::
   Child classes can use theme items defined for their parent class (``Button``
   and its derivatives being a good example of that). In fact, every control can
   use every theme item of any theme type, if it needs to (but for the clarity and
   predictability we try to avoid that in the engine).

   It is important to remember that for child classes that process is automated.
   Whenever a built-in control requests a theme item from the theme it can omit
   the theme type, and its class name will be used instead. On top of that,
   the class names of its parent classes will also be used in turn. This allows
   changes to the parent class, such as ``Button``, to affect all derived
   classes without the need to customize every one of them.

You can also define your own theme types, and additionally customize both built-in
controls and your own controls. Because built-in controls have no knowledge of
your custom theme types, you must utilize scripts to access those items. All control
nodes have several methods that allow to fetch theme items from the theme that
is applied to them. Those methods accept the theme type as one of the arguments.

.. tabs::
 .. code-tab:: gdscript

   var accent_color = get_color("accent_color", "MyType")
   label.add_color_override("font_color", accent_color)

 .. code-tab:: csharp

   Color accentColor = GetColor("accent_color", "MyType");
   label.AddColorOverride("font_color", accentColor);

To give more customization opportunities types can also be linked together as
type variations. This is another use-case for custom theme types. For example,
a theme can contain a type ``Header`` which can be marked as a variation of
the base ``Label`` type. An individual ``Label`` control can then be set to
use the ``Header`` variation for its type, and every time a theme item is
requested from a theme this variation will be used before any other type. This
allows to store various presets of theme items for the same class of the
control node in the single ``Theme`` resource.

.. warning::
   Only variations available from the default theme or defined in the custom
   project theme are shown in the Inspector dock as options. You can still
   input manually the name of a variation that is defined outside of those
   two places, but it is recommended to keep all variations to the project theme.

You can learn more about creating and using theme type variations in a
:ref:`dedicated article <doc_gui_theme_type_variations>`.

Customizing a control
---------------------

Each control node can be customized directly without the use of themes. This
is called local overrides. Every theme property from the control's class
reference can be overridden directly on the control itself, using either
the Inspector dock, or scripts. This allows to make granular changes to a
particular part of the UI, while not affecting anything else in the project,
including this control's children.

.. figure:: img/themecheck.png
   :align: center

Local overrides are less useful for the visual flair of your user interface,
especially if you aim for consistency. However, for layout nodes these are
essential. Nodes such as :ref:`BoxContainer <class_BoxContainer>` and
:ref:`GridContainer <class_GridContainer>` use theme constants for defining
separation between their children, and :ref:`MarginContainer <class_MarginContainer>`
stores its customizable margins in its theme items.

Whenever a control has a local theme item override, this is the value that
it uses. Values provided by the theme are ignored.

.. _doc_gui_theme_in_project:

Customizing a project
---------------------

Out of the box each project adopts the default project theme provided by Godot. The
default theme itself is constant and cannot be changed, but its items can be overridden
with a custom theme. Custom themes can be applied in two ways: as a project setting,
and as a node property throughout the tree of control nodes.

There are two project settings that can be adjusted to affect your entire project:
:ref:`gui/theme/custom<class_ProjectSettings_property_gui/theme/custom>` allows you to
set a custom project-wide theme, and :ref:`gui/theme/custom_font<class_ProjectSettings_property_gui/theme/custom_font>`
does the same to the default fallback font. When a theme item is requested by a control
node the custom project theme, if present, is checked first. Only if it doesn't have
the item the default theme is checked.

This allows you to configure the default look of every Godot control with a single
theme resource, but you can go more granular than that. Every control node also has
a :ref:`theme <class_Control_property_theme>` property, which allows you to set a
custom theme for the branch of nodes starting with that control. This means that the
control and all of its children, and their children in turn, would first check that
custom theme resource before falling back on the project and the default themes.

.. note::
   Instead of changing the project setting you can set the custom theme resource to the
   root-most control node of your entire UI branch to almost the same effect. While in the
   running project it will behave as expected, individual scenes will still display
   using the default theme when previewing or running them directly. To fix that you
   can set the same theme resource to the root control of each individual scene.

For example, you can have a certain style for buttons in your project theme, but want
a different look for buttons inside of a popup dialog. You can set a custom theme
resource to the root control of your popup and define a different style for buttons
within that resource. As long as the chain of control nodes between the root of
the popup and the buttons is uninterrupted, those buttons will use the styles defined
in the theme resource that is closest to them. All other controls will still be styled
using the project-wide theme and the default theme styles.

To sum it up, for an arbitrary control its theme item lookup would look something
like this:

#. Check for local overrides of the same data type and name.
#. Using control's class name and parent class names:

   a. Check every control starting from itself and see if it has a theme property set;
   b. If it does, check that theme for the matching item of the same name, data and theme type;
   c. If there is no custom theme or it doesn't have the item, move to the parent control;
   d. Repeat steps a-c. until the root of the tree is reached, or a non-control node is reached.

#. Using control's class name check the project-wide theme, if it's present.
#. Using control's class name check the default theme.

Even if the item doesn't exist in any theme, a corresponding default value for that
data type will be returned.

Beyond controls
---------------

Naturally, themes are an ideal type of resource for storing configuration for
something visual. While the support for theming is built into control nodes,
other nodes can use them as well, just like any other resource.

An example of using themes for something beyond controls can be a modulation
of sprites for the same units on different teams in a strategy game. A theme
resource can define a collection of colors, and sprites (with a help from scripts)
can use those colors to draw the texture. The main benefit being that you
could make different themes using the same theme items for red, blue, and
green teams, and swap them with a single resource change.


===================================================
/. ./tutorials/ui/gui_using_theme_editor.rst
===================================================

.. _doc_gui_using_theme_editor:

Using the theme editor
======================

This articles explains how to create and manage UI themes using the Godot
editor and its theme editor tool. We recommend getting familiar with the
basics behind GUI skinning/theming by reading :ref:`doc_gui_skinning` before starting.

The theme editor is a bottom panel tool that activates automatically, when
a :ref:`Theme <class_Theme>` resource is selected for editing. It contains
the necessary UI for adding, removing, and adjusting theme types and theme
items. It features a preview section for testing your changes live, as well
as a window dialog for doing bulk operations of the theme items.

Creating a theme
----------------

Like any other resources, themes can be created directly in the file system dock
by right-clicking and selecting **New Resource...**, then selecting **Theme**
and clicking **Create**. This is especially useful for creating project-wide
themes.

Themes also can be created from any control node. Select a control node in the scene
hierarchy, then in the inspector go to the ``theme`` property. From there you can
select **New Theme**.

.. figure:: img/new_theme.png
   :align: center

This will create an empty theme and open up the theme editor. Keep in mind that
resources created this way are bundled with the scene by default. Use the context
menu to save the new theme to a file instead.

While the theme editor provides the tools to manage theme types and items, themes also
include the default, fallback font that you can edit only using the Inspector dock.
Same applies to the contents of complex resource types, such as :ref:`StyleBoxes <class_StyleBox>`
and icons — they open for editing in the Inspector.

.. figure:: img/default_font.png
   :align: center

Theme editor overview
---------------------

.. figure:: img/theme_editor.png
   :align: center

The theme editor has two main parts. The main theme editor, located at the bottom of
the Godot editor, aims to provide users with tools to quickly create, edit, and delete
theme items and types. It gives visual tools for picking and changing controls, abstracting
the underlying theme concepts. The **Manage Theme Items** dialog, on the other hand,
tries to address the needs of those who want to change themes manually. It's also
useful for creating a new editor theme.

Theme previews
~~~~~~~~~~~~~~

The left-hand side of the main editor has a set of preview tabs. The **Default Preview**
tab is visible out of the box and contains most of the frequently used controls in various
states. Previews are interactive, so intermediate states (e.g. hover) can be previewed as well.

.. figure:: img/default_preview.png
   :align: center

Additional tabs can be created from arbitrary scenes in your project. The scene
must have a control node as its root to function as a preview. To add a new tab
click the **Add Preview** button and select the saved scene from your file system.

.. figure:: img/scene_preview.png
   :align: center

If you make changes to the scene, they will not be reflected in the preview
automatically. To update the preview click the reload button on the toolbar.

Previews can also be used to quickly select the theme type to edit. Select the
picker tool from the toolbar and hover over the preview area to highlight control
nodes. Highlighted control nodes display their class name. Clicking on the highlighted
control opens it for editing on the right-hand side.

.. figure:: img/theme_preview_picker.png
   :align: center

Theme types and items
~~~~~~~~~~~~~~~~~~~~~

The right-hand side of the theme editor provides a list of theme types available
in the edited theme resource, and the contents of the selected type. The list of
type's items is divided into several tabs, corresponding to each data type available
in the theme (colors, constants, styles, etc.). If the **Show Default** option is
enabled, then for each built-in type its default theme values are displayed, greyed
out. If the option is disabled, only the items available in the edited theme itself
are displayed.

.. figure:: img/theme_type_editor.png
   :align: center

Individual items from the default theme can be added to the current theme by
clicking on the **Override** button next to the item. You can also override all
the default items of the selected theme type by clicking on the **Override All**
button. Overridden properties can then be removed with the **Remove Item** button.
Properties can also be renamed using the **Rename Item** button, and completely
custom properties can be added to the list using the text field below it.

Overridden theme items can be edited directly in the right-hand panel, unless they
are resources. Resources have rudimentary controls available for them, but must be
edited in the Inspector dock instead.

.. figure:: img/theme_item_inspector.png
   :align: center

Styleboxes have an unique feature available, where you can pin an individual
stylebox from the list. Pinned stylebox acts like the leader of the pack, and
all styleboxes of the same type are updated alongside it when you change its
properties. This allows you to edit properties of several styleboxes at the
same time.

.. figure:: img/theme_pin_the_stylebox.png
   :align: center

While theme types can be picked from a preview, they can also be added manually.
Clicking the plus button next to the type list opens the **Add item Type** menu.
In that menu you can either select a type from the list, or you can enter an
arbitrary name to create a custom type. Text field also filters the list of control
nodes.

.. figure:: img/add_item_type.png
   :align: center

Manage and import items
-----------------------

Clicking the **Manage Items** button brings up the **Manage Theme Items** dialog. In
the **Edit Items** tab you can view and add theme types, as well as view and edit
the theme items of the selected type.

.. figure:: img/manage_items.png
   :align: center

You can create, rename and remove individual theme items here by clicking the
corresponding **Add X Item** and specifying their name. You can also mass delete
theme items either by their data type (using the brush icon in the list) or by
their quality. **Remove Class Items** will remove all built-in theme items you
have customized for a control node type. **Remove Custom Items** will remove all
the custom theme items for the selected type. Finally, **Remove All Items** will
remove everything from the type.

From the **Import Items** tab you can import theme items from other themes. You can
import items from the default Godot theme, the Godot editor theme, or another custom
theme. You can import individual or multiple items, and you can decide whether to
copy or omit their data as well. There are several way you can select and deselect the
items, including by hand, by hierarchy, by data type, and everything. Opting to
include the data will copy all theme items as they are to your theme. Omitting the data
will create the items of the corresponding data type and name, but will leave them empty,
creating a template of a theme in a way.

.. figure:: img/import_items.png
   :align: center


===================================================
/. ./tutorials/ui/gui_theme_type_variations.rst
===================================================

.. _doc_gui_theme_type_variations:

Theme type variations
=====================

When designing a user interface there may be times when a :ref:`Control <class_Control>` node
needs to have a different look than what is normally defined by a :ref:`Theme <class_Theme>`.
Every control node has theme property overrides, which allow you to redefine the styling for
each individual UI element.

.. figure:: img/themecheck.png
   :align: center

This approach quickly becomes hard to manage, if you need to share the same custom look
between several controls. Imagine that you use gray, blue, and red variants of :ref:`Button <class_Button>`
throughout your project. Setting it up every time you add a new button element to your interface
is a tedious task.

To help with the organization and to better utilize the :ref:`power of themes <doc_gui_skinning>`
you can use theme type variations. These work like normal theme types, but instead
of being self-sufficient and standalone they extend another, base type.

Following the previous example, your theme can have some styles, colors, and fonts
defined for the ``Button`` type, customizing the looks of every button element in your UI.
To then have a gray, red, or blue button you would create a new type, e.g. ``GrayButton``, and
mark it as a variation of the base ``Button`` type.

Type variations can replace some aspects of the base type, but keep others.
They can also define properties that the base style hasn't defined. For example,
your ``GrayButton`` can override the ``normal`` style from the base ``Button``
and add ``font_color`` that ``Button`` has never defined. The control will use
a combination of both types giving priority to the type variation.

.. note::
   The way controls resolve what theme items they use from each type and each
   theme is better described in the :ref:`Customizing a project <doc_gui_theme_in_project>`
   section of the "Introduction to GUI skinning" article.

Creating a type variation
-------------------------

To create a type variation open the theme editor, then click the plus icon
next to the **Type** dropdown on the right side of the editor. Type in what
you want to name your theme type variation in the text box, then click **Add Type**.

Below the **Type** dropdown are the property tabs. Switch to the tab with a wrench
and screwdriver icon.

.. figure:: img/base_type.png
   :align: center

Click on the plus icon next to the **Base Type** field. You can select the base type
there, which would typically be the name of a control node class (e.g., ``Button``, ``Label``, etc).
Type variations can also chain and extend other type variations. This works in the
same way control nodes inherit styling of their base class. For example, ``CheckButton``
inherits styles from ``Button`` because corresponding node types extend each other.

After you select the base type, you should now be able to see its properties on the other
tabs in the theme editor. You can edit them as usual.

Using a type variation
----------------------

Now that a type variation has been created you can apply it to your nodes.
In the inspector dock, under the **Theme** property of a control node,
you can find the **Theme Type Variation** property. It is empty by default,
which means that only the base type has an effect on this node.

You can either select a type variations from a dropdown list, or input its name
manually. Variations appear on the list only if the type variation belongs to
the project-wide theme, which you can configure in the project settings. For
any other case you have to input the name of the variation manually. Click on
the pencil icon to the right. Then type in the name of the type variation and click the
check mark icon or press enter. If a type variation with that name exists it
will now be used by the node.


===================================================
/. ./tutorials/ui/bbcode_in_richtextlabel.rst
===================================================

.. _doc_bbcode_in_richtextlabel:

BBCode in RichTextLabel
=======================

Introduction
------------

Label nodes are great for displaying basic text, but they have limits. If you want
to change the color of the text, or its alignment, that change affects all of the
text in the Label node. You can't have only one part of the text be one color, or
only one part of the text be centered. To get around this limitation you would use
a :ref:`class_RichTextLabel`.

:ref:`class_RichTextLabel` allows the display of complex text markup in a Control.
It has a built-in API for generating the markup, but can also parse a BBCode.

Note that the BBCode tags can also be used, to some extent, in the
:ref:`XML source of the class reference <doc_updating_the_class_reference>`.

Using BBCode
------------

For uniformly formatted text you can write in the "Text" property, but if you want
to use BBCode markup you should use the "Text" property in the "Bb Code" section
instead (``bbcode_text``). Writing to this property will trigger the parsing of your
markup to format the text as requested. Before this happens, you need to toggle the
"Enabled" checkbox in the "Bb Code" section (``bbcode_enabled``).

.. image:: img/bbcodeText.png

For example, ``BBCode [color=blue]blue[/color]`` would render the word "blue" with
a blue color.

.. image:: img/bbcodeDemo.png

You'll notice that after writing in the BBCode "Text" property the regular "Text"
property now has the text without the BBCode. While the text property will be updated
by the BBCode property, you can't edit the text property or you'll lose the BBCode
markup. All changes to the text must be done in the BBCode parameter.

.. note::

    For BBCode tags such as ``[b]`` (bold), ``[i]`` (italics) or ``[code]`` to
    work, you must set up custom fonts for the RichTextLabel node first.

    There are no BBCode tags to control vertical centering of text yet.

Reference
---------

+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| Command               | Tag                                                       | Description                                                              |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **bold**              | ``[b]{text}[/b]``                                         | Makes {text} bold.                                                       |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **italics**           | ``[i]{text}[/i]``                                         | Makes {text} italics.                                                    |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **underline**         | ``[u]{text}[/u]``                                         | Makes {text} underline.                                                  |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **strikethrough**     | ``[s]{text}[/s]``                                         | Makes {text} strikethrough.                                              |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **code**              | ``[code]{text}[/code]``                                   | Makes {text} use the code font (which is typically monospace).           |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **center**            | ``[center]{text}[/center]``                               | Makes {text} horizontally centered.                                      |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **right**             | ``[right]{text}[/right]``                                 | Makes {text} horizontally right-aligned.                                 |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **fill**              | ``[fill]{text}[/fill]``                                   | Makes {text} fill the RichTextLabel's width.                             |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **indent**            | ``[indent]{text}[/indent]``                               | Increase the indentation level of {text}.                                |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **url**               | ``[url]{url}[/url]``                                      | Show {url} as such, underline it and make it clickable.                  |
|                       |                                                           | **Must be handled with the "meta_clicked" signal to have an effect.**    |
|                       |                                                           | See :ref:`doc_bbcode_in_richtextlabel_handling_url_tag_clicks`.          |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **url (ref)**         | ``[url=<url>]{text}[/url]``                               | Makes {text} reference <url> (underlined and clickable).                 |
|                       |                                                           | **Must be handled with the "meta_clicked" signal to have an effect.**    |
|                       |                                                           | See :ref:`doc_bbcode_in_richtextlabel_handling_url_tag_clicks`.          |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **image**             | ``[img]{path}[/img]``                                     | Insert image at resource {path}.                                         |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **resized image**     | ``[img=<width>]{path}[/img]``                             | Insert image at resource {path} using <width> (keeps ratio).             |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **resized image**     | ``[img=<width>x<height>]{path}[/img]``                    | Insert image at resource {path} using <width>×<height>.                  |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **font**              | ``[font=<path>]{text}[/font]``                            | Use custom font at <path> for {text}.                                    |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **color**             | ``[color=<code/name>]{text}[/color]``                     | Change {text} color; use name or # format, such as ``#ff00ff``.          |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **table**             | ``[table=<number>]{cells}[/table]``                       | Creates a table with <number> of columns.                                |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+
| **cell**              | ``[cell]{text}[/cell]``                                   | Adds cells with the {text} to the table.                                 |
+-----------------------+-----------------------------------------------------------+--------------------------------------------------------------------------+

Built-in color names
~~~~~~~~~~~~~~~~~~~~

List of valid color names for the [color=<name>] tag:

-  aqua
-  black
-  blue
-  fuchsia
-  gray
-  green
-  lime
-  maroon
-  navy
-  purple
-  red
-  silver
-  teal
-  white
-  yellow

Hexadecimal color codes
~~~~~~~~~~~~~~~~~~~~~~~

For opaque RGB colors, any valid 6-digit hexadecimal code is supported, e.g. ``[color=#ffffff]white[/color]``.
Short RGB color codes such as ``#6f2`` (equivalent to ``#66ff22``) are also supported.

For transparent RGB colors, any 8-digit hexadecimal code can be used, e.g. ``[color=#88ffffff]translucent white[/color]``.
In this case, note that the alpha channel is the **first** component of the color code, not the last one.
Short RGBA color codes such as ``#86f2`` (equivalent to ``#8866ff22``) are also supported.

.. _doc_bbcode_in_richtextlabel_handling_url_tag_clicks:

Handling ``[url]`` tag clicks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, ``[url]`` tags do nothing when clicked. This is to allow flexible use
of ``[url]`` tags rather than limiting them to opening URLs in a web browser.

To handle clicked ``[url]`` tags, connect the RichTextLabel node's
:ref:`meta_clicked <class_RichTextLabel_signal_meta_clicked>` signal to a script function.

For example, the following method can be connected to ``meta_clicked`` to open
clicked URLs using the user's default web browser::

    # This assumes RichTextLabel's `meta_clicked` signal was connected to
    # the function below using the signal connection dialog.
    func _richtextlabel_on_meta_clicked(meta):
        # `meta` is not guaranteed to be a String, so convert it to a String
        # to avoid script errors at run-time.
        OS.shell_open(str(meta))

For more advanced use cases, it's also possible to store JSON in an ``[url]``
tag's option and parse it in the function that handles the ``meta_clicked`` signal.
For example: ``[url={"example": "value"}]JSON[/url]``

Image vertical offset
~~~~~~~~~~~~~~~~~~~~~

You use a custom font for your image in order to align it vertically.

1. Create a ``BitmapFont`` resource
2. Set this bitmap font with a positive value for the ``ascent`` property, that's your height offset
3. Set the BBCode tag this way: ``[font=<font-path>][img]{image-path}[/img][/font]``

Animation effects
-----------------

BBCode can also be used to create different text animation effects. Five customizable
effects are provided out of the box, and you can easily create your own.

Wave
~~~~

.. image:: img/wave.png

Wave makes the text go up and down. Its tag format is ``[wave amp=50 freq=2][/wave]``.
``amp`` controls how high and low the effect goes, and ``freq`` controls how fast the
text goes up and down.

Tornado
~~~~~~~

.. image:: img/tornado.png

Tornao makes the text move around in a circle. Its tag format is
``[tornado radius=5 freq=2][/tornado]``.
``radius`` is the radius of the circle that controls the offset, ``freq`` is how
fast the text moves in a circle.

Shake
~~~~~

.. image:: img/shake.png

Shake makes the text shake. Its tag format is ``[shake rate=5 level=10][/shake]``.
``rate`` controls how fast the text shakes, ``level`` controls how far the text is
offset from the origin.

Fade
~~~~

.. image:: img/fade.png

Fade creates a fade effect over the text that is not animated. Its tag format is
``[fade start=4 length=14][/fade]``.
``start`` controls the starting position of the falloff relative to where the fade
command is inserted, ``length`` controls over how many characters should the fade
out take place.

Rainbow
~~~~~~~

.. image:: img/rainbow.png

Rainbow gives the text a rainbow color that changes over time. Its tag format is
``[rainbow freq=0.2 sat=10 val=20][/rainbow]``.
``freq`` is the number of full rainbow cycles per second, ``sat`` is the saturation
of the rainbow, ``val`` is the value of the rainbow.

Custom BBCode tags and text effects
-----------------------------------

You can extend the :ref:`class_RichTextEffect` resource type to create your own custom
BBCode tags. You begin by extending the :ref:`class_RichTextEffect` resource type. Add
the ``tool`` prefix to your GDScript file if you wish to have these custom effects run
within the editor itself. The RichTextLabel does not need to have a script attached,
nor does it need to be running in ``tool`` mode. The new effect will be activable in
the Inspector through the **Custom Effects** property.

.. warning::

    If the custom effect is not registered within the RichTextLabel's
    **Custom Effects** property, no effect will be visible and the original
    tag will be left as-is.

There is only one function that you need to extend: ``_process_custom_fx(char_fx)``.
Optionally, you can also provide a custom BBCode identifier simply by adding a member
name ``bbcode``. The code will check the ``bbcode`` property automatically or will
use the name of the file to determine what the BBCode tag should be.

``_process_custom_fx``
~~~~~~~~~~~~~~~~~~~~~~

This is where the logic of each effect takes place and is called once per character
during the draw phase of text rendering. This passes in a :ref:`class_CharFXTransform`
object, which holds a few variables to control how the associated character is rendered:

- ``identity`` specifies which custom effect is being processed. You should use that for
  code flow control.
- ``relative_index`` tells you how far into a given custom effect block you are in as an
  index.
- ``absolute_index`` tells you how far into the entire text you are as an index.
- ``elapsed_time`` is the total amount of time the text effect has been running.
- ``visible`` will tell you whether the character is visible or not and will also allow you
  to hide a given portion of text.
- ``offset`` is an offset position relative to where the given character should render under
  normal circumstances.
- ``color`` is the color of a given character.
- Finally, ``env`` is a :ref:`class_Dictionary` of parameters assigned to a given custom
  effect. You can use :ref:`get() <class_Dictionary_method_get>` with an optional default value
  to retrieve each parameter, if specified by the user. For example ``[custom_fx spread=0.5
  color=#FFFF00]test[/custom_fx]`` would have a float ``spread`` and Color ``color``
  parameters in its ` `env`` Dictionary. See below for more usage examples.

The last thing to note about this function is that it is necessary to return a boolean
``true`` value to verify that the effect processed correctly. This way, if there's a problem
with rendering a given character, it will back out of rendering custom effects entirely until
the user fixes whatever error cropped up in their custom effect logic.

Here are some examples of custom effects:

Ghost
~~~~~

::

    tool
    extends RichTextEffect
    class_name RichTextGhost

    # Syntax: [ghost freq=5.0 span=10.0][/ghost]

    # Define the tag name.
    var bbcode = "ghost"

    func _process_custom_fx(char_fx):
        # Get parameters, or use the provided default value if missing.
        var speed = char_fx.env.get("freq", 5.0)
        var span = char_fx.env.get("span", 10.0)

        var alpha = sin(char_fx.elapsed_time * speed + (char_fx.absolute_index / span)) * 0.5 + 0.5
        char_fx.color.a = alpha
        return true

Pulse
~~~~~

::

    tool
    extends RichTextEffect
    class_name RichTextPulse

    # Syntax: [pulse color=#00FFAA height=0.0 freq=2.0][/pulse]

    # Define the tag name.
    var bbcode = "pulse"

    func _process_custom_fx(char_fx):
        # Get parameters, or use the provided default value if missing.
        var color = char_fx.env.get("color", char_fx.color)
        var height = char_fx.env.get("height", 0.0)
        var freq = char_fx.env.get("freq", 2.0)

        var sined_time = (sin(char_fx.elapsed_time * freq) + 1.0) / 2.0
        var y_off = sined_time * height
        color.a = 1.0
        char_fx.color = char_fx.color.linear_interpolate(color, sined_time)
        char_fx.offset = Vector2(0, -1) * y_off
        return true

Matrix
~~~~~~

::

    tool
    extends RichTextEffect
    class_name RichTextMatrix

    # Syntax: [matrix clean=2.0 dirty=1.0 span=50][/matrix]

    # Define the tag name.
    var bbcode = "matrix"

    func _process_custom_fx(char_fx):
        # Get parameters, or use the provided default value if missing.
        var clear_time = char_fx.env.get("clean", 2.0)
        var dirty_time = char_fx.env.get("dirty", 1.0)
        var text_span = char_fx.env.get("span", 50)

        var value = char_fx.character

        var matrix_time = fmod(char_fx.elapsed_time + (char_fx.absolute_index / float(text_span)), \
                               clear_time + dirty_time)

        matrix_time = 0.0 if matrix_time < clear_time else \
                      (matrix_time - clear_time) / dirty_time

        if value >= 65 && value < 126 && matrix_time > 0.0:
            value -= 65
            value = value + int(1 * matrix_time * (126 - 65))
            value %= (126 - 65)
            value += 65
        char_fx.character = value
        return true

This will add a few new BBCode commands, which can be used like so:

::

    [center][ghost]This is a custom [matrix]effect[/matrix][/ghost] made in
    [pulse freq=5.0 height=2.0][pulse color=#00FFAA freq=2.0]GDScript[/pulse][/pulse].[/center]


===================================================
/. ./tutorials/vr/index.rst
===================================================

XR (AR/VR)
==========

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-vr

   xr_primer
   openxr/index
   oculus_mobile/index
   openvr/index


===================================================
/. ./tutorials/vr/xr_primer.rst
===================================================

.. _doc_xr_primer:

AR/VR primer
============

This tutorial gives you a springboard into the world of AR and VR in the Godot game engine.

A new architecture was introduced in Godot 3 called the AR/VR Server. On top of this
architecture, specific implementations are available as interfaces, most of which are plugins
based on GDNative. This tutorial focuses purely on the core elements abstracted by the core
architecture. This architecture has enough features for you to create an entire VR experience
that can then be deployed for various interfaces. However, each platform often has some unique
features that are impossible to abstract. Such features will be documented on the relevant
interfaces and fall outside of the scope of this primer.

AR/VR server
------------

When Godot starts, each available interface will make itself known to the AR/VR server.
GDNative interfaces are setup as singletons; as long as they are added to the list of
GDNative singletons in your project, they will make themselves known to the server.

You can use the function :ref:`get_interfaces() <class_ARVRServer_method_get_interfaces>`
to return a list of available interfaces, but for this tutorial, we're going to use the
:ref:`native mobile VR interface <class_MobileVRInterface>` in our examples. This interface
is a straightforward implementation that uses the 3DOF sensors on your phone for orientation
and outputs a stereoscopic image to the screen. It is also available in the Godot core and
outputs to screen on desktop, which makes it ideal for prototyping or a tutorial such as
this one.

To enable an interface, you execute the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    var arvr_interface = ARVRServer.find_interface("Native mobile")
    if arvr_interface and arvr_interface.initialize():
        get_viewport().arvr = true

 .. code-tab:: csharp

    var arvrInterface = ARVRServer.FindInterface("Native mobile");
    if (arvrInterface != null && arvrInterface.Initialize())
    {
        GetViewport().Arvr = true;
    }

This code finds the interface we wish to use, initializes it and, if that is successful, binds
the main viewport to the interface. This last step gives some control over the viewport to the
interface, which automatically enables things like stereoscopic rendering on the viewport.

For our mobile VR interface, and any interface where the main input is directly displayed on
screen, the main viewport needs to be the viewport where :ref:`arvr<class_Viewport_property_arvr>`
is set to ``true``. But for interfaces that render on an externally attached device, you can use
a secondary viewport. In the latter case, a viewport that shows its output on screen will show an
undistorted version of the left eye, while showing the fully processed stereoscopic output on the
device.

Finally, you should only initialize an interface once; switching scenes and reinitializing interfaces
will just introduce a lot of overhead. If you want to turn the headset off temporarily, just disable
the viewport or set :ref:`arvr<class_Viewport_property_arvr>` to ``false`` on the viewport. In most
scenarios though, you wouldn't disable the headset once you're in VR, this can be disconcerting to
the gamer.

New AR/VR nodes
---------------

Three new node types have been added for supporting AR and VR in Godot and one additional
node type especially for AR. These are:

* :ref:`ARVROrigin <class_ARVROrigin>` - our origin point in the world
* :ref:`ARVRCamera <class_ARVRCamera>` - a special subclass of the camera, which is positionally tracked
* :ref:`ARVRController <class_ARVRController>` - a new spatial class, which tracks the location of a controller
* :ref:`ARVRAnchor <class_ARVRAnchor>` - an anchor point for an AR implementation mapping a real world location into your virtual world

The first two must exist in your scene for AR/VR to work and this tutorial focuses purely
on them.

:ref:`ARVROrigin <class_ARVROrigin>` is an important node, you must have one and only one
of these somewhere in your scene. This node maps the center of your real world tracking
space to a location in your virtual world. Everything else is positionally tracked in
relation to this point. Where this point lies exactly differs from one implementation to
another, but the best example to understand how this node works is to take a look at a room
scale location. While we have functions to adjust the point to center it on the player by
default, the origin point will be the center location of the room you are in. As you
physically walk around the room, the location of the HMD is tracked in relation to this
center position and the tracking is mirror in the virtual world.

To keep things simple, when you physically move around your room, the ARVR Origin point stays
where it is, the position of the camera and controllers will be adjusted according to your
movements. When you move through the virtual world, either through controller input or when
you implement a teleport system, it is the position of the origin point which you will
have to adjust.

:ref:`ARVRCamera <class_ARVRCamera>` is the second node that must always be a part of your
scene and it must always be a child node of your origin node. It is a subclass of Godot's
normal camera. However, its position is automatically updated each frame based on the physical
orientation and position of the HMD. Also due to the precision required for rendering to an
HMD or rendering an AR overlay over a real world camera, most of the standard camera properties
are ignored. The only properties of the camera that are used are the near and far plane
settings. The FOV, aspect ratio and projection mode are all ignored.

Note that, for our native mobile VR implementation, there is no positional tracking, only
the orientation of the phone and by extension, the HMD is tracked. This implementation
artificially places the camera at a height (Y) of 1.85.

Conclusion: your minimum setup in your scene to make AR or VR work should look like this:

.. image:: img/minimum_setup.png

And that's all you need to get started with the native mobile interface. Obviously, you need
to add something more into your scene, so there is something to see, but after that, you can
export the game to your phone of choice, pop it into a viewer and away you go.

Official plugins and resources
------------------------------

As mentioned earlier, Godot does not support the various VR and AR SDKs out of the box, you
need a plugin for the specific SDK you want to use. There are several official plugins available
in the `GodotVR Repository <https://github.com/GodotVR>`__.

* `Godot OpenXR <https://github.com/GodotVR/godot_openxr>`_: This is the **official XR plugin**
  starting with Godot **3.4**. It supports OpenXR, an open standard for designing and building
  cross-platform VR and AR software.
  Tested with SteamVR, Monada and Oculus OpenXR (desktop and mobile) runtimes.

    * See :ref:`doc_openxr_introduction`.

* `Godot Oculus Mobile <https://github.com/GodotVR/godot_oculus_mobile>`_ provides :ref:`support for
  the Meta Quest <doc_developing_for_oculus_quest>`.

    * **Note**: This plugin has been deprecated starting with Godot 3.4.
      We recommend migrating to the `Godot OpenXR <https://github.com/GodotVR/godot_openxr>`_ plugin instead.

* `Godot OpenVR <https://github.com/GodotVR/godot_openvr>`_ (not to be confused with OpenXR)
  supports the OpenVR SDK used by Steam.
* `Godot Oculus <https://github.com/GodotVR/godot_oculus>`__ supports the Oculus SDK
  (desktop headsets only).

    * **Note**: This plugin has been deprecated starting with Godot 3.4.
      We recommend migrating to the `Godot OpenXR <https://github.com/GodotVR/godot_openxr>`_ plugin instead.

* `Godot OpenHMD <https://github.com/GodotVR/godot_openhmd>`_ supports OpenHMD, an open source
  API and drivers for headsets.

These plugins can be downloaded from GitHub or the Godot Asset Library.

In addition to the plugins, there are several official demos.

* `Godot Oculus Demo <https://github.com/GodotVR/godot-oculus-demo>`__.
* `Godot OpenVR FPS <https://github.com/GodotVR/godot_openvr_fps>`__ (the tutorial for this project
  is :ref:`doc_vr_starter_tutorial_part_one`).
* `Godot XR tools <https://github.com/GodotVR/godot-xr-tools>`__, which shows implementations for VR
  features such as movement and picking up objects.

Other things to consider
------------------------

There are a few other subjects that we need to briefly touch upon in this primer that are important
to know.

The first are our units. In normal 3D games, you don't have to think a lot about units. As long as
everything is at the same scale, a box sized 1 unit by 1 unit by 1 unit can be any size from a cub
you can hold in your hand to something the size of a building. In AR and VR, this changes because
things in your virtual world are mapped to things in the real world. If you step 1 meter forward in
the real world, but you only move 1 cm forward in your virtual world, you have a problem. The same
with the position of your controllers; if they don't appear in the right relative space, it breaks
the immersion for the player. Most VR platforms, including our AR/VR Server, assume that 1 unit = 1
meter. The AR/VR server, however, has a property that, for convenience, is also exposed on the
ARVROrigin node called world scale. For instance, setting this to a value of 10 changes our coordinate
system so 10 units = 1 meter.

Performance is another thing that needs to be carefully considered. Especially VR taxes your game
a lot more than most people realize. For mobile VR, you have to be extra careful here, but even for
desktop games, there are three factors that make life extra difficult:

* You are rendering stereoscopic, two for the price of one. While not exactly doubling the work load
  and with things in the pipeline such as supporting the new MultiView OpenGL extension in mind, there
  still is an extra workload in rendering images for both eyes
* A normal game will run acceptably on 30fps and ideally manages 60fps. That gives you a big range to
  play with between lower end and higher end hardware. For any HMD application of AR or VR, however,
  60fps is the absolute minimum and you should target your games to run at a stable 90fps to ensure your
  users don't get motion sickness right off the bat.
* The high FOV and related lens distortion effect require many VR experiences to render at double the
  resolution. Yes a VIVE may only have a resolution of 1080x1200 per eye, we're rendering each eye at
  2160x2400 as a result. This is less of an issue for most AR applications.

All in all, the workload your GPU has in comparison with a normal 3D game is a fair amount
higher. While things are in the pipeline to improve this, such as MultiView and foveated rendering,
these aren't supported on all devices. This is why you see many VR games using a more art style
and if you pay close attention to those VR games that go for realism, you'll probably notice they're
a bit more conservative on the effects or use some good old optical trickery.


===================================================
/. ./tutorials/vr/openxr/index.rst
===================================================

.. _doc_openxr_introduction:

OpenXR plugin
=============

Welcome to the Godot OpenXR documentation!

Introduction
------------

This is the documentation for the `Godot OpenXR plugin <https://github.com/GodotVR/godot_openxr>`__.

The plugin is supported on Godot 3.4 and later. However, it does **not** support the upcoming Godot 4.0 release.

Getting started
---------------

To start a new project that supports OpenXR, start by opening up the Godot editor and creating a new project.

Copy the plugin into this new project in the subfolder ``addons/godot_openxr/`` using your operating system's file manager.
It is important that the plugin is placed in this **exact** location in your project folder.

Back in Godot, create a new 3D scene and press the **Instance Child Scene** button
(represented by a chain link icon) in the scene tree dock.
Select the ``addons/godot_openxr/scenes/first_person_controller_vr.tscn`` subscene
and add it to your scene.
Right-click the added node and select **Editable Children** to gain access
to some of the nodes in this subscene:

.. image:: img/editable_children.png

This is the bare minimum you need. However, for good measure, we suggest adding
a DirectionalLight node and a few MeshInstance nodes so you have something to see.
If you add those to the hand nodes, you can visualize where your controllers
are tracking.

Your scene should now look something like this:

.. image:: img/default_scene.png

Now you can press the **Run** button in the top-right corner of the editor
to start your project and you should be able to look around.

Next steps
----------

To turn this simple scene into a proper game, the sky is the limit.
Below, there are a few more topics specific to this plugin.
However, the following resources are a good place to continue:

- :ref:`VR starter tutorial <doc_vr_starter_tutorial_part_one>`
  in the official documentation may focus on OpenVR, but almost everything
  there applies to OpenXR as well.
- `Godot XR tools <https://github.com/GodotVR/godot-xr-tools>`__ is a plugin
  that contains a set of handy sub scene to quickly
  implement locomotion, object interaction and UI elements in your XR experience.

Please check the `Godot Engine community page <https://godotengine.org/community>`__ to find help from other Godot developers.
The ``#xr`` channel on the Godot Discord has become a vibrant Godot XR community.

Plugin features
---------------

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-vr-openxr

   enable_plugin
   runtime_selection
   passthrough
   deploy_on_quest
   handtracking


===================================================
/. ./tutorials/vr/openxr/enable_plugin.rst
===================================================

.. _doc_enable_plugin:

Enabling the OpenXR plugin
==========================

Due to the design of Godot's XR system, the plugin will always automatically load the OpenXR interface.
However, additional editor features will not be available unless the OpenXR plugin is enabled.

For this, go to **Project > Project Settings** and select the **Plugins** tab:

.. image:: img/enable_plugin.png

Make sure the **Enable** checkbox is checked.


===================================================
/. ./tutorials/vr/openxr/runtime_selection.rst
===================================================

.. _doc_runtime_selection:

Switching runtimes
==================

In OpenXR, it is standard for each runtime to implement a mechanism to make it
the current runtime. In Steam, the Oculus application or Windows MR portal,
there will be an option to switch to their runtime as the current OpenXR runtime.

Generally speaking, end users will have a preferred runtime due to not having a reason
to switch runtimes when playing games that support OpenXR. However, developers may wish to
test multiple runtimes to see if their game behaves.

To make this easy, Godot provides a dropdown in the top-right corner which can
switch the runtime Godot will use when testing:

.. image:: img/switch_runtime.png

The OpenXR plugin will **not** work with the Microsoft MR runtime.
That runtime only supports OpenXR applications that use DirectX,
but Godot uses OpenGL ES 3.0 or 2.0.

.. note::

    Selecting a runtime in this dropdown only applies to running the game
    from the editor. It does **not** change the runtime used by other
    applications. Exported projects will use the computers current runtime.
    Also, if you are deploying to an external device, this setting has no effect.

As OpenXR doesn't have a mechanism for registering runtimes that we can query,
Godot will check common locations for runtime configuration files.
The locations that are checked are stored in the ``addons/godot_openxr/runtimes.json`` file.
If you've installed a runtime in a nonstandard location or a runtime not currently present in this file, you can add it manually using a text editor.

.. seealso::

    If the dropdown isn't shown in your editor, make sure the plugin is enabled. 
    See :ref:`doc_enable_plugin`.


===================================================
/. ./tutorials/vr/openxr/passthrough.rst
===================================================

.. _doc_passthrough:

Passthrough
===========

.. note::

    Only available in versions **1.1.1 and later** of the OpenXR plugin.

Passthrough is a new feature introduced on the Meta Quest and added to the OpenXR spec as a Meta extension. 
It is likely this implementation will be implemented by other vendors where the hardware supports a passthrough mode
and promoted to core at some point.

Keep in mind that this feature is not guaranteed to be available.
Passthrough allows for the camera input on the headset to be used within the headset so the user can see the real world. 
This allows us to implement an AR-like experience in a VR headset.

If you are using the ``first person controller`` scene, you can simply
enable passthrough by checking the **Start Passthrough** option
on the controller node:

.. image:: img/start_passthrough.png

If you rather do this through code, you will first need to create an instance
of the ``OpenXRConfig`` object. 
You can do this the same way the ``first person controller`` does
and assign the ``OpenXRConfig.gdns`` as the script to a node,
or you can instance it in code as shown below:

.. code::

    var openxr_config = null


    func _ready():
        var config_gdns = load("res://addons/godot_ovrmobile/OvrInitConfig.gdns")
        if config_gdns:
            openxr_config = config_gdns.new()


    func start_passthrough():
        if openxr_config:
            return openxr_config.start_passthrough()
        else:
            return false


    func stop_passthrough():
        if openxr_config:
            openxr_config.stop_passthrough()

.. note::

        The Viewport's **Transparent Bg** property must be enabled prior to starting passthrough.
        The plugin will log a warning message if it detects an incorrect configuration. 

.. seealso::

    A fix for a bug related to turning transparent background on/off
    is scheduled for the Godot 3.4.3 release. If you wish to toggle passthrough
    in your game, you will need to be on that version or newer.


===================================================
/. ./tutorials/vr/openxr/deploy_on_quest.rst
===================================================

.. _doc_deploy_on_quest:

Deploying on Quest
==================

The OpenXR plugin makes developing for Android seamless with developing desktop XR experiences. 
Note that many Android based devices are very constrained performance-wise. Therefore,
**we highly recommend using the GLES2 renderer.**

.. note::

    Currently, the only Android-based device supported is the Meta Quest. 
    As Khronos is finalizing the official Android support for OpenXR, we will be able to offer further support soon.

.. seealso::

    As with any other Android device, please follow 
    `the instructions in the official Godot documentation for deploying to Android <https://docs.godotengine.org/en/stable/getting_started/workflow/export/exporting_for_android.html#doc-exporting-for-android>`__.

Enable developer mode on the Quest
----------------------------------

You can only deploy games to the Meta Quest if developer mode is enabled.
You can do this from the Oculus support application installed on your phone.
Please `follow the instructions on the Oculus developer site <https://developer.oculus.com/documentation/native/android/mobile-device-setup/>`__.

Setting up the export template
------------------------------

The instruction in the official Godot documentation already has you configuring an export template in Godot. However, a few extra settings are needed for XR deployment.

Open the export settings again by opening the **Project > Export...** menu and select the Android export template you created. 
If you haven't created it yet, do so now by pressing **Add...** and selecting **Android**.

Scroll down to the **Xr Features** section. Here, the important setting is the **Xr Mode** which should be set to **OpenXR**.
Note that the other options shown here should be set according to your project's needs.

.. image:: img/android_xr_features.png


===================================================
/. ./tutorials/vr/openxr/handtracking.rst
===================================================

.. _doc_handtracking:

Hand tracking
=============

.. note::

    Only available in versions **1.1.0 and later** of the OpenXR plugin.

The hand tracking API was originally added to OpenXR by Microsoft to make the tracking information for the users hands and fingers available to the XR client. The API provides pose data for all the bones in the players hands but leaves some room for interpretation in how the API is implemented by the XR runtime.

In SteamVR support was added based on Valves existing hand tracking system that also provides fully rigged bone data extrapolated from controller inputs and proximity sensors if hand tracking is not supported natively on the system used.

Meta added support for this API to their mobile OpenXR runtime tied into their existing hand tracking functionality on the Quest. Note that you do need to enable hand tracking in the export settings for this to be active. The hand tracking API is only used for pure hand tracking, no pose data is presented when controllers are used.

.. note::

    When using the hand tracking API it is thus important that the capabilities of the target platform are taken into account. 
    This may improve in time as feedback is provided to the OpenXR working group.

The hand tracking API defines the bone structure that all XR runtimes must abide to however it doesn't dictate the orientation of the bones in rest or any size requirements.

.. image:: img/hand_tracking_bones.png

Image courtesy of Khronos OpenXR specification.

The hand tracking API is independent of the action system and doesn't make use of it's poses. Hand tracking data is provided internally in global space (relative to the tracking volumes origin point) and the hand tracking nodes should thus have the :ref:`ARVROrigin <class_ARVROrigin>` node as their parent, not a :ref:`ARVRController <class_ARVRController>` node.

The plugin exposes the hand tracking API as two seperate systems. One that updates positions of a tree of nodes and one that updates bones of a :ref:`Skeleton <class_Skeleton>` so mesh deformation can be used.

Node based hand tracking
------------------------

This implementation is the most versatile as it doesn't require any knowledge of the hand model in rest pose. Note that the plugin comes with two example scenes called `left_hand_nodes.tscn` and `right_hand_nodes.tscn` that you can instance as child nodes of the `ARVROrigin` node. These scenes contain logic to automatically resize the used meshes to fit the size of the provided bone data.

.. image:: img/arvr_nodes_example.png

At the root of this scene is a :ref:`Spatial <class_Spatial>` node that has `config/OpenXRHand.gdns` assigned as its script. This class from the plugin will position the spatial node at the base of the hand (see Palm in our image up above) and will update the position and orientation of its children. 

.. image:: img/arvr_openxr_hand.png

There are two properties here:

* `Hand` identifies whether we are tracking the position of the left or right hand. 
* `Motion Range` is only available on SteamVR and limits how far the hand can close, this is only used in conjunction with infered hand tracking based on controller input.

Our spatial node needs a number of child nodes with hardcoded names that will be updated by our hand tracking system. The type of nodes is not important, our example script uses :ref:`MeshInstance <class_MeshInstance>` nodes to also visualise the bones. 

.. image:: img/hand_tracking_nodes.png

First we find the child node `Wrist`, underneath here there are nodes for each finger. Each node starts with the name of the finger followed by the name of the bone. The finger names are `Thumb`, `Index`, `Middle`, `Ring` and `Little`. The bone names are `Metacarpal`, `Proximal`, `Intermediate`, `Distal` and `Tip`. Ergo IndexDistal is the distal bone of the index finger.

.. note::
    The thumb is the only finger that does not have a intermediate bone! 

The parent-child relationships of these nodes are important and the hand will only look correct if this structure if followed exactly. Note that adding extra nodes isn't a problem, the example scenes add a number of extra bone meshes in to complete the look of the hand. Note also that the example scenes have scripts attached to the wrist node that update the size and positions of these extra nodes. 

Skeleton based hand tracking
----------------------------

The second method supported by the OpenXR plugin is exposing the bone data as a :ref:`Skeleton <class_Skeleton>` node. In this case the solution is divided in two classes, one for placing the hand in space and the second to animate the aforementioned skeleton by updating the bone poses of the skeleton.

This approach allows deforming a mesh which is a visually more pleasing solution however differences in implementation between the platforms does pose some problems.

.. note::
    Microsoft has added another API to OpenXR that allows for retrieving a properly skinned hand mesh however as they are currently the only platform supporting this API it has not yet been added to the plugin.

At this point in time the plugin only exposes the data as it is provided by the OpenXR runtime. The plugin has an example implementation based on meshes that Valve has made publicly available however these work most reliable when used in conjunction with SteamVR.
These scenes are `scenes/left_hand_mesh.tscn` and `scenes/right_hand_mesh.tscn` and can be childed to the :ref:`ARVROrigin <class_ARVROrigin>` node.

.. image:: img/arvr_mesh_example.png

Below is an overview of the steps needed to implement your own version.

.. note::
    The best way to implement this logic is to ask an artist to model a hand in 3D software using real hands dimensions and create an armature for the hand that follows the bone structure exactly as the OpenXR specification dictates in the image at the top of this article. When skinning special care needs to be taken keeping in mind that if full hand tracking is available, the distance between joints will be determined by the actual size of the players hand and may thus be different to the 3D model. After importing the model into Godot you can add the required scripts to make everything work.

To place the hand mesh in space a node needs to be added as a child to the :ref:`ARVROrigin <class_ARVROrigin>` node, this node needs to have the `config/OpenXRPose.gdns` script attached. When importing a 3D file you can add this script to the root node of the imported model.

The `OpenXRPose` script isn't just used by the hand logic but also exposes other pose locations configured in the action map.

.. image:: img/arvr_openxr_pose.png

The following properties can be set on this node:

* `Invisible If Inactive` enables logic that will automatically make this node invisible if the hand is not being tracked. 
* `Action` specifies which action in the actionmap is being tracked, this needs to be set to the special type `SkeletonBase`.
* `Path` specified the OpenXR input path, this is `/user/hand/left` for the left hand and `/user/hand/right` for the right hand.

The next step is adding the script `config/OpenXRSkeleton.gdns` to the skeleton node of the 3D model. This script has the same two properties as the `OpenXRHand` script namely `Hand` and `Motion Range` and they have the same use.

Note that the bone names are standardised, the list of bone names is presented below and need to be suffixed with either `_L` or `_R` depending on whether the bone is for respectively the left hand or the right hand:

* Palm
* Wrist
* Thumb_Metacarpal
* Thumb_Proximal
* Thumb_Distal
* Thumb_Tip
* Index_Metacarpal
* Index_Proximal
* Index_Intermediate
* Index_Distal
* Index_Tip
* Middle_Metacarpal
* Middle_Proximal
* Middle_Intermediate
* Middle_Distal
* Middle_Tip
* Ring_Metacarpal
* Ring_Proximal
* Ring_Intermediate
* Ring_Distal
* Ring_Tip
* Little_Metacarpal
* Little_Proximal
* Little_Intermediate
* Little_Distal
* Little_Tip

Finally, and this is standard Godot functionality, a common addition to hand tracking is to track the location of the tip of a finger for physics interaction. This can be accomplished with the :ref:`BoneAttachment <class_BoneAttachment>` node. Simply add this as a child node to the :ref:`Skeleton <class_Skeleton>` node and select the bone you want to track. Now you can add the desired physics object as a child to this node. 


===================================================
/. ./tutorials/vr/oculus_mobile/index.rst
===================================================

Oculus mobile plugin (deprecated)
=================================

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-vr-oculus_mobile

   developing_for_oculus_quest


===================================================
/. ./tutorials/vr/oculus_mobile/developing_for_oculus_quest.rst
===================================================

.. _doc_developing_for_oculus_quest:

Developing for Oculus Quest
===========================

Introduction
------------

This tutorial goes over how to get started developing for the
*Meta Quest* with the Godot Oculus Mobile plugin.

Before starting, there are two things you need to do:

First you need to go through the steps on the :ref:`doc_exporting_for_android`
page. This leads you through installing the toolset that Godot
needs to export to Android devices.

Next you need the Quest plugin. You can get it from the Asset
Library or manually download it from `here <https://github.com/GodotVR/godot-oculus-mobile-asset>`__.

Setting Up Godot
----------------

To get started open Godot and create a new project.

.. image:: img/quest_new_project.png

Make sure to choose the ``GLES2`` renderer. Due to the
Quest's GPU this backend is far better suited for the Quest.

Copy the addons folder from the Oculus Mobile asset into your Godot
project. Your project tree should look similar to this:

.. image:: img/quest_project_tree.png

Now you can start building the main scene:

- Add an :ref:`ARVROrigin <class_ARVROrigin>` node first.
- Then add three child nodes to the origin node, one :ref:`ARVRCamera <class_ARVRCamera>` and two :ref:`ARVRController <class_ARVRController>` nodes.
- Assign controller ID 1 to the first :ref:`ARVRController <class_ARVRController>` and rename that to ``LeftHand``.
- Assign controller ID 2 to the second :ref:`ARVRController <class_ARVRController>` and rename that to ``RightHand``.
- Finally add a :ref:`MeshInstance <class_MeshInstance>` as a child node to our first :ref:`ARVRController <class_ARVRController>` and create a box shape, resize the box so each side is set to 0.1. Now duplicate the :ref:`MeshInstance <class_MeshInstance>` and move it to the second :ref:`ARVRController <class_ARVRController>` node. These will stand in for our controllers.

.. image:: img/quest_scene_tree.png

Now add a script to the main node and add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Spatial


    var perform_runtime_config = false


    onready var ovr_init_config = preload("res://addons/godot_ovrmobile/OvrInitConfig.gdns").new()
    onready var ovr_performance = preload("res://addons/godot_ovrmobile/OvrPerformance.gdns").new()


    func _ready():
        var interface = ARVRServer.find_interface("OVRMobile")
        if interface:
            ovr_init_config.set_render_target_size_multiplier(1)

            if interface.initialize():
                get_viewport().arvr = true


    func _process(_delta):
        if not perform_runtime_config:
            ovr_performance.set_clock_levels(1, 1)
            ovr_performance.set_extra_latency_mode(1)
            perform_runtime_config = true

Before you can export this project to the Quest you need to do three
more things.

First go into the project settings and make sure that the main scene
is the scene we run. Godot does not ask you to set this on export.

.. image:: img/quest_project_settings.png

Then go into the export menu and configure a new Android export. If
you still haven't gone through the :ref:`doc_exporting_for_android`
page do it now. If you didn't you'll have some red messages on this
screen.

If you did you can forge ahead and make a few small changes to the
export settings. First change the XR Mode to ``Oculus Mobile VR``.
Then change the Degrees of Freedom mode to ``6DOF``.

.. image:: img/quest_export_settings.png

Now save and close the export window.

Setting Up Your Quest
---------------------

Follow `these instructions <https://developer.oculus.com/documentation/native/android/mobile-device-setup/>`__ to 
setup your device for development. 

Once your device is set up and connected, click the **Android logo** that should be visible in the top-right corner of the Godot editor.
When clicked, it exports your project and runs it on the connected device.
If you do not see this Android logo, make sure you have create an Android export preset
and that the preset is marked as **Runnable** in the Export dialog.

The above does the bare minimum to get your project running on the Quest,
it's not very exciting. Holger Dammertz has made a great toolkit for the
quest that contains a lot of scenes to get help you on your way including
really nice controller meshes.

You can find the toolkit `here <https://github.com/NeoSpark314/godot_oculus_quest_toolkit>`__.

If you want to help out with improving the plugin please join us `here <https://github.com/GodotVR/godot_oculus_mobile>`__.


===================================================
/. ./tutorials/vr/openvr/index.rst
===================================================

OpenVR plugin
=============

.. toctree::
   :maxdepth: 1
   :name: toc-tutorials-vr-openvr

   vr_starter_tutorial/index


===================================================
/. ./tutorials/vr/openvr/vr_starter_tutorial/index.rst
===================================================

VR starter tutorial
===================

.. toctree::
   :maxdepth: 1
   :name: doc_vr_starter_tutorial

   vr_starter_tutorial_part_one
   vr_starter_tutorial_part_two


===================================================
/. ./tutorials/vr/openvr/vr_starter_tutorial/vr_starter_tutorial_part_one.rst
===================================================

.. _doc_vr_starter_tutorial_part_one:

VR starter tutorial part 1
==========================

Introduction
------------

.. image:: img/starter_vr_tutorial_sword.png

This tutorial will show you how to make a beginner VR game project in Godot.

Keep in mind, **one of the most important things when making VR content is getting the scale of your assets correct**!
It can take lots of practice and iterations to get this right, but there are a few things you can do to make it easier:

- In VR, 1 unit is typically considered 1 meter. If you design your assets around that standard, you can save yourself a lot of headache.
- In your 3D modeling program, see if there is a way to measure and use real world distances. In Blender, you can use the MeasureIt add-on; in Maya, you can use the Measure Tool.
- You can make rough models using a tool like `Google Blocks <https://vr.google.com/blocks/>`__, and then refine in another 3D modelling program.
- Test often, as the assets can look dramatically different in VR than on a flat screen!

Throughout the course of this tutorial, we will cover:

- How to tell Godot to run in VR.
- How to make a teleportation locomotion system that uses the VR controllers.
- How to make a artificial movement locomotion system that uses the VR controllers.
- How to create a :ref:`RigidBody <class_RigidBody>`-based system that allows for picking up, dropping, and throwing RigidBody nodes using the VR controllers.
- How to create simple destroyable target.
- How to create some special :ref:`RigidBody <class_RigidBody>`-based objects that can destroy the targets.

.. tip:: While this tutorial can be completed by beginners, it is highly
          advised to complete :ref:`doc_your_first_2d_game`,
          if you are new to Godot and/or game development.

          **Some experience with making 3D games is required** before going through this tutorial series.
          This tutorial assumes you have experience with the Godot editor, GDScript, and basic 3D game development.
          A OpenVR-ready headset and two OpenVR-ready controllers are required.

          This tutorial was written and tested using a Windows Mixed Reality headset and controllers. This project has also been tested on the HTC Vive. Code adjustments may be required
          for other VR Headsets, such as the Oculus Rift.

The Godot project for this tutorial is found on the `OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__. The starter assets for this tutorial can be found in the releases
section on the GitHub repository. The starter assets contain some 3D models, sounds, scripts, and scenes that are configured for this tutorial.

.. note:: **Credits for the assets provided**:

          - The sky panorama was created by `CGTuts <https://cgi.tutsplus.com/articles/freebie-8-awesome-ocean-hdris--cg-5684>`__.

          - The font used is Titillium-Regular
          - - The font is licensed under the SIL Open Font License, Version 1.1

          - The audio used are from several different sources, all downloaded from the Sonniss #GameAudioGDC Bundle (`License PDF <https://sonniss.com/gdc-bundle-license/>`__)
          - - The folders where the audio files are stored have the same name as folders in the Sonniss audio bundle.

          - The OpenVR addon was created by `Bastiaan Olij <https://github.com/BastiaanOlij>`__ and is released under the MIT license. It can be found both on the `Godot Asset Library <https://godotengine.org/asset-library/asset/150>`__ and on `GitHub <https://github.com/GodotVR/godot-openvr-asset>`__. *3rd party code and libraries used in the OpenVR addon may be under a different license.*

          - The initial project, 3D models, and scripts were created by `TwistedTwigleg <https://github.com/TwistedTwigleg>`__ and is released under the MIT license.

.. tip:: You can find the finished project on the `OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__.


Getting everything ready
------------------------

If you have not already, go to the `OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps/releases/>`__ and download the "Starter Assets" file from the releases. Once you have the
starter assets downloaded, open up the project in Godot.

.. note:: The starter assets are not required to use the scripts provided in this tutorial.
          The starter assets include several premade scenes and scripts that will be used throughout the tutorial.

When the project is first loaded, the Game.tscn scene will be opened. This will be the main scene used for the tutorial. It includes several nodes and scenes already placed
throughout the scene, some background music, and several GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes.

_________________

The GUI-related :ref:`MeshInstance <class_MeshInstance>` nodes already have scripts attached to them. These scripts will set the texture of a :ref:`Viewport <class_Viewport>`
node to the albedo texture of the material of the :ref:`MeshInstance <class_MeshInstance>` node. This is used to display text within the VR project. Feel free to take a look
at the script, ``GUI.gd``, if you want. We will not be going over how to to use :ref:`Viewport <class_Viewport>` nodes for displaying UI on :ref:`MeshInstance <class_MeshInstance>`
nodes in this tutorial .

If you are interested in how to use :ref:`Viewport <class_Viewport>` nodes for displaying UI on :ref:`MeshInstance <class_MeshInstance>` nodes, see the :ref:`doc_viewport_as_texture`
tutorial. It covers how to use a :ref:`Viewport <class_Viewport>` as a render texture, along with how to apply that texture onto a :ref:`MeshInstance <class_MeshInstance>` node.

_________________

Before we jump into the tutorial, let's take a moment to talk about how the nodes used for VR work.

The :ref:`ARVROrigin <class_ARVROrigin>` node is the center point of the VR tracking system. The position of the :ref:`ARVROrigin <class_ARVROrigin>` is the position
the VR system considers the 'center' point on the floor. The :ref:`ARVROrigin <class_ARVROrigin>` has a `world scale` property that effects the size of the user within
the VR scene. For this tutorial, it is set to `1.4`, as the world was originally just a tad to big. As mentioned earlier, keeping the scale relatively consistent is
important in VR.

The :ref:`ARVRCamera <class_ARVRCamera>` is the player's headset and view into the scene. The :ref:`ARVRCamera <class_ARVRCamera>` is offset on the Y axis by the VR user's height,
which will be important later when we add teleportation locomotoin. If the VR system supports room tracking, then the :ref:`ARVRCamera <class_ARVRCamera>` will move as the player moves.
This means that the :ref:`ARVRCamera <class_ARVRCamera>` is not guaranteed to be in the same position as the :ref:`ARVROrigin <class_ARVROrigin>` node.

The :ref:`ARVRController <class_ARVRController>` node represents a VR controller. The :ref:`ARVRController <class_ARVRController>` will follow the position and rotation of the VR
controller relative to the :ref:`ARVROrigin <class_ARVROrigin>` node. All of the input for the VR controllers happens through the :ref:`ARVRController <class_ARVRController>` node.
An :ref:`ARVRController <class_ARVRController>` node with an ``ID`` of ``1`` represents the left VR controller, while an :ref:`ARVRController <class_ARVRController>` controller with an
``ID`` of ``2`` represents the right VR controller.

To summarize:

- The :ref:`ARVROrigin <class_ARVROrigin>` node is the center of the VR tracking system and is positioned on the floor.

- The :ref:`ARVRCamera <class_ARVRCamera>` is the player's VR headset and view into the scene.

- The :ref:`ARVRCamera <class_ARVRCamera>` node is offset on the Y axis by the user's height.

- If the VR system supports room tracking, then the :ref:`ARVRCamera <class_ARVRCamera>` node may be offset on the X and Z axes as the player moves.

- The :ref:`ARVRController <class_ARVRController>` nodes represent the VR controllers and handle all of the input from the VR controllers.


Starting VR
-----------

Now that we have gone over the VR nodes, let's start working on the project. While in ``Game.tscn``, select the ``Game`` node and make a new script called ``Game.gd``.
In the ``Game.gd`` file, add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Spatial

    func _ready():
        var VR = ARVRServer.find_interface("OpenVR")
        if VR and VR.initialize():
            get_viewport().arvr = true

            OS.vsync_enabled = false
            Engine.target_fps = 90
            # Also, the physics FPS in the project settings is also 90 FPS. This makes the physics
            # run at the same frame rate as the display, which makes things look smoother in VR!

 .. code-tab:: csharp

    using Godot;
    using System;

    public class Game : Spatial
    {
        public override void _Ready()
        {
            var vr = ARVRServer.FindInterface("OpenVR");
            if (vr != null && vr.Initialize())
            {
                GetViewport().Arvr = true;

                OS.VsyncEnabled = false;
                Engine.TargetFps = 90;
                // Also, the physics FPS in the project settings is also 90 FPS. This makes the physics
                // run at the same frame rate as the display, which makes things look smoother in VR!
            }
        }
    }

Let's go over what this code does.

_________________

In the ``_ready`` function, we first get the OpenVR VR interface using the ``find_interface`` function in the :ref:`ARVRServer <class_ARVRServer>` and assign it to a variable
called `VR`. If the :ref:`ARVRServer <class_ARVRServer>` finds an interface with the name OpenVR, it will return it, otherwise it will return ``null``.

.. note:: The OpenVR VR interface is not included with Godot by default. You will need to download the OpenVR asset from the
          `Asset Library <https://godotengine.org/asset-library/asset/150>`__ or `GitHub <https://github.com/GodotVR/godot-openvr-asset>`__.

The code then combines two conditionals, one to check if the `VR` variable is NOT null (``if VR``) and another calls the initialize function, which returns a boolean based on
whether the OpenVR interface was able to initialize or not. If both of these conditionals return true, then we can turn the main Godot :ref:`Viewport <class_Viewport>` into
an ARVR viewport.

If the VR interface initialized successfully, we then get the root :ref:`Viewport <class_Viewport>` and set the `arvr` property to ``true``. This will tell Godot to use the initialized
ARVR interface to drive the :ref:`Viewport <class_Viewport>` display.

Finally, we disable VSync so the Frames Per Second (FPS) is not capped by the computer monitor. After this we tell Godot to render at ``90`` frames per second, which is the
standard for most VR headsets. Without disabling VSync, the normal computer monitor may limit the frame rate of the VR headset to the frame rate of the computer monitor.

.. note:: In the project settings, under the ``Physics->Common`` tab, the physics FPS has been set to ``90``. This makes the physics engine run at the same frame rate as
          the VR display, which makes physics reactions look smoother when in VR.

_________________

That is all we need to do for Godot to launch OpenVR within the project! Go ahead and give it a try if you want. Assuming everything works, you will be able to look around
the world. If you have a VR headset with room tracking, then you will be able to move around the scene within the limits of the room tracking.

Creating the controllers
------------------------

.. image:: img/starter_vr_tutorial_hands.png

Right now all that the VR user can do is stand around, which isn't really what we are going for unless we are working on a VR film. Lets write the code for the
VR controllers. We are going to write all the code for the VR controllers in one go, so the code is rather long. That said, once we are finished you will be
able to teleport around the scene, artificially move using the touchpad/joystick on the VR controller, and be able to pick up, drop, and throw
:ref:`RigidBody <class_RigidBody>`-based nodes.

First we need to open the scene used for the VR controllers. ``Left_Controller.tscn`` or ``Right_Controller.tscn``. Let's briefly go over how the scene is setup.

How the VR controller scene is setup
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In both scenes the root node is a ARVRController node. The only difference is that the ``Left_Controller`` scene has the ``Controller Id`` property set to ``1`` while
the ``Right_Controller`` has the ``Controller Id`` property set to ``2``.

.. note:: The :ref:`ARVRServer <class_ARVRServer>` attempts to use these two IDs for the left and right VR controllers. For VR systems that support more than 2
          controllers/tracked-objects, these IDs may need adjusting.

Next is the ``Hand`` :ref:`MeshInstance <class_MeshInstance>` node. This node is used to display the hand mesh that will be used when the VR controller is not holding onto a
:ref:`RigidBody <class_RigidBody>` node. The hand in the ``Left_Controller`` scene is a left hand, while the hand on the ``Right_Controller`` scene is a right hand.

The node named ``Raycast`` is a :ref:`Raycast <class_Raycast>` node that is used for aiming where to teleport to when the VR controller is teleporting.
The length of the :ref:`Raycast <class_Raycast>` is set to ``-16`` on the Y axis and is rotated so that it points out of the pointer finger of the hand. The ``Raycast`` node has
a single child node, ``Mesh``, that is a :ref:`MeshInstance <class_MeshInstance>`. This is used for visually showing where the teleportation :ref:`Raycast <class_Raycast>` is aiming.

The node named ``Area`` is a :ref:`Area <class_Area>` node will be used for grabbing :ref:`RigidBody <class_RigidBody>`-based nodes when the VR controller grab mode is set to ``AREA``.
The ``Area`` node has a single child node, ``CollisionShape``, that defines a sphere :ref:`CollisionShape <class_CollisionShape>`. When the VR controller is not holding any objects and the grab button is pressed,
the first :ref:`RigidBody <class_RigidBody>`-based node within the ``Area`` node will be picked up.

Next is a :ref:`Position3D <class_Position3D>` node called ``Grab_Pos``. This is used to define the position that grabbed :ref:`RigidBody <class_RigidBody>` nodes will follow then
they are held by the VR controller.

A large :ref:`Area <class_Area>` node called ``Sleep_Area`` is used to disable sleeping for any RigidBody nodes within its :ref:`CollisionShape <class_CollisionShape>`,
simple called ``CollisionShape``. This is needed because if a :ref:`RigidBody <class_RigidBody>` node falls asleep, then the VR controller will be unable to grab it.
By using ``Sleep_Area``, we can write code that makes any :ref:`RigidBody <class_RigidBody>` node within it not able to sleep, therefore allowing the VR controller to grab it.

An :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node called ``AudioStreamPlayer3D`` has a sound loaded that we will use when an object has been picked up, dropped
or thrown by the VR controller. While this is not necessary for the functionality of the VR controller, it makes grabbing and dropping objects feel more natural.

Finally, the last nodes are the ``Grab_Cast`` node and it's only child node, ``Mesh``. The ``Grab_Cast`` node will be used for grabbing :ref:`RigidBody <class_RigidBody>`-based
nodes when the VR controller grab mode is set to ``RAYCAST``. This will allow the VR controller to grab objects that are just slightly out of reach using a Raycast. The ``Mesh``
node is used for visually showing where the teleportation :ref:`Raycast <class_Raycast>` is aiming.

That is a quick overview of how the VR controller scenes are setup, and how we will be using the nodes to provide the functionality for them. Now that we have looked at the
VR controller scene, let's write the code that will drive them.

The code for the VR controllers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Select the root node of the scene, either ``Right_Controller`` or ``Left_Controller``, and make a new script called ``VR_Controller.gd``. Both scenes will be using
the same script, so it doesn't matter which you use first. With ``VR_Controller.gd`` opened, add the following code:

.. tip:: You can copy and paste the code from this page directly into the script editor.

         If you do this, all the code copied will be using spaces instead of tabs.

         To convert the spaces to tabs in the script editor, click the ``Edit`` menu and select ``Convert Indent To Tabs``.
         This will convert all the spaces into tabs. You can select ``Convert Indent To Spaces`` to convert tabs back into spaces.

.. tabs::
 .. code-tab:: gdscript GDScript

    extends ARVRController

    var controller_velocity = Vector3(0,0,0)
    var prior_controller_position = Vector3(0,0,0)
    var prior_controller_velocities = []

    var held_object = null
    var held_object_data = {"mode":RigidBody.MODE_RIGID, "layer":1, "mask":1}

    var grab_area
    var grab_raycast

    var grab_mode = "AREA"
    var grab_pos_node

    var hand_mesh
    var hand_pickup_drop_sound

    var teleport_pos = Vector3.ZERO
    var teleport_mesh
    var teleport_button_down
    var teleport_raycast

    # A constant to define the dead zone for both the trackpad and the joystick.
    # See https://web.archive.org/web/20191208161810/http://www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html
    # for more information on what dead zones are, and how we are using them in this project.
    const CONTROLLER_DEADZONE = 0.65

    const MOVEMENT_SPEED = 1.5

    const CONTROLLER_RUMBLE_FADE_SPEED = 2.0

    var directional_movement = false


    func _ready():
        # Ignore the warnings the from the connect function calls.
        # (We will not need the returned values for this tutorial)
        # warning-ignore-all:return_value_discarded

        teleport_raycast = get_node("RayCast")

        teleport_mesh = get_tree().root.get_node("Game/Teleport_Mesh")

        teleport_button_down = false
        teleport_mesh.visible = false
        teleport_raycast.visible = false

        grab_area = get_node("Area")
        grab_raycast = get_node("Grab_Cast")
        grab_pos_node = get_node("Grab_Pos")

        grab_mode = "AREA"
        grab_raycast.visible = false

        get_node("Sleep_Area").connect("body_entered", self, "sleep_area_entered")
        get_node("Sleep_Area").connect("body_exited", self, "sleep_area_exited")

        hand_mesh = get_node("Hand")
        hand_pickup_drop_sound = get_node("AudioStreamPlayer3D")

        connect("button_pressed", self, "button_pressed")
        connect("button_release", self, "button_released")


    func _physics_process(delta):
        if rumble > 0:
            rumble -= delta * CONTROLLER_RUMBLE_FADE_SPEED
            if rumble < 0:
                rumble = 0

        if teleport_button_down == true:
            teleport_raycast.force_raycast_update()
            if teleport_raycast.is_colliding():
                if teleport_raycast.get_collider() is StaticBody:
                    if teleport_raycast.get_collision_normal().y >= 0.85:
                        teleport_pos = teleport_raycast.get_collision_point()
                        teleport_mesh.global_transform.origin = teleport_pos


        if get_is_active() == true:
            _physics_process_update_controller_velocity(delta)

        if held_object != null:
            var held_scale = held_object.scale
            held_object.global_transform = grab_pos_node.global_transform
            held_object.scale = held_scale

        _physics_process_directional_movement(delta);


    func _physics_process_update_controller_velocity(delta):
        controller_velocity = Vector3(0,0,0)

        if prior_controller_velocities.size() > 0:
            for vel in prior_controller_velocities:
                controller_velocity += vel

            controller_velocity = controller_velocity / prior_controller_velocities.size()

        var relative_controller_position = (global_transform.origin - prior_controller_position)

        controller_velocity += relative_controller_position

        prior_controller_velocities.append(relative_controller_position)

        prior_controller_position = global_transform.origin

        controller_velocity /= delta;

        if prior_controller_velocities.size() > 30:
            prior_controller_velocities.remove(0)


    func _physics_process_directional_movement(delta):
        var trackpad_vector = Vector2(-get_joystick_axis(1), get_joystick_axis(0))
        var joystick_vector = Vector2(-get_joystick_axis(5), get_joystick_axis(4))

        if trackpad_vector.length() < CONTROLLER_DEADZONE:
            trackpad_vector = Vector2(0,0)
        else:
            trackpad_vector = trackpad_vector.normalized() * ((trackpad_vector.length() - CONTROLLER_DEADZONE) / (1 - CONTROLLER_DEADZONE))

        if joystick_vector.length() < CONTROLLER_DEADZONE:
            joystick_vector = Vector2(0,0)
        else:
            joystick_vector = joystick_vector.normalized() * ((joystick_vector.length() - CONTROLLER_DEADZONE) / (1 - CONTROLLER_DEADZONE))

        var forward_direction = get_parent().get_node("Player_Camera").global_transform.basis.z.normalized()
        var right_direction = get_parent().get_node("Player_Camera").global_transform.basis.x.normalized()

        # Because the trackpad and the joystick will both move the player, we can add them together and normalize
        # the result, giving the combined movement direction
        var movement_vector = (trackpad_vector + joystick_vector).normalized()

        var movement_forward = forward_direction * movement_vector.x * delta * MOVEMENT_SPEED
        var movement_right = right_direction * movement_vector.y * delta * MOVEMENT_SPEED

        movement_forward.y = 0
        movement_right.y = 0

        if movement_right.length() > 0 or movement_forward.length() > 0:
            get_parent().global_translate(movement_right + movement_forward)
            directional_movement = true
        else:
            directional_movement = false


    func button_pressed(button_index):
        if button_index == 15:
            _on_button_pressed_trigger()

        if button_index == 2:
            _on_button_pressed_grab()

        if button_index == 1:
            _on_button_pressed_menu()


    func _on_button_pressed_trigger():
        if held_object == null:
            if teleport_mesh.visible == false:
                teleport_button_down = true
                teleport_mesh.visible = true
                teleport_raycast.visible = true
        else:
            if held_object is VR_Interactable_Rigidbody:
                held_object.interact()


    func _on_button_pressed_grab():
        if teleport_button_down == true:
            return

        if held_object == null:
            _pickup_rigidbody()
        else:
            _throw_rigidbody()

        hand_pickup_drop_sound.play()


    func _pickup_rigidbody():
        var rigid_body = null

        if grab_mode == "AREA":
            var bodies = grab_area.get_overlapping_bodies()
            if len(bodies) > 0:
                for body in bodies:
                    if body is RigidBody:
                        if !("NO_PICKUP" in body):
                            rigid_body = body
                            break

        elif grab_mode == "RAYCAST":
            grab_raycast.force_raycast_update()
            if grab_raycast.is_colliding():
                var body = grab_raycast.get_collider()
                if body is RigidBody:
                    if !("NO_PICKUP" in body):
                        rigid_body = body


        if rigid_body != null:

            held_object = rigid_body

            held_object_data["mode"] = held_object.mode
            held_object_data["layer"] = held_object.collision_layer
            held_object_data["mask"] = held_object.collision_mask

            held_object.mode = RigidBody.MODE_STATIC
            held_object.collision_layer = 0
            held_object.collision_mask = 0

            hand_mesh.visible = false
            grab_raycast.visible = false

            if held_object is VR_Interactable_Rigidbody:
                held_object.controller = self
                held_object.picked_up()


    func _throw_rigidbody():
        if held_object == null:
            return

        held_object.mode = held_object_data["mode"]
        held_object.collision_layer = held_object_data["layer"]
        held_object.collision_mask = held_object_data["mask"]

        held_object.apply_impulse(Vector3(0, 0, 0), controller_velocity)

        if held_object is VR_Interactable_Rigidbody:
            held_object.dropped()
            held_object.controller = null

        held_object = null
        hand_mesh.visible = true

        if grab_mode == "RAYCAST":
            grab_raycast.visible = true


    func _on_button_pressed_menu():
        if grab_mode == "AREA":
            grab_mode = "RAYCAST"
            if held_object == null:
                grab_raycast.visible = true

        elif grab_mode == "RAYCAST":
            grab_mode = "AREA"
            grab_raycast.visible = false


    func button_released(button_index):
        if button_index == 15:
            _on_button_released_trigger()


    func _on_button_released_trigger():
        if teleport_button_down == true:

            if teleport_pos != null and teleport_mesh.visible == true:
                var camera_offset = get_parent().get_node("Player_Camera").global_transform.origin - get_parent().global_transform.origin
                camera_offset.y = 0

                get_parent().global_transform.origin = teleport_pos - camera_offset

            teleport_button_down = false
            teleport_mesh.visible = false
            teleport_raycast.visible = false
            teleport_pos = null


    func sleep_area_entered(body):
        if "can_sleep" in body:
            body.can_sleep = false
            body.sleeping = false


    func sleep_area_exited(body):
        if "can_sleep" in body:
            # Allow the CollisionBody to sleep by setting the "can_sleep" variable to true
            body.can_sleep = true

This is quite a bit of code to go through. Let's go through what the code does step-by-step.

Explaining the VR controller code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, let's go through all the class variables in the script:

* ``controller_velocity``: A variable to hold a rough approximation of the VR controller's velocity.
* ``prior_controller_position``: A variable to hold the VR controller's last position in 3D space.
* ``prior_controller_velocities``: An Array to hold the last 30 calculated VR controller velocities. This is used to smooth the velocity calculations over time.
* ``held_object``: A variable to hold a reference to the object the VR controller is holding. If the VR controller is not holding any objects, this variable will be ``null``.
* ``held_object_data``: A dictionary to hold data for the :ref:`RigidBody <class_RigidBody>` node being held by the VR controller. This is used to reset the :ref:`RigidBody <class_RigidBody>`'s data when it is no longer held.
* ``grab_area``: A variable to hold the :ref:`Area <class_Area>` node used to grab objects with the VR controller.
* ``grab_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node used to grab objects with the VR controller.
* ``grab_mode``: A variable to define the grab mode the VR controller is using. There are only two modes for grabbing objects in this tutorial, ``AREA`` and ``RAYCAST``.
* ``grab_pos_node``: A variable to hold the node that will be used to update the position and rotation of held objects.
* ``hand_mesh``: A variable to hold the :ref:`MeshInstance <class_MeshInstance>` node that contains the hand mesh for the VR controller. This mesh will be shown when the VR controller is not holding anything.
* ``hand_pickup_drop_sound``: A variable to hold the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node that contains the pickup/drop sound.
* ``teleport_pos``: A variable to hold the position the player will be teleported to when the VR controller teleports the player.
* ``teleport_mesh``: A variable to hold the :ref:`MeshInstance <class_MeshInstance>` node used to show where the player is teleporting to.
* ``teleport_button_down``: A variable used to track whether the controller's teleport button is held down. This will be used to detect if this VR controller is trying to teleport the player.
* ``teleport_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node used to calculate the teleport position. This node also has a :ref:`MeshInstance <class_MeshInstance>` that acts as a 'laser sight' for aiming.
* ``CONTROLLER_DEADZONE``: A constant to define the deadzone for both the trackpad and the joystick on the VR controller. See the note below for more information.
* ``MOVEMENT_SPEED``: A constant to define the speed the player moves at when using the trackpad/joystick to move artificially.
* ``CONTROLLER_RUMBLE_FADE_SPEED``: A constant to define how fast the VR controller rumble fades.
* ``directional_movement``: A variable to hold whether this VR controller is moving the player using the touchpad/joystick.

.. note:: You can find a great article explaining all about how to handle touchpad/joystick dead zones `here <https://web.archive.org/web/20191208161810/http://www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html>`__.

          We are using a translated version of the scaled radial dead zone code provided in that article for the VR controller's joystick/touchpad.
          The article is a great read, and I highly suggest giving it a look!

That is quite a few class variables. Most of them are used to hold references to nodes we will need throughout the code. Next let's start looking at the functions, starting
with the ``_ready`` function.

_________________

``_ready`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""

First we tell Godot to silence the warnings about not using the values returned by the ``connect`` function. We will not need the returned
values for this tutorial.

Next we get the :ref:`Raycast <class_Raycast>` node we are going to use for determining the position for teleporting and assign it to the ``teleport_raycast`` variable.
We then get the :ref:`MeshInstance <class_MeshInstance>` node that we will use to show where the player will be teleporting to. The node we are using for teleporting
is a child of the ``Game`` scene. We do this so the teleport mesh node is not effected by changes in the VR controller, and so the teleport mesh can be used by both VR controllers.

Then the ``teleport_button_down`` variable is set to false, ``teleport_mesh.visible`` is set to ``false``, and ``teleport_raycast.visible`` is set to ``false``. This sets up the variables
for teleporting the player into their initial, not teleporting the player, state.

The code then gets the ``grab_area`` node, the ``grab_raycast`` node, and the ``grab_pos_node`` node and assigns them all to their respective variables for use later.

Next the ``grab_mode`` is set to ``AREA`` so the VR controller will attempt to grab objects using the :ref:`Area <class_Area>` node defined in ``grab_area`` when the VR controller's
grab/grip button is pressed. We also set the ``grab_raycast`` node's ``visible`` property to ``false`` so the 'laser sight' child node of ``grab_raycast`` is not visible.

After that we connect the ``body_entered`` and ``body_exited`` signals from the ``Sleep_Area`` node in the VR controller to the ``sleep_area_entered`` and ``sleep_area_exited`` functions.
The ``sleep_area_entered`` and ``sleep_area_exited`` functions will be used to make :ref:`RigidBody <class_RigidBody>` nodes unable to sleep when nearby the VR controller.

Then the ``hand_mesh`` and ``hand_pickup_drop_sound`` nodes are gotten and assigned them to their respective variables for use later.

Finally, the ``button_pressed`` and ``button_release`` signals in the :ref:`ARVRController <class_ARVRController>` node, which the VR controller extends, are connected to the
``button_pressed`` and ``button_released`` functions respectively. This means that when a button on the VR controller is pressed or released, the ``button_pressed`` or ``button_released``
functions defined in this script will be called.


``_physics_process`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""

First we check to see if the ``rumble`` variable is more than zero. If the ``rumble`` variable, which is a property of the :ref:`ARVRController <class_ARVRController>` node, is more
than zero then the VR controller rumbles.

If the ``rumble`` variable is more than zero, then we reduce the rumble by ``CONTROLLER_RUMBLE_FADE_SPEED`` every second by subtracting ``CONTROLLER_RUMBLE_FADE_SPEED`` multiplied by delta.
There is then a ``if`` condition to check if ``rumble`` is less than zero, which sets ``rumble`` to zero if its value is less than zero.

This small section of code is all we need for reducing the VR controller's rumble. Now when we set ``rumble`` to a value, this code will automatically make it fade over time.

_________________

The first section of code checks to see if the ``teleport_button_down`` variable is equal to ``true``, which means this VR controller is trying to teleport.

If ``teleport_button_down`` is equal to ``true``, we force the ``teleport_raycast`` :ref:`Raycast <class_Raycast>` node to update using the ``force_raycast_update`` function.
The ``force_raycast_update`` function will update the properties within the :ref:`Raycast <class_Raycast>` node with the latest version of the physics world.

The code then checks to see if the ``teleport_raycast`` collided with anything by checking of the ``is_colliding`` function in ``teleport_raycast`` is true. If the :ref:`Raycast <class_Raycast>`
collided with something, we then check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the raycast collided with is a :ref:`StaticBody <class_StaticBody>` or not. We then check to
see if the collision normal vector returned by the raycast is greater than or equal to ``0.85`` on the Y axis.

.. note:: We do this because we do not want the user to be able to teleport onto RigidBody nodes and we only want the player to be able to teleport on floor-like surfaces.

If all these conditions are met, then we assign the ``teleport_pos`` variable to the ``get_collision_point`` function in ``teleport_raycast``. This will assign ``teleport_pos`` to the
position the raycast collided at in world space. We then move the ``teleport_mesh`` to the world position stored in ``teleport_pos``.

This section of code will get the position the player is aiming at with the teleportation raycast and update the teleportation mesh, giving a visual update on where the user will be teleporting
to when the release the teleport button.

_________________

The next section of code first checks to see if the VR controller is active through the ``get_is_active`` function, which is defined by :ref:`ARVRController <class_ARVRController>`. If the
VR controller is active, then it calls the ``_physics_process_update_controller_velocity`` function.

The ``_physics_process_update_controller_velocity`` function will calculate the VR controller's velocity through changes in position. It is not perfect, but this process gets a rough
idea of the velocity of the VR controller, which is fine for the purposes of this tutorial.

_________________

The next section of code checks to see if the VR controller is holding an object by checking to see if the ``held_object`` variable is not equal to ``null``.

If the VR controller is holding an object, we first store it's scale in a temporary variable called ``held_scale``. We then set the ``global_transform`` of the held object
to the ``global_transform`` of the ``held_object`` node. This will make the held object have the same position, rotation, and scale of the ``grab_pos_node`` node in world space.

However, because we do not want the held object to change in scale when it is grabbed, we need to set the ``scale`` property of the ``held_object`` node back to ``held_scale``.

This section of code will keep the held object in the same position and rotation as the VR controller, keeping it synced with the VR controller.

_________________

Finally, the last section of code simply calls the ``_physics_process_directional_movement`` function. This function contains all the code for moving the player when the
touchpad/joystick on the VR controller moves.


``_physics_process_update_controller_velocity`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

First this function resets the ``controller_velocity`` variable to zero :ref:`Vector3 <class_Vector3>`.

_________________

Then we check to see if there are any stored/cached VR controller velocities saved in the ``prior_controller_velocities`` array. We do this by checking to see if the ``size()`` function
returns a value greater than ``0``. If there are cached velocities within ``prior_controller_velocities``, then we iterate through each of the stored velocities using a ``for`` loop.

For each of the cached velocities, we simply add its value to ``controller_velocity``. Once the code has gone through all of the cached velocities in ``prior_controller_velocities``,
we divide ``controller_velocity`` by the size of the ``prior_controller_velocities`` array, which will give us the combined velocity value. This helps take the previous velocities into
account, making the direction of the controller's velocity more accurate.

_________________

Next we calculate the change in position the VR controller has taken since the last ``_physics_process`` function call. We do this by subtracting ``prior_controller_position`` from the
global position of the VR controller, ``global_transform.origin``. This will give us a :ref:`Vector3 <class_Vector3>` that points from the position in ``prior_controller_position`` to
the current position of the VR controller, which we store in a variable called ``relative_controller_position``.

Next we add the change in position to ``controller_velocity`` so the latest change in position is taken into account in the velocity calculation. We then add ``relative_controller_position``
to ``prior_controller_velocities`` so it can be taken into account on the next calculation of the VR controller's velocity.

Then ``prior_controller_position`` is updated with the global position of the VR controller, ``global_transform.origin``. We then divide ``controller_velocity`` by ``delta`` so the velocity
is higher, giving results like those we expect, while still being relative to the amount of time that has passed. It is not a perfect solution, but the results look decent most of the time
and for the purposes of this tutorial, it is good enough.

Finally, the function checks to see if the ``prior_controller_velocities`` has more than ``30`` velocities cached by checking if the ``size()`` function returns a value greater than ``30``.
If there are more than ``30`` cached velocities stored in ``prior_controller_velocities``, then we simply remove the oldest cached velocity by calling the ``remove`` function and passing in
a index position of ``0``.

_________________

What this function ultimately does is that it gets a rough idea of the VR controller's velocity by calculating the VR controller's relative changes in position
over the last thirty ``_physics_process`` calls. While this is not perfect, it gives a decent idea of how fast the VR controller is moving in 3D space.


``_physics_process_directional_movement`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

First this function gets the axes for the trackpad and the joystick and assigns them to :ref:`Vector2 <class_Vector2>` variables called ``trackpad_vector`` and ``joystick_vector`` respectively.

.. note:: You may need to remap the joystick and/or touchpad index values depending on your VR headset and controller. The inputs in this tutorial are the index values of a
          Windows Mixed Reality headset.

Then ``trackpad_vector`` and ``joystick_vector`` have their deadzones account for. The code for this is detailed in the article below, with slight changes as the code is converted from
C# to GDScript.

Once the ``trackpad_vector`` and ``joystick_vector`` variables have had their deadzones account for, the code then gets the forward and right direction vectors relative to the
global transform of the :ref:`ARVRCamera <class_ARVRCamera>`. What this does is that it gives us vectors that point forward and right relative to the rotation of the user camera,
the :ref:`ARVRCamera <class_ARVRCamera>`, in world space. These vectors point in the same direction of the blue and red arrows when you select an object in the Godot editor with
the ``local space mode`` button enabled. The forward direction vector is stored in a variable called ``forward_direction``, while the right direction vector is stored in a variable
called ``right_direction``.

Next the code adds the ``trackpad_vector`` and ``joystick_vector`` variables together and normalizes the results using the ``normalized`` function. This gives us the
combined movement direction of both input devices, so we can use a single :ref:`Vector2 <class_Vector2>` for moving the user. We assign the combined direction to a variable called ``movement_vector``.

Then we calculate the distance the user will move forward, relative to the forward direction stored in ``forward_direction``. To calculate this, we multiply ``forward_direction`` by ``movement_vector.x``,
``delta``, and ``MOVEMENT_SPEED``. This will give us the distance the user will move forward when the trackpad/joystick is pushed forward or backwards. We assign this to a variable called
``movement_forward``.

We do a similar calculation for the distance the user will move right, relative to the right direction stored in ``right_direction``. To calculate the distance the user will move right,
we multiply ``right_direction`` by ``movement_vector.y``, ``delta``, and ``MOVEMENT_SPEED``. This will give us the distance the user will move right when the trackpad/joystick is pushed right or left.
We assign this to a variable called ``movement_right``.

Next we remove any movement on the ``Y`` axis of ``movement_forward`` and ``movement_right`` by assigning their ``Y`` values to ``0``. We do this so the user cannot fly/fall simply by moving the trackpad
or joystick. Without doing this, the player could fly in the direction they are facing.

Finally, we check to see if the ``length`` function on ``movement_right`` or ``movement_forward`` is greater than ``0``. If it is, then we need to move the user. To move the user, we perform a global
translation to the :ref:`ARVROrigin <class_ARVROrigin>` node using ``get_parent().global_translate`` and pass in the ``movement_right`` variable with the ``movement_forward`` variable added to it. This
will move the player in the direction the trackpad/joystick is pointing, relative to the rotation of the VR headset. We also set the ``directional_movement`` variable to ``true`` so the code knows this
VR controller is moving the player.

If the ``length`` function on ``movement_right`` or ``movement_forward`` is less than or equal to ``0``, then we simply set the ``directional_movement`` variable to ``false`` so the code knows this VR
controller is not moving the player.


_________________

What this function ultimately does is takes the input from the VR controller's trackpad and joystick and moves the player in the direction the player is pushing them. Movement is relative to the rotation
of the VR headset, so if the player pushes forward and turns their head to the left, they will move to the left.


``button_pressed`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""

This function checks to see if the VR button that was just pressed is equal to one of the VR buttons used in this project. The ``button_index`` variable is passed in by the
``button_pressed`` signal in :ref:`ARVRController <class_ARVRController>`, which we connected in the ``_ready`` function.

There are only three buttons we are looking for in this project: the trigger button, the grab/grip button, and the menu button.

.. note:: You may need to remap these button index values depending on your VR headset and controller. The inputs in this tutorial are the index values of a
          Windows Mixed Reality headset.

First we check if the ``button_index`` is equal to ``15``, which should map to the trigger button on the VR controller. If the button pressed is the trigger button,
then the ``_on_button_pressed_trigger`` function is called.

If the ``button_index`` is equal to ``2``, then the grab button was just pressed. If the button pressed is the grab button, the ``_on_button_pressed_grab`` function is called.

Finally, if the ``button_index`` is equal to ``1``, then the menu button was just pressed. If the button pressed is the menu button, the ``_on_button_pressed_menu`` function is called.


``_on_button_pressed_trigger`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

First this function checks to see if the VR controller is not holding by checking if ``held_object`` is equal to ``null``. If the VR controller is not holding anything, then
we assume that the trigger press on the VR controller was for teleporting. We then make sure that ``teleport_mesh.visible`` is equal to ``false``. We use this to tell if
the other VR controller is trying to teleport or not, as ``teleport_mesh`` will be visible if the other VR controller is teleporting.

If ``teleport_mesh.visible`` is equal to ``false``, then we can teleport with this VR controller. We set the ``teleport_button_down`` variable to ``true``, set
``teleport_mesh.visible`` to true, and set ``teleport_raycast.visible`` to ``true``. This will tell the code in ``_physics_process`` that this VR controller is going to
teleport, it will make the ``teleport_mesh`` visible so the user knows where the are teleporting to, and will make ``teleport_raycast`` visible to the player has a
'laser sight' they can use to aim the teleportation pos.

_________________

If ``held_object`` is not equal to ``null``, then the VR controller is holding something. We then check to see if the object that is being held, ``held_object``, extends
a class called ``VR_Interactable_Rigidbody``. We have not made ``VR_Interactable_Rigidbody`` yet, but ``VR_Interactable_Rigidbody`` will be a custom class we will use
on all of the special/custom :ref:`RigidBody <class_RigidBody>`-based nodes in the project.

.. tip:: Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!

If the ``held_object`` extends ``VR_Interactable_Rigidbody``, then we call the ``interact`` function, so the held object can do whatever it is supposed to do when
the trigger is pressed and the object is held by the VR controller.


``_on_button_pressed_grab`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

First this function checks to see if ``teleport_button_down`` is equal to ``true``. If it is, then it calls ``return``. We do this because we do not want the user to be
able to pick up objects while teleporting.

Then we check to see if the VR controller is currently not holding anything by checking if ``held_object`` is equal to ``null``. If the VR controller is not holding anything,
then the ``_pickup_rigidbody`` function is called. If the VR controller is holding something, ``held_object`` is not equal to ``null``, then the ``_throw_rigidbody`` function is called.

Finally, the pick-up/drop sound is played by calling the ``play`` function on ``hand_pickup_drop_sound``.


``_pickup_rigidbody`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""

First the function makes a variable called ``rigid_body``, which we'll be using to store the :ref:`RigidBody <class_RigidBody>` that the VR controller is going to
pick up, assuming there is a RigidBody to pick up.

_________________

Then the function checks to see if the ``grab_mode`` variable is equal to ``AREA``. If it is, then it gets all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes within the ``grab_area`` using
the ``get_overlapping_bodies`` functions. This function will return an array of :ref:`PhysicsBody <class_PhysicsBody>` nodes. We assign the array of :ref:`PhysicsBody <class_PhysicsBody>` to a new
variable called ``bodies``.

We then check to see if the length of the ``bodies`` variable is more than ``0``. If it is, we go through each of the :ref:`PhysicsBody <class_PhysicsBody>` nodes in ``bodies`` using a for loop.

For each :ref:`PhysicsBody <class_PhysicsBody>` node, we check if it is, or extends, a :ref:`RigidBody <class_RigidBody>` node using ``if body is RigidBody``, which will return ``true`` if the
:ref:`PhysicsBody <class_PhysicsBody>` node is or extends the :ref:`RigidBody <class_RigidBody>` node. If the object is a :ref:`RigidBody <class_RigidBody>`, then we check to make sure there is not
a variable/constant called ``NO_PICKUP`` defined in the body. We do this because if you want to have :ref:`RigidBody <class_RigidBody>` nodes that cannot be picked up, all you have to do is
define a constant/variable called ``NO_PICKUP`` and the VR controller will be unable to pick it up. If the :ref:`RigidBody <class_RigidBody>` node does not have a variable/constant defined with
the name ``NO_PICKUP``, then we assign the ``rigid_body`` variable to the :ref:`RigidBody <class_RigidBody>` node and break the for loop.

What this section of code does is goes through all of the physics bodies within the ``grab_area`` and grabs the first :ref:`RigidBody <class_RigidBody>` node that does not have a
variable/constant named ``NO_PICKUP`` and assigns it to the ``rigid_body`` variable so we can do some additional post processing later in this function.

_________________

If the ``grab_mode`` variable is not equal to ``AREA``, we then check to see if it is equal to ``RAYCAST`` instead. If it is equal to ``RAYCAST``, we force the ``grab_raycast`` node to update
using the ``force_raycast_update`` function. The ``force_raycast_update`` function will update the :ref:`Raycast <class_Raycast>` with the latest changes in the physics world. We then check
to see if the ``grab_raycast`` node collided with something using the ``is_colliding`` function, which will return true if the :ref:`Raycast <class_Raycast>` hit something.

If the ``grab_raycast`` hit something, we get the :ref:`PhysicsBody <class_PhysicsBody>` node hit using the ``get_collider`` function. The code then checks to see if the node hit is
a :ref:`RigidBody <class_RigidBody>` node using ``if body is RigidBody``, which will return ``true`` if the :ref:`PhysicsBody <class_PhysicsBody>` node is or extends the
:ref:`RigidBody <class_RigidBody>` node. Then the code checks to see if the :ref:`RigidBody <class_RigidBody>` node does not have a variable named ``NO_PICKUP``, and if it does not,
then it assigns the :ref:`RigidBody <class_RigidBody>` node to the ``rigid_body`` variable.

What this section of code does is sends the ``grab_raycast`` :ref:`Raycast <class_Raycast>` node out and checks if it collided with a :ref:`RigidBody <class_RigidBody>` node that does
not have a variable/constant named ``NO_PICKUP``. If it collided with a RigidBody without ``NO_PICKUP``, it assigns the node to the ``rigid_body`` variable so we can do some
additional post processing later in this function.

_________________

The final section of code first checks to see if ``rigid_body`` is not equal to ``null``. If ``rigid_body`` is not equal to ``null``, then the VR controller found a
:ref:`RigidBody <class_RigidBody>`-based node that can be picked up.

If there is a VR controller to pickup, we assign ``held_object`` to the :ref:`RigidBody <class_RigidBody>` node stored in ``rigid_body``. We then store the :ref:`RigidBody <class_RigidBody>` node's
``mode``, ``collision_layer``, and ``collision_mask`` in ``held_object_data`` using ``mode``, ``layer``, and ``mask`` as keys for the respective values. This is so we can reapply them
later when the object is dropped by the VR controller.

We then set the :ref:`RigidBody <class_RigidBody>`'s mode to ``MODE_STATIC``, it's ``collision_layer`` to zero, and it's ``collision_mask`` to zero. This will make it where the held
:ref:`RigidBody <class_RigidBody>` cannot interact with other objects in the physics world when held by the VR controller.

Next the ``hand_mesh`` :ref:`MeshInstance <class_MeshInstance>` is made invisible by setting the ``visible`` property to ``false``. This is so the hand does not get in the way of the held object.
Likewise, the ``grab_raycast`` 'laser sight' is made invisible by setting the ``visible`` property to ``false``.

Then the code checks to see if the held object extends a class called ``VR_Interactable_Rigidbody``. If it does, then sets a variable called ``controller`` on ``held_object`` to ``self``, and
calls the ``picked_up`` function on ``held_object``. While we haven't made ``VR_Interactable_Rigidbody`` just yet, what this will do is set tell the ``VR_Interactable_Rigidbody`` class that it is
being held by a VR controller, where the a reference to the controller is stored in the ``controller`` variable, through calling the ``picked_up`` function.

.. tip:: Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!

         The code should make more sense after completing part 2 of this tutorial series, where we will actually be using ``VR_Interactable_Rigidbody``.

What this section of code does is that if a :ref:`RigidBody <class_RigidBody>` was found using the grab :ref:`Area <class_Area>` or :ref:`Raycast <class_Raycast>`, it sets it up so that
it can be carried by the VR controller.

``_throw_rigidbody`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""

First the function checks to see if the VR controller is not holding any object by checking if the ``held_object`` variable is equal to ``null``. If it is, then it simply
calls ``return`` so nothing happens. While this shouldn't be possible, the ``_throw_rigidbody`` function should only be called if an object is held, this check helps ensure
that if something strange happens, this function will react as expected.

After checking if the VR controller is holding an object, we assume it is and set the stored :ref:`RigidBody <class_RigidBody>` data back to the held object. We take the ``mode``, ``layer`` and
``mask`` data stored in the ``held_object_data`` dictionary and reapply it to the object in ``held_object``. This will set the :ref:`RigidBody <class_RigidBody>` back to the state it was prior to
being picked up.

Then we call ``apply_impulse`` on the ``held_object`` so that the :ref:`RigidBody <class_RigidBody>` is thrown in the direction of the VR controller's velocity, ``controller_velocity``.

We then check to see if the object held extends a class called ``VR_Interactable_Rigidbody``. If it does, then we call a function called ``dropped`` in ``held_object`` and set
``held_object.controller`` to ``null``. While we have not made ``VR_Interactable_Rigidbody`` yet, but what this will do is call the ``droppped`` function so the :ref:`RigidBody <class_RigidBody>`
can do whatever it needs to do when dropped, and we set the ``controller`` variable to ``null`` so that the :ref:`RigidBody <class_RigidBody>` knows that it is not being held.

.. tip:: Don't worry, we will cover ``VR_Interactable_Rigidbody`` after this section!

         The code should make more sense after completing part 2 of this tutorial series, where we will actually be using ``VR_Interactable_Rigidbody``.

Regardless of whether ``held_object`` extends ``VR_Interactable_Rigidbody`` or not, we then set ``held_object`` to ``null`` so the VR controller knows it is no longer holding anything.
Because the VR controller is no longer holding anything, we make the ``hand_mesh`` visible by setting ``hand_mesh.visible`` to true.

Finally, if the ``grab_mode`` variable is set to ``RAYCAST``, we set ``grab_raycast.visible`` to ``true`` so the 'laser sight' for the :ref:`Raycast <class_Raycast>` in ``grab_raycast`` is visible.


``_on_button_pressed_menu`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

First this function checks to see if the ``grab_mode`` variable is equal to ``AREA``. If it is, then it sets ``grab_mode`` to ``RAYCAST``. It then checks to see if the VR controller is not
holding anything by checking to see if ``held_object`` is equal to ``null``. If the VR controller is not holding anything, then ``grab_raycast.visible`` is set to ``true`` so the
'laser sight' on the grab raycast is visible.

If the ``grab_mode`` variable is not equal to ``AREA``, then it checks to see if it is equal to ``RAYCAST``. If it is, then it sets the ``grab_mode`` to ``AREA`` and sets ``grab_raycast.visible``
to ``false`` so the 'laser sight' on the grab raycast is not visible.

This section of code simply changes how the VR controller will grab :ref:`RigidBody <class_RigidBody>`-based nodes when the grab/grip button is pressed. If ``grab_mode`` is set to ``AREA``, then
the :ref:`Area <class_Area>` node in ``grab_area`` will be used for detecting :ref:`RigidBody <class_RigidBody>` nodes, while if ``grab_mode`` is set to ``RAYCAST`` the :ref:`Raycast <class_Raycast>`
node in ``grab_raycast`` will be used for detecting :ref:`RigidBody <class_RigidBody>` nodes.


``button_released`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""

The only section of code in this function checks to see if the index of the button that was just released, ``button_index``, is equal to ``15``, which should map to the trigger button
on the VR controller. The ``button_index`` variable is passed in by the ``button_release`` signal in :ref:`ARVRController <class_ARVRController>`, which we connected in the ``_ready`` function.

If the trigger button was just released, then the ``_on_button_released_trigger`` function is called.


``_on_button_released_trigger`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The only section of code in this function first checks to see if the VR controller is trying to teleport by checking if the ``teleport_button_down`` variable is equal to ``true``.

If the ``teleport_button_down`` variable is equal to ``true``, the code then checks if there is a teleport position set and whether the teleport mesh is visible. It does this by
checking to see if ``teleport_pos`` is not equal to ``null`` and if ``teleport_mesh.visible`` is equal to ``true``.

If there is a teleport position set and the teleport mesh is visible, the code then calculates the offset from the camera to the :ref:`ARVROrigin <class_ARVROrigin>` node, which is assumed to be the
parent node of the VR controller. To calculate the offset, the global position (``global_transform.origin``) of the ``Player_Camera`` node has the global position of the :ref:`ARVROrigin <class_ARVROrigin>`
subtracted from it. This will result in a vector that points from the :ref:`ARVROrigin <class_ARVROrigin>` to the :ref:`ARVRCamera <class_ARVRCamera>`, which we store in a variable called ``camera_offset``.

The reason we need to know the offset is because some VR headsets use room tracking, where the player's camera can be offset from the :ref:`ARVROrigin <class_ARVROrigin>` node. Because of this, when we teleport we want to
keep the offset created by room tracking so that when the player teleports, the offset created by the room tracking is not applied. Without this, if you moved in a room and then teleported, instead
of appearing at the position you wanted to teleport at, your position would be offset by the amount of distance you have from the :ref:`ARVROrigin <class_ARVROrigin>` node.

Now that we know the offset from the VR camera to the VR origin, we need to remove the difference on the ``Y`` axis. We do this because we do not want to offset based on the user's height.
If we did not do this, when teleporting the player's head would be level with the ground.

Then we can 'teleport' the player by setting the global position (``global_transform.origin``) of the ARVROrigin node to the position stored in ``teleport_pos`` with ``camera_offset`` subtracted from it.
This will teleport the player and remove the room tracking offset, so the user appears exactly where they want when teleporting.

Finally, regardless of whether the VR controller teleported the user or not, we reset the teleport related variables. ``teleport_button_down`` is set to ``false``, ``teleport_mesh.visible`` is
set to ``false`` so the mesh is invisible, ``teleport_raycast.visible`` is set to ``false``, and ``teleport_pos`` is set to ``null``.


``sleep_area_entered`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The only section of code in this function checks to see if the :ref:`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node
has a variable called ``can_sleep``. If it does, then it sets the ``can_sleep`` variable to ``false`` and sets the ``sleeping`` variable to ``false``.

Without doing this, sleeping :ref:`PhysicsBody <class_PhysicsBody>` nodes would not be able to be picked up by the VR controller, even if the VR controller
is at the same position as the :ref:`PhysicsBody <class_PhysicsBody>` node. To work around this, we simply 'wake up' :ref:`PhysicsBody <class_PhysicsBody>` nodes
that are close to the VR controller.


``sleep_area_exited`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""

The only section of code in this function checks to see if the :ref:`PhysicsBody <class_PhysicsBody>` node that entered the ``Sleep_Area`` node
has a variable called ``can_sleep``. If it does, then it sets the ``can_sleep`` variable to ``true``.

This allows :ref:`RigidBody <class_RigidBody>` nodes that leave the ``Sleep_Area`` to sleep again, saving performance.

_________________

Okay, whew! That was a lot of code! Add the same script, ``VR_Controller.gd`` to the other VR controller scene so both VR controllers have the same script.

Now we just need to do one thing before testing the project! Right now we are referencing a class called ``VR_Interactable_Rigidbody``, but we have not defined it yet.
While we will not be using ``VR_Interactable_Rigidbody`` in this tutorial, let's create it real quick so the project can be run.



Creating a base class for interactable VR objects
-------------------------------------------------

With the ``Script`` tab still open, create a new GDScript called ``VR_Interactable_Rigidbody.gd``.

.. tip:: You can create GDScripts in the ``Script`` tab by pressing ``File -> New Script...``.

Once you have ``VR_Interactable_Rigidbody.gd`` open, add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    class_name VR_Interactable_Rigidbody
    extends RigidBody

    # (Ignore the unused variable warning)
    # warning-ignore:unused_class_variable
    var controller = null


    func _ready():
        pass


    func interact():
        pass


    func picked_up():
        pass


    func dropped():
        pass


Let's quickly go through what this script.

_________________

First we start the script with ``class_name VR_Interactable_Rigidbody``. What this does is that it tells Godot that this GDScript is a new class that called ``VR_Interactable_Rigidbody``.
This allows us to compare nodes against the ``VR_Interactable_Rigidbody`` class in other script files without having to load the script directly or do anything special. We can compare
the class just like all of the built-in Godot classes.

Next is a class variable called ``controller``. ``controller`` will be used to hold a reference to the VR controller that is currently holding the object. If a VR controller is not
holding the object, then the ``controller`` variable will be ``null``. The reason we need to have a reference to the VR controller is so held objects can access VR controller specific
data, like ``controller_velocity``.

Finally, we have four functions. The ``_ready`` function is defined by Godot and all we do is simply have ``pass`` as there is nothing we need to do when the object is added to the scene
in ``VR_Interactable_Rigidbody``.

The ``interact`` function is a stub function that will be called when the interact button on the VR controller, the trigger in this case, is pressed while the object is held.

.. tip:: A stub function is a function that is defined but does not have any code. Stub functions are generally designed to be overwritten or extended. In this project, we are using
         the stub functions so there is a consistent interface across all interactable :ref:`RigidBody <class_RigidBody>` objects.

The ``picked_up`` and ``dropped`` functions are stub functions that will be called when the object is picked up and dropped by the VR controller.

_________________

That is all we need to do for now! In the next part of this tutorial series, we'll start making special interactable :ref:`RigidBody <class_RigidBody>` objects.

Now that the base class is defined, the code in the VR controller should work. Go ahead and try the game again, and you should find you can teleport around by pressing the touch pad,
and can grab and throw objects using the grab/grip buttons.

Now, you may want to try moving using the trackpads and/or joysticks, but **it may make you motion sick!**

One of the main reasons this can make you feel motion sick is because your vision tells you that you are moving, while your body is not moving.
This conflict of signals can make the body feel sick. Let's add a vignette shader to help reduce motion sickness while moving in VR!



Reducing motion sickness
------------------------

.. note:: There are plenty of ways to reduce motion sickness in VR, and there is no one perfect way to reduce motion sickness. See
          `this page on the Oculus Developer Center <https://developer.oculus.com/design/latest/concepts/bp-locomotion/>`__
          for more information on how to implement locomotion and reducing motion sickness.

To help reduce motion sickness while moving, we are going to add a vignette effect that will only be visible while the player moves.

First, quickly switch back to ``Game.tscn``. Under the :ref:`ARVROrigin <class_ARVROrigin>` node there is a child node called ``Movement_Vignette``. This node is going to apply a simple
vignette to the VR headset when the player is moving using the VR controllers. This should help reduce motion sickness.

Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` folder. The scene is just a :ref:`ColorRect <class_ColorRect>` node with a custom
shader. Feel free to look at the custom shader if you want, it is just a slightly modified version of the vignette shader you can find in the
`Godot demo repository <https://github.com/godotengine/godot-demo-projects>`__.

Let's write the code that will make the vignette shader visible when the player is moving. Select the ``Movement_Vignette`` node and create a new script called ``Movement_Vignette.gd``.
Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Control

    var controller_one
    var controller_two


    func _ready():
        yield(get_tree(), "idle_frame")
        yield(get_tree(), "idle_frame")
        yield(get_tree(), "idle_frame")
        yield(get_tree(), "idle_frame")

        var interface = ARVRServer.primary_interface

        if interface == null:
            set_process(false)
            printerr("Movement_Vignette: no VR interface found!")
            return

        rect_size = interface.get_render_targetsize()
        rect_position = Vector2(0,0)

        controller_one = get_parent().get_node("Left_Controller")
        controller_two = get_parent().get_node("Right_Controller")

        visible = false


    func _process(_delta):
        if controller_one == null or controller_two == null:
            return

        if controller_one.directional_movement == true or controller_two.directional_movement == true:
            visible = true
        else:
            visible = false

Because this script is fairly brief, let's quickly go over what it does.


Explaining the vignette code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are two class variables, ``controller_one`` and ``controller_two``. These variables will hold references to the left and right VR controllers.

_________________

In the ``_ready`` function first waits for four frames using ``yield``. The reason we are waiting four frames is because we want to ensure the VR interface is ready
and accessible.

After waiting the primary VR interface is retrieved using ``ARVRServer.primary_interface``, which is assigned to a variable called ``interface``.
The code then checks to see if ``interface`` is equal to ``null``. If ``interface`` is equal to ``null``, then ``_process`` is disabled using ``set_process`` with a value of ``false``.

If ``interface`` is not ``null``, then we set the ``rect_size`` of the vignette shader to the render size of the VR viewport so it takes up the entire screen. We need to do this because
different VR headsets have different resolutions and aspect ratios, so we need to resize the node accordingly. We also set the ``rect_position`` of the vignette shader to zero so it
is in the correct position relative to the screen.

The left and right VR controllers are then retrieved and assigned to ``controller_one`` and ``controller_two`` respectively. Finally, the vignette shader is made invisible by default
by setting it's ``visible`` property to ``false``.

_________________

In ``_process`` the code first checks if either ``controller_one`` or ``controller_two`` are equal to ``null``. If either node is equal to ``null``, then ``return`` is called so
nothing happens.

Then the code checks to see if either of the VR controllers are moving the player using the touchpad/joystick by checking if ``directional_movement`` is equal to ``true`` in
``controller_one`` or ``controller_two``. If either of the VR controllers are moving the player, then the vignette shader makes itself visible by setting it's ``visible`` property
to ``true``. If neither VR controller is moving the player, so ``directional_movement`` is ``false`` in both VR controllers, than the vignette shader makes itself invisible by setting
it's ``visible`` property to ``false``.

_________________

That is the whole script! Now that we have written the code, go ahead and try moving around with the trackpad and/or joystick. You should find that it is less motion sickness-inducing
then before!

.. note:: As previously mentioned, there are plenty of ways to reduce motion sickness in VR. Check out
          `this page on the Oculus Developer Center <https://developer.oculus.com/design/latest/concepts/bp-locomotion/>`__
          for more information on how to implement locomotion and reducing motion sickness.



Final notes
-----------

.. image:: img/starter_vr_tutorial_hands.png

Now you have fully working VR controllers that can move around the environment and interact with :ref:`RigidBody <class_RigidBody>`-based objects.
In the next part of this tutorial series, we will be creating some special :ref:`RigidBody <class_RigidBody>`-based objects for the player to use!

.. warning:: You can download the finished project for this tutorial series on the Godot OpenVR GitHub repository, under the releases tab!


===================================================
/. ./tutorials/vr/openvr/vr_starter_tutorial/vr_starter_tutorial_part_two.rst
===================================================

.. _doc_vr_starter_tutorial_part_two:

VR starter tutorial part 2
==========================

Introduction
------------

.. image:: img/starter_vr_tutorial_sword.png

In this part of the VR starter tutorial series, we will be adding a number of special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used in VR.

This continues from where we left on in the last tutorial part, where we just finished getting the VR controllers working and defined a custom
class called ``VR_Interactable_Rigidbody``.

.. tip:: You can find the finished project on the `OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__.


Adding destroyable targets
--------------------------

Before we make any of the special :ref:`RigidBody <class_RigidBody>`-based nodes, we need something for them to do. Let's make a simple sphere target that will break into a bunch of pieces
when destroyed.

Open up ``Sphere_Target.tscn``, which is in the ``Scenes`` folder. The scene is fairly simple, with just a :ref:`StaticBody <class_StaticBody>` with a sphere shaped
:ref:`CollisionShape <class_CollisionShape>`, a :ref:`MeshInstance <class_MeshInstance>` node displaying a sphere mesh, and an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node.

The special :ref:`RigidBody <class_RigidBody>` nodes will handle damaging the sphere, which is why we are using a :ref:`StaticBody <class_StaticBody>` node instead of something like
an :ref:`Area <class_Area>` or :ref:`RigidBody <class_RigidBody>` node. Outside of that, there isn't really a lot to talk about, so let's move straight into writing the code.

Select the ``Sphere_Target_Root`` node and make a new script called ``Sphere_Target.gd``. Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Spatial

    var destroyed = false
    var destroyed_timer = 0
    const DESTROY_WAIT_TIME = 80

    var health = 80

    const RIGID_BODY_TARGET = preload("res://Assets/RigidBody_Sphere.scn")


    func _ready():
        set_physics_process(false)


    func _physics_process(delta):
        destroyed_timer += delta
        if destroyed_timer >= DESTROY_WAIT_TIME:
            queue_free()


    func damage(damage):
        if destroyed == true:
            return

        health -= damage

        if health <= 0:

            get_node("CollisionShape").disabled = true
            get_node("Shpere_Target").visible = false

            var clone = RIGID_BODY_TARGET.instance()
            add_child(clone)
            clone.global_transform = global_transform

            destroyed = true
            set_physics_process(true)

            get_node("AudioStreamPlayer").play()
            get_tree().root.get_node("Game").remove_sphere()


Let's go over how this script works.

Explaining the Sphere Target code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, let's go through all the class variables in the script:

* ``destroyed``: A variable to track whether the sphere target has been destroyed.
* ``destroyed_timer``: A variable to track how long the sphere target has been destroyed.
* ``DESTROY_WAIT_TIME``: A constant to define the length of time the target can be destroyed for before it frees/deletes itself.
* ``health``: A variable to store the amount of health the sphere target has.
* ``RIGID_BODY_TARGET``: A constant to hold the scene of the destroyed sphere target.

.. note:: Feel free to check out the ``RIGID_BODY_TARGET`` scene. It is just a bunch of :ref:`RigidBody <class_RigidBody>` nodes and a broken sphere model.

          We'll be instancing this scene so when the target is destroyed, it looks like it broke into a bunch of pieces.


``_ready`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""

All the ``_ready`` function does is that it stops the ``_physics_process`` from being called by calling ``set_physics_process`` and passing ``false``.
The reason we do this is because all the code in ``_physics_process`` is for destroying this node when enough time has passed, which we only want to
do when the target has been destroyed.


``_physics_process`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""

First this function adds time, ``delta``, to the ``destroyed_timer`` variable. It then checks to see if ``destroyed_timer`` is greater than or equal to
``DESTROY_WAIT_TIME``. If ``destroyed_timer`` is greater than or equal to ``DESTROY_WAIT_TIME``, then the sphere target frees/deletes itself by calling
the ``queue_free`` function.

``damage`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""

The ``damage`` function will be called by the special :ref:`RigidBody <class_RigidBody>` nodes, which will pass the amount of damage done to the target, which is a function argument
variable called ``damage``. The ``damage`` variable will hold the amount of damage the special :ref:`RigidBody <class_RigidBody>` node did to the sphere target.

First this function checks to make sure the target is not already destroyed by checking if the ``destroyed`` variable is equal to ``true``. If ``destroyed`` is equal to ``true``, then
the function calls ``return`` so none of the other code is called. This is just a safety check so that if two things damage the target at exactly the same time, the target cannot be
destroyed twice.

Next the function removes the amount of damage taken, ``damage``, from the target's health, ``health``. If then checks to see if ``health`` is equal to zero or less, meaning that the
target has just been destroyed.

If the target has just been destroyed, then we disable the :ref:`CollisionShape <class_CollisionShape>` by setting it's ``disabled`` property to ``true``. We then make the ``Sphere_Target``
:ref:`MeshInstance <class_MeshInstance>` invisible by setting the ``visible`` property to ``false``. We do this so the target can no longer effect the physics world and so the non-broken target mesh is not visible.

After this the function then instances the ``RIGID_BODY_TARGET`` scene and adds it as a child of the target. It then sets the ``global_transform`` of the newly instanced scene, called ``clone``, to the
``global_transform`` of the non-broken target. This makes it where the broken target starts at the same position as the non-broken target with the same rotation and scale.

Then the function sets the ``destroyed`` variable to ``true`` so the target knows it has been destroyed and calls the ``set_physics_process`` function and passes ``true``. This will start
executing the code in ``_physics_process`` so that after ``DESTROY_WAIT_TIME`` seconds have passed, the sphere target will free/destroy itself.

The function then gets the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node and calls the ``play`` function so it plays its sound.

Finally, the ``remove_sphere`` function is called in ``Game.gd``. To get ``Game.gd``, the code uses the scene tree and works its way from the root of the scene tree to the root of the
``Game.tscn`` scene.


Adding the ``remove_sphere`` function to ``Game.gd``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You may have noticed we are calling a function in ``Game.gd``, called ``remove_sphere``, that we have not defined yet. Open up ``Game.gd`` and
add the following additional class variables:

.. tabs::
 .. code-tab:: gdscript GDScript

    var spheres_left = 10
    var sphere_ui = null

- ``spheres_left``: The amount of sphere targets left in the world. In the provided ``Game`` scene, there are ``10`` spheres, so that is the initial value.
- ``sphere_ui``: A reference to the sphere UI. We will use this later in the tutorial to display the amount of spheres left in the world.

With these variables defined, we can now add the ``remove_sphere`` function. Add the following code to ``Game.gd``:

.. tabs::
 .. code-tab:: gdscript GDScript

    func remove_sphere():
        spheres_left -= 1

        if sphere_ui != null:
            sphere_ui.update_ui(spheres_left)


Let's go through what this function does real quick:

First, it removes one from the ``spheres_left`` variable. It then checks to see if the ``sphere_ui`` variable is not equal to ``null``, and if it is not
equal to ``null`` it calls the ``update_ui`` function on ``sphere_ui``, passing in the number of spheres as an argument to the function.

.. note:: We will add the code for ``sphere_ui`` later in this tutorial!

Now the ``Sphere_Target`` is ready to be used, but we don't have any way to destroy it. Let's fix that by adding some special :ref:`RigidBody <class_RigidBody>`-based nodes
that can damage the targets.


Adding a pistol
---------------

Let's add a pistol as the first interactable :ref:`RigidBody <class_RigidBody>` node. Open up ``Pistol.tscn``, which you can find in the ``Scenes`` folder.

Let's quickly go over a few things of note in ``Pistol.tscn`` real quick before we add the code.

All of the nodes in ``Pistol.tscn`` expect the root node are rotated. This is so the pistol is in the correct rotation relative to the VR controller when it is picked up. The root node
is a :ref:`RigidBody <class_RigidBody>` node, which we need because we're going to use the ``VR_Interactable_Rigidbody`` class we created in the last part of this tutorial series.

There is a :ref:`MeshInstance <class_MeshInstance>` node called ``Pistol_Flash``, which is a simple mesh that we will be using to simulate the muzzle flash on the end of the pistol's barrel.
A :ref:`MeshInstance <class_MeshInstance>` node called ``LaserSight`` is used to as a guide for aiming the pistol, and it follows the direction of the :ref:`Raycast <class_Raycast>` node,
called ``Raycast``, that the pistol uses to detect if its 'bullet' hit something. Finally, there is an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node at the end of the
pistol that we will use to play the sound of the pistol firing.

Feel free to look at the other parts of the scene if you want. Most of the scene is fairly straightforward, with the major changes mentioned above. Select the :ref:`RigidBody <class_RigidBody>`
node called ``Pistol`` and make a new script called ``Pistol.gd``. Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends VR_Interactable_Rigidbody

    var flash_mesh
    const FLASH_TIME = 0.25
    var flash_timer = 0

    var laser_sight_mesh
    var pistol_fire_sound

    var raycast
    const BULLET_DAMAGE = 20
    const COLLISION_FORCE = 1.5


    func _ready():
        flash_mesh = get_node("Pistol_Flash")
        flash_mesh.visible = false

        laser_sight_mesh = get_node("LaserSight")
        laser_sight_mesh.visible = false

        raycast = get_node("RayCast")
        pistol_fire_sound = get_node("AudioStreamPlayer3D")


    func _physics_process(delta):
        if flash_timer > 0:
            flash_timer -= delta
            if flash_timer <= 0:
                flash_mesh.visible = false


    func interact():
        if flash_timer <= 0:

            flash_timer = FLASH_TIME
            flash_mesh.visible = true

            raycast.force_raycast_update()
            if raycast.is_colliding():

                var body = raycast.get_collider()
                var direction_vector = raycast.global_transform.basis.z.normalized()
                var raycast_distance = raycast.global_transform.origin.distance_to(raycast.get_collision_point())

                if body.has_method("damage"):
                    body.damage(BULLET_DAMAGE)
                elif body is RigidBody:
                    var collision_force = (COLLISION_FORCE / raycast_distance) * body.mass
                    body.apply_impulse((raycast.global_transform.origin - body.global_transform.origin).normalized(), direction_vector * collision_force)

            pistol_fire_sound.play()

            if controller != null:
                controller.rumble = 0.25


    func picked_up():
        laser_sight_mesh.visible = true


    func dropped():
        laser_sight_mesh.visible = false

Let's go over how this script works.


Explaining the pistol code
^^^^^^^^^^^^^^^^^^^^^^^^^^

First, notice how instead of ``extends RigidBody``, we instead have ``extends VR_Interactable_Rigidbody``. This makes it where the pistol script extends the
``VR_Interactable_Rigidbody`` class so the VR controllers know this object can be interacted with and that the functions defined in ``VR_Interactable_Rigidbody``
can be called when this object is held by a VR controller.

Next, let's look at the class variables:

* ``flash_mesh``: A variable to hold the :ref:`MeshInstance <class_MeshInstance>` node that is used to simulate muzzle flash on the pistol.
* ``FLASH_TIME``: A constant to define how long the muzzle flash will be visible. This will also define how fast the pistol can fire.
* ``flash_timer``: A variable to hold the amount of time the muzzle flash has been visible for.
* ``laser_sight_mesh``: A variable to hold the :ref:`MeshInstance <class_MeshInstance>` node that acts as the pistol's 'laser sight'.
* ``pistol_fire_sound``: A variable to hold the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used for the pistol's firing sound.
* ``raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node that is used for calculating the bullet's position and normal when the pistol is fired.
* ``BULLET_DAMAGE``: A constant to define the amount of damage a single bullet from the pistol does.
* ``COLLISION_FORCE``: A constant that defines the amount of force that is applied to :ref:`RigidBody <class_RigidBody>` nodes when the pistol's bullet collides.


``_ready`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""

This function gets the nodes and assigns them to their proper variables. For the ``flash_mesh`` and ``laser_sight_mesh`` nodes, both have their ``visible`` property set to ``false``
so they are not visible initially.

``_physics_process`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``_physics_process`` function first checks to see if the pistol's muzzle flash is visible by checking if ``flash_timer`` is more than zero. If ``flash_timer`` is more than
zero, then we remove time, ``delta`` from it. Next we check if the ``flash_timer`` variable is zero or less now that we removed ``delta`` from it. If it is, then the pistol
muzzle flash timer just finished and so we need to make ``flash_mesh`` invisible by setting it's ``visible`` property to ``false``.

``interact`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""

The interact function first checks to see if the pistol's muzzle flash is invisible by checking to see if ``flash_timer`` is less than or equal to zero. We do this so we
can limit the rate of fire of the pistol to the length of time the muzzle flash is visible, which is a simple solution for limiting how fast the player can fire.

If ``flash_timer`` is zero or less, we then set ``flash_timer`` to ``FLASH_TIME`` so there is a delay before the pistol can fire again. After that we set ``flash_mesh.visible``
to ``true`` so the muzzle flash at the end of the pistol is visible while ``flash_timer`` is more than zero.

Next we call the ``force_raycast_update`` function on the :ref:`Raycast <class_Raycast>` node in ``raycast`` so that it gets the latest collision info from the physics world.
We then check if the ``raycast`` hit something by checking if the ``is_colliding`` function is equal to ``true``.

_________________

If the ``raycast`` hit something, then we get the :ref:`PhysicsBody <class_PhysicsBody>` it collided with through the ``get_collider`` function. We assign the
hit :ref:`PhysicsBody <class_PhysicsBody>` to a variable called ``body``.

We then get the direction of the :ref:`Raycast <class_Raycast>` by getting it's positive ``Z`` directional axis from the :ref:`Basis <class_Basis>` on the ``raycast`` node's ``global_transform``.
This will give us the direction the raycast is pointing on the Z axis, which is the same direction as the blue arrow on the :ref:`Spatial <class_Spatial>` gizmo when
``Local space mode`` is enabled in the Godot editor. We store this direction in a variable called ``direction_vector``.

Next we get the distance from the :ref:`Raycast <class_Raycast>` origin to the :ref:`Raycast <class_Raycast>` collision point by getting the distance from the global position, ``global_transform.origin``
of the ``raycast`` node to the collision point of the :ref:`Raycast <class_Raycast>`, ``raycast.get_collision_point``, using the ``distance_to`` function. This will give us the distance the
:ref:`Raycast <class_Raycast>` traveled before it collided, which we store in a variable called ``raycast_distance``.

Then the code checks if the :ref:`PhysicsBody <class_PhysicsBody>`, ``body``, has a function/method called ``damage`` using the ``has_method`` function. If the :ref:`PhysicsBody <class_PhysicsBody>`
has a function/method called ``damage``, then we call the ``damage`` function and pass ``BULLET_DAMAGE`` so it takes damage from the bullet colliding into it.

Regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` has a ``damage`` function, we then check to see if ``body`` is a :ref:`RigidBody <class_RigidBody>`-based node. If ``body`` is a
:ref:`RigidBody <class_RigidBody>`-based node, then we want to push it when the bullet collides.

To calculate the amount of force applied, we simply take ``COLLISION_FORCE`` and divide it by ``raycast_distance``, then we multiply the whole thing by ``body.mass``. We store this calculation in
a variable called ``collision_force``. This will make collisions over a shorter distance apply move force than those over longer distances, giving a *slightly* more realistic collision response.

We then push the :ref:`RigidBody <class_RigidBody>` using the ``apply_impulse`` function, where the position is a zero Vector3 so the force is applied from the center, and the collision force is the ``collision_force`` variable we calculated.

_________________

Regardless of whether the ``raycast`` variable hit something or not, we then play the pistol shot sound by calling the ``play`` function on the ``pistol_fire_sound`` variable.

Finally, we check to see if the pistol is being held by a VR controller by checking to see if the ``controller`` variable is not equal to ``null``. If it is not equal to ``null``,
we then set the ``rumble`` property of the VR controller to ``0.25``, so there is a slight rumble when the pistol fires.


``picked_up`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""""

This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance <class_MeshInstance>` visible by setting the ``visible`` property to ``true``.

``dropped`` function step-by-step explanation
"""""""""""""""""""""""""""""""""""""""""""""

This function simply makes the ``laser_sight_mesh`` :ref:`MeshInstance <class_MeshInstance>` invisible by setting the ``visible`` property to ``false``.


Pistol finished
^^^^^^^^^^^^^^^

.. image:: img/starter_vr_tutorial_pistol.png


That is all we need to do to have working pistols in the project! Go ahead and run the project. If you climb up the stairs and grab the pistols, you can fire them at the sphere
targets in the scene using the trigger button on the VR controller! If you fire at the targets long enough, they will break into pieces.



Adding a shotgun
----------------

Next let's add a shotgun to the VR project.

Adding a special shotgun :ref:`RigidBody <class_RigidBody>` should be fairly straightforward, as almost everything with the shotgun is the same as the pistol.

Open up ``Shotgun.tscn``, which you can find in the ``Scenes`` folder and take a look at the scene. Almost everything is the same as in ``Pistol.tscn``.
The only thing that is different, beyond name changes, is that instead of a single :ref:`Raycast <class_Raycast>`, there are five :ref:`Raycast <class_Raycast>` nodes.
This is because a shotgun generally fires in a cone shape, so we are going to emulate that effect by having several :ref:`Raycast <class_Raycast>` nodes that will rotate
randomly in a cone shape when the shotgun fires.

Outside of that, everything is more or less the same as ``Pistol.tscn``.

Let's write the code for the shotgun. Select the :ref:`RigidBody <class_RigidBody>` node called ``Shotgun`` and make a new script called ``Shotgun.gd``. Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends VR_Interactable_Rigidbody

    var flash_mesh
    const FLASH_TIME = 0.25
    var flash_timer = 0

    var laser_sight_mesh
    var shotgun_fire_sound

    var raycasts
    const BULLET_DAMAGE = 30
    const COLLISION_FORCE = 4


    func _ready():
        flash_mesh = get_node("Shotgun_Flash")
        flash_mesh.visible = false

        laser_sight_mesh = get_node("LaserSight")
        laser_sight_mesh.visible = false

        raycasts = get_node("Raycasts")
        shotgun_fire_sound = get_node("AudioStreamPlayer3D")


    func _physics_process(delta):
        if flash_timer > 0:
            flash_timer -= delta
            if flash_timer <= 0:
                flash_mesh.visible = false


    func interact():
        if flash_timer <= 0:

            flash_timer = FLASH_TIME
            flash_mesh.visible = true

            for raycast in raycasts.get_children():

                if not raycast is RayCast:
                    continue

                raycast.rotation_degrees = Vector3(90 + rand_range(10, -10), 0, rand_range(10, -10))

                raycast.force_raycast_update()
                if raycast.is_colliding():

                    var body = raycast.get_collider()
                    var direction_vector = raycasts.global_transform.basis.z.normalized()
                    var raycast_distance = raycasts.global_transform.origin.distance_to(raycast.get_collision_point())

                    if body.has_method("damage"):
                        body.damage(BULLET_DAMAGE)

                    if body is RigidBody:
                        var collision_force = (COLLISION_FORCE / raycast_distance) * body.mass
                        body.apply_impulse((raycast.global_transform.origin - body.global_transform.origin).normalized(), direction_vector * collision_force)

            shotgun_fire_sound.play()

            if controller != null:
                controller.rumble = 0.25


    func picked_up():
        laser_sight_mesh.visible = true


    func dropped():
        laser_sight_mesh.visible = false


The majority of this code is exactly the same as the code for the pistol with just a few *minor* changes that are primarily just different names.
Due to how similar these scripts are, let's just focus on the changes.

Explaining the shotgun code
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Like with the pistol, the shotgun extends ``VR_Interactable_Rigidbody`` so the VR controllers know that this object can be interacted with and what functions are
available.

There is only one new class variable:

* ``raycasts``: A variable to hold the node that has all of the :ref:`Raycast <class_Raycast>` nodes as its children.

The new class variable replaces the ``raycast`` variable from ``Pistol.gd``, because with the shotgun we need to process multiple :ref:`Raycast <class_Raycast>` nodes
instead of just one. All of the other class variables are the same as ``Pistol.gd`` and function the same way, some just are renamed to be non-pistol specific.

``interact`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""

The interact function first checks to see if the shotgun's muzzle flash is invisible by checking to see if ``flash_timer`` is less than or equal to zero. We do this so we
can limit the rate of fire of the shotgun to the length of time the muzzle flash is visible, which is a simple solution for limiting how fast the player can fire.

If ``flash_timer`` is zero or less, we then set ``flash_timer`` to ``FLASH_TIME`` so there is a delay before the shotgun can fire again. After that we set ``flash_mesh.visible``
to ``true`` so the muzzle flash at the end of the shotgun is visible while ``flash_timer`` is more than zero.

Next we call the ``force_raycast_update`` function on the :ref:`Raycast <class_Raycast>` node in ``raycast`` so that it gets the latest collision info from the physics world.
We then check if the ``raycast`` hit something by checking if the ``is_colliding`` function is equal to ``true``.

Next we go through each of the child nodes of the ``raycasts`` variable using a for loop. This way the code will go through each of the :ref:`Raycast <class_Raycast>` nodes
that are children of the ``raycasts`` variable.

_________________

For each node, we check to see if ``raycast`` is *not* a :ref:`Raycast <class_Raycast>` node. If the node is not a :ref:`Raycast <class_Raycast>` node, we simply use ``continue`` to skip it.

Next we rotate the ``raycast`` node randomly around a small ``10`` degrees cone by settings the ``rotation_degrees`` variable of the ``raycast`` to a Vector3 where the X and Z axis
are a random number from ``-10`` to ``10``. This random number is selected using the ``rand_range`` function.

Then we call the ``force_raycast_update`` function on the :ref:`Raycast <class_Raycast>` node in ``raycast`` so that it gets the latest collision info from the physics world.
We then check if the ``raycast`` hit something by checking if the ``is_colliding`` function is equal to ``true``.

The rest of the code is exactly the same, but this process is repeated for each :ref:`Raycast <class_Raycast>` node that is a child of the ``raycasts`` variable.

_________________

If the ``raycast`` hit something, then we get the :ref:`PhysicsBody <class_PhysicsBody>` it collided with through the ``get_collider`` function. We assign the
hit :ref:`PhysicsBody <class_PhysicsBody>` to a variable called ``body``.

We then get the direction of the raycast by getting it's positive ``Z`` directional axis from the :ref:`Basis <class_Basis>` on the ``raycast`` node's ``global_transform``.
This will give us the direction the raycast is pointing on the Z axis, which is the same direction as the blue arrow on the :ref:`Spatial <class_Spatial>` gizmo when
``Local space mode`` is enabled in the Godot editor. We store this direction in a variable called ``direction_vector``.

Next we get the distance from the raycast origin to the raycast collision point by getting the distance from the global position, ``global_transform.origin`` of the ``raycast``
node to the collision point of the raycast, ``raycast.get_collision_point``, using the ``distance_to`` function. This will give us the distance the :ref:`Raycast <class_Raycast>`
traveled before it collided, which we store in a variable called ``raycast_distance``.

Then the code checks if the :ref:`PhysicsBody <class_PhysicsBody>`, ``body``, has a function/method called ``damage`` using the ``has_method`` function. If the :ref:`PhysicsBody <class_PhysicsBody>`
has a function/method called ``damage``, then we call the ``damage`` function and pass ``BULLET_DAMAGE`` so it takes damage from the bullet colliding into it.

Regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` has a ``damage`` function, we then check to see if ``body`` is a :ref:`RigidBody <class_RigidBody>`-based node. If ``body`` is a
:ref:`RigidBody <class_RigidBody>`-based node, then we want to push it when the bullet collides.

To calculate the amount of force applied, we simply take ``COLLISION_FORCE`` and divide it by ``raycast_distance``, then we multiply the whole thing by ``body.mass``. We store this calculation in
a variable called ``collision_force``. This will make collisions over a shorter distance apply move force than those over longer distances, giving a *slightly* more realistic collision response.

We then push the :ref:`RigidBody <class_RigidBody>` using the ``apply_impulse`` function, where the position is a zero Vector3 so the force is applied from the center,
and the collision force is the ``collision_force`` variable we calculated.

_________________

Once all of the :ref:`Raycast <class_Raycast>`\s in the ``raycast`` variable have been iterated over, we then play the shotgun shot sound by calling the ``play`` function on the ``shotgun_fire_sound`` variable.

Finally, we check to see if the shotgun is being held by a VR controller by checking to see if the ``controller`` variable is not equal to ``null``. If it is not equal to ``null``,
we then set the ``rumble`` property of the VR controller to ``0.25``, so there is a slight rumble when the shotgun fires.

Shotgun finished
^^^^^^^^^^^^^^^^

Everything else is exactly the same as the pistol, with at most just some simple name changes.

Now the shotgun is finished! You can find the shotgun in the sample scene by looking around the back of one of the walls (not in the building though!).



Adding a bomb
-------------

Okay, let's add a different special :ref:`RigidBody <class_RigidBody>`. Instead of adding something that shoots, let's add something we can throw - a bomb!

Open up ``Bomb.tscn``, which is in the ``Scenes`` folder.

The root node is a :ref:`RigidBody <class_RigidBody>` node that we'll be extending to use ``VR_Interactable_Rigidbody``, which has a :ref:`CollisionShape <class_CollisionShape>`
like the other special :ref:`RigidBody <class_RigidBody>` nodes we've made so far. Likewise, there is a :ref:`MeshInstance <class_MeshInstance>` called ``Bomb`` that is used to
display the mesh for the bomb.

Then we have an :ref:`Area <class_Area>` node simply called ``Area`` that has a large :ref:`CollisionShape <class_CollisionShape>` as its child. We'll use this :ref:`Area <class_Area>`
node to effect anything within it when the bomb explodes. Essentially, this :ref:`Area <class_Area>` node will be the blast radius for the bomb.

There is also a couple :ref:`Particles <class_Particles>` nodes. One of the :ref:`Particles <class_Particles>` nodes are for the smoke coming out of the bomb's fuse, while another
is for the explosion. You can take a look at the :ref:`ParticlesMaterial <class_ParticlesMaterial>` resources, which define how the particles work, if you want. We will not be covering
how the particles work in this tutorial due to it being outside of the scope of this tutorial.

There is one thing with the :ref:`Particles <class_Particles>` nodes that we need to make note of. If you select the ``Explosion_Particles`` node, you'll find that its ``lifetime`` property
is set to ``0.75`` and that the ``one shot`` checkbox is enabled. This means that the particles will only play once, and the particles will last for ``0.75`` seconds.
We'll need to know this so we can time the removal of the bomb with the end of the explosion :ref:`Particles <class_Particles>`.

Let's write the code for the bomb. Select the ``Bomb`` :ref:`RigidBody <class_RigidBody>` node and make a new script called ``Bomb.gd``. Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends VR_Interactable_Rigidbody

    var bomb_mesh

    const FUSE_TIME = 4
    var fuse_timer = 0

    var explosion_area
    const EXPLOSION_DAMAGE = 100
    const EXPLOSION_TIME = 0.75
    var explosion_timer = 0
    var exploded = false

    const COLLISION_FORCE = 8

    var fuse_particles
    var explosion_particles
    var explosion_sound


    func _ready():

        bomb_mesh = get_node("Bomb")
        explosion_area = get_node("Area")
        fuse_particles = get_node("Fuse_Particles")
        explosion_particles = get_node("Explosion_Particles")
        explosion_sound = get_node("AudioStreamPlayer3D")

        set_physics_process(false)


    func _physics_process(delta):

        if fuse_timer < FUSE_TIME:

            fuse_timer += delta

            if fuse_timer >= FUSE_TIME:

                fuse_particles.emitting = false

                explosion_particles.one_shot = true
                explosion_particles.emitting = true

                bomb_mesh.visible = false

                collision_layer = 0
                collision_mask = 0
                mode = RigidBody.MODE_STATIC

                for body in explosion_area.get_overlapping_bodies():
                    if body == self:
                        pass
                    else:
                        if body.has_method("damage"):
                            body.damage(EXPLOSION_DAMAGE)

                        if body is RigidBody:
                            var direction_vector = body.global_transform.origin - global_transform.origin
                            var bomb_distance = direction_vector.length()
                            var collision_force = (COLLISION_FORCE / bomb_distance) * body.mass
                            body.apply_impulse(Vector3.ZERO, direction_vector.normalized() * collision_force)

                exploded = true
                explosion_sound.play()


        if exploded:

            explosion_timer += delta

            if explosion_timer >= EXPLOSION_TIME:

                explosion_area.monitoring = false

                if controller != null:
                    controller.held_object = null
                    controller.hand_mesh.visible = true

                    if controller.grab_mode == "RAYCAST":
                        controller.grab_raycast.visible = true

                queue_free()


    func interact():
        set_physics_process(true)

        fuse_particles.emitting = true


Let's go over how this script works.


Explaining the bomb code
^^^^^^^^^^^^^^^^^^^^^^^^

Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the bomb extends ``VR_Interactable_Rigidbody`` so the VR controllers know this object can be interacted with and
that the functions defined defined in ``VR_Interactable_Rigidbody`` can be called when this object is held by a VR controller.

Next, let's look at the class variables:

* ``bomb_mesh``: A variable to hold the :ref:`MeshInstance <class_MeshInstance>` node that is used for the non-exploded bomb.
* ``FUSE_TIME``: A constant to define how long the fuse will 'burn' before the bomb explodes
* ``fuse_timer``: A variable to hold the length of time that has passed since the bomb's fuse has started to burn.
* ``explosion_area``: A variable to hold the :ref:`Area <class_Area>` node used to detect objects within the bomb's explosion.
* ``EXPLOSION_DAMAGE``: A constant to define how much damage is applied with the bomb explodes.
* ``EXPLOSION_TIME``: A constant to define how long the bomb will last in the scene after it explodes. This value should be the same as the ``lifetime`` property of the explosion :ref:`Particles <class_Particles>` node.
* ``explosion_timer`` A variable to hold the length of time that has passed since the bomb exploded.
* ``exploded``: A variable to hold whether the bomb has exploded or not.
* ``COLLISION_FORCE``: A constant that defines the amount of force that is applied to :ref:`RigidBody <class_RigidBody>` nodes when the bomb explodes.
* ``fuse_particles``: A variable to hold a reference to the :ref:`Particles <class_Particles>` node used for the bomb's fuse.
* ``explosion_particles``: A variable to hold a reference to the :ref:`Particles <class_Particles>` node used for the bomb's explosion.
* ``explosion_sound``: A variable to hold a reference to the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used for the explosion sound.


``_ready`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""

The ``_ready`` function first gets all of the nodes from the bomb scene and assigns them to their respective class variables for later use.

Then we call ``set_physics_process`` and pass ``false`` so ``_physics_process`` is not executed. We do this because the code in ``_physics_process`` will start burning
the fuse and exploding the bomb, which we only want to do when the user interacts with the bomb. If we did not disable ``_physics_process``, the bomb's fuse would start
before the user has a chance to get to the bomb.


``_physics_process`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""

The ``_physics_process`` function first checks to see if ``fuse_timer`` is less than ``FUSE_TIME``. If it is, then the bomb's fuse is still burning.

If the bomb's fuse is still burning, we then add time, ``delta``, to the ``fuse_timer`` variable. We then check to see if ``fuse_timer`` is more than or equal to ``FUSE_TIME``
now that we have added ``delta`` to it. If ``fuse_timer`` is more than or equal to ``FUSE_TIME``, then the fuse has just finished and we need to explode the bomb.

To explode the bomb, we first stop emitting particles for the fuse by setting ``emitting`` to ``false`` on ``fuse_particles``. We then tell the explosion :ref:`Particles <class_Particles>`
node, ``explosion_particles``, to emit all of its particle in a single shot by setting ``one_shot`` to ``true``. After that, we set ``emitting`` to ``true`` on ``explosion_particles`` so it looks
like the bomb has exploded. To help make it look like the bomb exploded, we hide the bomb :ref:`MeshInstance <class_MeshInstance>` node by setting ``bomb_mesh.visible`` to ``false``.

To keep the bomb from colliding with other objects in the physics world, we set the ``collision_layer`` and ``collision_mask`` properties of the bomb to ``0``. We also
change the :ref:`RigidBody <class_RigidBody>` mode to ``MODE_STATIC`` so the bomb :ref:`RigidBody <class_RigidBody>` does not move.

Then we need to get all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes within the ``explosion_area`` node. To do this, we use the ``get_overlapping_bodies`` in a for loop. The ``get_overlapping_bodies``
function will return an array of :ref:`PhysicsBody <class_PhysicsBody>` nodes within the :ref:`Area <class_Area>` node, which is exactly what we are looking for.

_________________

For each :ref:`PhysicsBody <class_PhysicsBody>` node, which we store in a variable called ``body``, we check to see if it is equal to ``self``. We do this so the bomb does not accidentally explode
itself, as the ``explosion_area`` could potentially detect the ``Bomb`` :ref:`RigidBody <class_RigidBody>` as a PhysicsBody within the explosion area.

If the :ref:`PhysicsBody <class_PhysicsBody>` node, ``body``, is not the bomb, then we first check to see if the :ref:`PhysicsBody <class_PhysicsBody>` node has a function
called ``damage``. If the :ref:`PhysicsBody <class_PhysicsBody>` node has a function called ``damage``, we call it and pass ``EXPLOSION_DAMAGE`` to it so it takes damage from the explosion.

Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` node is a :ref:`RigidBody <class_RigidBody>`. If ``body`` is a :ref:`RigidBody <class_RigidBody>`, we want to move it
when the bomb explodes.

To move the :ref:`RigidBody <class_RigidBody>` node when the bomb explodes, we first need to calculate the direction from the bomb to the :ref:`RigidBody <class_RigidBody>` node. To do this
we subtract the global position of the bomb, ``global_transform.origin`` from the global position of the :ref:`RigidBody <class_RigidBody>`. This will give us a :ref:`Vector3 <class_Vector3>`
that points from the bomb to the :ref:`RigidBody <class_RigidBody>` node. We store this :ref:`Vector3 <class_Vector3>` in a variable called ``direction_vector``.

We then calculate the distance the :ref:`RigidBody <class_RigidBody>` is from the bomb by using the ``length`` function on ``direction_vector``. We store the distance in a variable called
``bomb_distance``.

We then calculate the amount of force the bomb will be applied to the :ref:`RigidBody <class_RigidBody>` node when the bomb explodes by dividing ``COLLISION_FORCE`` by
``bomb_distance``, and multiplying that by ``collision_force``. This will make it so if the :ref:`RigidBody <class_RigidBody>` node is closer to the bomb, it will be pushed farther.

Finally, we push the :ref:`RigidBody <class_RigidBody>` node using the ``apply_impulse`` function, with a :ref:`Vector3 <class_Vector3>` position of zero and ``collision_force``
multiplied by ``direction_vector.normalized`` as the force. This will send the :ref:`RigidBody <class_RigidBody>` node flying when the bomb explodes.

_________________

After we have looped through all of the :ref:`PhysicsBody <class_PhysicsBody>` nodes within the ``explosion_area``, we set the ``exploded`` variable to ``true`` so the code knows the bomb
exploded and call ``play`` on ``explosion_sound`` so the sound of an explosion is played.

_________________

Alright, the next section of code starts by first checking if ``exploded`` is equal to ``true``.

If ``exploded`` is equal to ``true``, then that means the bomb is waiting for the explosion particles to finish before it frees/destroys itself. We add time, ``delta``, to
``explosion_timer`` so we can track how long it has been since the bomb has exploded.

If ``explosion_timer`` is greater than or equal to ``EXPLOSION_TIME`` after we added ``delta``, then the explosion timer just finished.

If the explosion timer just finished, we set ``explosion_area.monitoring`` to ``false``. The reason we do this is because there was a bug that would print an error when you
freed/deleted an :ref:`Area <class_Area>` node when the ``monitoring`` property was true. To make sure this doesn't happen, we simply set ``monitoring`` to false on ``explosion_area``.

Next we check to see if the bomb is being held by a VR controller by checking to see if the ``controller`` variable is not equal to ``null``. If the bomb is being held by a VR controller,
we set the ``held_object`` property of the VR controller, ``controller``, to ``null``. Because the VR controller is no longer holding anything, we make the VR controller's hand mesh
visible by setting ``controller.hand_mesh.visible`` to ``true``. Then we check to see if the VR controller grab mode is ``RAYCAST``, and if it is we set ``controller.grab_raycast.visible`` to
``true`` so the 'laser sight' for the grab raycast is visible.

Finally, regardless if the bomb is being held by a VR controller or not, we call ``queue_free`` so the bomb scene is freed/removed from the scene.

``interact`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""

First the ``interact`` function calls ``set_physics_process`` and passes ``true`` so the code in ``_physics_process`` starts executing. This will start the bomb's fuse and
eventually lead to the bomb exploding.

Finally, we start the fuse particles by setting ``fuse_particles.visible`` to ``true``.


Bomb finished
^^^^^^^^^^^^^

Now the bomb is ready to go! You can find the bombs in the orange building.

Because of how we are calculating the VR controller's velocity, it is easiest to throw the bombs using a thrusting-like motion instead of a more natural throwing-like motion.
The smooth curve of a throwing-like motion is harder to track with the code we are using for calculating the velocity of the VR controllers, so it does not always work correctly
and can lead inaccurately calculated velocities.



Adding a sword
--------------

Let's add one last special :ref:`RigidBody <class_RigidBody>`-based node that can destroy targets. Let's add a sword so we can slice through the targets!

Open up ``Sword.tscn``, which you can find in the ``Scenes`` folder.

There is not a whole lot going on here. All of the child nodes of the root ``Sword`` :ref:`RigidBody <class_RigidBody>` node are rotated to they are positioned correctly when the
VR controller picks them up, there is a :ref:`MeshInstance <class_MeshInstance>` node for displaying the sword, and there is an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>`
node that holds a sound for the sword colliding with something.

There is one thing that is slightly different though. There is a :ref:`KinematicBody <class_KinematicBody>` node called ``Damage_Body``. If you take a look at it, you'll find that it
is not on any collision layers, and is instead only on a single collision mask. This is so the :ref:`KinematicBody <class_KinematicBody>` will not effect other
:ref:`PhysicsBody <class_PhysicsBody>` nodes in the scene, but it will still be effected by :ref:`PhysicsBody <class_PhysicsBody>` nodes.

We are going to use the ``Damage_Body`` :ref:`KinematicBody <class_KinematicBody>` node to detect the collision point and normal when the sword collides with something in the scene.

.. tip:: While this is perhaps not the best way of getting the collision information from a performance point of view, it does give us a lot of information we can use for post-processing!
         Using a :ref:`KinematicBody <class_KinematicBody>` this way means we can detect exactly where the sword collided with other :ref:`PhysicsBody <class_PhysicsBody>` nodes.

That is really the only thing note worthy about the sword scene. Select the ``Sword`` :ref:`RigidBody <class_RigidBody>` node and make a new script called ``Sword.gd``.
Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends VR_Interactable_Rigidbody

    const SWORD_DAMAGE = 2

    const COLLISION_FORCE = 0.15

    var damage_body = null


    func _ready():
        damage_body = get_node("Damage_Body")
        damage_body.add_collision_exception_with(self)
        sword_noise = get_node("AudioStreamPlayer3D")


    func _physics_process(_delta):

        var collision_results = damage_body.move_and_collide(Vector3.ZERO, true, true, true);

        if (collision_results != null):
            if collision_results.collider.has_method("damage"):
                collision_results.collider.damage(SWORD_DAMAGE)

            if collision_results.collider is RigidBody:
                if controller == null:
                    collision_results.collider.apply_impulse(
                        collision_results.position,
                        collision_results.normal * linear_velocity * COLLISION_FORCE)
                else:
                    collision_results.collider.apply_impulse(
                        collision_results.position,
                        collision_results.normal * controller.controller_velocity * COLLISION_FORCE)

            sword_noise.play()

Let's go over how this script works!


Explaining the sword code
^^^^^^^^^^^^^^^^^^^^^^^^^

Like with the other special :ref:`RigidBody <class_RigidBody>` nodes, the sword extends ``VR_Interactable_Rigidbody`` so the VR controllers know this object can be interacted with and
that the functions defined defined in ``VR_Interactable_Rigidbody`` can be called when this object is held by a VR controller.

Next, let's look at the class variables:

* ``SWORD_DAMAGE``: A constant to define the amount of damage the sword does. This damage is applied to every object in the sword on every ``_physics_process`` call
* ``COLLISION_FORCE``: A constant that defines the amount of force applied to :ref:`RigidBody <class_RigidBody>` nodes when the sword collides with a :ref:`PhysicsBody <class_PhysicsBody>`.
* ``damage_body``: A variable to hold the :ref:`KinematicBody <class_KinematicBody>` node used to detect whether the sword is stabbing a :ref:`PhysicsBody <class_PhysicsBody>` node or not.
* ``sword_noise``: A variable to hold the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node used to play a sound when the sword collides with something.


``_ready`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""

All we are doing in the ``_ready`` function is getting the ``Damage_Body`` :ref:`KinematicBody <class_KinematicBody>` node and assigning it to ``damage_body``.
Because we do not want the sword to detect a collision with the root :ref:`RigidBody <class_RigidBody>` node of the sword, we call
``add_collision_exception_with`` on ``damage_body`` and pass ``self`` so the sword will not be detected.

Finally, we get the :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node for the sword collision sound and apply it to the ``sword_noise`` variable.


``_physics_process`` function step-by-step explanation
""""""""""""""""""""""""""""""""""""""""""""""""""""""

First we need to determine whether the sword is colliding with something or not. To do this, we use the ``move_and_collide`` function of the ``damage_body`` node.
Unlike how ``move_and_collide`` is normally used, we are not passing a velocity and instead are passing an empty :ref:`Vector3 <class_Vector3>`. Because we do not
want the ``damage_body`` node to move, we set the ``test_only`` argument (the fourth argument) as ``true`` so the :ref:`KinematicBody <class_KinematicBody>` generates
collision info without actually causing any collisions within the collision world.

The ``move_and_collide`` function will return a :ref:`KinematicCollision <class_KinematicCollision>` class that has all of the information we need for detecting collisions
on the sword. We assign the return value of ``move_and_collide`` to a variable called ``collision_results``.

Next we check to see if ``collision_results`` is not equal to ``null``. If ``collision_results`` is not equal to ``null``, then we know that the sword has collided with something.

We then check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword collided with has a function/method called ``damage`` using the ``has_method`` function. If the
:ref:`PhysicsBody <class_PhysicsBody>` has a function called ``damage_body``, we call it and pass the amount of damage the sword does, ``SWORD_DAMAGE``, to it.

Next we check to see if the :ref:`PhysicsBody <class_PhysicsBody>` the sword collided with is a :ref:`RigidBody <class_RigidBody>`. If what the sword collided with is a
:ref:`RigidBody <class_RigidBody>` node, we then check to see if the sword is being held by a VR controller or not by checking to see if ``controller`` is equal to ``null``.

If the sword is not being held by a VR controller, ``controller`` is equal to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the sword collided with using
the ``apply_impulse`` function. For the ``position`` of the ``apply_impulse`` function, we use ``collision_position`` variable stored within the :ref:`KinematicCollision <class_KinematicCollision>`
class in ``collision_results``. For the ``velocity`` of the ``apply_impulse`` function, we use the ``collision_normal`` multiplied by the ``linear_velocity`` of the sword's
:ref:`RigidBody <class_RigidBody>` node multiplied by ``COLLISION_FORCE``.

If the sword is being held by a VR controller, ``controller`` is not equal to ``null``, then we move the :ref:`RigidBody <class_RigidBody>` node the sword collided with using
the ``apply_impulse`` function. For the ``position`` of the ``apply_impulse`` function, we use ``collision_position`` variable stored within the :ref:`KinematicCollision <class_KinematicCollision>`
class in ``collision_results``. For the ``velocity`` of the ``apply_impulse`` function, we use the ``collision_normal`` multiplied by the VR controller's velocity multiplied by ``COLLISION_FORCE``.

Finally, regardless of whether the :ref:`PhysicsBody <class_PhysicsBody>` is a :ref:`RigidBody <class_RigidBody>` or not, we play the sound of the sword colliding with
something by calling ``play`` on ``sword_noise``.


Sword finished
^^^^^^^^^^^^^^

.. image:: img/starter_vr_tutorial_sword.png

With that done, you can now slice through the targets! You can find the sword in the corner in between the shotgun and the pistol.



Updating the target UI
----------------------

Let's update the UI as the sphere targets are destroyed.

Open up ``Main_VR_GUI.tscn``, which you can find in the ``Scenes`` folder.
Feel free to look at how the scene is setup if you want, but in an effort to keep this tutorial from becoming too long, we will not be covering the scene setup in this tutorial.

Expand the ``GUI`` :ref:`Viewport <class_Viewport>` node and then select the ``Base_Control`` node. Add a new script called ``Base_Control.gd``, and add the following:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends Control

    var sphere_count_label

    func _ready():
        sphere_count_label = get_node("Label_Sphere_Count")

        get_tree().root.get_node("Game").sphere_ui = self


    func update_ui(sphere_count):
        if sphere_count > 0:
            sphere_count_label.text = str(sphere_count) + " Spheres remaining"
        else:
            sphere_count_label.text = "No spheres remaining! Good job!"

Let's go over how this script works real quick.

First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how many spheres are left and assign it to the ``sphere_count_label`` class variable.
Next, we get ``Game.gd`` by using ``get_tree().root`` and assign ``sphere_ui`` to this script.

In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If there is at least one sphere remaining, we change the text to show how many spheres are still
left in the world. If there are no more spheres remaining, we change the text and congratulate the player.



Adding the final special RigidBody
----------------------------------

Finally, before we finish this tutorial, let's add a way to reset the game while in VR.

Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the ``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script called ``Reset_Box.gd``.
Add the following code:

.. tabs::
 .. code-tab:: gdscript GDScript

    extends VR_Interactable_Rigidbody

    var start_transform

    var reset_timer = 0
    const RESET_TIME = 10
    const RESET_MIN_DISTANCE = 1


    func _ready():
        start_transform = global_transform


    func _physics_process(delta):
        if start_transform.origin.distance_to(global_transform.origin) >= RESET_MIN_DISTANCE:
            reset_timer += delta
            if reset_timer >= RESET_TIME:
                global_transform = start_transform
                reset_timer = 0


    func interact():
        # (Ignore the unused variable warning)
        # warning-ignore:return_value_discarded
        get_tree().change_scene("res://Game.tscn")


    func dropped():
        global_transform = start_transform
        reset_timer = 0


Let's quickly go over how this script works.


Explaining the reset box code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Like with the other special :ref:`RigidBody <class_RigidBody>`-based objects we've created, the reset box extends ``VR_Interactable_Rigidbody``.

The ``start_transform`` class variable will store the global transform of the reset box when the game starts, the ``reset_timer`` class variable will hold the length of
time that has passed since the reset box's position has moved, the ``RESET_TIME`` constant defines the length of time the reset box has to wait before being reset, and
the ``RESET_MIN_DISTANCE`` constant defines how far the reset box has to be away from it's initial position before the reset timer starts.

In the ``_ready`` function all we are doing is storing the ``global_transform`` of the reset position when the scene starts. This is so we can reset the position, rotation, and scale
of the reset box object to this initial transform when enough time has passed.

In the ``_physics_process`` function, the code checks to see if the reset box's initial position to the reset box's current position is farther than ``RESET_MIN_DISTANCE``. If it is
farther, then it starts adding time, ``delta``, to ``reset_timer``. Once ``reset_timer`` is more than or equal to ``RESET_TIME``, we reset the ``global_transform`` to the ``start_transform``
so the reset box is back in its initial position. We then set ``reset_timer`` to ``0``.

The ``interact`` function simply reloads the ``Game.tscn`` scene using ``get_tree().change_scene``. This will reload the game scene, resetting everything.

Finally, the ``dropped`` function resets the ``global_transform`` to the initial transform in ``start_transform`` so the reset box has its initial position/rotation. Then ``reset_timer`` is
set to ``0`` so the timer is reset.


Reset box finished
^^^^^^^^^^^^^^^^^^

With that done, when you grab and interact with the reset box, the entire scene will reset/restart and you can destroy all the targets again!

.. note:: Resetting the scene abruptly without any sort of transition can lead to discomfort in VR.



Final notes
-----------

.. image:: img/starter_vr_tutorial_pistol.png

Whew! That was a lot of work.

Now you have a fully working VR project with multiple different types of special :ref:`RigidBody <class_RigidBody>`-based nodes that can be used and extended. Hopefully this will
help serve as an introduction to making fully-featured VR games in Godot! The code and concepts detailed in this tutorial can be expanded on to make puzzle games, action games,
story-based games, and more!

.. warning:: You can download the finished project for this tutorial series on the `OpenVR GitHub repository <https://github.com/GodotVR/godot_openvr_fps>`__, under the releases tab!


===================================================
/. ./development/compiling/index.rst
===================================================

Compiling
=========

.. toctree::
   :maxdepth: 1
   :name: toc-devel-compiling

   getting_source
   introduction_to_the_buildsystem
   compiling_for_windows
   compiling_for_x11
   compiling_for_osx
   compiling_for_android
   compiling_for_ios
   cross-compiling_for_ios_on_linux
   compiling_for_uwp
   compiling_for_web
   compiling_with_mono
   optimizing_for_size
   compiling_with_script_encryption_key


===================================================
/. ./development/compiling/getting_source.rst
===================================================

.. _doc_getting_source:

Getting the source
==================

.. highlight:: shell

Downloading the Godot source code
---------------------------------

Before :ref:`getting into the SCons build system <doc_introduction_to_the_buildsystem>`
and compiling Godot, you need to actually download the Godot source code.

The source code is available on `GitHub <https://github.com/godotengine/godot>`__
and while you can manually download it via the website, in general you want to
do it via the ``git`` version control system.

If you are compiling in order to make contributions or pull requests, you should
follow the instructions from the :ref:`Pull Request workflow <doc_pr_workflow>`.

If you don't know much about ``git`` yet, there are a great number of
`tutorials <https://git-scm.com/book>`__ available on various websites.

In general, you need to install ``git`` and/or one of the various GUI clients.

Afterwards, to get the latest development version of the Godot source code
(the unstable ``master`` branch), you can use ``git clone``.

If you are using the ``git`` command line client, this is done by entering
the following in a terminal:

::

    git clone https://github.com/godotengine/godot.git
    # You can add the --depth 1 argument to omit the commit history.
    # Faster, but not all Git operations (like blame) will work.

For any stable release, visit the `release page <https://github.com/godotengine/godot/releases>`__
and click on the link for the release you want.
You can then download and extract the source from the download link on the page.

With ``git``, you can also clone a stable release by specifying its branch or tag
after the ``--branch`` (or just ``-b``) argument::

    # Clone the continuously maintained stable branch (`3.x` as of writing).
    git clone https://github.com/godotengine/godot.git -b 3.x

    # Clone the `3.2.3-stable` tag. This is a fixed revision that will never change.
    git clone https://github.com/godotengine/godot.git -b 3.2.3-stable

There are also generally branches besides ``master`` for each major version.

After downloading the Godot source code,
you can :ref:`continue to compiling Godot <doc_introduction_to_the_buildsystem>`.


===================================================
/. ./development/compiling/introduction_to_the_buildsystem.rst
===================================================

.. _doc_introduction_to_the_buildsystem:

Introduction to the buildsystem
===============================

.. highlight:: shell

SCons
-----

Godot uses `SCons <https://www.scons.org/>`__ to build. We love it, we are
not changing it for anything else. We are not even sure other build
systems are up to the task of building Godot. We constantly get requests
to move the build system to CMake, or Visual Studio, but this is not
going to happen. There are many reasons why we have chosen SCons over
other alternatives, for example:

-  Godot can be compiled for a dozen different platforms: all PC
   platforms, all mobile platforms, many consoles, and WebAssembly.
-  Developers often need to compile for several of the platforms **at
   the same time**, or even different targets of the same platform. They
   can't afford reconfiguring and rebuilding the project each time.
   SCons can do this with no sweat, without breaking the builds.
-  SCons will *never* break a build no matter how many changes,
   configurations, additions, removals etc. You have more chances to die
   struck by lightning than needing to clean and rebuild in SCons.
-  Godot build process is not simple. Several files are generated by
   code (binders), others are parsed (shaders), and others need to offer
   customization (plugins). This requires complex logic which is easier
   to write in an actual programming language (like Python) rather than
   using a mostly macro-based language only meant for building.
-  Godot build process makes heavy use of cross-compiling tools. Each
   platform has a specific detection process, and all these must be
   handled as specific cases with special code written for each.

So, please try to keep an open mind and get at least a little familiar with it
if you are planning to build Godot yourself.

Setup
-----

Please refer to the documentation for :ref:`doc_compiling_for_android`,
:ref:`doc_compiling_for_ios`, :ref:`doc_compiling_for_osx`,
:ref:`doc_compiling_for_uwp`, :ref:`doc_compiling_for_web`,
:ref:`doc_compiling_for_windows` and :ref:`doc_compiling_for_x11`.

Note that for **Windows/Visual Studio**, you need to use ``x86_x64 Cross Tools
Command Prompt for VS 2017`` or similar, depending on your install, instead of
the standard Windows command prompt to enter the commands below.

Platform selection
------------------

Godot's build system will begin by detecting the platforms it can build
for. If not detected, the platform will simply not appear on the list of
available platforms. The build requirements for each platform are
described in the rest of this tutorial section.

SCons is invoked by just calling ``scons``. If no platform is specified,
SCons will detect the target platform automatically based on the host platform.
It will then start building for the target platform right away.

To list the available target platforms, use ``scons platform=list``::

    scons platform=list
    scons: Reading SConscript files ...
    The following platforms are available:

        android
        javascript
        server
        windows
        x11

    Please run SCons again and select a valid platform: platform=<string>

To build for a platform (for example, x11), run with the ``platform=`` (or
``p=`` to make it short) argument:

::

    scons platform=x11

This will start the build process, which will take a while. By default, Godot's
SCons setup is configured to use all CPU threads but one (to keep the system
responsive during compilation). If you want to adjust how many CPU threads SCons
will use, use the ``-j <threads>`` parameter to specify how many threads will be
used for the build.

Example for using 4 threads:

::

    scons platform=x11 -j 4

Resulting binary
----------------

The resulting binaries will be placed in the ``bin/`` subdirectory,
generally with this naming convention::

    godot.<platform>.[opt].[tools/debug].<architecture>[extension]

For the previous build attempt, the result would look like this::

    ls bin
    bin/godot.x11.tools.64

This means that the binary is for X11, is not optimized, has tools (the
whole editor) compiled in, and is meant for 64 bits.

A Windows binary with the same configuration will look like this:

.. code-block:: console

    C:\godot> dir bin/
    godot.windows.tools.64.exe

Copy that binary to any location you like, as it contains the project manager,
editor and all means to execute the game. However, it lacks the data to export
it to the different platforms. For that the export templates are needed (which
can be either downloaded from `godotengine.org <https://godotengine.org/>`__, or
you can build them yourself).

Aside from that, there are a few standard options that can be set in all
build targets, and which will be explained below.

.. _doc_introduction_to_the_buildsystem_tools:

Tools
-----

Tools are enabled by default in all PC targets (Linux, Windows, macOS),
disabled for everything else. Disabling tools produces a binary that can
run projects but that does not include the editor or the project
manager.

::

    scons platform=<platform> tools=yes/no

.. _doc_introduction_to_the_buildsystem_target:

Target
------

Target controls optimization and debug flags. Each mode means:

-  **debug**: Build with C++ debugging symbols, runtime checks (performs
   checks and reports error) and none to little optimization.
-  **release_debug**: Build without C++ debugging symbols and
   optimization, but keep the runtime checks (performs checks and
   reports errors). Official editor binaries use this configuration.
-  **release**: Build without symbols, with optimization and with little
   to no runtime checks. This target can't be used together with
   ``tools=yes``, as the editor requires some debug functionality and run-time
   checks to run.

::

    scons platform=<platform> target=debug/release_debug/release

This flag appends the ``.debug`` suffix (for debug), or ``.tools`` (for debug
with tools enabled). When optimization is enabled (release), it appends
the ``.opt`` suffix.

Bits
----

Bits is meant to control the CPU or OS version intended to run the
binaries. It is focused mostly on desktop platforms and ignored everywhere
else.

-  **32**: Build binaries for 32-bit platforms.
-  **64**: Build binaries for 64-bit platforms.
-  **default**: Build for the architecture that matches the host platform.

::

    scons platform=<platform> bits=default/32/64

This flag appends ``.32`` or ``.64`` suffixes to resulting binaries when
relevant. If ``bits=default`` is used, the suffix will match the detected
architecture.

.. _doc_buildsystem_custom_modules:

Custom modules
--------------

It's possible to compile modules residing outside of Godot's directory
tree, along with the built-in modules.

A ``custom_modules`` build option can be passed to the command line before
compiling. The option represents a comma-separated list of directory paths
containing a collection of independent C++ modules that can be seen as C++
packages, just like the built-in ``modules/`` directory.

For instance, it's possible to provide both relative, absolute, and user
directory paths containing such modules:

::

    scons custom_modules="../modules,/abs/path/to/modules,~/src/godot_modules"

.. note::

    If there's any custom module with the exact directory name as a built-in
    module, the engine will only compile the custom one. This logic can be used
    to override built-in module implementations.

.. seealso::

    :ref:`doc_custom_modules_in_c++`

Cleaning generated files
------------------------

Sometimes, you may encounter an error due to generated files being present. You
can remove them by using ``scons --clean <options>``, where ``<options>`` is the
list of build options you've used to build Godot previously.

Alternatively, you can use ``git clean -fixd`` which will clean build artifacts
for all platforms and configurations. Beware, as this will remove all untracked
and ignored files in the repository. Don't run this command if you have
uncommitted work!

Other build options
-------------------

There are several other build options that you can use to configure the
way Godot should be built (compiler, debug options, etc.) as well as the
features to include/disable.

Check the output of ``scons --help`` for details about each option for
the version you are willing to compile.

.. _doc_overriding_build_options:

Overriding the build options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using a file
^^^^^^^^^^^^

The default ``custom.py`` file can be created at the root of the Godot Engine
source to initialize any SCons build options passed via the command line:

.. code-block:: python

    # custom.py

    optimize = "size"
    module_mono_enabled = "yes"
    use_llvm = "yes"
    extra_suffix = "game_title"

You can also disable some of the builtin modules before compiling, saving some
time it takes to build the engine. See :ref:`doc_optimizing_for_size` page for more details.

.. seealso::

    You can use the online
    `Godot build options generator <https://godot-build-options-generator.github.io/>`__
    to generate a ``custom.py`` file containing SCons options.
    You can then save this file and place it at the root of your Godot source directory.

Another custom file can be specified explicitly with the ``profile`` command
line option, both overriding the default build configuration:

.. code-block:: shell

    scons profile=path/to/custom.py

.. note:: Build options set from the file can be overridden by the command line
          options.

It's also possible to override the options conditionally:

.. code-block:: python

    # custom.py

    import version

    # Override options specific for Godot 3.x and 4.x versions.
    if version.major == 3:
        pass
    elif version.major == 4:
        pass

Using the SCONSFLAGS
^^^^^^^^^^^^^^^^^^^^

``SCONSFLAGS`` is an environment variable which is used by the SCons to set the
options automatically without having to supply them via the command line.

For instance, you may want to force a number of CPU threads with the
aforementioned ``-j`` option for all future builds:

.. tabs::
 .. code-tab:: bash Linux/macOS

     export SCONSFLAGS="-j4"

 .. code-tab:: bat Windows (cmd)

     set SCONSFLAGS=-j4

 .. code-tab:: powershell Windows (powershell)

     $env:SCONSFLAGS="-j4"

Export templates
----------------

Official export templates are downloaded from the Godot Engine site:
`godotengine.org <https://godotengine.org/>`__. However, you might want
to build them yourself (in case you want newer ones, you are using custom
modules, or simply don't trust your own shadow).

If you download the official export templates package and unzip it, you
will notice that most files are optimized binaries or packages for each
platform:

.. code-block:: none

    android_debug.apk
    android_release.apk
    webassembly_debug.zip
    webassembly_release.zip
    linux_server_32
    linux_server_64
    linux_x11_32_debug
    linux_x11_32_release
    linux_x11_64_debug
    linux_x11_64_release
    osx.zip
    version.txt
    windows_32_debug.exe
    windows_32_release.exe
    windows_64_debug.exe
    windows_64_release.exe

To create those yourself, follow the instructions detailed for each
platform in this same tutorial section. Each platform explains how to
create its own template.

The ``version.txt`` file should contain the corresponding Godot version
identifier. This file is used to install export templates in a version-specific
directory to avoid conflicts. For instance, if you are building export templates
for Godot 3.1.1, ``version.txt`` should contain ``3.1.1.stable`` on the first
line (and nothing else). This version identifier is based on the ``major``,
``minor``, ``patch`` (if present) and ``status`` lines of the
`version.py file in the Godot Git repository <https://github.com/godotengine/godot/blob/master/version.py>`__.

If you are developing for multiple platforms, macOS is definitely the most
convenient host platform for cross-compilation, since you can cross-compile for
almost every target (except for UWP). Linux and Windows come in second place,
but Linux has the advantage of being the easier platform to set this up.


===================================================
/. ./development/compiling/compiling_for_windows.rst
===================================================

.. _doc_compiling_for_windows:

Compiling for Windows
=====================

.. highlight:: shell

.. seealso::

    This page describes how to compile Windows editor and export template binaries from source.
    If you're looking to export your project to Windows instead, read :ref:`doc_exporting_for_windows`.

Requirements
------------

For compiling under Windows, the following is required:

- `Visual Studio Community <https://www.visualstudio.com/vs/community/>`_,
  version 2017 or later. VS 2019 is recommended.
  **Make sure to read "Installing Visual Studio caveats" below or you
  will have to run/download the installer again.**
- `MinGW-w64 <http://mingw-w64.org/>`__ with GCC can be used as an alternative to
  Visual Studio. Be sure to install/configure it to use the ``posix`` thread model.
- `Python 3.5+ <https://www.python.org/downloads/windows/>`_.
  **Make sure to enable the option to add Python to the ``PATH`` in the installer.**
- `SCons <https://www.scons.org/>`_ build system. Using the latest release is
  recommended, especially for proper support of recent Visual Studio releases.

.. note:: If you have `Scoop <https://scoop.sh/>`_ installed, you can easily
          install MinGW and other dependencies using the following command::

              scoop install gcc python scons make

.. note:: If you have `MSYS2 <https://www.msys2.org/>`_ installed, you can easily
          install MinGW and other dependencies using the following command::

              pacman -S mingw-w64-x86_64-python3-pip mingw-w64-x86_64-gcc \
                  mingw-w64-i686-python3-pip mingw-w64-i686-gcc make

          For each MSYS2 MinGW subsystem, you should then run
          `pip3 install scons` in its shell.

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

Setting up SCons
----------------

To install SCons, open the command prompt and run the following command::

    python -m pip install scons

If you are prompted with the message
``Defaulting to user installation because normal site-packages is not
writeable``, you may have to run that command again using elevated
permissions. Open a new command prompt as an Administrator then run the command
again to ensure that SCons is available from the ``PATH``.

To check whether you have installed Python and SCons correctly, you can
type ``python --version`` and ``scons --version`` into a command prompt
(``cmd.exe``).

If the commands above don't work, make sure to add Python to your ``PATH``
environment variable after installing it, then check again.
You can do so by running the Python installer again and enabling the option
to add Python to the ``PATH``.

If SCons cannot detect your Visual Studio installation, it might be that your
SCons version is too old. Update it to the latest version with
``python -m pip install --upgrade scons``.

.. _doc_compiling_for_windows_install_vs:

Installing Visual Studio caveats
--------------------------------

If installing Visual Studio 2017 or 2019, make sure to enable **C++** in
the list of workflows to install.

If installing Visual Studio 2015, make sure to run a **Custom**
installation instead of **Typical** and select **C++** as a language there.

If you've already made the mistake of installing Visual Studio without
C++ support, run the installer again; it should present you a **Modify** button.
Running the installer from *Add/Remove Programs* will only give you
a **Repair** option, which won't let you install C++ tools.

Downloading Godot's source
--------------------------

Refer to :ref:`doc_getting_source` for detailed instructions.

The tutorial will assume from now on that you placed the source code in
``C:\godot``.

.. warning::

    To prevent slowdowns caused by continuous virus scanning during compilation,
    add the Godot source folder to the list of exceptions in your antivirus
    software.

    For Windows Defender, hit the :kbd:`Windows` key, type
    "Windows Defender Settings" then hit :kbd:`Enter`.
    Under **Virus & threat protection**, go to **Virus & threat protection setting**
    and scroll down to **Exclusions**. Click **Add or remove exclusions** then
    add the Godot source folder.

Compiling
---------

Selecting a compiler
~~~~~~~~~~~~~~~~~~~~

SCons will automatically find and use an existing Visual Studio installation.
If you do not have Visual Studio installed, it will attempt to use
MinGW instead. If you already have Visual Studio installed and want to
use MinGW, pass ``use_mingw=yes`` to the SCons command line. Note that MSVC
builds cannot be performed from the MSYS2 or MinGW shells. Use either
``cmd.exe`` or PowerShell instead.

During development, using the Visual Studio compiler is usually a better idea,
as it links the Godot binary much faster than MinGW. However, MinGW can
produce more optimized binaries using link-time optimization (see below),
making it a better choice for production use.

Running SCons
~~~~~~~~~~~~~

After opening a command prompt, change to the root directory of
the engine source code (using ``cd``) and type::

    C:\godot> scons platform=windows

.. note:: When compiling with multiple CPU threads, SCons may warn about
          pywin32 being missing. You can safely ignore this warning.

If all goes well, the resulting binary executable will be placed in
``C:\godot\bin\`` with the name ``godot.windows.tools.32.exe`` or
``godot.windows.tools.64.exe``. By default, SCons will build a binary matching
your CPU architecture, but this can be overridden using ``bits=64`` or
``bits=32``.

This executable file contains the whole engine and runs without any
dependencies. Running it will bring up the Project Manager.

.. note:: If you are compiling Godot for production use, then you can
          make the final executable smaller and faster by adding the
          SCons option ``target=release_debug``.

          If you are compiling Godot with MinGW, you can make the binary
          even smaller and faster by adding the SCons option ``lto=full``.
          As link-time optimization is a memory-intensive process,
          this will require about 7 GB of available RAM while compiling.

.. note:: If you want to use separate editor settings for your own Godot builds
          and official releases, you can enable
          :ref:`doc_data_paths_self_contained_mode` by creating a file called
          ``._sc_`` or ``_sc_`` in the ``bin/`` folder.

Development in Visual Studio
----------------------------

Using an IDE is not required to compile Godot, as SCons takes care of everything.
But if you intend to do engine development or debugging of the engine's C++ code,
you may be interested in configuring a code editor or an IDE.

Folder-based editors don't require any particular setup to start working with Godot's
codebase. To edit projects with Visual Studio they need to be set up as a solution.

You can create a Visual Studio solution via SCons by running SCons with
the ``vsproj=yes`` parameter, like this::

   scons p=windows vsproj=yes

You will be able to open Godot's source in a Visual Studio solution now,
and able to build Godot using Visual Studio's **Build** button.

.. seealso:: See :ref:`doc_configuring_an_ide_vs` for further details.

Cross-compiling for Windows from other operating systems
--------------------------------------------------------

If you are a Linux or macOS user, you need to install
`MinGW-w64 <https://mingw-w64.org/doku.php>`__, which typically comes in 32-bit
and 64-bit variants. The package names may differ based on your distribution,
here are some known ones:

+----------------+--------------------------------------------------------------+
| **Arch Linux** | Install `mingw-w64-gcc from the AUR`_.                       |
+----------------+--------------------------------------------------------------+
| **Debian** /   | ::                                                           |
| **Ubuntu**     |                                                              |
|                |     apt install mingw-w64                                    |
+----------------+--------------------------------------------------------------+
| **Fedora**     | ::                                                           |
|                |                                                              |
|                |     dnf install mingw64-gcc-c++ mingw64-winpthreads-static \ |
|                |                 mingw32-gcc-c++ mingw32-winpthreads-static   |
+----------------+--------------------------------------------------------------+
| **macOS**      | ::                                                           |
|                |                                                              |
|                |     brew install mingw-w64                                   |
+----------------+--------------------------------------------------------------+
| **Mageia**     | ::                                                           |
|                |                                                              |
|                |     urpmi mingw64-gcc-c++ mingw64-winpthreads-static \       |
|                |           mingw32-gcc-c++ mingw32-winpthreads-static         |
+----------------+--------------------------------------------------------------+

.. _mingw-w64-gcc from the AUR: https://aur.archlinux.org/packages/mingw-w64-gcc/

Before attempting the compilation, SCons will check for
the following binaries in your ``PATH`` environment variable::

    i686-w64-mingw32-gcc
    x86_64-w64-mingw32-gcc

If the binaries are not located in the ``PATH`` (e.g. ``/usr/bin``),
you can define the following environment variables to give a hint to
the build system::

    export MINGW32_PREFIX="/path/to/i686-w64-mingw32-"
    export MINGW64_PREFIX="/path/to/x86_64-w64-mingw32-"

To make sure you are doing things correctly, executing the following in
the shell should result in a working compiler (the version output may
differ based on your system)::

    ${MINGW32_PREFIX}gcc --version
    # i686-w64-mingw32-gcc (GCC) 6.1.0 20160427 (Mageia MinGW 6.1.0-1.mga6)

Troubleshooting
~~~~~~~~~~~~~~~

Cross-compiling from some Ubuntu versions may lead to
`this bug <https://github.com/godotengine/godot/issues/9258>`_,
due to a default configuration lacking support for POSIX threading.

You can change that configuration following those instructions,
for 64-bit::

    sudo update-alternatives --config x86_64-w64-mingw32-gcc
    <choose x86_64-w64-mingw32-gcc-posix from the list>
    sudo update-alternatives --config x86_64-w64-mingw32-g++
    <choose x86_64-w64-mingw32-g++-posix from the list>

And for 32-bit::

    sudo update-alternatives --config i686-w64-mingw32-gcc
    <choose i686-w64-mingw32-gcc-posix from the list>
    sudo update-alternatives --config i686-w64-mingw32-g++
    <choose i686-w64-mingw32-g++-posix from the list>

Creating Windows export templates
---------------------------------

Windows export templates are created by compiling Godot without the editor,
with the following flags::

    C:\godot> scons platform=windows tools=no target=release_debug bits=32
    C:\godot> scons platform=windows tools=no target=release bits=32
    C:\godot> scons platform=windows tools=no target=release_debug bits=64
    C:\godot> scons platform=windows tools=no target=release bits=64

If you plan on replacing the standard export templates, copy these to the
following location, replacing ``<version>`` with the version identifier
(such as ``3.1.1.stable`` or ``3.2.dev``)::

    %USERPROFILE%\AppData\Roaming\Godot\templates\<version>\

With the following names::

    windows_32_debug.exe
    windows_32_release.exe
    windows_64_debug.exe
    windows_64_release.exe

However, if you are using custom modules or custom engine code, you
may instead want to configure your binaries as custom export templates
here:

.. image:: img/wintemplates.png

You don't need to copy them in this case, just reference the resulting
files in the ``bin\`` directory of your Godot source folder, so the next
time you build, you will automatically have the custom templates referenced.


===================================================
/. ./development/compiling/compiling_for_x11.rst
===================================================

.. _doc_compiling_for_x11:

Compiling for X11 (Linux, \*BSD)
================================

.. highlight:: shell

.. seealso::

    This page describes how to compile Linux editor and export template binaries from source.
    If you're looking to export your project to Linux instead, read :ref:`doc_exporting_for_linux`.

Requirements
------------

For compiling under Linux or other Unix variants, the following is
required:

-  GCC 7+ or Clang 6+.
-  Python 3.5+.
-  SCons 3.0+ build system. If your distribution uses Python 2 by default,
   or you are using a version of SCons prior to 3.1.2, you will need to change
   the version of Python that SCons uses by changing the shebang (the first line)
   of the SCons script file to ``#! /usr/bin/python3``.
   Use the command ``which scons`` to find the location of the SCons script file.
-  pkg-config (used to detect the dependencies below).
-  X11, Xcursor, Xinerama, Xi and XRandR development libraries.
-  MesaGL development libraries.
-  ALSA development libraries.
-  PulseAudio development libraries.
-  *Optional* - libudev (build with ``udev=yes``).
-  *Optional* - yasm (for WebM SIMD optimizations).

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

Distro-specific one-liners
^^^^^^^^^^^^^^^^^^^^^^^^^^
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Alpine Linux** | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     apk add scons pkgconf gcc g++ libx11-dev libxcursor-dev libxinerama-dev libxi-dev libxrandr-dev \     |
|                  |         mesa-dev libexecinfo-dev eudev-dev alsa-lib-dev pulseaudio-dev                                    |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Arch Linux**   | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     pacman -S --needed scons pkgconf gcc libxcursor libxinerama libxi libxrandr mesa glu libglvnd \       |
|                  |         alsa-lib pulseaudio yasm                                                                          |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Debian** /     | ::                                                                                                        |
| **Ubuntu**       |                                                                                                           |
|                  |     sudo apt-get install build-essential scons pkg-config libx11-dev libxcursor-dev libxinerama-dev \     |
|                  |         libgl1-mesa-dev libglu-dev libasound2-dev libpulse-dev libudev-dev libxi-dev libxrandr-dev yasm   |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Fedora**       | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     sudo dnf install scons pkgconfig libX11-devel libXcursor-devel libXrandr-devel libXinerama-devel \    |
|                  |         libXi-devel mesa-libGL-devel mesa-libGLU-devel alsa-lib-devel pulseaudio-libs-devel \             |
|                  |         libudev-devel yasm gcc-c++ libstdc++-static libatomic-static                                      |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **FreeBSD**      | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     sudo pkg install py37-scons pkgconf xorg-libraries libXcursor libXrandr libXi xorgproto libGLU \      |
|                  |         alsa-lib pulseaudio yasm                                                                          |
|                  |                                                                                                           |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Gentoo**       | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     emerge -an dev-util/scons x11-libs/libX11 x11-libs/libXcursor x11-libs/libXinerama x11-libs/libXi \   |
|                  |         media-libs/mesa media-libs/glu media-libs/alsa-lib media-sound/pulseaudio dev-lang/yasm           |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Mageia**       | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     urpmi scons task-c++-devel pkgconfig "pkgconfig(alsa)" "pkgconfig(glu)" "pkgconfig(libpulse)" \       |
|                  |         "pkgconfig(udev)" "pkgconfig(x11)" "pkgconfig(xcursor)" "pkgconfig(xinerama)" "pkgconfig(xi)" \   |
|                  |         "pkgconfig(xrandr)" yasm                                                                          |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **OpenBSD**      | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     pkg_add python scons llvm yasm                                                                        |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **openSUSE**     | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     sudo zypper install scons pkgconfig libX11-devel libXcursor-devel libXrandr-devel libXinerama-devel \ |
|                  |             libXi-devel Mesa-libGL-devel alsa-devel libpulse-devel libudev-devel libGLU1 yasm             |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **NetBSD**       | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     pkg_add pkg-config py37-scons yasm                                                                    |
|                  |                                                                                                           |
|                  | For audio support, you can optionally install ``pulseaudio``.                                             |
+------------------+-----------------------------------------------------------------------------------------------------------+
| **Solus**        | ::                                                                                                        |
|                  |                                                                                                           |
|                  |     sudo eopkg install -c system.devel scons libxcursor-devel libxinerama-devel libxi-devel \             |
|                  |         libxrandr-devel mesalib-devel libglu alsa-lib-devel pulseaudio-devel yasm                         |
+------------------+-----------------------------------------------------------------------------------------------------------+

Compiling
---------

Start a terminal, go to the root dir of the engine source code and type:

::

    scons platform=x11

If all goes well, the resulting binary executable will be placed in the
"bin" subdirectory. This executable file contains the whole engine and
runs without any dependencies. Executing it will bring up the project
manager.

.. note::

    If you wish to compile using Clang rather than GCC, use this command:

    ::

        scons platform=x11 use_llvm=yes

    Using Clang appears to be a requirement for OpenBSD, otherwise fonts
    would not build.

.. note:: If you are compiling Godot for production use, then you can
          make the final executable smaller and faster by adding the
          SCons option ``target=release_debug``.

          If you are compiling Godot with GCC, you can make the binary
          even smaller and faster by adding the SCons option ``lto=full``.
          As link-time optimization is a memory-intensive process,
          this will require about 7 GB of available RAM while compiling.

.. note:: If you want to use separate editor settings for your own Godot builds
          and official releases, you can enable
          :ref:`doc_data_paths_self_contained_mode` by creating a file called
          ``._sc_`` or ``_sc_`` in the ``bin/`` folder.

Compiling a headless/server build
---------------------------------

To compile a *headless* build which provides editor functionality to export
projects in an automated manner, use::

    scons platform=server tools=yes target=release_debug

To compile a debug *server* build which can be used with
:ref:`remote debugging tools <doc_command_line_tutorial>`, use::

    scons platform=server tools=no target=release_debug

To compile a *server* build which is optimized to run dedicated game servers,
use::

    scons platform=server tools=no target=release

Building export templates
-------------------------

.. warning:: Linux binaries usually won't run on distributions that are
             older than the distribution they were built on. If you wish to
             distribute binaries that work on most distributions,
             you should build them on an old distribution such as Ubuntu 16.04.
             You can use a virtual machine or a container to set up a suitable
             build environment.


To build X11 (Linux, \*BSD) export templates, run the build system with the
following parameters:

-  (32 bits)

::

    scons platform=x11 tools=no target=release bits=32
    scons platform=x11 tools=no target=release_debug bits=32

-  (64 bits)

::

    scons platform=x11 tools=no target=release bits=64
    scons platform=x11 tools=no target=release_debug bits=64

Note that cross-compiling for the opposite bits (64/32) as your host
platform is not always straight-forward and might need a chroot environment.

To create standard export templates, the resulting files must be copied to:

::

    $HOME/.local/share/godot/templates/[gd-version]/

and named like this (even for \*BSD which is seen as "Linux X11" by Godot):

::

    linux_x11_32_debug
    linux_x11_32_release
    linux_x11_64_debug
    linux_x11_64_release

However, if you are writing your custom modules or custom C++ code, you
might instead want to configure your binaries as custom export templates
here:

.. image:: img/lintemplates.png

You don't even need to copy them, you can just reference the resulting
files in the ``bin/`` directory of your Godot source folder, so the next
time you build, you automatically have the custom templates referenced.

Using Clang and LLD for faster development
------------------------------------------

You can also use Clang and LLD to build Godot. This has two upsides compared to
the default GCC + GNU ld setup:

- LLD links Godot significantly faster compared to GNU ld or gold. This leads to
  faster iteration times.
- Clang tends to give more useful error messages compared to GCC.

To do so, install Clang and the ``lld`` package from your distribution's package manager
then use the following SCons command::

    scons platform=x11 use_llvm=yes linker=lld

After the build is completed, a new binary with a ``.llvm`` suffix will be
created in the ``bin/`` folder.

It's still recommended to use GCC for production builds as they can be compiled using
link-time optimization, making the resulting binaries smaller and faster.

Using Pyston for faster development
-----------------------------------

You can use `Pyston <https://www.pyston.org/>`__ to run SCons. Pyston is a JIT-enabled
implementation of the Python language (which SCons is written in). It is currently
only compatible with Linux. Pyston can speed up incremental builds significantly,
often by a factor between 1.5× and 2×. Pyston can be combined with Clang and LLD
to get even faster builds.

- Download the `latest portable Pyston release <https://github.com/pyston/pyston/releases/latest>`__.
- Extract the portable ``.tar.gz`` to a set location, such as ``$HOME/.local/opt/pyston/`` (create folders as needed).
- Use ``cd`` to reach the extracted Pyston folder from a terminal,
  then run ``./pyston -m pip install scons`` to install SCons within Pyston.
- To make SCons via Pyston easier to run, create a symbolic link of its wrapper
  script to a location in your ``PATH`` environment variable::

    ln -s ~/.local/opt/pyston/bin/scons ~/.local/bin/pyston-scons

- Instead of running ``scons <build arguments>``, run ``pyston-scons <build arguments>``
  to compile Godot.

If you can't run ``pyston-scons`` after creating the symbolic link,
make sure ``$HOME/.local/bin/`` is part of your user's ``PATH`` environment variable.


===================================================
/. ./development/compiling/compiling_for_osx.rst
===================================================

.. _doc_compiling_for_osx:

Compiling for macOS
===================

.. highlight:: shell

.. note::

    This page describes how to compile macOS editor and export template binaries from source.
    If you're looking to export your project to macOS instead, read :ref:`doc_exporting_for_macos`.

Requirements
------------

For compiling under macOS, the following is required:

- `Python 3.5+ <https://www.python.org>`_.
- `SCons 3.0+ <https://www.scons.org>`_ build system.
- `Xcode <https://apps.apple.com/us/app/xcode/id497799835>`_
  (or the more lightweight Command Line Tools for Xcode).
- *Optional* - `yasm <https://yasm.tortall.net/>`_ (for WebM SIMD optimizations).

.. note:: If you have `Homebrew <https://brew.sh/>`_ installed, you can easily
          install SCons and yasm using the following command::

              brew install scons yasm

          Installing Homebrew will also fetch the Command Line Tools
          for Xcode automatically if you don't have them already.

          Similarly, if you have `MacPorts <https://www.macports.org/>`_
          installed, you can easily install SCons and yasm using the
          following command::

              sudo port install scons yasm

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

Compiling
---------

Start a terminal, go to the root directory of the engine source code.

To compile for Intel (x86-64) powered Macs, use::

    scons platform=osx arch=x86_64

To compile for Apple Silicon (ARM64) powered Macs, use::

    scons platform=osx arch=arm64

To support both architectures in a single "Universal 2" binary, run the above two commands and then use ``lipo`` to bundle them together::

    lipo -create bin/godot.osx.tools.x86_64 bin/godot.osx.tools.arm64 -output bin/godot.osx.tools.universal

If all goes well, the resulting binary executable will be placed in the
``bin/`` subdirectory. This executable file contains the whole engine and
runs without any dependencies. Executing it will bring up the project
manager.

.. note:: If you want to use separate editor settings for your own Godot builds
          and official releases, you can enable
          :ref:`doc_data_paths_self_contained_mode` by creating a file called
          ``._sc_`` or ``_sc_`` in the ``bin/`` folder.

To create an ``.app`` bundle like in the official builds, you need to use the
template located in ``misc/dist/osx_tools.app``. Typically, for an optimized
editor binary built with ``target=release_debug``::

    cp -r misc/dist/osx_tools.app ./Godot.app
    mkdir -p Godot.app/Contents/MacOS
    cp bin/godot.osx.opt.tools.universal Godot.app/Contents/MacOS/Godot
    chmod +x Godot.app/Contents/MacOS/Godot

Compiling a headless/server build
---------------------------------

To compile a *headless* build which provides editor functionality to export
projects in an automated manner, use::

    scons platform=server tools=yes target=release_debug

To compile a debug *server* build which can be used with
:ref:`remote debugging tools <doc_command_line_tutorial>`, use::

    scons platform=server tools=no target=release_debug

To compile a release *server* build which is optimized to run dedicated game servers,
use::

    scons platform=server tools=no target=release

Building export templates
-------------------------

To build macOS export templates, you have to compile with ``tools=no`` (no
editor) and respectively for ``target=release`` (release template) and
``target=release_debug``.

Official templates are universal binaries which support both Intel x86_64 and
ARM64 architectures. You can also create export templates that support only one
of those two architectures by leaving out the ``lipo`` step below.

- For Intel x86_64::

    scons platform=osx tools=no target=release arch=x86_64
    scons platform=osx tools=no target=release_debug arch=x86_64

- For ARM64 (Apple M1)::

    scons platform=osx tools=no target=release arch=arm64
    scons platform=osx tools=no target=release_debug arch=arm64

To support both architectures in a single "Universal 2" binary, run the above
two commands blocks and then use ``lipo`` to bundle them together::

    lipo -create bin/godot.osx.opt.x86_64 bin/godot.osx.opt.arm64 -output bin/godot.osx.opt.universal
    lipo -create bin/godot.osx.opt.debug.x86_64 bin/godot.osx.opt.debug.arm64 -output bin/godot.osx.opt.debug.universal

To create an ``.app`` bundle like in the official builds, you need to use the
template located in ``misc/dist/osx_template.app``. The release and debug
builds should be placed in ``osx_template.app/Contents/MacOS`` with the names
``godot_osx_release.64`` and ``godot_osx_debug.64`` respectively. You can do so
with the following commands (assuming a universal build, otherwise replace the
``.universal`` extension with the one of your arch-specific binaries)::

    cp -r misc/dist/osx_template.app .
    mkdir -p osx_template.app/Contents/MacOS
    cp bin/godot.osx.opt.universal osx_template.app/Contents/MacOS/godot_osx_release.64
    cp bin/godot.osx.opt.debug.universal osx_template.app/Contents/MacOS/godot_osx_debug.64
    chmod +x osx_template.app/Contents/MacOS/godot_osx*

You can then zip the ``osx_template.app`` folder to reproduce the ``osx.zip``
template from the official Godot distribution::

    zip -q -9 -r osx.zip osx_template.app

Cross-compiling for macOS from Linux
------------------------------------

It is possible to compile for macOS in a Linux environment (and maybe also in
Windows using the Windows Subsystem for Linux). For that, you'll need to install
`OSXCross <https://github.com/tpoechtrager/osxcross>`__ to be able to use macOS
as a target. First, follow the instructions to install it:

Clone the `OSXCross repository <https://github.com/tpoechtrager/osxcross>`__
somewhere on your machine (or download a ZIP file and extract it somewhere),
e.g.::

    git clone --depth=1 https://github.com/tpoechtrager/osxcross.git "$HOME/osxcross"

1. Follow the instructions to package the SDK:
   https://github.com/tpoechtrager/osxcross#packaging-the-sdk
2. Follow the instructions to install OSXCross:
   https://github.com/tpoechtrager/osxcross#installation

After that, you will need to define the ``OSXCROSS_ROOT`` as the path to
the OSXCross installation (the same place where you cloned the
repository/extracted the zip), e.g.::

    export OSXCROSS_ROOT="$HOME/osxcross"

Now you can compile with SCons like you normally would::

    scons platform=osx

If you have an OSXCross SDK version different from the one expected by the SCons buildsystem, you can specify a custom one with the ``osxcross_sdk`` argument::

    scons platform=osx osxcross_sdk=darwin15


===================================================
/. ./development/compiling/compiling_for_android.rst
===================================================

.. _doc_compiling_for_android:

Compiling for Android
=====================

.. highlight:: shell

.. seealso::

    This page describes how to compile Android export template binaries from source.
    If you're looking to export your project to Android instead, read :ref:`doc_exporting_for_android`.

Note
----

In most cases, using the built-in deployer and export templates is good
enough. Compiling the Android APK manually is mostly useful for custom
builds or custom packages for the deployer.

Also, you still need to follow the steps mentioned in the
:ref:`doc_exporting_for_android` tutorial before attempting to build
a custom export template.

Requirements
------------

For compiling under Windows, Linux or macOS, the following is required:

-  `Python 3.5+ <https://www.python.org/downloads/>`_.
-  `SCons 3.0+ <https://scons.org/pages/download.html>`_ build system.
-  `Android SDK <https://developer.android.com/studio/#command-tools>`_
   (command-line tools are sufficient).

   -  Required SDK components will be automatically installed.
   -  On Linux,
      **do not use an Android SDK provided by your distribution's repositories as it will often be outdated**.

-  Gradle (will be downloaded and installed automatically if missing).
-  JDK 11 (either OpenJDK or Oracle JDK).

   -  You can download a build from `ojdkbuild <https://github.com/ojdkbuild/ojdkbuild>`_.

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

.. _doc_android_setting_up_the_buildsystem:

Setting up the buildsystem
--------------------------

-  Set the environment variable ``ANDROID_SDK_ROOT`` to point to the Android 
   SDK. If you downloaded the Android command-line tools, this would be
   the folder where you extracted the contents of the ZIP archive.

-  Install the necessary SDK components in this folder:

    -  Accept the SDK component licenses by running the following command 
       where ``android_sdk_path`` is the path to the Android SDK, then answering all the prompts with ``y``:

    ::

        tools/bin/sdkmanager --sdk_root=<android_sdk_path> --licenses

    -  Complete setup by running the following command where ``android_sdk_path`` is the path to the Android SDK.

    ::

        tools/bin/sdkmanager --sdk_root=<android_sdk_path> "platform-tools" "build-tools;30.0.3" "platforms;android-29" "cmdline-tools;latest" "cmake;3.10.2.4988404"

.. seealso::   To set the environment variable on Windows, press :kbd:`Windows + R`, type 
            "control system", then click on **Advanced system settings** in the left
            pane, then click on **Environment variables** on the window that appears.

.. seealso::   To set the environment variable on Linux or macOS, use
            ``export ANDROID_SDK_ROOT=/path/to/android-sdk`` where ``/path/to/android-sdk`` points to
            the root of the SDK directories.

Building the export templates
-----------------------------

Godot needs two export templates for Android: the optimized "release"
template (``android_release.apk``) and the debug template (``android_debug.apk``).
As Google will require all APKs to include ARMv8 (64-bit) libraries starting
from August 2019, the commands below will build an APK containing both
ARMv7 and ARMv8 libraries.

Compiling the standard export templates is done by calling SCons from the Godot
root directory with the following arguments:

-  Release template (used when exporting with **Debugging Enabled** unchecked)

::

    scons platform=android target=release android_arch=armv7
    scons platform=android target=release android_arch=arm64v8
    cd platform/android/java
    # On Windows
    .\gradlew generateGodotTemplates
    # On Linux and macOS
    ./gradlew generateGodotTemplates


The resulting APK will be located at ``bin/android_release.apk``.

-  Debug template (used when exporting with **Debugging Enabled** checked)

::

    scons platform=android target=release_debug android_arch=armv7
    scons platform=android target=release_debug android_arch=arm64v8
    cd platform/android/java
    # On Windows
    .\gradlew generateGodotTemplates
    # On Linux and macOS
    ./gradlew generateGodotTemplates


The resulting APK will be located at ``bin/android_debug.apk``.

Adding support for x86 devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you also want to include support for x86 and x86-64 devices, run the SCons
command a third and fourth time with the ``android_arch=x86``, and
``android_arch=x86_64`` arguments before building the APK with Gradle. For
example, for the release template:

::

    scons platform=android target=release android_arch=armv7
    scons platform=android target=release android_arch=arm64v8
    scons platform=android target=release android_arch=x86
    scons platform=android target=release android_arch=x86_64
    cd platform/android/java
    # On Windows
    .\gradlew generateGodotTemplates
    # On Linux and macOS
    ./gradlew generateGodotTemplates


This will create a fat binary that works on all platforms.
The final APK size of exported projects will depend on the platforms you choose
to support when exporting; in other words, unused platforms will be removed from
the APK.

Cleaning the generated export templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use the following commands to remove the generated export templates:

::

    cd platform/android/java
    # On Windows
    .\gradlew cleanGodotTemplates
    # On Linux and macOS
    ./gradlew cleanGodotTemplates


Using the export templates
--------------------------

Godot needs release and debug APKs that were compiled against the same
version/commit as the editor. If you are using official binaries
for the editor, make sure to install the matching export templates,
or build your own from the same version.

When exporting your game, Godot opens the APK, changes a few things inside and
adds your files.

Installing the templates
~~~~~~~~~~~~~~~~~~~~~~~~

The newly-compiled templates (``android_debug.apk``
and ``android_release.apk``) must be copied to Godot's templates folder
with their respective names. The templates folder can be located in:

-  Windows: ``%APPDATA%\Godot\templates\<version>\``
-  Linux: ``$HOME/.local/share/godot/templates/<version>/``
-  macOS: ``$HOME/Library/Application Support/Godot/templates/<version>/``

``<version>`` is of the form ``major.minor[.patch].status`` using values from
``version.py`` in your Godot source repository (e.g. ``3.0.5.stable`` or ``3.1.dev``).
You also need to write this same version string to a ``version.txt`` file located
next to your export templates.

.. TODO: Move these paths to a common reference page

However, if you are writing your custom modules or custom C++ code, you
might instead want to configure your APKs as custom export templates
here:

.. image:: img/andtemplates.png

You don't even need to copy them, you can just reference the resulting
file in the ``bin\`` directory of your Godot source folder, so that the
next time you build you will automatically have the custom templates
referenced.

Troubleshooting
---------------

Platform doesn't appear in SCons
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Double-check that you've set the ``ANDROID_SDK_ROOT``
environment variable. This is required for the platform to appear in SCons'
list of detected platforms.
See :ref:`Setting up the buildsystem <doc_android_setting_up_the_buildsystem>`
for more information.

Application not installed
~~~~~~~~~~~~~~~~~~~~~~~~~

Android might complain the application is not correctly installed.
If so:

-  Check that the debug keystore is properly generated.
-  Check that the jarsigner executable is from JDK 8.

If it still fails, open a command line and run `logcat <https://developer.android.com/studio/command-line/logcat>`_:

::

    adb logcat

Then check the output while the application is installed;
the error message should be presented there.
Seek assistance if you can't figure it out.

Application exits immediately
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If the application runs but exits immediately, this might be due to
one of the following reasons:

-  Make sure to use export templates that match your editor version; if
   you use a new Godot version, you *have* to update the templates too.
-  ``libgodot_android.so`` is not in ``libs/<android_arch>/``
   where ``<android_arch>`` is the device's architecture.
-  The device's architecture does not match the exported one(s).
   Make sure your templates were built for that device's architecture,
   and that the export settings included support for that architecture.

In any case, ``adb logcat`` should also show the cause of the error.


===================================================
/. ./development/compiling/compiling_for_ios.rst
===================================================

.. _doc_compiling_for_ios:

Compiling for iOS
=================

.. highlight:: shell

.. seealso::

    This page describes how to compile iOS export template binaries from source.
    If you're looking to export your project to iOS instead, read :ref:`doc_exporting_for_ios`.

Requirements
------------

-  SCons 3.0+ (you can install it via `Homebrew <https://brew.sh/>`_ or
   `MacPorts <https://www.macports.org/>`_, you should be able
   to run ``scons`` in a terminal when installed).
-  Xcode 10.0 (or later) with the iOS (10.0) SDK and the command line tools.

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

Compiling
---------

Open a Terminal, go to the root dir of the engine source code and type:

::

    $ scons p=iphone target=debug

for a debug build, or:

::

    $ scons p=iphone target=release

for a release build (check ``platform/iphone/detect.py`` for the compiler
flags used for each configuration).

Alternatively, you can run

::

    $ scons p=iphone arch=x86_64 target=debug

for a Simulator executable.

For recent devices, Apple requires 64-bit versions of application binaries when you are uploading to the Apple Store.
The best way to provide these is to create a bundle in which there are both 32-bit and 64-bit binaries, so every device will be able to run the game.

It can be done in three steps: first compile the 32-bit version, then compile the 64-bit version and then use ``lipo`` to bundle them into one "universal" binary.
All those steps can be performed with following commands:

::

    $ scons p=iphone tools=no target=release arch=arm
    $ scons p=iphone tools=no target=release arch=arm64
    $ lipo -create bin/libgodot.iphone.opt.arm.a bin/libgodot.iphone.opt.arm64.a -output bin/libgodot.iphone.release.fat.a
    $ lipo -create bin/libgodot_camera_module.iphone.opt.arm.a bin/libgodot_camera_module.iphone.opt.arm64.a -output bin/libgodot_camera_module.iphone.release.fat.a
    $ lipo -create bin/libgodot_arkit_module.iphone.opt.arm.a bin/libgodot_arkit_module.iphone.opt.arm64.a -output bin/libgodot_arkit_module.iphone.release.fat.a

If you also want to provide a simulator build (reduces the chance of any linker errors with dependencies), you'll need to build and lipo the ``x86_64`` architecture as well.

::

    $ scons p=iphone tools=no target=release arch=arm
    $ scons p=iphone tools=no target=release arch=arm64
    $ scons p=iphone tools=no target=release arch=x86_64
    $ lipo -create bin/libgodot.iphone.opt.arm.a bin/libgodot.iphone.opt.arm64.a bin/libgodot.iphone.opt.x86_64.a -output bin/libgodot.iphone.release.fat.a
    $ lipo -create bin/libgodot_camera_module.iphone.opt.arm.a bin/libgodot_camera_module.iphone.opt.arm64.a bin/libgodot_camera_module.iphone.opt.x86_64.a -output bin/libgodot_camera_module.iphone.release.fat.a
    $ lipo -create bin/libgodot_arkit_module.iphone.opt.arm.a bin/libgodot_arkit_module.iphone.opt.arm64.a bin/libgodot_arkit_module.iphone.opt.x86_64.a -output bin/libgodot_arkit_module.iphone.release.fat.a

Run
---

To run on a device or simulator, follow these instructions:
:ref:`doc_exporting_for_ios`.

Replace or add your executable to the Xcode project, and change the
"executable name" property on Info.plist accordingly if you use an
alternative build.


===================================================
/. ./development/compiling/cross-compiling_for_ios_on_linux.rst
===================================================

.. _doc_cross-compiling_for_ios_on_linux:

Cross-compiling for iOS on Linux
================================

.. highlight:: shell

The procedure for this is somewhat complex and requires a lot of steps,
but once you have the environment properly configured it will be easy to
compile Godot for iOS anytime you want.

Disclaimer
----------

While it is possible to compile for iOS on a Linux environment, Apple is
very restrictive about the tools to be used (especially hardware-wise),
allowing pretty much only their products to be used for development. So
this is **not official**. However, a `statement from Apple in 2010
<http://www.apple.com/pr/library/2010/09/09Statement-by-Apple-on-App-Store-Review-Guidelines.html>`__
says they relaxed some of the `App Store review guidelines
<https://developer.apple.com/app-store/review/guidelines/>`__
to allow any tool to be used, as long as the resulting binary does not
download any code, which means it should be OK to use the procedure
described here and cross-compiling the binary.

Requirements
------------

-  `XCode with the iOS SDK <https://developer.apple.com/xcode/download>`__
   (a dmg image)
-  `Clang >= 3.5 <http://clang.llvm.org>`__ for your development
   machine installed and in the ``PATH``. It has to be version >= 3.5
   to target ``arm64`` architecture.
-  `Fuse <https://github.com/libfuse/libfuse>`__ for mounting and umounting
   the dmg image.
-  `darling-dmg <https://github.com/darlinghq/darling-dmg>`__, which
   needs to be built from source. The procedure for that is explained
   below.

   -  For building darling-dmg, you'll need the development packages of
      the following libraries: fuse, icu, openssl, zlib, bzip2.

-  `cctools-port <https://github.com/tpoechtrager/cctools-port>`__
   for the needed build tools. The procedure for building is quite
   peculiar and is described below.

   -  This also has some extra dependencies: automake, autogen, libtool.

Configuring the environment
---------------------------

darling-dmg
~~~~~~~~~~~

Clone the repository on your machine:

::

    $ git clone https://github.com/darlinghq/darling-dmg.git

Build it:

::

    $ cd darling-dmg
    $ mkdir build
    $ cd build
    $ cmake .. -DCMAKE_BUILD_TYPE=Release
    $ make -j 4  # The number is the amount of cores your processor has, for faster build
    $ cd ../..

Preparing the SDK
~~~~~~~~~~~~~~~~~

Mount the XCode image:

::

    $ mkdir xcode
    $ ./darling-dmg/build/darling-dmg /path/to/Xcode_7.1.1.dmg xcode
    [...]
    Everything looks OK, disk mounted

Extract the iOS SDK:

::

    $ mkdir -p iPhoneSDK/iPhoneOS9.1.sdk
    $ cp -r xcode/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/* iPhoneSDK/iPhoneOS9.1.sdk
    $ cp -r xcode/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/* iPhoneSDK/iPhoneOS9.1.sdk/usr/include/c++
    $ fusermount -u xcode  # unmount the image

Pack the SDK:

::

    $ cd iPhoneSDK
    $ tar -cf - * | xz -9 -c - > iPhoneOS9.1.sdk.tar.xz

Toolchain
~~~~~~~~~

Build cctools:

::

    $ git clone https://github.com/tpoechtrager/cctools-port.git
    $ cd cctools-port/usage_examples/ios_toolchain
    $ ./build.sh /path/iPhoneOS9.1.sdk.tar.xz arm64

Copy the tools to a nicer place. Note that the SCons scripts for
building will look under ``usr/bin`` inside the directory you provide
for the toolchain binaries, so you must copy to such subdirectory, akin
to the following commands:

::

    $ mkdir -p /home/user/iostoolchain/usr
    $ cp -r target/bin /home/user/iostoolchain/usr/

Now you should have the iOS toolchain binaries in
``/home/user/iostoolchain/usr/bin``.

Compiling Godot for iPhone
--------------------------

Once you've done the above steps, you should keep two things in your
environment: the built toolchain and the iPhoneOS SDK directory. Those
can stay anywhere you want since you have to provide their paths to the
SCons build command.

For the iPhone platform to be detected, you need the ``OSXCROSS_IOS``
environment variable defined to anything.

::

    $ export OSXCROSS_IOS=anything

Now you can compile for iPhone using SCons like the standard Godot
way, with some additional arguments to provide the correct paths:

::

    $ scons -j 4 platform=iphone arch=arm target=release_debug IPHONESDK="/path/to/iPhoneSDK" IPHONEPATH="/path/to/iostoolchain" ios_triple="arm-apple-darwin11-"
    $ scons -j 4 platform=iphone arch=arm64 target=release_debug IPHONESDK="/path/to/iPhoneSDK" IPHONEPATH="/path/to/iostoolchain" ios_triple="arm-apple-darwin11-"

Producing fat binaries
~~~~~~~~~~~~~~~~~~~~~~

Apple requires a fat binary with both architectures (``armv7`` and
``arm64``) in a single file. To do this, use the
``arm-apple-darwin11-lipo`` executable. The following example assumes
you are in the root Godot source directory:

::

    $ /path/to/iostoolchain/usr/bin/arm-apple-darwin11-lipo -create bin/libgodot.iphone.opt.debug.arm.a bin/libgodot.iphone.opt.debug.arm64.a -output bin/libgodot.iphone.debug.fat.a
    $ /path/to/iostoolchain/usr/bin/arm-apple-darwin11-lipo -create bin/libgodot_camera_module.iphone.opt.debug.arm.a bin/libgodot_camera_module.iphone.opt.debug.arm64.a -output bin/libgodot_camera_module.iphone.debug.fat.a
    $ /path/to/iostoolchain/usr/bin/arm-apple-darwin11-lipo -create bin/libgodot_arkit_module.iphone.opt.debug.arm.a bin/libgodot_arkit_module.iphone.opt.debug.arm64.a -output bin/libgodot_arkit_module.iphone.debug.fat.a


Then you will have iOS fat binaries in ``bin`` directory.


===================================================
/. ./development/compiling/compiling_for_uwp.rst
===================================================

.. _doc_compiling_for_uwp:

Compiling for Universal Windows Platform
========================================

.. highlight:: shell

.. seealso::

    This page describes how to compile UWP export template binaries from source.
    If you're looking to export your project to UWP instead, read :ref:`doc_exporting_for_uwp`.

Requirements
------------

-  SCons 3.0+ (see :ref:`doc_compiling_for_windows` for more details).
-  Visual Studio 2017 or later. See :ref:`doc_compiling_for_windows` about the
   caveats of installing it and the various prompts.
-  Windows 10 SDK (can be selected in Visual Studio installation).
-  `ANGLE source <https://github.com/Microsoft/angle>`__. Use the
   ``ms_master`` (default) branch. Keep it in a path without spaces to
   avoid problems.

.. note:: The ANGLE repo by Microsoft has been discontinued and the
          ``ms_master`` branch has been cleared out.

          As a temporary workaround however, it is still possible to
          download an older state of the source code via commit
          `c61d048 <https://github.com/microsoft/angle/tree/c61d0488abd9663e0d4d2450db7345baa2c0dfb6>`__.

          This page will eventually be updated in the future to reflect
          the new build instructions.

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

Compiling
---------

You need to open a proper Visual Studio prompt for the target architecture
you want to build. Check :ref:`doc_compiling_for_windows` to see how these
prompts work.

There are three target architectures for UWP: x86 (32-bits), x64 (64-bits)
and ARM (32-bits). For the latter, you can run ``vcvarsall.bat`` with
``x86_arm`` or ``amd64_arm`` as argument to set the environment.

Set the ``ANGLE_SRC_PATH`` to the directory where you downloaded the ANGLE
source code. The build process will also build ANGLE to produce the
required DLLs for the selected architecture.

Once you're set, run the SCons command similarly to the other platforms::

    C:\godot>scons platform=uwp

Creating UWP export templates
-----------------------------

To export using the editor you need to properly build package the templates.
You need all three architectures with ``debug`` and ``release`` templates to
be able to export.

Open the command prompt for one architecture and run SCons twice (once for
each target)::

    C:\godot>scons platform=uwp target=release_debug
    C:\godot>scons platform=uwp target=release

Repeat for the other architectures.

In the end your ``bin`` folder will have the ``.exe`` binaries with a name
like ``godot.uwp.opt.debug.32.x86.exe`` (with variations for each
target/arch).

Copy one of these to ``misc/dist/uwp_template`` inside the Godot source
folder and rename the binary to ``godot.uwp.exe``. From the ANGLE source,
under ``winrt/10/src/Release_%arch%`` (where ``%arch%`` can be ``Win32``,
``x64`` or ``ARM``), get the ``libEGL.dll`` and the ``libGLESv2.dll``,
putting them along with the executable.

Add the files in the ``uwp_template`` folder to a ZIP. Rename the resulting
Zip according to the target/architecture of the template::

    uwp_x86_debug.zip
    uwp_x86_release.zip
    uwp_x64_debug.zip
    uwp_x64_release.zip
    uwp_arm_debug.zip
    uwp_arm_release.zip

Move those templates to the ``[versionstring]\templates`` folder in Godot
settings path, where `versionstring` is the version of Godot you have compiled
the export templates for - e.g. `3.0.alpha` for the alpha version of Godot 3.
If you don't want to replace the templates, you can set the "Custom Package"
property in the export window.

Running UWP apps with Visual Studio
-----------------------------------

If you want to debug the UWP port or simply run your apps without packaging
and signing, you can deploy and launch them using Visual Studio. It might be
the easiest way if you are testing on a device such as a Windows Phone or an
Xbox One.

Within the ANGLE source folder, open ``templates`` and double-click the
``install.bat`` script file. This will install the Visual Studio project
templates for ANGLE apps.

If you have not built Godot yet, open the ``winrt/10/src/angle.sln`` solution
from the ANGLE source and build it to Release/Win32 target. You may also need
to build it for ARM if you plan to run on a device. You can also use MSBuild if
you're comfortable with the command line.

Create a new Windows App project using the "App for OpenGL ES
(Windows Universal)" project template, which can be found under the
``Visual C++/Windows/Universal`` category.

This is a base project with the ANGLE dependencies already set up. However, by
default it picks the debug version of the DLLs which usually have poor
performance. So in the "Binaries" filter, click in each of the DLLs there
and in the "Properties" window and change the relative path from
``Debug_Win32`` to ``Release_Win32`` (or ``Release_ARM`` for devices).

In the same "Binaries" filter, select "Add > Existing Item" and point to the
Godot executable for UWP you have. In the "Properties" window, set "Content"
to ``True`` so it's included in the project.

Right-click the ``Package.appxmanifest`` file and select "Open With... > XML
(Text) Editor". In the ``Package/Applications/Application`` element, replace
the ``Executable`` attribute from ``$targetnametoken$.exe`` to
``godot.uwp.exe`` (or whatever your Godot executable is called). Also change
the ``EntryPoint`` attribute to ``GodotUWP.App``. This will ensure that
the Godot executable is correctly called when the app starts.

Create a folder (*not* a filter) called ``game`` in your Visual Studio project
folder and there you can put either a ``data.pck`` file or your Godot project
files. After that, make sure to include it all with the "Add > Existing Item"
command and set their "Content" property to ``True`` so they're copied to the
app.

To ease the workflow, you can open the "Solution Properties" and in the
"Configuration" section untick the "Build" option for the app. You still have
to build it at least once to generate some needed files, you can do so by
right-clicking the project (*not* the solution) in the "Solution Explorer" and
selecting "Build".

Now you can just run the project and your app should open. You can also use
the "Start Without Debugging" option from the "Debug" menu (or press :kbd:`Ctrl + F5`) to make it
launch faster.


===================================================
/. ./development/compiling/compiling_for_web.rst
===================================================

.. _doc_compiling_for_web:

Compiling for the Web
=====================

.. seealso::

    This page describes how to compile HTML5 editor and export template binaries from source.
    If you're looking to export your project to HTML5 instead, read :ref:`doc_exporting_for_web`.

.. highlight:: shell

Requirements
------------

To compile export templates for the Web, the following is required:

-  `Emscripten 1.39.9+ <https://emscripten.org>`__.
-  `Python 3.5+ <https://www.python.org/>`__.
-  `SCons 3.0+ <https://www.scons.org>`__ build system.

.. seealso:: To get the Godot source code for compiling, see
             :ref:`doc_getting_source`.

             For a general overview of SCons usage for Godot, see
             :ref:`doc_introduction_to_the_buildsystem`.

Building export templates
-------------------------

Before starting, confirm that ``emcc`` is available in your PATH. This is
usually configured by the Emscripten SDK, e.g. when invoking ``emsdk activate``
and ``source ./emsdk_env.sh``/``emsdk_env.bat``.

Open a terminal and navigate to the root directory of the engine source code.
Then instruct SCons to build the JavaScript platform. Specify ``target`` as
either ``release`` for a release build or ``release_debug`` for a debug build::

    scons platform=javascript tools=no target=release
    scons platform=javascript tools=no target=release_debug

By default, the :ref:`JavaScript singleton <doc_javascript_eval>` will be built
into the engine. Official export templates also have the JavaScript singleton
enabled. Since ``eval()`` calls can be a security concern, the
``javascript_eval`` option can be used to build without the singleton::

    scons platform=javascript tools=no target=release javascript_eval=no
    scons platform=javascript tools=no target=release_debug javascript_eval=no

The engine will now be compiled to WebAssembly by Emscripten. Once finished,
the resulting file will be placed in the ``bin`` subdirectory. Its name is
``godot.javascript.opt.zip`` for release or ``godot.javascript.opt.debug.zip``
for debug.

Finally, rename the zip archive to ``webassembly_release.zip`` for the
release template::

    mv bin/godot.javascript.opt.zip bin/webassembly_release.zip

And ``webassembly_debug.zip`` for the debug template::

    mv bin/godot.javascript.opt.debug.zip bin/webassembly_debug.zip

Threads and GDNative
--------------------

The default export templates do not include threads and GDNative support for
performance and compatibility reasons. See the
:ref:`export page <doc_javascript_export_options>` for more info.

You can build the export templates using the option ``threads_enabled=yes`` or
``gdnative_enabled=yes`` to enable threads or GDNative support::

    scons platform=javascript tools=no threads_enabled=yes target=release
    scons platform=javascript tools=no threads_enabled=yes target=release_debug

    scons platform=javascript tools=no gdnative_enabled=yes target=release
    scons platform=javascript tools=no gdnative_enabled=yes target=release_debug

Once finished, the resulting file will be placed in the ``bin`` subdirectory.
Its name will have either the ``.threads`` or ``.gdnative`` suffix.

Finally, rename the zip archives to ``webassembly_release_threads.zip`` and
``webassembly_release_gdnative.zip`` for the release template::

    mv bin/godot.javascript.opt.threads.zip bin/webassembly_threads_release.zip
    mv bin/godot.javascript.opt.gdnative.zip bin/webassembly_gdnative_release.zip

And ``webassembly_debug_threads.zip`` and ``webassembly_debug_gdnative.zip`` for
the debug template::

    mv bin/godot.javascript.opt.debug.threads.zip bin/webassembly_threads_debug.zip
    mv bin/godot.javascript.opt.debug.gdnative.zip bin/webassembly_gdnative_debug.zip

Building the Editor
-------------------

It is also possible to build a version of the Godot editor that can run in the
browser. The editor version requires threads support and is not recommended
over the native build. You can build the editor with::

    scons platform=javascript tools=yes threads_enabled=yes target=release_debug

Once finished, the resulting file will be placed in the ``bin`` subdirectory.
Its name will be ``godot.javascript.opt.tools.threads.zip``. You can upload the
zip content to your web server and visit it with your browser to use the editor.

Refer to the :ref:`export page <doc_javascript_export_options>` for the web
server requirements.


===================================================
/. ./development/compiling/compiling_with_mono.rst
===================================================

.. _doc_compiling_with_mono:

Compiling with Mono
===================

.. highlight:: shell

Requirements
------------

- Mono 6.12.0 or greater
- MSBuild
- NuGet
- **On Linux/macOS only:** pkg-config

You may need to import necessary certificates for NuGet to perform HTTPS
requests.

The recommended method is to use **curl**'s CA (Certificate Authorities) certificate bundle.

Run the following commands to download and import it. On Windows, you can run it
from the Mono command line prompt (or the regular prompt if you added Mono's
``bin`` directory to your ``PATH`` environment variable)::

    # If using PowerShell, replace `curl` with `curl.exe` below.
    curl -LO https://curl.haxx.se/ca/cacert.pem
    cert-sync --user cacert.pem

Alternatively, you can use the following command, though it's deprecated and may not work correctly::

    mozroots --import --sync

Environment variables
---------------------

By default, SCons will try to find Mono in the Windows Registry on Windows or
via ``pkg-config`` on other platforms. You can specify a different installation
directory by passing the ``mono_prefix`` command-line option to SCons; e.g.
``scons [...] mono_prefix=%ProgramFiles%/Mono``.

This is the directory that contains the subdirectories ``include`` and ``lib``.

Enable the Mono module
----------------------

By default, the Mono module is disabled when building. To enable it, add the
option ``module_mono_enabled=yes`` to the SCons command line.

Generate the glue
-----------------

Glue sources are the wrapper functions that will be called by managed methods.
These source files must be generated before building your final binaries. In
order to generate them, first, you must build a temporary Godot binary with the
options ``tools=yes`` and ``mono_glue=no``::

    scons p=<platform> tools=yes module_mono_enabled=yes mono_glue=no

After the build finishes, you need to run the compiled executable with the
parameter ``--generate-mono-glue`` followed by the path to an output directory.
This path must be ``modules/mono/glue`` in the Godot directory::

    <godot_binary> --generate-mono-glue modules/mono/glue

This command will tell Godot to generate the file ``modules/mono/glue/mono_glue.gen.cpp``,
the C# solution for the Godot API at ``modules/mono/glue/GodotSharp/GodotSharp/Generated``,
and the C# solution for the editor tools at ``modules/mono/glue/GodotSharp/GodotSharpEditor/Generated``.
Once these files are generated, you can build Godot for all the desired targets
without having to repeat this process.

``<godot_binary>`` refers to the tools binary you compiled above with the Mono
module enabled. Its exact name will differ based on your system and
configuration, but should be of the form
``bin/godot.<platform>.tools.<bits>.mono``, e.g. ``bin/godot.x11.tools.64.mono``
or ``bin/godot.windows.tools.64.mono.exe``. Be especially aware of the **.mono**
suffix! If you've previously compiled Godot without Mono support, you might have
similarly named binaries without this suffix. These binaries can't be used to
generate the Mono glue.

Notes
^^^^^

- **Do not build your final binaries with** ``mono_glue=no``.
  This disables C# scripting. This option must be used only for the temporary
  binary that will generate the glue. Godot will print a warning at startup if
  it was built without the glue sources.
- The glue sources must be regenerated every time the ClassDB-registered API
  changes. That is, for example, when a new method is registered to the
  scripting API or one of the parameters of such a method changes.
  Godot will print an error at startup if there is an API mismatch
  between ClassDB and the glue sources.


Rebuild with Mono glue
----------------------

Once you have generated the Mono glue, you can build the final binary with
``mono_glue=yes``. This is the default value for ``mono_glue``, so you can also
omit it. To build a Mono-enabled editor::

    scons p=<platform> tools=yes module_mono_enabled=yes mono_glue=yes

And Mono-enabled export templates::

    scons p=<platform> tools=no module_mono_enabled=yes mono_glue=yes

If everything went well, apart from the normal output, SCons should have created
the following files in the ``bin`` directory:

- If you're not linking the Mono runtime statically, the build script will place
  the Mono runtime shared library (``monosgen-2.0``) next to the Godot
  binary in the output directory. Make sure to include this library when
  distributing Godot. When targeting Android, no extra steps are required as
  this library is automatically copied to ``#platform/android/java/libs`` and
  Gradle takes care of the rest.
- Unlike "classical" Godot builds, when building with the Mono module enabled
  (and depending on the target platform), a data directory may be created both
  for the editor and for export templates. This directory is important for
  proper functioning and must be distributed together with Godot.
  More details about this directory in
  :ref:`Data directory<compiling_with_mono_data_directory>`.

Examples
--------

Example (Windows)
^^^^^^^^^^^^^^^^^

::

    # Build temporary binary
    scons p=windows tools=yes module_mono_enabled=yes mono_glue=no
    # Generate glue sources
    bin\godot.windows.tools.64.mono --generate-mono-glue modules/mono/glue

    ### Build binaries normally
    # Editor
    scons p=windows target=release_debug tools=yes module_mono_enabled=yes
    # Export templates
    scons p=windows target=release_debug tools=no module_mono_enabled=yes
    scons p=windows target=release tools=no module_mono_enabled=yes

Example (X11)
^^^^^^^^^^^^^

::

    # Build temporary binary
    scons p=x11 tools=yes module_mono_enabled=yes mono_glue=no
    # Generate glue sources
    bin/godot.x11.tools.64.mono --generate-mono-glue modules/mono/glue

    ### Build binaries normally
    # Editor
    scons p=x11 target=release_debug tools=yes module_mono_enabled=yes
    # Export templates
    scons p=x11 target=release_debug tools=no module_mono_enabled=yes
    scons p=x11 target=release tools=no module_mono_enabled=yes

.. _compiling_with_mono_data_directory:

Data directory
--------------

The data directory is a dependency for Godot binaries built with the Mono module
enabled. It contains important files for the correct functioning of Godot. It
must be distributed together with the Godot executable.

.. note:: The information below doesn't apply for Android, iOS and WASM,
          as there is no data directory for these platforms.

Export templates
^^^^^^^^^^^^^^^^

The name of the data directory for an export template differs based on the
configuration it was built with. The format is
``data.mono.<platform>.<bits>.<target>``, e.g. ``data.mono.x11.32.release_debug`` or
``data.mono.windows.64.release``.

This directory must be placed with its original name next to the Godot export
templates. When exporting a project, Godot will also copy this directory with
the game executable but the name will be changed to ``data_<APPNAME>``, where
``<APPNAME>`` is the application name as specified in the project setting
``application/config/name``.

In the case of macOS, where the export template is compressed as a ZIP archive,
the contents of the data directory can be placed in the following locations
inside the ZIP archive:

+-------------------------------------------------------+---------------------------------------------------------------+
| ``bin/data.mono.<platform>.<bits>.<target>/Mono/lib`` | ``/osx_template.app/Contents/Frameworks/GodotSharp/Mono/lib`` |
+-------------------------------------------------------+---------------------------------------------------------------+
| ``bin/data.mono.<platform>.<bits>.<target>/Mono/etc`` | ``/osx_template.app/Contents/Resources/GodotSharp/Mono/etc``  |
+-------------------------------------------------------+---------------------------------------------------------------+

Editor
^^^^^^

The name of the data directory for the Godot editor will always be
``GodotSharp``. The contents of this directory are the following:

- ``Api``
- ``Mono`` (optional)
- ``Tools``

The ``Api`` subdirectory contains the Godot API assemblies. On macOS, if the
Godot editor is distributed as a bundle, the contents of the data directory may
be placed in the following locations:

+-------------------------------------------------------+---------------------------------------------------------------+
| ``bin/data.mono.<platform>.<bits>.<target>/Api``      | ``<bundle_name>.app/Contents/Frameworks/GodotSharp/Api``      |
+-------------------------------------------------------+---------------------------------------------------------------+
| ``bin/data.mono.<platform>.<bits>.<target>/Mono/lib`` | ``<bundle_name>.app/Contents/Frameworks/GodotSharp/Mono/lib`` |
+-------------------------------------------------------+---------------------------------------------------------------+
| ``bin/data.mono.<platform>.<bits>.<target>/Mono/etc`` | ``<bundle_name>.app/Contents/Resources/GodotSharp/Mono/etc``  |
+-------------------------------------------------------+---------------------------------------------------------------+
| ``bin/data.mono.<platform>.<bits>.<target>/Tools``    | ``<bundle_name>.app/Contents/Frameworks/GodotSharp/Tools``    |
+-------------------------------------------------------+---------------------------------------------------------------+

The ``Mono`` subdirectory is optional. It will be needed when distributing the
editor, as issues can arise when the user-installed Mono version isn't identical
to the one the Godot editor was built with. Pass ``copy_mono_root=yes`` to SCons
when building the editor in order to create this folder and its contents.

The ``Tools`` subdirectory contains tools required by the editor, like the
``GodotTools`` assemblies and its dependencies.

Building the Mono runtime
-------------------------

When building Godot for the desktop, you will likely use the pre-built Mono runtime
that is installed on your system. This likely won't be the case when targeting other
platforms like Android, iOS and WebAssembly. You will have to build the Mono runtime
yourself for those platforms.

We recommend using these `build scripts <https://github.com/godotengine/godot-mono-builds>`_.
They simplify this process but also include some patches needed
for proper functioning with Godot. See the README on the link above
for instructions on how to use the scripts.

Targeting Android
-----------------

Compiling the Android export templates with Mono is a bit simpler than it is for
the desktop platforms, as there are no additional steps required after building.
There is no need to worry about run-time dependencies like a data directory or
the shared library (when dynamically linking) as those are automatically added
to the Gradle project.

Once you've built Mono, you can proceed to build Godot with the instructions
described in this page and the
:ref:`Compiling for Android<doc_compiling_for_android>` page.
Make sure to let SCons know about the location of the Mono runtime you've just built, e.g.:
``scons [...] mono_prefix="$HOME/mono-installs/android-armeabi-v7a-release"``
(This path may be different on your system).

Targeting iOS
-------------

Once you've built Mono, you can proceed to build Godot with the instructions
described in this page and the
:ref:`Compiling for iOS<doc_compiling_for_ios>` page.
Make sure to let SCons know about the location of the Mono runtime you've just built, e.g.:
``scons [...] mono_prefix="$HOME/mono-installs/ios-arm64-release"``
(This path may be different on your system).

After building Godot for each architecture, you will notice SCons has
copied the Mono libraries for each of them to the output directory:

::

    #bin/libmono-native.iphone.<arch>.a
    #bin/libmonosgen-2.0.iphone.<arch>.a
    #bin/libmonoprofiler-log.iphone.<arch>.a

    #bin/libmono-ilgen.iphone.<arch>.a
    #bin/libmono-ee-interp.iphone.<arch>.a
    #bin/libmono-icall-table.iphone.<arch>.a

The last three are only for iOS devices and are not available for the iOS simulator.

These libraries must be put in universal (multi-architecture) "fat"
files to be distributed with the export templates.

The following bash script will create the "fat" libraries in the directory ``#bin/ios/iphone-mono-libs``:

::

    mkdir -p bin/ios
    mkdir -p bin/ios/iphone-mono-libs

    lipo -create bin/libmonosgen-2.0.iphone.arm64.a bin/libmonosgen-2.0.iphone.x86_64.a -output bin/ios/iphone-mono-libs/libmonosgen-2.0.iphone.fat.a
    lipo -create bin/libmono-native.iphone.arm64.a bin/libmono-native.iphone.x86_64.a -output bin/ios/iphone-mono-libs/libmono-native.iphone.fat.a
    lipo -create bin/libmono-profiler-log.iphone.arm64.a bin/libmono-profiler-log.iphone.x86_64.a -output bin/ios/iphone-mono-libs/libmono-profiler-log.iphone.fat.a

    # The Mono libraries for the interpreter are not available for simulator builds
    lipo -create bin/libmono-ee-interp.iphone.arm64.a -output bin/ios/iphone-mono-libs/libmono-ee-interp.iphone.fat.a
    lipo -create bin/libmono-icall-table.iphone.arm64.a -output bin/ios/iphone-mono-libs/libmono-icall-table.iphone.fat.a
    lipo -create bin/libmono-ilgen.iphone.arm64.a -output bin/ios/iphone-mono-libs/libmono-ilgen.iphone.fat.a

The ``iphone-mono-libs`` folder must be distributed with the export templates.
The Godot editor will look for the libraries in ``<templates>/iphone-mono-libs/lib<name>.iphone.fat.a``.

Targeting WebAssembly
---------------------

Building for WebAssembly currently involves the same process regardless of whether the Mono module is enabled.

Once you've built Mono, you can proceed to build Godot with the instructions
described in this page and the
:ref:`Compiling for the Web<doc_compiling_for_web>` page.
Make sure to let SCons know about the location of the Mono runtime you've just built, e.g.:
``scons [...] mono_prefix="$HOME/mono-installs/wasm-runtime-release"``
(This path may be different on your system).

Base Class Library
------------------

The export templates must also include the BCL (Base Class Library) for each target platform.
Godot looks for the BCL folder at ``<templates>/bcl/<target_platform>``,
where ``<target_platform>`` is the same name passed to the SCons ``platform`` option,
e.g.: ``<templates>/bcl/windows``, ``<templates>/bcl/javascript``.

Alternatively, Godot will look for them in the following locations:

+-------------------+---------------------------------+
|      Android      |  ``<templates>/bcl/monodroid``  |
+-------------------+---------------------------------+
|        iOS        |  ``<templates>/bcl/monotouch``  |
+-------------------+---------------------------------+
|    WebAssembly    |    ``<templates>/bcl/wasm``     |
+-------------------+---------------------------------+
|  Linux and macOS  |   ``<templates>/bcl/net_4_x``   |
+-------------------+---------------------------------+
|      Windows      | ``<templates>/bcl/net_4_x_win`` |
+-------------------+---------------------------------+

As of now, we're assuming the same BCL profile can be used for both Linux and macOS,
but this may change in the future as they're not guaranteed to be the same
(as is the case with the Windows BCL).

If the target platform is the same as the platform of the Godot editor,
then the editor will use the BCL it's running on (``<data_folder>/Mono/lib/mono/4.5``)
if it cannot find the BCL in the export templates.

AOT cross-compilers
-------------------

To perform ahead-of-time (AOT) compilation for other platforms, Godot needs to have
access to the Mono cross-compilers for that platform and architecture.

Godot will look for the cross-compiler executable in the AOT compilers folder.
The location of this folder is ``<data_folder>/Tools/aot-compilers/``.

In order to build the cross-compilers we recommend using these
`build scripts <https://github.com/godotengine/godot-mono-builds>`_.

After building them, copy the executable to the Godot AOT compilers directory. The
executable name is ``<triple>-mono-sgen``, e.g.: ``aarch64-apple-darwin-mono-sgen``.

Command-line options
--------------------

The following is the list of command-line options available when building with
the Mono module:

- **module_mono_enabled**\ =yes | **no**

  - Build Godot with the Mono module enabled.

- **mono_glue**\ =\ **yes** | no

  - Whether to include the glue source files in the build
    and define ``MONO_GLUE_DISABLED`` as a preprocessor macro.

- **mono_prefix**\ =path

  - Path to the Mono installation directory for the target platform and architecture.

- **mono_static**\ =yes | no

  - Whether to link the Mono runtime statically.
  - The default is **yes** for iOS and WASM, and **no** for other platforms.

- **copy_mono_root**\ =yes | **no**

  - Whether to copy the Mono framework assemblies
    and configuration files required by the Godot editor.


===================================================
/. ./development/compiling/optimizing_for_size.rst
===================================================

.. _doc_optimizing_for_size:

Optimizing a build for size
===========================

.. highlight:: shell

Rationale
---------

Sometimes, it is desired to optimize a build for size rather than speed.
This means not compiling unused functions from the engine, as well as using
specific compiler flags to aid on decreasing build size.
Common situations include creating builds for mobile and Web platforms.

This tutorial aims to give an overview on different methods to create
a smaller binary. Before continuing, it is recommended to read the previous tutorials
on compiling Godot for each platform.

The options below are listed from the most important (greatest size savings)
to the least important (lowest size savings).

Stripping binaries
------------------

- **Space savings:** Very high
- **Difficulty:** Easy
- **Performed in official builds:** Yes

If you build Windows (MinGW), Linux or macOS binaries from source, remember to
strip debug symbols from binaries by installing the ``strip`` package from your
distribution then running:

::

    strip path/to/godot.binary

On Windows, ``strip.exe`` is included in most MinGW toolchain setups.

This will reduce the size of compiled binaries by a factor between 5× and 10×.
The downside is that crash backtraces will no longer provide accurate information
(which is useful for troubleshooting the cause of a crash).
:ref:`C++ profilers <doc_using_cpp_profilers>` will also no longer be able to display
function names (this does not affect the built-in GDScript profiler).

.. note::

    The above command will not work on Windows binaries compiled with MSVC
    and platforms such as Android and HTML5. Instead, pass ``debug_symbols=no``
    on the SCons command line when compiling.

Optimizing for size instead of speed
------------------------------------

- **Space savings:** High
- **Difficulty:** Easy
- **Performed in official builds:** Yes, but only for HTML5

Godot 3.1 onwards allows compiling using size optimizations (instead of speed).
To enable this, set the ``optimize`` flag to ``size``:

::

    scons p=windows target=release tools=no optimize=size

Some platforms such as WebAssembly already use this mode by default.

Compiling with link-time optimization
-------------------------------------

- **Space savings:** High
- **Difficulty:** Easy
- **Performed in official builds:** Yes

Enabling link-time optimization produces more efficient binaries, both in
terms of performance and file size. It works by eliminating duplicate
template functions and unused code. It can currently be used with the GCC
and MSVC compilers:

::

    scons p=windows target=release tools=no lto=full

Linking becomes much slower and more RAM-consuming with this option,
so it should be used only for release builds:

- When compiling the ``master`` branch, you need to have at least 8 GB of RAM
  available for successful linking with LTO enabled.
- When compiling the ``3.x`` branch, you need to have at least 6 GB of RAM
  available for successful linking with LTO enabled.

Disabling 3D
------------

- **Space savings:** Moderate
- **Difficulty:** Easy
- **Performed in official builds:** No

For 2D games, having the whole 3D engine available usually makes no sense. Because of this, there is a build flag to disable it:

::

    scons p=windows target=release tools=no disable_3d=yes

Tools must be disabled in order to use this flag, as the editor is not designed
to operate without 3D support. Without it, the binary size can be reduced
by about 15%.

Disabling advanced GUI objects
------------------------------

- **Space savings:** Moderate
- **Difficulty:** Easy
- **Performed in official builds:** No

Most small games don't require complex GUI controls such as Tree, ItemList,
TextEdit or GraphEdit. They can be disabled using a build flag:

::

    scons p=windows target=release tools=no disable_advanced_gui=yes

This is everything that will be disabled:

- FileDialog
- PopupMenu
- Tree
- TextEdit
- TreeItem
- OptionButton
- SpinBox
- ColorPicker
- ColorPickerButton
- RichTextLabel
- RichTextEffect
- CharFXTransform
- PopupDialog
- WindowDialog
- AcceptDialog
- ConfirmationDialog
- MarginContainer
- ViewportContainer
- SplitContainer
- HSplitContainer
- GraphNode
- GraphEdit

Disabling unwanted modules
--------------------------

- **Space savings:** Very low to moderate depending on modules
- **Difficulty:** Medium to hard depending on modules
- **Performed in official builds:** No

A lot of Godot's functions are offered as modules.
You can see a list of modules with the following command:

::

    scons --help

The list of modules that can be disabled will appear, together with all
build options. If you are working on a simple 2D game, you could disable
a lot of them:

::

    scons p=windows target=release tools=no module_arkit_enabled=no module_assimp_enabled=no module_bmp_enabled=no module_bullet_enabled=no module_camera_enabled=no module_csg_enabled=no module_dds_enabled=no module_enet_enabled=no module_etc_enabled=no module_gdnative_enabled=no module_gridmap_enabled=no module_hdr_enabled=no module_jsonrpc_enabled=no module_mbedtls_enabled=no module_mobile_vr_enabled=no module_opensimplex_enabled=no module_opus_enabled=no module_pvr_enabled=no module_recast_enabled=no module_regex_enabled=no module_squish_enabled=no module_svg_enabled=no module_tga_enabled=no module_theora_enabled=no module_tinyexr_enabled=no module_upnp_enabled=no module_vhacd_enabled=no module_vorbis_enabled=no module_webm_enabled=no module_webrtc_enabled=no module_websocket_enabled=no module_xatlas_unwrap_enabled=no

If this proves not to work for your use case, you should review the list of
modules and see which ones you actually still need for your game (e.g. you
might want to keep networking-related modules, regex support, or theora/webm
to play videos).

Alternatively, you can supply a list of disabled modules by creating
``custom.py`` at the root of the source, with the contents similar to the
following:

.. code-block:: python

    # custom.py

    module_arkit_enabled = "no"
    module_assimp_enabled = "no"
    module_bmp_enabled = "no"
    module_bullet_enabled = "no"
    module_camera_enabled = "no"
    module_csg_enabled = "no"
    module_dds_enabled = "no"
    module_enet_enabled = "no"
    module_etc_enabled = "no"
    module_gdnative_enabled = "no"
    module_gridmap_enabled = "no"
    module_hdr_enabled = "no"
    module_jsonrpc_enabled = "no"
    module_mbedtls_enabled = "no"
    module_mobile_vr_enabled = "no"
    module_opensimplex_enabled = "no"
    module_opus_enabled = "no"
    module_pvr_enabled = "no"
    module_recast_enabled = "no"
    module_regex_enabled = "no"
    module_squish_enabled = "no"
    module_svg_enabled = "no"
    module_tga_enabled = "no"
    module_theora_enabled = "no"
    module_tinyexr_enabled = "no"
    module_upnp_enabled = "no"
    module_vhacd_enabled = "no"
    module_vorbis_enabled = "no"
    module_webm_enabled = "no"
    module_webrtc_enabled = "no"
    module_websocket_enabled = "no"
    module_xatlas_unwrap_enabled = "no"

.. seealso::

    :ref:`doc_overriding_build_options`.


===================================================
/. ./development/compiling/compiling_with_script_encryption_key.rst
===================================================

.. _doc_compiling_with_script_encryption_key:

Compiling with script encryption key
====================================

.. highlight:: shell

The export dialog gives you the option to encrypt your scripts with a 256-bit
AES key when releasing your project. This will make sure your scripts are not
stored in plain text and can not easily be ripped by some script kiddie.

Of course, the key needs to be stored in the binary, but if it's compiled,
optimized and without symbols, it would take some effort to find it.

For this to work, you need to build the export templates from source,
with that same key.

.. warning::

    This will **not** work if you use official, precompiled export templates.
    It is absolutely **required** to compile your own export templates to use
    PCK encryption.

Step by step
------------

1. Generate a 256-bit AES key in hexadecimal format. You can use the aes-256-cbc variant from
   `this service <https://asecuritysite.com/encryption/keygen>`_.

   Alternatively, you can generate it yourself using
   `OpenSSL <https://www.openssl.org/>`__ command-line tools:

   ::

       openssl rand -hex 32 > godot.gdkey

   The output in ``godot.gdkey`` should be similar to:

   ::

       # NOTE: Do not use the key below! Generate your own key instead.
       aeb1bc56aaf580cc31784e9c41551e9ed976ecba10d315db591e749f3f64890f

   You can generate the key without redirecting the output to a file, but
   that way you can minimize the risk of exposing the key.

2. Set this key as environment variable in the console that you will use to
   compile Godot, like this:

   .. tabs::
    .. code-tab:: bash Linux/macOS

       export SCRIPT_AES256_ENCRYPTION_KEY="your_generated_key"

    .. code-tab:: bat Windows (cmd)

       set SCRIPT_AES256_ENCRYPTION_KEY=your_generated_key

    .. code-tab:: bat Windows (PowerShell)

       $env:SCRIPT_AES256_ENCRYPTION_KEY="your_generated_key"

3. Compile Godot export templates and set them as custom export templates
   in the export preset options.

4. Set the encryption key in the **Script** tab of the export preset:

   .. image:: img/script_encryption_key.png

5. Export the project. The game should run with encrypted scripts now.

Troubleshooting
---------------

If you get an error like below, it means the key wasn't properly included in
your Godot build. Godot is encrypting the scripts during export, but can't read
them at runtime.

::

   ERROR: open_and_parse: Condition "String::md5(md5.digest) != String::md5(md5d)" is true. Returning: ERR_FILE_CORRUPT
      At: core/io/file_access_encrypted.cpp:103
   ERROR: load_byte_code: Condition ' err ' is true. returned: err
      At: modules/gdscript/gdscript.cpp:755
   ERROR: load: Condition ' err != OK ' is true. returned: RES()
      At: modules/gdscript/gdscript.cpp:2135
   ERROR: Failed loading resource: res://Node2D.gde
      At: core/io/resource_loader.cpp:279
   ERROR: poll: res://Node2D.tscn:3 - Parse Error: [ext_resource] referenced nonexistent resource at: res://Node2D.gd
      At: scene/resources/scene_format_text.cpp:439
   ERROR: load: Condition ' err != OK ' is true. returned: RES()
      At: core/io/resource_loader.cpp:202
   ERROR: Failed loading resource: res://Node2D.tscn
      At: core/io/resource_loader.cpp:279
   ERROR: Failed loading scene: res://Node2D.tscn
      At: main/main.cpp:1727
   WARNING: cleanup: ObjectDB Instances still exist!
        At: core/object.cpp:2081
   ERROR: clear: Resources Still in use at Exit!
      At: core/resource.cpp:425


===================================================
/. ./development/cpp/index.rst
===================================================

Engine development
==================

Setting up a development environment
------------------------------------

To modify Godot's source code, you need to set up a development environment. Start here.

.. toctree::
   :maxdepth: 1
   :name: toc-devel-cpp-dev-env

   configuring_an_ide/index

Getting started with Godot's source code
----------------------------------------

This section covers the basics that you will encounter in (almost) every source file.

.. toctree::
   :maxdepth: 1
   :name: toc-devel-cpp-source-beginner

   introduction_to_godot_development
   common_engine_methods_and_macros
   core_types
   variant_class
   object_class
   inheritance_class_tree

Extending Godot by modifying its source code
---------------------------------------------

This section covers what you can do by modifying Godot's C++ source code.

.. toctree::
   :maxdepth: 1
   :name: toc-devel-cpp-source-advanced

   custom_modules_in_cpp
   binding_to_external_libraries
   custom_godot_servers
   custom_resource_format_loaders
   custom_audiostreams

Debugging and profiling
-----------------------

This section is about finding spots to optimize in the engine code when you need it in your project.

.. toctree::
   :maxdepth: 1
   :name: toc-devel-cpp-debug-profiling

   macos_debug
   using_cpp_profilers


===================================================
/. ./development/cpp/configuring_an_ide/index.rst
===================================================

Configuring an IDE
==================

We assume that you have already `cloned <https://github.com/godotengine/godot>`_
and :ref:`compiled <toc-devel-compiling>` Godot.

You can easily develop Godot with any text editor and by invoking ``scons``
on the command line, but if you want to work with an IDE (Integrated
Development Environment), here are setup instructions for some popular ones:

.. toctree::
   :maxdepth: 1
   :name: toc-devel-configuring_an_ide

   android_studio
   clion
   code_blocks
   kdevelop
   qt_creator
   visual_studio
   visual_studio_code
   xcode

It is possible to use other IDEs, but their setup is not documented yet.


===================================================
/. ./development/cpp/configuring_an_ide/android_studio.rst
===================================================

.. _doc_configuring_an_ide_android_studio:

Android Studio
==============

`Android Studio <https://developer.android.com/studio>`_ is a free
`JetBrains <https://www.jetbrains.com/>`_ IDE for Android development.
It has a feature-rich editor which supports Java and C/C++. It can be used to
work on Godot's core engine as well as the Android platform codebase.

Importing the project
---------------------

- From the Android Studio's welcome window select **Open an existing 
  Android Studio project**.

.. figure:: img/android_studio_setup_project_1.png
   :figclass: figure-w480
   :align: center
   
   Android Studio's welcome window.

- Navigate to ``<Godot root directory>/platform/android/java`` and select the ``settings.gradle`` file.
- Android Studio will import and index the project.
- To build the project, follow the :ref:`compiling instructions <toc-devel-compiling>`.

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/configuring_an_ide/clion.rst
===================================================

.. _doc_configuring_an_ide_clion:

CLion
=====

`CLion <https://www.jetbrains.com/clion/>`_ is a commercial 
`JetBrains <https://www.jetbrains.com/>`_ IDE for C++.

Importing the project
---------------------

CLion requires a ``CMakeLists.txt`` file as a project file, which is problematic
for Godot because it uses the SCons buildsystem instead of CMake. However, 
there is a ``CMakeLists.txt`` configuration for :ref:`Android Studio <doc_configuring_an_ide_android_studio>` 
which can also be used by CLion.

- From the CLion's welcome window choose the option to import an existing 
  project. If you've already opened another project, choose **File > Open**
  from the top menu.
- Navigate to ``<Godot root directory>/platform/android/java/nativeSrcsConfigs`` (the
  ``CMakeLists.txt`` file is located there) and select it (but *not* the
  ``CMakeLists.txt`` file itself), then click **OK**.

.. figure:: img/clion_1_open.png
   :align: center

   The folder containing the ``CMakeLists.txt`` file.

- If this popup window appears, select **This Window** to open the project:

.. figure:: img/clion_2_this_window.png
   :align: center

- Choose **Tools > CMake > Change Project Root** from the top menu and select 
  the Godot root folder.

.. figure:: img/clion_3_change_project_root.png
   :align: center

- You should be now be able to see all the project files. Autocomplete should
  work once the project has finished indexing.

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.

Debugging the project
---------------------

Since CLion does not support SCons, you won't be able to compile, launch, and debug Godot from CLion in one step.
You will first need to `compile godot yourself <https://docs.godotengine.org/en/stable/development/compiling/index.html>`__ and run the binary without CLion. You will then be able to debug Godot by using the `Attach to process <https://www.jetbrains.com/help/clion/attaching-to-local-process.html>`__ feature.

- Run the compilation in debug mode by entering ``scons``.

- Run the binary you have created (in the bin directory). If you want to debug a specific project, run the binary with the following arguments : ``--editor --path path/to/your/godot/project``. To run the project instead of editing it, remove the ``--editor`` argument.

- In CLion, go to **Run > Attach to Process...**

.. figure:: img/clion_4_select_attach_to_process.png
   :align: center

- Find and Select godot in the list (or type the binary name/Process ID)

.. figure:: img/clion_5_select_godot_process.png
   :align: center

You can now use the debugging tools from CLion.

.. note::

    If you run the binary without any arguments, you will only debug the project manager window.
    Don't forget to add the ``--path path/to/your/godot/project`` argument to debug a project.


===================================================
/. ./development/cpp/configuring_an_ide/code_blocks.rst
===================================================

.. _doc_configuring_an_ide_code_blocks:

Code::Blocks
============

`Code::Blocks <https://codeblocks.org/>`_ is a free, open source, cross platform IDE.

Creating a new project
----------------------

From Code::Blocks' main screen, click **Create a new project** or select **File > New > Project...**.

.. figure:: img/code_blocks_file_new_project.png
   :figclass: figure-w480
   :align: center

In the **New from template** window, from **Projects**, select **Empty project**, and click **Go**.

.. figure:: img/code_blocks_new_empty_project.png
   :figclass: figure-w480
   :align: center

Click Next, to pass the welcome to the new empty project wizard.

.. figure:: img/code_blocks_wizard_welcome.png
   :figclass: figure-w480
   :align: center

The project file should be created in the root of the cloned project folder. To achieve this, first, ensure that the **Project title** is the same as the folder name that Godot was cloned into. Unless you cloned the project into a folder with a different name, this will be ``godot``.

Second, ensure that the **Folder to create project in** is the folder you ran the Git clone command from, not the ``godot`` project folder. Confirm that the **Resulting filename** field will create the project file in the root of the cloned project folder.

.. figure:: img/code_blocks_project_title_and_location.png
   :figclass: figure-w480
   :align: center

The compiler and configuration settings are managed through **SCons** and will be configured later. However, it's worth deselecting the **Create "Release" configuration** option; so only a single build target is created before clicking **Finish**.

.. figure:: img/code_blocks_compiler_and_configuration.png
   :figclass: figure-w480
   :align: center

Configuring the build
---------------------

The first step is to change the project properties. Right-click on the new project and select **Properties...**.

.. figure:: img/code_blocks_open_properties.png
   :figclass: figure-w480
   :align: center

Check the **This is a custom Makefile** property. Click OK to save the changes.

.. figure:: img/code_blocks_project_properties.png
   :figclass: figure-w480
   :align: center

The next step is to change the build options. Right-click on the new project and select **Build Options...**.

.. figure:: img/code_blocks_open_build_options.png
   :figclass: figure-w480
   :align: center

Select the **"Make" commands** tab and remove all the existing commands for all the build targets. For each build target enter the **SCons** command for creating the desired build in the **Build project/target** field. The minimum is ``scons``. For details on the **SCons** build options, see :ref:`doc_introduction_to_the_buildsystem`. It's also useful to add the ``scons --clean`` command in the **Clean project/target** field to the project's default commmands.

If you're using Windows, all the commands need to be preceded with ``cmd /c`` to iniitalize the command interpreter.

.. figure:: img/code_blocks_scons_minimum.png
   :figclass: figure-w480
   :align: center

.. figure:: img/code_blocks_scons_clean.png
   :figclass: figure-w480
   :align: center

Windows example:

.. figure:: img/code_blocks_scons_windows.png
   :figclass: figure-w480
   :align: center

Code::Blocks should now be configured to build Godot; so either select **Build > Build**, click the gear button, or press :kbd:`Ctrl + F9`.

Configuring the run
-------------------

Once **SCons** has successfully built the desired target, reopen the project **Properties...** and select the **Build targets** tab. In the **Output filename** field, browse to the ``bin`` folder and select the compiled file.

Deselect the **Auto-generate filename prefix** and **Auto-generate filename extension** options.

.. figure:: img/code_blocks_build_targets.png
   :figclass: figure-w480
   :align: center

Code::Blocks should now be configured to run your compiled Godot executable; so either select **Build > Run**, click the green arrow button, or press :kbd:`Ctrl + F10`.

There are two additional points worth noting. First, if required, the **Execution working dir** field can be used to test specific projects, by setting it to the folder containing the ``project.godot`` file. Second, the **Build targets** tab can be used to add and remove build targets for working with and creating different builds.

Adding files to the project
---------------------------

To add all the Godot code files to the project, right-click on the new project and select **Add files recursively...**.

.. figure:: img/code_blocks_add_files_recursively.png
   :figclass: figure-w480
   :align: center

It should automatically select the project folder; so simply click **Open**. By default, all code files are included, so simply click **OK**.

.. figure:: img/code_blocks_select_files.png
   :figclass: figure-w480
   :align: center

Code style configuration
------------------------

Before editing any files, remember that all code needs to comply with the :ref:`doc_code_style_guidelines`. One important difference with Godot is the use of tabs for indents. Therefore, the key default editor setting that needs to be changed in Code::Blocks is to enable tabs for indents. This setting can be found by selecting **Settings > Editor**.

.. figure:: img/code_blocks_update_editor_settings.png
   :figclass: figure-w480
   :align: center

Under **General Settings**, on the **Editor Settings** tab, under **Tab Options** check **Use TAB character**.

.. figure:: img/code_block_use_tab_character.png
   :figclass: figure-w480
   :align: center

That's it. You're ready to start contributing to Godot using the Code::Blocks IDE. Remember to save the project file and the **Workspace**. If you run into any issues, ask for help in one of `Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/configuring_an_ide/kdevelop.rst
===================================================

.. _doc_configuring_an_ide_kdevelop:

KDevelop
========

`KDevelop <https://www.kdevelop.org>`_ is a free, open source IDE for all desktop platforms.

Importing the project
---------------------

- From the KDevelop's main screen select **Open Project**.

.. figure:: img/kdevelop_newproject.png
   :figclass: figure-w480
   :align: center

   KDevelop's main screen.

- Navigate to the Godot root folder and select it.
- On the next screen, choose **Custom Build System** for the **Project Manager**.

.. figure:: img/kdevelop_custombuild.png
   :figclass: figure-w480
   :align: center

- After the project has been imported, open the project configuration by right-clicking 
  on it in the **Projects** panel and selecting **Open Configuration..** option.

.. figure:: img/kdevelop_openconfig.png
   :figclass: figure-w480
   :align: center

- Under **Language Support** open the **Includes/Imports** tab and add the following paths:

  .. code-block:: none

     .  // A dot, to indicate the root of the Godot project
     core/
     core/os/
     core/math/
     drivers/
     platform/<your_platform>/  // Replace <your_platform> with a folder 
                                   corresponding to your current platform

.. figure:: img/kdevelop_addincludes.png
   :figclass: figure-w480
   :align: center

- Apply the changes.
- Under **Custom Build System** add a new build configuration with the following settings:

  +-----------------+------------------------------------------------------------------------------+
  | Build Directory | *blank*                                                                      |
  +-----------------+------------------------------------------------------------------------------+
  | Enable          | **True**                                                                     |
  +-----------------+------------------------------------------------------------------------------+
  | Executable      | **scons**                                                                    |
  +-----------------+------------------------------------------------------------------------------+
  | Arguments       | See :ref:`doc_introduction_to_the_buildsystem` for a full list of arguments. |
  +-----------------+------------------------------------------------------------------------------+

.. figure:: img/kdevelop_buildconfig.png
   :figclass: figure-w480
   :align: center

- Apply the changes and close the configuration window.

Debugging the project
---------------------

- Select **Run > Configure Launches...** from the top menu.

.. figure:: img/kdevelop_configlaunches.png
   :figclass: figure-w480
   :align: center

- Click **Add** to create a new launch configuration.
- Select **Executable** option and specify the path to your executable located in 
  the ``<Godot root directory>/bin`` folder. The name depends on your build configuration,
  e.g. ``godot.x11.tools.64`` for 64-bit X11 platform with ``tools`` enabled.

.. figure:: img/kdevelop_configlaunches2.png
   :figclass: figure-w480
   :align: center

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/configuring_an_ide/qt_creator.rst
===================================================

.. _doc_configuring_an_ide_qtcreator:

Qt Creator
==========

`Qt Creator <https://doc.qt.io/qtcreator/index.html>`_ is a free, open source IDE for all desktop platforms.

Importing the project
---------------------

- From the Qt Creator's main screen select **New Project > Import Project > Import Existing Project**.

.. figure:: img/qtcreator-new-project.png
   :figclass: figure-w480
   :align: center

- Under **Location** select the Godot root folder.

.. figure:: img/qtcreator-set-project-path.png
   :figclass: figure-w480
   :align: center

- Next, you can choose which folders and files will be visible to the project.
  While C/C++ files are added automatically, other extensions can be potentially useful:
  ``*.glsl`` for shader files, ``*.py`` for buildsystem files,
  ``*.java`` for Android platform development, ``*.mm`` for macOS platform development.

.. figure:: img/qtcreator-apply-import-filter.png
   :figclass: figure-w480
   :align: center

.. note:: You can change this configuration later by right-clicking on your project
          and selecting the **Edit Files...** option.

          .. figure:: img/qtcreator-edit-files-menu.png
            :figclass: figure-w480
            :align: center


- Finish the import.
- Open the ``project_name.includes`` file and add a line containing ``.`` to it
  to correctly enable the code completion.

.. figure:: img/qtcreator-project-name-includes.png
   :figclass: figure-w480
   :align: center

- From the left-side menu select **Projects** and open the **Build** tab.
- Delete the predefined ``make`` build step.

.. figure:: img/qtcreator-projects-build.png
   :figclass: figure-w480
   :align: center

- Click **Add Build Step > Custom Process Step** to add a new build step 
  with the following settings:

  +-----------+------------------------------------------------------------------------------+
  | Command   | **scons**                                                                    |
  +-----------+------------------------------------------------------------------------------+
  | Arguments | See :ref:`doc_introduction_to_the_buildsystem` for a full list of arguments. |
  +-----------+------------------------------------------------------------------------------+

.. figure:: img/qtcreator-set-scons-command.png
   :figclass: figure-w480
   :align: center

.. note:: If the build fails with ``Could not start process "scons"``, it can mean that ``scons`` 
          is not in your ``PATH`` environment variable. In this case, you'll have to specify the
          full path to the SCons binary.

Debugging the project
---------------------

- From the left-side menu select **Projects** and open the **Run** tab.
- Under **Executable** specify the path to your executable located in 
  the ``<Godot root directory>/bin`` folder. The name depends on your build configuration,
  e.g. ``godot.x11.tools.64`` for 64-bit X11 platform with ``tools`` enabled.
  You can use ``%{buildDir}`` to reference the project root, e.g: ``%{buildDir}/bin/godot.x11.opt.tools.64``.
- If you want to run a specific project, specify its root folder under **Working directory**.
- If you want to run the editor, add ``-e`` to the **Command line arguments** field.

.. figure:: img/qtcreator-run-command.png
   :figclass: figure-w480
   :align: center

To learn more about command line arguments, refer to the
:ref:`command line tutorial <doc_command_line_tutorial>`.

Code style configuration
------------------------

Developers must follow the project's :ref:`code style <doc_code_style_guidelines>`
and the IDE should help them follow it. By default, Qt Creator uses spaces
for indentation which doesn't match the Godot code style guidelines. You can
change this behavior by changing the **Code Style** in **Tools > Options > C++**.

.. figure:: img/qtcreator-options-cpp.png
   :figclass: figure-w480
   :align: center

Click on **Edit** to change the current settings, then click on
**Copy Built-in Code Style** button to set a new code style. Set a name for it
(e.g. Godot) and change the Tab policy to be **Tabs Only**.

.. figure:: img/qtcreator-edit-codestyle.png
   :figclass: figure-w480
   :align: center

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/configuring_an_ide/visual_studio.rst
===================================================

.. _doc_configuring_an_ide_vs:

Visual Studio
=============

`Visual Studio Community <https://visualstudio.microsoft.com>`__ is a Windows-only IDE
by `Microsoft <https://microsoft.com>`_ that's free for individual use or non-commercial use within organizations.
It has many useful features, such as memory view, performance view, source
control and more.

Importing the project
---------------------

Visual Studio requires a solution file to work on a project. While Godot does not come
with the solution file, it can be generated using SCons.

- Navigate to the Godot root folder and open a Command Prompt or PowerShell window.
- Run ``scons platform=windows vsproj=yes`` to generate the solution.
- You can now open the project by double-clicking on the ``godot.sln`` in the project root
  or by using the **Open a project or solution** option inside of the Visual Studio.
- Use the **Build** top menu to build the project.

.. warning:: Visual Studio must be configured with the C++ package. It can be selected
             in the intaller:

             .. figure:: img/vs_1_install_cpp_package.png
                :align: center

Debugging the project
---------------------

Visual Studio features a powerful debugger. This allows the user to examine Godot's
source code, stop at specific points in the code, inspect the current execution context,
and make live changes to the codebase.

You can launch the project with the debugger attached using the **Debug > Start Debugging**
option from the top menu. However, unless you want to debug the project manager specifically,
you'd need to configure debugging options first. This is due to the fact that when the Godot
project manager opens a project, the initial process is terminated and the debugger gets detached.

- To configure the launch options to use with the debugger use **Project > Properties**
  from the top menu:

.. figure:: img/vs_2_project_properties.png
   :align: center

- Open the **Debugging** section and under **Command Arguments** add two new arguments:
  the ``-e`` flag opens the editor instead of the project manager, and the ``--path`` argument
  tells the executable to open the specified project (must be provided as an *absolute* path
  to the project root, not the ``project.godot`` file).

.. figure:: img/vs_3_debug_command_line.png
   :align: center

To learn more about command line arguments, refer to the
:ref:`command line tutorial <doc_command_line_tutorial>`.

Even if you start the project without a debugger attached it can still be connected to the running
process using **Debug > Attach to Process...** menu.

To check that everything is working, put a breakpoint in ``main.cpp`` and press :kbd:`F5` to
start debugging.

.. figure:: img/vs_4_debugging_main.png
   :align: center

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/configuring_an_ide/visual_studio_code.rst
===================================================

.. _doc_configuring_an_ide_vscode:

Visual Studio Code
==================

`Visual Studio Code <https://code.visualstudio.com>`_ is a free cross-platform code editor
by `Microsoft <https://microsoft.com>`_ (not to be confused with :ref:`doc_configuring_an_ide_vs`).

Importing the project
---------------------

- Make sure the C/C++ extension is installed. You can find instructions in
  the `official documentation <https://code.visualstudio.com/docs/languages/cpp>`_.
  Alternatively, `clangd <https://open-vsx.org/extension/llvm-vs-code-extensions/vscode-clangd>`_
  can be used instead.
- When using the clangd extension, run ``scons compiledb=yes``.
- From the Visual Studio Code's main screen open the Godot root folder with
  **File > Open Folder...**.
- Press :kbd:`Ctrl + Shift + P` to open the command prompt window and enter *Configure Task*.

.. figure:: img/vscode_configure_task.png
   :align: center

- Select the **Create tasks.json file from template** option.

.. figure:: img/vscode_create_tasksjson.png
   :align: center

- Then select **Others**.

.. figure:: img/vscode_create_tasksjson_others.png
   :align: center

- Within the ``tasks.json`` file find the ``"tasks"`` array and add a new section to it:

.. code-block:: js

    {
      "label": "build",
      "group": "build",
      "type": "shell",
      "command": "scons",
      "problemMatcher": "$msCompile"
    }

.. figure:: img/vscode_3_tasks.json.png
   :figclass: figure-w480
   :align: center

   An example of a filled out ``tasks.json``.

Arguments can be different based on your own setup and needs. See
:ref:`doc_introduction_to_the_buildsystem` for a full list of arguments.

Debugging the project
---------------------

To run and debug the project you need to create a new configuration in the ``launch.json`` file.

- Press :kbd:`Ctrl + Shift + D` to open the Run panel.
- If ``launch.json`` file is missing you will be prompted to create a new one.

.. figure:: img/vscode_1_create_launch.json.png
   :align: center

- Select **C++ (GDB/LLDB)**. There may be another platform specific option here. If selected,
  adjust the configuration example provided accordingly.
- Within the ``launch.json`` file find the ``"configurations"`` array and add a new section to it:

.. tabs::
  .. code-tab:: js X11

    {
      "name": "Launch Project",
      "type": "lldb",
      "request": "launch",
      // Change to godot.x11.tools.64.llvm for llvm-based builds.
      "program": "${workspaceFolder}/bin/godot.x11.tools.64",
      // Change the arguments below for the project you want to test with.
      // To run the project instead of editing it, remove the "--editor" argument.
      "args": [ "--editor", "--path", "path-to-your-godot-project-folder" ],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "preLaunchTask": "build"
    }
  .. code-tab:: js X11_gdb

    {
      "name": "Launch Project",
      "type": "cppdbg",
      "request": "launch",
      // Change to godot.x11.tools.64.llvm for llvm-based builds.
      "program": "${workspaceFolder}/bin/godot.x11.tools.64",
      // Change the arguments below for the project you want to test with.
      // To run the project instead of editing it, remove the "--editor" argument.
      "args": [ "--editor", "--path", "path-to-your-godot-project-folder" ],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "setupCommands":
      [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "build"
    }

  .. code-tab:: js Windows

    {
      "name": "Launch Project",
      "type": "cppvsdbg",
      "request": "launch",
      "program": "${workspaceFolder}/bin/godot.windows.tools.64.exe",
      // Change the arguments below for the project you want to test with.
      // To run the project instead of editing it, remove the "--editor" argument.
      "args": [ "--editor", "--path", "path-to-your-godot-project-folder" ],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "console": "internalConsole",
      "visualizerFile": "${workspaceFolder}/platform/windows/godot.natvis",
      "preLaunchTask": "build"
    }

.. figure:: img/vscode_2_launch.json.png
   :figclass: figure-w480
   :align: center

   An example of a filled out ``launch.json``.


.. note::

    Due to sporadic performance issues, it is recommended to use LLDB over GDB on Unix-based systems.
    Make sure that the `CodeLLDB extension <https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb>`_
    is installed.

    If you encounter issues with lldb, you may consider using gdb (see the X11_gdb configuration).

    Do note that lldb may work better with llvm-based builds. See :ref:`doc_compiling_for_x11` for further information.

The name under ``program`` depends on your build configuration,
e.g. ``godot.x11.tools.64`` for 64-bit X11 platform with ``tools`` enabled.

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/configuring_an_ide/xcode.rst
===================================================

.. _doc_configuring_an_ide_xcode:

Xcode
=====

`Xcode <https://developer.apple.com/xcode>`_ is a free macOS-only IDE. You can 
download it from the Mac App Store.

Importing the project
---------------------

- From Xcode's main screen create a new project using the **Other > External Build System** template.

.. figure:: img/xcode_1_create_external_build_project.png
   :figclass: figure-w480
   :align: center

- Open your build targets from the **Targets** section and select the **Info** tab.
- Fill out the form with the following settings:

  +------------+------------------------------------------------------------------------------+
  | Build Tool | A full path to the **scons** executable, e.g. **/usr/local/bin/scons**       |
  +------------+------------------------------------------------------------------------------+
  | Arguments  | See :ref:`doc_introduction_to_the_buildsystem` for a full list of arguments. |
  +------------+------------------------------------------------------------------------------+
  | Directory  | A full path to the Godot root folder                                         |
  +------------+------------------------------------------------------------------------------+

.. figure:: img/xcode_2_configure_scons.png
   :figclass: figure-w480
   :align: center

- Add a Command Line Tool target which will be used for indexing the project by
  choosing **File > New > Target...**.

.. figure:: img/xcode_3_add_new_target.png
   :figclass: figure-w480
   :align: center

- Select **OS X > Application > Command Line Tool**.

.. figure:: img/xcode_4_select_command_line_target.png
   :figclass: figure-w480
   :align: center

.. note:: Name it something so you know not to compile with this target (e.g. ``GodotXcodeIndex``).

- For this target open the **Build Settings** tab and look for **Header Search Paths**.
- Set **Header Search Paths** to the absolute path to the Godot root folder. You need to
  include subdirectories as well. To achieve that, add two two asterisks (``**``) to the 
  end of the path, e.g. ``/Users/me/repos/godot-source/**``.

- Add the Godot source to the project by dragging and dropping it into the project file browser.
- Uncheck **Create external build system project**.

.. figure:: img/xcode_5_after_add_godot_source_to_project.png
   :figclass: figure-w480
   :align: center

- Next select **Create groups** for the **Added folders** option and check *only* 
  your command line indexing target in the **Add to targets** section.

.. figure:: img/xcode_6_after_add_godot_source_to_project_2.png
   :figclass: figure-w480
   :align: center

- Xcode will now index the files. This may take a few minutes.
- Once Xcode is done indexing, you should have jump-to-definition,
  autocompletion, and full syntax highlighting.

Debugging the project
---------------------

To enable debugging support you need to edit the external build target's build and run schemes.

- Open the scheme editor of the external build target.
- Locate the **Build > Post Actions** section.
- Add a new script run action
- Under **Provide build settings from** select your project. This allows to reference 
  the project directory within the script.
- Create a script that will give the binary a name that Xcode can recognize, e.g.:

.. code-block:: shell

  ln -f ${PROJECT_DIR}/godot/bin/godot.osx.tools.64 ${PROJECT_DIR}/godot/bin/godot

.. figure:: img/xcode_7_setup_build_post_action.png
   :figclass: figure-w480
   :align: center

- Build the external build target.

- Open the scheme editor again and select **Run**.

.. figure:: img/xcode_8_setup_run_scheme.png
   :figclass: figure-w480
   :align: center

- Set the **Executable** to the file you linked in your post-build action script.
- Check **Debug executable**.
- You can add two arguments on the **Arguments** tab:
  the ``-e`` flag opens the editor instead of the project manager, and the ``--path`` argument
  tells the executable to open the specified project (must be provided as an *absolute* path 
  to the project root, not the ``project.godot`` file).

To check that everything is working, put a breakpoint in ``platform/osx/godot_main_osx.mm`` and
run the project.

If you run into any issues, ask for help in one of
`Godot's community channels <https://godotengine.org/community>`__.


===================================================
/. ./development/cpp/introduction_to_godot_development.rst
===================================================

.. _doc_introduction_to_godot_development:

Introduction to Godot development
=================================

This page is meant to introduce the global organization of Godot Engine's
source code, and give useful tips for extending/fixing the engine on the
C++ side.

Architecture diagram
--------------------

The following diagram describes the architecture used by Godot, from the
core components down to the abstracted drivers, via the scene
structure and the servers.

.. image:: img/architecture_diagram.jpg

Debugging the editor with gdb
-----------------------------

If you are writing or correcting bugs affecting Godot Engine's editor,
remember that the binary will by default run the project manager first,
and then only run the editor in another process once you've selected a
project. To launch a project directly, you need to run the editor by
passing the ``-e`` argument to Godot Engine's binary from within your
project's folder. Typically:

.. code-block:: none

    $ cd ~/myproject
    $ gdb godot
    > run -e

Or:

.. code-block:: none

    $ gdb godot
    > run -e --path ~/myproject


===================================================
/. ./development/cpp/common_engine_methods_and_macros.rst
===================================================

.. _doc_common_engine_methods_and_macros:

Common engine methods and macros
================================

Godot's C++ codebase makes use of dozens of custom methods and macros which are
used in almost every file. This page is geared towards beginner contributors,
but it can also be useful for those writing custom C++ modules.

Print text
----------

.. code-block:: cpp

    // Prints a message to standard output.
    print_line("Message");

    // Prints a message to standard output, but only when the engine
    // is started with the `--verbose` command line argument.
    print_verbose("Message");

    // Prints a formatted error or warning message with a trace.
    ERR_PRINT("Message");
    WARN_PRINT("Message");

    // Prints an error or warning message only once per session.
    // This can be used to avoid spamming the console output.
    ERR_PRINT_ONCE("Message");
    WARN_PRINT_ONCE("Message");

If you need to add placeholders in your messages, use format strings as
described below.

Format a string
---------------

The ``vformat()`` function returns a formatted :ref:`class_String`. It behaves
in a way similar to C's ``sprintf()``:

.. code-block:: cpp

    vformat("My name is %s.", "Godette");
    vformat("%d bugs on the wall!", 1234);
    vformat("Pi is approximately %f.", 3.1416);

    // Converts the resulting String into a `const char *`.
    // You may need to do this if passing the result as an argument
    // to a method that expects a `const char *` instead of a String.
    vformat("My name is %s.", "Godette").c_str();

In most cases, try to use ``vformat()`` instead of string concatenation as it
makes for more readable code.

Convert an integer or float to a string
---------------------------------------

This is mainly useful when printing numbers directly.

.. code-block:: cpp

    // Prints "42" using integer-to-string conversion.
    print_line(itos(42));

    // Prints "123.45" using real-to-string conversion.
    print_line(rtos(123.45));

Internationalize a string
-------------------------

There are two types of internationalization in Godot's codebase:

- ``TTR()``: **Editor ("tools") translations** will only be processed in the
  editor. If a user uses the same text in one of their projects, it won't be
  translated if they provide a translation for it. When contributing to the
  engine, this is generally the macro you should use for localizable strings.
- ``RTR()``: **Run-time translations** will be automatically localized in
  projects if they provide a translation for the given string. This kind of
  translation shouldn't be used in editor-only code.

.. code-block:: cpp

    // Returns the translated string that matches the user's locale settings.
    // Translations are located in `editor/translations`.
    // The localization template is generated automatically; don't modify it.
    TTR("Exit the editor?");

To insert placeholders in localizable strings, wrap the localization macro in a
``vformat()`` call as follows:

.. code-block:: cpp

    String file_path = "example.txt";
    vformat(TTR("Couldn't open \"%s\" for reading."), file_path);

.. note::

    When using ``vformat()`` and a translation macro together, always wrap the
    translation macro in ``vformat()``, not the other way around. Otherwise, the
    string will never match the translation as it will have the placeholder
    already replaced when it's passed to TranslationServer.

Clamp a value
-------------

Godot provides macros for clamping a value with a lower bound (``MAX``), an
upper bound (``MIN``) or both (``CLAMP``):

.. code-block:: cpp

    int a = 3;
    int b = 5;

    MAX(b, 6); // 6
    MIN(2, a); // 2
    CLAMP(a, 10, 30); // 10

This works with any type that can be compared to other values (like ``int`` and
``float``).

Microbenchmarking
-----------------

If you want to benchmark a piece of code but don't know how to use a profiler,
use this snippet:

.. code-block:: cpp

    uint64_t begin = OS::get_singleton()->get_ticks_usec();

    // Your code here...

    uint64_t end = OS::get_singleton()->get_ticks_usec();
    print_line(vformat("Snippet took %d microseconds", end - begin));

This will print the time spent between the ``begin`` declaration and the ``end``
declaration.

.. note::

    You may have to ``#include "core/os/os.h"`` if it's not present already.

    When opening a pull request, make sure to remove this snippet as well as the
    include if it wasn't there previously.

Get project/editor settings
---------------------------

There are four macros available for this:

.. code-block:: cpp

    // Returns the specified project setting's value,
    // defaulting to `false` if it doesn't exist.
    GLOBAL_DEF("section/subsection/value", false);

    // Returns the specified editor setting's value,
    // defaulting to "Untitled" if it doesn't exist.
    EDITOR_DEF("section/subsection/value", "Untitled");

If a default value has been specified elsewhere, don't specify it again to avoid
repetition:

.. code-block:: cpp

    // Returns the value of the project setting.
    GLOBAL_GET("section/subsection/value");
    // Returns the value of the editor setting.
    EDITOR_GET("section/subsection/value");

It's recommended to use ``GLOBAL_DEF``/``EDITOR_DEF`` only once per setting and
use ``GLOBAL_GET``/``EDITOR_GET`` in all other places where it's referenced.

Error macros
------------

Godot features many error macros to make error reporting more convenient.

.. warning::

    Conditions in error macros work in the **opposite** way of GDScript's
    built-in ``assert()`` function. An error is reached if the condition inside
    evaluates to ``true``, not ``false``.

.. note::

    Only variants with custom messages are documented here, as these should
    always be used in new contributions. Make sure the custom message provided
    includes enough information for people to diagnose the issue, even if they
    don't know C++. In case a method was passed invalid arguments, you can print
    the invalid value in question to ease debugging.

    For internal error checking where displaying a human-readable message isn't
    necessary, remove ``_MSG`` at the end of the macro name and don't supply a
    message argument.

    Also, always try to return processable data so the engine can keep running
    well.

.. code-block:: cpp

    // Conditionally prints an error message and returns from the function.
    // Use this in methods which don't return a value.
    ERR_FAIL_COND_MSG(!mesh.is_valid(), vformat("Couldn't load mesh at: %s", path));

    // Conditionally prints an error message and returns `0` from the function.
    // Use this in methods which must return a value.
    ERR_FAIL_COND_V_MSG(rect.x < 0 || rect.y < 0, 0,
            "Couldn't calculate the rectangle's area.");

    // Prints an error message if `index` is < 0 or >= `SomeEnum::QUALITY_MAX`,
    // then returns from the function.
    ERR_FAIL_INDEX_MSG(index, SomeEnum::QUALITY_MAX,
            vformat("Invalid quality: %d. See SomeEnum for allowed values.", index));

    // Prints an error message if `index` is < 0 >= `some_array.size()`,
    // then returns `-1` from the function.
    ERR_FAIL_INDEX_V_MSG(index, some_array.size(), -1,
            vformat("Item %d is out of bounds.", index));

    // Unconditionally prints an error message and returns from the function.
    // Only use this if you need to perform complex error checking.
    if (!complex_error_checking_routine()) {
        ERR_FAIL_MSG("Couldn't reload the filesystem cache.");
    }

    // Unconditionally prints an error message and returns `false` from the function.
    // Only use this if you need to perform complex error checking.
    if (!complex_error_checking_routine()) {
        ERR_FAIL_V_MSG(false, "Couldn't parse the input arguments.");
    }

    // Crashes the engine. This should generally never be used
    // except for testing crash handling code. Godot's philosophy
    // is to never crash, both in the editor and in exported projects.
    CRASH_NOW_MSG("Can't predict the future! Aborting.");


.. seealso::

    See `core/error_macros.h <https://github.com/godotengine/godot/blob/3.x/core/error_macros.h>`__
    in Godot's codebase for more information about each error macro.

    Some functions return an error code (materialized by a return type of
    ``Error``). This value can be returned directly from an error macro.
    See the list of available error codes in
    `core/error_list.h <https://github.com/godotengine/godot/blob/3.x/core/error_list.h>`__.


===================================================
/. ./development/cpp/core_types.rst
===================================================

.. _doc_core_types:

Core types
==========

Godot has a rich set of classes and templates that compose its core,
and everything is built upon them.

This reference will try to list them in order for their better
understanding.

Definitions
-----------

Godot uses the standard C99 datatypes, such as ``uint8_t``,
``uint32_t``, ``int64_t``, etc. which are nowadays supported by every
compiler. Reinventing the wheel for those is not fun, as it makes code
more difficult to read.

In general, care is not taken to use the most efficient datatype for a
given task unless using large structures or arrays. ``int`` is used
through most of the code unless necessary. This is done because nowadays
every device has at least a 32 bits bus and can do such operations in
one cycle. It makes code more readable too.

For files or memory sizes, ``size_t`` is used, which is warranted to be
64 bits.

For Unicode characters, CharType instead of wchar_t is used, because
many architectures have 4 bytes long wchar_t, where 2 bytes might be
desired. However, by default, this has not been forced and CharType maps
directly to wchar_t.

References:
~~~~~~~~~~~

-  `core/typedefs.h <https://github.com/godotengine/godot/blob/3.x/core/typedefs.h>`__

Memory model
------------

PC is a wonderful architecture. Computers often have gigabytes of RAM,
terabytes of storage and gigahertz of CPU, and when an application needs
more resources the OS will swap out the inactive ones. Other
architectures (like mobile or consoles) are in general more limited.

The most common memory model is the heap, where an application will
request a region of memory, and the underlying OS will try to fit it
somewhere and return it. This often works best and is flexible,
but over time and with abuse, this can lead to segmentation.

Segmentation slowly creates holes that are too small for most common
allocations, so that memory is wasted. There is a lot of literature
about heap and segmentation, so this topic will not be developed
further here. Modern operating systems use paged memory, which helps
mitigate the problem of segmentation but doesn't solve it.

However, in many studies and tests, it is shown that given enough
memory, if the maximum allocation size is below a given threshold in
proportion to the maximum heap size and proportion of memory intended to
be unused, segmentation will not be a problem over time as it will
remain constant. In other words, leave 10-20% of your memory free
and perform all small allocations and you are fine.

Godot ensures that all objects that can be allocated dynamically are
small (less than a few kb at most). But what happens if an allocation is
too large (like an image or mesh geometry or large array)? In this case
Godot has the option to use a dynamic memory pool. This memory needs to
be locked to be accessed, and if an allocation runs out of memory, the
pool will be rearranged and compacted on demand. Depending on the need
of the game, the programmer can configure the dynamic memory pool size.

Allocating memory
-----------------

Godot has many tools for tracking memory usage in a game, especially
during debug. Because of this, the regular C and C++ library calls
should not be used. Instead, a few other ones are provided.

For C-style allocation, Godot provides a few macros:

.. code-block:: none

    memalloc()
    memrealloc()
    memfree()

These are equivalent to the usual malloc, realloc, free of the standard C
library.

For C++-style allocation, special macros are provided:

.. code-block:: none

    memnew( Class / Class(args) )
    memdelete( instance )

    memnew_arr( Class , amount )
    memdelete_arr( pointer to array )

which are equivalent to new, delete, new[] and delete[].

memnew/memdelete also use a little C++ magic and notify Objects right
after they are created, and right before they are deleted.

For dynamic memory, the PoolVector<> template is provided. PoolVector is a
standard vector class, and is very similar to vector in the C++ standard library.
To create a PoolVector buffer, use this:

.. code-block:: cpp

    PoolVector<int> data;

PoolVector can be accessed using the [] operator and a few helpers exist for this:

.. code-block:: cpp

    PoolVector<int>::Read r = data.read()
    int someint = r[4]

.. code-block:: cpp

    PoolVector<int>::Write w = data.write()
    w[4] = 22;

These operations allow fast read/write from PoolVectors and keep it
locked until they go out of scope. However, PoolVectors should be used
for small, dynamic memory operations, as read() and write() are too slow for a
large amount of accesses.

References:
~~~~~~~~~~~

-  `core/os/memory.h <https://github.com/godotengine/godot/blob/3.x/core/os/memory.h>`__
-  `core/pool_vector.h <https://github.com/godotengine/godot/blob/3.x/core/pool_vector.cpp>`__

Containers
----------

Godot provides also a set of common containers:

-  Vector
-  List
-  Set
-  Map

They are simple and aim to be as minimal as possible, as templates
in C++ are often inlined and make the binary size much fatter, both in
debug symbols and code. List, Set and Map can be iterated using
pointers, like this:

.. code-block:: cpp

    for(List<int>::Element *E=somelist.front();E;E=E->next()) {
        print_line(E->get()); // print the element
    }

The Vector<> class also has a few nice features:

-  It does copy on write, so making copies of it is cheap as long as
   they are not modified.
-  It supports multi-threading, by using atomic operations on the
   reference counter.

References:
~~~~~~~~~~~

-  `core/vector.h <https://github.com/godotengine/godot/blob/3.x/core/vector.h>`__
-  `core/list.h <https://github.com/godotengine/godot/blob/3.x/core/list.h>`__
-  `core/set.h <https://github.com/godotengine/godot/blob/3.x/core/set.h>`__
-  `core/map.h <https://github.com/godotengine/godot/blob/3.x/core/map.h>`__

String
------

Godot also provides a String class. This class has a huge amount of
features, full Unicode support in all the functions (like case
operations) and utf8 parsing/extracting, as well as helpers for
conversion and visualization.

References:
~~~~~~~~~~~

-  `core/ustring.h <https://github.com/godotengine/godot/blob/3.x/core/ustring.h>`__

StringName
----------

StringNames are like a String, but they are unique. Creating a
StringName from a string results in a unique internal pointer for all
equal strings. StringNames are useful for using strings as
identifier, as comparing them is basically comparing a pointer.

Creation of a StringName (especially a new one) is slow, but comparison
is fast.

References:
~~~~~~~~~~~

-  `core/string_name.h <https://github.com/godotengine/godot/blob/3.x/core/string_name.h>`__

Math types
----------

There are several linear math types available in the core/math
directory.

References:
~~~~~~~~~~~

-  `core/math <https://github.com/godotengine/godot/tree/3.x/core/math>`__

NodePath
--------

This is a special datatype used for storing paths in a scene tree and
referencing them fast.

References:
~~~~~~~~~~~

-  `core/node_path.h <https://github.com/godotengine/godot/blob/3.x/core/node_path.h>`__

RID
---

RIDs are resource IDs. Servers use these to reference data stored in
them. RIDs are opaque, meaning that the data they reference can't be
accessed directly. RIDs are unique, even for different types of
referenced data.

References:
~~~~~~~~~~~

-  `core/rid.h <https://github.com/godotengine/godot/blob/3.x/core/rid.h>`__


===================================================
/. ./development/cpp/variant_class.rst
===================================================

.. _doc_variant_class:

Variant class
=============

About
-----

Variant is the most important datatype of Godot, it's the most important
class in the engine. A Variant takes up only 20 bytes and can store
almost any engine datatype inside of it. Variants are rarely used to
hold information for long periods of time, instead they are used mainly
for communication, editing, serialization and generally moving data
around.

A Variant can:

-  Store almost any datatype
-  Perform operations between many variants (GDScript uses Variant as
   its atomic/native datatype).
-  Be hashed, so it can be compared quickly to other variants
-  Be used to convert safely between datatypes
-  Be used to abstract calling methods and their arguments (Godot
   exports all its functions through variants)
-  Be used to defer calls or move data between threads.
-  Be serialized as binary and stored to disk, or transferred via
   network.
-  Be serialized to text and use it for printing values and editable
   settings.
-  Work as an exported property, so the editor can edit it universally.
-  Be used for dictionaries, arrays, parsers, etc.

Basically, thanks to the Variant class, writing Godot itself was a much,
much easier task, as it allows for highly dynamic constructs not common
of C++ with little effort. Become a friend of Variant today.

References:
~~~~~~~~~~~

-  `core/variant.h <https://github.com/godotengine/godot/blob/3.x/core/variant.h>`__

Containers: Dictionary and Array
--------------------------------

Both are implemented using variants. A Dictionary can match any datatype
used as key to any other datatype. An Array just holds an array of
Variants. Of course, a Variant can also hold a Dictionary and an Array
inside, making it even more flexible.

Modifications to a container will modify all references to
it. A Mutex should be created to lock it if multi threaded access is
desired.

Copy-on-write (COW) mode support for containers was dropped with Godot 3.0.

References:
~~~~~~~~~~~

-  `core/dictionary.h <https://github.com/godotengine/godot/blob/3.x/core/dictionary.h>`__
-  `core/array.h <https://github.com/godotengine/godot/blob/3.x/core/array.h>`__


===================================================
/. ./development/cpp/object_class.rst
===================================================

.. _doc_object_class:

Object class
============

.. seealso::

    This page describes the C++ implementation of objects in Godot.
    Looking for the Object class reference? :ref:`Have a look here. <class_Object>`

General definition
------------------

:ref:`Object <class_object>` is the base class for almost everything. Most classes in Godot
inherit directly or indirectly from it. Objects provide reflection and
editable properties, and declaring them is a matter of using a single
macro like this.

.. code-block:: cpp

    class CustomObject : public Object {

        GDCLASS(CustomObject, Object); // this is required to inherit
    };

This makes Objects gain a lot of functionality, like for example

.. code-block:: cpp

    obj = memnew(CustomObject);
    print_line("Object class: ", obj->get_class()); // print object class

    obj2 = Object::cast_to<OtherClass>(obj); // converting between classes, this also works without RTTI enabled.

References:
~~~~~~~~~~~

-  `core/object.h <https://github.com/godotengine/godot/blob/3.x/core/object.h>`__

Registering an Object
---------------------

ClassDB is a static class that holds the entire list of registered
classes that inherit from Object, as well as dynamic bindings to all
their methods properties and integer constants.

Classes are registered by calling:

.. code-block:: cpp

    ClassDB::register_class<MyCustomClass>()

Registering it will allow the class to be instanced by scripts, code, or
creating them again when deserializing.

Registering as virtual is the same but it can't be instanced.

.. code-block:: cpp

    ClassDB::register_virtual_class<MyCustomClass>()

Object-derived classes can override the static function
``static void _bind_methods()``. When one class is registered, this
static function is called to register all the object methods,
properties, constants, etc. It's only called once. If an Object derived
class is instanced but has not been registered, it will be registered as
virtual automatically.

Inside ``_bind_methods``, there are a couple of things that can be done.
Registering functions is one:

.. code-block:: cpp

    ClassDB::bind_method(D_METHOD("methodname", "arg1name", "arg2name"), &MyCustomMethod);

Default values for arguments can be passed in reverse order:

.. code-block:: cpp

    ClassDB::bind_method(D_METHOD("methodname", "arg1name", "arg2name"), &MyCustomType::method, DEFVAL(-1)); // default value for arg2name

``D_METHOD`` is a macro that converts "methodname" to a StringName for more
efficiency. Argument names are used for introspection, but when
compiling on release, the macro ignores them, so the strings are unused
and optimized away.

Check ``_bind_methods`` of Control or Object for more examples.

If just adding modules and functionality that is not expected to be
documented as thoroughly, the ``D_METHOD()`` macro can safely be ignored and a
string passing the name can be passed for brevity.

References:
~~~~~~~~~~~

-  `core/class_db.h <https://github.com/godotengine/godot/blob/3.x/core/class_db.h>`__

Constants
---------

Classes often have enums such as:

.. code-block:: cpp

    enum SomeMode {
       MODE_FIRST,
       MODE_SECOND
    };

For these to work when binding to methods, the enum must be declared
convertible to int, for this a macro is provided:

.. code-block:: cpp

    VARIANT_ENUM_CAST(MyClass::SomeMode); // now functions that take SomeMode can be bound.

The constants can also be bound inside ``_bind_methods``, by using:

.. code-block:: cpp

    BIND_CONSTANT(MODE_FIRST);
    BIND_CONSTANT(MODE_SECOND);

Properties (set/get)
--------------------

Objects export properties, properties are useful for the following:

-  Serializing and deserializing the object.
-  Creating a list of editable values for the Object derived class.

Properties are usually defined by the PropertyInfo() class. Usually
constructed as:

.. code-block:: cpp

    PropertyInfo(type, name, hint, hint_string, usage_flags)

For example:

.. code-block:: cpp

    PropertyInfo(Variant::INT, "amount", PROPERTY_HINT_RANGE, "0,49,1", PROPERTY_USAGE_EDITOR)

This is an integer property, named "amount", hint is a range, range goes
from 0 to 49 in steps of 1 (integers). It is only usable for the editor
(edit value visually) but won't be serialized.

Another example:

.. code-block:: cpp

    PropertyInfo(Variant::STRING, "modes", PROPERTY_HINT_ENUM, "Enabled,Disabled,Turbo")

This is a string property, can take any string but the editor will only
allow the defined hint ones. Since no usage flags were specified, the
default ones are PROPERTY_USAGE_STORAGE and PROPERTY_USAGE_EDITOR.

There are plenty of hints and usage flags available in object.h, give them a
check.

Properties can also work like C# properties and be accessed from script
using indexing, but this usage is generally discouraged, as using
functions is preferred for legibility. Many properties are also bound
with categories, such as "animation/frame" which also make indexing
impossible unless using operator [].

From ``_bind_methods()``, properties can be created and bound as long as
set/get functions exist. Example:

.. code-block:: cpp

    ADD_PROPERTY(PropertyInfo(Variant::INT, "amount"), "set_amount", "get_amount")

This creates the property using the setter and the getter.

.. _doc_binding_properties_using_set_get_property_list:

Binding properties using ``_set``/``_get``/``_get_property_list``
-----------------------------------------------------------------

An additional method of creating properties exists when more flexibility
is desired (i.e. adding or removing properties on context).

The following functions can be overridden in an Object derived class,
they are NOT virtual, DO NOT make them virtual, they are called for
every override and the previous ones are not invalidated (multilevel
call).

.. code-block:: cpp

    protected:
         void _get_property_list(List<PropertyInfo> *r_props) const;      // return list of properties
         bool _get(const StringName &p_property, Variant &r_value) const; // return true if property was found
         bool _set(const StringName &p_property, const Variant &p_value); // return true if property was found

This is also a little less efficient since ``p_property`` must be
compared against the desired names in serial order.

Dynamic casting
---------------

Godot provides dynamic casting between Object-derived classes, for
example:

.. code-block:: cpp

    void somefunc(Object *some_obj) {

         Button *button = Object::cast_to<Button>(some_obj);
    }

If cast fails, NULL is returned. This system uses RTTI, but it also
works fine (although a bit slower) when RTTI is disabled. This is useful
on platforms where a small binary size is ideal, such as HTML5 or
consoles (with low memory footprint).

Signals
-------

Objects can have a set of signals defined (similar to Delegates in other
languages). Connecting to them is rather easy:

.. code-block:: cpp

    obj->connect(<signal>, target_instance, target_method)
    // for example:
    obj->connect("enter_tree", this, "_node_entered_tree")

The method ``_node_entered_tree`` must be registered to the class using
``ClassDB::bind_method`` (explained before).

Adding signals to a class is done in ``_bind_methods``, using the
``ADD_SIGNAL`` macro, for example:

.. code-block:: cpp

    ADD_SIGNAL(MethodInfo("been_killed"))

Notifications
-------------

All objects in Godot have a :ref:`_notification <class_Object_method__notification>`
method that allows it to respond to engine level callbacks that may relate to it.
More information can be found on the :ref:`doc_godot_notifications` page.

References
----------

:ref:`Reference <class_reference>` inherits from Object and holds a
reference count. It is the base for reference counted object types.
Declaring them must be done using Ref<> template. For example:

.. code-block:: cpp

    class MyReference: public Reference {
        GDCLASS(MyReference, Reference);
    };

    Ref<MyReference> myref(memnew(MyReference));

``myref`` is reference counted. It will be freed when no more Ref<>
templates point to it.

References:
~~~~~~~~~~~

-  `core/reference.h <https://github.com/godotengine/godot/blob/3.x/core/reference.h>`__

Resources:
----------

:ref:`Resource <class_resource>` inherits from Reference, so all resources
are reference counted. Resources can optionally contain a path, which
reference a file on disk. This can be set with ``resource.set_path(path)``.
This is normally done by the resource loader though. No two different
resources can have the same path, attempt to do so will result in an error.

Resources without a path are fine too.

References:
~~~~~~~~~~~

-  `core/resource.h <https://github.com/godotengine/godot/blob/3.x/core/resource.h>`__

Resource loading
----------------

Resources can be loaded with the ResourceLoader API, like this:

.. code-block:: cpp

    Ref<Resource> res = ResourceLoader::load("res://someresource.res")

If a reference to that resource has been loaded previously and is in
memory, the resource loader will return that reference. This means that
there can be only one resource loaded from a file referenced on disk at
the same time.

-  resourceinteractiveloader (TODO)

References:
~~~~~~~~~~~

-  `core/io/resource_loader.h <https://github.com/godotengine/godot/blob/3.x/core/io/resource_loader.h>`__

Resource saving
---------------

Saving a resource can be done with the resource saver API:

.. code-block:: cpp

    ResourceSaver::save("res://someresource.res", instance)

Instance will be saved. Sub resources that have a path to a file will be
saved as a reference to that resource. Sub resources without a path will
be bundled with the saved resource and assigned sub-IDs, like
``res://someresource.res::1``. This also helps to cache them when loaded.

References:
~~~~~~~~~~~

-  `core/io/resource_saver.h <https://github.com/godotengine/godot/blob/3.x/core/io/resource_saver.h>`__


===================================================
/. ./development/cpp/inheritance_class_tree.rst
===================================================

Inheritance class tree
======================

Object
------

.. image:: img/Object.png

Reference
---------

.. image:: img/Reference.png

Control
-------

.. image:: img/Control.png

Node2D
------

.. image:: img/Node2D.png

Spatial
-------

.. image:: img/Spatial.png

Source files: :download:`class_tree.zip <files/class_tree.zip>`.


===================================================
/. ./development/cpp/custom_modules_in_cpp.rst
===================================================

.. _doc_custom_modules_in_c++:

Custom modules in C++
=====================

Modules
-------

Godot allows extending the engine in a modular way. New modules can be
created and then enabled/disabled. This allows for adding new engine
functionality at every level without modifying the core, which can be
split for use and reuse in different modules.

Modules are located in the ``modules/`` subdirectory of the build system.
By default, dozens of modules are enabled, such as GDScript (which, yes,
is not part of the base engine), the Mono runtime, a regular expressions
module, and others. As many new modules as desired can be
created and combined. The SCons build system will take care of it
transparently.

What for?
---------

While it's recommended that most of a game be written in scripting (as
it is an enormous time saver), it's perfectly possible to use C++
instead. Adding C++ modules can be useful in the following scenarios:

-  Binding an external library to Godot (like PhysX, FMOD, etc).
-  Optimize critical parts of a game.
-  Adding new functionality to the engine and/or editor.
-  Porting an existing game.
-  Write a whole, new game in C++ because you can't live without C++.

Creating a new module
---------------------

Before creating a module, make sure to :ref:`download the source code of Godot
and compile it <toc-devel-compiling>`.

To create a new module, the first step is creating a directory inside
``modules/``. If you want to maintain the module separately, you can checkout
a different VCS into modules and use it.

The example module will be called "summator" (``godot/modules/summator``).
Inside we will create a simple summator class:

.. code-block:: cpp

    /* summator.h */

    #ifndef SUMMATOR_H
    #define SUMMATOR_H

    #include "core/reference.h"

    class Summator : public Reference {
        GDCLASS(Summator, Reference);

        int count;

    protected:
        static void _bind_methods();

    public:
        void add(int p_value);
        void reset();
        int get_total() const;

        Summator();
    };

    #endif // SUMMATOR_H

And then the cpp file.

.. code-block:: cpp

    /* summator.cpp */

    #include "summator.h"

    void Summator::add(int p_value) {
        count += p_value;
    }

    void Summator::reset() {
        count = 0;
    }

    int Summator::get_total() const {
        return count;
    }

    void Summator::_bind_methods() {
        ClassDB::bind_method(D_METHOD("add", "value"), &Summator::add);
        ClassDB::bind_method(D_METHOD("reset"), &Summator::reset);
        ClassDB::bind_method(D_METHOD("get_total"), &Summator::get_total);
    }

    Summator::Summator() {
        count = 0;
    }

Then, the new class needs to be registered somehow, so two more files
need to be created:

.. code-block:: none

    register_types.h
    register_types.cpp

.. important::
    These files must be in the top-level folder of your module (next to your
    ``SCsub`` and ``config.py`` files) for the module to be registered properly.

These files should contain the following:

.. code-block:: cpp

    /* register_types.h */

    void register_summator_types();
    void unregister_summator_types();
    /* yes, the word in the middle must be the same as the module folder name */

.. code-block:: cpp

    /* register_types.cpp */

    #include "register_types.h"

    #include "core/class_db.h"
    #include "summator.h"

    void register_summator_types() {
        ClassDB::register_class<Summator>();
    }

    void unregister_summator_types() {
       // Nothing to do here in this example.
    }

Next, we need to create a ``SCsub`` file so the build system compiles
this module:

.. code-block:: python

    # SCsub

    Import('env')

    env.add_source_files(env.modules_sources, "*.cpp") # Add all cpp files to the build

With multiple sources, you can also add each file individually to a Python
string list:

.. code-block:: python

    src_list = ["summator.cpp", "other.cpp", "etc.cpp"]
    env.add_source_files(env.modules_sources, src_list)

This allows for powerful possibilities using Python to construct the file list
using loops and logic statements. Look at some modules that ship with Godot by
default for examples.

To add include directories for the compiler to look at you can append it to the
environment's paths:

.. code-block:: python

    env.Append(CPPPATH=["mylib/include"]) # this is a relative path
    env.Append(CPPPATH=["#myotherlib/include"]) # this is an 'absolute' path

If you want to add custom compiler flags when building your module, you need to clone
``env`` first, so it won't add those flags to whole Godot build (which can cause errors).
Example ``SCsub`` with custom flags:

.. code-block:: python

    # SCsub

    Import('env')

    module_env = env.Clone()
    module_env.add_source_files(env.modules_sources, "*.cpp")
    # Append CCFLAGS flags for both C and C++ code.
    module_env.Append(CCFLAGS=['-O2'])
    # If you need to, you can:
    # - Append CFLAGS for C code only.
    # - Append CXXFLAGS for C++ code only.

And finally, the configuration file for the module, this is a simple
python script that must be named ``config.py``:

.. code-block:: python

    # config.py

    def can_build(env, platform):
        return True

    def configure(env):
        pass

The module is asked if it's OK to build for the specific platform (in
this case, ``True`` means it will build for every platform).

And that's it. Hope it was not too complex! Your module should look like
this:

.. code-block:: none

    godot/modules/summator/config.py
    godot/modules/summator/summator.h
    godot/modules/summator/summator.cpp
    godot/modules/summator/register_types.h
    godot/modules/summator/register_types.cpp
    godot/modules/summator/SCsub

You can then zip it and share the module with everyone else. When
building for every platform (instructions in the previous sections),
your module will be included.

.. note:: There is a parameter limit of 5 in C++ modules for things such
          as subclasses. This can be raised to 13 by including the header
          file ``core/method_bind_ext.gen.inc``.

Using the module
----------------

You can now use your newly created module from any script:

.. tabs::
 .. code-tab:: gdscript GDScript

    var s = Summator.new()
    s.add(10)
    s.add(20)
    s.add(30)
    print(s.get_total())
    s.reset()

The output will be ``60``.

.. seealso:: The previous Summator example is great for small, custom modules,
  but what if you want to use a larger, external library? Refer to
  :ref:`doc_binding_to_external_libraries` for details about binding to
  external libraries.

.. warning:: If your module is meant to be accessed from the running project
             (not just from the editor), you must also recompile every export
             template you plan to use, then specify the path to the custom
             template in each export preset. Otherwise, you'll get errors when
             running the project as the module isn't compiled in the export
             template. See the :ref:`Compiling <toc-devel-compiling>` pages
             for more information.

Compiling a module externally
-----------------------------

Compiling a module involves moving the module's sources directly under the
engine's ``modules/`` directory. While this is the most straightforward way to
compile a module, there are a couple of reasons as to why this might not be a
practical thing to do:

1. Having to manually copy modules sources every time you want to compile the
   engine with or without the module, or taking additional steps needed to
   manually disable a module during compilation with a build option similar to
   ``module_summator_enabled=no``. Creating symbolic links may also be a solution,
   but you may additionally need to overcome OS restrictions like needing the
   symbolic link privilege if doing this via script.

2. Depending on whether you have to work with the engine's source code, the
   module files added directly to ``modules/`` changes the working tree to the
   point where using a VCS (like ``git``) proves to be cumbersome as you need to
   make sure that only the engine-related code is committed by filtering
   changes.

So if you feel like the independent structure of custom modules is needed, lets
take our "summator" module and move it to the engine's parent directory:

.. code-block:: shell

    mkdir ../modules
    mv modules/summator ../modules

Compile the engine with our module by providing ``custom_modules`` build option
which accepts a comma-separated list of directory paths containing custom C++
modules, similar to the following:

.. code-block:: shell

    scons custom_modules=../modules

The build system shall detect all modules under the ``../modules`` directory
and compile them accordingly, including our "summator" module.

.. warning::

    Any path passed to ``custom_modules`` will be converted to an absolute path
    internally as a way to distinguish between custom and built-in modules. It
    means that things like generating module documentation may rely on a
    specific path structure on your machine.

.. seealso::

    :ref:`Introduction to the buildsystem - Custom modules build option <doc_buildsystem_custom_modules>`.

Improving the build system for development
------------------------------------------

.. warning::

    This shared library support is not designed to support distributing a module
    to other users without recompiling the engine. For that purpose, use
    :ref:`GDNative <doc_what_is_gdnative>` instead.

So far, we defined a clean SCsub that allows us to add the sources
of our new module as part of the Godot binary.

This static approach is fine when we want to build a release version of our
game, given we want all the modules in a single binary.

However, the trade-off is that every single change requires a full recompilation of the
game. Even though SCons is able to detect and recompile only the file that was
changed, finding such files and eventually linking the final binary takes a long time.

The solution to avoid such a cost is to build our own module as a shared
library that will be dynamically loaded when starting our game's binary.

.. code-block:: python

    # SCsub

    Import('env')

    sources = [
        "register_types.cpp",
        "summator.cpp"
    ]

    # First, create a custom env for the shared library.
    module_env = env.Clone()

    # Position-independent code is required for a shared library.
    module_env.Append(CCFLAGS=['-fPIC'])

    # Don't inject Godot's dependencies into our shared library.
    module_env['LIBS'] = []

    # Define the shared library. By default, it would be built in the module's
    # folder, however it's better to output it into `bin` next to the
    # Godot binary.
    shared_lib = module_env.SharedLibrary(target='#bin/summator', source=sources)

    # Finally, notify the main build environment it now has our shared library
    # as a new dependency.

    # LIBPATH and LIBS need to be set on the real "env" (not the clone)
    # to link the specified libraries to the Godot executable.

    env.Append(LIBPATH=['#bin'])

    # SCons wants the name of the library with it custom suffixes
    # (e.g. ".x11.tools.64") but without the final ".so".
    shared_lib_shim = shared_lib[0].name.rsplit('.', 1)[0]
    env.Append(LIBS=[shared_lib_shim])

Once compiled, we should end up with a ``bin`` directory containing both the
``godot*`` binary and our ``libsummator*.so``. However given the .so is not in
a standard directory (like ``/usr/lib``), we have to help our binary find it
during runtime with the ``LD_LIBRARY_PATH`` environment variable:

.. code-block:: shell

    export LD_LIBRARY_PATH="$PWD/bin/"
    ./bin/godot*

.. note::
  You have to ``export`` the environment variable. Otherwise,
  you won't be able to run your project from the editor.

On top of that, it would be nice to be able to select whether to compile our
module as shared library (for development) or as a part of the Godot binary
(for release). To do that we can define a custom flag to be passed to SCons
using the ``ARGUMENT`` command:

.. code-block:: python

    # SCsub

    Import('env')

    sources = [
        "register_types.cpp",
        "summator.cpp"
    ]

    module_env = env.Clone()
    module_env.Append(CCFLAGS=['-O2'])

    if ARGUMENTS.get('summator_shared', 'no') == 'yes':
        # Shared lib compilation
        module_env.Append(CCFLAGS=['-fPIC'])
        module_env['LIBS'] = []
        shared_lib = module_env.SharedLibrary(target='#bin/summator', source=sources)
        shared_lib_shim = shared_lib[0].name.rsplit('.', 1)[0]
        env.Append(LIBS=[shared_lib_shim])
        env.Append(LIBPATH=['#bin'])
    else:
        # Static compilation
        module_env.add_source_files(env.modules_sources, sources)

Now by default ``scons`` command will build our module as part of Godot's binary
and as a shared library when passing ``summator_shared=yes``.

Finally, you can even speed up the build further by explicitly specifying your
shared module as target in the SCons command:

.. code-block:: shell

    scons summator_shared=yes platform=x11 bin/libsummator.x11.tools.64.so

Writing custom documentation
----------------------------

Writing documentation may seem like a boring task, but it is highly recommended
to document your newly created module in order to make it easier for users to
benefit from it. Not to mention that the code you've written one year ago may
become indistinguishable from the code that was written by someone else, so be
kind to your future self!

There are several steps in order to setup custom docs for the module:

1. Make a new directory in the root of the module. The directory name can be
   anything, but we'll be using the ``doc_classes`` name throughout this section.

2. Now, we need to edit ``config.py``, add the following snippet:

   .. code-block:: python

        def get_doc_path():
            return "doc_classes"

        def get_doc_classes():
            return [
                "Summator",
            ]

The ``get_doc_path()`` function is used by the build system to determine
the location of the docs. In this case, they will be located in the
``modules/summator/doc_classes`` directory. If you don't define this,
the doc path for your module will fall back to the main ``doc/classes``
directory.

The ``get_doc_classes()`` method is necessary for the build system to
know which registered classes belong to the module. You need to list all of your
classes here. The classes that you don't list will end up in the
main ``doc/classes`` directory.

.. tip::

    You can use Git to check if you have missed some of your classes by checking the
    untracked files with ``git status``. For example::

        user@host:~/godot$ git status

    Example output::

        Untracked files:
            (use "git add <file>..." to include in what will be committed)

            doc/classes/MyClass2D.xml
            doc/classes/MyClass4D.xml
            doc/classes/MyClass5D.xml
            doc/classes/MyClass6D.xml
            ...


3. Now we can generate the documentation:

We can do this via running Godot's doctool i.e. ``godot --doctool <path>``,
which will dump the engine API reference to the given ``<path>`` in XML format.

In our case we'll point it to the root of the cloned repository. You can point it
to an another folder, and just copy over the files that you need.

Run command:

   ::

      user@host:~/godot/bin$ ./bin/<godot_binary> --doctool .

Now if you go to the ``godot/modules/summator/doc_classes`` folder, you will see
that it contains a ``Summator.xml`` file, or any other classes, that you referenced
in your ``get_doc_classes`` function.

Edit the file(s) following :ref:`doc_updating_the_class_reference` and recompile the engine.

Once the compilation process is finished, the docs will become accessible within
the engine's built-in documentation system.

In order to keep documentation up-to-date, all you'll have to do is simply modify
one of the XML files and recompile the engine from now on.

If you change your module's API, you can also re-extract the docs, they will contain
the things that you previously added. Of course if you point it to your godot
folder, make sure you don't lose work by extracting older docs from an older engine build
on top of the newer ones.

Note that if you don't have write access rights to your supplied ``<path>``,
you might encounter an error similar to the following:

.. code-block:: console

    ERROR: Can't write doc file: docs/doc/classes/@GDScript.xml
       At: editor/doc/doc_data.cpp:956


.. _doc_custom_module_icons:

Adding custom editor icons
--------------------------

Similarly to how you can write self-contained documentation within a module,
you can also create your own custom icons for classes to appear in the editor.

For the actual process of creating editor icons to be integrated within the engine,
please refer to :ref:`doc_editor_icons` first.

Once you've created your icon(s), proceed with the following steps:

1. Make a new directory in the root of the module named ``icons``. This is the
   default path for the engine to look for module's editor icons.

2. Move your newly created ``svg`` icons (optimized or not) into that folder.

3. Recompile the engine and run the editor. Now the icon(s) will appear in
   editor's interface where appropriate.

If you'd like to store your icons somewhere else within your module,
add the following code snippet to ``config.py`` to override the default path:

   .. code-block:: python

       def get_icons_path():
           return "path/to/icons"

Summing up
----------

Remember to:

-  use ``GDCLASS`` macro for inheritance, so Godot can wrap it
-  use ``_bind_methods`` to bind your functions to scripting, and to
   allow them to work as callbacks for signals.

But this is not all, depending what you do, you will be greeted with
some (hopefully positive) surprises.

-  If you inherit from :ref:`class_Node` (or any derived node type, such as
   Sprite), your new class will appear in the editor, in the inheritance
   tree in the "Add Node" dialog.
-  If you inherit from :ref:`class_Resource`, it will appear in the resource
   list, and all the exposed properties can be serialized when
   saved/loaded.
-  By this same logic, you can extend the Editor and almost any area of
   the engine.


===================================================
/. ./development/cpp/binding_to_external_libraries.rst
===================================================

.. _doc_binding_to_external_libraries:

Binding to external libraries
=============================

Modules
-------

The Summator example in :ref:`doc_custom_modules_in_c++` is great for small,
custom modules, but what if you want to use a larger, external library?
Let's look at an example using `Festival <http://www.cstr.ed.ac.uk/projects/festival/>`_,
a speech synthesis (text-to-speech) library written in C++.

To bind to an external library, set up a module directory similar to the Summator example:

.. code-block:: none

    godot/modules/tts/

Next, you will create a header file with a simple TTS class:

.. code-block:: cpp

    /* tts.h */

    #ifndef GODOT_TTS_H
    #define GODOT_TTS_H

    #include "core/reference.h"

    class TTS : public Reference {
        GDCLASS(TTS, Reference);

    protected:
        static void _bind_methods();

    public:
        bool say_text(String p_txt);

        TTS();
    };

    #endif // GODOT_TTS_H

And then you'll add the cpp file.

.. code-block:: cpp

    /* tts.cpp */

    #include "tts.h"

    #include <festival.h>

    bool TTS::say_text(String p_txt) {

        //convert Godot String to Godot CharString to C string
        return festival_say_text(p_txt.ascii().get_data());
    }

    void TTS::_bind_methods() {

        ClassDB::bind_method(D_METHOD("say_text", "txt"), &TTS::say_text);
    }

    TTS::TTS() {
        festival_initialize(true, 210000); //not the best way to do it as this should only ever be called once.
    }

Just as before, the new class needs to be registered somehow, so two more files
need to be created:

.. code-block:: none

    register_types.h
    register_types.cpp

.. important::
    These files must be in the top-level folder of your module (next to your
    ``SCsub`` and ``config.py`` files) for the module to be registered properly.

These files should contain the following:

.. code-block:: cpp

    /* register_types.h */

    void register_tts_types();
    void unregister_tts_types();
    /* yes, the word in the middle must be the same as the module folder name */

.. code-block:: cpp

    /* register_types.cpp */

    #include "register_types.h"

    #include "core/class_db.h"
    #include "tts.h"

    void register_tts_types() {
        ClassDB::register_class<TTS>();
    }

    void unregister_tts_types() {
        // Nothing to do here in this example.
    }

Next, you need to create a ``SCsub`` file so the build system compiles
this module:

.. code-block:: python

    # SCsub

    Import('env')

    env_tts = env.Clone()
    env_tts.add_source_files(env.modules_sources, "*.cpp") # Add all cpp files to the build

You'll need to install the external library on your machine to get the .a library files. See the library's official
documentation for specific instructions on how to do this for your operation system. We've included the
installation commands for Linux below, for reference.

.. code-block:: shell

    sudo apt-get install festival festival-dev <-- Installs festival and speech_tools libraries
    apt-cache search festvox-* <-- Displays list of voice packages
    sudo apt-get install festvox-don festvox-rablpc16k festvox-kallpc16k festvox-kdlpc16k <-- Installs voices

.. important::
    The voices that Festival uses (and any other potential external/3rd-party
    resource) all have varying licenses and terms of use; some (if not most) of them may be
    be problematic with Godot, even if the Festival Library itself is MIT License compatible.
    Please be sure to check the licenses and terms of use.

The external library will also need to be installed inside your module to make the source
files accessible to the compiler, while also keeping the module code self-contained. The
festival and speech_tools libraries can be installed from the modules/tts/ directory via
git using the following commands:

.. code-block:: shell

    git clone https://github.com/festvox/festival
    git clone https://github.com/festvox/speech_tools

If you don't want the external repository source files committed to your repository, you
can link to them instead by adding them as submodules (from within the modules/tts/ directory), as seen below:

.. code-block:: shell

    git submodule add https://github.com/festvox/festival
    git submodule add https://github.com/festvox/speech_tools

.. important::
    Please note that Git submodules are not used in the Godot repository. If
    you are developing a module to be merged into the main Godot repository, you should not
    use submodules. If your module doesn't get merged in, you can always try to implement
    the external library as a GDNative C++ plugin.

To add include directories for the compiler to look at you can append it to the
environment's paths:

.. code-block:: python

    # These paths are relative to /modules/tts/
    env_tts.Append(CPPPATH=["speech_tools/include", "festival/src/include"])

    # LIBPATH and LIBS need to be set on the real "env" (not the clone)
    # to link the specified libraries to the Godot executable.

    # This is a path relative to /modules/tts/ where your .a libraries reside.
    # If you are compiling the module externally (not in the godot source tree),
    # these will need to be full paths.
    env.Append(LIBPATH=['libpath'])

    # Check with the documentation of the external library to see which library
    # files should be included/linked.
    env.Append(LIBS=['Festival', 'estools', 'estbase', 'eststring'])

If you want to add custom compiler flags when building your module, you need to clone
`env` first, so it won't add those flags to whole Godot build (which can cause errors).
Example `SCsub` with custom flags:

.. code-block:: python

    # SCsub

    Import('env')

    env_tts = env.Clone()
    env_tts.add_source_files(env.modules_sources, "*.cpp")
	# Append CCFLAGS flags for both C and C++ code.
    env_tts.Append(CCFLAGS=['-O2'])
    # If you need to, you can:
    # - Append CFLAGS for C code only.
    # - Append CXXFLAGS for C++ code only.

The final module should look like this:

.. code-block:: none

    godot/modules/tts/festival/
    godot/modules/tts/libpath/libestbase.a
    godot/modules/tts/libpath/libestools.a
    godot/modules/tts/libpath/libeststring.a
    godot/modules/tts/libpath/libFestival.a
    godot/modules/tts/speech_tools/
    godot/modules/tts/config.py
    godot/modules/tts/tts.h
    godot/modules/tts/tts.cpp
    godot/modules/tts/register_types.h
    godot/modules/tts/register_types.cpp
    godot/modules/tts/SCsub

Using the module
----------------

You can now use your newly created module from any script:

::

    var t = TTS.new()
    var script = "Hello world. This is a test!"
    var is_spoken = t.say_text(script)
    print('is_spoken: ', is_spoken)

And the output will be ``is_spoken: True`` if the text is spoken.


===================================================
/. ./development/cpp/custom_godot_servers.rst
===================================================

.. _doc_custom_godot_servers:

Custom Godot servers
====================

Introduction
------------

Godot implements multi-threading as servers. Servers are daemons which
manage data, process it, and push the result. Servers implement the
mediator pattern which interprets resource ID and process data for the
engine and other modules. In addition, the server claims ownership for
its RID allocations.

This guide assumes the reader knows how to create C++ modules and Godot
data types. If not, refer to :ref:`doc_custom_modules_in_c++`.

References
~~~~~~~~~~~

- `Why does Godot use servers and RIDs? <https://godotengine.org/article/why-does-godot-use-servers-and-rids>`__
- `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__
- `Mediator pattern <https://en.wikipedia.org/wiki/Mediator_pattern>`__

What for?
---------

- Adding artificial intelligence.
- Adding custom asynchronous threads.
- Adding support for a new input device.
- Adding writing threads.
- Adding a custom VoIP protocol.
- And more...

Creating a Godot server
-----------------------

At minimum, a server must have a static instance, a sleep timer, a thread loop,
an initialization state and a cleanup procedure.

.. code-block:: cpp

	#ifndef HILBERT_HOTEL_H
	#define HILBERT_HOTEL_H

	#include "core/list.h"
	#include "core/object.h"
	#include "core/os/thread.h"
	#include "core/os/mutex.h"
	#include "core/rid.h"
	#include "core/set.h"
	#include "core/variant.h"

	class HilbertHotel : public Object {
		GDCLASS(HilbertHotel, Object);

		static HilbertHotel *singleton;
		static void thread_func(void *p_udata);

	private:
		bool thread_exited;
		mutable bool exit_thread;
		Thread *thread;
		Mutex *mutex;

	public:
		static HilbertHotel *get_singleton();
		Error init();
		void lock();
		void unlock();
		void finish();

	protected:
		static void _bind_methods();

	private:
		uint64_t counter;
		RID_Owner<InfiniteBus> bus_owner;
		// https://github.com/godotengine/godot/blob/3.x/core/rid.h#L196
		Set<RID> buses;
		void _emit_occupy_room(uint64_t room, RID rid);

	public:
		RID create_bus();
		Variant get_bus_info(RID id);
		bool empty();
		bool delete_bus(RID id);
		void clear();
		void register_rooms();
		HilbertHotel();
	};

	#endif

.. code-block:: cpp

	#include "hilbert_hotel.h"

	#include "core/dictionary.h"
	#include "core/list.h"
	#include "core/os/os.h"
	#include "core/variant.h"

	#include "prime_225.h"

	void HilbertHotel::thread_func(void *p_udata) {

		HilbertHotel *ac = (HilbertHotel *) p_udata;
		uint64_t msdelay = 1000;

		while (!ac->exit_thread) {
			if (!ac->empty()) {
				ac->lock();
				ac->register_rooms();
				ac->unlock();
			}
			OS::get_singleton()->delay_usec(msdelay * 1000);
		}
	}

	Error HilbertHotel::init() {
		thread_exited = false;
		counter = 0;
		mutex = Mutex::create();
		thread = Thread::create(HilbertHotel::thread_func, this);
		return OK;
	}

	HilbertHotel *HilbertHotel::singleton = NULL;

	HilbertHotel *HilbertHotel::get_singleton() {
		return singleton;
	}

	void HilbertHotel::register_rooms() {
		for (Set<RID>::Element *e = buses.front(); e; e = e->next()) {
			auto bus = bus_owner.getornull(e->get());

			if (bus) {
				uint64_t room = bus->next_room();
				_emit_occupy_room(room, bus->get_self());
			}
		}
	}

	void HilbertHotel::unlock() {
		if (!thread || !mutex) {
			return;
		}

		mutex->unlock();
	}

	void HilbertHotel::lock() {
		if (!thread || !mutex) {
			return;
		}

		mutex->lock();
	}

	void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
		_HilbertHotel::get_singleton()->_occupy_room(room, rid);
	}

	Variant HilbertHotel::get_bus_info(RID id) {
		InfiniteBus *)bus = bus_owner.getornull(id);

		if (bus) {
			Dictionary d;
			d["prime"] = bus->get_bus_num();
			d["current_room"] = bus->get_current_room();
			return d;
		}

		return Variant();
	}

	void HilbertHotel::finish() {
		if (!thread) {
			return;
		}

		exit_thread = true;
		Thread::wait_to_finish(thread);

		memdelete(thread);

		if (mutex) {
			memdelete(mutex);
		}

		thread = NULL;
	}

	RID HilbertHotel::create_bus() {
		lock();
		InfiniteBus *ptr = memnew(InfiniteBus(PRIME[counter++]));
		RID ret = bus_owner.make_rid(ptr);
		ptr->set_self(ret);
		buses.insert(ret);
		unlock();

		return ret;
	}

	// https://github.com/godotengine/godot/blob/3.x/core/rid.h#L187
	bool HilbertHotel::delete_bus(RID id) {
		if (bus_owner.owns(id)) {
			lock();
			InfiniteBus *b = bus_owner.get(id);
			bus_owner.free(id);
			buses.erase(id);
			memdelete(b);
			unlock();
			return true;
		}

		return false;
	}

	void HilbertHotel::clear() {
		for (Set<RID>::Element *e = buses.front(); e; e = e->next()) {
			delete_bus(e->get());
		}
	}

	bool HilbertHotel::empty() {
		return buses.size() <= 0;
	}

	void HilbertHotel::_bind_methods() {
	}

	HilbertHotel::HilbertHotel() {
		singleton = this;
	}

.. code-block:: cpp

	/* prime_225.h */

	#include "core/int_types.h"

	const uint64_t PRIME[225] = {
			2,3,5,7,11,13,17,19,23,
			29,31,37,41,43,47,53,59,61,
			67,71,73,79,83,89,97,101,103,
			107,109,113,127,131,137,139,149,151,
			157,163,167,173,179,181,191,193,197,
			199,211,223,227,229,233,239,241,251,
			257,263,269,271,277,281,283,293,307,
			311,313,317,331,337,347,349,353,359,
			367,373,379,383,389,397,401,409,419,
			421,431,433,439,443,449,457,461,463,
			467,479,487,491,499,503,509,521,523,
			541,547,557,563,569,571,577,587,593,
			599,601,607,613,617,619,631,641,643,
			647,653,659,661,673,677,683,691,701,
			709,719,727,733,739,743,751,757,761,
			769,773,787,797,809,811,821,823,827,
			829,839,853,857,859,863,877,881,883,
			887,907,911,919,929,937,941,947,953,
			967,971,977,983,991,997,1009,1013,1019,
			1021,1031,1033,1039,1049,1051,1061,1063,1069,
			1087,1091,1093,1097,1103,1109,1117,1123,1129,
			1151,1153,1163,1171,1181,1187,1193,1201,1213,
			1217,1223,1229,1231,1237,1249,1259,1277,1279,
			1283,1289,1291,1297,1301,1303,1307,1319,1321,
			1327,1361,1367,1373,1381,1399,1409,1423,1427
	};

Custom managed resource data
----------------------------

Godot servers implement a mediator pattern. All data types inherit ``RID_Data``.
``RID_Owner<MyRID_Data>`` owns the object when ``make_rid`` is called. During debug mode only,
RID_Owner maintains a list of RIDs. In practice, RIDs are similar to writing
object-oriented C code.

.. code-block:: cpp

	class InfiniteBus : public RID_Data {
		RID self;

	private:
		uint64_t prime_num;
		uint64_t num;

	public:
		uint64_t next_room() {
			return prime_num * num++;
		}

		uint64_t get_bus_num() const {
			return prime_num;
		}

		uint64_t get_current_room() const {
			return prime_num * num;
		}

		_FORCE_INLINE_ void set_self(const RID &p_self) {
			self = p_self;
		}

		_FORCE_INLINE_ RID get_self() const {
			return self;
		}

		InfiniteBus(uint64_t prime) : prime_num(prime), num(1) {};
		~InfiniteBus() {};
	}

References
~~~~~~~~~~~

- :ref:`RID<class_rid>`
- `core/rid.h <https://github.com/godotengine/godot/blob/3.x/core/rid.h>`__

Registering the class in GDScript
---------------------------------

Servers are allocated in ``register_types.cpp``. The constructor sets the static
instance and ``init()`` creates the managed thread; ``unregister_types.cpp``
cleans up the server.

Since a Godot server class creates an instance and binds it to a static singleton,
binding the class might not reference the correct instance. Therefore, a dummy
class must be created to reference the proper Godot server.

In ``register_server_types()``, ``Engine::get_singleton()->add_singleton``
is used to register the dummy class in GDScript.

.. code-block:: cpp

	/* register_types.cpp */

	#include "register_types.h"

	#include "core/class_db.h"
	#include "core/engine.h"

	#include "hilbert_hotel.h"

	static HilbertHotel *hilbert_hotel = NULL;
	static _HilbertHotel *_hilbert_hotel = NULL;

	void register_hilbert_hotel_types() {
		hilbert_hotel = memnew(HilbertHotel);
		hilbert_hotel->init();
		_hilbert_hotel = memnew(_HilbertHotel);
		ClassDB::register_class<_HilbertHotel>();
		Engine::get_singleton()->add_singleton(Engine::Singleton("HilbertHotel", _HilbertHotel::get_singleton()));
	}

	void unregister_hilbert_hotel_types() {
		if (hilbert_hotel) {
			hilbert_hotel->finish();
			memdelete(hilbert_hotel);
		}

		if (_hilbert_hotel) {
			memdelete(_hilbert_hotel);
		}
	}

.. code-block:: cpp

	/* register_types.h */

	/* Yes, the word in the middle must be the same as the module folder name */
	void register_hilbert_hotel_types();
	void unregister_hilbert_hotel_types();

- `servers/register_server_types.cpp <https://github.com/godotengine/godot/blob/master/servers/register_server_types.cpp>`__

Bind methods
~~~~~~~~~~~~

The dummy class binds singleton methods to GDScript. In most cases, the dummy class methods wraps around.

.. code-block:: cpp

	Variant _HilbertHotel::get_bus_info(RID id) {
		return HilbertHotel::get_singleton()->get_bus_info(id);
	}

Binding Signals

It is possible to emit signals to GDScript by calling the GDScript dummy object.

.. code-block:: cpp

	void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
		_HilbertHotel::get_singleton()->_occupy_room(room, rid);
	}

.. code-block:: cpp

	class _HilbertHotel : public Object {
		GDCLASS(_HilbertHotel, Object);

		friend class HilbertHotel;
		static _HilbertHotel *singleton;

	protected:
		static void _bind_methods();

	private:
		void _occupy_room(int room_number, RID bus);

	public:
		RID create_bus();
		void connect_signals();
		bool delete_bus(RID id);
		static _HilbertHotel *get_singleton();
		Variant get_bus_info(RID id);

		_HilbertHotel();
		~_HilbertHotel();
	};

	#endif

.. code-block:: cpp

	_HilbertHotel *_HilbertHotel::singleton = NULL;
	_HilbertHotel *_HilbertHotel::get_singleton() { return singleton; }

	RID _HilbertHotel::create_bus() {
		return HilbertHotel::get_singleton()->create_bus();
	}

	bool _HilbertHotel::delete_bus(RID rid) {
		return HilbertHotel::get_singleton()->delete_bus(rid);
	}

	void _HilbertHotel::_occupy_room(int room_number, RID bus) {
		emit_signal("occupy_room", room_number, bus);
	}

	Variant _HilbertHotel::get_bus_info(RID id) {
		return HilbertHotel::get_singleton()->get_bus_info(id);
	}

	void _HilbertHotel::_bind_methods() {
		ClassDB::bind_method(D_METHOD("get_bus_info", "r_id"), &_HilbertHotel::get_bus_info);
		ClassDB::bind_method(D_METHOD("create_bus"), &_HilbertHotel::create_bus);
		ClassDB::bind_method(D_METHOD("delete_bus"), &_HilbertHotel::delete_bus);
		ADD_SIGNAL(MethodInfo("occupy_room", PropertyInfo(Variant::INT, "room_number"), PropertyInfo(Variant::_RID, "r_id")));
	}

	void _HilbertHotel::connect_signals() {
		HilbertHotel::get_singleton()->connect("occupy_room", _HilbertHotel::get_singleton(), "_occupy_room");
	}

	_HilbertHotel::_HilbertHotel() {
		singleton = this;
	}

	_HilbertHotel::~_HilbertHotel() {
	}

MessageQueue
------------

In order to send commands into SceneTree, MessageQueue is a thread-safe buffer
to queue set and call methods for other threads. To queue a command, obtain
the target object RID and use either ``push_call``, ``push_set``, or ``push_notification``
to execute the desired behavior. The queue will be flushed whenever either
``SceneTree::idle`` or ``SceneTree::iteration`` is executed.

References:
~~~~~~~~~~~

- `core/message_queue.cpp <https://github.com/godotengine/godot/blob/3.x/core/message_queue.cpp>`__

Summing it up
-------------

Here is the GDScript sample code:

::

    extends Node

    func _ready():
        print("Start debugging")
        HilbertHotel.connect("occupy_room", self, "_print_occupy_room")
        var rid = HilbertHotel.create_bus()
        OS.delay_msec(2000)
        HilbertHotel.create_bus()
        OS.delay_msec(2000)
        HilbertHotel.create_bus()
        OS.delay_msec(2000)
        print(HilbertHotel.get_bus_info(rid))
        HilbertHotel.delete_bus(rid)
        print("Ready done")

    func _print_occupy_room(room_number, r_id):
        print("Room number: "  + str(room_number) + ", RID: " + str(r_id))
        print(HilbertHotel.get_bus_info(r_id))

Notes
~~~~~

- The actual `Hilbert Hotel <https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel>`__ is impossible.
- Connecting signal example code is pretty hacky.


===================================================
/. ./development/cpp/custom_resource_format_loaders.rst
===================================================

.. _doc_custom_resource_format_loaders:

Custom resource format loaders
==============================

Introduction
------------

ResourceFormatLoader is a factory interface for loading file assets.
Resources are primary containers. When load is called on the same file
path again, the previous loaded Resource will be referenced. Naturally,
loaded resources must be stateless.

This guide assumes the reader knows how to create C++ modules and Godot
data types. If not, refer to this guide :ref:`doc_custom_modules_in_c++`.

References
~~~~~~~~~~

- :ref:`ResourceLoader<class_resourceloader>`
- `core/io/resource_loader.cpp <https://github.com/godotengine/godot/blob/master/core/io/resource_loader.cpp>`_

What for?
---------

- Adding new support for many file formats
- Audio formats
- Video formats
- Machine learning models

What not?
---------

- Raster images

ImageFormatLoader should be used to load images.

References
~~~~~~~~~~

- `core/io/image_loader.h <https://github.com/godotengine/godot/blob/master/core/io/image_loader.h>`_


Creating a ResourceFormatLoader
-------------------------------

Each file format consist of a data container and a ``ResourceFormatLoader``.

ResourceFormatLoaders are usually simple classes which return all the
necessary metadata for supporting new extensions in Godot. The
class must return the format name and the extension string.

In addition, ResourceFormatLoaders must convert file paths into
resources with the ``load`` function. To load a resource, ``load`` must
read and handle data serialization.


.. code-block:: cpp

    /* resource_loader_json.h */

    #ifndef RESOURCE_LOADER_JSON_H
    #define RESOURCE_LOADER_JSON_H

    #include "core/io/resource_loader.h"

    class ResourceFormatLoaderJson : public ResourceFormatLoader {
    	GDCLASS(ResourceFormatLoaderJson, ResourceFormatLoader);
    public:
    	virtual RES load(const String &p_path, const String &p_original_path, Error *r_error = NULL);
    	virtual void get_recognized_extensions(List<String> *r_extensions) const;
    	virtual bool handles_type(const String &p_type) const;
    	virtual String get_resource_type(const String &p_path) const;
    };
    #endif // RESOURCE_LOADER_JSON_H

.. code-block:: cpp

    /* resource_loader_json.cpp */

    #include "resource_loader_json.h"

    #include "resource_json.h"

    RES ResourceFormatLoaderJson::load(const String &p_path, const String &p_original_path, Error *r_error) {
    Ref<JsonResource> json = memnew(JsonResource);
    	if (r_error) {
    		*r_error = OK;
    	}
    	Error err = json->load_file(p_path);
    	return json;
    }

    void ResourceFormatLoaderJson::get_recognized_extensions(List<String> *r_extensions) const {
    	if (!r_extensions->find("json")) {
    		r_extensions->push_back("json");
    	}
    }

    String ResourceFormatLoaderJson::get_resource_type(const String &p_path) const {
    	return "Resource";
    }

    bool ResourceFormatLoaderJson::handles_type(const String &p_type) const {
    	return ClassDB::is_parent_class(p_type, "Resource");
    }

Creating a ResourceFormatSaver
------------------------------

If you'd like to be able to edit and save a resource, you can implement a
``ResourceFormatSaver``:

.. code-block:: cpp

    /* resource_saver_json.h */

    #ifndef RESOURCE_SAVER_JSON_H
    #define RESOURCE_SAVER_JSON_H

    #include "core/io/resource_saver.h"

    class ResourceFormatSaverJson : public ResourceFormatSaver {
    	GDCLASS(ResourceFormatSaverJson, ResourceFormatSaver);
    public:
    	virtual Error save(const String &p_path, const RES &p_resource, uint32_t p_flags = 0);
    	virtual bool recognize(const RES &p_resource) const;
    	virtual void get_recognized_extensions(const RES &p_resource, List<String> *r_extensions) const;
    };
    #endif // RESOURCE_SAVER_JSON_H

.. code-block:: cpp

    /* resource_saver_json.cpp */

    #include "resource_saver_json.h"

    #include "resource_json.h"
    #include "scene/resources/resource_format_text.h"

    Error ResourceFormatSaverJson::save(const String &p_path, const RES &p_resource, uint32_t p_flags) {
    	Ref<JsonResource> json = memnew(JsonResource);
    	Error error = json->save_file(p_path, p_resource);
    	return error;
    }

    bool ResourceFormatSaverJson::recognize(const RES &p_resource) const {
    	return Object::cast_to<JsonResource>(*p_resource) != NULL;
    }

    void ResourceFormatSaverJson::get_recognized_extensions(const RES &p_resource, List<String> *r_extensions) const {
    	if (Object::cast_to<JsonResource>(*p_resource)) {
    		r_extensions->push_back("json");
    	}
    }

Creating custom data types
--------------------------

Godot may not have a proper substitute within its :ref:`doc_core_types`
or managed resources. Godot needs a new registered data type to
understand additional binary formats such as machine learning models.

Here is an example of creating a custom datatype:

.. code-block:: cpp

    /* resource_json.h */

    #ifndef RESOURCE_JSON_H
    #define RESOURCE_JSON_H

    #include "core/io/json.h"
    #include "core/variant_parser.h"

    class JsonResource : public Resource {
    	GDCLASS(JsonResource, Resource);

    protected:
    	static void _bind_methods() {
    		ClassDB::bind_method(D_METHOD("set_dict", "dict"), &JsonResource::set_dict);
    		ClassDB::bind_method(D_METHOD("get_dict"), &JsonResource::get_dict);

    		ADD_PROPERTY(PropertyInfo(Variant::DICTIONARY, "content"), "set_dict", "get_dict");
    	}

    private:
    	Dictionary content;

    public:
    	Error load_file(const String &p_path);
    	Error save_file(const String &p_path, const RES &p_resource);

    	void set_dict(const Dictionary &p_dict);
    	Dictionary get_dict();
    };
    #endif // RESOURCE_JSON_H

.. code-block:: cpp

    /* resource_json.cpp */

    #include "resource_json.h"

    Error JsonResource::load_file(const String &p_path) {
    	Error error;
    	FileAccess *file = FileAccess::open(p_path, FileAccess::READ, &error);
    	if (error != OK) {
    		if (file) {
    			file->close();
    		}
    		return error;
    	}

    	String json_string = String("");
    	while (!file->eof_reached()) {
    		json_string += file->get_line();
    	}
    	file->close();

    	String error_string;
    	int error_line;
    	JSON json;
    	Variant result;
    	error = json.parse(json_string, result, error_string, error_line);
    	if (error != OK) {
    		file->close();
    		return error;
    	}

    	content = Dictionary(result);
    	return OK;
    }

    Error JsonResource::save_file(const String &p_path, const RES &p_resource) {
    	Error error;
    	FileAccess *file = FileAccess::open(p_path, FileAccess::WRITE, &error);
    	if (error != OK) {
    		if (file) {
    			file->close();
    		}
    		return error;
    	}

    	Ref<JsonResource> json_ref = p_resource.get_ref_ptr();
    	JSON json;

    	file->store_string(json.print(json_ref->get_dict(), "    "));
    	file->close();
    	return OK;
    }

    void JsonResource::set_dict(const Dictionary &p_dict) {
    	content = p_dict;
    }

    Dictionary JsonResource::get_dict() {
    	return content;
    }

Considerations
~~~~~~~~~~~~~~

Some libraries may not define certain common routines such as IO handling.
Therefore, Godot call translations are required.

For example, here is the code for translating ``FileAccess``
calls into ``std::istream``.

.. code-block:: cpp

    #include "core/os/file_access.h"

    #include <istream>
    #include <streambuf>

    class GodotFileInStreamBuf : public std::streambuf {

    public:
    	GodotFileInStreamBuf(FileAccess *fa) {
    		_file = fa;
    	}
    	int underflow() {
    		if (_file->eof_reached()) {
    			return EOF;
    		} else {
    			size_t pos = _file->get_position();
    			uint8_t ret = _file->get_8();
    			_file->seek(pos); // Required since get_8() advances the read head.
    			return ret;
    		}
    	}
    	int uflow() {
    		return _file->eof_reached() ? EOF : _file->get_8();
    	}

    private:
    	FileAccess *_file;
    };


References
~~~~~~~~~~

- `istream <http://www.cplusplus.com/reference/istream/istream/>`_
- `streambuf <http://www.cplusplus.com/reference/streambuf/streambuf/?kw=streambuf>`_
- `core/io/fileaccess.h <https://github.com/godotengine/godot/blob/master/core/os/file_access.h>`_

Registering the new file format
-------------------------------

Godot registers ``ResourcesFormatLoader`` with a ``ResourceLoader``
handler. The handler selects the proper loader automatically
when ``load`` is called.

.. code-block:: cpp

    /* register_types.h */

    void register_json_types();
    void unregister_json_types();

.. code-block:: cpp

    /* register_types.cpp */

    #include "register_types.h"

    #include "core/class_db.h"
    #include "resource_loader_json.h"
    #include "resource_saver_json.h"
    #include "resource_json.h"

    static Ref<ResourceFormatLoaderJson> json_loader;
    static Ref<ResourceFormatSaverJson> json_saver;

    void register_json_types() {
    	ClassDB::register_class<JsonResource>();

    	json_loader.instance();
    	ResourceLoader::add_resource_format_loader(json_loader);

    	json_saver.instance();
    	ResourceSaver::add_resource_format_saver(json_saver);
    }

    void unregister_json_types() {
    	ResourceLoader::remove_resource_format_loader(json_loader);
    	json_loader.unref();

    	ResourceSaver::remove_resource_format_saver(json_saver);
    	json_saver.unref();
    }

References
~~~~~~~~~~

- `core/io/resource_loader.cpp <https://github.com/godotengine/godot/blob/master/core/io/resource_loader.cpp>`_

Loading it on GDScript
----------------------

Save a file called ``demo.json`` with the following contents and place it in the
project's root folder:

.. code-block:: json

    {
      "savefilename": "demo.json",
      "demo": [
        "welcome",
        "to",
        "godot",
        "resource",
        "loaders"
      ]
    }

Then attach the following script to any node::

    extends Node

    onready var json_resource = load("res://demo.json")

    func _ready():
        print(json_resource.get_dict())


===================================================
/. ./development/cpp/custom_audiostreams.rst
===================================================

.. _doc_custom_audiostreams:

Custom AudioStreams
===================

Introduction
------------

AudioStream is the base class of all audio emitting objects.
AudioStreamPlayer binds onto an AudioStream to emit PCM data
into an AudioServer which manages audio drivers.

All audio resources require two audio based classes: AudioStream
and AudioStreamPlayback. As a data container, AudioStream contains
the resource and exposes itself to GDScript. AudioStream references
its own internal custom AudioStreamPlayback which translates
AudioStream into PCM data.

This guide assumes the reader knows how to create C++ modules. If not, refer to this guide
:ref:`doc_custom_modules_in_c++`.

References:
~~~~~~~~~~~

-  `servers/audio/audio_stream.h <https://github.com/godotengine/godot/blob/master/servers/audio/audio_stream.h>`__
-  `scene/audio/audioplayer.cpp <https://github.com/godotengine/godot/blob/master/scene/audio/audio_player.cpp>`__

What for?
---------

- Binding external libraries (like Wwise, FMOD, etc).
- Adding custom audio queues
- Adding support for more audio formats

Create an AudioStream
---------------------

An AudioStream consists of three components: data container, stream name,
and an AudioStreamPlayback friend class generator. Audio data can be
loaded in a number of ways such as with an internal counter for a tone generator,
internal/external buffer, or a file reference.

Some AudioStreams need to be stateless such as objects loaded from
ResourceLoader. ResourceLoader loads once and references the same
object regardless how many times ``load`` is called on a specific resource.
Therefore, playback state must be self-contained in AudioStreamPlayback.

.. code-block:: cpp

	/* audiostream_mytone.h */

	#include "core/reference.h"
	#include "core/resource.h"
	#include "servers/audio/audio_stream.h"

	class AudioStreamMyTone : public AudioStream {
		GDCLASS(AudioStreamMyTone, AudioStream)

	private:
		friend class AudioStreamPlaybackMyTone;
		uint64_t pos;
		int mix_rate;
		bool stereo;
		int hz;

	public:
		void reset();
		void set_position(uint64_t pos);
		virtual Ref<AudioStreamPlayback> instance_playback();
		virtual String get_stream_name() const;
		void gen_tone(int16_t *pcm_buf, int size);
		virtual float get_length() const { return 0; } // if supported, otherwise return 0
		AudioStreamMyTone();

	protected:
		static void _bind_methods();
	};

.. code-block:: cpp

	/* audiostream_mytone.cpp */

	#include "audiostream_mytone.h"

	AudioStreamMyTone::AudioStreamMyTone()
			: mix_rate(44100), stereo(false), hz(639) {
	}

	Ref<AudioStreamPlayback> AudioStreamMyTone::instance_playback() {
		Ref<AudioStreamPlaybackMyTone> talking_tree;
		talking_tree.instance();
		talking_tree->base = Ref<AudioStreamMyTone>(this);
		return talking_tree;
	}

	String AudioStreamMyTone::get_stream_name() const {
		return "MyTone";
	}
	void AudioStreamMyTone::reset() {
		set_position(0);
	}
	void AudioStreamMyTone::set_position(uint64_t p) {
		pos = p;
	}
	void AudioStreamMyTone::gen_tone(int16_t *pcm_buf, int size) {
		for (int i = 0; i < size; i++) {
			pcm_buf[i] = 32767.0 * sin(2.0 * Math_PI * double(pos + i) / (double(mix_rate) / double(hz)));
		}
		pos += size;
	}
	void AudioStreamMyTone::_bind_methods() {
		ClassDB::bind_method(D_METHOD("reset"), &AudioStreamMyTone::reset);
		ClassDB::bind_method(D_METHOD("get_stream_name"), &AudioStreamMyTone::get_stream_name);
	}

References:
~~~~~~~~~~~

-  `servers/audio/audio_stream.h <https://github.com/godotengine/godot/blob/master/servers/audio/audio_stream.h>`__


Create an AudioStreamPlayback
-----------------------------

AudioStreamPlayer uses ``mix`` callback to obtain PCM data. The callback must match sample rate and fill the buffer.

Since AudioStreamPlayback is controlled by the audio thread, i/o and dynamic memory allocation are forbidden.

.. code-block:: cpp

	/*  audiostreamplayer_mytone.h */

	#include "core/reference.h"
	#include "core/resource.h"
	#include "servers/audio/audio_stream.h"

	class AudioStreamPlaybackMyTone : public AudioStreamPlayback {
		GDCLASS(AudioStreamPlaybackMyTone, AudioStreamPlayback)
		friend class AudioStreamMyTone;

	private:
		enum {
			PCM_BUFFER_SIZE = 4096
		};
		enum {
			MIX_FRAC_BITS = 13,
			MIX_FRAC_LEN = (1 << MIX_FRAC_BITS),
			MIX_FRAC_MASK = MIX_FRAC_LEN - 1,
		};
		void *pcm_buffer;
		Ref<AudioStreamMyTone> base;
		bool active;

	public:
		virtual void start(float p_from_pos = 0.0);
		virtual void stop();
		virtual bool is_playing() const;
		virtual int get_loop_count() const; // times it looped
		virtual float get_playback_position() const;
		virtual void seek(float p_time);
		virtual void mix(AudioFrame *p_buffer, float p_rate_scale, int p_frames);
		virtual float get_length() const; // if supported, otherwise return 0
		AudioStreamPlaybackMyTone();
		~AudioStreamPlaybackMyTone();
	};

.. code-block:: cpp

	/* audiostreamplayer_mytone.cpp */

	#include "audiostreamplayer_mytone.h"

	#include "core/math/math_funcs.h"
	#include "core/print_string.h"

	AudioStreamPlaybackMyTone::AudioStreamPlaybackMyTone()
			: active(false) {
		AudioServer::get_singleton()->lock();
		pcm_buffer = AudioServer::get_singleton()->audio_data_alloc(PCM_BUFFER_SIZE);
		zeromem(pcm_buffer, PCM_BUFFER_SIZE);
		AudioServer::get_singleton()->unlock();
	}
	AudioStreamPlaybackMyTone::~AudioStreamPlaybackMyTone() {
		if(pcm_buffer) {
			AudioServer::get_singleton()->audio_data_free(pcm_buffer);
			pcm_buffer = NULL;
		}
	}
	void AudioStreamPlaybackMyTone::stop() {
		active = false;
		base->reset();
	}
	void AudioStreamPlaybackMyTone::start(float p_from_pos) {
		seek(p_from_pos);
		active = true;
	}
	void AudioStreamPlaybackMyTone::seek(float p_time) {
		float max = get_length();
		if (p_time < 0) {
				p_time = 0;
		}
		base->set_position(uint64_t(p_time * base->mix_rate) << MIX_FRAC_BITS);
	}
	void AudioStreamPlaybackMyTone::mix(AudioFrame *p_buffer, float p_rate, int p_frames) {
		ERR_FAIL_COND(!active);
		if (!active) {
				return;
		}
		zeromem(pcm_buffer, PCM_BUFFER_SIZE);
		int16_t *buf = (int16_t *)pcm_buffer;
		base->gen_tone(buf, p_frames);

		for(int i = 0; i < p_frames; i++) {
			float sample = float(buf[i]) / 32767.0;
			p_buffer[i] = AudioFrame(sample, sample);
		}
	}
	int AudioStreamPlaybackMyTone::get_loop_count() const {
		return 0;
	}
	float AudioStreamPlaybackMyTone::get_playback_position() const {
		return 0.0;
	}
	float AudioStreamPlaybackMyTone::get_length() const {
		return 0.0;
	}
	bool AudioStreamPlaybackMyTone::is_playing() const {
		return active;
	}

Resampling
~~~~~~~~~~

Godot's AudioServer currently uses 44100 Hz sample rate. When other sample rates are
needed such as 48000, either provide one or use AudioStreamPlaybackResampled.
Godot provides cubic interpolation for audio resampling.

Instead of overloading ``mix``, AudioStreamPlaybackResampled uses ``_mix_internal`` to
query AudioFrames and ``get_stream_sampling_rate`` to query current mix rate.

.. code-block:: cpp

	#include "core/reference.h"
	#include "core/resource.h"
	#include "servers/audio/audio_stream.h"

	class AudioStreamMyToneResampled;

	class AudioStreamPlaybackResampledMyTone : public AudioStreamPlaybackResampled {
		GDCLASS(AudioStreamPlaybackResampledMyTone, AudioStreamPlaybackResampled)
		friend class AudioStreamMyToneResampled;

	private:
		enum {
			PCM_BUFFER_SIZE = 4096
		};
		enum {
			MIX_FRAC_BITS = 13,
			MIX_FRAC_LEN = (1 << MIX_FRAC_BITS),
			MIX_FRAC_MASK = MIX_FRAC_LEN - 1,
		};
		void *pcm_buffer;
		Ref<AudioStreamMyToneResampled> base;
		bool active;

	protected:
		virtual void _mix_internal(AudioFrame *p_buffer, int p_frames);

	public:
		virtual void start(float p_from_pos = 0.0);
		virtual void stop();
		virtual bool is_playing() const;
		virtual int get_loop_count() const; // times it looped
		virtual float get_playback_position() const;
		virtual void seek(float p_time);
		virtual float get_length() const; // if supported, otherwise return 0
		virtual float get_stream_sampling_rate();
		AudioStreamPlaybackResampledMyTone();
		~AudioStreamPlaybackResampledMyTone();
	};

.. code-block:: cpp

	#include "mytone_audiostream_resampled.h"

	#include "core/math/math_funcs.h"
	#include "core/print_string.h"

	AudioStreamPlaybackResampledMyTone::AudioStreamPlaybackResampledMyTone()
			: active(false) {
		AudioServer::get_singleton()->lock();
		pcm_buffer = AudioServer::get_singleton()->audio_data_alloc(PCM_BUFFER_SIZE);
		zeromem(pcm_buffer, PCM_BUFFER_SIZE);
		AudioServer::get_singleton()->unlock();
	}
	AudioStreamPlaybackResampledMyTone::~AudioStreamPlaybackResampledMyTone() {
		if (pcm_buffer) {
			AudioServer::get_singleton()->audio_data_free(pcm_buffer);
			pcm_buffer = NULL;
		}
	}
	void AudioStreamPlaybackResampledMyTone::stop() {
		active = false;
		base->reset();
	}
	void AudioStreamPlaybackResampledMyTone::start(float p_from_pos) {
		seek(p_from_pos);
		active = true;
	}
	void AudioStreamPlaybackResampledMyTone::seek(float p_time) {
		float max = get_length();
		if (p_time < 0) {
				p_time = 0;
		}
		base->set_position(uint64_t(p_time * base->mix_rate) << MIX_FRAC_BITS);
	}
	void AudioStreamPlaybackResampledMyTone::_mix_internal(AudioFrame *p_buffer, int p_frames) {
		ERR_FAIL_COND(!active);
		if (!active) {
			return;
		}
		zeromem(pcm_buffer, PCM_BUFFER_SIZE);
		int16_t *buf = (int16_t *)pcm_buffer;
		base->gen_tone(buf, p_frames);

		for(int i = 0;  i < p_frames; i++) {
			float sample = float(buf[i]) / 32767.0;
				p_buffer[i] = AudioFrame(sample, sample);
		}
	}
	float AudioStreamPlaybackResampledMyTone::get_stream_sampling_rate() {
		return float(base->mix_rate);
	}
	int AudioStreamPlaybackResampledMyTone::get_loop_count() const {
		return 0;
	}
	float AudioStreamPlaybackResampledMyTone::get_playback_position() const {
		return 0.0;
	}
	float AudioStreamPlaybackResampledMyTone::get_length() const {
		return 0.0;
	}
	bool AudioStreamPlaybackResampledMyTone::is_playing() const {
		return active;
	}

References:
~~~~~~~~~~~
-  `core/math/audio_frame.h <https://github.com/godotengine/godot/blob/master/core/math/audio_frame.h>`__
-  `servers/audio/audio_stream.h <https://github.com/godotengine/godot/blob/master/servers/audio/audio_stream.h>`__
-  `scene/audio/audioplayer.cpp <https://github.com/godotengine/godot/blob/master/scene/audio/audio_player.cpp>`__


===================================================
/. ./development/cpp/macos_debug.rst
===================================================

Debugging on macOS
==================

Debugging Godot editor
----------------------

Attaching a debugger to the signed macOS process requires the "com.apple.security.get-task-allow" entitlement, which is not enabled by default, since apps can't be notarized as long as it is enabled.
If you want to debug an official build of the editor it should be re-signed with the proper entitlements.

Create an ``editor.entitlements`` text file with the following contents:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
        <dict>
            <key>com.apple.security.cs.allow-dyld-environment-variables</key>
            <true/>
            <key>com.apple.security.cs.allow-jit</key>
            <true/>
            <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
            <true/>
            <key>com.apple.security.cs.disable-executable-page-protection</key>
            <true/>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
            <key>com.apple.security.device.audio-input</key>
            <true/>
            <key>com.apple.security.device.camera</key>
            <true/>
        </dict>
    </plist>

Then use the following command to re-sign the editor::

    codesign -s - --deep --force --options=runtime --entitlements ./editor.entitlements ./path/to/Godot.app

Debugging exported project
--------------------------

To allow debugging, select the ``codesign\debugging`` (``com.apple.security.get-task-allow``) entitlement during the export. When it is selected, notarization is not supported and should be disabled.


===================================================
/. ./development/cpp/using_cpp_profilers.rst
===================================================

.. _doc_using_cpp_profilers:

Using C++ profilers
===================

To optimize Godot's performance, you need to know what to optimize first.
To this end, profilers are useful tools.

.. note::

    There is a built-in GDScript profiler in the editor, but using C++ profiler
    may be useful in cases where the GDScript profiler is not accurate enough
    or is missing information due to bugs in the profiler.

Recommended profilers
---------------------

- `VerySleepy <http://www.codersnotes.com/sleepy/>`__ (Windows only)
- `HotSpot <https://github.com/KDAB/hotspot>`__ (Linux only)
- `Xcode Instruments <https://developer.apple.com/xcode/>`__ (macOS only)

These profilers may not be the most powerful or flexible options, but their
standalone operation and limited feature set tends to make them easier to use.

Setting up Godot
----------------

To get useful profiling information, it is **absolutely required** to use a Godot
build that includes debugging symbols. Official binaries do not include debugging
symbols, since these would make the download size significantly larger.

To get profiling data that best matches the production environment (but with debugging symbols),
you should compile binaries with the ``production=yes debug_symbols=yes`` SCons options.

It is possible to run a profiler on less optimized builds (e.g. ``target=debug`` without LTO),
but results will naturally be less representative of real world conditions.

.. warning::

    Do *not* strip debugging symbols on the binaries using the ``strip`` command
    after compiling the binaries. Otherwise, you will no longer get useful
    profiling information when running a profiler.

Benchmarking startup/shutdown times
-----------------------------------

If you're looking into optimizing Godot's startup/shutdown performance,
you can tell the profiler to use the ``--quit`` command line option on the Godot binary.
This will exit Godot just after it finished starting.
The ``--quit`` option works with ``--editor``, ``--project-manager`` or
``--path <path to project directory>`` (which runs a project directly).

.. seealso::

    See :ref:`doc_command_line_tutorial` for more command line arguments
    supported by Godot.

Profiler-specific instructions
------------------------------

VerySleepy
^^^^^^^^^^

- Start the Godot editor or your project first.
  If you start the project manager, make sure to edit or run a project first.
  Otherwise, the profiler will not track the child process since the project manager
  will spawn a child process for every project edited or run.
- Open VerySleepy and select the Godot executable in the list of processes on the left:

.. image:: img/cpp_profiler_verysleepy_select_process.png

- Click the **Profile All** button on the right to start profiling.
- Perform the actions you wish to profile in the editor or project. When you're done, click **Stop** (*not* Abort).
- Wait for the results window to appear.
- Once the results window appears, filter the view to remove external modules (such as the graphics driver).
  You can filter by module by finding a line whose **Module** matches the Godot
  executable name, right-clicking that line then choosing
  **Filter Module to <Godot executable name>** in the dropdown that appears.
- Your results window should now look something like this:

.. image:: img/cpp_profiler_verysleepy_results_filtered.png

HotSpot
^^^^^^^

- Open HotSpot. Click **Record Data**:

.. image:: img/cpp_profiler_hotspot_welcome.png

- In the next window, specify the path to the Godot binary that includes debug symbols.
- Specify command line arguments to run a specific project, with or without the editor.
- The path to the working directory can be anything if an absolute path is used
  for the ``--path`` command line argument. Otherwise, it must be set to that
  the relative path to the project is valid.
- Make sure **Elevate Privileges** is checked if you have administrative privileges.
  While not essential for profiling Godot, this will ensure all events can be captured.
  Otherwise, some events may be missing in the capture.
  Your settings should now look something like this:

.. image:: img/cpp_profiler_hotspot_record.png

- Click **Start Recording** and perform the actions you wish to profile in the editor/project.
- Quit the editor/project normally or use the **Stop Profiling** button in HotSpot
  to stop profiling early. Stopping profiling early can result in cleaner profiles
  if you're not interested in the engine's quit procedure.
- Click **View Results** and wait for the profiling visualization to be generated:

.. image:: img/cpp_profiler_hotspot_view_results.png

- Use the tabs at the top to navigate between the different views. These views
  show the same data, but in different ways. The **Flame Graph** tab is a good
  way to see which functions take up the most time at a glance. These functions
  are therefore the most important ones to optimize, since optimizing them will
  improve performance the most.
- At the bottom of all tabs except **Summary**, you will also see a list of CPU threads
  started by the engine among with the CPU utilization for each thread.
  This lets you see threads that can be a bottleneck at a given point in time.

.. image:: img/cpp_profiler_hotspot_flame_graph.png

.. note::

    If you don't want the startup procedure to be included in the profile, you
    can also attach HotSpot to a running process by clicking **Record Data**
    then setting the **Launch Application** dropdown option to **Attach To
    Process(es)**.

    This process attachment-based workflow is similar to the one used by VerySleepy.

Xcode Instruments
^^^^^^^^^^^^^^^^^

- Open Xcode. Select **Open Developer Tool** - **Instruments** from the **Xcode** app menu:
- Double-click on **Time Profiler** in the **Instruments** window:

.. image:: img/cpp_profiler_xcode_menu.png

- In the Time Profiler window, click on the **Target** menu, select **Choose target...**
  and specify the path to the Godot binary, command line arguments and environment variables
  in the next window.

.. image:: img/cpp_profiler_time_profiler.png

- You can also attach the Time Profiler to a running process by selecting it from the **Target**
  menu.

- Click the **Start an immediate mode recording** button to start profiling.

.. image:: img/cpp_profiler_time_profiler_record.png

- Perform the actions you wish to profile in the editor or project. When you're done,
  click the **Stop** button.

- Wait for the results to appear.
- At the bottom of the window you will see a call tree for all CPU threads started, and
  the **Heaviest Stack Trace** overview.
- Select **Hide system libraries** in the **Call Tree** menu (at the bottom of window) to
  remove external modules.
- You can use the timeline at the top of the window to display details for the specific time period.

.. image:: img/cpp_profiler_time_profiler_result.png


===================================================
/. ./development/editor/index.rst
===================================================

Editor development
==================

.. toctree::
   :maxdepth: 1
   :name: toc-devel-editor

   introduction_to_editor_development
   creating_icons
   editor_style_guide


===================================================
/. ./development/editor/introduction_to_editor_development.rst
===================================================

.. _doc_introduction_to_editor_development:

Introduction to editor development
==================================

On this page, you will learn:

- The **design decisions** behind the Godot editor.
- How to work efficiently on the Godot editor's C++ code.

This guide is aimed at current or future engine contributors.
To create editor plugins in GDScript, see :ref:`doc_making_plugins` instead.

.. seealso::

    If you are new to Godot, we recommended you to read
    :ref:`doc_godot_design_philosophy` before continuing. Since the Godot editor
    is a Godot project written in C++, much of the engine's philosophy applies
    to the editor.

Technical choices
-----------------

The Godot editor is drawn using Godot's renderer and
:ref:`UI system <toc-gui-basics>`. It does *not* rely on a toolkit
such as GTK or Qt. This is similar in spirit to software like Blender.
While using toolkits makes it easier to achieve a "native" appearance, they are
also quite heavy and their licensing is not compatible with Godot's.

The editor is fully written in C++. It can't contain any GDScript or C# code.

Directory structure
-------------------

The editor's code is fully self-contained in the
`editor/ <https://github.com/godotengine/godot/tree/master/editor>`__ folder
of the Godot source repository.

Some editor functionality is also implemented via
:ref:`modules <doc_custom_modules_in_c++>`. Some of these are only enabled in
editor builds to decrease the binary size of export templates. See the
`modules/ <https://github.com/godotengine/godot/tree/master/modules>`__ folder
in the Godot source repository.

Some important files in the editor are:

- `editor/editor_node.cpp <https://github.com/godotengine/godot/blob/3.x/editor/editor_node.cpp>`__:
  Main editor initialization file. Effectively the "main scene" of the editor.
- `editor/project_manager.cpp <https://github.com/godotengine/godot/blob/3.x/editor/project_manager.cpp>`__:
  Main project manager initialization file. Effectively the "main scene" of the project manager.
- `editor/plugins/canvas_item_editor_plugin.cpp <https://github.com/godotengine/godot/blob/3.x/editor/plugins/canvas_item_editor_plugin.cpp>`__:
  The 2D editor viewport and related functionality (toolbar at the top, editing modes, overlaid helpers/panels, …).
- `editor/plugins/spatial_editor_plugin.cpp <https://github.com/godotengine/godot/blob/3.x/editor/plugins/spatial_editor_plugin.cpp>`__:
  The 3D editor viewport and related functionality (toolbar at the top, editing modes, overlaid panels, …).
- `editor/spatial_editor_gizmos.cpp <https://github.com/godotengine/godot/blob/3.x/editor/spatial_editor_gizmos.cpp>`__:
  Where the 3D editor gizmos are defined and drawn.
  This file doesn't have a 2D counterpart as 2D gizmos are drawn by the nodes themselves.

Editor dependencies in ``scene/`` files
---------------------------------------

When working on an editor feature, you may have to modify files in
Godot's GUI nodes, which you can find in the ``scene/`` folder.

One rule to keep in mind is that you must **not** introduce new dependencies to
``editor/`` includes in other folders such as ``scene/``. This applies even if
you use ``#ifdef TOOLS_ENABLED``.

To make the codebase easier to follow and more self-contained, the allowed
dependency order is:

- ``editor/`` -> ``scene/`` -> ``servers/`` -> ``core/``

This means that files in ``editor/`` can depend on includes from ``scene/``,
``servers/``, and ``core/``. But, for example, while ``scene/`` can depend on includes
from ``servers/`` and ``core/``, it cannot depend on includes from ``editor/``.

Currently, there are some dependencies to ``editor/`` includes in ``scene/``
files, but
`they are in the process of being removed <https://github.com/godotengine/godot/issues/29730>`__.

Development tips
----------------

To iterate quickly on the editor, we recommend to set up a test project and
:ref:`open it from the command line <doc_command_line_tutorial>` after compiling
the editor. This way, you don't have to go through the project manager every
time you start Godot.


===================================================
/. ./development/editor/creating_icons.rst
===================================================

.. _doc_editor_icons:

Editor icons
============

When a new class is created and exposed to scripting, the editor's interface
will display it with a default icon representing the base class it inherits
from. In most cases, it's still recommended to create icons for new classes to
improve the user experience.

Creating icons
~~~~~~~~~~~~~~

To create new icons, you first need a vector graphics editor installed.
For instance, you can use the open source `Inkscape <https://inkscape.org/>`_ editor.

Clone the ``godot`` repository containing all the editor icons:

.. code-block:: bash

    git clone https://github.com/godotengine/godot.git

The icons must be created in a vector graphics editor in SVG format. There are
two main requirements to follow:

- Icons must be 16×16. In Inkscape, you can configure the document size in
  **File > Document Properties**.
- Lines should be snapped to pixels whenever possible to remain crisp at lower DPI.
  You can create a 16×16 grid in Inkscape to make this easier.

Once you're satisfied with the icon's design, save the icon in the cloned
repository's ``editor/icons`` folder. The icon name should match the intended
name in a case-sensitive manner. For example, to create an icon for
CPUParticles2D, name the file ``CPUParticles2D.svg``.

Color conversion for light editor themes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If the user has configured their editor to use a light theme, Godot will
convert the icon's colors based on a
`set of predefined color mappings <https://github.com/godotengine/godot/blob/b9f2e57d6240346f1833fd0390de195c956299e7/editor/editor_themes.cpp#L122-L184>`__.
This is to ensure the icon always displays with a sufficient contrast rate.
Try to restrict your icon's color palette to colors found in the list above.
Otherwise, your icon may become difficult to read on a light background.

Icon optimization
~~~~~~~~~~~~~~~~~

Because the editor renders SVGs once at load time, they need to be small
in size so they can be efficiently parsed. Editor icons must be first
optimized before being added to the engine, to do so:

1. Install `svgcleaner <https://github.com/RazrFalcon/svgcleaner>`__
   by downloading a binary from its
   `Releases tab <https://github.com/RazrFalcon/svgcleaner/releases/latest>`__
   and placing it into a location in your ``PATH`` environment variable.

2. Run the command below, replacing ``svg_source.svg`` with the path to your
   SVG file (which can be a relative or absolute path):

   .. code-block:: bash

       svgcleaner --multipass svg_source.svg svg_optimized.svg

The ``--multipass`` switch improves compression, so make sure to include it.
The optimized icon will be saved to ``svg_optimized.svg``. You can also change
the destination parameter to any relative or absolute path you'd like.

.. note::

    While this optimization step won't impact the icon's quality noticeably, it
    will still remove editor-only information such as guides. Therefore, it's
    recommended to keep the source SVG around if you need to make further
    changes.

Integrating and sharing the icons
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're contributing to the engine itself, you should make a pull request to
add optimized icons to ``editor/icons`` in the main repository. Recompile the
engine to make it pick up new icons for classes.

It's also possible to create custom icons within a module. If you're creating
your own module and don't plan to integrate it with Godot, you don't need to
make a separate pull request for your icons to be available within the editor
as they can be self-contained.

For specific instructions on how to create module icons, refer to
:ref:`Creating custom module icons<doc_custom_module_icons>`.

Troubleshooting
~~~~~~~~~~~~~~~

If icons don't appear in the editor, make sure that:

1. Each icon's filename matches the naming requirement as described previously.

2. ``modules/svg`` is enabled (it should be enabled by default). Without it,
   icons won't appear in the editor at all.

References
~~~~~~~~~~

-  `editor/icons <https://github.com/godotengine/godot/tree/master/editor/icons>`__


===================================================
/. ./development/editor/editor_style_guide.rst
===================================================

.. _doc_editor_style_guide:

Editor style guide
==================

Introduction
------------

Thanks for your interest in contributing to the Godot editor!

This page describes the grammar and writing style used throughout the Godot
editor. Following this style guide will help your contribution get merged faster
since there will be fewer review steps required.

Writing style
-------------

- **Write messages (errors, warnings, ...) as full sentences.** They should start
  with an uppercase letter and end with a period.
- **Try to keep sentences short.** This makes it more likely that their translations
  will be short as well, which is a good thing to avoid UI bugs.
- **Use contractions.** For example, use "isn't" instead of "is not". An exception
  to this rule can be made when you specifically want to emphasize one of the
  contraction's words.
- **Use double quotes in messages** (``""``) instead of single quotes (``''``).
  Double quotes should be used to quote user input, file paths and possibly
  other things depending on the context.

.. seealso::

    Try to follow the :ref:`doc_docs_writing_guidelines` in addition to the
    guidelines outlined above.

Button and menu texts
---------------------

Capitalize text in buttons and menu actions:

- **Good:** *Open Editor Data Folder*
- **Bad:** *Open editor data folder*

If a menu action opens a modal dialog, suffix it with an ellipsis (``...``).

- **Good:** *Editor Settings...*
- **Bad:** *Editor Settings*

Inspector sections
------------------

In general, don't create sections that contain less than 3 items. Sections that
contain few items make it difficult to navigate the inspector, while missing the
benefits of using sections such as folding.

There are some valid exceptions for this, such as material features in
:ref:`class_SpatialMaterial`.

This advice also applies to the Project Settings and Editor Settings.

Inspector performance hints
---------------------------

Enum properties that noticeably impact performance should have a performance
hint associated. The hint should refer to the *absolute* performance impact,
rather than being relative to the other options provided in the enum. Here are
some examples taken from the Godot editor:

- **Screen-space antialiasing:** *Disabled (Fastest), FXAA (Fast)*
- **MSAA quality:** *Disabled (Fastest), 2x (Fast), 4x (Average), 8x (Slow), 16x
  (Slower)*
- **DirectionalLight mode:** *Orthogonal (Fast), PSSM 2 Splits
  (Average), PSSM 4 Splits (Slow)*

For consistency, try to stick to the terms below (from fastest to slowest):

- *Fastest, Faster, Fast, Average, Slow, Slower, Slowest*

Their usage doesn't have to be contiguous. For example, you can use only "Fast"
and "Slow" from the list above.

If you're adding a new enum, its values should be ordered from the fastest
option to the slowest option.

Tooltips
--------

Consider adding tooltips whenever the action performed by a button or menu
action isn't obvious. You can also provide additional context or highlight
caveats in the tooltip.

You can do this by calling ``set_tooltip(TTR("Text here."))`` on the
Control-based node in question. If the tooltip is particularly long (more than
~80 characters), wrap it over several lines by adding line breaks using ``\n``.

Tooltips should follow the writing style described above. In addition to this,
use indicative mood instead of imperative mood:

- **Good:** *Computes global illumination for the selected GIProbe.*
- **Bad:** *Compute global illumination for the selected GIProbe.*


===================================================
/. ./development/file_formats/index.rst
===================================================

Godot file formats
==================

.. toctree::
   :maxdepth: 1
   :name: toc-devel-file-formats

   gdscript_grammar.rst
   tscn.rst


===================================================
/. ./development/file_formats/gdscript_grammar.rst
===================================================

.. _doc_gdscript_grammar:

GDScript grammar
================

This is the formal grammar of GDScript written in `EBNF <https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form>`_,
for reference purposes.

.. note:: This grammar is descriptive only, derived from the reference
          documentation and current implementation. The GDScript parser is
          **not** generated from a grammar definition. Inconsistencies here
          likely mean an error in this grammar, not a bug in GDScript.

.. code-block:: ebnf

    (* GDScript EBNF grammar.
       Uppercase words are terminals generated by the tokenizer.
       INDENT/DEDENT are not generated by the tokenizer yet, but they are added
       here for reading convenience.
       Naturally, this only cover syntax. Semantics can't be inferred from this
       description.
    *)

    program = [ inheritance NEWLINE ] [ className ] { topLevelDecl } ;

    inheritance = "extends" ( IDENTIFIER | STRING ) { "." IDENTIFIER } ;
    className = "class_name" IDENTIFIER [ "," STRING ] NEWLINE ;

    topLevelDecl
        = classVarDecl
        | constDecl
        | signalDecl
        | enumDecl
        | methodDecl
        | constructorDecl
        | innerClass
        | "tool"
        ;

    classVarDecl = [ "onready" ] [ export ] "var" IDENTIFIER [ ":" typeHint ]
        [ "=" expression ] [ setget ] NEWLINE ;
    setget = "setget" [ IDENTIFIER ] [ "," IDENTIFIER] ;
    export = "export" [ "(" [ BUILTINTYPE | IDENTIFIER { "," literal } ] ")" ] ;
    typeHint = BUILTINTYPE | IDENTIFIER ;

    constDecl = "const" IDENTIFIER [ ":" typeHint ] "=" expression NEWLINE ;

    signalDecl = "signal" IDENTIFIER [ signalParList ] NEWLINE ;
    signalParList = "(" [ IDENTIFIER { "," IDENTIFIER } ] ")" ;

    enumDecl = "enum" [ IDENTIFIER ] "{" [ IDENTIFIER [ "=" INTEGER ]
        { "," IDENTIFIER [ "=" INTEGER ] } [ "," ] ] "}" NEWLINE ;

    methodDecl = [ rpc ] [ "static" ] "func" IDENTIFIER "(" [ parList ] ")"
        [ "->" typeHint] ":" stmtOrSuite ;
    parList = parameter { "," parameter } ;
    parameter = [ "var" ] IDENTIFIER [ ":" typeHint ] [ "=" expression ] ;
    rpc = "remote" | "master" | "puppet"
        | "remotesync" | "mastersync"  | "puppetsync";

    constructorDecl = "func" IDENTIFIER "(" [ parList ] ")"
        [ "." "(" [ argList ] ")" ] ":" stmtOrSuite ;
    argList = expression { "," expression } ;

    innerClass = "class" IDENTIFIER [ inheritance ] ":" NEWLINE
        INDENT [ inheritance NEWLINE ] topLevelDecl { topLevelDecl } DEDENT ;

    stmtOrSuite = stmt | NEWLINE INDENT suite DEDENT ;
    suite = stmt { stmt };

    stmt
        = varDeclStmt
        | ifStmt
        | forStmt
        | whileStmt
        | matchStmt
        | flowStmt
        | assignmentStmt
        | exprStmt
        | assertStmt
        | yieldStmt
        | preloadStmt
        | "breakpoint" stmtEnd
        | "pass" stmtEnd
        ;
    stmtEnd = NEWLINE | ";" ;

    ifStmt = "if" expression ":" stmtOrSuite { "elif" expression ":" stmtOrSuite }
        [ "else" ":" stmtOrSuite ] ;
    whileStmt = "while" expression ":" stmtOrSuite;
    forStmt = "for" IDENTIFIER "in" expression ":" stmtOrSuite ;

    matchStmt = "match" expression ":" NEWLINE INDENT matchBlock DEDENT;
    matchBlock = patternList ":" stmtOrSuite { patternList ":" stmtOrSuite };
    patternList = pattern { "," pattern } ;
    (* Note: you can't have a binding in a pattern list, but to not complicate the
    grammar more it won't be restricted syntactically *)
    pattern = literal | BUILTINTYPE | CONSTANT | "_" | bindingPattern
        | arrayPattern | dictPattern ;
    bindingPattern = "var" IDENTIFIER ;
    arrayPattern = "[" [ pattern { "," pattern } [ ".." ] ] "]" ;
    dictPattern = "{" [ keyValuePattern ] { "," keyValuePattern } [ ".." ] "}" ;
    keyValuePattern = STRING [ ":" pattern ] ;

    flowStmt
        = "continue" stmtEnd
        | "break" stmtEnd
        | "return" [ expression ] stmtEnd
        ;

    assignmentStmt = subscription "=" expression stmtEnd;
    varDeclStmt = "var" IDENTIFIER [ "=" expression ] stmtEnd;

    assertStmt = "assert" "(" expression [ "," STRING ] ")" stmtEnd ;
    yieldStmt = "yield" "(" [ expression "," expression ] ")" ;
    preloadStmt = "preload" "(" CONSTANT ")" ;

    (* This expression grammar encodes precedence. Items later in the list have
    higher precedence than the ones before. *)
    exprStmt = expression stmtEnd ;
    expression = cast [ "[" expression "]" ] ;
    cast = ternaryExpr [ "as" typeHint ];
    ternaryExpr = logicOr [ "if" logicOr "else" logicOr ] ;
    logicOr = logicAnd { ( "or" | "||" ) logicAnd } ;
    logicAnd = logicNot { ( "and" | "&&" ) logicNot };
    logicNot = ( "!" | "not" ) logicNot | in;
    in = comparison { "in" comparison };
    comparison = bitOr { ( "<" | ">" | "<=" | ">=" | "==" | "!=" ) bitOr } ;
    bitOr = bitXor { "|" bitXor } ;
    bitXor = bitAnd { "^" bitAnd } ;
    bitAnd = bitShift { "&" bitShift } ;
    bitShift = minus { ( "<<" | ">>" ) minus } ;
    minus = plus { "-" plus } ;
    plus = factor { "+" factor } ;
    factor = sign { ( "*" | "/" | "%" ) sign } ;
    sign = ( "-" | "+" ) sign | bitNot ;
    bitNot = "~" bitNot | is ;
    is = call [ "is" ( IDENTIFIER | BUILTINTYPE ) ] ;
    call = attribute [ "(" [ argList ] ")" ];
    attribute = subscription { "." IDENTIFIER } ;
    subscription = primary [ "[" expression "]" ] ;
    primary = "true" | "false" | "null" | "self" | literal | arrayDecl
        | dictDecl | "(" expression ")" ;

    literal = STRING | NUMBER | IDENTIFIER | BUILTINTYPE
        | "PI" | "TAU" | "NAN" | "INF" ;
    arrayDecl = "[" [ expression { "," expression } "," ] "]" ;
    dictDecl = "{" [ keyValue { "," keyValue } "," ] "}" ;
    keyValue
        = expression ":" expression
        | IDENTIFIER "=" expression
        ;


===================================================
/. ./development/file_formats/tscn.rst
===================================================

.. _doc_tscn_file_format:

TSCN file format
================

The TSCN (text scene) file format represents a single scene tree inside
Godot. Unlike binary SCN files, TSCN files have the advantage of being mostly
human-readable and easy for version control systems to manage.

The ESCN (exported scene) file format is identical to the TSCN file format, but
is used to indicate to Godot that the file has been exported from another
program and should not be edited by the user from within Godot.
Unlike SCN and TSCN files, during import, ESCN files are compiled to binary
SCN files stored inside the ``.import/`` folder.
This reduces the data size and speeds up loading, as binary formats are faster
to load compared to text-based formats.

For those looking for a complete description, the parsing is handled in the file
`resource_format_text.cpp <https://github.com/godotengine/godot/blob/master/scene/resources/resource_format_text.cpp>`_
in the ``ResourceFormatLoaderText`` class.

File structure
--------------

There are five main sections inside the TSCN file:

0. File Descriptor
1. External resources
2. Internal resources
3. Nodes
4. Connections

The file descriptor looks like ``[gd_scene load_steps=3 format=2]`` and should
be the first entry in the file. The ``load_steps`` parameter is equal to the
total amount of resources (internal and external) plus one (for the file itself).
If the file has no resources, ``load_steps`` is omitted. The engine will
still load the file correctly if ``load_steps`` is incorrect, but this will affect
loading bars and any other piece of code relying on that value.

These sections should appear in order, but it can be hard to distinguish them.
The only difference between them is the first element in the heading for all of
the items in the section. For example, the heading of all external resources
should start with ``[ext_resource .....]``.

A TSCN file may contain single-line comments starting with a semicolon (``;``).
However, comments will be discarded when saving the file using the Godot editor.

Entries inside the file
~~~~~~~~~~~~~~~~~~~~~~~

A heading looks like
``[<resource_type> key=value key=value key=value ...]``
where resource_type is one of:

- ``ext_resource``
- ``sub_resource``
- ``node``
- ``connection``

Below every heading comes zero or more ``key = value`` pairs. The
values can be complex datatypes such as Arrays, Transforms, Colors, and
so on. For example, a spatial node looks like:

::

    [node name="Cube" type="Spatial" parent="."]
    transform=Transform( 1.0, 0.0, 0.0 ,0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 )


The scene tree
--------------

The scene tree is made up of… nodes! The heading of each node consists of
its name, parent and (most of the time) a type. For example
``[node type="Camera" name="PlayerCamera" parent="Player/Head"]``

Other valid keywords include:

 - ``instance``
 - ``instance_placeholder``
 - ``owner``
 - ``index`` (sets the order of appearance in the tree. If absent, inherited nodes will take precedence over plain ones)
 - ``groups``

The first node in the file, which is also the scene root, must not have a
``parent=Path/To/Node`` entry in its heading. All scene files should have
exactly *one* scene root. If it doesn't, Godot will fail to import the file.
The parent path of other nodes should be absolute, but shouldn't contain
the scene root's name. If the node is a direct child of the scene root,
the path should be ``"."``. Here is an example scene tree
(but without any node content):

::

    [node name="Player" type="Spatial"]             ; The scene root
    [node name="Arm" parent="." type="Spatial"]     ; Parented to the scene root
    [node name="Hand" parent="Arm" type="Spatial"]
    [node name="Finger" parent="Arm/Hand" type="Spatial"]


Similar to the internal resource, the document for each node is currently
incomplete. Fortunately, it is easy to find out because you can simply
save a file with that node in it. Some example nodes are:

::

    [node type="CollisionShape" name="SphereCollision" parent="SpherePhysics"]

    shape = SubResource(8)
    transform = Transform( 1.0 , 0.0 , -0.0 , 0.0 , -4.371138828673793e-08 , 1.0 , -0.0 , -1.0 , -4.371138828673793e-08 ,0.0 ,0.0 ,-0.0  )


    [node type="MeshInstance" name="Sphere" parent="SpherePhysics"]

    mesh = SubResource(9)
    transform = Transform( 1.0 , 0.0 , -0.0 , 0.0 , 1.0 , -0.0 , -0.0 , -0.0 , 1.0 ,0.0 ,0.0 ,-0.0  )


    [node type="OmniLight" name="Lamp" parent="."]

    light_energy = 1.0
    light_specular = 1.0
    transform = Transform( -0.29086464643478394 , -0.7711008191108704 , 0.5663931369781494 , -0.05518905818462372 , 0.6045246720314026 , 0.7946722507476807 , -0.9551711678504944 , 0.199883371591568 , -0.21839118003845215 ,4.076245307922363 ,7.3235554695129395 ,-1.0054539442062378  )
    omni_range = 30
    shadow_enabled = true
    light_negative = false
    light_color = Color( 1.0, 1.0, 1.0, 1.0 )


    [node type="Camera" name="Camera" parent="."]

    projection = 0
    near = 0.10000000149011612
    fov = 50
    transform = Transform( 0.6859206557273865 , -0.32401350140571594 , 0.6515582203865051 , 0.0 , 0.8953956365585327 , 0.44527143239974976 , -0.7276763319969177 , -0.3054208755493164 , 0.6141703724861145 ,14.430776596069336 ,10.093015670776367 ,13.058500289916992  )
    far = 100.0


NodePath
~~~~~~~~

A tree structure is not enough to represent the whole scene. Godot uses a
``NodePath(Path/To/Node)`` structure to refer to another node or attribute of
the node anywhere in the scene tree. For instance, MeshInstance uses
``NodePath()`` to point to its skeleton. Likewise, Animation tracks use
``NodePath()`` to point to node properties to animate.

::

    [node name="mesh" type="MeshInstance" parent="Armature001"]

    mesh = SubResource(1)
    skeleton = NodePath("..:")


::

    [sub_resource id=3 type="Animation"]

    ...
    tracks/0/type = "transform
    tracks/0/path = NodePath("Cube:")
    ...


Skeleton
~~~~~~~~

The Skeleton node inherits the Spatial node, but also may have a list of bones
described in key-value pairs in the format ``bones/Id/Attribute=Value``. The
bone attributes consist of:

- ``name``
- ``parent``
- ``rest``
- ``pose``
- ``enabled``
- ``bound_children``

1. ``name`` must be the first attribute of each bone.
2. ``parent`` is the index of parent bone in the bone list, with parent index,
   the bone list is built to a bone tree.
3. ``rest`` is the transform matrix of bone in its "resting" position.
4. ``pose`` is the pose matrix; use ``rest`` as the basis.
5. ``bound_children`` is a list of ``NodePath()`` which point to
   BoneAttachments belonging to this bone.

Here's an example of a skeleton node with two bones:

::

    [node name="Skeleton" type="Skeleton" parent="Armature001" index="0"]

    bones/0/name = "Bone.001"
    bones/0/parent = -1
    bones/0/rest = Transform( 1, 0, 0, 0, 0, -1, 0, 1, 0, 0.038694, 0.252999, 0.0877164 )
    bones/0/pose = Transform( 1.0, 0.0, -0.0, 0.0, 1.0, -0.0, -0.0, -0.0, 1.0, 0.0, 0.0, -0.0 )
    bones/0/enabled = true
    bones/0/bound_children = [  ]
    bones/1/name = "Bone.002"
    bones/1/parent = 0
    bones/1/rest = Transform( 0.0349042, 0.99939, 0.000512929, -0.721447, 0.0248417, 0.692024, 0.691589, -0.0245245, 0.721874, 0, 5.96046e-08, -1.22688 )
    bones/1/pose = Transform( 1.0, 0.0, -0.0, 0.0, 1.0, -0.0, -0.0, -0.0, 1.0, 0.0, 0.0, -0.0 )
    bones/1/enabled = true
    bones/1/bound_children = [  ]


BoneAttachment
~~~~~~~~~~~~~~

BoneAttachment node is an intermediate node to describe some node being parented
to a single bone in a Skeleton node. The BoneAttachment has a
``bone_name=NameOfBone`` attribute, and the corresponding bone being the parent has the
BoneAttachment node in its ``bound_children`` list.

An example of one MeshInstance parented to a bone in Skeleton:

::

    [node name="Armature" type="Skeleton" parent="."]

    transform = Transform(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, -0.0219986, 0.0125825, 0.0343127)
    bones/0/name = "Bone"
    bones/0/parent = -1
    bones/0/rest = Transform(1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)
    bones/0/pose = Transform(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
    bones/0/enabled = true
    bones/0/bound_children = [NodePath("BoneAttachment:")]

    [node name="BoneAttachment" type="BoneAttachment" parent="Armature"]

    bone_name = "Bone"

    [node name="Cylinder" type="MeshInstance" parent="Armature/BoneAttachment"]

    mesh = SubResource(1)
    transform = Transform(1.0, 0.0, 0.0, 0.0, 1.86265e-09, 1.0, 0.0, -1.0, 0.0, 0.0219986, -0.0343127, 2.25595)


AnimationPlayer
~~~~~~~~~~~~~~~

AnimationPlayer works as an animation library. It stores animations listed in
the format ``anim/Name=SubResource(ResourceId)``; each line refers to an
Animation resource. All the animation resources use the root node of
AnimationPlayer. The root node is stored as
``root_node=NodePath(Path/To/Node)``.

::

    [node name="AnimationPlayer" type="AnimationPlayer" parent="." index="1"]

    root_node = NodePath("..")
    autoplay = ""
    playback_process_mode = 1
    playback_default_blend_time = 0.0
    playback_speed = 1.0
    anims/default = SubResource( 2 )
    blend_times = [  ]


Resources
---------

Resources are components that make up the nodes. For example, a MeshInstance
node will have an accompanying ArrayMesh resource. The ArrayMesh resource
may be either internal or external to the TSCN file.

References to the resources are handled by ``id`` numbers in the resource's
heading. External resources and internal resources are referred to with
``ExtResource(id)`` and ``SubResource(id)``, respectively. Because there
have different methods to refer to internal and external resources, you can have
the same ID for both an internal and external resource.

For example, to refer to the resource ``[ext_resource id=3 type="PackedScene"
path=....]``, you would use ``ExtResource(3)``.

External resources
~~~~~~~~~~~~~~~~~~

External resources are links to resources not contained within the TSCN file
itself. An external resource consists of a path, a type and an ID.

Godot always generates absolute paths relative to the resource directory and
thus prefixed with ``res://``, but paths relative to the TSCN file's location
are also valid.

Some example external resources are:

::

    [ext_resource path="res://characters/player.dae" type="PackedScene" id=1]
    [ext_resource path="metal.tres" type="Material" id=2]


Like TSCN files, a TRES file may contain single-line comments starting with a
semicolon (``;``). However, comments will be discarded when saving the resource
using the Godot editor.

Internal resources
~~~~~~~~~~~~~~~~~~

A TSCN file can contain meshes, materials and other data. These are contained in
the *internal resources* section of the file. The heading for an internal
resource looks similar to those of external resources, except that it doesn't
have a path. Internal resources also have ``key=value`` pairs under each
heading. For example, a capsule collision shape looks like:

::

    [sub_resource type="CapsuleShape" id=2]

    radius = 0.5
    height = 3.0


Some internal resources contain links to other internal resources (such as a
mesh having a material). In this case, the referring resource must appear
*before* the reference to it. This means that order matters in the file's
internal resources section.

Unfortunately, documentation on the formats for these subresources isn't
complete. Some examples can be found by inspecting saved resource files, but
others can only be found by looking through Godot's source.

ArrayMesh
~~~~~~~~~

ArrayMesh consists of several surfaces, each in the format ``surface\Index={}``.
Each surface is a set of vertices and a material.

TSCN files support two surface formats:

1. For the old format, each surface has three essential keys:

- ``primitive``
- ``arrays``
- ``morph_arrays``

    i. ``primitive`` is an enumerate variable, ``primitive=4`` which is
       ``PRIMITIVE_TRIANGLES`` is frequently used.

    ii. ``arrays`` is a two-dimensional array, it contains:

        1. Vertex positions array
        2. Normals array
        3. Tangents array
        4. Vertex colors array
        5. UV array 1
        6. UV array 2
        7. Bone indexes array
        8. Bone weights array
        9. Vertex indexes array

    iii. ``morph_arrays`` is an array of morphs. Each morph is exactly an
         ``arrays`` without the vertex indexes array.

An example of ArrayMesh:

::

    [sub_resource id=1 type="ArrayMesh"]

    surfaces/0 = {
        "primitive":4,
        "arrays":[
            Vector3Array(0.0, 1.0, -1.0, 0.866025, -1.0, -0.5, 0.0, -1.0, -1.0, 0.866025, 1.0, -0.5, 0.866025, -1.0, 0.5, 0.866025, 1.0, 0.5, -8.74228e-08, -1.0, 1.0, -8.74228e-08, 1.0, 1.0, -0.866025, -1.0, 0.5, -0.866025, 1.0, 0.5, -0.866025, -1.0, -0.5, -0.866025, 1.0, -0.5),
            Vector3Array(0.0, 0.609973, -0.792383, 0.686239, -0.609973, -0.396191, 0.0, -0.609973, -0.792383, 0.686239, 0.609973, -0.396191, 0.686239, -0.609973, 0.396191, 0.686239, 0.609973, 0.396191, 0.0, -0.609973, 0.792383, 0.0, 0.609973, 0.792383, -0.686239, -0.609973, 0.396191, -0.686239, 0.609973, 0.396191, -0.686239, -0.609973, -0.396191, -0.686239, 0.609973, -0.396191),
            null, ; No Tangents,
            null, ; no Vertex Colors,
            null, ; No UV1,
            null, ; No UV2,
            null, ; No Bones,
            null, ; No Weights,
            IntArray(0, 2, 1, 3, 1, 4, 5, 4, 6, 7, 6, 8, 0, 5, 9, 9, 8, 10, 11, 10, 2, 1, 10, 8, 0, 1, 3, 3, 4, 5, 5, 6, 7, 7, 8, 9, 5, 0, 3, 0, 9, 11, 9, 5, 7, 9, 10, 11, 11, 2, 0, 10, 1, 2, 1, 6, 4, 6, 1, 8)
        ],
        "morph_arrays":[]
    }


Animation
~~~~~~~~~

An animation resource consists of tracks. Besides, it has ``length``, ``loop``
and ``step`` applied to all the tracks.

1. ``length`` and ``step`` are both durations in seconds.

Each track is described by a list of key-value pairs in the format
``tracks/Id/Attribute``. Each track includes:

- ``type``
- ``path``
- ``interp``
- ``keys``
- ``loop_wrap``
- ``imported``
- ``enabled``

1. The ``type`` must be the first attribute of each track.
   The value of ``type`` can be:

    - ``transform``
    - ``value``
    - ``method``

2. The ``path`` has the format ``NodePath(Path/To/Node:attribute)``.
   It's the path to the animated node or attribute, relative to the root node
   defined in the AnimationPlayer.

3. The ``interp`` is the method to interpolate frames from the keyframes.
   It is an enum variable with one of the following values:

    - ``0`` (constant)
    - ``1`` (linear)
    - ``2`` (cubic)

4. The ``keys`` correspond to the keyframes. It appears as a ``PoolRealArray()``,
   but may have a different structure for tracks with different types.

    - A Transform track uses every 12 real numbers in the ``keys`` to describe
      a keyframe. The first number is the timestamp. The second number is the
      transition followed by a 3-number translation vector, followed by a
      4-number rotation quaternion (X, Y, Z, W) and finally a 3-number
      scale vector. The default transition in a Transform track is 1.0.

::

    [sub_resource type="Animation" id=2]

    length = 4.95833
    loop = false
    step = 0.1
    tracks/0/type = "transform"
    tracks/0/path = NodePath("Armature001")
    tracks/0/interp = 1
    tracks/0/loop_wrap = true
    tracks/0/imported = true
    tracks/0/enabled = true
    tracks/0/keys = PoolRealArray( 0, 1, -0.0358698, -0.829927, 0.444204, 0, 0, 0, 1, 0.815074, 0.815074, 0.815074, 4.95833, 1, -0.0358698, -0.829927, 0.444204, 0, 0, 0, 1, 0.815074, 0.815074, 0.815074 )
    tracks/1/type = "transform"
    tracks/1/path = NodePath("Armature001/Skeleton:Bone.001")
    tracks/1/interp = 1
    tracks/1/loop_wrap = true
    tracks/1/imported = true
    tracks/1/enabled = false
    tracks/1/keys = PoolRealArray( 0, 1, 0, 5.96046e-08, 0, 0, 0, 0, 1, 1, 1, 1, 4.95833, 1, 0, 5.96046e-08, 0, 0, 0, 0, 1, 1, 1, 1 )


===================================================
/. ./community/contributing/index.rst
===================================================

Contributing
============

Everyone is most welcome to contribute to Godot. Here are some ways in which you
can contribute to the project:

- Improving the engine by fixing bugs, coding new features, or refining existing ones.
- Writing or proofreading documentation. You can contribute both to this
  reference manual or the code reference.
- Translating the editor or documentation from English to other languages.
- Reporting issues or `writing detailed proposals
  <https://github.com/godotengine/godot-proposals/>`__.

Getting started
---------------

You would like to contribute but you don't know how or what to do? You can get
answers below.

.. toctree::
   :maxdepth: 1
   :name: toc-community-getting-started

   ways_to_contribute

.. _doc_community_contributing_to_the_engine:

Contributing to the engine
--------------------------

The guides below explain how to contribute to the engine's core. You will learn
about the code style, the contribution workflow, and more.

.. toctree::
   :maxdepth: 1
   :name: toc-community-contributing-to-the-engine

   best_practices_for_engine_contributors
   pr_workflow
   testing_pull_requests
   bisecting_regressions
   bug_triage_guidelines
   code_style_guidelines
   cpp_usage_guidelines

.. _doc_community_writing_documentation:

Writing documentation
---------------------

We always need help to improve the documentation, be it the class reference or
the manual. Below, you can find our content and writing guidelines and
concrete guides to make changes to the documentation.

Guidelines
~~~~~~~~~~

Here are the principles and guidelines we strive to follow to write accessible
documentation.

.. toctree::
   :maxdepth: 1
   :name: toc-community-writing-guidelines

   content_guidelines
   docs_writing_guidelines
   documentation_guidelines

Writing the manual
~~~~~~~~~~~~~~~~~~

.. toctree::
   :maxdepth: 1
   :name: toc-community-documentation

   contributing_to_the_documentation
   building_the_manual

Class reference guides
~~~~~~~~~~~~~~~~~~~~~~

The pages below focus on the class reference.

As the reference is included in the Godot editor, its source files are part of
the `godot repository <https://github.com/godotengine/godot>`_. We use XML files
to write it, so the process to contribute to the class reference differs from
writing the online manual.

.. toctree::
   :maxdepth: 1
   :name: toc-community-class-reference

   updating_the_class_reference
   class_reference_writing_guidelines

.. _doc_community_translating_the_documentation:

Translating the documentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The community is always working hard on making Godot and its documentation
available to more people. Localizing the documentation is a colossal and ongoing
effort you can be part of.

.. toctree::
   :maxdepth: 1
   :name: toc-community-localization

   editor_and_docs_localization


===================================================
/. ./community/contributing/ways_to_contribute.rst
===================================================

.. _doc_ways_to_contribute:

Ways to contribute
==================

Godot Engine is a non-profit, community-driven free and open source project.
Almost all (but our lead dev Juan, more on that below) developers are working
*pro bono* on their free time, out of personal interest and for the love of
creating a libre engine of exceptional quality.

This means that to thrive, Godot needs as many users as possible to get
involved by contributing to the engine. There are many ways to contribute to
such a big project, making it possible for everybody to bring something
positive to the engine, regardless of their skill set:

-  **Be part of the community.** The best way to contribute to Godot and help
   it become ever better is simply to use the engine and promote it by
   word-of-mouth, in the credits or splash screen of your games, blog posts, tutorials,
   videos, demos, gamedev or free software events, support on the Q&A, forums,
   Contributors Chat, Discord, etc. Participate!
   Being a user and advocate helps spread the word about our great engine,
   which has no marketing budget and can therefore only rely on its community
   to become more mainstream.

-  **Make games.** It's no secret that, to convince new users and especially the
   industry at large that Godot is a relevant market player, we need great games
   made with Godot. We know that the engine has a lot of potential, both for 2D
   and 3D games, but given its young age we still lack big releases that will
   draw attention to Godot. So keep working on your awesome projects, each new
   game increases our credibility on the gamedev market!

-  **Get involved in the engine's development.** This can be by contributing
   code via pull requests, testing the development snapshots or directly the
   git *master* branch, report bugs or suggest enhancements on the issue
   tracker, improve the official documentation (both the class reference and
   tutorials) and its translations.
   The following sections will cover each of those "direct" ways
   of contributing to the engine.

-  **Donate.** Godot is a non-profit project, but it can still benefit from
   user donations for many things. Apart from usual expenses such as hosting
   costs or promotional material on events, we also use donation money to
   acquire hardware when necessary (e.g. we used donation money to buy a
   MacBook Pro to implement Retina/HiDPI support and various other
   macOS-related features).
   Most importantly, we also used donation money to hire core developers so they
   can work full-time on the engine. Even with a low
   monthly wage, we need a steady donation income to continue doing this, which
   has been very beneficial to the project so far. So if you want to donate
   some money to the project, check `our website <https://godotengine.org/donate>`_
   for details.

Contributing code
-----------------

The possibility to study, use, modify and redistribute modifications of the
engine's source code are the fundamental rights that
Godot's `MIT <https://tldrlegal.com/license/mit-license>`_ license grants you,
making it `free and open source software <https://en.wikipedia.org/wiki/Free_and_open-source_software>`_.

As such, everyone is entitled to modify
`Godot's source code <https://github.com/godotengine/godot>`_, and send those
modifications back to the upstream project in the form of a patch (a text file
describing the changes in a ready-to-apply manner) or - in the modern workflow
that we use - via a so-called "pull request" (PR), i.e. a proposal to directly
merge one or more Git commits (patches) into the main development branch.

Contributing code changes upstream has two big advantages:

-  Your own code will be reviewed and improved by other developers, and will be
   further maintained directly in the upstream project, so you won't have to
   reapply your own changes every time you move to a newer version. On the
   other hand it comes with a responsibility, as your changes have to be
   generic enough to be beneficial to all users, and not just your project; so
   in some cases it might still be relevant to keep your changes only for your
   own project, if they are too specific.

-  The whole community will benefit from your work, and other contributors will
   behave the same way, contributing code that will be beneficial to you. At
   the time of this writing, more than 1000 developers have contributed code
   changes to the engine!

To ensure good collaboration and overall quality, the Godot developers
enforce some rules for code contributions, for example regarding the style to
use in the C++ code (indentation, brackets, etc.) or the Git and PR workflow.

A good place to start is by searching for issues tagged as
`good first issue <https://github.com/godotengine/godot/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22>`_
on GitHub.

.. seealso:: Technical details about the PR workflow are outlined in a
             specific section, :ref:`doc_pr_workflow`.

             Details about the code style guidelines and the ``clang-format``
             tool used to enforce them are outlined in
             :ref:`doc_code_style_guidelines`.

All pull requests must go through a review process before being accepted.
Depending on the scope of the changes, it may take some time for a maintainer
responsible for the modified part of the engine to provide their review.
We value all of our contributors and ask them to be patient in the meantime,
as it is expected that in an open source project like Godot, there is going to be
way more contributions than people validating them.

To make sure that your time and efforts aren't wasted, it is recommended to vet the idea
first before implementing it and putting it for a review as a PR. To that end, Godot
has a `proposal system <https://github.com/godotengine/godot-proposals>`_. Its
usage is encouraged to plan changes and discuss them with the community. Implementation
details can also be discussed with other contributors on the `Godot Contributors Chat <https://chat.godotengine.org/>`_.

.. note:: Proposals are only required when working on an enhancement or a new feature.
          Bug reports are sufficient for fixing issues.

Testing and reporting issues
----------------------------

Another great way of contributing to the engine is to test development releases
or the development branch and to report issues. It is also helpful to report
issues discovered in stable releases, so that they can be fixed in
the development branch and in future maintenance releases.

Testing development versions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To help with the testing, you have several possibilities:

-  Compile the engine from source yourself, following the instructions of the
   :ref:`Compiling <toc-devel-compiling>` page for your platform.

-  Test official pre-release binaries when they are announced (usually on the
   blog and other community platforms), such as alpha, beta and release candidate (RC) builds.

-  Test "trusted" unofficial builds of the development branch; just ask
   community members for reliable providers. Whenever possible, it's best to
   use official binaries or to compile yourself though, to be sure about the
   provenance of your binaries.

As mentioned previously, it is also helpful to keep your eyes peeled for
potential bugs that might still be present in the stable releases, especially
when using some niche features of the engine which might get less testing by
the developers.

Filing an issue on GitHub
~~~~~~~~~~~~~~~~~~~~~~~~~

Godot uses `GitHub's issue tracker <https://github.com/godotengine/godot/issues>`_
for bug reports and enhancement suggestions. You will need a GitHub account to
be able to open a new issue there, and click on the **New issue** button.

When you report a bug, you should keep in mind that the process is similar
to an appointment with your doctor. You noticed *symptoms* that make you think
that something might be wrong (the engine crashes, some features don't work as
expected, etc.). It's the role of the bug triaging team and the developers to
then help make the diagnosis of the issue you met, so that the actual cause of
the bug can be identified and addressed.

You should therefore always ask yourself: what is relevant information to
give so that other Godot contributors can understand the bug, identify it and
hopefully fix it. Here are some of the most important infos that you should
always provide:

-  **Operating system.** Sometimes bugs are system-specific, i.e. they happen
   only on Windows, or only on Linux, etc. That's particularly relevant for all
   bugs related to OS interfaces, such as file management, input, window
   management, audio, etc.

-  **Hardware.** Sometimes bugs are hardware-specific, i.e. they happen
   only on certain processors, graphic cards, etc. If you are able to,
   it can be helpful to include information on your hardware.

-  **Godot version.** This is a must-have. Some issues might be relevant in the
   current stable release, but fixed in the development branch, or the other
   way around. You might also be using an obsolete version of Godot and
   experiencing a known issue fixed in a later version, so knowing this from
   the start helps to speed up the diagnosis.

-  **How to reproduce the bug.** In the majority of cases, bugs are
   reproducible, i.e. it is possible to trigger them reliably by following some
   steps. Please always describe those steps as clearly as possible, so that
   everyone can try to reproduce the issue and confirm it. Ideally, make a demo
   project that reproduces this issue out of the box, zip it and attach it to
   the issue (you can do this by drag and drop).
   Even if you think that the issue is trivial to reproduce, adding a minimal
   project that lets everyone reproduce it is a big added value. You have to keep in
   mind that there are thousands of issues in the tracker, and developers can
   only dedicate little time to each issue.

When you click the **New issue** button, you should be presented with a text area
prefilled with our issue template. Please try to follow it so that all issues
are consistent and provide the required information.

Contributing to the documentation
---------------------------------

There are two separate resources referred to as "documentation" in Godot:

- **The class reference.** This is the documentation for the complete Godot API
  as exposed to GDScript and the other scripting languages. It can be consulted
  offline, directly in Godot's code editor, or online at :ref:`Godot API
  <doc_class_reference>`. To contribute to the class reference, you have to edit the
  XML file corresponding to the class and make a pull request.
  See :ref:`doc_updating_the_class_reference` and
  :ref:`doc_class_reference_writing_guidelines` for more details.

- **The tutorials and engine documentation and its translations.**
  This is the part you are reading now, which is distributed in the HTML format.
  Its contents are generated from plain text files in the reStructured Text
  (rst) format, to which you can contribute via pull requests on the
  `godot-docs <https://github.com/godotengine/godot-docs>`_ GitHub repository.
  See :ref:`doc_contributing_to_the_documentation` for more details.

Contributing translations
-------------------------

To make Godot accessible to everyone, including users who may prefer resources
in their native language instead of English, our community helps translate both
the Godot editor and its documentation in many languages.

See :ref:`doc_editor_and_docs_localization` for more details.


===================================================
/. ./community/contributing/best_practices_for_engine_contributors.rst
===================================================

.. _doc_best_practices_for_engine_contributors:

Best practices for engine contributors
======================================

Introduction
------------

Godot has a large amount of users who have the ability to contribute, given the
project itself is aimed mainly at users with the ability to do programming.
Despite this, not all of them have the same level of experience working in large
projects or in software engineering, which can lead to common misunderstandings
and bad practices during the process of contributing code to the project.

Language
--------

The scope of this document is to be a list of best practices for contributors to
follow, as well as to create a language they can use to refer to common
situations that arise in the process of submitting their contributions.

While some may find it useful to extend this to general software development,
our intention is to just restrict to situations that are most common in our
project.

Contributions are most of the time categorized as bug fixes, enhancements or new
features. To abstract this idea, we will call them *Solutions*, because they
always seek to solve something that can be described as a *Problem*.

Best Practices
--------------

#1: The problem always comes first
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many contributors are extremely creative and just enjoy the process of designing
abstract data structures, creating nice user interfaces, or simply love
programming. Whatever the case may be, they come up with cool ideas, which may
or may not be solving any real problems.

.. image:: img/best_practices1.png

These are usually called *Solutions in search of a problem*. In an ideal world,
they would not be harmful but, in reality, code takes time to write, takes space
as source and binary and requires maintenance once it exists. Avoiding the
addition of anything unnecessary is always considered a good practice in
software development.

#2: To solve the problem, it has to exist in the first place
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a variation of the previous practice. Adding anything unnecessary is not
a good idea, but what constitutes what is necessary and what isn't?

.. image:: img/best_practices2.png

The answer to this question is that the problem needs to *exist* before it can
be actually solved. It must not be speculation or a belief. The user must be
using the software as intended to create something they *need*. In this process,
the user may stumble into a problem that requires a solution to proceed, or in
order to achieve greater productivity. In this case, *a solution is needed*.

Believing that problems may arise in the future and that the software needs to
be ready to solve them by the time they appear is called *"Future proofing"* and
its characterized by lines of thought such as:

- I think it would be useful for users to...
- I think users will eventually need to...

This is generally considered a bad habit because trying to solve problems that
*don't actually exist* in the present will often lead to code that will be
written but never used, or that is considerably more complex to use and maintain
than it needs to be.

#3: The problem has to be complex or frequent
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Software is designed to solve problems, but we can't expect it to solve *every
problem that exists under the sun*. As a game engine, Godot will solve problems
for you, so it helps you to make games better and faster, but it won't make the
*entire game* for you. A line must be drawn somewhere.

.. image:: img/best_practices3.png

Whether a problem is worth solving is determined by the difficulty the user has
to work around it. This difficulty can be expressed as:

- The complexity of the problem
- The frequency the problem

If the problem is *too complex* for most users to solve, the software must offer
a ready-made solution for it. Likewise, if the problem is easy for the user to
work around, offering such a solution is unnecessary and it's up to the user to
do it.

The exception, however, is when the user stumbles into this problem *frequently
enough* that having to do the simple solution every time becomes an annoyance.
In this case, the software must offer a solution to simplify this use case.

In our experience, in most cases it's usually obvious to tell when a problem is
complex or frequent, but cases may arise where drawing this line is difficult.
This is why discussing with other developers (next point) is always advised.

#4: The solution must be discussed with others
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is often the case that when users stumble upon problems, they are only
immersed in their project, so they will naturally try to solve the problem
from their perspective, thinking only about their use case.

Because of this, user proposed solutions don't always contemplate other use
cases that developers are often aware of, so they are often biased towards their
own requirements.

.. image:: img/best_practices4.png

For developers, the perspective is different. They may find the user's problem
too unique to justify a solution (instead of a user workaround), or maybe they
will suggest a partial (usually simpler or lower level) solution that applies to
a wider range of known problems, and leave the rest of the solution up to the
user.

In any case, before attempting a contribution, it is important to discuss the
actual problems with the other developers or contributors, so a better agreement
on implementation can be reached.

The only exception, in this case, is when an area of code has a clear owner
(agreed by the other contributors), who talks to users directly and has the most
knowledge to implement a solution directly.

Also, Godot's philosophy is to favor ease of use and maintenance over absolute
performance. Performance optimizations will be considered, but they may not
be accepted if they make something too difficult to use or if they add too much
complexity to the codebase.

#5: To each problem, its own solution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For programmers, it is always a most enjoyable challenge to find the most
optimal solutions to problems. Things, however, may go overboard sometimes and
programmers will try to come up with solutions that solve as many problems as
possible.

The situation will often take a turn for the worse when, in order to make this
solution appear even more fantastic and flexible, the pure speculation-based
problems (as described in #2) also make their appearance on stage.

.. image:: img/best_practices5.png

The main problem is that, in reality, it rarely works this way. Most of the
time, writing an individual solution to each problem results in code that
is simpler and more maintainable.

Additionally, solutions that target individual problems are better for the
users, as they find something that does exactly what they need, without having
to learn and remember a more complex system they will only need for simple
tasks.

Big and flexible solutions also have an additional drawback which is that, over
time, they are rarely flexible enough for all users, who keep requesting more
functions added (and making the API and codebase more and more complex).

#6: Cater to common use cases, leave the door open for the rare ones
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a continuation of the previous point, which further explains why this
way of thinking and designing software is preferred.

As mentioned before (in point #2), it is very difficult for us (as human beings
who design software) to actually understand all future user needs. Trying to
write very flexible structures that cater to many use cases at once is often a
mistake.

We may come up with something we believe is brilliant, but when it's actually
used, we will find that users will never even use half of it, or that they will
require features that don't quite accommodate our original design, forcing us to
either throw it away or make it even more complex.

The question is then, how to design software that gives users what *we know they
need*, but that is flexible enough to allow them to do *what we don't know they
might need* in the future?

.. image:: img/best_practices6.png

The answer to this question is that, to ensure users still can do what they want
to do, we need to give them access to a *low level API* that they can use to
achieve what they want, even if it's more work for them because it means
reimplementing some logic that already exists.

In real-life scenarios, these use cases will be at most rare and uncommon
anyway, so it makes sense a custom solution needs to be written. This is why
it's important to still provide users the basic building blocks to do it.

#7: Prefer local solutions
~~~~~~~~~~~~~~~~~~~~~~~~~~

When looking for a solution to a problem, be it implementing a new feature or
fixing a bug, sometimes the easiest path is to add data or a new function in the
core layers of code.

The main problem here is, adding something to the core layers that will only be
used from a single location far away will not only make the code more difficult
to follow (split in two), but also make the core API larger, more complex, more
difficult to understand in general.

This is bad, because readability and cleanness of core APIs is always of extreme
importance given how much code relies on it, and because it's key for new
contributors as a starting point to learning the codebase.


.. image:: img/best_practices7.png


The common reasoning for wanting to do this is that it's usually less code to
simply add a hack in the core layers.

Despite this, this practice is not advised. Generally, the code for a solution
should be closer to where the problem originates, even if it involves more code,
duplicated, more complex or is less efficient. More creativity might be needed,
but this path is always the advised one.

#8: Don't use complex canned solutions for simple problems
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Not every problem has a simple solution and, many times, the right choice is to
use a third party library to solve the problem.

As Godot requires to be shipped in a large amount of platforms, we can't
link libraries dynamically. Instead, we bundle them in our source tree.

.. image:: img/best_practices8.png

As a result, we are very picky with what goes in, and we tend to prefer smaller
libraries (in fact, single header ones are our favorite). Only in cases where
there is no other choice we end up bundling something larger.

Also, libraries must use a permissive enough license to be included into Godot.
Some examples of acceptable licenses are Apache 2.0, BSD, MIT, ISC, and MPL 2.0.
In particular, we cannot accept libraries licensed under the GPL or LGPL since
these licenses effectively disallow static linking in proprietary software
(which Godot is distributed as in most exported projects). This requirement also
applies to the editor, since we may want to run it on iOS in the long term.
Since iOS doesn't support dynamic linking, static linking the only option on
that platform.


===================================================
/. ./community/contributing/pr_workflow.rst
===================================================

.. _doc_pr_workflow:

Pull request workflow
=====================

.. highlight:: shell

The so-called "PR workflow" used by Godot is common to many projects using
Git, and should be familiar to veteran free software contributors. The idea
is that only a small number (if any) commit directly to the *master* branch.
Instead, contributors *fork* the project (i.e. create a copy of it, which
they can modify as they wish), and then use the GitHub interface to request
a *pull* from one of their fork's branches to one branch of the original
(often named *upstream*) repository.

The resulting *pull request* (PR) can then be reviewed by other contributors,
which might approve it, reject it, or most often request that modifications
be done. Once approved, the PR can then be merged by one of the core
developers, and its commit(s) will become part of the target branch (usually
the *master* branch).

We will go together through an example to show the typical workflow and
associated Git commands. But first, let's have a quick look at the
organization of Godot's Git repository.

Git source repository
---------------------

The `repository on GitHub <https://github.com/godotengine/godot>`_ is a
`Git <https://git-scm.com>`_ code repository together with an embedded
issue tracker and PR system.

.. note:: If you are contributing to the documentation, its repository can
          be found `here <https://github.com/godotengine/godot-docs>`_.

The Git version control system is the tool used to keep track of successive
edits to the source code - to contribute efficiently to Godot, learning the
basics of the Git command line is *highly* recommended. There exist some
graphical interfaces for Git, but they usually encourage users to take bad
habits regarding the Git and PR workflow, and we therefore recommend not to
use them. In particular, we advise not to use GitHub's online editor for code
contributions (although it's tolerated for small fixes or documentation changes)
as it enforces one commit per file and per modification,
which quickly leads to PRs with an unreadable Git history (especially after peer review).

.. seealso:: The first sections of Git's "Book" are a good introduction to
             the tool's philosophy and the various commands you need to
             master in your daily workflow. You can read them online on the
             `Git SCM <https://git-scm.com/book/en/v2>`_ website.
             You can also try out `GitHub's interactive guide <https://try.github.io/>`__.

The branches on the Git repository are organized as follows:

-  The ``master`` branch is where the development of the next major version
   occurs. As a development branch, it can be unstable
   and is not meant for use in production. This is where PRs should be done
   in priority.
-  The stable branches are named after their version, e.g. ``3.1`` and ``2.1``.
   They are used to backport bugfixes and enhancements from the ``master``
   branch to the currently maintained stable release (e.g. 3.1.2 or 2.1.6).
   As a rule of thumb, the last stable branch is maintained until the next
   minor version (e.g. the ``3.0`` branch was maintained until the release of
   Godot 3.1).
   If you want to make PRs against a maintained stable branch, please check
   first if your changes are also relevant for the ``master`` branch, and if so
   make the PR for the ``master`` branch in priority. Release managers can then
   cherry-pick the fix to a stable branch if relevant.
-  There might occasionally be feature branches, usually meant to be merged into
   the ``master`` branch at some time.

Forking and cloning
-------------------

The first step is to *fork* the `godotengine/godot <https://github.com/godotengine/godot>`_
repository on GitHub. To do so, you will need to have a GitHub account and to
be logged in. In the top right corner of the repository's GitHub page, you
should see the "Fork" button as shown below:

.. image:: img/github_fork_button.png

Click it, and after a while you should be redirected to your own fork of the
Godot repo, with your GitHub username as namespace:

.. image:: img/github_fork_url.png

You can then *clone* your fork, i.e. create a local copy of the online
repository (in Git speak, the *origin remote*). If you haven't already,
download Git from `its website <https://git-scm.com>`_ if you're using Windows or
macOS, or install it through your package manager if you're using Linux.

.. note:: If you are on Windows, open Git Bash to type commands. macOS and Linux users
          can use their respective terminals.

To clone your fork from GitHub, use the following command:

::

    $ git clone https://github.com/USERNAME/godot

.. note:: In our examples, the "$" character denotes the command line prompt
          on typical UNIX shells. It is not part of the command and should
          not be typed.

After a little while, you should have a ``godot`` directory in your current
working directory. Move into it using the ``cd`` command:

::

    $ cd godot

We will start by setting up a reference to the original repository that we forked:

::

    $ git remote add upstream https://github.com/godotengine/godot
    $ git fetch upstream

This will create a reference named ``upstream`` pointing to the original
``godotengine/godot`` repository. This will be useful when you want to pull new
commits from its ``master`` branch to update your fork. You have another
remote reference named ``origin``, which points to your fork (``USERNAME/godot``).

You only need to do the above steps once, as long as you keep that local
``godot`` folder (which you can move around if you want, the relevant
metadata is hidden in its ``.git`` subfolder).

.. note:: *Branch it, pull it, code it, stage it, commit, push it, rebase
          it... technologic.*

          This bad take on Daft Punk's *Technologic* shows the general
          conception Git beginners have of its workflow: lots of strange
          commands to learn by copy and paste, hoping they will work as
          expected. And that's actually not a bad way to learn, as long as
          you're curious and don't hesitate to question your search engine
          when lost, so we will give you the basic commands to know when
          working in Git.

In the following, we will assume as an example that you want to implement a feature in
Godot's project manager, which is coded in the ``editor/project_manager.cpp``
file.

Branching
---------

By default, the ``git clone`` should have put you on the ``master`` branch of
your fork (``origin``). To start your own feature development, we will create
a feature branch:

::

    # Create the branch based on the current branch (master)
    $ git branch better-project-manager

    # Change the current branch to the new one
    $ git checkout better-project-manager

This command is equivalent:

::

    # Change the current branch to a new named one, based on the current branch
    $ git checkout -b better-project-manager

If you want to go back to the ``master`` branch, you'd use:

::

    $ git checkout master

You can see which branch you are currently on with the ``git branch``
command:

::

    $ git branch
      2.1
    * better-project-manager
      master

Be sure to always go back to the ``master`` branch before creating a new branch,
as your current branch will be used as the base for the new one. Alternatively,
you can specify a custom base branch after the new branch's name:

::

    $ git checkout -b my-new-feature master

Updating your branch
--------------------

This would not be needed the first time (just after you forked the upstream
repository). However, the next time you want to work on something, you will
notice that your fork's ``master`` is several commits behind the upstream
``master`` branch: pull requests from other contributors would have been merged
in the meantime.

To ensure there won't be conflicts between the feature you develop and the
current upstream ``master`` branch, you will have to update your branch by
*pulling* the upstream branch.

::

    $ git pull --rebase upstream master

The ``--rebase`` argument will ensure that any local changes that you committed
will be re-applied *on top* of the pulled branch, which is usually what we want
in our PR workflow. This way, when you open a pull request, your own commits will
be the only difference with the upstream ``master`` branch.

While rebasing, conflicts may arise if your commits modified code that has been
changed in the upstream branch in the meantime. If that happens, Git will stop at
the conflicting commit and will ask you to resolve the conflicts. You can do so
with any text editor, then stage the changes (more on that later), and proceed with
``git rebase --continue``. Repeat the operation if later commits have conflicts too,
until the rebase operation completes.

If you're unsure about what is going on during a rebase and you panic (no worry,
we all do the first few times), you can abort the rebase with ``git rebase --abort``.
You will then be back to the original state of your branch before calling
``git pull --rebase``.

.. note:: If you omit the ``--rebase`` argument, you will instead create a merge
          commit which tells Git what to make of the two distinct branches. If any
          conflicts arise, they would be resolved all at once via this merge commit.

          While this is a valid workflow and the default behavior of ``git pull``,
          merge commits within PRs are frowned upon in our PR workflow. We only use
          them when merging PRs into the upstream branch.

          The philosophy is that a PR should represent the final stage of the changes
          made to the codebase, and we are not interested in mistakes and fixes that
          would have been done in intermediate stages before merging.
          Git gives us great tools to "rewrite the history" and make it as if we got
          things right the first time, and we're happy to use it to ensure that
          changes are easy to review and understand long after they have been merged.

If you have already created a merge commit without using ``rebase``, or
have made any other changes that have resulted in undesired history, the best option
is to use an *interactive rebase* on the upstream branch. See the :ref:`dedicated
section <doc_pr_workflow_rebase>` for instructions.

.. tip:: If at any time you want to *reset* a local branch to a given commit or branch,
         you can do so with ``git reset --hard <commit ID>`` or
         ``git reset --hard <remote>/<branch>`` (e.g. ``git reset --hard upstream/master``).

         Be warned that this will remove any changes that you might have committed in
         this branch. If you ever lose commits by mistake, use the ``git reflog`` command
         to find the commit ID of the previous state that you would like to restore, and
         use it as argument of ``git reset --hard`` to go back to that state.

Making changes
--------------

You would then do your changes to our example's
``editor/project_manager.cpp`` file with your usual development environment
(text editor, IDE, etc.).

By default, those changes are *unstaged*. The staging area is a layer between
your working directory (where you make your modifications) and the local Git
repository (the commits and all the metadata in the ``.git`` folder). To
bring changes from the working directory to the Git repository, you need to
*stage* them with the ``git add`` command, and then to commit them with the
``git commit`` command.

There are various commands you should know to review your current work,
before staging it, while it is staged, and after it has been committed.

- ``git diff`` will show you the current unstaged changes, i.e. the
  differences between your working directory and the staging area.
- ``git checkout -- <files>`` will undo the unstaged changes to the given
  files.
- ``git add <files>`` will *stage* the changes on the listed files.
- ``git diff --staged`` will show the current staged changes, i.e. the
  differences between the staging area and the last commit.
- ``git reset HEAD <files>`` will *unstage* changes to the listed files.
- ``git status`` will show you what are the currently staged and unstaged
  modifications.
- ``git commit`` will commit the staged files. It will open a text editor
  (you can define the one you want to use with the ``GIT_EDITOR`` environment
  variable or the ``core.editor`` setting in your Git configuration) to let you
  write a commit log. You can use ``git commit -m "Cool commit log"`` to
  write the log directly.
- ``git commit --amend`` lets you amend the last commit with your currently
  staged changes (added with ``git add``). This is the best option if you
  want to fix a mistake in the last commit (bug, typo, style issue, etc.).
- ``git log`` will show you the last commits of your current branch. If you
  did local commits, they should be shown at the top.
- ``git show`` will show you the changes of the last commit. You can also
  specify a commit hash to see the changes for that commit.

That's a lot to memorize! Don't worry, just check this cheat sheet when you
need to make changes, and learn by doing.

Here's how the shell history could look like on our example:

::

    # It's nice to know where you're starting from
    $ git log

    # Do changes to the project manager with the nano text editor
    $ nano editor/project_manager.cpp

    # Find an unrelated bug in Control and fix it
    $ nano scene/gui/control.cpp

    # Review changes
    $ git status
    $ git diff

    # We'll do two commits for our unrelated changes,
    # starting by the Control changes necessary for the PM enhancements
    $ git add scene/gui/control.cpp
    $ git commit -m "Fix handling of margins in Control"

    # Check we did good
    $ git log
    $ git show
    $ git status

    # Make our second commit
    $ git add editor/project_manager.cpp
    $ git commit -m "Add a pretty banner to the project manager"
    $ git log

With this, we should have two new commits in our ``better-project-manager``
branch which were not in the ``master`` branch. They are still only local
though, the remote fork does not know about them, nor does the upstream repo.

Pushing changes to a remote
---------------------------

That's where ``git push`` will come into play. In Git, a commit is always
done in the local repository (unlike Subversion where a commit will modify
the remote repository directly). You need to *push* the new commits to a
remote branch to share them with the world. The syntax for this is:

::

    $ git push <remote> <local branch>[:<remote branch>]

The part about the remote branch can be omitted if you want it to have the
same name as the local branch, which is our case in this example, so we will
do:

::

    $ git push origin better-project-manager

Git will ask you for your username and password, and the changes will be sent
to your remote. If you check the fork's page on GitHub, you should see a new
branch with your added commits.

Issuing a pull request
----------------------

When you load your fork's branch on GitHub, you should see a line saying
*"This branch is 2 commits ahead of godotengine:master."* (and potentially some
commits behind, if your ``master`` branch was out of sync with the upstream
``master`` branch).

.. image:: img/github_fork_make_pr.png

On that line, there is a "Pull request" link. Clicking it will open a form
that will let you issue a pull request on the ``godotengine/godot`` upstream
repository. It should show you your two commits, and state "Able to merge".
If not (e.g. it has way more commits, or says there are merge conflicts),
don't create the PR yet, something went wrong. Go to our
`Godot Contributors Chat <https://chat.godotengine.org/>`_ and ask for support :)

Use an explicit title for the PR and put the necessary details in the comment
area. You can drag and drop screenshots, GIFs or zipped projects if relevant,
to showcase what your work implements. Click "Create a pull request", and
tadaa!

Modifying a pull request
------------------------

While it is reviewed by other contributors, you will often need to make
changes to your yet-unmerged PR, either because contributors requested them,
or because you found issues yourself while testing.

The good news is that you can modify a pull request simply by acting on the
branch you made the pull request from. You can e.g. make a new commit on that
branch, push it to your fork, and the PR will be updated automatically:

::

    # Check out your branch again if you had changed in the meantime
    $ git checkout better-project-manager

    # Fix a mistake
    $ nano editor/project_manager.cpp
    $ git add editor/project_manager.cpp
    $ git commit -m "Fix a typo in the banner's title"
    $ git push origin better-project-manager

However, be aware that in our PR workflow, we favor commits that bring the
codebase from one functional state to another functional state, without having
intermediate commits fixing up bugs in your own code or style issues. Most of
the time, we will prefer a single commit in a given PR (unless there's a good
reason to keep the changes separate). Instead of authoring a new commit,
consider using ``git commit --amend`` to amend the previous commit with your
fixes. The above example would then become:

::

    # Check out your branch again if you had changed in the meantime
    $ git checkout better-project-manager

    # Fix a mistake
    $ nano editor/project_manager.cpp
    $ git add editor/project_manager.cpp
    # --amend will change the previous commit, so you will have the opportunity
    # to edit its commit message if relevant.
    $ git commit --amend
    # As we modified the last commit, it no longer matches the one from your
    # remote branch, so we need to force push to overwrite that branch.
    $ git push --force origin better-project-manager

.. Kept for compatibility with the previous title, linked in many PRs.

.. _mastering-the-pr-workflow-the-rebase:

.. _doc_pr_workflow_rebase:

The interactive rebase
----------------------

If you didn't follow the above steps closely to *amend* changes into a commit
instead of creating fixup commits, or if you authored your changes without being
aware of our workflow and Git usage tips, reviewers might request of your to
*rebase* your branch to *squash* some or all of the commits into one.

Indeed, if some commits have been made following reviews to fix bugs, typos, etc.
in the original commit, they are not relevant to a future changelog reader who
would want to know what happened in the Godot codebase, or when and how a given
file was last modified.

To squash those extraneous commits into the main one, we will have to *rewrite
history*. Right, we have that power. You may read that it's a bad practice, and
it's true when it comes to branches of the upstream repo. But in your fork, you
can do whatever you want, and everything is allowed to get neat PRs :)

We will use the *interactive rebase* ``git rebase -i`` to do this. This
command takes a commit ID or a branch name as argument, and will let you modify
all commits between that commit/branch and the last one in your working branch,
the so-called ``HEAD``.

While you can give any commit ID to ``git rebase -i`` and review everything in
between, the most common and convenient workflow involves rebasing on the
upstream ``master`` branch, which you can do with:

::

    $ git rebase -i upstream/master

.. note:: Referencing branches in Git is a bit tricky due to the distinction
          between remote and local branches. Here, ``upstream/master`` (with a
          `/`) is a local branch which has been pulled from the ``upstream``
          remote's ``master`` branch.

          Interactive rebases can only be done on local branches, so the `/`
          is important here. As the upstream remote changes frequently, your
          local ``upstream/master`` branch may become outdated, so you can
          update it with ``git fetch upstream master``. Contrarily to
          ``git pull --rebase upstream master`` which would update your
          currently checked out branch, ``fetch`` will only update the
          ``upstream/master`` reference (which is distinct from your local
          ``master`` branch... yes it's confusing, but you'll become familiar
          with this little by little).

This will open a text editor (``vi`` by default, see
`Git docs <https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_core_editor>`_
to configure your favorite one) with something which may look like this:

.. code-block:: text

    pick 1b4aad7 Add a pretty banner to the project manager
    pick e07077e Fix a typo in the banner's title

The editor will also show instructions regarding how you can act on those
commits. In particular, it should tell you that "pick" means to use that
commit (do nothing), and that "squash" and "fixup" can be used to *meld* the
commit in its parent commit. The difference between "squash" and "fixup" is
that "fixup" will discard the commit log from the squashed commit. In our
example, we are not interested in keeping the log of the "Fix a typo" commit,
so we use:

.. code-block:: text

    pick 1b4aad7 Add a pretty banner to the project manager
    fixup e07077e Fix a typo in the banner's title

Upon saving and quitting the editor, the rebase will occur. The second commit
will be melded into the first one, and ``git log`` and ``git show`` should
now confirm that you have only one commit with the changes from both previous
commits.

But! You rewrote the history, and now your local and remote branches have
diverged. Indeed, commit 1b4aad7 in the above example will have changed, and
therefore got a new commit hash. If you try to push to your remote branch, it
will raise an error:

::

    $ git push origin better-project-manager
    To https://github.com/akien-mga/godot
     ! [rejected]        better-project-manager -> better-project-manager (non-fast-forward)
    error: failed to push some refs to 'https://akien-mga@github.com/akien-mga/godot'
    hint: Updates were rejected because the tip of your current branch is behind
    hint: its remote counterpart.

This is a sane behavior, Git will not let you push changes that would
override remote content. But that's actually what we want to do here, so we
will have to *force* it:

::

    $ git push --force origin better-project-manager

And tadaa! Git will happily *replace* your remote branch with what you had
locally (so make sure that's what you wanted, using ``git log``). This will
also update the PR accordingly.

Deleting a Git branch
---------------------

After your pull request gets merged, there's one last thing you should do: delete your
Git branch for the PR. There won't be issues if you don't delete your branch, but it's
good practice to do so. You'll need to do this twice, once for the local branch and another
for the remote branch on GitHub.

To delete our better project manager branch locally, use this command:

::

    $ git branch -d better-project-manager

Alternatively, if the branch hadn't been merged yet and we wanted to delete it anyway, instead
of ``-d`` you would use ``-D``.

Next, to delete the remote branch on GitHub use this command:

::

    $ git push origin -d better-project-manager

You can also delete the remote branch from the GitHub PR itself, a button should appear once
it has been merged or closed.


===================================================
/. ./community/contributing/testing_pull_requests.rst
===================================================

.. _doc_testing_pull_requests:

Testing pull requests
=====================

Many people are developing new features or fixing bugs on GitHub.
To help with engine development, you may be asked to test those pull requests
with a Godot build that includes code from the pull request in question.

Thanks to GitHub Actions, all `pull requests <https://github.com/godotengine/godot/pulls>`__
have continuous builds available. These builds let you try out pull requests
without having to compile anything from source.

Downloading a compiled build
----------------------------

You can download pull request builds from GitHub Actions. Since only signed in
users may download builds directly from GitHub Actions, the procedure varies
depending on whether you have a GitHub account or not.

.. note::

    Due to a GitHub Actions limitation, builds are only available for 90 days
    after the pull request was last updated. If you still wish to try a
    pull request locally, you can
    :ref:`compile the pull request branch from source <doc_testing_pull_requests_compile>`
    instead.

If you have a GitHub account
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Open the pull request page. Click the **Checks** tab near the top of the page:

.. image:: img/testing_pull_requests_access_checks.png

- In the list of platforms that appears on the left, select your platform by clicking
  it then choose the type of build you need (editor or export template).
  If in doubt, select an editor build:

.. image:: img/testing_pull_requests_checks_platforms.png

- Click the **Artifacts** dropdown on the right of the page then click the artifact's
  name to download it:

.. image:: img/testing_pull_requests_checks_artifacts.png

- Extract the ZIP archive then run the executable.
  Note that Windows and macOS binaries are not code signed.
  This means you may have to bypass a security warning before you can run the executable.
  If you frequently test pull request builds, it may be better to disable
  Windows SmartScreen or `disable macOS Gatekeeper <https://disable-gatekeeper.github.io/>`__ permanently.

If you don't have a GitHub account
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you don't have a GitHub account and can't sign up for one,
you can use the third-party `nightly.link <https://nightly.link>`__ service
to generate a universal download link.

- Open the pull request page. Click the *fork*'s branch name near the top of the page:

.. image:: img/testing_pull_requests_access_fork.png

- Now that you are on the fork's branch page, click the ``.github`` folder at the top of the file list.
  Then, click on the ``workflows`` folder (whicb is inside the ``.github`` folder).
  Click the workflow file for the platform you wish to download artifacts for.
  *After* clicking on the file (which opens the file view), copy the page URL from your browser's address bar.

- Open the `nightly.link <https://nightly.link>`__ website and paste the URL you just copied
  into the text field located below the heading **Paste a GitHub link, get a nightly.link!**.
  After pasting the URL, click **Get links** on the right.
  If the the format of the URL you pasted is correct, you should be presented
  with a page like this:

.. image:: img/testing_pull_requests_nightly_link.png

- Click the URL of the artifact you wish to download.

- Extract the ZIP archive then run the executable.
  Note that Windows and macOS binaries are not code signed.
  This means you may have to bypass a security warning before you can run the executable.
  If you frequently test pull request builds, it may be better to disable
  Windows SmartScreen or `disable macOS Gatekeeper <https://disable-gatekeeper.github.io/>`__ permanently.

.. _doc_testing_pull_requests_compile:

Compiling a pull request branch from source
-------------------------------------------

This approach may be needed for pull requests that were last updated more than
90 days ago, or to test on platforms and configurations that are not supported
by Godot's GitHub Actions setup.

- Open the pull request page. Click the *fork*'s branch name near the top of the page:

.. image:: img/testing_pull_requests_access_fork.png

- Now that you are on the fork's branch page, click the green **Code** button on the right of the page
  then choose **Download ZIP** in the dropdown:

.. image:: img/testing_pull_requests_fork_zip.png

- Extract the ZIP archive and follow the :ref:`compiling <toc-devel-compiling>` instructions
  for your operating system.


===================================================
/. ./community/contributing/bisecting_regressions.rst
===================================================

.. _doc_bisecting_regressions:

Bisecting regressions
=====================

.. highlight:: shell

Bisecting is a way to find regressions in software. After reporting a bug on the
`Godot repository on GitHub <https://github.com/godotengine/godot>`__, you may
be asked by a contributor to *bisect* the issue. Bisecting makes it possible for
contributors to fix bugs faster, as they can know in advance which commit caused
the regression. Your effort will be widely appreciated :)

The guide below explains how to find a regression by bisecting.

What is bisecting?
------------------

Godot developers use the `Git <https://git-scm.com/>`__ version control system.
In the context of Git, bisecting is the process of performing a manual
`binary search <https://en.wikipedia.org/wiki/Binary_search_algorithm>`__
to determine when a regression appeared. While it's typically used for bugs,
it can also be used to find other kinds of unexpected changes such as
performance regressions.

Using official builds to speed up bisecting
-------------------------------------------

Before using Git's ``bisect`` command, we strongly recommend trying to reproduce
the bug with an older (or newer) official release. This greatly reduces the
range of commits that potentially need to be built from source and tested.
You can find binaries of official releases, as well as alphas, betas,
and release candidates `here <https://downloads.tuxfamily.org/godotengine/>`__.

For example, if you've reported a bug against Godot 3.2, you should first try to
reproduce the bug in Godot 3.1 (not a patch release, see below for the reason).
If the bug doesn't occur there, try to reproduce it in Godot 3.2 *beta 1* (which
is roughly in the middle of all test builds available). If you can't reproduce
the bug with Godot 3.2 beta 1, then try newer betas and RC builds. If you do
manage to reproduce the bug with Godot 3.2 beta 1, then try older alpha builds.

.. warning::

    For bisecting regressions, don't use patch releases such as Godot 3.1.2.
    Instead, use the minor version's first release like Godot 3.1. This is
    because patch releases are built from a separate *stable branch*. This kind
    of branch doesn't follow the rest of Godot's development, which is done in
    the ``master`` branch.

The Git bisect command
----------------------

If you've found a build that didn't exhibit the bug in the above testing
process, you can now start bisecting the regression. The Git version control
system offers a built-in command for this: ``git bisect``. This makes the
process semi-automated as you only have to build the engine, run it and try to
reproduce the bug.

.. note::

    Before bisecting a regression, you need to set up a build environment to
    compile Godot from source. To do so, read the
    :ref:`Compiling <toc-devel-compiling>` page for your target platform.
    (Compiling Godot from source doesn't require C++ programming knowledge.)

    Note that compiling Godot can take a while on slow hardware (up an hour for
    each full rebuild on a slow dual-core CPU). This means the full process can
    take up to several hours. If your hardware is too slow, you may want to stop
    there and report the results of your "pre-bisecting" on the GitHub issue so
    another contributor can continue bisecting from there.

To start bisecting, you must first determine the commit hashes (identifiers) of
the "bad" and "good" build. "bad" refers to the build that exhibits the bug,
whereas "good" refers to the version that doesn't exhibit the bug. If you're
using a pre-release build as the "good" or "bad" build, browse the `download
mirror <https://downloads.tuxfamily.org/godotengine/>`__, go to the folder that
contains the pre-release you downloaded and look for the ``README.txt`` file.
The commit hash is written inside that file.

If you're using a stable release as the "good" or "bad" build, use one of the
following commit hashes depending on the version:

.. code-block:: none

    3.2-stable
    3.1-stable
    3.0-stable

To refer to the latest state of the master branch, you can use ``master``
instead of a commit hash.

:ref:`Get Godot's source code using Git <doc_getting_source>`. Once this
is done, in the terminal window, use ``cd`` to reach the Godot repository
folder and enter the following command:

.. code-block:: shell

    # <good commit hash> is hash of the build that works as expected.
    # <bad commit hash> is hash of the build exhibiting the bug.
    $ git bisect start
    $ git bisect good <good commit hash>
    $ git bisect bad <bad commit hash>

Compile Godot. This assumes you've set up a build environment:

.. code-block:: shell

    # <platform> is the platform you're targeting for regression testing,
    # like "windows", "x11" or "osx".
    $ scons platform=<platform> -j4

Since building Godot takes a while, you want to dedicate as many CPU threads as
possible to the task. This is what the ``-j`` parameter does. Here, the command
assigns 4 CPU threads to compiling Godot.

Run the binary located in the ``bin/`` folder and try to reproduce the bug.

If the build **still** exhibits the bug, run the following command:

.. code-block:: shell

    $ git bisect bad

If the build **does not** exhibit the bug, run the following command:

.. code-block:: shell

    $ git bisect good

After entering one of the commands above, Git will switch to a different commit.
You should now build Godot again, try to reproduce the bug, then enter ``git
bisect good`` or ``git bisect bad`` depending on the result. You'll have to
repeat this several times. The longer the commit range, the more steps will be
required. 5 to 10 steps are usually sufficient to find most regressions; Git
will remind you of the number of steps remaining (in the worst case scenario).

Once you've completed enough steps, Git will display the commit hash where the
regression appeared. Write this commit hash as a comment to the GitHub issue
you've bisected. This will help in solving the issue. Thanks again for
contributing to Godot :)

.. note::

    You can read the full documentation on ``git bisect``
    `here <https://git-scm.com/docs/git-bisect>`__.


===================================================
/. ./community/contributing/bug_triage_guidelines.rst
===================================================

.. _doc_bug_triage_guidelines:

Bug triage guidelines
=====================

This page describes the typical workflow of the bug triage team aka
bugsquad when handling issues and pull requests on Godot's
`GitHub repository <https://github.com/godotengine/godot>`__.
It is bound to evolve together with the bugsquad, so do not
hesitate to propose modifications to the following guidelines.

Issues management
-----------------

GitHub proposes various features to manage issues:

-  Set one or several labels from a predefined list
-  Set one milestone from a predefined list
-  Keep track of the issue in the project dashboard
-  Define one contributor as "assignee" among the Godot engine
   organization members

As the Godot engine organization on GitHub currently has a restricted
number of contributors, we do not use assignees extensively for now. All
contributors are welcome to take on any issue, if relevant after mentioning
it on the issue ticket and/or discussing the best way to resolve it with
other developers.

For the time being, we do not use the project dashboard feature either.

As far as possible, we try to assign labels (and milestones, when relevant)
to both issues and pull requests.

Labels
~~~~~~

The following labels are currently defined in the Godot repository:

**Categories:**

-  *Archived*: either a duplicate of another issue, or invalid. Such an
   issue would also be closed.
-  *Breaks compat*: describes something that can only be fixed by breaking
   compatibility with existing projects.
-  *Bug*: describes something that is not working properly.
-  *Cherrypick*: describes something that can be backported to a stable branch
   after being merged in the ``master`` branch.
-  *Crash:* describes a bug that causes the engine to crash.
   This label is only used for "hard" crashes, not freezes.
-  *Confirmed*: has been confirmed by at least one other contributor
   than the bug reporter (typically for *Bug* reports).
   The purpose of this label is to let developers know which issues are
   still reproducible when they want to select what to work on. It is
   therefore a good practice to add in a comment on what platform and
   what version or commit of Godot the issue could be reproduced; if a
   developer looks at the issue one year later, the *Confirmed* label
   may not be relevant anymore.
-  *Discussion*: the issue is not consensual and needs further
   discussion to define what exactly should be done to address the
   topic.
-  *Documentation*: issue related to the documentation. Mainly to request
   enhancements in the API documentation. Issues related to the ReadTheDocs
   documentation should be filed on the
   `godot-docs <https://github.com/godotengine/godot-docs>`_ repository.
-  *Enhancement*: describes a proposed enhancement to an existing
   functionality.
-  *Feature proposal*: describes a wish for a new feature to be
   implemented. Note that the main Godot repository no longer accepts
   feature requests. Please use
   `godot-proposals <https://github.com/godotengine/godot-proposals>`__ instead.
-  *For PR meeting*: the issue needs to be discussed in a pull request meeting.
   These meetings are public and are held on the `Godot Contributors Chat <https://chat.godotengine.org/>`_.
-  *Good first issue*: the issue is *assumed* to be an easy one to fix, which makes
   it a great fit for new contributors who need to become familiar with
   the code base.
-  *High priority:* the issue is particularly important as it can
   prevent people from releasing their projects or cause data loss.
-  *Needs work*: the pull request needs additional work before it can be merged.
-  *Needs testing*: the issue/pull request could not be completely tested
   and thus need further testing. This can mean that it needs to be tested
   on different hardware/software configurations or even that the steps to
   reproduce are not certain.
-  *Performance*: issues that directly impact engine or editor performance.
   Can also be used for pull requests that improve performance or add low-end-friendly options.
   Should not be coupled with *Usability*.
-  *PR welcome / Hero wanted!*: Contributions for issues with these labels
   are especially welcome. Note that this **doesn't** mean you can't work
   on issues without these labels.
-  *Regression*: the bug appeared after a stable release not exhibiting
   the bug was released.
-  *Salvageable*: the pull request can't be merged due to design issues or
   merge conflicts and its author is not active anymore. However, it can still
   be picked up by an external contributor to bring it to a mergeable state.
   To do so, you need to open a new pull request based on the original pull request.
-  *Tracker*: issue used to track other issues (like all issues related to
   the plugin system).
-  *Usability*: issues that directly impact user usability. Should not be coupled with *Performance*.

The categories are used for general triage of the issues. They can be
combined in some way when relevant, e.g. an issue can be labelled
*Enhancement* and *Usability* at the same time if it's an issue to improve
usability. Or *Feature proposal* and *Discussion* if it's a non-consensual
feature request, or one that is not precise enough to be worked on.

**Topics:**

-  *2D*: relates to 2D-specific issues. Should be coupled with one of the labels below, and should not be coupled with *3D*.
-  *3D*: relates to 3D-specific issues. Should be coupled with one of the labels below, and should not be coupled with *2D*.
-  *Assetlib*: relates to issues with the asset library.
-  *Audio*: relates to the audio features (low and high level).
-  *Buildsystem*: relates to building issues, either linked to the SCons
   buildsystem or to compiler peculiarities.
-  *Codestyle*: relates to the programming style used within the codebase.
-  *Core*: anything related to the core engine. It might be further
   split later on as it's a pretty big topic.
-  *Editor*: relates to issues in the editor (mainly UI).
-  *GDNative*: relates to the GDNative module.
-  *GDScript*: relates to GDScript.
-  *GUI*: relates to GUI (Control) nodes.
-  *Import*: relates to the resource import system.
-  *Input*: relates to input system.
-  *Mono*: relates to the C# / Mono bindings.
-  *Navigation*: relates to the navigation system (including A* and navmeshes).
-  *Network*: relates to networking.
-  *Physics*: relates to the physics engine (2D/3D).
-  *Plugin*: relates to problems encountered while writing plugins.
-  *Porting*: relates to some specific platforms or exporting projects.
-  *Rendering*: relates to the 2D and 3D rendering engines.
-  *Shaders*: relates to the Godot shader language or visual shaders.
-  *Tests*: relates to unit tests.
-  *Thirdparty*: relates to third-party libraries used in Godot.
-  *VisualScript*: relates to issues with the visual scripting language (*not* visual shaders).
-  *XR*: relates to Augmented Reality or Virtual Reality.

Issues would typically correspond to only one topic, though it's not
unthinkable to see issues that fit two bills. The general idea is that
there will be specialized contributors teams behind all topics, so they
can focus on the issues labelled with their team's topic.

**Platforms:**

*Android*, *HTML5*, *iOS*, *Linux*, *macOS*, *Windows*, *UWP*

By default, it is assumed that a given issue applies to all platforms.
If one of the platform labels is used, it is then exclusive and the
previous assumption doesn't stand anymore (so if it's a bug on e.g.
Android and Linux exclusively, select those two platforms).

Documentation labels
~~~~~~~~~~~~~~~~~~~~

In the `documentation repository <https://github.com/godotengine/godot-docs>`__, we
use the following labels:

-  *Bug*: Incorrect information in an existing page. Not to be used for
   *missing* information.
-  *Class reference*: the issue is about the class reference, not a documentation page.
-  *Discussion*: the issue is not consensual and needs further
   discussion to define what exactly should be done to address the
   topic.
-  *Enhancememnt*: new information to be added in an existing page.
-  *New page*: a new page to be created.
-  *Hero wanted!*: contributions for issues with these labels
   are especially welcome. Note that this **doesn't** mean you can't work
   on issues without these labels.
-  *Organization*: The issue involves moving pages around or reorganizing content.
-  *Redirect*: a redirection needs to be created in the Read the Docs backend.
   Only administrators can do this.
-  *Salvageable*: the pull request can't be merged due to design issues or
   merge conflicts and its author is not active anymore. However, it can still
   be picked up by an external contributor to bring it to a mergeable state.
   To do so, you need to open a new pull request based on the original pull request.
-  *Topic:Mono*: the issue is about C# support in Godot.
-  *Topic:Website*: the issue relates to the Sphinx/Read the Docs frontend or backend,
   not the documentation contents.

Milestones
~~~~~~~~~~

`Milestones <https://github.com/godotengine/godot/milestones>`_ correspond to
planned future versions of Godot for which there is an existing roadmap. Issues
that fit in the said roadmap should be filed under the corresponding milestone;
if they don't correspond to any current roadmap, they should be left without
milestone. As a rule of thumb, an issue corresponds to a given milestone if it
concerns a feature that is new in the milestone, or a critical bug that can't be
accepted in any future stable release, or anything that Juan wants to work on
right now. :)

Contributors are free to pick issues regardless of their assigned milestone;
if a fix is proposed for a bug that was not deemed urgent and thus without
milestone, it would likely still be very welcome.


===================================================
/. ./community/contributing/code_style_guidelines.rst
===================================================

.. _doc_code_style_guidelines:

Code style guidelines
=====================

.. highlight:: shell

When contributing to Godot's source code, you will be expected to follow the
style guidelines outlined below. Some of them are checked via the Continuous
Integration process and reviewers will ask you to fix potential issues, so
best setup your system as outlined below to ensure all your commits follow the
guidelines.

C++ and Objective-C
-------------------

There are no written guidelines, but the code style agreed upon by the
developers is enforced via the `clang-format <http://clang.llvm.org/docs/ClangFormat.html>`__
code beautifier, which takes care for you of all our conventions.
To name a few:

- Indentation and alignment are both tab based (respectively one and two tabs)
- One space around math and assignments operators as well as after commas
- Pointer and reference operators are affixed to the variable identifier, not
  to the type name
- See further down regarding header includes

The rules used by clang-format are outlined in the
`.clang-format <https://github.com/godotengine/godot/blob/master/.clang-format>`__
file of the Godot repository.

As long as you ensure that your style matches the surrounding code and that you
not introducing trailing whitespace or space-based indentation, you should be
fine. If you plan to contribute regularly however, we strongly advise that you
setup clang-format locally to check and automatically fix all your commits.

.. warning:: Godot's code style should *not* be applied to third-party code,
             i.e. that is included in Godot's source tree but was not written
             specifically for our project. Such code usually come from
             different upstream projects with their own style guides (or lack
             thereof), and don't want to introduce differences that would make
             syncing with upstream repositories harder.

             Third-party code is usually included in the ``thirdparty/`` folder
             and can thus easily be excluded from formatting scripts. For the
             rare cases where a third-party code snippet needs to be included
             directly within a Godot file, you can use
             ``/* clang-format off */`` and ``/* clang-format on */`` to tell
             clang-format to ignore a chunk of code.

.. seealso::

    These guidelines only cover code formatting. See :ref:`doc_cpp_usage_guidelines`
    for a list of language features that are permitted in pull requests.

Using clang-format locally
~~~~~~~~~~~~~~~~~~~~~~~~~~

First of all, you will need to install clang-format. As of now, you need to use
**clang-format 13** to be compatible with Godot's format. Later versions might
be suitable, but previous versions may not support all used options, or format
some things differently, leading to style issues in pull requests.

Installation
^^^^^^^^^^^^

Here's how to install clang-format:

- Linux: It will usually be available out-of-the-box with the clang toolchain
  packaged by your distribution. If your distro version is not the required one,
  you can download a pre-compiled version from the
  `LLVM website <http://releases.llvm.org/download.html>`__, or if you are on
  a Debian derivative, use the `upstream repos <http://apt.llvm.org/>`__.
- macOS and Windows: You can download precompiled binaries from the
  `LLVM website <http://releases.llvm.org/download.html>`__. You may need to add
  the path to the binary's folder to your system's ``PATH`` environment
  variable to be able to call ``clang-format`` out of the box.

You then have different possibilities to apply clang-format to your changes:

Manual usage
^^^^^^^^^^^^

You can apply clang-format manually one or more files with the following
command:

::

    clang-format -i <path/to/file(s)>

- ``-i`` means that the changes should be written directly to the file (by
  default clang-format would only output the fixed version to the terminal).
- The path can point to several files, either one after the other or using
  wildcards like in a typical Unix shell. Be careful when globbing so that
  you don't run clang-format on compiled objects (.o and .a files) that are
  in Godot's tree. So better use ``core/*.{cpp,h}`` than ``core/*``.

Pre-commit hook
^^^^^^^^^^^^^^^

For ease of use, we provide a pre-commit hook for Git that will run
clang-format automatically on all your commits to check them, and let you apply
its changes in the final commit.

This "hook" is a script which can be found in ``misc/hooks``, refer to that
folder's README.md for installation instructions.

If your clang-format is not in the ``PATH``, you may have to edit the
``pre-commit-clang-format`` to point to the correct binary for it to work.
The hook was tested on Linux and macOS, but should also work in the Git Shell
on Windows.

IDE plugin
^^^^^^^^^^

Most IDEs or code editors have beautifier plugins that can be configured to run
clang-format automatically, for example each time you save a file.

Here is a non-exhaustive list of beautifier plugins for some IDEs:

- Qt Creator: `Beautifier plugin <http://doc.qt.io/qtcreator/creator-beautifier.html>`__
- Visual Studio Code: `Clang-Format <https://marketplace.visualstudio.com/items?itemName=xaver.clang-format>`__
- Visual Studio: `ClangFormat <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.ClangFormat>`__
- vim: `vim-clang-format <https://github.com/rhysd/vim-clang-format>`__
- CLion: Starting from version ``2019.1``, no plugin is required. Instead, enable
  `ClangFormat <https://www.jetbrains.com/help/clion/clangformat-as-alternative-formatter.html#clion-support>`__

(Pull requests welcome to extend this list with tested plugins.)

.. _doc_code_style_guidelines_header_includes:

Header includes
~~~~~~~~~~~~~~~

When adding new C++ or Objective-C files or including new headers in existing
ones, the following rules should be followed:

- The first lines in the file should be Godot's copyright header and MIT
  license, copy-pasted from another file. Make sure to adjust the filename.
- In a ``.h`` header, include guards should be used with the form
  ``FILENAME_H``.

- In a ``.cpp`` file (e.g. ``filename.cpp``), the first include should be the
  one where the class is declared (e.g. ``#include "filename.h"``), followed by
  an empty line for separation.
- Then come headers from Godot's own code base, included in alphabetical order
  (enforced by ``clang-format``) with paths relative to the root folder. Those
  includes should be done with quotes, e.g. ``#include "core/object.h"``. The
  block of Godot header includes should then be followed by an empty line for
  separation.
- Finally, third-party headers (either from ``thirdparty`` or from the system's
  include paths) come next and should be included with the < and > symbols, e.g.
  ``#include <png.h>``. The block of third-party headers should also be followed
  by an empty line for separation.
- Godot and third-party headers should be included in the file that requires
  them, i.e. in the `.h` header if used in the declarative code or in the `.cpp`
  if used only in the imperative code.

Example:

.. code-block:: cpp

    /*************************************************************************/
    /*  my_new_file.h                                                        */
    /*************************************************************************/
    /*                       This file is part of:                           */
    /*                           GODOT ENGINE                                */
    /*                      https://godotengine.org                          */
    /*************************************************************************/
    /* Copyright (c) 2007-2021 Juan Linietsky, Ariel Manzur.                 */
    /* Copyright (c) 2014-2021 Godot Engine contributors (cf. AUTHORS.md).   */
    /*                                                                       */
    /* Permission is hereby granted, free of charge, to any person obtaining */
    /* a copy of this software and associated documentation files (the       */
    /* "Software"), to deal in the Software without restriction, including   */
    /* without limitation the rights to use, copy, modify, merge, publish,   */
    /* distribute, sublicense, and/or sell copies of the Software, and to    */
    /* permit persons to whom the Software is furnished to do so, subject to */
    /* the following conditions:                                             */
    /*                                                                       */
    /* The above copyright notice and this permission notice shall be        */
    /* included in all copies or substantial portions of the Software.       */
    /*                                                                       */
    /* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
    /* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
    /* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
    /* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
    /* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
    /* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
    /* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
    /*************************************************************************/

    #ifndef MY_NEW_FILE_H
    #define MY_NEW_FILE_H

    #include "core/hash_map.h"
    #include "core/list.h"
    #include "scene/gui/control.h"

    #include <png.h>

    ...

    #endif // MY_NEW_FILE_H

.. code-block:: cpp

    /*************************************************************************/
    /*  my_new_file.cpp                                                      */
    /*************************************************************************/
    /*                       This file is part of:                           */
    /*                           GODOT ENGINE                                */
    /*                      https://godotengine.org                          */
    /*************************************************************************/
    /* Copyright (c) 2007-2021 Juan Linietsky, Ariel Manzur.                 */
    /* Copyright (c) 2014-2021 Godot Engine contributors (cf. AUTHORS.md).   */
    /*                                                                       */
    /* Permission is hereby granted, free of charge, to any person obtaining */
    /* a copy of this software and associated documentation files (the       */
    /* "Software"), to deal in the Software without restriction, including   */
    /* without limitation the rights to use, copy, modify, merge, publish,   */
    /* distribute, sublicense, and/or sell copies of the Software, and to    */
    /* permit persons to whom the Software is furnished to do so, subject to */
    /* the following conditions:                                             */
    /*                                                                       */
    /* The above copyright notice and this permission notice shall be        */
    /* included in all copies or substantial portions of the Software.       */
    /*                                                                       */
    /* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
    /* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
    /* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
    /* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
    /* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
    /* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
    /* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
    /*************************************************************************/

    #include "my_new_file.h"

    #include "core/math/math_funcs.h"
    #include "scene/gui/line_edit.h"

    #include <zlib.h>
    #include <zstd.h>

Java
----

Godot's Java code (mostly in ``platform/android``) is also enforced via
``clang-format``, so see the instructions above to set it up. Keep in mind that
this style guide only applies to code written and maintained by Godot, not
third-party code such as the ``java/src/com/google`` subfolder.

Python
------

Godot's SCons buildsystem is written in Python, and various scripts included
in the source tree are also using Python.

For those, we follow the `Black style guide <https://github.com/psf/black#the-black-code-style>`__.
Blacken your Python changes using `Black <https://pypi.org/project/black/>`__.

Using black locally
~~~~~~~~~~~~~~~~~~~

First of all, you will need to install black. Black requires Python 3.6.0+
to run.

Installation
^^^^^^^^^^^^

Here's how to install black:

::

    pip3 install black --user


You then have different possibilities to apply black to your changes:

Manual usage
^^^^^^^^^^^^

You can apply ``black`` manually to one or more files with the following
command:

::

    black -l 120 <path/to/file(s)>

- ``-l 120`` means that the allowed number of characters per line is 120.
  This number was agreed upon by the developers.
- The path can point to several files, either one after the other or using
  wildcards like in a typical Unix shell.

Pre-commit hook
^^^^^^^^^^^^^^^

For ease of use, we provide a pre-commit hook for Git that will run
black automatically on all your commits to check them, and let you apply
its changes in the final commit.

This "hook" is a script which can be found in ``misc/hooks``. Refer to that
folder's ``README.md`` for installation instructions.


Editor integration
^^^^^^^^^^^^^^^^^^

Many IDEs or code editors have beautifier plugins that can be configured to run
black automatically, for example each time you save a file. For details you can
check `Black editor integration <https://github.com/psf/black#editor-integration>`__.

Comment style guide
-------------------

This comment style guide applies to all programming languages used within
Godot's codebase.

- Begin comments with a space character to distinguish them from disabled code.
- Use sentence case for comments. Begin comments with an uppercase character and
  always end them with a period.
- Reference variable/function names and values using backticks.
- Wrap comments to ~100 characters.
- You can use ``TODO:``, ``FIXME:``, ``NOTE:``, or ``HACK:`` as adominitions
  when needed.

**Example:**

.. code-block:: cpp

    // Compute the first 10,000 decimals of Pi.
    // FIXME: Don't crash when computing the 1,337th decimal due to `increment`
    //        being negative.

Don't repeat what the code says in a comment. Explain the *why* rather than *how*.

**Bad:**

.. code-block:: cpp

    // Draw loading screen.
    draw_load_screen();

You can use Javadoc-style comments above function or macro definitions. It's
recommended to use Javadoc-style comments *only* for methods which are not
exposed to scripting. This is because exposed methods should be documented in
the :ref:`class reference XML <doc_updating_the_class_reference>`
instead.

**Example:**

.. code-block:: cpp

    /**
     * Returns the number of nodes in the universe.
     * This can potentially be a very large number, hence the 64-bit return type.
     */
    uint64_t Universe::get_node_count() {
        // ...
    }

For member variables, don't use Javadoc-style comments but use single-line comments instead:

.. code-block:: cpp

    class Universe {
        // The cached number of nodes in the universe.
        // This value may not always be up-to-date with the current number of nodes
        // in the universe.
        uint64_t node_count_cached = 0;
    };


===================================================
/. ./community/contributing/cpp_usage_guidelines.rst
===================================================

.. _doc_cpp_usage_guidelines:

C++ usage guidelines
====================

Rationale
---------

Since Godot 4.0, the C++ standard used throughout the codebase is a subset of
**C++17**. While modern C++ brings a lot of opportunities to write faster, more
readable code, we chose to restrict our usage of C++ to a subset for a few
reasons:

- It makes it easier to review code in online editors. This is because engine
  contributors don't always have access to a full-featured IDE while reviewing
  code.
- It makes the code easier to grasp for beginner contributors (who may not be
  professional C++ programmers). Godot's codebase is known to be easy to learn
  from, and we'd like to keep it that way.

To get your pull request merged, it needs to follow the C++ usage guidelines
outlined here. Of course, you can use features not allowed here in your own C++
modules or GDNative scripts.

.. note::

    Prior to Godot 4.0, the C++ standard used throughout the codebase was C++03,
    with a handful of C++14 extensions. If you are contributing a pull request
    to the `3.x` branch rather than `master`, your code can't use C++17 features.
    Instead, your code must be able to be built with a C++14 compiler.

    The guidelines below don't apply to third-party dependencies, although we
    generally favor small libraries instead of larger solutions. See also
    :ref:`doc_best_practices_for_engine_contributors`.

.. seealso::

    See :ref:`doc_code_style_guidelines` for formatting guidelines.

Disallowed features
-------------------

**Any feature not listed below is allowed.** Using features like ``constexpr``
variables and ``nullptr`` is encouraged when possible. Still, try to keep your
use of modern C++ features conservative. Their use needs to serve a real
purpose, such as improving code readability or performance.

Standard Template Library
^^^^^^^^^^^^^^^^^^^^^^^^^

We don't allow using the `STL <https://en.wikipedia.org/wiki/Standard_Template_Library>`__
as Godot provides its own data types (among other things).
See :ref:`doc_faq_why_not_stl` for more information.

This means that pull requests should **not** use ``std::string``,
``std::vector`` and the like. Instead, use Godot's datatypes as described below:

- Use ``String`` instead of ``std::string``.
- Use ``Vector`` instead of ``std::vector``. In some cases, ``LocalVector``
  can be used as an alternative (ask core developers first).
- Use ``Array`` instead of ``std::array``.

.. note::

    Godot also has a List datatype (which is a linked list). While List is already used
    in the codebase, it typically performs worse than other datatypes like Vector
    and Array. Therefore, List should be avoided in new code unless necessary.

``auto`` keyword
^^^^^^^^^^^^^^^^

Please don't use the ``auto`` keyword for type inference. While it can avoid
repetition, it can also lead to confusing code:

.. code-block:: cpp

    // Not so confusing...
    auto button = memnew(Button);

    // ...but what about this?
    auto result = EditorNode::get_singleton()->get_complex_result();

Keep in mind hover documentation often isn't readily available for pull request
reviewers. Most of the time, reviewers will use GitHub's online viewer to review
pull requests.

We chose to forbid ``auto`` instead of allowing it on a case-by-case basis to
avoid having to decide on difficult edge cases. Thank you for your understanding.

Lambdas
^^^^^^^

Lambdas should be used conservatively when they make code effectively faster or
simpler, and do not impede readability. Please ask before using lambdas in a
pull request.

``#pragma once`` directive
^^^^^^^^^^^^^^^^^^^^^^^^^^

To follow the existing style, please use standard ``#ifdef``-based include
guards instead of ``#pragma once`` in new files.

.. seealso::

    See :ref:`doc_code_style_guidelines_header_includes` for guidelines on sorting
    includes in C++ and Objective-C files.


===================================================
/. ./community/contributing/content_guidelines.rst
===================================================

.. _doc_content_guidelines:

Content guidelines
==================

This document is here to help us assess what we should include in the official
documentation. Below, you will find a couple of principles and recommendations
to write accessible content.

We want to achieve two goals:

1. **Empathize with our users.** We should write in a way that makes it easy for
   them to learn from the docs.
2. **Write a complete reference manual**. Our goal here is not to teach
   programming foundations. Instead, we should provide a reference for how
   Godot's features work.

Guidelines and principles
-------------------------

Below are the guidelines we should strive to follow. They are not hard rules,
though: exceptionally, a topic will require breaking one or more of these.
Still, we should strive to achieve the two goals listed above.

Writing complete and accessible documentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**A feature doesn't exist unless it is documented**. If a user can't find
information about a feature and how it works, it doesn't exist to them. We
should ensure that we cover everything Godot does.

.. note::

    When adding or updating an engine feature, the documentation team needs to
    know about it. Contributors should open an issue on the `godot-docs` repository
    when their work gets merged and requires documentation.

Do your best to keep documents **under 1000 words in length**. If a page goes
past that threshold, consider splitting it into two parts if possible. Limiting
page size forces us to write concisely and to break large documents so they each
focus on a particular problem.

Make it clear what **problem** each page or section of a page tackles and what
the user will learn from it. Users need to know if they're reading the correct
guide to solving problems they encounter. For example, instead of writing the
heading "Signals", consider writing "Reacting to changes with signals". The
second title makes it clear what the purpose of signals is.

.. note::

    Long section titles lead to long entries in the side menu, which can make
    navigation cumbersome. Try to keep headings five words long or less.

If the page assumes specific knowledge of other Godot features, mention it and
link it to the corresponding documentation. For instance, a page about physics
may use signals, in which case we could note that the page that introduces
signals is a pre-requisite.

Limiting cognitive load
~~~~~~~~~~~~~~~~~~~~~~~

Limit the cognitive load required to read the documentation. The simpler and
more explicit language we use, the more efficient it becomes for people to
learn. You can do so by:

1. Introducing only one new concept at a time whenever possible.
2. Using simple English, as we recommend in our writing guidelines.
3. Including one or more **concrete usage examples**. Prefer a real-world example
   to abstract code like ``foobar``.

While many people may understand more complex language and abstract examples,
you will lose others. Also, understandable writing and practical examples
benefit everyone.

Always make an effort to **put yourself in the user's shoes**. When we
understand something thoroughly, it becomes evident to us. We may fail to think
about details relevant to a newcomer, but **good documentation meets users where
they are**. We should strive to explain each feature's capabilities or intended
uses with the most straightforward language possible.

Try to remember what you first needed to know when learning about the feature or
concept. What new terms did you need to learn? What confused you? What was the
hardest to grasp? You will want users to review your work, and we recommend you
practice explaining the feature before writing about it.

.. note::

    Having programming foundations is a pre-requisite to use a complex engine
    like Godot. Talking about variables, functions, or classes is acceptable.
    But we should favor plain language over specific terminology like
    "metaprogramming". If you need to use precise terms, be sure to define them.

When a page assumes knowledge of another engine feature, declare it at the
beginning and link to resources that cover what users need. You may also link to
other websites for pre-requisites beyond the documentation's scope. For example,
you could link to an introduction to programming in the getting started guide, or a
website that teaches math theory in the math section.


===================================================
/. ./community/contributing/docs_writing_guidelines.rst
===================================================

.. _doc_docs_writing_guidelines:

Docs writing guidelines
=======================

The Godot community is rich and international. Users come from all
around the world. Some of them are young, and many aren't native English
speakers. That's why we must all write using a clear and a common
language. For the class reference, the goal is to make it easy to read
for everyone and precise.

In summary, always try to:

1. Use the active voice
2. Use precise action verbs
3. Avoid verbs that end in -ing
4. Remove unnecessary adverbs and adjectives.
5. Ban these 8 words: obvious, simple, basic, easy, actual, just, clear, and however
6. Use explicit references
7. Use 's to show possession
8. Use the Oxford comma

There are 3 rules to describe classes:

1. Give an overview of the node in the brief description
2. Mention what methods return if it's useful
3. Use "if true" to describe booleans

.. note::

    A technical writer's job is to pack as much information as possible into
    the smallest and clearest sentences possible. These guidelines will help
    you work towards that goal.

.. seealso::

    See the :ref:`content guidelines <doc_content_guidelines>` for information
    on the types of documentation you can write in the official documentation.

7 rules for clear English
-------------------------

Use the active voice
~~~~~~~~~~~~~~~~~~~~

Use the active voice when possible. Take the classes, methods, and
constants you describe as the subject. It's natural to write using the
passive voice, but it's harder to read and produces longer sentences.

.. highlight:: none

Passive:

::

    The man **was bitten** by the dog.

Active:

::

    The dog bit the man.

**Don't** use the passive voice:

::

    void edit_set_pivot ( Vector2 pivot )
    [...] This method **is implemented** only in some nodes that inherit Node2D.

**Do** use the node's name as a noun:

::

    void edit_set_pivot ( Vector2 pivot )
    [...] Only some Node2Ds **implement** this method.

Use precise action verbs
~~~~~~~~~~~~~~~~~~~~~~~~

Favor precise yet common verbs over generic ones like ``make``, ``set``,
and any expression you can replace with a single word.

**Don't** repeat the method's name. It already states it sets the pivot
value to a new one:

::

    void edit_set_pivot ( Vector2 pivot )
    Set the pivot position of the 2D node to [code]pivot[/code] value. [...]

**Do** explain what's the consequence of this "set": use precise verbs
like ``place``, ``position``, ``rotate``, ``fade``, etc.

::

    void edit_set_pivot ( Vector2 pivot )
    Position the node's pivot to the [code]pivot[/code] value. [...]

Avoid verbs that end in -ing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The progressive forms describe continuous actions. E.g. "is calling",
"is moving".

**Don't** use the progressive form for instant changes.

::

    Vector2 move ( Vector2 rel_vec )
    Move the body in the given direction, **stopping** if there is an obstacle. [...]

**Do** use simple present, past, or future.

::

    Vector2 move ( Vector2 rel_vec )
    Moves the body in the vector's direction. The body **stops** if it collides with an obstacle. [...]

Exception: If the subject is not clear, replacing "ing" verbs is not an
improvement. For example, in the previous sentence, "it replaces"
would not make much sense where "replacing" currently is.

You may use the progressive tense to describe actions that are
continuous in time. Anything like animation or coroutines.

.. tip::

    Verbs can turn into adjectival nouns with -ing. This is not a
    conjugation, so you may use them: ``the remaining movement``,
    ``the missing file``, etc.

Remove unnecessary adverbs and adjectives
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Write as few adjectives and adverbs as possible. Only use them if they
add key information to the description.

**Don't** use redundant or meaningless adverbs. Words that lengthen the
documentation but don't add any information:

::

    **Basically** a big texture [...]

**Do** write short sentences in a simple, descriptive language:

::

    A big texture [...]

Ban these 8 words
~~~~~~~~~~~~~~~~~

**Don't** ever use these 8 banned words:

1. obvious
2. simple
3. basic
4. easy
5. actual
6. just
7. clear
8. however (some uses)

Game creation and programming aren't simple, and nothing's easy to
someone learning to use the API for the first time. Other words in the
list, like ``just`` or ``actual`` won't add any info to the sentence.
Don't use corresponding adverbs either: obviously, simply, basically,
easily, actually, clearly.

**Don't** example. The banned words lengthen the description and take
attention away from the most important info:

::

    **TextureRect**
    Control frame that **simply** draws an assigned texture. It can stretch or not. It's a **simple** way to **just** show an image in a UI.

**Do** remove them:

::

    **TextureRect**
    [Control] node that displays a texture. The texture can stretch to the node's bounding box or stay in the center. Useful to display sprites in your UIs.

"Simple" never helps. Remember, for other users, anything could be
complex or frustrate them. There's nothing like a good old *it's simple*
to make you cringe. Here's the old brief description, the first sentence
on the Timer node's page:

::

    **Timer**
    A **simple** Timer node.

**Do** explain what the node does instead:

::

    **Timer**
    Calls a function of your choice after a certain duration.

**Don't** use "basic", it is too vague:

::

    **Vector3**
    Vector class, which performs **basic** 3D vector math operations.

**Do** use the brief description to offer an overview of the node:

::

    **Vector3**
    Provides essential math functions to manipulate 3D vectors: cross product, normalize, rotate, etc.

Use explicit references
~~~~~~~~~~~~~~~~~~~~~~~

Favor explicit references over implicit ones.

**Don't** use words like "the former", "the latter", etc. They're not
the most common in English, and they require you to check the reference.

::

    [code]w[/code] and [code]h[/code] define right and bottom margins. The **latter** two resize the texture so it fits in the defined margin.

**Do** repeat words. They remove all ambiguity:

::

    [code]w[/code] and [code]h[/code] define right and bottom margins. **[code]w[/code] and [code]h[/code]** resize the texture so it fits the margin.

If you need to repeat the same variable name 3 or 4 times, you probably
need to rephrase your description.

Use 's to show possession
~~~~~~~~~~~~~~~~~~~~~~~~~

Avoid "The milk **of** the cow". It feels unnatural in English. Write "The cow's
milk" instead.

**Don't** write "of the X":

::

    The region **of the AtlasTexture that is** used.

**Do** use ``'s``. It lets you put the main subject at the start of the
sentence, and keep it short:

::

    The **AtlasTexture's** used region.

Use the Oxford comma to enumerate anything
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From the Oxford dictionary:

    The 'Oxford comma' is an optional comma before the word 'and' at the end of a list:
    *We sell books, videos, and magazines.*

    [...] Not all writers and publishers use it, but it can clarify the meaning of a sentence when the items in a list are not single words:
    *These items are available in black and white, red and yellow, and blue and green.*

**Don't** leave the last element of a list without a comma:

::

    Create a KinematicBody2D node, a CollisionShape2D node and a sprite node.

**Do** add a comma before `and` or `or`, for the last
element of a list with more than two elements.

::

    Create a KinematicBody2D node, a CollisionShape2D node, and a sprite node.


How to write methods and classes
--------------------------------

Dynamic vs static typing
~~~~~~~~~~~~~~~~~~~~~~~~

The code examples in the documentation should follow a consistent style not to
confuse users. As static type hints are an optional feature of GDScript, we
chose to stick to writing dynamic code. This leads to writing GDScript that is
concise and accessible.

The exception is topics that explain static typing concepts to users.

**Don't** add a type hint with a colon or by casting:

::

    const MainAttack := preload("res://fire_attack.gd")
    var hit_points := 5
    var name: String = "Bob"
    var body_sprite := $Sprite as Sprite


**Do** write constants and variables with dynamic typing:

::

    const MainAttack = preload("res://fire_attack.gd")
    var hit_points = 5
    var name = "Bob"
    var body_sprite = $Sprite


**Don't** write functions with inferred arguments or return types:

::

    func choose(arguments: PackedStringArray) -> String:
        # Chooses one of the arguments from array with equal chances
        randomize()
        var size := arguments.size()
        var choice: int = randi() % size
        return arguments[choice]

**Do** write functions using dynamic typing:

::

    func choose(arguments):
        # Chooses one of the arguments from array with equal chances
        randomize()
        var size = arguments.size()
        var choice = randi() % size
        return arguments[choice]

Use real-world code examples where appropriate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Real-world examples are more accessible to beginners than abstract ``foos`` and
``bars``. You can also copy them directly from your game projects, ensuring that
any code snippet compiles without errors.

Writing ``var speed = 10`` rather than ``var my_var = 10`` allows beginners to
understand code better. It gives them a frame of reference as to where they
could use the code snippets in a live project.

**Don't** write made-up examples:

::

    onready var a = preload("res://MyPath")
    onready var my_node = $MyNode


    func foo():
        # Do stuff

**Do** write concrete examples:

::

    onready var sfx_player_gun = preload("res://Assets/Sound/SFXPlayerGun.ogg")
    onready var audio_player = $Audio/AudioStreamPlayer


    func play_shooting_sound():
        audio_player.stream = sfx_player_gun
        audio_player.play()

Of course, there are times when using real-world examples is impractical. In
those situations, you should still avoid using names such as ``my_var``,
``foo()`` or ``my_func()`` and consider more meaningful names for your examples.

Give an overview of the node in the brief description
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The brief description is the reference's most important sentence. It's
the user's first contact with a node:

1. It's the only description in the "Create New Node" dialog.
2. It's at the top of every page in the reference

The brief description should explain the node's role and its
functionality, in up to 200 characters.

**Don't** write tiny and vague summaries:

::

    **Node2D**
    Base node for 2D system.

**Do** give an overview of the node's functionality:

::

    **Node2D**
    A 2D game object, inherited by all 2D-related nodes. Has a position, rotation, scale, and Z index.

Use the node's full description to provide more information, and a code
example, if possible.

Mention what methods return if it's useful
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some methods return important values. Describe them at the end of the
description, ideally on a new line. No need to mention the return values
for any method whose name starts with ``set`` or ``get``.

**Don't** use the passive voice:

::

    Vector2 move ( Vector2 rel_vec )
    [...] The returned vector is how much movement was remaining before being stopped.

**Do** always use "Returns".

::

    Vector2 move ( Vector2 rel_vec )
    [...] Returns the remaining movement before the body was stopped.

Notice the exception to the "direct voice" rule: with the move method,
an external collider can influence the method and the body that calls
``move``. In this case, you can use the passive voice.

Use "if true" to describe booleans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For boolean member variables, always use ``if true`` and/or
``if false``, to stay explicit. ``Controls whether or not`` may be
ambiguous and won't work for every member variable.

Also, surround boolean values, variable names and methods with ``[code][/code]``.

**Do** start with "if true":

::

    Timer.autostart
    If [code]true[/code], the timer will automatically start when entering the scene tree.


Use ``[code]`` around arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the class reference, always surround arguments with ``[code][/code]``. In the
documentation and in Godot, it will display like ``this``. When you edit XML
files in the Godot repository, replace existing arguments written like 'this' or
\`this\` with ``[code]this[/code]``.


Common vocabulary to use in Godot's documentation
-------------------------------------------------

The developers chose some specific words to refer to areas of the
interface. They're used in the sources, in the documentation, and you
should always use them instead of synonyms, so the users know what
you're talking about.

.. figure:: img/editor-vocabulary-overview.png
   :alt: Overview of the interface and common vocabulary

   Overview of the interface and common vocabulary

In the top left corner of the editor lie the ``main menus``. In the
center, the buttons change the ``workspace``. And together the buttons
in the top right are the ``playtest buttons``. The area in the center,
that displays the 2D or the 3D space, is the ``viewport``. At its top,
you find a list of ``tools`` inside the ``toolbar``.

The tabs or dockable panels on either side of the viewport are
``docks``. You have the ``FileSystem dock``, the ``Scene dock`` that
contains your scene tree, the ``Import dock``, the ``Node dock``, and
the ``Inspector`` or ``Inspector dock``. With the default layout you may
call the tabbed docks ``tabs``: the ``Scene tab``, the ``Node tab``...

The Animation, Debugger, etc. at the bottom of the viewport are
``panels``. Together they make up the ``bottom panels``.

Foldable areas of the Inspector are ``sections``. The node's parent
class names, which you can't fold, are ``Classes`` e.g. the
``KinematicBody2D class``. And individual lines with key-value pairs are
``properties``. E.g. ``position`` or ``modulate color`` are both
``properties``.

Keyboard shortcut guidelines
----------------------------

Keyboard and mouse shortcuts should make use of the ``:kbd:`` tag, which allows
shortcuts to stand out from the rest of the text and inline code. Use the
compact form for modifier keys (:kbd:`Ctrl`/:kbd:`Cmd`) instead of their spelled
out form (:kbd:`Control`/:kbd:`Command`). For combinations, use the ``+`` symbol
with a space on either side of the symbol.

Make sure to mention shortcuts that differ on macOS compared to other platforms.
On macOS, ``Cmd`` often replaces ``Ctrl`` in keyboard shortcuts.

Try to integrate the shortcut into sentences the best you can. Here are some
examples with the ``:kbd:`` tag left as-is for better visibility:

- Press ``:kbd:`Ctrl + Alt + T``` to toggle the panel (``:kbd:`Cmd + Alt + T``` on macOS).
- Press ``:kbd:`Space``` and hold the left mouse button to pan in the 2D editor.
- Press ``:kbd:`Shift + Up Arrow``` to move the node upwards by 8 pixels.

Image contribution guidelines
-----------------------------

A significant part of the documentation is images, and there are several
important guidelines to follow.

First, you should always be using the default editor theme and text when taking
screenshots.

To improve the appearance of 3D screenshots, use 4× MSAA, enable anisotropic
filtering on the project's textures, and set the anisotropic filter quality to
16× in Project Settings.

Screenshot sizes should not exceed 1920×1080 to ensure fast loading on slower
connections.

When you need to highlight an area of the editor to show something, like a
button or option, use a 2 pixel-thick yellow outline without a bevel. If the
outline is on a dark background, the outline should be yellow so it can be
easily seen by colorblind people. Please do not use red as it won't be visible
for some users.

Before you add or replace any images in the documentation, they should be run
through a PNG compressor to save size. You can use the lossless OxiPNG
compressor included in `Squoosh <https://squoosh.app/>`__ for this purpose. For
heavier images, consider using a lossy compressor like `pngquant
<https://pngquant.org/>`_. With it, almost no image quality is lost during
compression.

.. note::

    The program pngquant must be installed locally as it's not available in Squoosh.


===================================================
/. ./community/contributing/documentation_guidelines.rst
===================================================

.. _doc_documentation_guidelines:

Documentation guidelines
========================

This page describes the rules to follow if you want to contribute to Godot
Engine by writing or reviewing documentation, or by translating existing
documentation. Also, have a look at README of the
`godot-docs GitHub repository <https://github.com/godotengine/godot-docs>`_
and the `docs front page <https://docs.godotengine.org>`_
on what steps to follow and how to contact the docs team.

How to contribute
-----------------

Creating or modifying documentation pages is mainly done via the
`godot-docs GitHub repository <https://github.com/godotengine/godot-docs>`_.
The HTML (or PDF and EPUB) documentation is generated from the .rst files
(reStructuredText markup language) in that repository. Modifying those pages
in a pull request and getting it merged will trigger a rebuild of the online
documentation.

.. seealso:: For details on Git usage and the pull request workflow, please
             refer to the :ref:`doc_pr_workflow` page. Most of what it
             describes regarding the main godotengine/godot repository is
             also valid for the docs repository.

.. warning:: The class reference's source files are in the `Godot engine repository
             <https://github.com/godotengine/godot>`_. We generate the :ref:`Godot API
             <doc_class_reference>` section of this documentation from them. If you want
             to update the description of a class, its methods, or properties, read
             :ref:`doc_updating_the_class_reference`.

.. warning:: If you want to edit the **API reference**, please note that it
             should *not* be done in the godot-docs repository. Instead, you
             should edit the ``doc/classes/*`` XML files of Godot's
             main repository. These files are then later used to generate the
             in-editor documentation as well as the API reference of the
             online docs. Read more here: :ref:`doc_updating_the_class_reference`.

The 'Edit on GitHub' link
-------------------------

If you're reading documentation on `docs.godotengine.org <https://docs.godotengine.org>`_,
you'll see an **Edit on GitHub** hyperlink at the top right of the page.
Once you've created a GitHub account, you can propose changes to a page you're
reading as follows:

1. Click the **Edit on GitHub** button.

2. On the GitHub page you're taken to, click the pencil icon in the top-right
   corner near the **Raw**, **Blame** and **History** buttons. It has the tooltip
   "Edit the file in a fork of this project".

3. Complete all the edits you want to make for that page.

4. Summarize the changes you made in the form at the bottom of the page and
   click the button labelled **Propose file change** when done.

5. On the following screens, click the **Create pull request** button until you
   see a message like *Username wants to merge 1 commit into
   godotengine:master from Username:patch-6*.

6. A reviewer will evaluate your changes and incorporate them into the docs if
   they're acceptable. You might also be asked to make
   modifications to your changes before they're included.

What makes good documentation?
------------------------------

Documentation should be well written in plain English, using well-formed
sentences and various levels of sections and subsections. It should be clear
and objective. Also, have a look at the :ref:`doc_docs_writing_guidelines`.

We differentiate tutorial pages from other documentation pages by these
definitions:

-  Tutorial: a page aiming at explaining how to use one or more concepts in
   the editor or scripts in order to achieve a specific goal with a learning
   purpose (e.g. "Making a simple 2d Pong game", "Applying forces to an
   object").
-  Documentation: a page describing precisely one and only one concept at a
   time, if possible exhaustively (e.g. the list of methods of the
   Sprite class, or an overview of the input management in Godot).

You are free to write the kind of documentation you wish, as long as you
respect the following rules (and the ones on the repo).

Titles
------

Always begin pages with their title and a Sphinx reference name:

::

    .. _doc_insert_your_title_here:

    Insert your title here
    ======================

The reference allows linking to this page using the ``:ref:`` format, e.g.
``:ref:`doc_insert_your_title_here``` would link to the above example page
(note the lack of leading underscore in the reference).

Also, avoid American CamelCase titles: title's first word should begin
with a capitalized letter, and every following word should not. Thus,
this is a good example:

-  Insert your title here

And this is a bad example:

-  Insert Your Title Here

Only project, people and node class names should have capitalized first
letter.

Translating existing pages
--------------------------

You can help to translate the official Godot documentation on our `Hosted Weblate <https://hosted.weblate.org/engage/godot-engine/>`_.

.. image:: https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png
    :alt: Translation state
    :align: center
    :target: https://hosted.weblate.org/engage/godot-engine/?utm_source=widget
    :width: 287
    :height: 66

There also is the official
`Godot i18n repository <https://github.com/godotengine/godot-docs-l10n>`_
where you can see when the data was last synchronized.

License
-------

This documentation and every page it contains is published under the terms of
the `Creative Commons Attribution 3.0 license (CC-BY-3.0) <https://tldrlegal.com/license/creative-commons-attribution-(cc)>`_, with attribution to "Juan Linietsky, Ariel Manzur and the Godot community".

By contributing to the documentation on the GitHub repository, you agree that
your changes are distributed under this license.


===================================================
/. ./community/contributing/contributing_to_the_documentation.rst
===================================================

.. _doc_contributing_to_the_documentation:

Contributing to the documentation
=================================

This guide explains how to contribute to Godot's documentation, be it by
writing or reviewing pages.

.. seealso::

   If you want to translate pages or the class reference from English to other
   languages, read :ref:`doc_editor_and_docs_localization`.

Getting started
---------------

To modify or create pages in the reference manual, you need to edit ``.rst``
files in the `godot-docs GitHub repository
<https://github.com/godotengine/godot-docs>`_. Modifying those pages in a pull
request triggers a rebuild of the online documentation upon merging.

.. seealso:: For details on Git usage and the pull request workflow, please
             refer to the :ref:`doc_pr_workflow` page. Most of what it describes
             regarding the main godotengine/godot repository is also valid for
             the docs repository.

.. warning:: The class reference's source files are in the `Godot engine
             repository <https://github.com/godotengine/godot>`_. We generate
             the :ref:`Godot API <doc_class_reference>` section of this documentation
             from them. If you want to update the description of a class, its
             methods, or properties, read
             :ref:`doc_updating_the_class_reference`.

What is the Godot documentation
-------------------------------

The Godot documentation is intended as a comprehensive reference manual for the
Godot game engine. It is not meant to contain step-by-step tutorials, except for
two game creation tutorials in the Getting Started section.

We strive to write factual content in an accessible and well-written language. To
contribute, you should also read:

1. The :ref:`doc_docs_writing_guidelines`. There, you will find rules and
   recommendations to write in a way that everyone understands.
2. The content guidelines. They explain the principles we follow to write the
   documentation and the kind of content we accept.

Contributing changes
--------------------

**Pull Requests should use the** ``master`` **branch by default.** Only make Pull
Requests against other branches (e.g. ``2.1`` or ``3.0``) if your changes only
apply to that specific version of Godot.

Though less convenient to edit than a wiki, this Git repository is where we
write the documentation. Having direct access to the source files in a revision
control system is a plus to ensure our documentation quality.

Editing existing pages
~~~~~~~~~~~~~~~~~~~~~~

To edit an existing page, locate its ``.rst`` source file and open it in your
favorite text editor. You can then commit the changes, push them to your fork,
and make a pull request. **Note that the pages in** ``classes/`` **should not be
edited here.** They are automatically generated from Godot’s `XML class
reference <https://github.com/godotengine/godot/tree/master/doc/classes>`__.
See :ref:`doc_updating_the_class_reference` for details.

.. seealso:: To build the manual and test changes on your computer, see
             :ref:`doc_building_the_manual`.

Editing pages online
--------------------

You can edit the documentation online by clicking the **Edit on GitHub** link in
the top-right of every page.

Doing so takes you to the GitHub text editor. You need to have a GitHub account
and to log in to use it. Once logged in, you can propose change like so:

1. Click the **Edit on GitHub** button.

2. On the GitHub page you're taken to, click the pencil icon in the top-right
   corner near the **Raw**, **Blame**, and **Delete** buttons. It has the
   tooltip "Fork this project and edit the file".

3. Edit the text in the text editor.

4. At the bottom of the web page, summarize the changes you made and click the
   button **Propose file change**. Make sure to replace the placeholder "Update file.rst"
   by a short but clear one-line description, as this is the commit title.

5. On the following screens, click the **Create pull request** button until you
   see a message like *Username wants to merge 1 commit into godotengine:master
   from Username:patch-1*.

Another contributor will review your changes and merge them into the docs if
they're good. They may also make changes or ask you to do so before merging.

Adding new pages
----------------

Before adding a new page, please ensure that it fits in the documentation:

1. Look for `existing issues
   <https://github.com/godotengine/godot-docs/issues>`_ or open a new one to see
   if the page is necessary.
2. Ensure there isn't a page that already covers the topic.
3. Read our :ref:`doc_content_guidelines`.

To add a new page, create a ``.rst`` file with a meaningful name in the section you
want to add a file to, e.g. ``tutorials/3d/light_baking.rst``.

You should then add your page to the relevant "toctree" (table of contents,
e.g. ``tutorials/3d/index.rst``). Add your new filename to the list on a new
line, using a relative path and no extension, e.g. here ``light_baking``.

Titles
~~~~~~

Always begin pages with their title and a Sphinx reference name:

::

    .. _doc_insert_your_title_here:

    Insert your title here
    ======================

The reference ``_doc_insert_your_title_here`` and the title should match.

The reference allows linking to this page using the ``:ref:`` format, e.g.
``:ref:`doc_insert_your_title_here``` would link to the above example page (note
the lack of leading underscore in the reference).

Write your titles like plain sentences, without capitalizing each word:

-  **Good:** Understanding signals in Godot
-  **Bad:** Understanding Signals In Godot

Only propers nouns, projects, people, and node class names should have their
first letter capitalized.

Sphinx and reStructuredText syntax
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Check Sphinx’s `reST Primer <https://www.sphinx-doc.org/en/stable/rest.html>`__
and the `official reference <http://docutils.sourceforge.net/rst.html>`__ for
details on the syntax.

Sphinx uses specific reST comments to do specific operations, like defining the
table of contents (``.. toctree::``) or cross-referencing pages. Check the
`official Sphinx documentation
<https://www.sphinx-doc.org/en/stable/index.html>`__ for more details. To learn
how to use Sphinx directives like ``.. note::`` or ``.. seealso::``, check out
the `Sphinx directives documentation
<https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html>`__.

Adding images and attachments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To add images, please put them in an ``img/`` folder next to the ``.rst`` file with
a meaningful name and include them in your page with:

.. code:: rst

   .. image:: img/image_name.png

Similarly, you can include attachments, like assets as support material for a
tutorial, by placing them into a ``files/`` folder next to the ``.rst`` file, and
using this inline markup:

.. code:: rst

   :download:`myfilename.zip <files/myfilename.zip>`


License
-------

This documentation and every page it contains is published under the terms of
the `Creative Commons Attribution 3.0 license (CC-BY-3.0)
<https://tldrlegal.com/license/creative-commons-attribution-(cc)>`_, with
attribution to "Juan Linietsky, Ariel Manzur and the Godot community".

By contributing to the documentation on the GitHub repository, you agree that
your changes are distributed under this license.


===================================================
/. ./community/contributing/building_the_manual.rst
===================================================

.. _doc_building_the_manual:

Building the manual with Sphinx
===============================

This page explains how to build a local copy of the Godot manual using the
Sphinx docs engine. This allows you to have local HTML files and build the
documentation as a PDF, EPUB, or LaTeX file, for example.

To get started, you need to:

1. Clone the `godot-docs repository <https://github.com/godotengine/godot-docs/>`__.
2. Install `Sphinx <https://www.sphinx-doc.org/>`__
3. To build the docs as HTML files, install the `readthedocs.org theme
   <https://github.com/snide/sphinx_rtd_theme>`__.
4. Install the Sphinx extensions defined in the `godot-docs repository
   <https://github.com/godotengine/godot-docs/>`__ ``requirements.txt`` file.

We recommend using `pip <https://pip.pypa.io>`__, Python’s package manager to
install all these tools. It comes pre-installed with `Python
<https://www.python.org/>`__. Ensure that you install and use Python 3. Here are
the commands to clone the repository and then install all requirements.

.. note:: You may need to write ``python3 -m pip`` (Unix) or  ``py -m pip`` (Windows) instead of ``pip3``.
          If both approaches fail, `check that you have pip3 installed <https://pip.pypa.io/en/stable/installation/>`__.

.. code:: sh

    git clone https://github.com/godotengine/godot-docs.git
    pip3 install -r requirements.txt


With the programs installed, you can build the HTML documentation from the root
folder of this repository with the following command:

.. code:: sh

    # On Linux and macOS
    make html

    # On Windows, you need to execute the ``make.bat`` file instead.
    make.bat html

If you run into errors, you may try the following command:

.. code:: sh

    make SPHINXBUILD=~/.local/bin/sphinx-build html

Building the documentation requires at least 8 GB of RAM to run without disk
swapping, which slows it down. If you have at least 16 GB of RAM, you can speed
up compilation by running:

.. code:: sh

    # On Linux/macOS
    make html SPHINXOPTS=-j2

    # On Windows
    set SPHINXOPTS=-j2 && make html

The compilation will take some time as the ``classes/`` folder contains hundreds
of files.

You can then browse the documentation by opening ``_build/html/index.html`` in
your web browser.

In case you of a ``MemoryError`` or ``EOFError``, you can remove the
``classes/`` folder and run ``make`` again. This will drop the class references
from the final HTML documentation but will keep the rest intact.

.. note:: If you delete the ``classes/`` folder, do not use ``git add .`` when
          working on a pull request or the whole ``classes/`` folder will be
          removed when you commit. See `#3157
          <https://github.com/godotengine/godot-docs/issues/3157>`__ for more
          detail.

Alternatively, you can build the documentation by running the sphinx-build
program manually:

.. code:: sh

   sphinx-build -b html ./ _build

You can also specify a list of files to build, which can greatly speed up compilation:

.. code:: sh

  sphinx-build -b html ./ _build classes/class_node.rst classes/class_resource.rst

Building with Sphinx and virtualenv
-----------------------------------

If you want your Sphinx installation scoped to the project, you can install
sphinx-build using virtualenv. To do so, run this command from this repository's
root folder:

.. code:: sh

   virtualenv --system-site-packages env/
   . env/bin/activate
   pip3 install -r requirements.txt

Then, run ``make html`` as shown above.


===================================================
/. ./community/contributing/updating_the_class_reference.rst
===================================================

.. _doc_updating_the_class_reference:

Contributing to the class reference
===================================

.. highlight:: shell

The class reference is available online in the :ref:`classes <doc_class_reference>`
section of the documentation and in the Godot editor, from the help menu.

In the class reference, some methods, variables, and signals lack descriptions.
Others changed with recent releases and need updates. The developers can't write
the entire reference on their own. Godot needs you, and all of us, to
contribute.

**Important:** If you plan to make large changes, you should create an issue on
the `godot-docs repository <https://github.com/godotengine/godot-docs/>`_
or comment on an existing issue. Doing so lets others know you're already
taking care of a given class.

.. seealso::

    You can find the writing guidelines for the class reference :ref:`here <doc_class_reference_writing_guidelines>`.

    For details on Git usage and the pull request workflow, please
    refer to the :ref:`doc_pr_workflow` page.

    If you want to translate the class reference from English to another
    language, see :ref:`doc_editor_and_docs_localization`.

    This guide is also available as a `video tutorial on YouTube
    <https://www.youtube.com/watch?v=5jeHXxeX-JY>`_.

.. seealso::

    Not sure which class to contribute to? Take a look at the class reference's
    completion status `here <https://godotengine.github.io/doc-status/>`_.

You can find the source files for the class reference in Godot's GitHub
repository: `doc/classes/
<https://github.com/godotengine/godot/tree/master/doc/classes>`_.

.. note:: For some modules in the engine's source code, you'll find the XML
          files in the ``modules/<module_name>/doc_classes/`` directory instead.

.. warning:: Always edit the API reference through these source XML files. Do
             not edit the generated ``.rst`` files :ref:`in the online documentation
             <doc_class_reference>`, hosted in the `godot-docs
             <https://github.com/godotengine/godot-docs>`_ repository.

.. warning::

    Unless you make minor changes, like fixing a typo, we do not recommend using the GitHub web editor to edit the class reference's XML.

    It lacks features to edit XML well, like keeping indentations consistent, and it does not allow amending commits based on reviews.

    Also, it doesn't allow you to test your changes in the engine or with validation
    scripts as described in
    :ref:`doc_class_reference_writing_guidelines_editing_xml`.

Updating the documentation template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you create a new class or modify the engine's API, you need to re-generate the XML files in ``doc/classes/``.

To do so, you first need to compile Godot. See the
:ref:`doc_introduction_to_the_buildsystem` page to learn how. Then, execute the
compiled Godot binary from the Godot root directory with the ``--doctool`` option.
For example, if you're on 64-bit Linux, the command is::

    ./bin/godot.linuxbsd.tools.64 --doctool

The XML files in doc/classes should then be up-to-date with current Godot Engine
features. You can then check what changed using the ``git diff`` command. Please
only include changes that are relevant to your work on the API in your commits.
You can discard changes in other XML files using ``git checkout``.


===================================================
/. ./community/contributing/class_reference_writing_guidelines.rst
===================================================

.. _doc_class_reference_writing_guidelines:

Class reference writing guidelines
==================================

This page explains how to write the class reference. You will learn where to
write new descriptions for the classes, methods, and properties for Godot's
built-in node types.

.. seealso::

    To learn to submit your changes to the Godot project using the Git version
    control system, see :ref:`doc_updating_the_class_reference`.

The reference for each class is contained in an XML file like the one below:

.. code-block:: xml

    <class name="Node2D" inherits="CanvasItem" version="4.0">
        <brief_description>
            A 2D game object, inherited by all 2D-related nodes. Has a position, rotation, scale, and Z index.
        </brief_description>
        <description>
            A 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order.
        </description>
        <tutorials>
            <link title="Custom drawing in 2D">https://docs.godotengine.org/en/latest/tutorials/2d/custom_drawing_in_2d.html</link>
            <link title="All 2D Demos">https://github.com/godotengine/godot-demo-projects/tree/master/2d</link>
        </tutorials>
        <methods>
            <method name="apply_scale">
                <return type="void">
                </return>
                <argument index="0" name="ratio" type="Vector2">
                </argument>
                <description>
                    Multiplies the current scale by the [code]ratio[/code] vector.
                </description>
            </method>
            [...]
            <method name="translate">
                <return type="void">
                </return>
                <argument index="0" name="offset" type="Vector2">
                </argument>
                <description>
                    Translates the node by the given [code]offset[/code] in local coordinates.
                </description>
            </method>
        </methods>
        <members>
            <member name="global_position" type="Vector2" setter="set_global_position" getter="get_global_position">
                Global position.
            </member>
            [...]
            <member name="z_index" type="int" setter="set_z_index" getter="get_z_index" default="0">
                Z index. Controls the order in which the nodes render. A node with a higher Z index will display in front of others.
            </member>
        </members>
        <constants>
        </constants>
    </class>


It starts with brief and long descriptions. In the generated docs, the brief
description is always at the top of the page, while the long description lies
below the list of methods, variables, and constants. You can find methods,
member variables, constants, and signals in separate XML nodes.

For each, you want to learn how they work in Godot's source code. Then, fill
their documentation by completing or improving the text in these tags:

- `<brief_description>`
- `<description>`
- `<constant>`
- `<method>` (in its `<description>` tag; return types and arguments don't take separate
  documentation strings)
- `<member>`
- `<signal>` (in its `<description>` tag; arguments don't take separate documentation strings)
- `<constant>`

Write in a clear and simple language. Always follow the :ref:`writing guidelines
<doc_docs_writing_guidelines>` to keep your descriptions short and easy to read.
**Do not leave empty lines** in the descriptions: each line in the XML file will
result in a new paragraph, even if it is empty.

.. _doc_class_reference_writing_guidelines_editing_xml:

How to edit class XML
---------------------

Edit the file for your chosen class in ``doc/classes/`` to update the class
reference. The folder contains an XML file for each class. The XML lists the
constants and methods you will find in the class reference. Godot generates and
updates the XML automatically.

.. note:: For some modules in the engine's source code, you'll find the XML
          files in the ``modules/<module_name>/doc_classes/`` directory instead.

Edit it using your favorite text editor. If you use a code editor, make sure
that it doesn't change the indent style: you should use tabs for the XML and
four spaces inside BBCode-style blocks. More on that below.

To check that the modifications you've made are correct in the generated
documentation, navigate to the ``doc/`` folder and run the command ``make rst``.
This will convert the XML files to the online documentation's format and output
errors if anything's wrong.

Alternatively, you can build Godot and open the modified page in the built-in
code reference. To learn how to compile the engine, read the :ref:`compilation
guide <toc-devel-compiling>`.

We recommend using a code editor that supports XML files like Vim, Atom, Visual Studio Code,
Notepad++, or another to comfortably edit the file. You can also use their
search feature to find classes and properties quickly.

.. _doc_class_reference_writing_guidelines_bbcode:

Improve formatting with BBCode style tags
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Godot's class reference supports BBCode-like tags. They add nice formatting to
the text. Here's the list of available tags:

+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| Tag                        | Effect                               | Usage                             | Result                                            |
+============================+======================================+===================================+===================================================+
| [Class]                    | Link a class                         | Move the [Sprite].                | Move the :ref:`class_Sprite`.                     |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [method methodname]        | Link to a method in this class       | Call [method hide].               | Call :ref:`hide <class_Spatial_method_hide>`.     |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [method Class.methodname]  | Link to another class's method       | Call [method Spatial.hide].       | Call :ref:`hide <class_Spatial_method_hide>`.     |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [member membername]        | Link to a member in this class       | Get [member scale].               | Get :ref:`scale <class_Node2D_property_scale>`.   |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [member Class.membername]  | Link to another class's member       | Get [member Node2D.scale].        | Get :ref:`scale <class_Node2D_property_scale>`.   |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [signal signalname]        | Link to a signal in this class       | Emit [signal renamed].            | Emit :ref:`renamed <class_Node_signal_renamed>`.  |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [signal Class.signalname]  | Link to another class's signal       | Emit [signal Node.renamed].       | Emit :ref:`renamed <class_Node_signal_renamed>`.  |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [b] [/b]                   | Bold                                 | Some [b]bold[/b] text.            | Some **bold** text.                               |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [i] [/i]                   | Italic                               | Some [i]italic[/i] text.          | Some *italic* text.                               |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [code] [/code]             | Monospace                            | Some [code]monospace[/code] text. | Some ``monospace`` text.                          |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [kbd] [/kbd]               | Keyboard/mouse shortcut              | Some [kbd]Ctrl + C[/kbd] key.     | Some :kbd:`Ctrl + C` key.                         |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [codeblock] [/codeblock]   | Multiline preformatted block         | *See below.*                      | *See below.*                                      |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [codeblocks] [/codeblocks] | [codeblock] for multiple languages   | *See below.*                      | *See below.*                                      |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [gdscript] [/gdscript]     | GDScript codeblock tab in codeblocks | *See below.*                      | *See below.*                                      |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+
| [csharp] [/csharp]         | C# codeblock tab in codeblocks       | *See below.*                      | *See below.*                                      |
+----------------------------+--------------------------------------+-----------------------------------+---------------------------------------------------+

Use ``[codeblock]`` for pre-formatted code blocks. Inside ``[codeblock]``,
always use **four spaces** for indentation. The parser will delete tabs. For
example:

.. code-block:: none

    [codeblock]
    func _ready():
        var sprite = get_node("Sprite")
        print(sprite.get_pos())
    [/codeblock]

Will display as:

.. code-block:: gdscript

    func _ready():
        var sprite = get_node("Sprite")
        print(sprite.get_pos())

If you need to have different code version in GDScript and C#, use
``[codeblocks]`` instead. If you use ``[codeblocks]``, you also need to have at
least one of the language-specific tags, ``[gdscript]`` and ``[csharp]``.

Always write GDScript code examples first! You can use this `experimental code
translation tool <https://github.com/HaSa1002/codetranslator>`_ to speed up your
workflow.

.. code-block:: none

    [codeblocks]
    [gdscript]
    func _ready():
        var sprite = get_node("Sprite")
        print(sprite.get_pos())
    [/gdscript]
    [csharp]
    public override void _Ready()
    {
        var sprite = GetNode("Sprite");
        GD.Print(sprite.GetPos());
    }
    [/csharp]
    [/codeblocks]

The above will display as:

.. tabs::
 .. code-tab:: gdscript GDScript

    func _ready():
        var sprite = get_node("Sprite")
        print(sprite.get_pos())

 .. code-tab:: csharp

    public override void _Ready()
    {
        var sprite = GetNode("Sprite");
        GD.Print(sprite.GetPos());
    }

To denote important information, add a paragraph starting with "[b]Note:[/b]" at
the end of the description:

.. code-block:: none

    [b]Note:[/b] Only available when using the Vulkan renderer.

To denote crucial information that could cause security issues or loss of data
if not followed carefully, add a paragraph starting with "[b]Warning:[/b]" at
the end of the description:

.. code-block:: none

    [b]Warning:[/b] If this property is set to [code]true[/code], it allows clients to execute arbitrary code on the server.

For deprecated properties, add a paragraph starting with "[i]Deprecated.[/i]".
Notice the use of italics instead of bold:

.. code-block:: none

    [i]Deprecated.[/i] This property has been replaced by [member other_property].

In all the paragraphs described above, make sure the punctuation is part of the
BBCode tags for consistency.

I don't know what this method does!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

No problem. Leave it behind, and list the methods you skipped when you request a
pull of your changes. Another writer will take care of it.

You can still look at the methods' implementation in Godot's source code on
GitHub. If you have doubts, feel free to ask on the `Q&A website
<https://godotengine.org/qa/>`__ and `Godot Contributors Chat <https://chat.godotengine.org/>`_.


===================================================
/. ./community/contributing/editor_and_docs_localization.rst
===================================================

.. _doc_editor_and_docs_localization:

Editor and docs localization
============================

.. highlight:: none

Godot aims to make game development available to everyone, including people who
may not know or be comfortable with English. Therefore, we do our best to make
the most important resources available in many languages, thanks to the
translation effort of the community.

These resources include:

1. The `Godot editor's interface <https://hosted.weblate.org/projects/godot-engine/godot/>`__
   (ca. 15,000 words).
2. The `online documentation <https://hosted.weblate.org/projects/godot-engine/godot-docs/>`__
   (editor manual and tutorials, ca. 300,000 words).
3. The `class reference <https://hosted.weblate.org/projects/godot-engine/godot-class-reference/>`__,
   available both online and in the editor (ca. 200,000 words).

To manage translations, we use the GNU gettext file format (``PO`` files), and
the open source `Weblate <https://weblate.org>`__ web-based localization
platform, which allows easy collaboration of many contributors to complete the
translation for the various components, and keep them up to date. Click the bold
links above to access each resource on Weblate.

This page gives an overview of the general translation workflow on Weblate, and
some resource-specific instructions on e.g. how to handle some keywords or the
localization of images.

.. tip::

    Translating all the official Godot content is a massive undertaking, so we
    advise prioritizing the resources as they are listed above: first the editor
    interface, then the online documentation, and eventually the class reference
    if there are enough translators to keep up with updates.

Using Weblate for translations
------------------------------

While our translations eventually reside in the Git repositories of the Godot
engine and its documentation, all translation updates are handled through
Weblate, and thus direct pull requests to the Git repositories are not accepted.
Translations are synced manually between Weblate and the Godot repositories by
maintainers.

You should therefore `register on Weblate <https://hosted.weblate.org/accounts/register/>`__
to contribute to Godot's translations.

Once signed in, browse to the Godot resource which you want to contribute to (in
this page we will use the `editor translation <https://hosted.weblate.org/projects/godot-engine/godot/>`__
as an example) to find the list of all languages:

.. image:: img/l10n_01_language_list.png

.. seealso::

    Feel free to consult Weblate's own documentation on the `translation
    workflow <https://docs.weblate.org/en/latest/user/translating.html>`__ for
    more details.

Adding a new language
^^^^^^^^^^^^^^^^^^^^^

If your language is already listed, click on its name to access the overview,
and skip the rest of this section.

If your language is not listed, scroll to the bottom of the list of languages
and click the "Start new translation" button, and select the language you want
to translate to:

.. image:: img/l10n_02_new_translation.png

.. important::

    If your language is spoken in several countries with only limited regional
    variations, please consider adding it with its generic variant (e.g. ``fr``
    for French) instead of a regional variant (e.g. ``fr_FR`` for French
    (France), ``fr_CA`` for French (Canada), or ``fr_DZ`` for French (Algeria)).

    Godot has a huge amount of content to translate, so duplicating the work for
    regional variants should only be done if the language variations are
    significant enough. Additionally, if a translation is done with for a
    regional variant, it will only be available automatically for users located
    in this region (or having their system language configured for this region).

    When regional variations are significant enough to warrant separate
    translations, we advise to focus on completing a generic variant first if
    possible, then duplicate the fully completed translation for regional
    variants and do the relevant edits. This is typically a good strategy for
    e.g. Spanish (work on ``es`` first, then duplicate it to ``es_AR``,
    ``es_ES``, ``es_MX``, etc. if necessary) or Portuguese (``pt_BR`` vs
    ``pt_PT``).

Translation interface
^^^^^^^^^^^^^^^^^^^^^

Once a language has been selected, you will see an overview of the translation
status, including how many strings are left to translate or review. Each item
can be clicked and used to browse through the corresponding list. You can also
click the "Translate" button to get started on the list of strings needing
action.

.. image:: img/l10n_03_translation_overview.png

After selecting a list of clicking "Translate", you will see the main
translation interface where all the work happens:

.. image:: img/l10n_04_translation_interface.png

On that page, you have:

 - A toolbar which lets you cycle through strings of the current list, change
   to another predefined list or do a custom search, etc. There is also a "Zen"
   editing mode with a simplified interface.
 - The actual string you are working on in the "Translation" panel. By default,
   there should be the English source string and an edit box for your language.
   If you are familiar with other languages, you can add them in your user
   settings to give you more context for translation.
   Once you are done editing the current string, press "Save" to confirm changes
   and move to the next entry. Alternatively, use the "Skip" button to skip it.
   The "Needs editing" checkbox means that the original string was updated, and
   the translation therefore needs review to take those changes into account (in
   PO jargon, these are so-called "fuzzy" strings). Such strings won't be used
   in the translation until fixed.
 - The bottom panel has various tools which can help with the translation
   effort, such as context from nearby strings (usually from the same editor
   tool or documentation page, so they might use similar terms), comments from
   other translators, machine translations, and a list of all other existing
   translations for that string.
 - On the top right, the glossary shows terms for which an entry has been added
   previously, and which are included in the current string. For example, if
   you decided with fellow translators to use a specific translation for the
   "node" term in Godot, you can add it to the glossary to ensure that other
   translators use the same convention.
 - The bottom right panel includes information on the source string. The most
   relevant item is the "source string location", which links you to the
   original string on GitHub. You may need to search for the string in the page
   to locate it and its surrounding context.

Locating original content
-------------------------

PO files are an ordered list of source strings (``msgid``) and their translation
(``msgstr``), and by default, Weblate will present the strings in that order. It
can therefore be useful to understand how the content is organized in the PO
files to help you locate the original content and use it as a reference when
translating.

.. important::

    It is primordial to use the original context as reference when translating,
    as many words have several possible translations depending on the context.
    Using the wrong translation can actually be detrimental to the user and make
    things harder to understand than if they stayed in English.
    Using the context also makes the translation effort much easier and more
    enjoyable, as you can see directly if the translation you wrote will make
    sense in context.

- The editor interface's translation template is generated by parsing all the
  C++ source code in **alphabetical order**, so all the strings defined in a
  given file will be grouped together. For example, if the "source string
  location" indicates ``editor/code_editor.cpp``, the current string (and the
  nearby ones) is defined in the ``editor/code_editor.cpp`` code file, and is
  thereby related to the code editors in Godot (GDScript, shaders).
- The online documentation's translation template is generated from the source
  RST files in the same order as seen in the **table of contents**, so for
  example the first strings are from the front page of the documentation.
  The recommended workflow is therefore to find a unique string corresponding to
  a page that you want to translate, and then translate all the strings with the
  same source string location while comparing with the online version of that
  page in English. An example of source string location could be
  ``getting_started/step_by_step/nodes_and_scenes.rst`` for the
  page :ref:`doc_nodes_and_scenes`.
- The class reference's translation template is generated from the source XML
  files in **alphabetical order**, which is also the same as the order of the
  table of contents for the online version. You can therefore locate the source
  string corresponding to the brief description of a given class to find the
  first string to translate and all other descriptions from that class should be
  in the subsequent strings on Weblate. For example, the descriptions for the
  :ref:`class_Node2D` class would have the source string location
  ``doc/classes/Node2D.xml``.

A handy tool to locate specific pages/classes is to use Weblate's advanced
search feature, and especially the "Location strings" query (which can also be
used with the ``location:`` token, e.g. ``location:nodes_and_scenes.rst``):

.. image:: img/l10n_05_search_location.png

.. image:: img/l10n_06_browse_by_location.png

.. note::

    When a given source string is used in multiple source locations, they will
    all be concatenated into one. For example, the above
    ``location:nodes_and_scenes.rst`` query would land first on the
    "Introduction" source string which is used in dozens of pages, including
    some that come before ``nodes_and_scenes.rst`` in the template. Clicking the
    "Next" button then brings us to the "Scene and nodes" title string displayed
    above.
    So it may happen that a given paragraph or section title is not at the
    location you'd expect it when reading the online version of a page.

Respecting the markup syntax
----------------------------

Each translation resource originates from a different source code format, and
having some notions on the markup language used for each resource is important
to avoid creating syntax errors in your translations.

Editor interface (C++)
^^^^^^^^^^^^^^^^^^^^^^

The editor translations originate from C++ strings, and may use:

- **C format specifiers** such as ``%s`` (a string) or ``%d`` (a number). These
  specifiers are replaced by content at runtime, and should be preserved and
  placed in your translation where necessary for it to be meaningful after
  substitution. You may need to refer to the source string location to
  understand what kind of content will be substituted if it's not clear from the
  sentence. Example (``%s``  will be substituted with a file name or path)::

    # PO file:
    "There is no '%s' file."

    # Weblate:
    There is no '%s' file.

- **C escape characters** such as ``\n`` (line break) or ``\t`` (tabulation). In
  the Weblate editor, the ``\n`` characters are replaced by ``↵`` (return) and
  ``\t`` by ``↹``. Tabs are not used much, but you should make sure to use line
  breaks in the same way as the original English string (Weblate will issue a
  warning if you don't). Line breaks might sometimes be used for vertical
  spacing, or manual wrapping of long lines which would otherwise be too long
  especially in the editor translation). Example::

    # PO file:
    "Scene '%s' is currently being edited.\n"
    "Changes will only take effect when reloaded."

    # Weblate:
    Scene '%s' is currently being edited.↵
    Changes will only take effect when reloaded.

.. note::
  Only logical order of the characters matters, in the right-to-left text, format
  specifiers may be displayed as ``s%``.

Online documentation (RST)
^^^^^^^^^^^^^^^^^^^^^^^^^^

The documentation translations originate from reStructuredText (RST) files,
which also use their own markup syntax to style text, create internal and
external links, etc. Here are some examples::

    # "development" is styled bold.
    # "Have a look here" is a link pointing to https://docs.godotengine.org/en/latest.
    # You should translate "Have a look here", but not the URL, unless there is
    # a matching URL for the same content in your language.
    # Note: The `, <, >, and _ characters all have a meaning in the hyperlink
    # syntax and should be preserved.

    Looking for the documentation of the current **development** branch?
    `Have a look here <https://docs.godotengine.org/en/latest>`_.

    # "|supported|" is an inline reference to an image and should stay unchanged.
    # "master" uses the markup for inline code, and will be styled as such.
    # Note: Inline code in RST uses 2 backticks on each side, unlike Markdown.
    # Single backticks are used for hyperlinks.

    |supported| Backwards-compatible new features (backported from the ``master``
    branch) as well as bug, security, and platform support fixes.

    # The :ref: Sphinx "role" is used for internal references to other pages of
    # the documentation.
    # It can be used with only the reference name of a page (which should not be
    # changed), in which case the title of that page will be displayed:

    See :ref:`doc_ways_to_contribute`.

    # Or it can be used with an optional custom title, which should thus be translated:

    See :ref:`how to contribute <doc_ways_to_contribute>`.

    # You may encounter other Sphinx roles, such as :kbd: used for shortcut keys.
    # You can translate the content between backticks to match the usual key names,
    # if it's different from the English one.

    Save the scene. Click Scene -> Save, or press :kbd:`Ctrl + S` on Windows/Linux
    or :kbd:`Cmd + S` on macOS.

.. seealso::

    See Sphinx's `reStructured Text primer <https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html>`__
    for a quick overview of the markup language you may find in source strings.
    You may encounter especially the inline markup (bold, italics, inline code)
    and the internal and external hyperlink markup.

Class reference (BBCode)
^^^^^^^^^^^^^^^^^^^^^^^^

The class reference is documented in the main Godot repository using XML files,
and with BBCode-like markup for styling and internal references.

Some of the tags used are from the original BBCode (e.g. ``[b]Bold[/b]`` and
``[i]Italics[/i]``), while others are Godot-specific and used for advanced
features such as inline code (e.g. ``[code]true[/code]``), linking to another
class (e.g. ``[Node2D]``) or to a property in a given class (e.g.
``[member Node2D.position]``), or for multiline code blocks. Example::

    Returns a color according to the standardized [code]name[/code] with [code]alpha[/code] ranging from 0 to 1.
    [codeblock]
    red = ColorN("red", 1)
    [/codeblock]
    Supported color names are the same as the constants defined in [Color].

In the above example, ``[code]name[/code]``, ``[code]alpha[/code]``, and
``[Color]`` should *not* be translated, as they refer respectively to argument
names and a class of the Godot API. Similarly, the contents of the
``[codeblock]`` should not be translated, as ``ColorN`` is a function of the
Godot API and ``"red"`` is one of the named colors it supports. At most, you can
translate the name of the variable which holds the result (``red = ...``).

Note also that in the XML, each line is a paragraph, so you should not add line
breaks if they are not part of the original translation.

.. seealso::

    See our documentation for class reference writers for the :ref:`list of
    BBCode-like tags <doc_class_reference_writing_guidelines_bbcode>` which are used
    throughout the class reference.

Offline translation and testing
-------------------------------

While we advise using the Weblate interface to write translations, you also have
the possibility to download the PO file locally to translate it with your
preferred PO editing application, such as `Poedit <https://poedit.net/>`__ or
`Lokalize <https://userbase.kde.org/Lokalize>`__.

To download the PO file locally, browse to the translation overview for your
language, and select the first item in the "Files" menu:

.. image:: img/l10n_07_download_po_file.png

Once you are done with a series of edits, use the "Upload translation" item in
that same menu and select your file. Choose "Add as translation" for the file
upload mode.

.. note::

    If a significant amount of time has passed between your download of the PO
    file and the upload of the edited version, there is a risk to overwrite the
    translations authored by other contributors in the meantime. This is why we
    advise to use the online interface so that you always work on the latest
    version.

If you want to test changes locally (especially for the editor translation), you
can use the downloaded PO file and :ref:`compile Godot from source <toc-devel-compiling>`.

Rename the editor translation PO file to ``<lang>.po`` (e.g. ``eo.po`` for
Esperanto) and place it in the ``editor/translations/`` folder
(`GitHub <https://github.com/godotengine/godot/tree/master/editor/translations>`__).

You can also test class reference changes the same way by renaming the PO file
similarly and placing it in the ``doc/translations/`` folder
(`GitHub <https://github.com/godotengine/godot/tree/master/doc/translations>`__).

Localizing documentation images
-------------------------------

The online documentation includes many images, which can be screenshots of the
Godot editor, custom-made graphs, of any other kind of visual content. Some of
it includes text and might thus be relevant to localize in your language.

This part is not handled via Weblate, but directly on the `godot-docs-l10n
<https://github.com/godotengine/godot-docs-l10n>`_ Git repository where the
documentation translations are synced from Weblate.

.. note::

   The workflow is not the most straightforward and requires some knowledge of
   Git. We plan to work on a simplified Web tool which could be used to manage
   image localization in a convenient way, abstracting away these steps.

To translate an image, you should first locate it in the original English
documentation. To do so, browse the relevant page in the docs, e.g.
:ref:`doc_intro_to_the_editor_interface`. Click the "Edit on GitHub" link in the
top right corner:

.. image:: img/l10n_08_edit_on_github.png

On GitHub, click on the image you want to translate. If relevant, click on
"Download" to download it locally and edit it with an image edition tool.
Note the full path to the image as it will be needed further down (here
``getting_started/step_by_step/img/project_manager_first_open.png``).

.. image:: img/l10n_09_path_to_image.png

Create your localized version of the image, either by editing the English one,
or by taking a screenshot of the editor with your language, if it's an editor
screenshot. Some images may also have source files available in SVG format, so
you can browse the ``img/`` folder which contains them to check for that.

Name your localized image like the original one, but with the language code
added before the extension, e.g. ``project_manager_first_open.png`` would become
``project_manager_first_open.fr.png`` for the French localization.

Finally, on godot-docs-l10n_, recreate the same folder structure as for the
original image in the ``images`` subfolder
(`GitHub <https://github.com/godotengine/godot-docs-l10n/tree/master/images>`_),
and place your translated image there. In our example, the end result should be
``images/getting_started/step_by_step/img/project_manager_first_open.fr.png``.

Repeat this for other images and :ref:`make a Pull Request <doc_pr_workflow>`.


===================================================
/. ./community/asset_library/index.rst
===================================================

Asset Library
=============

.. toctree::
   :maxdepth: 1
   :name: toc-learn-features-assetlib

   what_is_assetlib
   using_assetlib
   submitting_to_assetlib


===================================================
/. ./community/asset_library/what_is_assetlib.rst
===================================================

.. _doc_what_is_assetlib:

About the Asset Library
=======================

The Godot Asset Library, otherwise known as the AssetLib, is a repository of
user-submitted Godot addons, scripts, tools, and other resources, collectively referred
to as assets. They're available to all Godot users for download directly from within the
engine, but it can also be accessed at Godot's `official website <https://godotengine.org/asset-library/asset>`_.

On the surface, the Asset Library might look and function similar to asset
stores available for other engines, such as Unity's Asset Store, or Unreal
Engine's Marketplace, where you can submit both freely-available assets, as well
as paid, commercial ones. In addition, often times such assets are distributed
under non-free, proprietary licenses, limiting what you can do with them.

The Asset Library is different - all assets are distributed free of charge, and under
a host of open-source licenses (such as the MIT license, the GPL, and the Boost Software License).
This makes the AssetLib more similar to the software repositories of a Linux distribution.

This set of pages will cover how to use the AssetLib (both from inside Godot, and on the
website), how you can submit your own assets, and what the guidelines for submission are.

Please note that the AssetLib is relatively young - it may have various pain points, bugs,
and usability issues. As with all Godot projects, the code repository is available on `GitHub <https://github.com/godotengine/godot-asset-library>`_,
where you can submit pull requests and issues, so please do not hesitate to visit it!

Types of assets
---------------

Be aware that there are, broadly, two different types of assets you can post.

* Assets labeled as "Templates", "Projects", or "Demos" appear under
  the "Templates" tab in the Godot project manager. These assets are
  standalone Godot projects that can run by themselves.

* Other assets show up inside of the Godot editor under the "AssetLib"
  main screen tab, next to "2D", "3D", and "Script". These assets are
  meant to be downloaded and placed into an existing Godot project.

Frequently asked questions
--------------------------

Can paid assets be uploaded to the asset library?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Not to the official one, though in the future, there might be other asset
libraries which allow it.
That said, you are allowed to monetize and sell Godot assets outside the
Asset Library.


===================================================
/. ./community/asset_library/using_assetlib.rst
===================================================

.. _doc_using_assetlib:

Using the Asset Library
=======================

On the website
--------------

Overview
~~~~~~~~

As mentioned before, you can access the web frontend of the Asset Library on
`Godot's official website <https://godotengine.org/asset-library/asset>`_.
This is what it looks like when you first visit it:

|image0|

At the top, you see the **header**, which takes you to various other parts of the
AssetLib - at the moment, it's empty, as we are not logged in.

Searching
~~~~~~~~~

In the center is the **search bar + settings** section, and the **assets** section
below it - this lets you filter out certain kinds of assets based on a host
of criteria. These include the asset **category** (such as 2D tools, scripts
and demos), **engine version** they are intended for, **sorting order** (by
update date, by name, etc.) and **support level**.

While most other filter settings should be fairly self-explanatory, it's worth
going over what "support level" means in the Asset Library.
Currently there are three support levels, and each asset can belong to only one.

**Official** assets are created and maintained by the official Godot Engine
developers. Currently, these include the official engine demos, which showcase
how various areas of the engine work.

**Community** assets are submitted and maintained by the members of the
Godot community.

**Testing** assets are works-in-progress, and may contain bugs and usability
issues. They are not recommended for use in serious projects, but you are
encouraged to download, test them, and submit issues to the original authors.

You can mix and match any of the search filters and criteria, and upon clicking
the Search button, receive the list of all assets in the Library that match them.

|image1|

Note that the search results are not updated in real-time, so you will have to
re-submit the search query each time you change the query settings.

Breakdown of an asset
~~~~~~~~~~~~~~~~~~~~~

Now let's take a look at what an asset's page looks like and what it contains.

|image2|

1. Asset's thumbnail/icon.
2. Asset's name.
3. Current version number of the asset.
4. Asset's category, Godot version, and support status.
5. Asset's original author/submitter.
6. The license the asset is distributed under.
7. The date of the asset's latest edit/update.
8. A textual description of the asset.
9. Links related to the asset (download link, file list, issue tracker).
10. Images and videos showcasing the asset.

Registering and logging in
~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to upload assets to the AssetLib, you need to be logged in, and to do
that, you need a registered user account. In the future, this may also give you
access to other features, such as commenting on or rating the existing assets.
You do *not* need to be logged in to browse and download the assets.

The login/registration page can be accessed from the AssetLib header.

|image3|

From here, you can register your account, which requires a valid email address,
a username, and a (preferably strong) password.

|image4|

Then, you can use your username and password to log in.

|image5|

This will change the look of the AssetLib header. Now you get access to a handful of
new functions:

- The feed, which shows a list of status updates on your submitted assets (and possibly more in the future).
- A list of your uploaded assets.
- The ability to submit new assets.

|image6|

You can learn how to submit assets to the Library, and what the asset submission
guidelines are, in the next part of this tutorial, :ref:`doc_submitting_to_assetlib`.

.. _doc_using_assetlib_editor:

In the editor
-------------

.. note::

    The editor will display different categories of assets depending on whether
    you're browsing the project manager's **Templates** tab or the editor's
    **AssetLib** tab.

    The project manager's **Templates** tab will only display assets that are
    standalone projects by themselves. This is denoted on the asset library with
    the *Templates*, *Demos* and *Projects* categories.

    The editor's **AssetLib** tab will only display assets that are *not* standalone
    projects by themselves. In other words, it will display assets from all
    categories except *Templates*, *Demos* and *Projects*.

You can also access the AssetLib directly from Godot:

|image7|

|image14|

Click on it, and Godot will fetch info about the assets from the AssetLib. Once
it's finished, you will see a window similar to what the AssetLib website looks
like, with some differences:

|image8|

Similarly to the web version of the AssetLib, here you can search
for assets by category, name, and sort them by factors such as name or edit date.

Notably, you can only fetch assets for the current version of Godot you are running.
Projects, Demos and Templates can be downloaded from the Project Manager
view of the AssetLib. Addons (tools, scripts, materials etc.) can be downloaded from
the in-project AssetLib and added to the current project.
In addition, unlike when using the web frontend, the search results are updated
in real-time (you do not have to press Search after every change to your search
query for the changes to take place).

In the future, you will be able to choose a different AssetLib provider to fetch
assets from (using the Site dropdown menu), however currently only the official
`Godot website <https://godotengine.org>`_ version of the AssetLib is supported,
as well as the version that may be running on your local machine's web server
(the localhost option).

When you click on an asset, you will see more information about it.

|image9|

If you click on the Install button, Godot will fetch an archive of the asset,
and will track download progress of it at the bottom of the editor window. If
the download fails, you can retry it using the Retry button.

|image10|

When it finishes, you can proceed to install it using the Install button.
This will bring up the Package Installer window.

|image11|

Here you can see a list of all the files that will be installed. You can tick off
any of the files that you do not wish to install, and Godot will also inform you
about any problems with files that it cannot install. These files will be shown
in red, and hovering over them will show you a message stating why it cannot be
installed.

|image12|

Once you are done, you can press the Install button, which will unzip all the
files in the archive, and import any assets contained therein, such as images or
3D models. Once this is done, you should see a message stating that the Package
installation is complete.

|image13|

You may also use the Import button to import asset archives obtained
elsewhere (such as downloading them directly from the AssetLib web frontend),
which will take you through the same package installation procedure as with the
assets downloaded directly via Godot that we just covered.

.. |image0| image:: img/assetlib_website.png
.. |image1| image:: img/assetlib_search.png
.. |image2| image:: img/assetlib_asset.png
.. |image3| image:: img/assetlib_register-login.png
.. |image4| image:: img/assetlib_register.png
.. |image5| image:: img/assetlib_login.png
.. |image6| image:: img/assetlib_login_header.png
.. |image7| image:: img/assetlib_editor_workspace.png
.. |image8| image:: img/assetlib_editor.png
.. |image9| image:: img/assetlib_editor_asset.png
.. |image10| image:: img/assetlib_editor_download.png
.. |image11| image:: img/assetlib_editor_installer.png
.. |image12| image:: img/assetlib_editor_installer_error.png
.. |image13| image:: img/assetlib_editor_installer_success.png
.. |image14| image:: img/assetlib_editor_projects.png


===================================================
/. ./community/asset_library/submitting_to_assetlib.rst
===================================================

.. _doc_submitting_to_assetlib:

Submitting to the Asset Library
===============================

Introduction
------------

This tutorial aims to serve as a guide on how you can submit your own assets
to the `Godot Asset Library <https://godotengine.org/asset-library/asset>`_
and share them with the Godot community.

As mentioned in the :ref:`doc_using_assetlib` document, in order to be able to
submit assets to the AssetLib, you need to have a registered account, and be
logged in.

Submission guidelines
---------------------

Before submitting your asset, please ensure it follows all of the
requirements, and also consider following the recommendations.

Requirements
~~~~~~~~~~~~

Generally speaking, most assets people submit to the asset library
are accepted. However, in order for your asset to be accepted, there
are a few requirements your asset needs to meet to be approved.

* The asset must **work**. If the asset doesn't run or otherwise doesn't
  work in the specified Godot version, then it will be rejected.

* The asset must have a proper **.gitignore** file. It's important to
  keep redundant data out of the repository.
  `Here's a template. <https://raw.githubusercontent.com/aaronfranke/gitignore/godot/Godot.gitignore>`_

* No **submodules**, or any submodules must be non-essential. GitHub
  does not include submodules in the downloaded ZIP file, so if the
  asset needs the contents of the submodule, your asset won't work.

* The **license** needs to be correct. The license listed on the asset
  library must match the license in the repository. The repo MUST
  have a license file, called either "LICENSE" or "LICENSE.md".
  This file must contain the license text itself and a copyright
  statement that includes the year(s) and copyright holder.

* Use proper **English** for the name and description of your asset.
  This includes using correct capitalization, and using full
  sentences in the description. You can also include other languages,
  but there should at least be an English version.

* The icon link must be a **direct link**. For icons hosted on GitHub, the
  link must start with "raw.githubusercontent.com", not "github.com".

Recommendations
~~~~~~~~~~~~~~~

These things are not required for your asset to be approved, but
if you follow these recommendations, you can help make the asset
library a better place for all users.

* Fix or suppress all script **warnings**. The warning system is there to
  help identify issues with your code, but people using your asset
  don't need to see them.

* Make your code conform to the official **style guides**. Having a
  consistent style helps other people read your code, and it also helps
  if other people wish to contribute to your asset. See: the
  :ref:`doc_gdscript_styleguide` or the :ref:`doc_c_sharp_styleguide`.

* If you have screenshots in your repo, place them in their own subfolder
  and add an empty **.gdignore** file in the same folder (note: **gd**, not **git**).
  This prevents Godot from importing your screenshots.
  On Windows, open a command prompt in the project folder and run
  ``type nul > .gdignore`` to create a file whose name starts with a period.

* If your asset is a library for working with other files,
  consider including **example files** in the asset.

* Consider adding a **.gitattributes** file to your repo. This file allows
  giving extra instructions to Git, such as specifying line endings and listing
  files not required for your asset to function with the ``export-ignore``
  directive. This directive removes such files from the resulting ZIP file,
  preventing them from being downloaded by the asset library users.
  These are common examples of **.gitattributes**:

  .. tabs::

   .. tab:: Projects / Templates

      .. code-block:: shell

        # Normalize line endings for all files that Git considers text files.
        * text=auto eol=lf

   .. tab:: Addons / Asset Packs

      .. code-block:: shell

        # Normalize line endings for all files that Git considers text files.
        * text=auto eol=lf

        # Only include the addons folder when downloading from the Asset Library.
        /**        export-ignore
        /addons    !export-ignore
        /addons/** !export-ignore

* If you are submitting a plugin, add a **copy** of your license and readme
  to the plugin folder itself. This is the folder that users are guaranteed to
  keep with their project, so a copy ensures they always have those files handy
  (and helps them fulfill your licensing terms).

* The **icon** should be a square, its aspect ratio should be 1:1. It should
  also ideally have a minimum resolution of 64x64 pixels.

* While the asset library allows more than just GitHub, consider
  hosting your asset's source code on **GitHub**. Other services may not
  work reliably, and a lack of familiarity can be a barrier to contributors.

Submitting
----------

Once you are logged in, you will be able to head over to the "Submit Assets" page
of the AssetLib, which will look like this:

|image0|

While it may look like a lot (and there is more as you scroll down), each field is
described in terms of what you should put in. We will nonetheless go over what
is required in the submission form here as well.

* **Asset Name**:
    The name of your asset. Should be a unique, descriptive title of
    what your asset is.
* **Category**:
    The category that your asset belongs to, and will be shown in
    search results. The category is split into **Addons** and **Projects**.
    In-editor, assets of the Project type (Templates, Demos, Projects) only show
    up when viewing the AssetLib from the Project Manager, while assets of the
    Addon type will only be visible from inside a project.
* **Godot version**:
    The version of the engine that the asset works with.
    Currently, it's not possible to have a single asset entry contain downloads for
    multiple engine versions, so you may need to re-submit the asset multiple times,
    with an entry for each Godot version it supports. This is particularly important
    when dealing with major versions of the engine, such as Godot 2.x and Godot 3.x.
* **Version**:
    The version number of the asset. While you are free to choose
    and use any versioning scheme that you like, you may want to look into
    something such as `SemVer <https://semver.org>`_ if you want your asset's
    versioning scheme to be clear and consistent. Note that there is also an
    internal version number, incremented every time the asset download URL is
    changed or updated.
* **Repository host**:
    Assets uploaded to the AssetLib are not hosted on it
    directly. Instead, they point to repositories hosted on third-party Git providers,
    such as GitHub, GitLab or Bitbucket. This is where you choose which provider
    your asset uses, so the site can compute the final download link.
* **Repository URL**:
    The URL to your asset's files/webpage. This will vary
    based on your choice of provider, but it should look similar to `https://github.com/<user>/<project>`.
* **Issues URL**:
    The URL to your asset's issue tracker. Again, this will differ
    from repository host to repository host, but will likely look similar to
    `https://github.com/<user>/<project>/issues`. You may leave this field empty
    if you use your provider's issue tracker, and it's part of the same repository.
* **Download Commit**:
    The commit of the asset. For example,
    `b1d3172f89b86e52465a74f63a74ac84c491d3e1`. The site computes
    the actual download URL from this.
* **Icon URL**:
    The URL to your asset's icon (which will be used as a thumbnail
    in the AssetLib search results and on the asset's page). Should be an image
    in either the PNG or JPG format.
* **License**:
    The license under which you are distributing the asset. The list
    includes a variety of free and open-source software licenses, such as GPL
    (v2 and v3), MIT, BSD and Boost Software License. You can visit `OpenSource.org <https://opensource.org>`_
    for a detailed description of each of the listed licenses.
* **Description**:
    Finally, you can use the Description field for a textual
    overview of your asset, its features and behavior, a changelog, et cetera. In the
    future, formatting with Markdown will be supported, but currently, your only
    option is plain text.

You may also include up to three video and/or image previews, which will be shown
at the bottom of the asset page. Use the "Enable" checkbox on each of the preview
submission boxes to enable them.

* **Type**:
    Either an image, or a video.
* **Image/YouTube URL**:
    Either a link to the image, or to a video, hosted on YouTube.
* **Thumbnail URL**:
    A URL to an image that will be used as a thumbnail for the
    preview. This option will be removed eventually, and thumbnails will be automatically
    computed instead.

Once you are done, press "Submit". Your asset will be entered into the review queue.
You can check all assets currently pending a review `here <https://godotengine.org/asset-library/asset/edit?&asset=-1>`_ .
The approval process is manual and may take up to a few days for your asset to be accepted (or rejected), so please
be patient!

.. note::

    You may have some luck accelerating the approval process by messaging the
    moderators and AssetLib reviewers on the `Godot Contributors Chat <https://chat.godotengine.org/>`_,
    or the official Discord server.

You will be informed when your asset is reviewed. If it was rejected,
you will be told why that may have been, and you will be able to submit it again
with the appropriate changes.

.. |image0| image:: img/assetlib_submit.png


===================================================
/. ./community/channels.rst
===================================================

.. _doc_community_channels:

Community channels
==================

So, where is the Godot community and where can you ask questions and get help?

Note that some of these channels are run and moderated by members of the Godot community or third parties.

A brief overview over these and other channels is also available on the `Godot website <https://godotengine.org/community>`_.

Q&A
---

- `Official Godot Questions & Answers <https://godotengine.org/qa/>`_

Rocket.Chat
-----------

- `Godot Contributors Chat <https://chat.godotengine.org/>`_

IRC on Libera.Chat
------------------

.. note::

    As of January 2021, core developer chat has moved to the Godot Contributors Chat platform listed above.

- `General: #godotengine <https://web.libera.chat/?channels=#godotengine>`_

IRC is less active than Discord. Please stick around to get an answer, as
it may take several hours for someone to see and answer your questions.

Other chats
-----------

- `Discord <https://discord.gg/4JBkykG>`_
- `Matrix (IRC compatible) <https://matrix.to/#/#godotengine:matrix.org>`_

Language-based communities
--------------------------

See the `User groups <https://godotengine.org/community/user-groups>`_ page of
the website for a list of local communities.

Social networks
---------------

- `GitHub <https://github.com/godotengine/>`_
- `Facebook group <https://www.facebook.com/groups/godotengine/>`_
- `Twitter <https://twitter.com/godotengine>`_
  (see also the `#GodotEngine <https://twitter.com/hashtag/GodotEngine>`_ hashtag)
- `Reddit <https://www.reddit.com/r/godot>`_
- `YouTube <https://www.youtube.com/c/GodotEngineOfficial>`_
- `Steam <https://steamcommunity.com/app/404790>`_

Forum
-----

- `Godot Forums <https://godotforums.org/>`_


===================================================
/. ./community/tutorials.rst
===================================================

.. _doc_community_tutorials:

Tutorials and resources
=======================

This is a list of third-party tutorials and resources created by the Godot community. For resources, remember that there is the official `Godot Asset Library <https://godotengine.org/asset-library/asset>`_ full of official and community resources too! Also, have a look at this `huge list over at Reddit <https://www.reddit.com/r/godot/comments/an0iq5/godot_tutorials_list_of_video_and_written/>`_.

Think there is something missing here? Feel free to submit a `Pull Request <https://github.com/godotengine/godot-docs/blob/master/community/tutorials.rst>`_ as always.

Where to start
--------------

The Godot video tutorials by `GDQuest <https://www.youtube.com/channel/UCxboW7x0jZqFdvMdCFKTMsQ/playlists>`_, `Game from Scratch <https://www.youtube.com/watch?v=iDEcP8Mc-7s&list=PLS9MbmO_ssyDk79j9ewONxV88fD5e_o5d>`_ and `KidsCanCode <https://www.youtube.com/channel/UCNaPQ5uLX5iIEHUCLmfAgKg/playlists>`_ are well-regarded in the community and often recommended as a gentle introduction to beginners.

If you're interested in Visual Scripting, `Emilio's tutorials <https://www.youtube.com/channel/UC9DR22-qohBDtZ74R3FxOZg>`_ may be worth a look.

If you're interested in a complete introduction to programming using Godot and GDScript, the unofficial `Godot Tutorials <https://www.youtube.com/channel/UCnr9ojBEQGgwbcKsZC-2rIg>`_ YouTube channel is a good place to start.

GDQuest's *Learn GDScript From Zero* is a free and open source interactive tutorial for absolute beginners to learn to program with Godot's GDScript language. It is available as a `desktop application <https://gdquest.itch.io/learn-godot-gdscript>`_  or `in the browser <https://gdquest.github.io/learn-gdscript>`_.

Some tutorials mentioned below provide more advanced tutorials, e.g. on 3D or shaders.

Video tutorials
---------------

- `Godot Tutorials <https://www.youtube.com/channel/UCnr9ojBEQGgwbcKsZC-2rIg>`_ (2D, GDScript, Programming Basics).
- `Emilio <https://www.youtube.com/channel/UC9DR22-qohBDtZ74R3FxOZg>`_ (2D, GDScript and VisualScript).
- `FinePointCGI <https://www.youtube.com/channel/UCSojAWUnEUTUcdA9iJ6bryQ>`_ (2D, 3D, GDScript and C#).
- `GDQuest <https://www.youtube.com/channel/UCxboW7x0jZqFdvMdCFKTMsQ/playlists>`_ (2D and 3D, GDScript, VisualScript and C#).
- `Game Development Center <https://www.youtube.com/c/GameDevelopmentCenter>`_ (2D, networked multiplayer, GDScript).
- `Game Endeavor <https://www.youtube.com/channel/UCLweX1UtQjRjj7rs_0XQ2Eg/videos>`_ (2D, GDScript).
- `Game from Scratch <https://www.youtube.com/watch?v=iDEcP8Mc-7s&list=PLS9MbmO_ssyDk79j9ewONxV88fD5e_o5d>`_ (2D and 3D, GDScript and C#).
- `HeartBeast <https://www.youtube.com/watch?v=wETY5_9kFtA&list=PL9FzW-m48fn2jlBu_0DRh7PvAt-GULEmd>`_ (2D, GDScript).
- `KidsCanCode <https://www.youtube.com/channel/UCNaPQ5uLX5iIEHUCLmfAgKg/playlists>`__ (2D and 3D, GDScript and VisualScript).
- `Mister Taft Creates <https://www.youtube.com/playlist?list=PL4vbr3u7UKWqwQlvwvgNcgDL1p_3hcNn2>`_ (2D, GDScript).
- `Miziziziz <https://www.youtube.com/playlist?list=PLmugv6_kd0qN6AyjG245_Pdak4MXKUx88>`_ (2D and 3D, GDScript).
- `P1X / Krzysztof Jankowski <https://www.youtube.com/playlist?list=PLvDk7UKhld4xGPovdB4IFtAHYMYjx_-3K>`_ (3D).
- `Pigdev <https://www.youtube.com/playlist?list=PLPMN4vCRFdordS3E-3zi0Hdh7pAsbWQ6a>`_ (2D, GDScript).
- `Steincodes <https://www.youtube.com/c/steincodes/playlists>`__ (2D, GDScript and VisualScript).
- `TheBuffED <https://www.youtube.com/watch?v=ygGaN1EOQEA&list=PLvN5Z3tTxXEDfQkt4Frg6ALirespSwZd7>`_ (2D, GDScript).
- `Code with Tom <https://www.youtube.com/playlist?list=PLiUQR4U_J9ec0k91iHPme_qtfS1nrWF3W>`_ (2D and 3D, GDScript).
- `BornCG <https://www.youtube.com/playlist?list=PLda3VoSoc_TSBBOBYwcmlamF1UrjVtccZ>`_ (2D and 3D, GDScript).
- `Gonkee <https://www.youtube.com/channel/UCJqCPFHdbc6443G3Sz6VYDw>`_ (2D and 3D, GDScript, Shaders).
- `TheGuideKnight <https://www.youtube.com/playlist?list=PLYcTJBw32KtX2fvOdtO_fS3Nd6sxM71tn>`_ (2D, GDScript).
- `GDScript Dude <https://www.youtube.com/channel/UCQs0i6vKISElM6mh7OzLouQ>`_ (GDScript).
- `Garbaj <https://www.youtube.com/c/Garbaj/>`_ (3D, GDScript).
- `Kasper Frandsen <https://www.youtube.com/c/KasperFrandsen/>`_ (3D, Shaders).

Text tutorials
--------------

- `FinepointCGI website by Mitch <http://finepointcgi.io/>`__
- `GDScript website by Andrew Wilkes <https://gdscript.com>`__
- `Godot Recipes by KidsCanCode <http://godotrecipes.com/>`__
- `Steincodes <https://steincodes.tumblr.com>`__

Devlogs
-------

- `Andrea Catania (Physics & AI) <https://www.youtube.com/channel/UCm4RuvYtgpgFDTCgaEUT5uQ/videos>`_
- `Bastiaan Olij (AR & VR) <https://www.youtube.com/channel/UCrbLJYzJjDf2p-vJC011lYw/videos>`_

Resources
---------

- `awesome-godot: A curated list of free/libre plugins, scripts and add-ons <https://github.com/godotengine/awesome-godot>`_
- `Zeef Godot Engine: A curated directory of resources by Andre Schmitz <https://godot-engine.zeef.com/andre.antonio.schmitz>`_



===================================================
/. ./classes/index.rst
===================================================

:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/3.5/doc/tools/make_rst.py.

.. _doc_class_reference:

All classes
===========

Globals
=======

.. toctree::
    :maxdepth: 1
    :name: toc-class-ref-globals

    class_@gdscript
    class_@globalscope

Nodes
=====

.. toctree::
    :maxdepth: 1
    :name: toc-class-ref-nodes

    class_node
    class_acceptdialog
    class_animatedsprite
    class_animatedsprite3d
    class_animationplayer
    class_animationtree
    class_animationtreeplayer
    class_area
    class_area2d
    class_arvranchor
    class_arvrcamera
    class_arvrcontroller
    class_arvrorigin
    class_aspectratiocontainer
    class_audiostreamplayer
    class_audiostreamplayer2d
    class_audiostreamplayer3d
    class_backbuffercopy
    class_bakedlightmap
    class_basebutton
    class_bone2d
    class_boneattachment
    class_boxcontainer
    class_button
    class_camera
    class_camera2d
    class_canvasitem
    class_canvaslayer
    class_canvasmodulate
    class_centercontainer
    class_checkbox
    class_checkbutton
    class_clippedcamera
    class_collisionobject
    class_collisionobject2d
    class_collisionpolygon
    class_collisionpolygon2d
    class_collisionshape
    class_collisionshape2d
    class_colorpicker
    class_colorpickerbutton
    class_colorrect
    class_conetwistjoint
    class_confirmationdialog
    class_container
    class_control
    class_cpuparticles
    class_cpuparticles2d
    class_csgbox
    class_csgcombiner
    class_csgcylinder
    class_csgmesh
    class_csgpolygon
    class_csgprimitive
    class_csgshape
    class_csgsphere
    class_csgtorus
    class_cullinstance
    class_dampedspringjoint2d
    class_directionallight
    class_editorfiledialog
    class_editorfilesystem
    class_editorinspector
    class_editorinterface
    class_editorplugin
    class_editorproperty
    class_editorresourcepicker
    class_editorresourcepreview
    class_editorscriptpicker
    class_editorspinslider
    class_filedialog
    class_filesystemdock
    class_flowcontainer
    class_generic6dofjoint
    class_geometryinstance
    class_giprobe
    class_graphedit
    class_graphnode
    class_gridcontainer
    class_gridmap
    class_groovejoint2d
    class_hboxcontainer
    class_hflowcontainer
    class_hingejoint
    class_hscrollbar
    class_hseparator
    class_hslider
    class_hsplitcontainer
    class_httprequest
    class_immediategeometry
    class_instanceplaceholder
    class_interpolatedcamera
    class_itemlist
    class_joint
    class_joint2d
    class_kinematicbody
    class_kinematicbody2d
    class_label
    class_label3d
    class_light
    class_light2d
    class_lightoccluder2d
    class_line2d
    class_lineedit
    class_linkbutton
    class_listener
    class_listener2d
    class_margincontainer
    class_menubutton
    class_meshinstance
    class_meshinstance2d
    class_multimeshinstance
    class_multimeshinstance2d
    class_navigation
    class_navigation2d
    class_navigationagent
    class_navigationagent2d
    class_navigationmeshinstance
    class_navigationobstacle
    class_navigationobstacle2d
    class_navigationpolygoninstance
    class_ninepatchrect
    class_node2d
    class_occluder
    class_omnilight
    class_optionbutton
    class_panel
    class_panelcontainer
    class_parallaxbackground
    class_parallaxlayer
    class_particles
    class_particles2d
    class_path
    class_path2d
    class_pathfollow
    class_pathfollow2d
    class_physicalbone
    class_physicsbody
    class_physicsbody2d
    class_pinjoint
    class_pinjoint2d
    class_polygon2d
    class_popup
    class_popupdialog
    class_popupmenu
    class_popuppanel
    class_portal
    class_position2d
    class_position3d
    class_progressbar
    class_proximitygroup
    class_range
    class_raycast
    class_raycast2d
    class_referencerect
    class_reflectionprobe
    class_remotetransform
    class_remotetransform2d
    class_resourcepreloader
    class_richtextlabel
    class_rigidbody
    class_rigidbody2d
    class_room
    class_roomgroup
    class_roommanager
    class_rootmotionview
    class_scriptcreatedialog
    class_scripteditor
    class_scrollbar
    class_scrollcontainer
    class_separator
    class_shapecast
    class_shapecast2d
    class_skeleton
    class_skeleton2d
    class_skeletonik
    class_slider
    class_sliderjoint
    class_softbody
    class_spatial
    class_spinbox
    class_splitcontainer
    class_spotlight
    class_springarm
    class_sprite
    class_sprite3d
    class_spritebase3d
    class_staticbody
    class_staticbody2d
    class_tabcontainer
    class_tabs
    class_textedit
    class_texturebutton
    class_textureprogress
    class_texturerect
    class_tilemap
    class_timer
    class_toolbutton
    class_touchscreenbutton
    class_tree
    class_tween
    class_vboxcontainer
    class_vehiclebody
    class_vehiclewheel
    class_vflowcontainer
    class_videoplayer
    class_viewport
    class_viewportcontainer
    class_visibilityenabler
    class_visibilityenabler2d
    class_visibilitynotifier
    class_visibilitynotifier2d
    class_visualinstance
    class_vscrollbar
    class_vseparator
    class_vslider
    class_vsplitcontainer
    class_windowdialog
    class_worldenvironment
    class_ysort

Resources
=========

.. toctree::
    :maxdepth: 1
    :name: toc-class-ref-resources

    class_resource
    class_animatedtexture
    class_animation
    class_animationnode
    class_animationnodeadd2
    class_animationnodeadd3
    class_animationnodeanimation
    class_animationnodeblend2
    class_animationnodeblend3
    class_animationnodeblendspace1d
    class_animationnodeblendspace2d
    class_animationnodeblendtree
    class_animationnodeoneshot
    class_animationnodeoutput
    class_animationnodestatemachine
    class_animationnodestatemachineplayback
    class_animationnodestatemachinetransition
    class_animationnodetimescale
    class_animationnodetimeseek
    class_animationnodetransition
    class_animationrootnode
    class_arraymesh
    class_atlastexture
    class_audiobuslayout
    class_audioeffect
    class_audioeffectamplify
    class_audioeffectbandlimitfilter
    class_audioeffectbandpassfilter
    class_audioeffectcapture
    class_audioeffectchorus
    class_audioeffectcompressor
    class_audioeffectdelay
    class_audioeffectdistortion
    class_audioeffecteq
    class_audioeffecteq10
    class_audioeffecteq21
    class_audioeffecteq6
    class_audioeffectfilter
    class_audioeffecthighpassfilter
    class_audioeffecthighshelffilter
    class_audioeffectlimiter
    class_audioeffectlowpassfilter
    class_audioeffectlowshelffilter
    class_audioeffectnotchfilter
    class_audioeffectpanner
    class_audioeffectphaser
    class_audioeffectpitchshift
    class_audioeffectrecord
    class_audioeffectreverb
    class_audioeffectspectrumanalyzer
    class_audioeffectstereoenhance
    class_audiostream
    class_audiostreamgenerator
    class_audiostreammicrophone
    class_audiostreammp3
    class_audiostreamoggvorbis
    class_audiostreamrandompitch
    class_audiostreamsample
    class_bakedlightmapdata
    class_bitmap
    class_bitmapfont
    class_boxshape
    class_buttongroup
    class_cameratexture
    class_canvasitemmaterial
    class_capsulemesh
    class_capsuleshape
    class_capsuleshape2d
    class_circleshape2d
    class_concavepolygonshape
    class_concavepolygonshape2d
    class_convexpolygonshape
    class_convexpolygonshape2d
    class_cryptokey
    class_csharpscript
    class_cubemap
    class_cubemesh
    class_curve
    class_curve2d
    class_curve3d
    class_curvetexture
    class_cylindermesh
    class_cylindershape
    class_dynamicfont
    class_dynamicfontdata
    class_editorsettings
    class_editorspatialgizmoplugin
    class_environment
    class_externaltexture
    class_font
    class_gdnativelibrary
    class_gdscript
    class_giprobedata
    class_gltfaccessor
    class_gltfanimation
    class_gltfbufferview
    class_gltfcamera
    class_gltfdocument
    class_gltfdocumentextension
    class_gltflight
    class_gltfmesh
    class_gltfnode
    class_gltfskeleton
    class_gltfskin
    class_gltfspecgloss
    class_gltfstate
    class_gltftexture
    class_gltftexturesampler
    class_gradient
    class_gradienttexture
    class_gradienttexture2d
    class_heightmapshape
    class_image
    class_imagetexture
    class_inputevent
    class_inputeventaction
    class_inputeventgesture
    class_inputeventjoypadbutton
    class_inputeventjoypadmotion
    class_inputeventkey
    class_inputeventmagnifygesture
    class_inputeventmidi
    class_inputeventmouse
    class_inputeventmousebutton
    class_inputeventmousemotion
    class_inputeventpangesture
    class_inputeventscreendrag
    class_inputeventscreentouch
    class_inputeventwithmodifiers
    class_largetexture
    class_lineshape2d
    class_material
    class_mesh
    class_meshlibrary
    class_meshtexture
    class_multimesh
    class_nativescript
    class_navigationmesh
    class_navigationpolygon
    class_noisetexture
    class_occluderpolygon2d
    class_occludershape
    class_occludershapepolygon
    class_occludershapesphere
    class_opensimplexnoise
    class_packeddatacontainer
    class_packedscene
    class_packedscenegltf
    class_panoramasky
    class_particlesmaterial
    class_phashtranslation
    class_physicsmaterial
    class_planemesh
    class_planeshape
    class_pluginscript
    class_pointmesh
    class_polygonpathfinder
    class_primitivemesh
    class_prismmesh
    class_proceduralsky
    class_proxytexture
    class_quadmesh
    class_rayshape
    class_rayshape2d
    class_rectangleshape2d
    class_richtexteffect
    class_script
    class_segmentshape2d
    class_shader
    class_shadermaterial
    class_shape
    class_shape2d
    class_shortcut
    class_skin
    class_sky
    class_spatialmaterial
    class_spheremesh
    class_sphereshape
    class_spriteframes
    class_streamtexture
    class_stylebox
    class_styleboxempty
    class_styleboxflat
    class_styleboxline
    class_styleboxtexture
    class_textfile
    class_textmesh
    class_texture
    class_texture3d
    class_texturearray
    class_texturelayered
    class_theme
    class_tileset
    class_torusmesh
    class_translation
    class_videostream
    class_videostreamgdnative
    class_videostreamtheora
    class_videostreamwebm
    class_viewporttexture
    class_visualscript
    class_visualscriptbasictypeconstant
    class_visualscriptbuiltinfunc
    class_visualscriptclassconstant
    class_visualscriptcomment
    class_visualscriptcomposearray
    class_visualscriptcondition
    class_visualscriptconstant
    class_visualscriptconstructor
    class_visualscriptcustomnode
    class_visualscriptdeconstruct
    class_visualscriptemitsignal
    class_visualscriptenginesingleton
    class_visualscriptexpression
    class_visualscriptfunction
    class_visualscriptfunctioncall
    class_visualscriptglobalconstant
    class_visualscriptindexget
    class_visualscriptindexset
    class_visualscriptinputaction
    class_visualscriptiterator
    class_visualscriptlists
    class_visualscriptlocalvar
    class_visualscriptlocalvarset
    class_visualscriptmathconstant
    class_visualscriptnode
    class_visualscriptoperator
    class_visualscriptpreload
    class_visualscriptpropertyget
    class_visualscriptpropertyset
    class_visualscriptresourcepath
    class_visualscriptreturn
    class_visualscriptscenenode
    class_visualscriptscenetree
    class_visualscriptselect
    class_visualscriptself
    class_visualscriptsequence
    class_visualscriptsubcall
    class_visualscriptswitch
    class_visualscripttypecast
    class_visualscriptvariableget
    class_visualscriptvariableset
    class_visualscriptwhile
    class_visualscriptyield
    class_visualscriptyieldsignal
    class_visualshader
    class_visualshadernode
    class_visualshadernodebooleanconstant
    class_visualshadernodebooleanuniform
    class_visualshadernodecolorconstant
    class_visualshadernodecolorfunc
    class_visualshadernodecolorop
    class_visualshadernodecoloruniform
    class_visualshadernodecompare
    class_visualshadernodecubemap
    class_visualshadernodecubemapuniform
    class_visualshadernodecustom
    class_visualshadernodedeterminant
    class_visualshadernodedotproduct
    class_visualshadernodeexpression
    class_visualshadernodefaceforward
    class_visualshadernodefresnel
    class_visualshadernodeglobalexpression
    class_visualshadernodegroupbase
    class_visualshadernodeif
    class_visualshadernodeinput
    class_visualshadernodeis
    class_visualshadernodeouterproduct
    class_visualshadernodeoutput
    class_visualshadernodescalarclamp
    class_visualshadernodescalarconstant
    class_visualshadernodescalarderivativefunc
    class_visualshadernodescalarfunc
    class_visualshadernodescalarinterp
    class_visualshadernodescalarop
    class_visualshadernodescalarsmoothstep
    class_visualshadernodescalarswitch
    class_visualshadernodescalaruniform
    class_visualshadernodeswitch
    class_visualshadernodetexture
    class_visualshadernodetextureuniform
    class_visualshadernodetextureuniformtriplanar
    class_visualshadernodetransformcompose
    class_visualshadernodetransformconstant
    class_visualshadernodetransformdecompose
    class_visualshadernodetransformfunc
    class_visualshadernodetransformmult
    class_visualshadernodetransformuniform
    class_visualshadernodetransformvecmult
    class_visualshadernodeuniform
    class_visualshadernodeuniformref
    class_visualshadernodevec3constant
    class_visualshadernodevec3uniform
    class_visualshadernodevectorclamp
    class_visualshadernodevectorcompose
    class_visualshadernodevectordecompose
    class_visualshadernodevectorderivativefunc
    class_visualshadernodevectordistance
    class_visualshadernodevectorfunc
    class_visualshadernodevectorinterp
    class_visualshadernodevectorlen
    class_visualshadernodevectorop
    class_visualshadernodevectorrefract
    class_visualshadernodevectorscalarmix
    class_visualshadernodevectorscalarsmoothstep
    class_visualshadernodevectorscalarstep
    class_visualshadernodevectorsmoothstep
    class_world
    class_world2d
    class_x509certificate

Other objects
=============

.. toctree::
    :maxdepth: 1
    :name: toc-class-ref-objects

    class_object
    class_aescontext
    class_animationtrackeditplugin
    class_arvrinterface
    class_arvrinterfacegdnative
    class_arvrpositionaltracker
    class_arvrserver
    class_astar
    class_astar2d
    class_audioeffectinstance
    class_audioeffectspectrumanalyzerinstance
    class_audioserver
    class_audiostreamgeneratorplayback
    class_audiostreamplayback
    class_audiostreamplaybackresampled
    class_callbacktweener
    class_camerafeed
    class_cameraserver
    class_charfxtransform
    class_classdb
    class_configfile
    class_crypto
    class_directory
    class_dtlsserver
    class_editorexportplugin
    class_editorfeatureprofile
    class_editorfilesystemdirectory
    class_editorimportplugin
    class_editorinspectorplugin
    class_editorresourceconversionplugin
    class_editorresourcepreviewgenerator
    class_editorsceneimporter
    class_editorsceneimporterfbx
    class_editorsceneimportergltf
    class_editorscenepostimport
    class_editorscript
    class_editorselection
    class_editorspatialgizmo
    class_editorvcsinterface
    class_encodedobjectasid
    class_engine
    class_expression
    class_file
    class_funcref
    class_gdnative
    class_gdscriptfunctionstate
    class_geometry
    class_godotsharp
    class_hashingcontext
    class_hmaccontext
    class_httpclient
    class_input
    class_inputmap
    class_intervaltweener
    class_ip
    class_javaclass
    class_javaclasswrapper
    class_javascript
    class_javascriptobject
    class_jnisingleton
    class_json
    class_jsonparseresult
    class_jsonrpc
    class_kinematiccollision
    class_kinematiccollision2d
    class_mainloop
    class_marshalls
    class_meshdatatool
    class_methodtweener
    class_mobilevrinterface
    class_multiplayerapi
    class_multiplayerpeergdnative
    class_mutex
    class_navigation2dserver
    class_navigationmeshgenerator
    class_navigationserver
    class_networkedmultiplayercustom
    class_networkedmultiplayerenet
    class_networkedmultiplayerpeer
    class_node
    class_os
    class_packeddatacontainerref
    class_packetpeer
    class_packetpeerdtls
    class_packetpeergdnative
    class_packetpeerstream
    class_packetpeerudp
    class_pckpacker
    class_performance
    class_physics2ddirectbodystate
    class_physics2ddirectspacestate
    class_physics2dserver
    class_physics2dshapequeryparameters
    class_physics2dtestmotionresult
    class_physicsdirectbodystate
    class_physicsdirectspacestate
    class_physicsserver
    class_physicsshapequeryparameters
    class_physicstestmotionresult
    class_projectsettings
    class_propertytweener
    class_randomnumbergenerator
    class_reference
    class_regex
    class_regexmatch
    class_resource
    class_resourceformatloader
    class_resourceformatsaver
    class_resourceimporter
    class_resourceinteractiveloader
    class_resourceloader
    class_resourcesaver
    class_scenestate
    class_scenetree
    class_scenetreetimer
    class_scenetreetween
    class_semaphore
    class_skinreference
    class_spatialgizmo
    class_spatialvelocitytracker
    class_streampeer
    class_streampeerbuffer
    class_streampeergdnative
    class_streampeerssl
    class_streampeertcp
    class_surfacetool
    class_tcp_server
    class_thread
    class_time
    class_translationserver
    class_treeitem
    class_trianglemesh
    class_tweener
    class_udpserver
    class_undoredo
    class_upnp
    class_upnpdevice
    class_visualscripteditor
    class_visualscriptfunctionstate
    class_visualserver
    class_weakref
    class_webrtcdatachannel
    class_webrtcdatachannelgdnative
    class_webrtcmultiplayer
    class_webrtcpeerconnection
    class_webrtcpeerconnectiongdnative
    class_websocketclient
    class_websocketmultiplayerpeer
    class_websocketpeer
    class_websocketserver
    class_webxrinterface
    class_xmlparser

Variant types
=============

.. toctree::
    :maxdepth: 1
    :name: toc-class-ref-variants

    class_aabb
    class_array
    class_basis
    class_bool
    class_color
    class_dictionary
    class_float
    class_int
    class_nodepath
    class_object
    class_plane
    class_poolbytearray
    class_poolcolorarray
    class_poolintarray
    class_poolrealarray
    class_poolstringarray
    class_poolvector2array
    class_poolvector3array
    class_quat
    class_rect2
    class_rid
    class_string
    class_transform
    class_transform2d
    class_variant
    class_vector2
    class_vector3

